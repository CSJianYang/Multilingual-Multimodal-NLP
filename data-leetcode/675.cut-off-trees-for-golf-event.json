[
    {
        "title": "Bulb Switcher II",
        "question_content": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where:\n\n\tButton 1: Flips the status of all the bulbs.\n\tButton 2: Flips the status of all the bulbs with even labels (i.e., 2, 4, ...).\n\tButton 3: Flips the status of all the bulbs with odd labels (i.e., 1, 3, ...).\n\tButton 4: Flips the status of all the bulbs with a label j = 3k + 1 where k = 0, 1, 2, ... (i.e., 1, 4, 7, 10, ...).\n\nYou must make exactly presses button presses in total. For each press, you may pick any of the four buttons to press.\nGiven the two integers n and presses, return the number of different possible statuses after performing all presses button presses.\n&nbsp;\nExample 1:\n\nInput: n = 1, presses = 1\nOutput: 2\nExplanation: Status can be:\n- [off] by pressing button 1\n- [on] by pressing button 2\n\nExample 2:\n\nInput: n = 2, presses = 1\nOutput: 3\nExplanation: Status can be:\n- [off, off] by pressing button 1\n- [on, off] by pressing button 2\n- [off, on] by pressing button 3\n\nExample 3:\n\nInput: n = 3, presses = 1\nOutput: 4\nExplanation: Status can be:\n- [off, off, off] by pressing button 1\n- [off, on, off] by pressing button 2\n- [on, off, on] by pressing button 3\n- [off, on, on] by pressing button 4\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000\n\t0 <= presses <= 1000",
        "solutions": [
            {
                "id": 107269,
                "title": "java-o-1",
                "content": "We only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8. \\nThe four buttons:\\n\\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n\\n\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n`1 + 2 --> 3,    1 + 3 --> 2,      2 + 3 --> 1`\\nSo, there are only 8 cases. \\n\\n`All_on`, `1`, `2`, `3`, `4`, `1+4`, `2+4`, `3+4`\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107267,
                "title": "python-straightforward-with-explanation",
                "content": "Suppose we did `f[0]` of the first operation, `f[1]` of the second, `f[2]` of the third, and `f[3]` of the fourth, where `sum(f) == m`.\\n\\nFirst, all these operations commute: doing operation A followed by operation B yields the same result as doing operation B followed by operation A.  Also, doing operation A followed by operation A again is the same as doing nothing.  So really, we only needed to know the residues `cand[i] = f[i] % 2`.  There are only 16 different possibilities for the residues in total, so we can try them all.\\n\\nWe'll loop `cand` through all 16 possibilities `(0, 0, 0, 0), (0, 0, 0, 1), ..., (1, 1, 1, 1)`.  A necessary and sufficient condition for `cand` to be valid is that `sum(cand) % 2 == m % 2 and sum(cand) <= m`, as only when these conditions are satisfied can we find some `f` with `sum(f) == m` and `cand[i] = f[i] % 2`.\\n\\nAlso, as the sequence of lights definitely repeats every 6 lights, we could replace `n` with `min(n, 6)`. Actually, we could replace it with `min(n, 3)`, as those lights are representative: that is, knowing the first 3 lights is enough to reconstruct what the next 3 lights will be.  If the first 3 lights are X, Y, Z, then with a little effort we can prove the next 3 lights will be (X^Y^Z), Z, Y.\\n\\n```python\\ndef flipLights(self, n, m):\\n    seen = set()\\n    for cand in itertools.product((0, 1), repeat = 4):\\n        if sum(cand) % 2 == m % 2 and sum(cand) <= m:\\n            A = []\\n            for i in xrange(min(n, 3)):\\n                light = 1\\n                light ^= cand[0]\\n                light ^= cand[1] and i % 2\\n                light ^= cand[2] and i % 2 == 0\\n                light ^= cand[3] and i % 3 == 0\\n                A.append(light)\\n            seen.add(tuple(A))\\n\\n    return len(seen)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef flipLights(self, n, m):\\n    seen = set()\\n    for cand in itertools.product((0, 1), repeat = 4):\\n        if sum(cand) % 2 == m % 2 and sum(cand) <= m:\\n            A = []\\n            for i in xrange(min(n, 3)):\\n                light = 1\\n                light ^= cand[0]\\n                light ^= cand[1] and i % 2\\n                light ^= cand[2] and i % 2 == 0\\n                light ^= cand[3] and i % 3 == 0\\n                A.append(light)\\n            seen.add(tuple(A))\\n\\n    return len(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 107271,
                "title": "c-concise-code-o-1",
                "content": "When n <= 1, the solution is trial.\\n\\nFrom the 4 types of operations, \\n``` \\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n```\\nThere are three important observations:\\n1) For any operation, only odd or even matters, i.e. 0 or 1. Two same operations equal no operation.\\n2) The first 3 operations can be reduced to 1 or 0 operation. For example, flip all + flip even = flip odd. So the result of the first 3 operations is the same as either 1 operation or original.   \\n3) The solution for n > 3 is the same as n = 3. \\nFor example, 1 0 0 ....., I use 0 and 1 to represent off and on.\\nThe state of 2nd digit indicates even flip; The state of 3rd digit indicates odd flip; And the state difference of 1st and 3rd digits indicates 3k+1 flip.\\n\\nIn summary, the question can be simplified as m <= 3, n <= 3. I am sure you can figure out the rest easily. \\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m == 0 || n == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return m == 1? 3:4;\\n        if (m == 1) return 4;\\n        return m == 2? 7:8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n```\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m == 0 || n == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return m == 1? 3:4;\\n        if (m == 1) return 4;\\n        return m == 2? 7:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107272,
                "title": "short-and-clean-java-o-1-solution",
                "content": "> `1`: light is on\\n> `0`: light is off\\n\\n**n == 1**\\n\\nOnly **2** possibilities: `1` and `0`.\\n\\n**n == 2**\\n\\nAfter one operation, it has only **3** possibilities: `00`, `10` and `01`.\\nAfter two and more operations, it has only **4** possibilities: `11`, `10`, `01` and `00`.\\n\\n**n == 3**\\n\\nAfter one operation, it has only **4** possibilities: `000`, `101`, `010` and `011`.\\nAfter two operations, it has **7** possibilities: `111`,`101`,`010`,`100`,`000`,`001` and `110`.\\nAfter three and more operations, it has **8** possibilities, plus `011` on above case.\\n\\n**n >= 4**\\n\\nAfter one operation, it has only **4** possibilities: `0000`, `1010`, `0101` and `0110`.\\nAfter two or more operations: it has **8** possibilities, `1111`,`1010`,`0101`,`0111`,`0000`,`0011`, `1100` and `1001`.\\n\\n```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (m == 0) return 1;\\n        if (n <= 0 || m < 0) return 0;\\n        \\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else return (m == 1) ? 4 : ((m == 2) ? 7 : 8);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (m == 0) return 1;\\n        if (n <= 0 || m < 0) return 0;\\n        \\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else return (m == 1) ? 4 : ((m == 2) ? 7 : 8);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107270,
                "title": "easy-to-understand-java-bfs-solution-o-m",
                "content": "I see all are math based solutions and it is O(1). \\nHere is my BFS solution to count all potential status for n bulb after m operations.\\n\\n```\\npublic int flipLights(int n, int m) {\\n        n = n <= 6? n: (n % 6 + 6);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        int init = (1 << n) - 1;\\n        queue.offer(init);\\n        for (int i=0; i<m; i++) {\\n            int size = queue.size();\\n            visited.clear();\\n            for (int k=0; k<size; k++) {\\n                int s = queue.poll();\\n                int[] next = new int[] {flipAll(s, n), \\n                     flipEven(s, n), flipOdd(s, n), flip3k1(s, n)};\\n                for (int s1: next) {\\n                    if (!visited.contains(s1)) {\\n                        queue.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                }\\n            }\\n        }\\n        return queue.size();\\n    }\\n    \\n    private int flipAll(int s, int n) {\\n        int x = (1 << n) - 1;\\n        return s ^ x;\\n    }\\n\\n    private int flipEven(int s, int n) {\\n        for (int i=0; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flipOdd(int s, int n) {\\n        for (int i=1; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flip3k1(int s, int n) {\\n        for (int i=0; i<n; i+=3) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n        n = n <= 6? n: (n % 6 + 6);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        int init = (1 << n) - 1;\\n        queue.offer(init);\\n        for (int i=0; i<m; i++) {\\n            int size = queue.size();\\n            visited.clear();\\n            for (int k=0; k<size; k++) {\\n                int s = queue.poll();\\n                int[] next = new int[] {flipAll(s, n), \\n                     flipEven(s, n), flipOdd(s, n), flip3k1(s, n)};\\n                for (int s1: next) {\\n                    if (!visited.contains(s1)) {\\n                        queue.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                }\\n            }\\n        }\\n        return queue.size();\\n    }\\n    \\n    private int flipAll(int s, int n) {\\n        int x = (1 << n) - 1;\\n        return s ^ x;\\n    }\\n\\n    private int flipEven(int s, int n) {\\n        for (int i=0; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flipOdd(int s, int n) {\\n        for (int i=1; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flip3k1(int s, int n) {\\n        for (int i=0; i<n; i+=3) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107278,
                "title": "very-easy-to-understand-c-with-detailed-explanation",
                "content": "At first this problem appears very intimidating.  However, after walking through actual values, it is very simple.  Below is my solution, and a step-by-step analysis for each part of code.  Please feel free to provide comments to add/edit this post in order to provide better understanding for everyone.  Thanks!\\n\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        \\n        if (m==0) return 1;\\n        \\n        if (n==1)\\n            if (m>=1) return 2;\\n\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n        \\n        return 0; // invalid value for n or m\\n    }\\n};\\n```\\n**STEP-BY-STEP ANALYSIS:**\\n\\n**Part 1: Description**\\nThe first value to consider is m=0 operations.  Regardless how many n lightbulbs there are with initial state ON, with 0 operations, all n lightbulbs will remain ON.  Therefore, there is only one state ( all n lightbulbs ON ).\\n\\n**Part 1: Code**\\n```\\nif (m==0) return 1;\\n\\n```\\n\\n**Part 2: Description**\\nNow consider one lightbulb (n=1).  If we perform m=1 operation on that 1 lightbulb, then that 1 operation can be (flip all, flip odd, flip even, or flip 3k+1 [k=0, 3k+1=1]).  The lightbulb\\'s end state after 1 operation from [ flip all, flip odd, or flip 3k+1 ] is OFF.  The end state after 1 operation from [ flip even ] is ON (since there are no even lightbulbs to flip, this single odd lightbulb remains ON).  Therefore, there are 2 states for this 1 lightbulb after 1 operation.  Below is a table summary of this lightbulb and its potential states.  ON=1 and OFF=0.\\n\\n```\\nn=1\\nlightbulb ID       1\\n\\nINIT_STATE:\\n(initially ON)     1\\n\\nm=1\\nOPERATIONS:\\n                   0 ( after 1 operation: flip all, odd, or 3k+1 )\\n                   1 ( after 1 operation: flip even )\\nSTATE_COUNT:\\n                   2 ( 0 or 1 )\\n```\\n\\nNow consider if there are any additional unique states which can be created with this one lightbulb with more than one operation.  There are none.  Either this one lightbulb is ON or OFF after m=1 operations.  Any additional operations revert the lightbulb to a previous state, so there are no additional unique states created by any m>=1 operations.\\n\\n**Part 2: Code**\\n```\\n        if (n==1){\\n            if (m>=1) return 2;\\n        }\\n```\\n\\n**Part 3: Description**\\nNext consider n=2 lightbulbs.  The logic here is again the same as above, so I will skip the complete description and instead directly create an abridged table summary:\\n\\n```\\nn=2\\nlightbulb ID       1 2\\n\\nINIT_STATE:\\n(initially ON)     1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 ( after 1 operation: flip all )\\n                   0 1 ( after 1 operation: flip odd or 3k+1 )\\n                   1 0 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   3 ( 00 or 01 or 10 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 ( after 2 operations: flip odd, flip even )\\n                   0 1 ( after 2 operations: flip all, flip even )\\n                   1 0 ( after 2 operations: flip all, flip odd )\\n                   1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   4 ( 00 or 01 or 10 or 11 )\\n```\\n\\nThere are multiple ways to arrive at the same lightbulb state with m=2 operations, but I did NOT list them all.  This brevity is on purpose in order to help keep my verbose post as short and concise as possible.  There is no need to list them all anyways because we are only interested in the amount of unique states in the end, NOT all the different ways which we arrived at those states.\\n\\nNow consider if there are any additional unique states which can be created with these two lightbulbs with more than two operations.  There are none.  Any additional operation m>=2 reverts these 2 lightbulbs to a previous state.\\n\\n**Part 3: Code**\\n```\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n```\\n\\n**Part 4: Description**\\nNext consider n=3 lightbulbs. The logic here is again the same as above, so I will skip the complete description and instead directly create another abridged table summary:\\n\\n```\\nn=2\\nlightbulb ID       1 2 3\\n\\nINIT_STATE:\\n(initially ON)     1 1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 0 ( after 1 operation: flip all )\\n                   0 1 0 ( after 1 operation: flip odd )\\n                   0 1 1 ( after 1 operation: flip 3k+1 ) \\n                   1 0 1 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   4 ( 000 or 010 or 011 or 101 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 0 ( after 2 operations: flip odd, flip even )\\n                   0 0 1 ( after 2 operations: flip 3k+1, flip even )\\n                   0 1 0 ( after 2 operations: flip even, flip all )\\n                   1 0 0 ( after 2 operations: flip all, flip 3k+1 )\\n                   1 0 1 ( after 2 operations: flip odd, flip all )\\n                   1 1 0 ( after 2 operations: flip odd, flip 3k+1 )\\n                   1 1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   7 ( 000 or 001 or 010 or 100 or 101 or 110 or 111 )\\n\\nm=3\\nOPERATIONS:\\n                   ect...\\n                   ect...\\n                   ect...\\nm=3\\nSTATE_COUNT:\\n                   8 ( 000 or 001 or 010 or 011 or 100 or 101 or 110 or 111 )\\n```\\nAgain, there are multiple ways to arrive at the same lightbulb state with m=2 and m=3 operations, but I did NOT list them all. This brevity is on purpose.  Also, I did NOT explicitly write out all the different permutations for m=3, since they are all redundant states except for 011 which can be created with 3 operations [ flip 3k+1, flip odd, flip odd ].\\n\\nAgain, consider if there are any additional unique states which can be created with these three lightbulbs with more than three operations. There are none. Any additional operation m>=3 reverts these 3 lightbulbs to a previous state.  Also consider if there are more unique states which can be created with more than n=3 lightbulbs.  There are none.  Any additional amount of lightbulbs n>=3 does NOT create a new unique state.  Instead repeated patterns are observed for lightbulbs that are even 2,4,6,etc (i.e. lightbulbs at positions 2(k+1), k=0,1,2... ), lightbulbs that are odd 1,3,5,etc (i.e. lightbulbs at positions 2k+1, k=0,1,2...), and lightbulbs at every 3rd position 1,4,7,10,etc ( i.e. lightbulbs at positions 3k+1, k=0,1,2...).\\n\\n**Part 4: Code**\\n```\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        \\n        if (m==0) return 1;\\n        \\n        if (n==1)\\n            if (m>=1) return 2;\\n\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n        \\n        return 0; // invalid value for n or m\\n    }\\n};\\n```\n```\\nif (m==0) return 1;\\n\\n```\n```\\nn=1\\nlightbulb ID       1\\n\\nINIT_STATE:\\n(initially ON)     1\\n\\nm=1\\nOPERATIONS:\\n                   0 ( after 1 operation: flip all, odd, or 3k+1 )\\n                   1 ( after 1 operation: flip even )\\nSTATE_COUNT:\\n                   2 ( 0 or 1 )\\n```\n```\\n        if (n==1){\\n            if (m>=1) return 2;\\n        }\\n```\n```\\nn=2\\nlightbulb ID       1 2\\n\\nINIT_STATE:\\n(initially ON)     1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 ( after 1 operation: flip all )\\n                   0 1 ( after 1 operation: flip odd or 3k+1 )\\n                   1 0 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   3 ( 00 or 01 or 10 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 ( after 2 operations: flip odd, flip even )\\n                   0 1 ( after 2 operations: flip all, flip even )\\n                   1 0 ( after 2 operations: flip all, flip odd )\\n                   1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   4 ( 00 or 01 or 10 or 11 )\\n```\n```\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n```\n```\\nn=2\\nlightbulb ID       1 2 3\\n\\nINIT_STATE:\\n(initially ON)     1 1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 0 ( after 1 operation: flip all )\\n                   0 1 0 ( after 1 operation: flip odd )\\n                   0 1 1 ( after 1 operation: flip 3k+1 ) \\n                   1 0 1 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   4 ( 000 or 010 or 011 or 101 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 0 ( after 2 operations: flip odd, flip even )\\n                   0 0 1 ( after 2 operations: flip 3k+1, flip even )\\n                   0 1 0 ( after 2 operations: flip even, flip all )\\n                   1 0 0 ( after 2 operations: flip all, flip 3k+1 )\\n                   1 0 1 ( after 2 operations: flip odd, flip all )\\n                   1 1 0 ( after 2 operations: flip odd, flip 3k+1 )\\n                   1 1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   7 ( 000 or 001 or 010 or 100 or 101 or 110 or 111 )\\n\\nm=3\\nOPERATIONS:\\n                   ect...\\n                   ect...\\n                   ect...\\nm=3\\nSTATE_COUNT:\\n                   8 ( 000 or 001 or 010 or 011 or 100 or 101 or 110 or 111 )\\n```\n```\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107273,
                "title": "2-short-lines-simple-formula",
                "content": "    int flipLights(int n, int m) {\\n        n = min(n, 3);\\n        return min(1<<n, 1+m*n);\\n    }\\n\\nI can't (yet?) explain the `1+m*n` part, though. Really I just wrote a brute force solution, looked at the results for all cases where n, m &le; 10 and found a formula for the pattern I saw :-)",
                "solutionTags": [],
                "code": "    int flipLights(int n, int m) {\\n        n = min(n, 3);\\n        return min(1<<n, 1+m*n);\\n    }\\n\\nI can't (yet?) explain the `1+m*n` part, though. Really I just wrote a brute force solution, looked at the results for all cases where n, m &le; 10 and found a formula for the pattern I saw :-)",
                "codeTag": "Unknown"
            },
            {
                "id": 107277,
                "title": "share-my-o-1-c-solution-with-thinking-process-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nThere is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.\\n\\nSuppose n lights are labeled as number [1, 2, 3, ..., n], function of these 4 buttons are given below:\\n\\n    1. Flip all the lights.\\n    2. Flip lights with even numbers.\\n    3. Flip lights with odd numbers.\\n    4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n\\n**Example 1:**\\n\\n    Input: n = 1, m = 1.\\n    Output: 2\\n    Explanation: Status can be: [on], [off]\\n\\n**Example 2:**\\n\\n    Input: n = 2, m = 1.\\n    Output: 3\\n    Explanation: Status can be: [on, off], [off, on], [off, off]\\n\\n**Example 3:**\\n\\n    Input: n = 3, m = 1.\\n    Output: 4\\n    Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].\\n\\n**Note:** n and m both fit in range [0, 1000]. \\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Predefinition\\n\\n---\\n\\nIn order to make the explanation much clearer, **the state of the lights** is defined by an **n-digit binary number K**.\\n\\nSince n lights are labeled as number [1, 2, 3, ..., n], the **p-th (1 \\u2264 p \\u2264 n) digit of K** represents **the state of light p**, which means\\n\\n- When the digit is 1, light p is on.\\n\\n- When the digit is 0, light p is off.\\n\\nSince all lights are turned on initially, **the initial K is 111....1 (with n 1's)**.\\n\\nHere, the operations of the 4 buttons from 1 to 4 are also named to \\n\\n>#### **OP1, OP2, OP3, OP4**\\n\\nThe whole problem now becomes\\n\\n>#### **By doing m operations in {OP1, OP2, OP3, OP4}, how many different K's can we get?**\\n\\n---\\nIn the following explanation, the **4 different operations** will be marked by **4 different colors**:\\n\\n![0_1504591374428_color.png](https://discuss.leetcode.com/assets/uploads/files/1504591306285-color.png) \\n\\n---\\nHere, we also need to introduce [2 definitions in mathematics](https://en.wikipedia.org/wiki/Closure_(mathematics)).\\n\\n**Closure:**\\n\\n> #### **A set has closure under an operation if performance of that operation on members of the set always produces a member of the same set; in this case we also say that the set is closed under the operation.**\\n\\n**Closed under a collection of operations:**\\n\\n>#### **A set is said to be **closed under a collection of operations** if it is closed under each of the operations individually.**\\n\\n---\\n#### 2.2 Bi-directional proof\\n\\n---\\nIf the state of all the lights are represented by a binary number K,\\n\\n- If we do **a single operation** (OP1, OP2, OP3 or OP4) **even times**, the **specified lights** (all in OP1, even in OP2, odd in OP3, 3k+1 in OP4) will be **toggled even times**.\\n\\n- **The specified lights' status won't change, which means K won't change**.\\n\\n---\\nIt can be inferred that\\n\\n>#### **The transition between different K's are always bi-directional.**\\n\\n---\\n#### 2.3 Special case\\n\\n---\\nIf **m = 0, we do nothing, the result is only the initial K**, which means\\n\\n> #### **The answer is 1.**\\n\\n---\\n\\n#### 2.4 When n = 1\\n\\n---\\n\\nThe state diagram will be\\n\\n![0_1504591559446_diagram_1.png](http://discuss.leetcode.com/assets/uploads/files/1504591491378-diagram_1.png) \\n\\n---\\n**Initially, K = 1.**\\n\\n- After OP1, light 1 is off, K = 0.\\n- After OP2, since 1 is odd, light 1 is still on, K = 1.\\n- After OP3, since 1 is odd, light 1 is off, K = 0.\\n- After OP4, since 1 mod 3 = 1, light 1 is off, K = 0.\\n\\nSince the 4 transitions in the diagram are all bi-directional, the maximum number of probable K's is 2 (1 and 0).\\n\\n---\\nThen, do the **mathematical Induction**\\n\\n- When **m = 1**, the result can be 1(do OP2 once) and 0(do OP1, OP3 or OP4 once).\\n- Suppose after the q-th transition, **m = q (q \\u2265 1)**, we are probably at 0, 1.(**2 probable statuses**)\\n   - If the **result is 1**, in the next transition **(m = q + 1), K can be 1 or 0**.\\n   - If the **result is 0**, in the next transition **(m = q + 1), K can only be 1**.\\n   - **Still 2 probable statuses.**\\n- When **m = q + 1**, the **probable result STILL** can be **0 or 1**.\\n- **When n = 1, for all m, K can only be 0 or 1, and the answer is 2**\\n\\n---\\nIt's clear that\\n\\n> #### **The set {0,1} is a closure, and it is closed under the operation set {OP1, OP2, OP3, OP4}.**\\n\\nwhich means\\n\\n>#### **When n = 1, the answer is always 2.**\\n\\n---\\n#### 2.5 When n = 2\\n\\n---\\nThe state diagram will be\\n\\n![0_1504666814740_diagram_2.png](/assets/uploads/files/1504666748347-diagram_2.png) \\n\\n---\\n**Here, since all transitions are bi-directional, all two-way arrows are omitted.**\\n\\n**The maximum number of probable different K's is 4 (11, 00, 10, 01).**\\n\\n**The 4 statuses of K are marked as A0, A1, A2 and A3.**\\n\\n---\\n\\nFrom the diagram, we can see\\n\\n**Initially, K = A0 = 11.** Then, do the **mathematical Induction**\\n\\n- When **m = 1**, go from A0 to A1, A2 or A3. There are 3 different K's. **The answer is 3.**\\n- **We are now at A1, A2 or A3 after first transition.** \\n- When **m = 2**\\n    - Since A1, A2, A3 forms a **triangle loop**, they can **transit to each other**, which means A1, A2, A3 are all possible answer for K. \\n    - Since A1, A2, A3 can transit to A0, A0 is also a possible answer for K.\\n    - **The answer is 3 + 1 = 4.**\\n\\n- Suppose after the q-th transition, **m = q (q \\u2265 2)**, we are probably at A0, A1, A2, A3. (**4 probable statuses**)\\n- When **m = q + 1**\\n   - If we are at A0, next status will probably be A1, A2, A3.\\n   - If we are at A1, A2 or A3, next status will probably be A0, A1, A2, A3.\\n   - We are still probably at A0, A1, A2, A3.\\n   - **Still 4 probable statuses in all.**\\n\\n---\\nIt's clear that\\n\\n>#### **The set {A0, A1, A2, A3} is a closure, and it is closed under operation set {OP1, OP2, OP3, OP4}.**\\n\\nThe conclusion is\\n\\n> #### **When n = 2, If m = 1, the answer is 3. If m \\u2265 2, the answer is 4.**\\n\\n---\\n#### 2.6 When n = 3\\n\\n---\\nThe state diagram will be\\n\\n![0_1504666826464_diagram_3.png](/assets/uploads/files/1504666758850-diagram_3.png) \\n\\n---\\n**Here, since all transitions are bi-directional, all two-way arrows are omitted.**\\n\\n**The maximum number of probable different K's is 8 (111, 000, 101, 010, 011, 100, 001, 110).**\\n\\n**The 8 statuses of K are marked as A0, A1, A2, A3 (vertices in the outer pyramid) and B0, B1, B2, B3 (vertices in the inner pyramid).**\\n\\n---\\n\\nFrom the diagram, we can see\\n\\n**Initially, K = A0 = 111**. Then, do the **mathematical Induction**\\n\\n- When **m = 1**, go from A0 to B0, A1, A2 or A3. There are 4 different K's. **The answer is 4.**\\n- **We are now at B0, A1, A2 or A3 after first transition.** \\n- When **m = 2**\\n  - Since **A1, A2, A3 forms a triangle loop**, they can **transit to each other**, which means **A1, A2, A3 are possible answer for K**. \\n  - Since **A1 can transit to B1, A2 can transit to B2, A3 can transit to B3**, **B1, B2, B3 are possible answer for K**. \\n  - Since **B0, A1, A2 or A3 can transit to A0**, **A0 is a possible answer for K**.\\n  - Since **B0 can transit to B1, B2, B3**,  **B1, B2, B3 are possible answer for K**.\\n  - **All possible K's are A0, A1, A2, A3, B1, B2, B3 after second transition**.\\n  - **The answer is 7.**\\n- **We are now at A0, A1, A2, A3, B1, B2, B3 after second transition.**\\n- When **m = 3**\\n  - **A0 can transit to B0.**\\n  - **A1 can transit to B1.**\\n  - **A2 can transit to B2.**\\n  - **A3 can transit to B3.**\\n  - **A1, A2, A3 can transit to A0.**\\n  - **B1 can transit to A1.**\\n  - **B2 can transit to A2.**\\n  - **B3 can transit to A3.**\\n  - **All possible K's are A0, A1, A2, A3, B0, B1, B2, B3 after third transition**.\\n  - **The answer is 8.**\\n- Suppose after the q-th transition, **m = q (q \\u2265 3)**, we are probably at A0, A1, A2, A3, B0, B1, B2, B3. (**8 probable statuses**)\\n- When **m = q + 1**\\n  - **A0 can transit to B0.**\\n  - **A1 can transit to B1.**\\n  - **A2 can transit to B2.**\\n  - **A3 can transit to B3.**\\n  - **B0 can transit to A0.**\\n  - **B1 can transit to A1.**\\n  - **B2 can transit to A2.**\\n  - **B3 can transit to A3.**\\n  - **All possible K's are STILL A0, A1, A2, A3, B0, B1, B2, B3**.\\n  - **Still, the answer is 8.**\\n\\n---\\nIt's clear that\\n\\n> #### **The set {A0, A1, A2, A3, B0, B1, B2, B3} is a closure, and it is closed under operation set {OP1, OP2, OP3, OP4}.**\\n\\nThe conclusion is\\n\\n> #### **When n = 3, If m = 1, the answer is 4. If m = 2, the answer is 7. If m \\u2265 3, the answer is 8.**\\n\\n---\\n\\n#### 2.7 When n > 3\\n\\n---\\nSuppose **K = A0 has n digits, and its p-th digit is A0(p), 1 \\u2264 p \\u2264 n.**\\n\\n- **Initially, A0 = 111...1 (n 1's)**, which means\\n  - **A0(p) = 1, p mod 6 = 1.**\\n  - **A0(p) = 1, p mod 6 = 2.**\\n  - **A0(p) = 1, p mod 6 = 3.**\\n  - **A0(p) = 1, p mod 6 = 4.**\\n  - **A0(p) = 1, p mod 6 = 5.** \\n  - **A0(p) = 1, p mod 6 = 0.**\\n\\n---\\n- **By doing OP1 on A0 , we get A1,** and\\n  - **A1(p) = 0, p mod 6 = 1.**\\n  - **A1(p) = 0, p mod 6 = 2.**\\n  - **A1(p) = 0, p mod 6 = 3.**\\n  - **A1(p) = 0, p mod 6 = 4.**\\n  - **A1(p) = 0, p mod 6 = 5.**\\n  - **A1(p) = 0, p mod 6 = 0.**\\n- **By doing OP2 on A0 , we get A2,** and\\n  - **A2(p) = 1, p mod 6 = 1.**\\n  - **A2(p) = 0, p mod 6 = 2.**\\n  - **A2(p) = 1, p mod 6 = 3.**\\n  - **A2(p) = 0, p mod 6 = 4.**\\n  - **A2(p) = 1, p mod 6 = 5.**\\n  - **A2(p) = 0, p mod 6 = 0.**\\n- **By doing OP3 on A0 , we get A3,** and\\n  - **A3(p) = 0, p mod 6 = 1.**\\n  - **A3(p) = 1, p mod 6 = 2.**\\n  - **A3(p) = 0, p mod 6 = 3.**\\n  - **A3(p) = 1, p mod 6 = 4.**\\n  - **A3(p) = 0, p mod 6 = 5.**\\n  - **A3(p) = 1, p mod 6 = 0.**\\n\\n---\\n- **By doing OP4 on A0 , we get B0,** and\\n  - **B0(p) = 0, p mod 6 = 1.**\\n  - **B0(p) = 1, p mod 6 = 2.**\\n  - **B0(p) = 1, p mod 6 = 3.**\\n  - **B0(p) = 0, p mod 6 = 4.**\\n  - **B0(p) = 1, p mod 6 = 5.**\\n  - **B0(p) = 1, p mod 6 = 0.**\\n\\n---\\n- **By doing OP1 on B0 , we get B1,** and\\n  - **B1(p) = 1, p mod 6 = 1.**\\n  - **B1(p) = 0, p mod 6 = 2.**\\n  - **B1(p) = 0, p mod 6 = 3.**\\n  - **B1(p) = 1, p mod 6 = 4.**\\n  - **B1(p) = 0, p mod 6 = 5.**\\n  - **B1(p) = 0, p mod 6 = 0.**\\n- **By doing OP2 on B0 , we get B2,** and\\n  - **B2(p) = 0, p mod 6 = 1.**\\n  - **B2(p) = 0, p mod 6 = 2.**\\n  - **B2(p) = 1, p mod 6 = 3.**\\n  - **B2(p) = 1, p mod 6 = 4.**\\n  - **B2(p) = 1, p mod 6 = 5.**\\n  - **B2(p) = 0, p mod 6 = 0.**\\n- **By doing OP3 on B0 , we get B3,** and\\n  - **B3(p) = 1, p mod 6 = 1.**\\n  - **B3(p) = 1, p mod 6 = 2.**\\n  - **B3(p) = 0, p mod 6 = 3.**\\n  - **B3(p) = 0, p mod 6 = 4.**\\n  - **B3(p) = 0, p mod 6 = 5.**\\n  - **B3(p) = 1, p mod 6 = 0.**\\n\\n---\\nSince it has already been proved in 2.2 that\\n\\n> #### **The transition between different K's are always bi-directional.**\\n\\nSince we only need to calculate on a single direction, we can get\\n\\n- **By doing OP4 on B1 , we get A1.**\\n- **By doing OP4 on B2 , we get A2.**\\n- **By doing OP4 on B3 , we get A3.**\\n\\n---\\n- **By doing OP3 on A1 , we get A2.**\\n- **By doing OP1 on A2 , we get A3.**\\n- **By doing OP2 on A3 , we get A1.**\\n\\nSimilarly,\\n- **By doing OP3 on B1 , we get B2.**\\n- **By doing OP1 on B2 , we get B3.**\\n- **By doing OP2 on B3 , we get B1.**\\n\\n---\\nSince **the first 3 digits of A0, A1, A2, A3, B0, B1, B2, B3 are different**, we can inferred that\\n\\n>#### **A0, A1, A2, A3, B0, B1, B2, B3 are all different binary numbers.**\\n\\nwhich means\\n\\n>#### **A0, A1, A2, A3, B0, B1, B2, B3 represents 8 different statuses.**\\n\\nSince the result of doing {OP1, OP2, OP3, OP4} on the set {A0, A1, A2, A3, B0, B1, B2, B3} is still in the set  {A0, A1, A2, A3, B0, B1, B2, B3}, it can be inferred that when n > 3\\n\\n> #### **The set {A0, A1, A2, A3, B0, B1, B2, B3} is STILL a closure, and it is STILL closed under operation set {OP1, OP2, OP3, OP4}.**\\n\\n---\\nIf we draw the state diagram\\n\\n![0_1504666840971_diagram_m.png](/assets/uploads/files/1504666773118-diagram_m.png) \\n\\nwe can find **this diagram is as same as those in 2.6 when n = 3**.\\n\\n---\\nSince we have already discussed on the diagram in 2.6, here we come to the conclusion\\n\\n> #### **When n > 3, If m = 1, the answer is 4. If m = 2, the answer is 7. If m \\u2265 3, the answer is 8.**\\n\\n---\\n## 3. Conclusion\\n\\n---\\nAfter the discussion, we can infer that **the final answer is**\\n\\n- **When m = 0, the answer is 1.**\\n\\n\\n- **When n = 1, the answer is 2.**\\n- **When n = 2**\\n   - **If m = 1, the answer is 3.**\\n   - **If m \\u2265 2, the answer is 4.**\\n- **When n \\u2265 3**\\n   - **If m = 1, the answer is 4.**\\n   - **If m = 2, the answer is 7.**\\n   - **If m \\u2265 3, the answer is 8.**\\n\\n---\\n## 4. Complexity analysis\\n\\n---\\n> #### **Both the time and space complexity are O(1).**\\n\\n---\\n## 5. Code\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0)\\n        {\\n            return 1;\\n        }else{\\n            switch(n)\\n            {\\n                case 1: return 2;break;\\n                case 2: return (m == 1) ? 3 : 4;break;\\n                default:\\n                switch(m)\\n                {\\n                    case 1: return 4;break;\\n                    case 2: return 7;break;\\n                    default: return 8;break;\\n                }\\n                break;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0)\\n        {\\n            return 1;\\n        }else{\\n            switch(n)\\n            {\\n                case 1: return 2;break;\\n                case 2: return (m == 1) ? 3 : 4;break;\\n                default:\\n                switch(m)\\n                {\\n                    case 1: return 4;break;\\n                    case 2: return 7;break;\\n                    default: return 8;break;\\n                }\\n                break;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107274,
                "title": "2-line-python-recursive-with-explanation",
                "content": "Inspired by: [this post](https://discuss.leetcode.com/topic/102395/2-short-lines-simple-formula/2)\\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        m, n = min(3, m), min(3, n)\\n        return 1 if n == 0 or m == 0 else self.flipLights(n - 1,  m) + self.flipLights( n - 1, m - 1)      \\n```\\n\\nOperations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)\\nRelations:\\nO + O = N, E + E = N, A + A = N, T + T = N\\nO + E = A, O + A = E, E + A = O\\nExclusive statuses :\\nn > 2:\\n\\u2460 N\\n\\u2461 O\\n\\u2462 E\\n\\u2463 A\\n\\u2464 T\\n\\u2465 O + T\\n\\u2466 E + T\\n\\u2467 A + T\\n\\nn = 2 (remove all T related statuses):\\n\\u2460 N\\n\\u2461 O\\n\\u2462 E\\n\\u2463 A\\n\\nn = 1(remove all T, E, A related statuses):\\n\\u2460 N\\n\\u2461 O\\n\\nSteps needed to all status( always can plus 2 * k)\\n\\u2460 can only be achieved by 0, 2 steps\\n\\u2461\\uff0c\\u2462\\uff0c\\u2463 can be achieved by either 1 or 2 steps\\n\\u2464 can only be achieved by 1 steps\\n\\u2465\\uff0c\\u2466\\uff0c\\u2467 can only be achieved by 2 steps,\\n\\nThus:\\n0 steps -> \\u2460\\n1 steps -> \\u2461\\uff0c\\u2462\\uff0c\\u2463\\uff0c\\u2464\\n2 steps -> \\u2460\\uff0c\\u2461\\uff0c\\u2462\\uff0c\\u2463\\uff0c\\u2465\\uff0c\\u2466\\uff0c\\u2467\\nmore than 2 steps -> \\u2460, \\u2461, \\u2462, \\u2463, \\u2464, \\u2465, \\u2466, \\u2467\\n\\n![0_1504741152259_Screen Shot 2017-09-06 at 4.23.25 PM.png](/assets/uploads/files/1504741152817-screen-shot-2017-09-06-at-4.23.25-pm.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        m, n = min(3, m), min(3, n)\\n        return 1 if n == 0 or m == 0 else self.flipLights(n - 1,  m) + self.flipLights( n - 1, m - 1)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674197,
                "title": "c-5-lines-code-with-line-by-line-explanations-and-observations",
                "content": "I must admit I can\\'t solve it after staring at it for hours (Partly because I believe there must be a way to solve it without enumerating all cases...). So I read many posts and tried to write my code according to those posts, below is the AC code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) return 1; // no presses, original state\\n        if (n == 1) return 2; // constraint: (p > 0) : one light, binary states.\\n        if (p == 1) return n > 2 ? 4 : 3; // constraint: (p > 0 && n > 1) : one press, if (1) two lights -> all 2^2 but original state = 3 states (2) more than two lights -> 011, 010, 101, 000 = 4 states\\n        if (n == 2) return 4; // constraint: (p > 1 && n > 1) : two lights, multiple press, 4 states.\\n        return p == 2 ? 7 : 8; // constraint: (p > 1 && n > 2) : if only two presses, can\\'t be in 4(011) state -> 8-1 = 7\\n    }\\n};\\n\\n/**\\n\\nObservations:\\n1) only the first 3 lights matter, since we can only switch (1) even (2) odd (3) (x = 1 MOD 3) lights\\n2) all ops are commutative.\\n3) there is only 8 states possible for all situations: All-on(111), 1(000), 2(010), 3(101), 4(011), 41(100), 42(110), 43(001)\\n*/\\n```\\nIf it is helpful, maybe a upvote?",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) return 1; // no presses, original state\\n        if (n == 1) return 2; // constraint: (p > 0) : one light, binary states.\\n        if (p == 1) return n > 2 ? 4 : 3; // constraint: (p > 0 && n > 1) : one press, if (1) two lights -> all 2^2 but original state = 3 states (2) more than two lights -> 011, 010, 101, 000 = 4 states\\n        if (n == 2) return 4; // constraint: (p > 1 && n > 1) : two lights, multiple press, 4 states.\\n        return p == 2 ? 7 : 8; // constraint: (p > 1 && n > 2) : if only two presses, can\\'t be in 4(011) state -> 8-1 = 7\\n    }\\n};\\n\\n/**\\n\\nObservations:\\n1) only the first 3 lights matter, since we can only switch (1) even (2) odd (3) (x = 1 MOD 3) lights\\n2) all ops are commutative.\\n3) there is only 8 states possible for all situations: All-on(111), 1(000), 2(010), 3(101), 4(011), 41(100), 42(110), 43(001)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107282,
                "title": "java-o-1-solution",
                "content": "There's a total only `six` possible answers:\\n`1, 2, 3, 4, 7 and 8`\\n```\\npublic int flipLights(int n, int m) {\\n            if (n == 1 && m > 0) {\\n                return 2;\\n            } else if (n == 2 && m == 1) {\\n                return 3;\\n            } else if ((n > 2 && m == 1) || (n == 2 && m > 1)) {\\n                return 4;\\n            } else if (n > 2 && m == 2) {\\n                return 7;\\n            } else if (n > 2 && m > 2) {\\n                return 8;\\n            } else {\\n                return 1;\\n            }\\n        }\\n```\\n\\nOne can imagine there's a 2d array `dp` with `m` rows and `n` columns, suppose m == 5 and n == 7, this `dp` matrix will be like the following:\\n\\n```\\n2, 3, 4, 4, 4, 4, 4, \\n2, 4, 7, 7, 7, 7, 7, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8,\\n```\\n\\nAs `m` and `n` extend, the result will be fixed, so a total only 6 possible answers, we could basically \"hardcode\" them as the above.\\n\\nAlso viewable [here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/_672.java) on Github.",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n            if (n == 1 && m > 0) {\\n                return 2;\\n            } else if (n == 2 && m == 1) {\\n                return 3;\\n            } else if ((n > 2 && m == 1) || (n == 2 && m > 1)) {\\n                return 4;\\n            } else if (n > 2 && m == 2) {\\n                return 7;\\n            } else if (n > 2 && m > 2) {\\n                return 8;\\n            } else {\\n                return 1;\\n            }\\n        }\\n```\n```\\n2, 3, 4, 4, 4, 4, 4, \\n2, 4, 7, 7, 7, 7, 7, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8,\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107290,
                "title": "python-solution-this-is-not-a-programming-questions-imo",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0:\\n            return 1\\n        if n >= 3:\\n            return 4 if m == 1 else 7 if m == 2 else 8\\n        if n == 2:\\n            return 3 if m == 1 else 4\\n        if n == 1:\\n            return 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0:\\n            return 1\\n        if n >= 3:\\n            return 4 if m == 1 else 7 if m == 2 else 8\\n        if n == 2:\\n            return 3 if m == 1 else 4\\n        if n == 1:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897976,
                "title": "python3-o-1",
                "content": "Key insight: \\nIt is not difficult to find out that there are not a lot of states since \\n1) operations are reversible;\\n2) operations can be reproduced by other operations. \\n\\nTo get a more concrete understanding, let\\'s list the outcomes of given `m` and `n` up to 5. From the table, it is obvious that \\n1) beyond 3, `n` and `m` become irrelevant because there are at most 8 states all of which become achievable when `m` and `n` are large enough; \\n2) below 3, `fn(n, m) = fn(n-1, m-1) + fn(n-1, m)`. \\n\\n```\\nn/m 0 1 2 3 4 5\\t\\t\\n0   1 1 1 1 1 1\\t \\n1   1 2 2 2 2 2\\n2   1 3 4 4 4 4\\n3   1 4 7 8 8 8\\n4   1 4 7 8 8 8\\n5   1 4 7 8 8 8\\n```\\n\\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        \\n        def fn(n, m): \\n            \"\"\"Return number of different status.\"\"\"\\n            if m * n == 0: return 1\\n            return fn(n-1, m-1) + fn(n-1, m)\\n        \\n        return fn(min(n, 3), min(m, 3))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nn/m 0 1 2 3 4 5\\t\\t\\n0   1 1 1 1 1 1\\t \\n1   1 2 2 2 2 2\\n2   1 3 4 4 4 4\\n3   1 4 7 8 8 8\\n4   1 4 7 8 8 8\\n5   1 4 7 8 8 8\\n```\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        \\n        def fn(n, m): \\n            \"\"\"Return number of different status.\"\"\"\\n            if m * n == 0: return 1\\n            return fn(n-1, m-1) + fn(n-1, m)\\n        \\n        return fn(min(n, 3), min(m, 3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175165,
                "title": "conventional-c-bfs-solution-with-very-clear-explanation",
                "content": "At first glance of this question, we can easily come up with a dfs or bfs idea. But considering the time complexity (n,m<=1000), it appears a traditional search-based method will generate TLE. But if we carefully look at the state-transfer function, we can see that, the first three will just generate 3 different status (`00000....`,`11111....`,`01010101......`,`10101010....`) . So we may assume that the final status after m operations should not be too large, though we still didn\\'t take the 4th operations into account. Let\\'s think about our bfs solution in this way: after k steps,we expanded all elements that should be visited in the next level, let\\'s call them `status_set`. Here we use set because we don\\'t want to have duplicates of these status; We also memoraize the size of `status_set` (`prev_size`) generate by previous level. Once we found `status_set.size()==prev_size`, we know that there is no need to search deeper because no more elements will be added to the set. So now we can just return the `prev_size`, which is actually only 8. Below is my code:\\n```\\nclass Solution {\\npublic:\\n    string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    int flipLights(int n, int m) {\\n        string root(n,\\'1\\');\\n        unordered_set<string> mset;\\n        queue<string> q;\\n        q.push(root);\\n        mset.insert(root);\\n        int cur_size = mset.size();\\n        int level = 0;\\n        while(!q.empty() && level<m){\\n            int size = q.size();\\n            mset.clear();\\n            for(int i = 0;i<size;i++){\\n                string front = q.front();\\n                q.pop();\\n                for(int k = 0;k<4;k++){\\n                    string s = op(k,front);\\n                    mset.insert(s);   \\n                    q.push(s);\\n                }\\n            }\\n            level++;\\n            if(mset.size()==cur_size) break;\\n            cur_size = mset.size();\\n        }\\n        return cur_size;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    int flipLights(int n, int m) {\\n        string root(n,\\'1\\');\\n        unordered_set<string> mset;\\n        queue<string> q;\\n        q.push(root);\\n        mset.insert(root);\\n        int cur_size = mset.size();\\n        int level = 0;\\n        while(!q.empty() && level<m){\\n            int size = q.size();\\n            mset.clear();\\n            for(int i = 0;i<size;i++){\\n                string front = q.front();\\n                q.pop();\\n                for(int k = 0;k<4;k++){\\n                    string s = op(k,front);\\n                    mset.insert(s);   \\n                    q.push(s);\\n                }\\n            }\\n            level++;\\n            if(mset.size()==cur_size) break;\\n            cur_size = mset.size();\\n        }\\n        return cur_size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497288,
                "title": "easy-o-1-solution",
                "content": "\\n# Complexity\\n- Time complexity: **O(1)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2 && k == 1) return 3;\\n        if(n == 2 || k == 1) return 4;\\n        if(k == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2 && k == 1) return 3;\\n        if(n == 2 || k == 1) return 4;\\n        if(k == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317125,
                "title": "672-time-96-77-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Reduce n to at most 3, since any action performed more than 3 times will result in a pattern that has already been counted.\\n2. If m is 0, return 1 as there is only one possible outcome (all lights off).\\n3. If m is 1, return the number of possible outcomes for the given value of n and m.\\n4. If m is 2, return the number of possible outcomes for the given value of n and m.\\n5. If m is greater than or equal to 3, return the number of possible outcomes for the given value of n and m.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        # Reduce n to at most 3, since any action performed more than 3 times\\n        # will result in a pattern that has already been counted\\n        n = min(n, 3)\\n        if m == 0:\\n            return 1\\n        elif m == 1:\\n            # For m=1, there are only 2 outcomes for n=1, 3 outcomes for n=2, and 4 outcomes for n=3\\n            return [2, 3, 4][n - 1]\\n        elif m == 2:\\n            # For m=2, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 7 outcomes for n=3\\n            return [2, 4, 7][n - 1]\\n        else:\\n            # For m>=3, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 8 outcomes for n=3\\n            return [2, 4, 8][n - 1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        # Reduce n to at most 3, since any action performed more than 3 times\\n        # will result in a pattern that has already been counted\\n        n = min(n, 3)\\n        if m == 0:\\n            return 1\\n        elif m == 1:\\n            # For m=1, there are only 2 outcomes for n=1, 3 outcomes for n=2, and 4 outcomes for n=3\\n            return [2, 3, 4][n - 1]\\n        elif m == 2:\\n            # For m=2, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 7 outcomes for n=3\\n            return [2, 4, 7][n - 1]\\n        else:\\n            # For m>=3, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 8 outcomes for n=3\\n            return [2, 4, 8][n - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723656,
                "title": "4-liner-c-solution-o-1-tc",
                "content": "Here is my solution.\\n\\nThere are only 8 states possible and which can be convered in the following cases.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(n == 0) return 1;\\n        if(n == 1) return vector<int>{1,2}[min(p,1)];\\n        if(n == 2) return vector<int>{1,3,4}[min(p,2)];\\n        return vector<int>{1,4,7,8}[min(p,3)];\\n    }\\n};\\n```\\n\\nTC : O(1)\\nSC : O(1)\\n\\nThank you :>",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(n == 0) return 1;\\n        if(n == 1) return vector<int>{1,2}[min(p,1)];\\n        if(n == 2) return vector<int>{1,3,4}[min(p,2)];\\n        return vector<int>{1,4,7,8}[min(p,3)];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926323,
                "title": "python-bfs",
                "content": "# Intuition\\nWe need to traverse the states graph for exactly ``presses`` levels and get the total number of states discovered on the last level.\\n\\n# Approach\\nWe can do either BFS or DFS. We also need an efficient way to represent a state and to calculate next states. \\nWe can represent states as binary numbers where ith bit is set to ``1`` if the ith bulb is switched on and ``0`` otherwise. \\nThen, for the state transitions, we have: \\n1. Toggle all bulbs - perform an bitwise XOR on the state with all bits set to 1\\n2. Toggle even bulbs - perform an bitwise XOR on the state with all even bits set to 1 \\n3. Toggle odd bulbs - perform an bitwise XOR on the state with all odd bits set to 1 \\n4. Toggle ``3*k+1`` bulbs - perform an bitwise XOR on the state with all ith bits set to 1, where ``i % 3 == 1``\\n\\nSince ``n <= 1000`` we would need big numbers to represent those states. Luckily Python has an out of the box support for big numbers.\\n\\n\\n# Complexity\\n- Time complexity: $$O(presses)$$\\nWe need to perform ``presses`` steps traversing the states graph, each step has $$O(1)$$ operations.\\n\\n- Space complexity:\\nSpace complexity is trickier here. On each step we discover 4 states from each state, however there are a lot of duplicated states. It can be proven that because of the operations that we have we wouldn\\'t get more than ``8`` different states on each level. \\n\\nIntuition:\\nWe can divide the whole state in groups of 3 digits and only have following operations:\\n1. Switch all 3 bits\\n2. Switch odd bits\\n3. Switch even bits\\n4. Switch only last bit\\n\\nRest bits will be changed in the same way. The only problem is that we would change odd and even groups of 3 differently for odd and even bits toggles.\\n\\nI don\\'t have a better explanation yet, but my guess is that only ``8`` different states are possible at most.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n\\n        all_ones, evens, odds, three = 0, 0, 0, 0\\n        for i in range(n):\\n            all_ones = (all_ones << 1) + 1\\n            evens = (evens << 1) + (1 if (i+1) % 2 == 0 else 0)\\n            odds = (odds << 1) + (1 if (i+1) % 2 == 1 else 0)\\n            three = (three << 1) + (1 if (i+1) % 3 == 1 else 0)\\n\\n        state = all_ones\\n\\n        level = {state}\\n        for i in range(presses):\\n            next_level = set()\\n            for state in level:\\n                states = [state ^ all_ones,\\n                          state ^ evens,\\n                          state ^ odds,\\n                          state ^ three]\\n                for next_state in states:\\n                    next_level.add(next_state)\\n            level = next_level\\n\\n        return len(level)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n\\n        all_ones, evens, odds, three = 0, 0, 0, 0\\n        for i in range(n):\\n            all_ones = (all_ones << 1) + 1\\n            evens = (evens << 1) + (1 if (i+1) % 2 == 0 else 0)\\n            odds = (odds << 1) + (1 if (i+1) % 2 == 1 else 0)\\n            three = (three << 1) + (1 if (i+1) % 3 == 1 else 0)\\n\\n        state = all_ones\\n\\n        level = {state}\\n        for i in range(presses):\\n            next_level = set()\\n            for state in level:\\n                states = [state ^ all_ones,\\n                          state ^ evens,\\n                          state ^ odds,\\n                          state ^ three]\\n                for next_state in states:\\n                    next_level.add(next_state)\\n            level = next_level\\n\\n        return len(level)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623308,
                "title": "java-c-python-all-constant-time-o-1-explained",
                "content": "**UPVOTE PLEASE**\\n```\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\nC++:\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n\\n\\nPY:\\n\\ndef flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type presses: int\\n        :rtype: int\\n        \"\"\"\\n        if(m==0): return 1;\\n        if(n==1): return 2;\\n        if(n==2 and m==1): return 3;\\n        if(n==2): return 4;\\n        if(m==1): return 4;\\n        if(m==2): return 7;\\n        if(m>=3): return 8;\\n        return 8;\\n\\nJAVA:\\n\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\nC++:\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n\\n\\nPY:\\n\\ndef flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type presses: int\\n        :rtype: int\\n        \"\"\"\\n        if(m==0): return 1;\\n        if(n==1): return 2;\\n        if(n==2 and m==1): return 3;\\n        if(n==2): return 4;\\n        if(m==1): return 4;\\n        if(m==2): return 7;\\n        if(m>=3): return 8;\\n        return 8;\\n\\nJAVA:\\n\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633645,
                "title": "java-o-1-observation",
                "content": "Some press combination result in other press combination, for example, \\n1 & 2 == 3\\n1 & 3 == 2\\n2 & 3 == 1\\nThe only thing that\\'s interesting is press 4, but it can only stack with 2 or 3 to result in a new pattern `(4, 4 + 2, 4 + 3, 4 + 2 + 3)`, so there will only ever be at most 8 patterns in total.\\n\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        //1, 2 -> 3\\n        //1, 3 -> 2\\n        //2, 3 -> 1\\n        //all on, all off, even on, odd on, 3k+1 on, 3k+0+2 on, 3k+1 w/ 2, 3k+1 w/ 3\\n        if (n == 2 && presses == 1) return 3;\\n        if (presses == 1) return Math.min(1 << Math.min(4, n), 4); //i chose 4 arbitarily, just has to be big enough to cover small number and less than 31\\n        if (presses == 2) return Math.min(1 << Math.min(4, n), 7);\\n        if (presses >= 3) return Math.min(1 << Math.min(4, n), 8);\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        //1, 2 -> 3\\n        //1, 3 -> 2\\n        //2, 3 -> 1\\n        //all on, all off, even on, odd on, 3k+1 on, 3k+0+2 on, 3k+1 w/ 2, 3k+1 w/ 3\\n        if (n == 2 && presses == 1) return 3;\\n        if (presses == 1) return Math.min(1 << Math.min(4, n), 4); //i chose 4 arbitarily, just has to be big enough to cover small number and less than 31\\n        if (presses == 2) return Math.min(1 << Math.min(4, n), 7);\\n        if (presses >= 3) return Math.min(1 << Math.min(4, n), 8);\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598457,
                "title": "recursion",
                "content": "<br>\\n\\n![image](https://assets.leetcode.com/users/images/bb37b438-213f-4324-bc41-c8152a7764ba_1638030052.542557.png)\\n\\n<br>\\n<br>\\n\\n```\\nint flipLights(int n, int p)\\n{   \\n\\treturn !p or !n ? 1\\n                    : n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t          : flipLights(n-1, p-1) + flipLights(n-1, p);\\n}\\n```\\n||\\n```\\nint flipLights(int n, int p)\\n{\\n\\treturn n*p ? n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t     : flipLights(n-1, p-1) + flipLights(n-1, p)\\n               : 1;\\n}\\n```\\nI like this solution as it clearly has Fibonacci/Binomial_coeffs vibes.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint flipLights(int n, int p)\\n{   \\n\\treturn !p or !n ? 1\\n                    : n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t          : flipLights(n-1, p-1) + flipLights(n-1, p);\\n}\\n```\n```\\nint flipLights(int n, int p)\\n{\\n\\treturn n*p ? n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t     : flipLights(n-1, p-1) + flipLights(n-1, p)\\n               : 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580973,
                "title": "java-math-o-1-faster-than100-brief-explanation-by-formulas",
                "content": "We can get these formulas easily:\\n* \\tB1B2 = B3\\n* \\tB2B3 = B1\\n* \\tB3B1 = B2\\n* \\tBiBi = 0 (initial status)\\n* \\tBiBj = BjBi (commutative law)\\n\\nSo, for number of bulbs no less than 3, there are at most 8 statuses:\\n* 0(initial status)\\n* B1\\n* B2\\n* B3\\n* B1B4\\n* B2B4\\n* B3B4\\n* B4\\n\\nWe can easily enumrate all final statuses given the number of times we press buttons using the formulas above.\\n\\nNote that for number of bulbs less than 3:\\n1. B4 = B3\\n2. The final statuses will be less than 2^n.\\n\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        \\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        \\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337871,
                "title": "faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if ((presses == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (presses == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (presses >= 2);\\n        }\\n        // n >= 3, presses >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (presses >= 3);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if ((presses == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (presses == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (presses >= 2);\\n        }\\n        // n >= 3, presses >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (presses >= 3);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042202,
                "title": "o-1-detailed-explanation",
                "content": "```\\nfunction flipLights(n: number, m: number): number {\\n\\n    // Some observations:\\n    // Combination of 1 - 4 operations\\n    \\n    // Flip all and Flip even numbers = Flip odd numbers\\n    // Flip all and Flip odd numbers = Flip even numbers\\n    // Flip odd ande even numbers = Flip all\\n    // if n < 3, Flip 3k + 1 numbers = Flip odd numbers\\n    \\n    // => 1 + 2 = 3\\n    // => 1 + 3 = 2\\n    // => 2 + 3 = 1\\n    // => n < 3, 4 = 2\\n    \\n    // n = 0 or m = 0, only 1 state (initial state)\\n    if (n == 0 || m == 0) return 1;\\n    \\n    // n = 1, only 2 state\\n    if (n == 1) return 2;\\n    \\n    // n = 2, m = 1\\n    // we cound have 4 operations:\\n    // flip all => 00\\n    // flip odd => 01\\n    // flip even => 10\\n    // flip 3k + 1 => 01\\n    // 2 and 4 are the same, so we have 3 states\\n    if (n == 2 && m == 1) return 3\\n    \\n    // n = 2, m = 2\\n    // possible operations:\\n    // 1 + 1 => nothing change,     11 -> 00 -> 11\\n    // 1 + 2 => 3, flip odd,        11 -> 00 -> 01\\n    // 1 + 3 => 2, flip even,       11 -> 00 -> 10\\n    // 1 + 4 => 2, flip even,       11 -> 00 -> 10\\n    // 2 + 3 => 1, flip all,        11 -> 10 -> 00\\n    // 2 + 4 => 1, flip all,        11 -> 10 -> 00\\n    // 3 + 4 => nothing change,     11 -> 01 -> 11\\n    // added one more state on top of m = 1, so m = 2, 4 states\\n\\n    // based on the above, we can conclude that:\\n    // 1 + 2 = 3\\n    // 1 + 3 = 2\\n    // 2 + 3 = 1\\n    \\n    // n = 2, m > 2\\n    // 1 + 2 + 1 = 3 + 1, flip odd\\n    // 1 + 3 + 1 = 2 + 1, flip even\\n    // not gonna list all of them, but you got the idea:\\n    \\n    // for m >= 2, the possible states are 4\\n    if (n == 2 && m >= 2) return 4;\\n    \\n    // Say, n = 3, m = 1\\n    // flip all     =>      111 -> 000\\n    // flip odd     =>      111 -> 010\\n    // flip even    =>      111 -> 101\\n    // flip 3k + 1  =>      111 -> 011\\n    // could have 4 states, this is a general rule for all n > 2\\n    if (n > 2 && m == 1) return 4;\\n    \\n    // Say, n = 3, m = 2\\n    // 1 + 1                        111 -> 000 -> 111\\n    // 1 + 2 = 3, flip odd,         111 -> 000 -> 010\\n    // 1 + 3 = 2, flip even,        111 -> 000 -> 101\\n    // 1 + 4,                       111 -> 000 -> 100\\n    // 2 + 3 = 1, flip all,         111 -> 101 -> 000\\n    // 2 + 4                        111 -> 101 -> 001\\n    // 3 + 4                        111 -> 010 -> 110\\n    // could have 7 states, this is a general rule for all n > 2 and m = 2\\n    if (n > 2 && m == 2) return 7;\\n    \\n    // n = 3, m > 2\\n    // 1 + 2 + 4 = 3 + 4            111 -> 000 -> 010 -> 110\\n    // 1 + 3 + 4 = 2 + 4            111 -> 000 -> 101 -> 001\\n    // 1 + 4 + 1 = 4                111 -> 000 -> 100 -> 011\\n    // 2 + 4 + 1 = 3 + 4            111 -> 101 -> 001 -> 110\\n    // 3 + 4 + 1 = 2 + 4            111 -> 010 -> 110 -> 001\\n    // added one new possible state on top of m = 1, we got 8 states here\\n    // not gonna list all, but you got the idea:\\n    // for m > 2, we could simpify it to the base case m = 2\\n    // e.g. 1 + 4 + 2 + 3 \\n    //      => simpify 2 + 3 to 1           => 1 + 1 + 4\\n    //      => 1 + 1 is doing nothing       => 4\\n    if (n == 3 && m > 2) return 8;\\n    \\n    // for n > 3, m > 2 it is same as n = 3\\n    if (n > 3 && m > 2) return 8;\\n    \\n    // we can simplify the above findings to the follows but I would keep it to teach the future me\\n    if (n == 0 || m == 0) return 1;\\n    else if (n == 1) return 2;\\n    else if (n == 2 && m == 1) return 3;\\n    else if (m == 1) return 4;\\n    else if (m == 2) return 7;\\n    else return 8;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction flipLights(n: number, m: number): number {\\n\\n    // Some observations:\\n    // Combination of 1 - 4 operations\\n    \\n    // Flip all and Flip even numbers = Flip odd numbers\\n    // Flip all and Flip odd numbers = Flip even numbers\\n    // Flip odd ande even numbers = Flip all\\n    // if n < 3, Flip 3k + 1 numbers = Flip odd numbers\\n    \\n    // => 1 + 2 = 3\\n    // => 1 + 3 = 2\\n    // => 2 + 3 = 1\\n    // => n < 3, 4 = 2\\n    \\n    // n = 0 or m = 0, only 1 state (initial state)\\n    if (n == 0 || m == 0) return 1;\\n    \\n    // n = 1, only 2 state\\n    if (n == 1) return 2;\\n    \\n    // n = 2, m = 1\\n    // we cound have 4 operations:\\n    // flip all => 00\\n    // flip odd => 01\\n    // flip even => 10\\n    // flip 3k + 1 => 01\\n    // 2 and 4 are the same, so we have 3 states\\n    if (n == 2 && m == 1) return 3\\n    \\n    // n = 2, m = 2\\n    // possible operations:\\n    // 1 + 1 => nothing change,     11 -> 00 -> 11\\n    // 1 + 2 => 3, flip odd,        11 -> 00 -> 01\\n    // 1 + 3 => 2, flip even,       11 -> 00 -> 10\\n    // 1 + 4 => 2, flip even,       11 -> 00 -> 10\\n    // 2 + 3 => 1, flip all,        11 -> 10 -> 00\\n    // 2 + 4 => 1, flip all,        11 -> 10 -> 00\\n    // 3 + 4 => nothing change,     11 -> 01 -> 11\\n    // added one more state on top of m = 1, so m = 2, 4 states\\n\\n    // based on the above, we can conclude that:\\n    // 1 + 2 = 3\\n    // 1 + 3 = 2\\n    // 2 + 3 = 1\\n    \\n    // n = 2, m > 2\\n    // 1 + 2 + 1 = 3 + 1, flip odd\\n    // 1 + 3 + 1 = 2 + 1, flip even\\n    // not gonna list all of them, but you got the idea:\\n    \\n    // for m >= 2, the possible states are 4\\n    if (n == 2 && m >= 2) return 4;\\n    \\n    // Say, n = 3, m = 1\\n    // flip all     =>      111 -> 000\\n    // flip odd     =>      111 -> 010\\n    // flip even    =>      111 -> 101\\n    // flip 3k + 1  =>      111 -> 011\\n    // could have 4 states, this is a general rule for all n > 2\\n    if (n > 2 && m == 1) return 4;\\n    \\n    // Say, n = 3, m = 2\\n    // 1 + 1                        111 -> 000 -> 111\\n    // 1 + 2 = 3, flip odd,         111 -> 000 -> 010\\n    // 1 + 3 = 2, flip even,        111 -> 000 -> 101\\n    // 1 + 4,                       111 -> 000 -> 100\\n    // 2 + 3 = 1, flip all,         111 -> 101 -> 000\\n    // 2 + 4                        111 -> 101 -> 001\\n    // 3 + 4                        111 -> 010 -> 110\\n    // could have 7 states, this is a general rule for all n > 2 and m = 2\\n    if (n > 2 && m == 2) return 7;\\n    \\n    // n = 3, m > 2\\n    // 1 + 2 + 4 = 3 + 4            111 -> 000 -> 010 -> 110\\n    // 1 + 3 + 4 = 2 + 4            111 -> 000 -> 101 -> 001\\n    // 1 + 4 + 1 = 4                111 -> 000 -> 100 -> 011\\n    // 2 + 4 + 1 = 3 + 4            111 -> 101 -> 001 -> 110\\n    // 3 + 4 + 1 = 2 + 4            111 -> 010 -> 110 -> 001\\n    // added one new possible state on top of m = 1, we got 8 states here\\n    // not gonna list all, but you got the idea:\\n    // for m > 2, we could simpify it to the base case m = 2\\n    // e.g. 1 + 4 + 2 + 3 \\n    //      => simpify 2 + 3 to 1           => 1 + 1 + 4\\n    //      => 1 + 1 is doing nothing       => 4\\n    if (n == 3 && m > 2) return 8;\\n    \\n    // for n > 3, m > 2 it is same as n = 3\\n    if (n > 3 && m > 2) return 8;\\n    \\n    // we can simplify the above findings to the follows but I would keep it to teach the future me\\n    if (n == 0 || m == 0) return 1;\\n    else if (n == 1) return 2;\\n    else if (n == 2 && m == 1) return 3;\\n    else if (m == 1) return 4;\\n    else if (m == 2) return 7;\\n    else return 8;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699368,
                "title": "python3-bit-manipulate-first-3-bits-bulb-switcher-ii",
                "content": "I am too lazy to calculate the result manually and I don\\'t want to copy others answer. So I let computer do it for me.\\nInspired by https://leetcode.com/problems/bulb-switcher-ii/discuss/107274/2-Line-Python-Recursive-With-Explanation\\n```\\nclass Solution:\\n    # Operations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)\\n    states = {\\n        \\'N\\': 0b000,\\n        \\'A\\': 0b111,\\n        \\'O\\': 0b101,\\n        \\'E\\': 0b010,\\n        \\'T\\': 0b001,\\n        \\'AT\\': 0b111 ^ 0b001,\\n        \\'OT\\': 0b101 ^ 0b001,\\n        \\'ET\\': 0b010 ^ 0b001,\\n    }\\n    steps = {\\n        0: [\\'N\\'],\\n        1: [\\'A\\', \\'O\\', \\'E\\', \\'T\\'],\\n        2: [\\'N\\', \\'A\\', \\'O\\', \\'E\\', \\'AT\\', \\'OT\\', \\'ET\\'],\\n        3: states.keys(),\\n    }\\n    def flipLights(self, n: int, m: int) -> int:\\n        n, m = min(n, 3), min(m, 3)\\n        mask = (1 << n) - 1\\n        ans = set()\\n        for s in self.steps[m]:\\n            ans.add((0b111 ^ self.states[s]) & mask)\\n        return len(ans) \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    # Operations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)\\n    states = {\\n        \\'N\\': 0b000,\\n        \\'A\\': 0b111,\\n        \\'O\\': 0b101,\\n        \\'E\\': 0b010,\\n        \\'T\\': 0b001,\\n        \\'AT\\': 0b111 ^ 0b001,\\n        \\'OT\\': 0b101 ^ 0b001,\\n        \\'ET\\': 0b010 ^ 0b001,\\n    }\\n    steps = {\\n        0: [\\'N\\'],\\n        1: [\\'A\\', \\'O\\', \\'E\\', \\'T\\'],\\n        2: [\\'N\\', \\'A\\', \\'O\\', \\'E\\', \\'AT\\', \\'OT\\', \\'ET\\'],\\n        3: states.keys(),\\n    }\\n    def flipLights(self, n: int, m: int) -> int:\\n        n, m = min(n, 3), min(m, 3)\\n        mask = (1 << n) - 1\\n        ans = set()\\n        for s in self.steps[m]:\\n            ans.add((0b111 ^ self.states[s]) & mask)\\n        return len(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 663670,
                "title": "java-sol",
                "content": "Idea: only look at the first 3 balls, once we know the state of the first 3, we can know the rest\\n```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0)return 1;\\n        if(m==1){\\n            if(n==1)return 2;\\n            if(n==2)return 3;\\n            return 4;\\n        }\\n        if(m==2){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 7;\\n        }\\n        if(m>=3){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 8;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0)return 1;\\n        if(m==1){\\n            if(n==1)return 2;\\n            if(n==2)return 3;\\n            return 4;\\n        }\\n        if(m==2){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 7;\\n        }\\n        if(m>=3){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 8;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774929,
                "title": "dfs-memoization-bit-manipulation-java",
                "content": "# Code\\n```\\nclass Solution {\\n    private final Map<List<Integer>, Set<Integer>> memo = new HashMap<>();\\n    public int flipLights(int n, int presses) {\\n        int initialState = ((int) Math.pow(2, n)) - 1;\\n        List<Function<Integer, Integer>> buttons = initOperations(n);\\n        Set<Integer> states = new HashSet<>();\\n        dfs(initialState, presses, buttons, states);\\n        return states.size();\\n    }\\n\\n    private Set<Integer> dfs(int state, int presses, List<Function<Integer, Integer>> buttons, Set<Integer> states) {\\n        List<Integer> key = List.of(state, presses);\\n        if(memo.containsKey(key)) return memo.get(key);\\n        if(presses == 0) {\\n            states.add(state);\\n            memo.put(key, states);\\n            return states;\\n        }\\n        Set<Integer> uniqueStates = new HashSet<>();\\n        Set<Integer> newStates = new HashSet<>(states);\\n        for (Function<Integer, Integer> button: buttons) uniqueStates.add(button.apply(state));\\n        for(Integer newState: uniqueStates) newStates.addAll(dfs(newState, presses - 1, buttons, states));\\n        memo.put(key, newStates);\\n        return newStates;\\n    }\\n\\n    private List<Function<Integer, Integer>> initOperations(int n) {\\n        List<Function<Integer, Integer>> buttons = new ArrayList<>();\\n        int mask = (1 << n) - 1;\\n        buttons.add(i-> flipBits(i, mask));\\n        buttons.add(i-> flipOddBits(i, mask));\\n        buttons.add(i-> flipEvenBits(i, mask));\\n        buttons.add(i-> flipLabeledBits(i, mask));\\n        return buttons;\\n    }\\n\\n    private int flipBits(int state, int mask) { return (~state) & mask; }\\n\\n    private int flipOddBits(int state, int mask) { return (state ^ 0x55555555) & mask; }\\n\\n    private int flipEvenBits(int state, int mask) { return (state ^ 0xAAAAAAA) & mask; }\\n\\n    private int flipLabeledBits(int state, int mask) { return (state ^ 0x1249249) & mask; }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private final Map<List<Integer>, Set<Integer>> memo = new HashMap<>();\\n    public int flipLights(int n, int presses) {\\n        int initialState = ((int) Math.pow(2, n)) - 1;\\n        List<Function<Integer, Integer>> buttons = initOperations(n);\\n        Set<Integer> states = new HashSet<>();\\n        dfs(initialState, presses, buttons, states);\\n        return states.size();\\n    }\\n\\n    private Set<Integer> dfs(int state, int presses, List<Function<Integer, Integer>> buttons, Set<Integer> states) {\\n        List<Integer> key = List.of(state, presses);\\n        if(memo.containsKey(key)) return memo.get(key);\\n        if(presses == 0) {\\n            states.add(state);\\n            memo.put(key, states);\\n            return states;\\n        }\\n        Set<Integer> uniqueStates = new HashSet<>();\\n        Set<Integer> newStates = new HashSet<>(states);\\n        for (Function<Integer, Integer> button: buttons) uniqueStates.add(button.apply(state));\\n        for(Integer newState: uniqueStates) newStates.addAll(dfs(newState, presses - 1, buttons, states));\\n        memo.put(key, newStates);\\n        return newStates;\\n    }\\n\\n    private List<Function<Integer, Integer>> initOperations(int n) {\\n        List<Function<Integer, Integer>> buttons = new ArrayList<>();\\n        int mask = (1 << n) - 1;\\n        buttons.add(i-> flipBits(i, mask));\\n        buttons.add(i-> flipOddBits(i, mask));\\n        buttons.add(i-> flipEvenBits(i, mask));\\n        buttons.add(i-> flipLabeledBits(i, mask));\\n        return buttons;\\n    }\\n\\n    private int flipBits(int state, int mask) { return (~state) & mask; }\\n\\n    private int flipOddBits(int state, int mask) { return (state ^ 0x55555555) & mask; }\\n\\n    private int flipEvenBits(int state, int mask) { return (state ^ 0xAAAAAAA) & mask; }\\n\\n    private int flipLabeledBits(int state, int mask) { return (state ^ 0x1249249) & mask; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426981,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    n = min(n, 3);\\n    if (m == 0)\\n      return 1;\\n    if (m == 1)\\n      return vector{2, 3, 4}[n - 1];\\n    if (m == 2)\\n      return vector{2, 4, 7}[n - 1];\\n    return pow(2, n);\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n  def flipLights(self, n: int, m: int) -> int:\\n    n = min(n, 3)\\n\\n    if m == 0:\\n      return 1\\n    if m == 1:\\n      return [2, 3, 4][n - 1]\\n    if m == 2:\\n      return [2, 4, 7][n - 1]\\n\\n    return [2, 4, 8][n - 1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    n = min(n, 3);\\n    if (m == 0)\\n      return 1;\\n    if (m == 1)\\n      return vector{2, 3, 4}[n - 1];\\n    if (m == 2)\\n      return vector{2, 4, 7}[n - 1];\\n    return pow(2, n);\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n  def flipLights(self, n: int, m: int) -> int:\\n    n = min(n, 3)\\n\\n    if m == 0:\\n      return 1\\n    if m == 1:\\n      return [2, 3, 4][n - 1]\\n    if m == 2:\\n      return [2, 4, 7][n - 1]\\n\\n    return [2, 4, 8][n - 1]\\n```\n```Java []\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052235,
                "title": "python-sol-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem is to first check the base cases where n is 0 or presses is 0, and then to check for the different cases where n is 1, 2, or greater than 2 and presses is 1, 2, or greater than 2. Based on these cases, I can return the appropriate number of unique states that can be achieved by flipping the lights.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use if-else statements to check for the different cases of n and presses, and then return the appropriate number of unique states based on the cases.\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if n == 0 or presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            else:\\n                return 4\\n        if presses == 1:\\n            return 4\\n        if presses == 2:\\n            return 7\\n        return 8\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if n == 0 or presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            else:\\n                return 4\\n        if presses == 1:\\n            return 4\\n        if presses == 2:\\n            return 7\\n        return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584778,
                "title": "bulb-switcher-ii-very-easy-java-sol-with-proper-explanation",
                "content": "When any of p and n is 0, return 1\\nWhen p = 1:\\n        n = 1, the light has two states: on or off, so the answer is 2;\\n        n = 2, the light has 3 states: 00, 01, 10, so the answer is 3;\\n        n = 3, the light has 4 states: 000, 101, 010, 011, so the answer is 4;\\n        n = 4, the light has 4 states: 0000, 1010, 0101, 0110, so the answer is 4;\\n        Combining n = 3, n = 4, when n > 3, the answer is both 4.\\n\\nWhen p = 2:\\n        n = 1, the light has two states: on or off, so the answer is 2;\\n        n = 2, the light has 4 states: 11, 01, 10, 00, so the answer is 4;\\n        n = 3, the lamp has 7 states: 111, 101.010, 100, 000, 001, 110, so the answer is 7;\\n        Ditto, when n > 3, the answer is both 7.\\n\\n\\nWhen p = 3:\\n        n = 1, the light has two states: on or off, so the answer is 2;\\n        n = 2, the light has 4 states: 00, 01, 10, 11, so the answer is 4;\\n        n = 3, the light has 8 states: 111, 101.010, 100, 000, 001, 110, 011, so the answer is 8;\\n        Ditto, when n > 3, the answer is both 8.\\n\\nWhen p > 3, the answer should be the same as p = 3.\\n\\n\\n\\n```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        if (p == 0){\\n            return 1;\\n        }\\n            if(p==1){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 3;\\n                }\\n                else{\\n                    return 4;\\n                }\\n            }\\n        \\n        if(p==2){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 7;\\n                }\\n            }\\n        \\n        else{\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 8;\\n                }\\n            }       \\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        if (p == 0){\\n            return 1;\\n        }\\n            if(p==1){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 3;\\n                }\\n                else{\\n                    return 4;\\n                }\\n            }\\n        \\n        if(p==2){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 7;\\n                }\\n            }\\n        \\n        else{\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 8;\\n                }\\n            }       \\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172426,
                "title": "c-simple-approach-understanding-the-states",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k==0)\\n        return 1;\\n        \\n        if(n==1)\\n        return 2;\\n        if(n==2)\\n        {\\n            if(k==1)\\n            {\\n                return 3;\\n            }\\n            else\\n            {\\n                return 4;\\n            }\\n        }\\n        else\\n        {\\n            if(k==1)\\n            {\\n                return 4;\\n            }\\n            else if(k==2)\\n            {\\n                return 7;\\n            }\\n            else\\n            {\\n                return 8;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k==0)\\n        return 1;\\n        \\n        if(n==1)\\n        return 2;\\n        if(n==2)\\n        {\\n            if(k==1)\\n            {\\n                return 3;\\n            }\\n            else\\n            {\\n                return 4;\\n            }\\n        }\\n        else\\n        {\\n            if(k==1)\\n            {\\n                return 4;\\n            }\\n            else if(k==2)\\n            {\\n                return 7;\\n            }\\n            else\\n            {\\n                return 8;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909669,
                "title": "java-brute-force-with-optimization-then-o-1-solution",
                "content": "Here\\'s the matrix for all the possibilities of answers. \\n\\n```plain\\n       1  2  3  4 presses\\n1      2, 2, 2, 2\\n2      3, 4, 4, 4\\n3      4, 7, 8, 8\\n4      4, 7, 8, 8\\nlights\\n\\n* 0 press = 1\\n* for presses more than 4, if presses % 2 == 1 check 3 presses, otherwise 4 presses\\n```\\n\\nThere are countless ways to hard-code this matrix, but it is more important to know where these numbers come from.\\n\\nFirst is the brute-force solution. It takes about 1 second. The code uses a string to represent the lights and then switches the light with 4 buttons. Using a set to remove duplicated patterns.\\n\\n```java\\nint flipLights(int n, int presses) {\\n    Set<String> set = new HashSet<>();\\n    StringBuilder builder = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n        builder.append(\\'1\\');\\n    }\\n    set.add(builder.toString());\\n    for (int t = 0; t < presses; t++) {\\n        Set<String> newSet = new HashSet<>();\\n        for (String s : set) {\\n            // button 1\\n            char[] cs = s.toCharArray();\\n            for (int i = 0; i < length; i++) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 2\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 3\\n            cs = s.toCharArray();\\n            for (int i = 1; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 4\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 3) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n        }\\n        set = newSet;\\n    }\\n    return set.size();\\n}\\n```\\n\\nA quick optimization to reduce the time is to check how many lights we need to care about. There are 4 buttons, each button flips different lights. \\n\\n```plain\\nlight 1 button 1, 3, 4\\nlight 2 button 1, 2\\nlight 3 button 1, 3\\nlight 4 button 1, 2, 4\\nlight 5 button 1, 3\\nlight 6 button 1, 2\\nlight 7 button 1, 3, 4\\n...\\n```\\n\\nWhat we can see here is the first 4 lights have all the combinations of buttons. We can use these 4 lights as the sample to check all the patterns. \\n\\n```java\\nint flipLights(int n, int times) {\\n    n = Math.min(n, 4);\\n\\t// ...\\n}\\n```\\n\\nThis optimization gives me a solution with 55ms. It could be better, because 4 lights can be represented with a byte with 8 bits and you can flip the bit with xor bitwise operation.\\n\\nOn the other hand, there should be some way to reduce the presses as well. \\n\\nIf we think of the status of each light, **its final status depends on the count of operations to the light**. For example, 3 times means off, 4 times means on. If the count is an odd, the light is off, otherwise on.\\n\\nThis theory gives me an idea that **the order of the operations doesn\\'t matter** here since you only need to count the operations.\\n\\nAnother observation is **if the same button is pressed twice, the result doesn\\'t change**. Adding an even number to an odd number is still an odd number.\\n\\nWith these two observations, when considering the final status, the count of pressing each button could be simplified to\\n\\n* button 1: 0 times or once\\n* button 2: 0 times or once\\n* button 3: 0 times or once\\n* button 4: 0 times or once\\n\\nany even number becomes 0, any odd number becomes 1 here. In other words, **presses more than 4 can always be reduced to 4 or less**. \\n\\nThis is a big step but we need to think carefully about the button combinations here.\\n\\n```plain\\npresses\\n1: \\nunique buttons: {1}, {2}, {3}, {4}\\n\\n2: \\npress button x twice: {}\\nunique buttons: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\n\\n3: \\npress button x twice: {1}, {2}, {3}, {4}\\nunique buttons: {1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}\\n\\n4: \\npress button x 4 times: {}\\npress button x twice: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\nunique buttons: {1, 2, 3, 4}\\n\\n5: same as 3\\n6: same as 4\\n7: same as 3\\n...\\n```\\n\\nSome people would continue to find the patterns to reduce the combinations, I think it is good enough since we have only 4 cases here.\\n\\nThe code to calculate the patterns. This time I also add bit manipulation to do the flipping.\\n\\n```java\\npublic int flipLights(int n, int presses) {\\n    if (presses == 0) return 1;\\n\\n    int maxPresses = presses;\\n    if (presses > 4) {\\n        maxPresses = (presses % 2 == 1 ? 3 : 4);\\n    }\\n    return countPatterns(Math.min(n, 4), maxPresses);\\n}\\n\\nint countPatterns(int lights, int maxPresses) {\\n    if (maxPresses == 1) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4)));\\n    }\\n    if (maxPresses == 2) {\\n        return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n                Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4)));\\n    }\\n    if (maxPresses == 3) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4),\\n                Arrays.asList(1, 2, 3), Arrays.asList(1, 2, 4), Arrays.asList(1, 3, 4), Arrays.asList(2, 3, 4)));\\n    }\\n    // 4\\n    return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n            Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4), Arrays.asList(1, 2, 3, 4)));\\n}\\n\\nint countPatterns(int lights, List<List<Integer>> combinations) {\\n    int base = (1 << lights) - 1;\\n    Set<Integer> patterns = new HashSet<>();\\n    for (List<Integer> instructions : combinations) {\\n        patterns.addAll(pressButtons(base, instructions));\\n    }\\n    return patterns.size();\\n}\\n\\nprivate Set<Integer> pressButtons(int base, List<Integer> instructions) {\\n    Set<Integer> prev = new HashSet<>();\\n    prev.add(base);\\n    for (Integer button : instructions) {\\n        Set<Integer> next = new HashSet<>();\\n        for (Integer n : prev) {\\n            if (button == 1) {\\n\\t\\t\\t    // if we have only 3 lights, we need 0b111 here so using base as the mask\\n                next.add(n ^ (base & 0b1111));\\n            } else if (button == 2) {\\n                next.add(n ^ (base & 0b0101));\\n            } else if (button == 3) {\\n                next.add(n ^ (base & 0b1010));\\n            } else { // 4\\n                next.add(n ^ (base & 0b1001));\\n            }\\n        }\\n        prev = next;\\n    }\\n    return prev;\\n}\\n```\\n\\nThis solution only takes 5ms. In principal we don\\'t need to do optimization any more. If you want to use some hard-coded answers, do a simple 4x4 loop to generate the matrix at the first of this post.\\n\\nHope this post helps.",
                "solutionTags": [],
                "code": "```plain\\n       1  2  3  4 presses\\n1      2, 2, 2, 2\\n2      3, 4, 4, 4\\n3      4, 7, 8, 8\\n4      4, 7, 8, 8\\nlights\\n\\n* 0 press = 1\\n* for presses more than 4, if presses % 2 == 1 check 3 presses, otherwise 4 presses\\n```\n```java\\nint flipLights(int n, int presses) {\\n    Set<String> set = new HashSet<>();\\n    StringBuilder builder = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n        builder.append(\\'1\\');\\n    }\\n    set.add(builder.toString());\\n    for (int t = 0; t < presses; t++) {\\n        Set<String> newSet = new HashSet<>();\\n        for (String s : set) {\\n            // button 1\\n            char[] cs = s.toCharArray();\\n            for (int i = 0; i < length; i++) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 2\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 3\\n            cs = s.toCharArray();\\n            for (int i = 1; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 4\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 3) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n        }\\n        set = newSet;\\n    }\\n    return set.size();\\n}\\n```\n```plain\\nlight 1 button 1, 3, 4\\nlight 2 button 1, 2\\nlight 3 button 1, 3\\nlight 4 button 1, 2, 4\\nlight 5 button 1, 3\\nlight 6 button 1, 2\\nlight 7 button 1, 3, 4\\n...\\n```\n```java\\nint flipLights(int n, int times) {\\n    n = Math.min(n, 4);\\n\\t// ...\\n}\\n```\n```plain\\npresses\\n1: \\nunique buttons: {1}, {2}, {3}, {4}\\n\\n2: \\npress button x twice: {}\\nunique buttons: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\n\\n3: \\npress button x twice: {1}, {2}, {3}, {4}\\nunique buttons: {1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}\\n\\n4: \\npress button x 4 times: {}\\npress button x twice: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\nunique buttons: {1, 2, 3, 4}\\n\\n5: same as 3\\n6: same as 4\\n7: same as 3\\n...\\n```\n```java\\npublic int flipLights(int n, int presses) {\\n    if (presses == 0) return 1;\\n\\n    int maxPresses = presses;\\n    if (presses > 4) {\\n        maxPresses = (presses % 2 == 1 ? 3 : 4);\\n    }\\n    return countPatterns(Math.min(n, 4), maxPresses);\\n}\\n\\nint countPatterns(int lights, int maxPresses) {\\n    if (maxPresses == 1) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4)));\\n    }\\n    if (maxPresses == 2) {\\n        return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n                Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4)));\\n    }\\n    if (maxPresses == 3) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4),\\n                Arrays.asList(1, 2, 3), Arrays.asList(1, 2, 4), Arrays.asList(1, 3, 4), Arrays.asList(2, 3, 4)));\\n    }\\n    // 4\\n    return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n            Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4), Arrays.asList(1, 2, 3, 4)));\\n}\\n\\nint countPatterns(int lights, List<List<Integer>> combinations) {\\n    int base = (1 << lights) - 1;\\n    Set<Integer> patterns = new HashSet<>();\\n    for (List<Integer> instructions : combinations) {\\n        patterns.addAll(pressButtons(base, instructions));\\n    }\\n    return patterns.size();\\n}\\n\\nprivate Set<Integer> pressButtons(int base, List<Integer> instructions) {\\n    Set<Integer> prev = new HashSet<>();\\n    prev.add(base);\\n    for (Integer button : instructions) {\\n        Set<Integer> next = new HashSet<>();\\n        for (Integer n : prev) {\\n            if (button == 1) {\\n\\t\\t\\t    // if we have only 3 lights, we need 0b111 here so using base as the mask\\n                next.add(n ^ (base & 0b1111));\\n            } else if (button == 2) {\\n                next.add(n ^ (base & 0b0101));\\n            } else if (button == 3) {\\n                next.add(n ^ (base & 0b1010));\\n            } else { // 4\\n                next.add(n ^ (base & 0b1001));\\n            }\\n        }\\n        prev = next;\\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554733,
                "title": "c-bfs-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string rec( string temp , int k ){\\n        \\n        for( int i = 0 ; k == 1 && i < temp.length() ; i++ ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1;}\\n        }\\n        \\n        for( int i = 0 ; k == 2 && i < temp.length(); i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i = 1 ; k == 3 && i < temp.length() ; i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i =0 ; k == 4 && 3*i < temp.length() ; i++ ){\\n            if( temp[3*i] ){ temp[3*i] = 0; }\\n            else{ temp[3*i] = 1 ; }\\n        }\\n \\n        return temp;\\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        string r(n,1);\\n        unordered_map<string,int> umap;\\n        queue<string> q;\\n        q.push(r);\\n        int depth = 0;\\n        int prev_size = 0;\\n        while( depth < presses  ){\\n            int size = q.size();\\n            umap.clear();\\n            while( size-- ){\\n                string s = q.front(); q.pop();\\n                for( int k = 1 ; k <= 4 ; k++ ){\\n                    string a = rec(s , k );\\n                    umap[a] = 1;\\n                    q.push(a);\\n                }\\n            }\\n            if( umap.size() == prev_size ){\\n                break;\\n            }\\n            prev_size = umap.size();\\n            \\n            depth++;\\n               \\n        }\\n        \\n        \\n        \\n        return umap.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string rec( string temp , int k ){\\n        \\n        for( int i = 0 ; k == 1 && i < temp.length() ; i++ ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1;}\\n        }\\n        \\n        for( int i = 0 ; k == 2 && i < temp.length(); i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i = 1 ; k == 3 && i < temp.length() ; i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i =0 ; k == 4 && 3*i < temp.length() ; i++ ){\\n            if( temp[3*i] ){ temp[3*i] = 0; }\\n            else{ temp[3*i] = 1 ; }\\n        }\\n \\n        return temp;\\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        string r(n,1);\\n        unordered_map<string,int> umap;\\n        queue<string> q;\\n        q.push(r);\\n        int depth = 0;\\n        int prev_size = 0;\\n        while( depth < presses  ){\\n            int size = q.size();\\n            umap.clear();\\n            while( size-- ){\\n                string s = q.front(); q.pop();\\n                for( int k = 1 ; k <= 4 ; k++ ){\\n                    string a = rec(s , k );\\n                    umap[a] = 1;\\n                    q.push(a);\\n                }\\n            }\\n            if( umap.size() == prev_size ){\\n                break;\\n            }\\n            prev_size = umap.size();\\n            \\n            depth++;\\n               \\n        }\\n        \\n        \\n        \\n        return umap.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535818,
                "title": "python-3-math-o-1",
                "content": "- There are total 8 different status maximum\\n- Give some test case and play around, you will find the pattern for smaller inputs\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if not presses: \\n            return 1\\n        elif n < 3:\\n            if n == 1: \\n                return 2\\n            elif presses >= 2:\\n                return 4\\n            else:\\n                return 3\\n        else:\\n            if presses >= 3: \\n                return 8\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 4\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if not presses: \\n            return 1\\n        elif n < 3:\\n            if n == 1: \\n                return 2\\n            elif presses >= 2:\\n                return 4\\n            else:\\n                return 3\\n        else:\\n            if presses >= 3: \\n                return 8\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420284,
                "title": "c-faster-than-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(p==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return p==1?3:4;\\n        else return p==1?4:p==2?7:8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(p==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return p==1?3:4;\\n        else return p==1?4:p==2?7:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069221,
                "title": "hard-coded-python-with-picture",
                "content": "![image](https://assets.leetcode.com/users/images/c0886d27-c976-40a0-b01d-d5769caec17c_1613532414.2023501.png)\\n\\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if m == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        \\n        else:\\n            if m==1:\\n                return 4\\n            if m==2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if m == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        \\n        else:\\n            if m==1:\\n                return 4\\n            if m==2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828794,
                "title": "golang-o-1-0ms-solution-with-explanation",
                "content": "```go\\nfunc flipLights(n int, m int) int {\\n    // state1: all on\\n    // state2: all off\\n    // state3: even on odd off\\n    // state4: even off odd on\\n    // state5: 3k + 1 on others off\\n    // state6: 3k + 1 off others on\\n    // state7: even on odd off and press button4 once\\n    // state8: even off odd on and press button4 once\\n    if m == 0 || n == 0 {\\n        return 1\\n    }\\n    switch n {\\n    case 1:\\n        // only two status on or off\\n        return 2\\n    case 2:\\n        // button3 & button4 are the same\\n        if m == 1 {\\n            // state 2,3,4\\n            return 3\\n        }\\n        // state 1,2,3,4\\n        return 4\\n    }\\n    // n \\u2265 3 here\\n    switch m {\\n    case 1:\\n        // state 2,3,4,6\\n        return 4\\n    case 2:\\n        // state 1,2,3,4,5,7,8\\n        return 7\\n    }\\n    return 8\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc flipLights(n int, m int) int {\\n    // state1: all on\\n    // state2: all off\\n    // state3: even on odd off\\n    // state4: even off odd on\\n    // state5: 3k + 1 on others off\\n    // state6: 3k + 1 off others on\\n    // state7: even on odd off and press button4 once\\n    // state8: even off odd on and press button4 once\\n    if m == 0 || n == 0 {\\n        return 1\\n    }\\n    switch n {\\n    case 1:\\n        // only two status on or off\\n        return 2\\n    case 2:\\n        // button3 & button4 are the same\\n        if m == 1 {\\n            // state 2,3,4\\n            return 3\\n        }\\n        // state 1,2,3,4\\n        return 4\\n    }\\n    // n \\u2265 3 here\\n    switch m {\\n    case 1:\\n        // state 2,3,4,6\\n        return 4\\n    case 2:\\n        // state 1,2,3,4,5,7,8\\n        return 7\\n    }\\n    return 8\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812466,
                "title": "solution-without-enumerating-each-case-generalized-for-this-kind-of-question",
                "content": "At the first glance, the question seems to be quite trivial since for n larger than some number, the answer will be fixed.\\n\\nBut since the question is about dividing something into several groups and do operation for some of these groups. We can generalize it into XOR operation to a initial number.\\n\\nThe detail is:\\n1. We group these bulbs into four groups which can only be changed by operation 2 or 3, or 2,4 or 3,4.\\n2. For each group, we define the initial state as 1 and store it in a set, so the initial state is \\'1111\\' which is 15\\n3. For each operation, we changes state by XOR the current state with a number corresponding to that operation. For example, the operation 2 which flip the even number bulbs can be expressed as \\'1010\\' which means to change the group1 and group3.\\n4. Get all possibilities of the next step and save it as current state.\\n\\n```python\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if n==0:\\n            return 0\\n        \\n        ops = [15, 10, 5, 3]\\n        status = set([15])\\n        count = 0\\n        while count<m and len(status)<16:\\n            nstatus = set()\\n            for s in status:\\n                for op in ops:\\n                    nstatus.add(s^op)\\n            status = nstatus\\n            count+=1\\n        \\n\\t\\t# focus on the last n bits of the current status\\n        status = set([bin(s)[2:].rjust(4,\\'0\\')[-n:] for s in status])\\n        \\n        return len(status)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if n==0:\\n            return 0\\n        \\n        ops = [15, 10, 5, 3]\\n        status = set([15])\\n        count = 0\\n        while count<m and len(status)<16:\\n            nstatus = set()\\n            for s in status:\\n                for op in ops:\\n                    nstatus.add(s^op)\\n            status = nstatus\\n            count+=1\\n        \\n\\t\\t# focus on the last n bits of the current status\\n        status = set([bin(s)[2:].rjust(4,\\'0\\')[-n:] for s in status])\\n        \\n        return len(status)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774709,
                "title": "c-with-comments-on-each-base-case",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if ((m == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (m == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (m >= 2);\\n        }\\n        // n >= 3, m >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (m >= 3);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if ((m == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (m == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (m >= 2);\\n        }\\n        // n >= 3, m >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (m >= 3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491184,
                "title": "python3-find-regular-parttern",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        n = min(n, 3)\\n        return min(1<<n, 1+m*n)\\n        # Test cases one by one, u can find the regular pattern\\n        # n > 2, m = 1, res = 4; m = 2, res => 7; m >= 3 res = 8.\\n        # n = 2, m = 1, res = 3; m >= 2, res = 4.\\n        # n = 1, m >= 1, re = 2.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        n = min(n, 3)\\n        return min(1<<n, 1+m*n)\\n        # Test cases one by one, u can find the regular pattern\\n        # n > 2, m = 1, res = 4; m = 2, res => 7; m >= 3 res = 8.\\n        # n = 2, m = 1, res = 3; m >= 2, res = 4.\\n        # n = 1, m >= 1, re = 2.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480133,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    if (n == 0) return 0;\\n    if (n >= 1 && m == 0) return 1;\\n    if (n == 1)\\n      return 2;\\n    else if (n == 2 && m == 1)\\n      return 3;\\n    else if (n == 2 && m > 1)\\n      return 4;\\n    else if (n >= 3 && m == 1)\\n      return 4;\\n    else if (n >= 3 && m == 2)\\n      return 7;\\n    else\\n      return 8;\\n  }\\n};\\n```\\n### The idea is :\\n* Every even Flips will cancel each other out\\n* Every Flips 1 = Flips 2 + Flips 3\\n* When n < 3  Flips 3 = Flips 4  \\n### So there are only 8 condition:\\n* even Flips 4\\n* even Flips 4 + Flips 1\\n* even Flips 4 + Flips 2\\n* even Flips 4 + Flips 3\\n* odd Flips 4\\n* odd Flips 4 + Flips 1\\n* odd Flips 4 + Flips 2\\n* odd Flips 4 + Flips 3\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    if (n == 0) return 0;\\n    if (n >= 1 && m == 0) return 1;\\n    if (n == 1)\\n      return 2;\\n    else if (n == 2 && m == 1)\\n      return 3;\\n    else if (n == 2 && m > 1)\\n      return 4;\\n    else if (n >= 3 && m == 1)\\n      return 4;\\n    else if (n >= 3 && m == 2)\\n      return 7;\\n    else\\n      return 8;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195396,
                "title": "c-o-1-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {        \\n        static const int t[4][4] = {\\n            {},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}\\n        };\\n        \\n        m = min(3, m);\\n        n = min(3, n);\\n        \\n        return t[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {        \\n        static const int t[4][4] = {\\n            {},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}\\n        };\\n        \\n        m = min(3, m);\\n        n = min(3, n);\\n        \\n        return t[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165143,
                "title": "c-bit-manipulation-solution-with-comments-somewhat-complex",
                "content": "```\\n    int flipLights(int n, int m) {\\n        \\n        // The bulb operations will always end up the same for each group of 4 bulbs\\n        // Therefore, we have a max of 2^4 possible states or less for smaller n\\n        \\n        int states;\\n        if (n > 3)\\n            states = pow(2, 4);\\n        else\\n            states = pow(2, n);\\n        \\n        // There are 4 possible flips, 15 = 1111, 10 = 1010, 5 = 0101, 1 = 0001\\n        int flips[4] = {15, 10, 5, 1};\\n        \\n        // Initially we have only one state possible out of 16 (for n > 3): 1000000000000000\\n        int lastStates = (1 << (states - 1)), newStates = 0;\\n        \\n        // Iterate through all bulb operations (I think this can be reduced so it doesn\\'t have to go to m)\\n        for (int i = 0; i != m; ++i, lastStates = newStates, newStates = 0)\\n            for (int j = 0; j != states; ++j)\\n                if ((lastStates & (1 << j)) == (1 << j))            // if state j was a possibility in the last iteration\\n                    for (int k = 0; k != 4; ++k)                    // perform each bulb operation and flag that the state is now possible\\n                        newStates  |= (1 << ((states - 1) & (j ^ flips[k])));\\n        \\n        // count up our bits/states\\n        int count = 0;\\n        for (int i = 0; i != states; count += (lastStates & (1 << i)) == (1 << i), ++i);\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int flipLights(int n, int m) {\\n        \\n        // The bulb operations will always end up the same for each group of 4 bulbs\\n        // Therefore, we have a max of 2^4 possible states or less for smaller n\\n        \\n        int states;\\n        if (n > 3)\\n            states = pow(2, 4);\\n        else\\n            states = pow(2, n);\\n        \\n        // There are 4 possible flips, 15 = 1111, 10 = 1010, 5 = 0101, 1 = 0001\\n        int flips[4] = {15, 10, 5, 1};\\n        \\n        // Initially we have only one state possible out of 16 (for n > 3): 1000000000000000\\n        int lastStates = (1 << (states - 1)), newStates = 0;\\n        \\n        // Iterate through all bulb operations (I think this can be reduced so it doesn\\'t have to go to m)\\n        for (int i = 0; i != m; ++i, lastStates = newStates, newStates = 0)\\n            for (int j = 0; j != states; ++j)\\n                if ((lastStates & (1 << j)) == (1 << j))            // if state j was a possibility in the last iteration\\n                    for (int k = 0; k != 4; ++k)                    // perform each bulb operation and flag that the state is now possible\\n                        newStates  |= (1 << ((states - 1) & (j ^ flips[k])));\\n        \\n        // count up our bits/states\\n        int count = 0;\\n        for (int i = 0; i != states; count += (lastStates & (1 << i)) == (1 << i), ++i);\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 157343,
                "title": "explained-literally-just-a-bunch-of-if-statements-because-math",
                "content": "So you start with the state 11111.... (n number of 1\\'s), m = 0\\nThen, there\\'s 4 possible states when m = 1\\n* 00000\\n* 10101\\n* 01010\\n* 01101\\n\\nAnd then, when m = 2, there\\'s 7 states:\\n* 11111\\n* 00000\\n* 10101\\n* 01010\\n* 10010\\n* 00111\\n* 11000\\n\\nAnd then you have 8 total states for the next one, and that wraps up all the states. (There can only be 8, because the sequence repeats itself every 3 numbers)\\n\\nThere you have it, ladies and gentleman.\\n\\n\\n```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        if m == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2 and m == 1:\\n            return 3\\n        if n == 2 and m > 1:\\n            return 4\\n        if m == 1:\\n            return 4\\n        if m == 2:\\n            return 7\\n        return 8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        if m == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2 and m == 1:\\n            return 3\\n        if n == 2 and m > 1:\\n            return 4\\n        if m == 1:\\n            return 4\\n        if m == 2:\\n            return 7\\n        return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107266,
                "title": "lazy-generalizable-o-1-python-solution-with-explanation",
                "content": "Operations:\\n\\n\\n1. toggle all\\n2. toggle even\\n3. toggle odd\\n4. toggle 1+3k\\n\\nSince each operation always toggles the same set of lights, each operation cancels itself out when applied twice (or an even number of times). Thus we can consider each operation to be like a state, which can be \"ON\" or \"OFF\".  There are 4 individual \"operation states\", which combined yield an upper bound of 2^4 \"bulb states\" (since \"bulb states\" are a function of the operation states). \\n\\nBut since operation 1 (toggle all) is equivalent to operations 2+3, (odd+even) it is redundant unless constrained by # of operations, there are only 3 unique operations and 2^3 = 8 possible \"operation states\". (We can only reach 4 unique \"bulb states\" using any number of operations 1,2,3, i.e. the bulb states [\"all off\", \"even on\", \"odd on\", \"all on\"]), .\\n\\nSince we can reach any of the 2^3 \"operation states\" in at most 3 operations, we are free to limit `m` to a max of 3, and consider only the arity of values of `m` >3 (since we need *exactly*, not *at least* `m` operations).\\n\\nBut, again since operations 2+3 (even + odd) are equivalent to operation 1 (toggle all), we can also ignore the arity for  `m>3` values, since we can always change arity of `m` by changing operation 1 with 2+3 or viceversa.\\n\\nFinally, for each of the unique combination of the 2^3 \"operation states\", we can find the 8 sets of integers which it affects (i.e. all the integers in this set will have the same value):\\n\\n* : {}\\n* 1: odd integers\\n* 2: even integers\\n* 1+2: all integers\\n* 3: integers n s.t. n%3==1\\n* 3+1 integers n s.t. n%3==1 and n%2==1\\n* 3+2: integers n s.t. n%3==1 and n%2==0\\n* 3+1+2: integers n s.t. n%3!=1\\n\\n\\nSince when n=3, there is at least one integer represented in each of the sets above, we can restrict n to a max 3 (any higher index will be in an equivalence class represented by one of the numbers <=3 regardless of which \"operation states\" are \"ON\").\\n\\nSince we can limit both n and m to a constant, we can do an exhaustive search in constant time to find the number of unique bulb-states:\\n\\n```\\nclass Solution(object):\\n        \\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        states=set()\\n        n=min(3,n)\\n        m=min(m,3)\\n        def flips(op, i):\\n            return op==0 or\\\\\\n                    (op==1 and i%2==1) or\\\\\\n                    (op==2 and i%2==0) or\\\\\\n                    (op==3 and i%3==0)\\n        \\n        for B in xrange(1<<4):\\n            nflips=sum((B>>i)&1 for i in xrange(1<<4))\\n            if nflips>m or nflips%2 != m%2:\\n                continue\\n            curr=\"\"\\n            for i in xrange(n):\\n                d=sum(flips(op, i) for op in xrange(4) if (B>>op)&1)\\n                curr+=\"01\"[d%2]\\n            states.add(curr)\\n                \\n        return len(states)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n        \\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        states=set()\\n        n=min(3,n)\\n        m=min(m,3)\\n        def flips(op, i):\\n            return op==0 or\\\\\\n                    (op==1 and i%2==1) or\\\\\\n                    (op==2 and i%2==0) or\\\\\\n                    (op==3 and i%3==0)\\n        \\n        for B in xrange(1<<4):\\n            nflips=sum((B>>i)&1 for i in xrange(1<<4))\\n            if nflips>m or nflips%2 != m%2:\\n                continue\\n            curr=\"\"\\n            for i in xrange(n):\\n                d=sum(flips(op, i) for op in xrange(4) if (B>>op)&1)\\n                curr+=\"01\"[d%2]\\n            states.add(curr)\\n                \\n        return len(states)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107280,
                "title": "intuitive-solution",
                "content": "First of all, this solution is not mine, I got it after studying cuiaoxiang's contest solution.\\n\\nThis solution is based on the observation that any result from m > 4 can also be retrieved from a combination while m <= 4. This is because taking a same action twice is same as not taking it, while taking a same action three times is same as taking it one time, etc.\\nWhile m <= 4, we should get 16 different combinations, and we can use a binary number to help us track whether we are taking operation 1), 2), 3) or 4)\\n\\nIn this solution, we will check each of 16 combinations. In each combination, we firstly check how many operations will be taken. If the count > m, then we will not continue in current loop.  If count <= m, then we also need to check if m%2 == count%2. Why? Please see comments in the code....\\nAfter that, We can construct an array with len(n), because n <= 1000, this should not cause any boundary cases. We will apply each operation when the binary number has a 1 in the corresponding digit..\\nWe use a HashSet to catch all possible results and the size of result set should be our output.\\nIt costs me few hours to understand this solution, and I think it is more intuitive for me.....So here it is.\\n```\\npublic int flipLights(int n, int m) {\\n        HashSet<List<Boolean>> hs = new HashSet<>();\\n        \\n        for(int k = 0; k < 16; k++){\\n            //n bulbs\\n            Boolean[] curr = new Boolean[n];\\n            Arrays.fill(curr, false);\\n            int count = 0;\\n            \\n            for(int i = 0; i < 4; i++){\\n                //check how many methods will be used in this loop\\n                if( (k&(1<<i)) > 0 )  count++;  \\n            }\\n            \\n            //if we are going to pick more than m methods, then we skip current loop\\n            if(count > m) continue;\\n            //count < m will also work, since we can apply a same method multiple times\\n            //so that we need to check if m and count are both even or both odd.\\n            //duplicate operations + count = m\\n            //if count = 2, m = 3, then there is no way that we can use 3 operations to achieve the same effect of two operations\\n            //if count = 1, m = 3, then we can apply a method twice to achieve the same result\\n            //if count = 1, m = 2, then there is no way that we can use 1 operation to achieve the same effect of two operations\\n            //if count = 2 or count = 0, m = 2, we can just apply two methods or a method twice to achieve count = 2 or count = 0\\n            if( count%2 != m%2 ) continue;\\n            \\n            if( (k&1) > 0){\\n                for(int i = 0; i < n; i++) curr[i] = !curr[i]; \\n            }\\n            \\n            if( (k&2) > 0){\\n                for(int i = 0; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&4) > 0){\\n                for(int i = 1; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&8) > 0){\\n                //3k+1, k = 0,1,2 => now we are 0 based, so it is 3k, k = 0,1,2\\n                for(int i = 0; i < n; i += 3 ) curr[i] = !curr[i];\\n            }            \\n            List<Boolean> list = Arrays.asList(curr);\\n            hs.add(list);\\n        }\\n        \\n        //System.out.println(hs);\\n        return hs.size();\\n }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n        HashSet<List<Boolean>> hs = new HashSet<>();\\n        \\n        for(int k = 0; k < 16; k++){\\n            //n bulbs\\n            Boolean[] curr = new Boolean[n];\\n            Arrays.fill(curr, false);\\n            int count = 0;\\n            \\n            for(int i = 0; i < 4; i++){\\n                //check how many methods will be used in this loop\\n                if( (k&(1<<i)) > 0 )  count++;  \\n            }\\n            \\n            //if we are going to pick more than m methods, then we skip current loop\\n            if(count > m) continue;\\n            //count < m will also work, since we can apply a same method multiple times\\n            //so that we need to check if m and count are both even or both odd.\\n            //duplicate operations + count = m\\n            //if count = 2, m = 3, then there is no way that we can use 3 operations to achieve the same effect of two operations\\n            //if count = 1, m = 3, then we can apply a method twice to achieve the same result\\n            //if count = 1, m = 2, then there is no way that we can use 1 operation to achieve the same effect of two operations\\n            //if count = 2 or count = 0, m = 2, we can just apply two methods or a method twice to achieve count = 2 or count = 0\\n            if( count%2 != m%2 ) continue;\\n            \\n            if( (k&1) > 0){\\n                for(int i = 0; i < n; i++) curr[i] = !curr[i]; \\n            }\\n            \\n            if( (k&2) > 0){\\n                for(int i = 0; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&4) > 0){\\n                for(int i = 1; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&8) > 0){\\n                //3k+1, k = 0,1,2 => now we are 0 based, so it is 3k, k = 0,1,2\\n                for(int i = 0; i < n; i += 3 ) curr[i] = !curr[i];\\n            }            \\n            List<Boolean> list = Arrays.asList(curr);\\n            hs.add(list);\\n        }\\n        \\n        //System.out.println(hs);\\n        return hs.size();\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107281,
                "title": "a-c-solution-using-bit-manipulation",
                "content": "My solution does not leverage much math insights into the problem, but rather apply bit manipulation to simulate the process to find all states after m steps.\\n\\nNevertheless, I do use some insights to reduce the number of bits used to represent light state from n to 3. This is because the n lights can be grouped into the following 3 groups. As lights within the same group will not have a different on/off state through out the m operations, their share one bit to represent their states.\\n\\n* group 1: whose with odd index representable as 3k+1, use the last bit in a char.\\n\\n\\n* group 2: whose with even index use the second last bit in a char.\\n\\n* group 3: whose with odd index, but not representable as 3k+1, use the third last bit in a char.\\n\\nWhen a button is pressed, it is flipping the state (and the corresponding bit ) of one or more groups:\\n\\n* button 1 flips all 3 groups, we can do XOR 7 on the old state to get the new state.\\n\\n* button 2 flips group 2, do XOR 2 on the old state to get the new state.\\n\\n* button 3 flips group 1 and group 3, do XOR 5\\n\\n* button 4 flips group 1, do XOR 1\\n\\nFor small n such as 1 and 2, there maybe zero lights in some of the 3 groups, and we setup mask to disregard the corresponding bits every time we simulate the flip.\\n\\nThe finally observation is that the number of states cannot be more than 8, so once we get a set of 8 states at some step, we do not need to simulate all the remaining ones.\\n\\nThe code in C++ is in the following:\\n\\n\\n\\n\\n    int flipLights(int n, int m) {\\n        char s0,mask;\\n        const int maxStates = 8;\\n        vector<char> buttons = {1,2,5,7};\\n\\n        switch(n){\\n            case 1:\\n                s0 = mask = 1;\\n                break;\\n            case 2:\\n                s0 = mask = 3;\\n                break;\\n            default:\\n                s0 = mask = 7;\\n        }\\n        \\n        set<char> states;\\n        states.insert(s0);\\n        for (int i = 1; i<=m && states.size() < maxStates; i++){\\n            set <char> newStates;\\n            for (auto s : states)\\n                for (auto b: buttons) \\n                    newStates.insert(s^b&mask);\\n            states = newStates;\\n        }\\n        \\n        return states.size();\\n    }\\n\\nAlthough this approach is slower than the other ones with pure math insights, it is generic and justifies this problem as a valid coding problem.",
                "solutionTags": [],
                "code": "My solution does not leverage much math insights into the problem, but rather apply bit manipulation to simulate the process to find all states after m steps.\\n\\nNevertheless, I do use some insights to reduce the number of bits used to represent light state from n to 3. This is because the n lights can be grouped into the following 3 groups. As lights within the same group will not have a different on/off state through out the m operations, their share one bit to represent their states.\\n\\n* group 1: whose with odd index representable as 3k+1, use the last bit in a char.\\n\\n\\n* group 2: whose with even index use the second last bit in a char.\\n\\n* group 3: whose with odd index, but not representable as 3k+1, use the third last bit in a char.\\n\\nWhen a button is pressed, it is flipping the state (and the corresponding bit ) of one or more groups:\\n\\n* button 1 flips all 3 groups, we can do XOR 7 on the old state to get the new state.\\n\\n* button 2 flips group 2, do XOR 2 on the old state to get the new state.\\n\\n* button 3 flips group 1 and group 3, do XOR 5\\n\\n* button 4 flips group 1, do XOR 1\\n\\nFor small n such as 1 and 2, there maybe zero lights in some of the 3 groups, and we setup mask to disregard the corresponding bits every time we simulate the flip.\\n\\nThe finally observation is that the number of states cannot be more than 8, so once we get a set of 8 states at some step, we do not need to simulate all the remaining ones.\\n\\nThe code in C++ is in the following:\\n\\n\\n\\n\\n    int flipLights(int n, int m) {\\n        char s0,mask;\\n        const int maxStates = 8;\\n        vector<char> buttons = {1,2,5,7};\\n\\n        switch(n){\\n            case 1:\\n                s0 = mask = 1;\\n                break;\\n            case 2:\\n                s0 = mask = 3;\\n                break;\\n            default:\\n                s0 = mask = 7;\\n        }\\n        \\n        set<char> states;\\n        states.insert(s0);\\n        for (int i = 1; i<=m && states.size() < maxStates; i++){\\n            set <char> newStates;\\n            for (auto s : states)\\n                for (auto b: buttons) \\n                    newStates.insert(s^b&mask);\\n            states = newStates;\\n        }\\n        \\n        return states.size();\\n    }\\n\\nAlthough this approach is slower than the other ones with pure math insights, it is generic and justifies this problem as a valid coding problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 107288,
                "title": "python-o-1-with-detailed-analysis",
                "content": "First of all, we can just discuss the case that `n = 1,2,3,4,5,6`, because the lights repeat the pattern of first 6 bulbs. Remarkably, the 5th and 6th bulb is the same as 4th and 3th respectively, so we just need to discuss the case `n = 1,2,3,4`. When `n>4`, it is the same as `n=4`.\\n\\nIf you are familiar with group theory, this question is quite simple. We now have four operations `A` (flip All), `E` (flip Even), `O` (flip Odd), `K` (flip 3k+1). Here we denote identical operation (the operation that changes nothing) with `I`. It's obvious that all operations are commutative, the order in which they are performed does not matter. Additionally, we have some other basic rules here, such as perform the same operation twice is equal to do nothing, and flipping all and then flipping even is equal to just flipping Odd. Formally, these rule can be written as\\n\\n```python\\nAA=EE=OO=KK=I    # two same operation is equal to Identical operation\\nAE=O             # flipping all and even is equal to flipping odd\\nAO=E             # flipping all and odd is equal to flipping even\\nOE=A             # flipping odd and even is equal to flipping all\\n```\\n\\n## When `n=1`\\nIn this trivial case, the answer is always 2.\\n\\n## When `n=2`\\n\\nIn this case, the operation K is equal to operation O, so we actually have three operations `A, O, E`. \\nIf `m=1`, three status by performing `A, O, E`. We can draw a table to count the status. The table below shows where can we reach from the identical operation (the initial status is equal to having performed an identical operation).\\n```\\n___|_A___O___E_\\n I | A   O   E \\n```\\nIf `m=2`, we draw table below. In the case `m=1`, we can reach `A, O, E`, after performing one more operation we can reach `A, O, E, I`, four status.\\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n```\\nif `m=3`, we show go one operation far from `m=2`. Again, we can reach four status `A, O, E, I `.\\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n I | A   O   E\\n```\\nIf `m>3`, the table will be the same as `m=3`.\\n\\n## When `n>=3`\\nNow we have four distinct operations `A, O, E, K `.\\nIf `m=1`, four kinds of status, `A, O, E, K `\\n```\\n___|_A__O__E__K__\\n I | A  O  E  K \\n```\\nif `m=2`, we have 7 kinds of status, `I, A, O, E, AK, EK, OK`. Here, `AK` means perform operation `A` and `K` in order. `EK, OK` is the same.\\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n K | AK  OK  EK  I\\n```\\nif `m=3`, we have 8 kinds of status, `A, O, E, K, I, AK, OK, EK`.\\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n I | A   O   E   K\\n- - - - - - - - - -  # Add this line to make it more readable\\nAK | K   EK  OK  A\\nOK | EK  K   AK  A\\nEK | OK  AK  K   A\\n```\\nif `m>3`, the table will be above one with an extra row. But this does not introduce new status. So it is still 8 kinds of status.\\n```\\n___|_A___O___E___K_\\n K | AK  OK  EK  I\\n```\\n## Summary\\nThe reuslts forms this table:\\n```\\nn\\\\m_0_1_2_3_...\\n1|  1 2 2 2 ...\\n2|  1 3 4 4 ...\\n3|  1 4 7 8 ...\\n4|  1 4 7 8 ...\\n.|  . . . .\\n.|  . . . .\\n```\\n## Python Code\\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0: \\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        else:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "solutionTags": [],
                "code": "```python\\nAA=EE=OO=KK=I    # two same operation is equal to Identical operation\\nAE=O             # flipping all and even is equal to flipping odd\\nAO=E             # flipping all and odd is equal to flipping even\\nOE=A             # flipping odd and even is equal to flipping all\\n```\n```\\n___|_A___O___E_\\n I | A   O   E \\n```\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n```\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n I | A   O   E\\n```\n```\\n___|_A__O__E__K__\\n I | A  O  E  K \\n```\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n K | AK  OK  EK  I\\n```\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n I | A   O   E   K\\n- - - - - - - - - -  # Add this line to make it more readable\\nAK | K   EK  OK  A\\nOK | EK  K   AK  A\\nEK | OK  AK  K   A\\n```\n```\\n___|_A___O___E___K_\\n K | AK  OK  EK  I\\n```\n```\\nn\\\\m_0_1_2_3_...\\n1|  1 2 2 2 ...\\n2|  1 3 4 4 ...\\n3|  1 4 7 8 ...\\n4|  1 4 7 8 ...\\n.|  . . . .\\n.|  . . . .\\n```\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0: \\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        else:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091720,
                "title": "consider-all-cases-o-1",
                "content": "Straightforward to know that what matters is only n % 6.\\nSuppose we have a,b,c,d operations of 1,2,3,4.\\nBulb1 =  (a+b+d) % 2\\nBulb2 =  (a+c) % 2\\nBulb3 =  (a+b) % 2\\nand bulb 4 same as 1, 5 same as 3, 6 same as 2\\n\\nTherefore, what really matters is only the first three bulbs. \\n\\nIf we have only 1 bulb, in on step we have the two states 0 and 1 reachable. And so on, we just return 2.\\n\\nIn the case where we have 2 bulbs, step 1 would lead us to states 11,10,01 but not 00. After step 2 we can get 00 again, and so on we can reach whaterver we want.\\n\\n3 bulb, draw on your paper and easily we see in one step we got 4 states, and 2 steps we have all 8 states but 100, which can be reached after the 3 step. \\n\\nTherefore, just a few ifelses, O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(3,n)\\n        state = 0\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            return 4 if presses > 1 else 3\\n        if n == 3:\\n            if presses > 2:return 8\\n            elif presses == 2: return 7\\n            else: return 4\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(3,n)\\n        state = 0\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            return 4 if presses > 1 else 3\\n        if n == 3:\\n            if presses > 2:return 8\\n            elif presses == 2: return 7\\n            else: return 4\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079069,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int flipLights(int n, int presses) {\\n    if (presses == 0) {\\n      return 1;\\n    } else if (presses == 1) {\\n      if (n < 3) {\\n        return n + 1;\\n      } else {\\n        return 4;\\n      }\\n    } else if (presses == 2) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 7;\\n      }\\n    } else if (presses >= 3) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 8;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int flipLights(int n, int presses) {\\n    if (presses == 0) {\\n      return 1;\\n    } else if (presses == 1) {\\n      if (n < 3) {\\n        return n + 1;\\n      } else {\\n        return 4;\\n      }\\n    } else if (presses == 2) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 7;\\n      }\\n    } else if (presses >= 3) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 8;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028188,
                "title": "java-simple-solution-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n          if(presses==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&presses==1) return 3;\\n        if(n==2) return 4;\\n        if(presses==1) return 4;\\n        if(presses==2) return 7;\\n        if(presses>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n          if(presses==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&presses==1) return 3;\\n        if(n==2) return 4;\\n        if(presses==1) return 4;\\n        if(presses==2) return 7;\\n        if(presses>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923599,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public int flipLights(int n, int p) {\\n        n = Math.min(n, 4); \\n        p = Math.min(p, 4);\\n        int thre = (1<<n)-1;\\n\\n        int[] flips = new int[] {\\n            Integer.parseInt(\"1111\", 2)&thre,\\n            Integer.parseInt(\"0101\", 2)&thre,\\n            Integer.parseInt(\"1010\", 2)&thre,\\n            Integer.parseInt(\"1001\", 2)&thre\\n        };\\n\\n        if(p==0) return 1;\\n\\n        int ans = 0;\\n        boolean[] used = new boolean[(1<<10)+1];\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, 0});\\n\\n        while(!q.isEmpty()){\\n            int[] val = q.remove();\\n            int cur = val[0];\\n            int presses = val[1];\\n\\n            if(presses==p) {\\n                if(!used[cur]) ans++;\\n                used[cur] = true;\\n                continue;\\n            }\\n\\n            for(int flip : flips){\\n                q.add(new int[] {flip ^ cur, presses + 1});\\n            }          \\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n```python3 []\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n\\n    public int flipLights(int n, int p) {\\n        n = Math.min(n, 4); \\n        p = Math.min(p, 4);\\n        int thre = (1<<n)-1;\\n\\n        int[] flips = new int[] {\\n            Integer.parseInt(\"1111\", 2)&thre,\\n            Integer.parseInt(\"0101\", 2)&thre,\\n            Integer.parseInt(\"1010\", 2)&thre,\\n            Integer.parseInt(\"1001\", 2)&thre\\n        };\\n\\n        if(p==0) return 1;\\n\\n        int ans = 0;\\n        boolean[] used = new boolean[(1<<10)+1];\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, 0});\\n\\n        while(!q.isEmpty()){\\n            int[] val = q.remove();\\n            int cur = val[0];\\n            int presses = val[1];\\n\\n            if(presses==p) {\\n                if(!used[cur]) ans++;\\n                used[cur] = true;\\n                continue;\\n            }\\n\\n            for(int flip : flips){\\n                q.add(new int[] {flip ^ cur, presses + 1});\\n            }          \\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```python3 []\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3896100,
                "title": "c-observational-logic-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is highly observation based problem. \\nWe can note that if n is 1 we can only have 2 states (0,1) if we have presses>0. \\nWe then can observe that, when we have n = 2, if presses == 1 we will have (11,01,10). But if we have presses == 2 we have all 4 combinations (00,11,01,10).\\n\\nWe then can observe that if n = 3, if we have presses == 1 we will have 4 unique states (111,010,101,100). If presses == 2 we will have ((111,101,010),000,011,110) 7 states and if presses >= 3 we have ((111,101,010),000,011,110,100,001) all 8 possible states.\\n\\nBut now if we observe for n == 4, if presses == 1 we have same 4 states (1111,0101,1010,1001). For presses == 2 we have ((1111,0101,1010),0000,0110,1100,0011). For presses == 3 we have (((1111,0101,1010),0000,0110,1100,0011), 1001) and for presses == 4,5.. we have same states.\\n\\nThis trend continues for any n >= 3. Hence we follow the above code.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0)return 1;\\n        if(n==1)return 2;\\n        if(n==2)return presses==1?3:4;\\n        if(presses==1)return 4;\\n        if(presses==2)return 7;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0)return 1;\\n        if(n==1)return 2;\\n        if(n==2)return presses==1?3:4;\\n        if(presses==1)return 4;\\n        if(presses==2)return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860294,
                "title": "c-bitset",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3830675,
                "title": "100-faster-simple-clean-code",
                "content": "# Intuition\\n\\n# Approach\\n1) If same switch repeats itself, it nullifies its effect.\\n2) Switch (1,2,3) form closed loop, i.e., pressing any 2 is equivalent to another\\n3) When (n>2), all switches have unique effect\\n4) At max 8 states possible due to constraint in step-1,2 \\n5) presses==2 : we can\\'t reach a state same as config obtained by switch 4\\n# Complexity\\n- Time complexity:O(1)\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n\\n        if(presses==0) return 1;\\n        if(n==1) {\\n            return 2 ;\\n        } \\n        if(n==2){\\n            if(presses==1) return 3 ; \\n            return 4;  \\n        }\\n        if(presses==1) return 4 ; \\n        if(presses==2) return 7 ;   \\n        return 8 ; \\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n\\n        if(presses==0) return 1;\\n        if(n==1) {\\n            return 2 ;\\n        } \\n        if(n==2){\\n            if(presses==1) return 3 ; \\n            return 4;  \\n        }\\n        if(presses==1) return 4 ; \\n        if(presses==2) return 7 ;   \\n        return 8 ; \\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792532,
                "title": "o-1-time-complexity-only-if-else-nothing-other-than-that-beautiful-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return (presses == 1) ? 3 : 4;\\n        if (presses == 1) return 4;\\n        return (presses == 2) ? 7 : 8;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return (presses == 1) ? 3 : 4;\\n        if (presses == 1) return 4;\\n        return (presses == 2) ? 7 : 8;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685181,
                "title": "scala-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach recursive\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = {\\n      if (presses == 0 || n == 0) 1\\n      else if (n > 3) flipLights(3, presses)\\n      else flipLights(n - 1, presses - 1) + flipLights(n - 1, presses)\\n    }\\n}\\n```\\n\\n# Approach math\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = (n, presses) match {\\n      case (_, 0) => 1\\n      case (1, _) => 2\\n      case (2, 1) => 3\\n      case (2, _) => 4\\n      case (_, 1) => 4\\n      case (_, 2) => 7\\n      case (_,_) => 8\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = {\\n      if (presses == 0 || n == 0) 1\\n      else if (n > 3) flipLights(3, presses)\\n      else flipLights(n - 1, presses - 1) + flipLights(n - 1, presses)\\n    }\\n}\\n```\n```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = (n, presses) match {\\n      case (_, 0) => 1\\n      case (1, _) => 2\\n      case (2, 1) => 3\\n      case (2, _) => 4\\n      case (_, 1) => 4\\n      case (_, 2) => 7\\n      case (_,_) => 8\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3664452,
                "title": "bit-manipulation-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(m)$$. m is number of different states.\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0:\\n            return 1\\n        length = min(10, n)\\n        state = (1 << length) - 1\\n        buttons = [(1 << length) - 1, 0, 0, 0]\\n        for i in range(length):\\n            if i % 2 != 0:\\n                buttons[1] |= 1 << i\\n            if i % 2 == 0:\\n                buttons[2] |= 1 << i\\n            if 3 * i + 1 < length:\\n                buttons[3] |= 1 << (3 * i)\\n        states = set()\\n        visited = set()\\n        q = deque()\\n        q.append([state, presses])\\n        while q:\\n            for _ in range(len(q)):\\n                currentState, currentPresses = q.popleft()\\n                for button in buttons:\\n                    newState = currentState ^ button\\n                    if newState not in states and (newState, currentPresses - 1) not in visited:\\n                        if currentPresses - 1 > 0:\\n                            q.append([newState, currentPresses - 1])\\n                            visited.add((newState, currentPresses - 1))\\n                        else:\\n                            states.add(newState)\\n        return len(states)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0:\\n            return 1\\n        length = min(10, n)\\n        state = (1 << length) - 1\\n        buttons = [(1 << length) - 1, 0, 0, 0]\\n        for i in range(length):\\n            if i % 2 != 0:\\n                buttons[1] |= 1 << i\\n            if i % 2 == 0:\\n                buttons[2] |= 1 << i\\n            if 3 * i + 1 < length:\\n                buttons[3] |= 1 << (3 * i)\\n        states = set()\\n        visited = set()\\n        q = deque()\\n        q.append([state, presses])\\n        while q:\\n            for _ in range(len(q)):\\n                currentState, currentPresses = q.popleft()\\n                for button in buttons:\\n                    newState = currentState ^ button\\n                    if newState not in states and (newState, currentPresses - 1) not in visited:\\n                        if currentPresses - 1 > 0:\\n                            q.append([newState, currentPresses - 1])\\n                            visited.add((newState, currentPresses - 1))\\n                        else:\\n                            states.add(newState)\\n        return len(states)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608789,
                "title": "bit-manipulation-bfs-rust-and-python3-solution",
                "content": "###  Rust Solution (passes)\\n\\n```\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\\n\\n### Python3 Solution (TLE)\\n```\\nclass Solution:\\n    \\n    def flipBit(self, number, position):\\n        mask = 1 << position\\n        flipped_number = number ^ mask\\n        return flipped_number\\n        \\n    def yFunction(self, x: int) -> int:\\n        return 3*x + 1\\n    \\n    def getNeighbors(self, state: int, n: int,) -> List[int]:\\n        nbrs = []\\n        \\n        curr_num = state\\n        for i in range(1, n):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(1, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(0, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n        \\n        i = 0\\n        while self.yFunction(i) < n:\\n            curr_num = self.flipBit(curr_num, self.yFunction(i))\\n            i += 1\\n        nbrs.append(curr_num)  \\n        \\n        return nbrs\\n            \\n            \\n    # O(n*press) time,\\n    # O(n*space) space,\\n    # Approach: bfs, bit manipulation, \\n    def flipLights(self, n: int, presses: int) -> int:\\n        answer = set()\\n        queue = deque()\\n        queue.append(2**n - 1)\\n        answer.add(queue[0])\\n        \\n        while presses and queue:\\n            presses -= 1\\n            queue_len = len(queue)\\n            answer = set()\\n            for _ in range(queue_len):\\n                state = queue.popleft()\\n                nbrs = self.getNeighbors(state, n)\\n                for nbr in nbrs:\\n                    if nbr in answer:\\n                        continue\\n                    answer.add(nbr)\\n                    queue.append(nbr)\\n\\n        return len(answer)\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\n```\\nclass Solution:\\n    \\n    def flipBit(self, number, position):\\n        mask = 1 << position\\n        flipped_number = number ^ mask\\n        return flipped_number\\n        \\n    def yFunction(self, x: int) -> int:\\n        return 3*x + 1\\n    \\n    def getNeighbors(self, state: int, n: int,) -> List[int]:\\n        nbrs = []\\n        \\n        curr_num = state\\n        for i in range(1, n):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(1, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(0, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n        \\n        i = 0\\n        while self.yFunction(i) < n:\\n            curr_num = self.flipBit(curr_num, self.yFunction(i))\\n            i += 1\\n        nbrs.append(curr_num)  \\n        \\n        return nbrs\\n            \\n            \\n    # O(n*press) time,\\n    # O(n*space) space,\\n    # Approach: bfs, bit manipulation, \\n    def flipLights(self, n: int, presses: int) -> int:\\n        answer = set()\\n        queue = deque()\\n        queue.append(2**n - 1)\\n        answer.add(queue[0])\\n        \\n        while presses and queue:\\n            presses -= 1\\n            queue_len = len(queue)\\n            answer = set()\\n            for _ in range(queue_len):\\n                state = queue.popleft()\\n                nbrs = self.getNeighbors(state, n)\\n                for nbr in nbrs:\\n                    if nbr in answer:\\n                        continue\\n                    answer.add(nbr)\\n                    queue.append(nbr)\\n\\n        return len(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574891,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p)\\n     {\\n        if (p == 0)\\n         return 1; \\n        if (n == 1) \\n        return 2;\\n        if (p == 1) \\n        return n > 2 ? 4 : 3; \\n        if (n == 2) \\n        return 4; \\n        return p == 2 ? 7 : 8; \\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p)\\n     {\\n        if (p == 0)\\n         return 1; \\n        if (n == 1) \\n        return 2;\\n        if (p == 1) \\n        return n > 2 ? 4 : 3; \\n        if (n == 2) \\n        return 4; \\n        return p == 2 ? 7 : 8; \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547953,
                "title": "java-math",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        // even - 0000, (p>1) 1100, 1010, 1001, 0110, 0101, 0011, 1111 (for p>3)\\n        // odd  - 1000, 0100, 0010, 0001, (p>2) 1110, 1101, 1011, 0111 \\n\\n        //edge cases\\n        if (p ==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2 && p==1) return 3;\\n        if (n==2 && p>1) return 4;\\n\\n        if (p>4) p= (p%2==0)? 4:3;\\n\\n        if (p==1) return 4; // 1000, 0100, 0010, 0001\\n        if (p==2) return 7; //0000, 1100, 1010, 1001, 0110, 0101, 0011\\n        if (p==3) return 8; //1000, 0100, 0010, 0001, 1110, 1101, 1011, 0111 \\n        if (p==4) return 8;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        // even - 0000, (p>1) 1100, 1010, 1001, 0110, 0101, 0011, 1111 (for p>3)\\n        // odd  - 1000, 0100, 0010, 0001, (p>2) 1110, 1101, 1011, 0111 \\n\\n        //edge cases\\n        if (p ==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2 && p==1) return 3;\\n        if (n==2 && p>1) return 4;\\n\\n        if (p>4) p= (p%2==0)? 4:3;\\n\\n        if (p==1) return 4; // 1000, 0100, 0010, 0001\\n        if (p==2) return 7; //0000, 1100, 1010, 1001, 0110, 0101, 0011\\n        if (p==3) return 8; //1000, 0100, 0010, 0001, 1110, 1101, 1011, 0111 \\n        if (p==4) return 8;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468142,
                "title": "javascript-detailed-explanation-o-1-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSituation 1 `n===1`: Button 1,3,4 are the same, So 2 types of button in total. `t(1) = 2`\\nSituation 2 `n===2`: Button 3,4 are the same, So 3 types of button in total. `t(2) = 3`\\nSituation 3 `n>=3`: 4 button has different outcome. So 4 types of button. `t(n) = 4, n>=3`.\\n\\n**Important:** Based on observation\\n1. Press any button twice equals not press anything.\\n2. The sequence of press button will not impact outcome. Means press `Button 1 -> Button 2` equals `Button 2 -> Button 1`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen `presses == 0 `, no state change, all lights are on. Just `1` status.\\n`flipLights(n, 0) = 1`, when `n >= 1`\\n\\nWhen `presses >= 1`:\\n1. `presses == 1`.\\n\\n`flipLights(n, 1) = t(n)` where `t(1) = 2, t(2) = 3, t(i) = 4 (i>2)`.\\n\\n2. `presses == 2`.\\nSituation 1 `n===1`: `flipLights(1, 2) = C(t(1),2) + flipLights(1, 0) = 1 + 1 = 2`.\\nSituation 2 `n===2`: `flipLights(2, 2) = C(t(2),2) + flipLights(2, 0) = 3 + 1 = 4`.\\nSituation 3 `n>=3`: `flipLights(n, 2) = C(t(n),2) + flipLights(n, 0) = 6 + 1 = 7`.\\n\\n\\n`C(n, r)` is the combination formula, `n` is the size of set, `k` is the size of permutation.\\nFor example, `C(t(3), 2) = C(4, 2)` means, when there are 3 lights, we have 4 different buttons in total, we need to press 2 buttons. So we choose 2 different buttons to press from a total of 4 buttons. That\\'s 6 different combinations.\\n\\n3. `presses >= 3`.\\nWe can have it in general.\\n\\n`flipLights(n, presses) = C(t(n), presses) + flipLights(n, presses-2)`.\\n\\nWhen `t(n) < presses, C(t(n), presses) = 0`, we will get `flipLights(n, presses) = flipLights(n, presses-2)`. It happens when `presses >= 5`. \\n\\nSo all we need to do is to analyse and get the below table.\\n\\nn | presses 0 | presses 1 | presses 2 | presses 3 | presses 4 | presses >= 5| ...\\n--- | --- | --- | --- | --- | --- | --- | ---\\n1 | 1 | 2 | 2 | 2 | 2 | 2 | 2...\\n2 | 1 | 3 | 4 | 4 | 4 | 4 | 4...\\nLarger than 3 | 1 | 4 | 7 | 8 | 8 | 8 | 8...\\n\\n# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} presses\\n * @return {number}\\n */\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) {\\n      return 1;\\n    } else if (n === 1) {\\n      return 2;\\n    } else if (n === 2) {\\n      return presses === 1 ? 3 : 4;\\n    } else {\\n      return presses === 1 ? 4 : presses === 2 ? 7 : 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} presses\\n * @return {number}\\n */\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) {\\n      return 1;\\n    } else if (n === 1) {\\n      return 2;\\n    } else if (n === 2) {\\n      return presses === 1 ? 3 : 4;\\n    } else {\\n      return presses === 1 ? 4 : presses === 2 ? 7 : 8;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3463933,
                "title": "one-image-to-illustrate-the-finite-state-machine",
                "content": "# Intuition\\n1, any two same buttons(operations) lead to the origin state\\ne.g. button1 + button1 = nothing changed\\n2, As to the former 3 operations, any two operations lead to the third operation. e.g. button1 + button2 = button3\\n\\nobserve the image below: \\n![image.png](https://assets.leetcode.com/users/images/e05a58bc-fb9d-44cb-a599-d99672c64fe2_1682698761.0383983.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\n// fi + fi = nil, i=1,2,3,4\\n// f1 + f2 = f3, f2 + f3 = f1, f1 + f3 = f2\\n// so, there are 8 situations, which are\\n// nil, f1, f2, f3, f4, f1+f4, f2+f4, f3+f4\\nfunc flipLights(n int, presses int) int {\\n    if presses == 0 {return 1}\\n    if n == 1 {return 2}\\n    if n == 2 {\\n        if presses == 1 {return 3}\\n        return 4\\n    }\\n    if presses == 1 {return 4}\\n    if presses == 2 {return 7}\\n    return 8\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// fi + fi = nil, i=1,2,3,4\\n// f1 + f2 = f3, f2 + f3 = f1, f1 + f3 = f2\\n// so, there are 8 situations, which are\\n// nil, f1, f2, f3, f4, f1+f4, f2+f4, f3+f4\\nfunc flipLights(n int, presses int) int {\\n    if presses == 0 {return 1}\\n    if n == 1 {return 2}\\n    if n == 2 {\\n        if presses == 1 {return 3}\\n        return 4\\n    }\\n    if presses == 1 {return 4}\\n    if presses == 2 {return 7}\\n    return 8\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459452,
                "title": "code-in-5-lines-using-conditional-statement-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2 && m==1) return 3;\\n        if(n==2 || m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2 && m==1) return 3;\\n        if(n==2 || m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459260,
                "title": "very-easy-solution",
                "content": "Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] LessThan3 = new int[]{1,3,4};\\n        int[] MoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,LessThan3[Math.min(presses,2)]);            \\n        return MoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] LessThan3 = new int[]{1,3,4};\\n        int[] MoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,LessThan3[Math.min(presses,2)]);            \\n        return MoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437936,
                "title": "scala",
                "content": "# Code\\n```\\nobject Solution {\\n  def flipLights(n: Int, presses: Int): Int = {\\n    type Status = Set[Int] // contains indexes of bulbes on\\n    \\n    val allOn: Status = Set.from(1 to n)\\n    \\n    def flip(s: Status)(c: Int => Boolean): Status = allOn.filter {\\n      case b if s(b) => !c(b)\\n      case b => c(b)\\n    }\\n    \\n    def button1(s: Status): Status = flip(s)(_ => true)\\n    def button2(s: Status): Status = flip(s)(_ % 2 == 0)\\n    def button3(s: Status): Status = flip(s)(_ % 2 == 1)\\n    def button4(s: Status): Status = flip(s)(_ % 3 == 1)\\n\\n    val mem = scala.collection.mutable.Map[Status, Set[Status]]()\\n\\n    def statusesFrom(s: Status): Set[Status] = {\\n      mem.getOrElseUpdate(s,\\n        Set(button1(s), button2(s), button3(s), button4(s))\\n      )\\n    }\\n\\n    val statuses = LazyList.iterate(Set(allOn)) {\\n      _.flatMap(statusesFrom)\\n    }\\n\\n    statuses(presses).size\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def flipLights(n: Int, presses: Int): Int = {\\n    type Status = Set[Int] // contains indexes of bulbes on\\n    \\n    val allOn: Status = Set.from(1 to n)\\n    \\n    def flip(s: Status)(c: Int => Boolean): Status = allOn.filter {\\n      case b if s(b) => !c(b)\\n      case b => c(b)\\n    }\\n    \\n    def button1(s: Status): Status = flip(s)(_ => true)\\n    def button2(s: Status): Status = flip(s)(_ % 2 == 0)\\n    def button3(s: Status): Status = flip(s)(_ % 2 == 1)\\n    def button4(s: Status): Status = flip(s)(_ % 3 == 1)\\n\\n    val mem = scala.collection.mutable.Map[Status, Set[Status]]()\\n\\n    def statusesFrom(s: Status): Set[Status] = {\\n      mem.getOrElseUpdate(s,\\n        Set(button1(s), button2(s), button3(s), button4(s))\\n      )\\n    }\\n\\n    val statuses = LazyList.iterate(Set(allOn)) {\\n      _.flatMap(statusesFrom)\\n    }\\n\\n    statuses(presses).size\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3428024,
                "title": "java-intuitive-bfs-with-early-termination-if-converge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. 4 operations are four next states from current state\\n2. each press is one bfs search \\n3. we return the size of the results in the neighbors \\n4. one concern is that if press is big, it soon becomes exponential algorithm and very slow\\n5. will the result become stable?\\n6. let\\'s assume it will be stable, how do we terminate the search once it\\'s stable? Check the result size between each press\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOriginally thought about using int to represent a state, but since n could be large, I decide to go with string.\\nTypical BFS algorithm with some additions:\\na. add a set to check all the children string results to avoid duplicates.\\nb. Between each round of BFS, check the result size, if the size stays the same, it means we reach a stable status, we can return the stable result \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Math.min(4^presses, 4^(n times to stable))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Math.min(4^presses, 4^(n times to stable))\\n# Code\\n```\\nclass Solution {\\n\\n\\n\\n    public int flipLights(int n, int presses) {\\n\\n        // 4 operations are four next states from current state\\n        // each press is one bfs search \\n        // we return the size of the results in the neighbors \\n        // one concern is that if press is big, it soon becomes exponential algorithm and very slow\\n        // will the result become stable?\\n        // let\\'s assume it will be stable, how do we terminate the search once it\\'s stable?\\n        if(presses == 0) return 1;\\n\\n        String init =  buildOnes(n);\\n    \\n        Queue<String> states = new LinkedList<>();\\n        states.offer(init);\\n\\n        int pressCnt = 0;\\n\\n        HashSet<String> memo = new HashSet<>();\\n\\n     \\n   \\n        while(!states.isEmpty() && pressCnt < presses)\\n        {\\n            int size = states.size();\\n            memo.clear();\\n            for(int i=0; i<size; i++)\\n            {\\n                String cur = states.poll();\\n                for(int j=1; j<=4; j++)\\n                {\\n                    String child = operations(cur, j);\\n                    if(!memo.contains(child))\\n                        {\\n                            memo.add(child);\\n                            states.offer(child);\\n                            //System.out.print(child+\" \");\\n                        }\\n                }\\n                \\n            }\\n            //System.out.println();\\n            if(states.size() == size) return size; // it becomes stable we can return    \\n\\n            pressCnt++;\\n        }\\n\\n        return states.size();\\n\\n    }\\n\\n    private String buildOnes(int n)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            sb.append(\"1\");\\n        return sb.toString();\\n    }\\n\\n    private String operations(String cur, int buttonNum)\\n    {\\n        switch(buttonNum)\\n        {\\n            case 1: return one(cur);\\n            case 2: return two(cur);\\n            case 3: return three(cur);\\n            case 4: return four(cur);\\n            default: break;\\n        }\\n        return cur;\\n    }\\n\\n    private String one(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c:cur.toCharArray())\\n        {\\n            if(c==\\'0\\') sb.append(\"1\");\\n            else sb.append(\"0\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    private String two(String cur)\\n    {\\n         StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String three(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 == 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String four(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( ((i+1)-1) % 3 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n\\n    public int flipLights(int n, int presses) {\\n\\n        // 4 operations are four next states from current state\\n        // each press is one bfs search \\n        // we return the size of the results in the neighbors \\n        // one concern is that if press is big, it soon becomes exponential algorithm and very slow\\n        // will the result become stable?\\n        // let\\'s assume it will be stable, how do we terminate the search once it\\'s stable?\\n        if(presses == 0) return 1;\\n\\n        String init =  buildOnes(n);\\n    \\n        Queue<String> states = new LinkedList<>();\\n        states.offer(init);\\n\\n        int pressCnt = 0;\\n\\n        HashSet<String> memo = new HashSet<>();\\n\\n     \\n   \\n        while(!states.isEmpty() && pressCnt < presses)\\n        {\\n            int size = states.size();\\n            memo.clear();\\n            for(int i=0; i<size; i++)\\n            {\\n                String cur = states.poll();\\n                for(int j=1; j<=4; j++)\\n                {\\n                    String child = operations(cur, j);\\n                    if(!memo.contains(child))\\n                        {\\n                            memo.add(child);\\n                            states.offer(child);\\n                            //System.out.print(child+\" \");\\n                        }\\n                }\\n                \\n            }\\n            //System.out.println();\\n            if(states.size() == size) return size; // it becomes stable we can return    \\n\\n            pressCnt++;\\n        }\\n\\n        return states.size();\\n\\n    }\\n\\n    private String buildOnes(int n)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            sb.append(\"1\");\\n        return sb.toString();\\n    }\\n\\n    private String operations(String cur, int buttonNum)\\n    {\\n        switch(buttonNum)\\n        {\\n            case 1: return one(cur);\\n            case 2: return two(cur);\\n            case 3: return three(cur);\\n            case 4: return four(cur);\\n            default: break;\\n        }\\n        return cur;\\n    }\\n\\n    private String one(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c:cur.toCharArray())\\n        {\\n            if(c==\\'0\\') sb.append(\"1\");\\n            else sb.append(\"0\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    private String two(String cur)\\n    {\\n         StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String three(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 == 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String four(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( ((i+1)-1) % 3 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383937,
                "title": "java-minimum-value-in-a-binary-tree-with-unique-values",
                "content": "# Intuition\\nWe can approach this problem by analyzing the effect of each button press on the bulbs and try to find a pattern that emerges as we perform a certain number of presses.\\n# Approach\\n- If the number of presses is 0, then all bulbs remain turned on, and there is only one possible status.\\n- If there is only one bulb, then we can either turn it off or on, so there are two possible statuses.\\n- If there are two bulbs, then we can either flip both bulbs, flip only the even bulb, flip only the odd bulb, or not flip any bulb. If we have only one press, then we can do any of the four operations, so there are three possible statuses. If we have two presses, then we can do two operations that cancel out each other, so we have four possible statuses.\\n- If there are three or more bulbs, then the fourth button is relevant as it flips bulbs with labels 3k + 1. We can use it to flip all the bulbs in a certain pattern, which can be used to generate all possible statuses.\\n\\nWe can derive the following pattern:\\n\\n- If we press the fourth button, then we flip all bulbs with odd labels.\\n- If we press the first button, then we flip all bulbs.\\n- If we press the second button, then we flip all even bulbs.\\n- If we press the third button, then we flip all odd bulbs.\\n\\nUsing the fourth button, we can generate all possible patterns with only odd bulbs turned on. If n >= 3 and presses >= 2, then we can perform the following sequence of operations:\\n\\n- Press button 4 to turn off all bulbs with labels 1, 4, 7, ...\\n- Press button 2 or 3 to toggle all even or odd bulbs, respectively.\\n- Press button 1 to toggle all bulbs.\\n- Press button 2 or 3 to toggle all even or odd bulbs, respectively.\\n\\nThis generates 8 possible statuses. If we have only one press, then we can do any of the four operations, so there are four possible statuses. If we have two presses but n = 2, then there are only four possible statuses as there are no bulbs with odd labels.\\n# Complexity\\n- Time complexity:\\nO(1). The solution performs a constant number of operations to derive the answer.\\n- Space complexity:\\nO(1). The solution does not use any extra data structures that depend on the input size.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        } else if (n == 1) {\\n            return 2;\\n        } else if (n == 2) {\\n            return presses == 1 ? 3 : 4;\\n        } else {\\n            return presses == 1 ? 4 : (presses == 2 ? 7 : 8);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        } else if (n == 1) {\\n            return 2;\\n        } else if (n == 2) {\\n            return presses == 1 ? 3 : 4;\\n        } else {\\n            return presses == 1 ? 4 : (presses == 2 ? 7 : 8);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383078,
                "title": "dfs-solution-recursion-dp",
                "content": "\\n\\n# Code 1\\n```\\n\\nclass Solution {\\npublic:\\n    set<string>st;\\n        string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    void solve(string s,int presses,unordered_map<string,unordered_map<int,int>>&dp){\\n        if(presses == 0){\\n            st.insert(s);\\n            return;\\n        }\\n\\n        if(dp.count(s) and dp[s].count(presses)) return;\\n\\n        dp[s][presses] = 1;\\n     \\n        solve(op(0,s),presses-1,dp); \\n        solve(op(1,s),presses-1,dp); \\n        solve(op(2,s),presses-1,dp); \\n        solve(op(3,s),presses-1,dp); \\n    }\\n    int flipLights(int n, int presses) {\\n        string s(n,\\'1\\');\\n        unordered_map<string,unordered_map<int,int>>dp;\\n        solve(s,presses,dp);\\n        return st.size();       \\n    }\\n};\\n```\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return m==1 ? 3 : 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        return 8;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    set<string>st;\\n        string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    void solve(string s,int presses,unordered_map<string,unordered_map<int,int>>&dp){\\n        if(presses == 0){\\n            st.insert(s);\\n            return;\\n        }\\n\\n        if(dp.count(s) and dp[s].count(presses)) return;\\n\\n        dp[s][presses] = 1;\\n     \\n        solve(op(0,s),presses-1,dp); \\n        solve(op(1,s),presses-1,dp); \\n        solve(op(2,s),presses-1,dp); \\n        solve(op(3,s),presses-1,dp); \\n    }\\n    int flipLights(int n, int presses) {\\n        string s(n,\\'1\\');\\n        unordered_map<string,unordered_map<int,int>>dp;\\n        solve(s,presses,dp);\\n        return st.size();       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return m==1 ? 3 : 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296699,
                "title": "bfs",
                "content": "```ruby\\ndef flip_lights n, p\\n    s = Set[[1] * n]\\n    p.times do\\n        t = Set.new\\n        s.each do | x |\\n            a, b, c, d = *4.times.map { x.clone }\\n            for i in 0...n\\n                a[i] ^= 1\\n                i.odd? ? b[i] ^= 1 : c[i] ^= 1\\n                d[i] ^= 1 if i % 3 == 0\\n            end\\n            t += Set[a, b, c, d]\\n        end\\n        s == t ? (break) : s = t\\n    end\\n    s.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef flip_lights n, p\\n    s = Set[[1] * n]\\n    p.times do\\n        t = Set.new\\n        s.each do | x |\\n            a, b, c, d = *4.times.map { x.clone }\\n            for i in 0...n\\n                a[i] ^= 1\\n                i.odd? ? b[i] ^= 1 : c[i] ^= 1\\n                d[i] ^= 1 if i % 3 == 0\\n            end\\n            t += Set[a, b, c, d]\\n        end\\n        s == t ? (break) : s = t\\n    end\\n    s.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3214722,
                "title": "python3-interview-feasible-solution",
                "content": "## Inspired by [awice\\'s post](https://leetcode.com/problems/bulb-switcher-ii/solutions/107267/Python-Straightforward-with-Explanation/)\\n\\n### 1. Observations:\\n1. pressing a button twice ->  nothing happen\\n2. buttons order doesn\\'t matter -> `Button1 + Button2` = `Button2 + Button1` \\n\\n### 2. Thought Processes:\\nFor each of the 4 buttons, it will either be pressed or not pressed at the end (pressing twice equal to nothing happen). \\n\\nHence, we can construct a list of combinations of whether each button is pressed or not, and then validate if we can get that `combination`, like `(1, 0, 0, 1)` meaning `Button1` and `Button4` are pressed. We only have 16 such combinations (2 ** 4)\\n\\nAnd how are we gonna validate the combination? \\n1. `sum(combination) % 2` == `presses % 2` \\n\\n\\tsum of all presses in the combination should be the same as `presses`, ignoring the case pressing the same button even times.\\n\\t\\n\\tLet say testcase `presses=6` and we are validating `combination=(2, 1, 3, 0)`.  We can reduce the combination to `(0, 1, 1, 0)` (`Observation 1`). In this case `sum(combination) % 2` = `presses % 2` = `0`, hence, this should be a potential valid combination.\\n\\t\\n2.  `sum(combination`) <= `presses` \\n\\tif `presses` <= 4, we should not expect more than `presses` buttons being pressed in the combination.\\n\\n\\n\\n#### 3. Code\\n```python\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        https://leetcode.com/problems/bulb-switcher-ii/discuss/107267\\n        \"\"\"\\n        result = set()\\n\\n        # we can find out that the pattern is repeated each 6 bulbs (least common multiple of 2 and 3)\\n        # 1 is light on, and 0 is off for each bulb\\n        # each of the following represents the operation of the 4 buttons\\n        switches = [\\n            int(\\'111111\\'[-n:], 2),\\n            int(\\'101010\\'[-n:], 2),\\n            int(\\'010101\\'[-n:], 2),\\n            int(\\'001001\\'[-n:], 2),\\n        ]\\n\\n        for combination in itertools.product((0, 1), repeat=4):\\n            # validate operation\\n            if sum(combination) % 2 == presses % 2 and sum(combination) <= presses:\\n                # all lights on initially\\n                bulbs = int(\\'111111\\', 2)\\n                for i, op in enumerate(combination):\\n                    if op == 1:\\n                        bulbs ^= switches[i]\\n\\n                result.add(bulbs)\\n        \\n        return len(result)\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        https://leetcode.com/problems/bulb-switcher-ii/discuss/107267\\n        \"\"\"\\n        result = set()\\n\\n        # we can find out that the pattern is repeated each 6 bulbs (least common multiple of 2 and 3)\\n        # 1 is light on, and 0 is off for each bulb\\n        # each of the following represents the operation of the 4 buttons\\n        switches = [\\n            int(\\'111111\\'[-n:], 2),\\n            int(\\'101010\\'[-n:], 2),\\n            int(\\'010101\\'[-n:], 2),\\n            int(\\'001001\\'[-n:], 2),\\n        ]\\n\\n        for combination in itertools.product((0, 1), repeat=4):\\n            # validate operation\\n            if sum(combination) % 2 == presses % 2 and sum(combination) <= presses:\\n                # all lights on initially\\n                bulbs = int(\\'111111\\', 2)\\n                for i, op in enumerate(combination):\\n                    if op == 1:\\n                        bulbs ^= switches[i]\\n\\n                result.add(bulbs)\\n        \\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153235,
                "title": "beats-100-0ms-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int statuses = 0;\\n        if(n==1 && presses > 0){\\n            statuses = n + 1;\\n        }\\n        else if(presses==1 && n < 4){\\n            statuses = n + presses;\\n        }\\n        else if((n == 2 && presses > 0) || (presses == 1 && n >= 4)){\\n            statuses = 4;\\n        }\\n        else if(presses == 2 && n > presses){\\n            statuses = 7;\\n        }\\n        else if(n*presses > 8){\\n            statuses = 8;\\n        }\\n        else if(n*presses < 8 && n > presses){\\n            statuses = n*presses + 1;\\n        }\\n        else if(n*presses <= 8 && n <= presses){\\n            statuses = 4;\\n        }\\n        else{\\n            return statuses = 1;\\n        }\\n        return statuses;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int statuses = 0;\\n        if(n==1 && presses > 0){\\n            statuses = n + 1;\\n        }\\n        else if(presses==1 && n < 4){\\n            statuses = n + presses;\\n        }\\n        else if((n == 2 && presses > 0) || (presses == 1 && n >= 4)){\\n            statuses = 4;\\n        }\\n        else if(presses == 2 && n > presses){\\n            statuses = 7;\\n        }\\n        else if(n*presses > 8){\\n            statuses = 8;\\n        }\\n        else if(n*presses < 8 && n > presses){\\n            statuses = n*presses + 1;\\n        }\\n        else if(n*presses <= 8 && n <= presses){\\n            statuses = 4;\\n        }\\n        else{\\n            return statuses = 1;\\n        }\\n        return statuses;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152375,
                "title": "c-100-beats-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nint flipLights(int n, int presses)\\n{\\n    if(presses==0)  {return 1;}\\n    if(n==1)    {return 2;}\\n    if(n==2 && presses==1)  {return 3;}\\n    if(n==2 || presses==1)  {return 4;}\\n    if(presses==2)  {return 7;}\\n    if(presses>=3)  {return 8;}\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint flipLights(int n, int presses)\\n{\\n    if(presses==0)  {return 1;}\\n    if(n==1)    {return 2;}\\n    if(n==2 && presses==1)  {return 3;}\\n    if(n==2 || presses==1)  {return 4;}\\n    if(presses==2)  {return 7;}\\n    if(presses>=3)  {return 8;}\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152363,
                "title": "c-c-o-1-time-and-space-using-if-condition",
                "content": "\\n# *Complexity*\\n- *Time complexity*:\\n`O(1)`\\n- *Space complexity*:\\n`O(1)`\\n\\n# *Code*\\n```\\nclass Solution\\n{\\npublic:\\n    int flipLights(int x, int y)\\n    {\\n        if(y == 0)\\n        {\\n            return 1;\\n        }\\n        if(x == 1)\\n        {\\n            return 2;\\n        }\\n\\n        if(x == 2 && y == 1)\\n        {\\n            return 3;\\n        }\\n        if(x == 2 || y == 1)\\n        {\\n            return 4;\\n        }\\n        if(y == 2)\\n        {\\n            return 7;\\n        }\\n        if(y >= 3)\\n        {\\n            return 8;\\n        }\\n        return 0;\\n    }\\n};\\n```\\nDo upvote for this\\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int flipLights(int x, int y)\\n    {\\n        if(y == 0)\\n        {\\n            return 1;\\n        }\\n        if(x == 1)\\n        {\\n            return 2;\\n        }\\n\\n        if(x == 2 && y == 1)\\n        {\\n            return 3;\\n        }\\n        if(x == 2 || y == 1)\\n        {\\n            return 4;\\n        }\\n        if(y == 2)\\n        {\\n            return 7;\\n        }\\n        if(y >= 3)\\n        {\\n            return 8;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095593,
                "title": "python-one-line-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust try small cases and find a pattern. \\n\\n# Complexity\\n- Time complexity: ```O(1)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self,n,p):\\n        return [[1,1,1],[2,3,4],[2,4,7],[2,4,8]][min(p,3)][min(n-1,2)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```O(1)```\n```O(1)```\n```\\nclass Solution:\\n    def flipLights(self,n,p):\\n        return [[1,1,1],[2,3,4],[2,4,7],[2,4,8]][min(p,3)][min(n-1,2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067989,
                "title": "brute-forcing-2-4-possibilities",
                "content": "```\\nclass Solution {\\npublic:\\n    void fill( vector<string> &allpossi,string &s)\\n    {\\n        if (s.size()==4)\\n        {\\n            allpossi.push_back(s);\\n            return;\\n        }\\n        s.push_back(\\'0\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n        s.push_back(\\'1\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n    }\\n    \\n    void change(string &t,int k)\\n    {\\n        if (k==0)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n            }\\n        }\\n        else if (k==1)\\n        {\\n            \\n            \\n             for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==0)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n        else if (k==2)\\n        {\\n            \\n            \\n            \\n            \\n          for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        else if (k==3)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%3==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n    \\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        // pressing a specific button two times is equivalent to not pressing it at all\\n        unordered_set<string> ans;\\n\\n        \\n        string s=\"\";\\n        vector<string> allpossi;\\n        fill(allpossi,s);\\n        \\n         s=\"\";\\n         for (int i=0;i<n;i++)\\n        {\\n            s+=\\'1\\';\\n        }\\n       // for (auto x:allpossi)\\n         //   cout<<x<<endl;\\n       \\n      for (int i=0;i<allpossi.size();i++)\\n      {\\n          string temp=s;\\n          string ps=allpossi[i];\\n          int count=0;\\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n                  count++;\\n          }\\n          if (count>presses)\\n              continue;\\n          if (count==0)\\n          {\\n              cout<<i<<\" \"<<temp<<endl;\\n              if (presses%2==0)\\n              {\\n                  ans.insert(temp);\\n              }\\n              continue;\\n          }\\n          \\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n              {\\n                  change(temp,k);\\n                 \\n              }\\n          }\\n       //   if (count==presses) // this is wrong\\n       //   ans.insert(temp);\\n          \\n          \\n          if (count==presses)\\n          {\\n              ans.insert(temp);\\n              continue;\\n          }  //count<presses\\n          \\n          if (presses%2==0)\\n          {\\n              \\n              if(count%2==0)\\n              {\\n                 ans.insert(temp); \\n              }\\n          }\\n          else\\n          {\\n              \\n              ans.insert(temp);\\n              \\n          }\\n          \\n          \\n          \\n      }\\n        \\n      for (auto x:ans)\\n          cout<<x<<endl;\\n        \\n        \\n        return ans.size();\\n            \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void fill( vector<string> &allpossi,string &s)\\n    {\\n        if (s.size()==4)\\n        {\\n            allpossi.push_back(s);\\n            return;\\n        }\\n        s.push_back(\\'0\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n        s.push_back(\\'1\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n    }\\n    \\n    void change(string &t,int k)\\n    {\\n        if (k==0)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n            }\\n        }\\n        else if (k==1)\\n        {\\n            \\n            \\n             for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==0)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n        else if (k==2)\\n        {\\n            \\n            \\n            \\n            \\n          for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        else if (k==3)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%3==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n    \\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        // pressing a specific button two times is equivalent to not pressing it at all\\n        unordered_set<string> ans;\\n\\n        \\n        string s=\"\";\\n        vector<string> allpossi;\\n        fill(allpossi,s);\\n        \\n         s=\"\";\\n         for (int i=0;i<n;i++)\\n        {\\n            s+=\\'1\\';\\n        }\\n       // for (auto x:allpossi)\\n         //   cout<<x<<endl;\\n       \\n      for (int i=0;i<allpossi.size();i++)\\n      {\\n          string temp=s;\\n          string ps=allpossi[i];\\n          int count=0;\\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n                  count++;\\n          }\\n          if (count>presses)\\n              continue;\\n          if (count==0)\\n          {\\n              cout<<i<<\" \"<<temp<<endl;\\n              if (presses%2==0)\\n              {\\n                  ans.insert(temp);\\n              }\\n              continue;\\n          }\\n          \\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n              {\\n                  change(temp,k);\\n                 \\n              }\\n          }\\n       //   if (count==presses) // this is wrong\\n       //   ans.insert(temp);\\n          \\n          \\n          if (count==presses)\\n          {\\n              ans.insert(temp);\\n              continue;\\n          }  //count<presses\\n          \\n          if (presses%2==0)\\n          {\\n              \\n              if(count%2==0)\\n              {\\n                 ans.insert(temp); \\n              }\\n          }\\n          else\\n          {\\n              \\n              ans.insert(temp);\\n              \\n          }\\n          \\n          \\n          \\n      }\\n        \\n      for (auto x:ans)\\n          cout<<x<<endl;\\n        \\n        \\n        return ans.size();\\n            \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3044902,
                "title": "identify-the-states-of-bulb-for-n-1-2-3-o-1",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        the trick to problem is that only 3 bulbs are indicative of all the n bulbs\\n        this is because, sequence repeats every 3 bulbs\\n\\n        if n>3, then we can consider sequence of 3 bubls since that will reprsent the \\n        entire sequence\\n\\n        (1, 1, 1) -> (0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1) [for n>=3, k=1, ans=4]\\n\\n        (0, 0, 0) -> (1, 1, 1), (1, 0, 1), (0, 1, 0), (1, 0, 0)\\n        (0, 1, 0) -> (1, 0, 1), (1, 1, 1), (0, 0, 0), (1, 1, 0)\\n        (1, 0, 1) -> (0, 1, 0), (0, 0, 0), (1, 1, 1), (0, 0, 1)\\n        (0, 1, 1) -> (1, 0, 0), (1, 1, 0), (0, 0, 1), (1, 1, 1) [for n>=3, k=2, ans=7]\\n\\n        for n>=3, k>=3, there will be one more state added i.e. (0, 1, 1)\\n        along with the other 7 states, so ans=8\\n\\n        when n = 1, k>=1\\n        (1) -> (0), (1), (0), (0) [for n=1, for every k, ans=2]\\n\\n        when n=2, k=1\\n        (1,1) -> (0, 0), (1, 0), (0, 1), (0, 1) [for n=2, k=1, ans=3]\\n\\n        (0, 0) -> (1, 1), (1, 0), (0, 1), (0, 0)\\n        (1, 0) -> (0, 1), (1, 1), (0, 0), (0, 0)\\n        (0, 1) -> (1, 0), (1, 1), (0, 0), (1, 1) [for n=2, k>=2, ans=4]\\n        \"\"\"\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses==1:\\n                return 3\\n            else:\\n                return 4\\n        if n >= 3:\\n            if presses == 1:\\n                return 4\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        the trick to problem is that only 3 bulbs are indicative of all the n bulbs\\n        this is because, sequence repeats every 3 bulbs\\n\\n        if n>3, then we can consider sequence of 3 bubls since that will reprsent the \\n        entire sequence\\n\\n        (1, 1, 1) -> (0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1) [for n>=3, k=1, ans=4]\\n\\n        (0, 0, 0) -> (1, 1, 1), (1, 0, 1), (0, 1, 0), (1, 0, 0)\\n        (0, 1, 0) -> (1, 0, 1), (1, 1, 1), (0, 0, 0), (1, 1, 0)\\n        (1, 0, 1) -> (0, 1, 0), (0, 0, 0), (1, 1, 1), (0, 0, 1)\\n        (0, 1, 1) -> (1, 0, 0), (1, 1, 0), (0, 0, 1), (1, 1, 1) [for n>=3, k=2, ans=7]\\n\\n        for n>=3, k>=3, there will be one more state added i.e. (0, 1, 1)\\n        along with the other 7 states, so ans=8\\n\\n        when n = 1, k>=1\\n        (1) -> (0), (1), (0), (0) [for n=1, for every k, ans=2]\\n\\n        when n=2, k=1\\n        (1,1) -> (0, 0), (1, 0), (0, 1), (0, 1) [for n=2, k=1, ans=3]\\n\\n        (0, 0) -> (1, 1), (1, 0), (0, 1), (0, 0)\\n        (1, 0) -> (0, 1), (1, 1), (0, 0), (0, 0)\\n        (0, 1) -> (1, 0), (1, 1), (0, 0), (1, 1) [for n=2, k>=2, ans=4]\\n        \"\"\"\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses==1:\\n                return 3\\n            else:\\n                return 4\\n        if n >= 3:\\n            if presses == 1:\\n                return 4\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979329,
                "title": "python3-o-1-time-and-space-complexity",
                "content": "I claim that, if presses and n are both at least 3, the return is always 8.\\n\\nWith buttons 1, 2, and 3 we have 4 obvious possible states:\\n\\n- all off\\n- all on\\n- evens only\\n- odds only\\n\\nIf we apply button 4 to each of the above we can get:\\n- [3k + 1] are on\\n- [3k + 1] are off\\n- [3k + 1] are on for odds only; other evens are lit\\n- [3k + 1] are on for evens only; other odds are lit\\n\\nFrom each of these states, it is clear that pressing \\'4\\' from here will just return to the state before it was pressed. Under each of the four conditions, what happens when button 1, 2, or 3 is pressed?\\n\\n- first condition above:\\n    - Button 1: toggles to second condition\\n    - Button 2: toggles to the third condition\\n    - Button 3: toggles to the fourth condition\\n- second condition:\\n    - Button 1: toggles to first condition\\n    - Button 2: toggles to fourth condition\\n    - Button 3: toggles to third condition\\n- third condition:\\n    - Button 1: toggles to fourth condition\\n    - Button 2: toggles to first condition\\n    - Button 3: toggles to second condition\\n- fourth condition:\\n    - Button 1: toggles to third condition\\n    - Button 2: toggles to second condition\\n    - Button 3: toggles to the first conditions\\n\\nSo there are 8 possible states achievable given any number of button presses (at least 3) when there are at least 3 bulbs. Per the above, each of these states can be achieved by at most 3 presses.\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: return 1\\n        if n == 1: return 2\\n        elif n == 2: \\n            if presses == 1:\\n                return 3\\n            else: \\n                return 4\\n        elif presses == 1: return 4\\n        elif presses == 2: return 7\\n        else: return 8\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: return 1\\n        if n == 1: return 2\\n        elif n == 2: \\n            if presses == 1:\\n                return 3\\n            else: \\n                return 4\\n        elif presses == 1: return 4\\n        elif presses == 2: return 7\\n        else: return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881799,
                "title": "python3-modified-bfs",
                "content": "# Intuition\\nRepresent \"state\" with 4 lightbulbs, then just flip them and see what we get.  If there\\'s less lightbulbs than 4, then just hide them with a bitmask (bm)\\n\\nPresses bumps up against the pidgeonhole problem.  The 5th toggle, necessarily is going to be reverting a previous button press, therefore we can infer that any state achieved by an EVEN number >=4 can also be achieved by exactly 4 and any odd number higher than 4 can be represented by 5.  So there\\'s no need to go further than that.\\n\\nops variable represents bits corresponding to which lightbulbs will be toggled with each button press.  4 buttons = 4 operations\\n\\n# Note\\nYes, I am aware I could copy my output and put it into a lookup table for O(1), I just don\\'t find that as interesting\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(4, n)\\n        if presses > 4:\\n            presses = 4 + presses % 2\\n\\n        ops = [15, 5, 10, 9]\\n\\n        items = [(0, 0)]\\n        \\n        found = set()\\n\\n        bm = (1<<n) - 1\\n\\n        while items:\\n            p, s = items.pop(0)\\n            if p == presses:\\n                found.add(s & bm)\\n            else:\\n                for o in ops:\\n                    items.append((p+1, s^o))\\n        \\n        return len(found)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(4, n)\\n        if presses > 4:\\n            presses = 4 + presses % 2\\n\\n        ops = [15, 5, 10, 9]\\n\\n        items = [(0, 0)]\\n        \\n        found = set()\\n\\n        bm = (1<<n) - 1\\n\\n        while items:\\n            p, s = items.pop(0)\\n            if p == presses:\\n                found.add(s & bm)\\n            else:\\n                for o in ops:\\n                    items.append((p+1, s^o))\\n        \\n        return len(found)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694529,
                "title": "python-o-1-solution-faster-than-84",
                "content": "```\\n\\'\\'\\'\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: \\n            return 1\\n        if n == 1: \\n            return 2\\n        if n == 2 and presses == 1: \\n            return 3\\n        if n == 2: \\n            return 4\\n        if presses == 1: \\n            return 4\\n        if presses == 2: \\n            return 7\\n        if presses >= 3: \\n            return 8\\n        return 8\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\'\\'\\'\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: \\n            return 1\\n        if n == 1: \\n            return 2\\n        if n == 2 and presses == 1: \\n            return 3\\n        if n == 2: \\n            return 4\\n        if presses == 1: \\n            return 4\\n        if presses == 2: \\n            return 7\\n        if presses >= 3: \\n            return 8\\n        return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631375,
                "title": "c-amazing-question-with-ad-hoc-o-1-solution",
                "content": "Great question indeed.\\n\\nHere\\'s the logic:\\n\\nLet 0 = switched off, 1 = switched on.\\n\\n* You don\\'t have to simulate the entire process (e.g. press buttons 1000 times, for each time, randomly select button 1 to 4).\\n\\n* Instead, notice the **base cases**: \\n\\n\\t1. If you press 1 button **even** number of times (e.g. 0, 2, 4, ...), **the effect cancelled out**. (on->off->on->off...->on->off). So, the initial state (all switched off) = \"00...000\" is possible.\\n\\t2. In contrast, If you press 1 button **odd** number of times, it is **equivalent to pressing 1 of the four buttons 1 time.**\\n\\n* Next, you shall notice that you can press 2, 3 or 4 **distinct** buttons odd number of times to create **distinct** states. The exact figure of pressing button one to four is irrelevant.\\n\\n\\t* For example, if you have a press sequence like \"11233223321244\", that\\'s equivalent to pressing \"12\". \\n\\n* Also, Recall simple combination, 4C2 = 6, 4C3 = 4, 4C4 = 1.\\n\\n* And notices that:\\n\\n\\t1. If the **even number of counts >= 2**, then you can press two buttons odd number of times.\\n\\ta. For example, if number of counts = 4, you can press one button 3 times, and the second button 1 time.\\n\\nBased on all those rules, you can derive the conditionals easily.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    set<string> res;\\n    string opt1(string s) {\\n        for (int i = 0; i < s.length(); i++) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt2(string s) {\\n        for (int i = 0; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt3(string s) {\\n        for (int i = 1; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt4(string s) {\\n        int k;\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) { k = 3 * i; if (k >= len) { break; } s[k] = s[k] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    int flipLights(int n, int p) {\\n        string init(n, \\'0\\');\\n        res.clear();\\n        if (p == 0)\\n            return 1;\\n        if ((p & 1) == 0) {\\n            res.insert(init);\\n        }\\n        if ((p & 1) != 0) {\\n            res.insert(opt1(init));\\n            res.insert(opt2(init));\\n            res.insert(opt3(init));\\n            res.insert(opt4(init));\\n        }\\n        if (p >= 2) {\\n            if ((p >= 2 && p % 2 == 0 && ((p / 2) & 1) != 0) || \\n                (p >= 4 && ((p - 2) & 1) == 0) ||\\n                (p >= 6 && ((p - 4) & 1) == 0)) {\\n                res.insert(opt2(opt1(init)));\\n                res.insert(opt3(opt1(init)));\\n                res.insert(opt4(opt1(init)));\\n                res.insert(opt3(opt2(init)));\\n                res.insert(opt4(opt2(init)));\\n                res.insert(opt4(opt3(init)));\\n            }\\n        }\\n        if (p >= 3 && (p & 1) != 0) {\\n            res.insert(opt3(opt2(opt1(init))));\\n            res.insert(opt4(opt2(opt1(init))));\\n            res.insert(opt4(opt3(opt1(init))));\\n            res.insert(opt4(opt3(opt2(init))));            \\n        }\\n        if (p >= 4) {\\n            if ((p % 4 == 0 && ((p / 4) & 1) != 0) ||\\n                (((p - 3) & 1) != 0) ||\\n                (((p - 2) & 1) == 0) ||\\n                (((p - 1) & 1) != 0)) {\\n                res.insert(opt4(opt3(opt2(opt1(init)))));\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    set<string> res;\\n    string opt1(string s) {\\n        for (int i = 0; i < s.length(); i++) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt2(string s) {\\n        for (int i = 0; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt3(string s) {\\n        for (int i = 1; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt4(string s) {\\n        int k;\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) { k = 3 * i; if (k >= len) { break; } s[k] = s[k] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    int flipLights(int n, int p) {\\n        string init(n, \\'0\\');\\n        res.clear();\\n        if (p == 0)\\n            return 1;\\n        if ((p & 1) == 0) {\\n            res.insert(init);\\n        }\\n        if ((p & 1) != 0) {\\n            res.insert(opt1(init));\\n            res.insert(opt2(init));\\n            res.insert(opt3(init));\\n            res.insert(opt4(init));\\n        }\\n        if (p >= 2) {\\n            if ((p >= 2 && p % 2 == 0 && ((p / 2) & 1) != 0) || \\n                (p >= 4 && ((p - 2) & 1) == 0) ||\\n                (p >= 6 && ((p - 4) & 1) == 0)) {\\n                res.insert(opt2(opt1(init)));\\n                res.insert(opt3(opt1(init)));\\n                res.insert(opt4(opt1(init)));\\n                res.insert(opt3(opt2(init)));\\n                res.insert(opt4(opt2(init)));\\n                res.insert(opt4(opt3(init)));\\n            }\\n        }\\n        if (p >= 3 && (p & 1) != 0) {\\n            res.insert(opt3(opt2(opt1(init))));\\n            res.insert(opt4(opt2(opt1(init))));\\n            res.insert(opt4(opt3(opt1(init))));\\n            res.insert(opt4(opt3(opt2(init))));            \\n        }\\n        if (p >= 4) {\\n            if ((p % 4 == 0 && ((p / 4) & 1) != 0) ||\\n                (((p - 3) & 1) != 0) ||\\n                (((p - 2) & 1) == 0) ||\\n                (((p - 1) & 1) != 0)) {\\n                res.insert(opt4(opt3(opt2(opt1(init)))));\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615933,
                "title": "python-top-down-dp",
                "content": "```\\nfrom functools import cache\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        state = tuple([True]*min(6, n))\\n        states = set()\\n        def flip(v, idxs):\\n            for i in idxs:\\n                v[i] = not v[i]\\n        @cache\\n        def dfs(v, press_cnt):\\n            if press_cnt == presses:\\n                if v not in states: \\n                    states.add(v)\\n                return\\n            w = list(v)\\n            flip(w, range(len(w)))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(1,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),3))\\n            dfs(tuple(w), press_cnt + 1)\\n        dfs(state, 0)\\n        return len(states)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        state = tuple([True]*min(6, n))\\n        states = set()\\n        def flip(v, idxs):\\n            for i in idxs:\\n                v[i] = not v[i]\\n        @cache\\n        def dfs(v, press_cnt):\\n            if press_cnt == presses:\\n                if v not in states: \\n                    states.add(v)\\n                return\\n            w = list(v)\\n            flip(w, range(len(w)))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(1,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),3))\\n            dfs(tuple(w), press_cnt + 1)\\n        dfs(state, 0)\\n        return len(states)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2586762,
                "title": "bulb-switcher-easy-easy-approch-best-solution",
                "content": "class Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 3 + (p > 1);\\n        }\\n        if (p == 1) {\\n            return 4;\\n        }\\n        if (p == 2) {\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2448655,
                "title": "bulb-switcher-ii-0ms",
                "content": "\\n    public int flipLights(int n, int p) {\\n    if (p == 0) \\n      return 1;\\n    if (n == 1)\\n      return 2;\\n    if (n == 2){\\n        if(p==1)\\n            return 3;\\n        return 4;\\n    }\\n    if (p== 1)\\n      return 4;\\n    else{\\n        if(p==2)\\n            return 7;\\n        return 8;\\n    }\\n  }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int flipLights(int n, int p) {\\n    if (p == 0) \\n      return 1;\\n    if (n == 1)\\n      return 2;\\n    if (n == 2){\\n        if(p==1)\\n            return 3;\\n        return 4;\\n    }\\n    if (p== 1)\\n      return 4;\\n    else{\\n        if(p==2)\\n            return 7;\\n        return 8;\\n    }\\n  }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2437696,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 3 + (p > 1);\\n        }\\n        if (p == 1) {\\n            return 4;\\n        }\\n        if (p == 2) {\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 3 + (p > 1);\\n        }\\n        if (p == 1) {\\n            return 4;\\n        }\\n        if (p == 2) {\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426754,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  int flipLights(const int n, const int presses) {\\n    if (presses == 0) {\\n      /**\\n       * all bulbs are turned on\\n       */\\n      return 1;\\n    }\\n    if (n == 1) {\\n      /**\\n       * the only bulb is turned on or off, since any button can be pressed at least once\\n       */\\n      return 2;\\n    }\\n    if (n == 2) {\\n      /**\\n       * 1. if `presses` is `1`, pressing button 3 and pressing button 4 have the same effect,\\n       *    so the number of different possible statuses after performing one button press is 3,\\n       *    that is i) press the button 1, ii) press the button 2, iii) press the button 3\\n       * 2. if `presses` is `2`, all 4 different possible statuses can be achieved finally.\\n       */\\n      return presses == 1 ? 3 : 4;\\n    }\\n    if (presses == 1) {\\n      /**\\n       * 1. press button 1 once\\n       * 2. press button 2 once\\n       * 3. press button 3 once\\n       * 4. press button 4 once\\n       */\\n      return 4;\\n    }\\n    /**\\n     * there are 8 possible statuses\\n     * 1. all bulbs are turned on\\n     * 2. press button 1\\n     * 3. press button 2\\n     * 4. press button 3\\n     * 5. press button 4\\n     * 6. press button 1 and 4\\n     * 7. press button 2 and 4\\n     * 8. press button 3 and 4\\n     *\\n     * a) if `presses` is 2, all 8 possible statuses except `5` can be achieved\\n     * b) if `presses` is greater than 2, all 8 possible statuses can be achieved\\n     */\\n    return presses == 2 ? 7 : 8;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  int flipLights(const int n, const int presses) {\\n    if (presses == 0) {\\n      /**\\n       * all bulbs are turned on\\n       */\\n      return 1;\\n    }\\n    if (n == 1) {\\n      /**\\n       * the only bulb is turned on or off, since any button can be pressed at least once\\n       */\\n      return 2;\\n    }\\n    if (n == 2) {\\n      /**\\n       * 1. if `presses` is `1`, pressing button 3 and pressing button 4 have the same effect,\\n       *    so the number of different possible statuses after performing one button press is 3,\\n       *    that is i) press the button 1, ii) press the button 2, iii) press the button 3\\n       * 2. if `presses` is `2`, all 4 different possible statuses can be achieved finally.\\n       */\\n      return presses == 1 ? 3 : 4;\\n    }\\n    if (presses == 1) {\\n      /**\\n       * 1. press button 1 once\\n       * 2. press button 2 once\\n       * 3. press button 3 once\\n       * 4. press button 4 once\\n       */\\n      return 4;\\n    }\\n    /**\\n     * there are 8 possible statuses\\n     * 1. all bulbs are turned on\\n     * 2. press button 1\\n     * 3. press button 2\\n     * 4. press button 3\\n     * 5. press button 4\\n     * 6. press button 1 and 4\\n     * 7. press button 2 and 4\\n     * 8. press button 3 and 4\\n     *\\n     * a) if `presses` is 2, all 8 possible statuses except `5` can be achieved\\n     * b) if `presses` is greater than 2, all 8 possible statuses can be achieved\\n     */\\n    return presses == 2 ? 7 : 8;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352345,
                "title": "beats-100-solns-state-diagram-for-understanding",
                "content": "```\\n---------------------------STATE DIAGRAM --------------------------\\n\\na* means a some p times (aaa...a)\\n\\n0* --on step 1-->1*\\n0* --on step 2-->(01)*\\n0* --on step 3-->(10)*\\n0* --on step 4-->(100)*\\n\\n1* --on step 1-->0*\\n1* --on step 2-->(10)*\\n1* --on step 3-->(01)*\\n1* --on step 4-->(011)*\\n\\n(01)* --on step 1-->(10)*\\n(01)* --on step 2-->(0)*\\n(01)* --on step 3-->(1)*\\n(01)* --on step 4-->(110001)*\\n\\n(10)* --on step 1-->(01)*\\n(10)* --on step 2-->(1)*\\n(10)* --on step 3-->(0)*\\n(10)* --on step 4-->(001110)*\\n\\n(011)* --on step 1-->(100)*\\n(011)* --on step 2-->(001110)*\\n(011)* --on step 3-->(110001)*\\n(011)* --on step 4-->(1)*\\n\\n(100)* --on step 1-->(011)*\\n(100)* --on step 2-->(110001)*\\n(100)* --on step 3-->(001110)*\\n(100)* --on step 4-->(0)*\\n\\n(110001)* --on step 1-->(001110)*\\n(110001)* --on step 2-->(100)*\\n(110001)* --on step 3-->(011)*\\n(110001)* --on step 4-->(01)*\\n\\n(001110)* --on step 1-->(110001)*\\n(001110)* --on step 2-->(011)*\\n(001110)* --on step 3-->(100)*\\n(001110)* --on step 4-->(10)*\\n\\n\\n\\nso there a 8 states => 0, 1, 01, 10, 100, 011, 110001, 001110\\n\\nif n==1\\n\\t0 = 01 = 011 = 001110\\n\\t1 = 10 = 100 = 110001\\nif n==2\\n\\t0 = 001110\\n\\t1 = 110001\\n\\t01, 10, 100, 011 are distinct states\\nif n>=3\\n\\tall states are different\\nif presses == 0\\n\\tthere is only 1 state i.e 0*\\nif presses == 1\\n\\tu can reach 4 states from 0*\\nif presses == 2\\n\\tu can reach 7 states from 0*\\nif presses == 3\\n\\tu can reach all 8 states from 0*\\nbut remember among these s states some may be common depending on n value as stated above. Have fun!!\\n\\n```\\n\\n```\\n/*code*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0){\\n            return 1;\\n        }\\n        if(n == 1){\\n            return 2;\\n        } else if(n == 2){\\n            if(k == 1){\\n                return 3;\\n            } else {\\n                return 4;                \\n            }\\n        } else {\\n            if(k == 1){\\n                return 4;\\n            } else if(k == 2){\\n                return 7;\\n            }else {\\n                return 8;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n---------------------------STATE DIAGRAM --------------------------\\n\\na* means a some p times (aaa...a)\\n\\n0* --on step 1-->1*\\n0* --on step 2-->(01)*\\n0* --on step 3-->(10)*\\n0* --on step 4-->(100)*\\n\\n1* --on step 1-->0*\\n1* --on step 2-->(10)*\\n1* --on step 3-->(01)*\\n1* --on step 4-->(011)*\\n\\n(01)* --on step 1-->(10)*\\n(01)* --on step 2-->(0)*\\n(01)* --on step 3-->(1)*\\n(01)* --on step 4-->(110001)*\\n\\n(10)* --on step 1-->(01)*\\n(10)* --on step 2-->(1)*\\n(10)* --on step 3-->(0)*\\n(10)* --on step 4-->(001110)*\\n\\n(011)* --on step 1-->(100)*\\n(011)* --on step 2-->(001110)*\\n(011)* --on step 3-->(110001)*\\n(011)* --on step 4-->(1)*\\n\\n(100)* --on step 1-->(011)*\\n(100)* --on step 2-->(110001)*\\n(100)* --on step 3-->(001110)*\\n(100)* --on step 4-->(0)*\\n\\n(110001)* --on step 1-->(001110)*\\n(110001)* --on step 2-->(100)*\\n(110001)* --on step 3-->(011)*\\n(110001)* --on step 4-->(01)*\\n\\n(001110)* --on step 1-->(110001)*\\n(001110)* --on step 2-->(011)*\\n(001110)* --on step 3-->(100)*\\n(001110)* --on step 4-->(10)*\\n\\n\\n\\nso there a 8 states => 0, 1, 01, 10, 100, 011, 110001, 001110\\n\\nif n==1\\n\\t0 = 01 = 011 = 001110\\n\\t1 = 10 = 100 = 110001\\nif n==2\\n\\t0 = 001110\\n\\t1 = 110001\\n\\t01, 10, 100, 011 are distinct states\\nif n>=3\\n\\tall states are different\\nif presses == 0\\n\\tthere is only 1 state i.e 0*\\nif presses == 1\\n\\tu can reach 4 states from 0*\\nif presses == 2\\n\\tu can reach 7 states from 0*\\nif presses == 3\\n\\tu can reach all 8 states from 0*\\nbut remember among these s states some may be common depending on n value as stated above. Have fun!!\\n\\n```\n```\\n/*code*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0){\\n            return 1;\\n        }\\n        if(n == 1){\\n            return 2;\\n        } else if(n == 2){\\n            if(k == 1){\\n                return 3;\\n            } else {\\n                return 4;                \\n            }\\n        } else {\\n            if(k == 1){\\n                return 4;\\n            } else if(k == 2){\\n                return 7;\\n            }else {\\n                return 8;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342649,
                "title": "simple-swift-solution-with-explanation-beats-100",
                "content": "## Code \\n\\n```\\nclass Solution {\\n    func flipLights(_ n: Int, _ presses: Int) -> Int {\\n        if n < 3 {\\n            return min(1 << n, [1, 3, 4][min(presses, 2)])\\n        }\\n        return [1, 4, 7, 8][min(presses, 3)]\\n    }\\n}\\n```\\n\\n## Explanation\\n\\n1. If n < 3, then the answer is the minimum of the two possible answers:\\n    a. 1 << n, which is the number of lights that are on if all are off\\n    b. [1, 3, 4][min(presses, 2)], which is the number of lights that are on if only the first and last are off\\n2. If n >= 3, then the answer is the minimum of the three possible answers:\\n    a. [1, 4, 7, 8][min(presses, 3)], which is the number of lights that are on if only the first, second, and last are off\\n    b. 1 << n, which is the number of lights that are on if all are off\\n    c. [1, 3, 4][min(presses, 2)], which is the number of lights that are on if only the first and last are off",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func flipLights(_ n: Int, _ presses: Int) -> Int {\\n        if n < 3 {\\n            return min(1 << n, [1, 3, 4][min(presses, 2)])\\n        }\\n        return [1, 4, 7, 8][min(presses, 3)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339209,
                "title": "c-simulation-no-math-alternative-solution-0ms",
                "content": "# C++ Simulation, no math, alternative solution\\n\\nI do like the pure math solutions. \\nHere, I just want to show that we have an alternative (to the math ones), and that the plain old simulation method works, and it also runs fast in 0ms.\\n\\n```\\n// Idea / Approach: simulation we need only 4 bulbs 1..4 to cover all cases.\\nclass Solution { // _Simulation\\n    static unordered_set<uint8_t> simulateStep(const unordered_set<uint8_t>& states, uint8_t mask) {\\n        auto op1 = [](uint8_t x) { return x ^ 0x0f; };\\n        auto op2 = [](uint8_t x) { return x ^ 0b1010; };\\n        auto op3 = [](uint8_t x) { return x ^ 0b0101; };\\n        auto op4 = [](uint8_t x) { return x ^ 0b1001; };\\n\\n        unordered_set<uint8_t> res;\\n        for (auto x : states) {\\n            res.insert(op1(x) & mask);\\n            res.insert(op2(x) & mask);\\n            res.insert(op3(x) & mask);\\n            res.insert(op4(x) & mask);\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        }\\n\\n        uint8_t mask = 0x0F;\\n        if (n == 1) {\\n            mask = 1;\\n        } else if (n == 2) {\\n            mask = 0b11;\\n        } else if (n == 3) {\\n            mask = 0b111;\\n        }\\n        unordered_set<uint8_t> reached; // reached states\\n        reached.insert(0x0F & mask);\\n\\t\\t// if presses > 4, then there must be p-4 presses that are cancelling each other, and not\\n        // creating new states.\\n        // so we can max it out at 4.\\n        for (int i = 0; i < min(4, presses); ++i) {\\n            reached = simulateStep(reached, mask);\\n        }\\n        return reached.size();\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n// Idea / Approach: simulation we need only 4 bulbs 1..4 to cover all cases.\\nclass Solution { // _Simulation\\n    static unordered_set<uint8_t> simulateStep(const unordered_set<uint8_t>& states, uint8_t mask) {\\n        auto op1 = [](uint8_t x) { return x ^ 0x0f; };\\n        auto op2 = [](uint8_t x) { return x ^ 0b1010; };\\n        auto op3 = [](uint8_t x) { return x ^ 0b0101; };\\n        auto op4 = [](uint8_t x) { return x ^ 0b1001; };\\n\\n        unordered_set<uint8_t> res;\\n        for (auto x : states) {\\n            res.insert(op1(x) & mask);\\n            res.insert(op2(x) & mask);\\n            res.insert(op3(x) & mask);\\n            res.insert(op4(x) & mask);\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        }\\n\\n        uint8_t mask = 0x0F;\\n        if (n == 1) {\\n            mask = 1;\\n        } else if (n == 2) {\\n            mask = 0b11;\\n        } else if (n == 3) {\\n            mask = 0b111;\\n        }\\n        unordered_set<uint8_t> reached; // reached states\\n        reached.insert(0x0F & mask);\\n\\t\\t// if presses > 4, then there must be p-4 presses that are cancelling each other, and not\\n        // creating new states.\\n        // so we can max it out at 4.\\n        for (int i = 0; i < min(4, presses); ++i) {\\n            reached = simulateStep(reached, mask);\\n        }\\n        return reached.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309835,
                "title": "c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n    //Regardless how many n lightbulbs there are with initial state ON=>only 1 state\\n        if (presses==0) return 1;   \\n    //[ flip all, flip odd, or flip 3k+1 ] is OFF.\\n    //[ flip even ] is ON \\n        if (n==1)\\n    //Either this one lightbulb is ON or OFF after m=1 operations. Any additional operations revert the lightbulb to a previous state\\n            if (presses>=1) return 2;\\n                 /*  0 0 ( after 1 operation: flip all )\\n                     0 1 ( after 1 operation: flip odd or 3k+1 )\\n                     1 0 ( after 1 operation: flip even )\\n                  */\\n        if (n==2){\\n            if (presses==1) return 3;\\n            /*\\n               00 or 01 or 10 or 11 possible \\n            */\\n            if (presses>=2) return 4;\\n        }\\n        if (n>=3){\\n            //000 or 010 or 011 or 101\\n            if (presses==1) return 4;\\n            //000 or 001 or 010 or 100 or 101 or 110 or 111\\n            if (presses==2) return 7;\\n            //000 or 001 or 010 or 011 or 100 or 101 or 110 or 111\\n            if (presses>=3) return 8;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n    //Regardless how many n lightbulbs there are with initial state ON=>only 1 state\\n        if (presses==0) return 1;   \\n    //[ flip all, flip odd, or flip 3k+1 ] is OFF.\\n    //[ flip even ] is ON \\n        if (n==1)\\n    //Either this one lightbulb is ON or OFF after m=1 operations. Any additional operations revert the lightbulb to a previous state\\n            if (presses>=1) return 2;\\n                 /*  0 0 ( after 1 operation: flip all )\\n                     0 1 ( after 1 operation: flip odd or 3k+1 )\\n                     1 0 ( after 1 operation: flip even )\\n                  */\\n        if (n==2){\\n            if (presses==1) return 3;\\n            /*\\n               00 or 01 or 10 or 11 possible \\n            */\\n            if (presses>=2) return 4;\\n        }\\n        if (n>=3){\\n            //000 or 010 or 011 or 101\\n            if (presses==1) return 4;\\n            //000 or 001 or 010 or 100 or 101 or 110 or 111\\n            if (presses==2) return 7;\\n            //000 or 001 or 010 or 011 or 100 or 101 or 110 or 111\\n            if (presses>=3) return 8;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214239,
                "title": "python-simple-logic",
                "content": "\\n    def flipLights(self, n, presses):\\n        if presses == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if presses<2 else 4\\n        else:\\n            if presses == 1:\\n                return 4\\n            if presses == 2:\\n                return 7\\n            else:\\n                return 8",
                "solutionTags": [],
                "code": "\\n    def flipLights(self, n, presses):\\n        if presses == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if presses<2 else 4\\n        else:\\n            if presses == 1:\\n                return 4\\n            if presses == 2:\\n                return 7\\n            else:\\n                return 8",
                "codeTag": "Python3"
            },
            {
                "id": 2110980,
                "title": "c-o-1-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/c73cf10c-367d-4de6-a1fa-eb26b123bd99_1654369307.6417487.png)\\n\\n```\\nint flipLights(int n, int m) {\\n\\tif (m==0) return 1;\\n\\tif(n==1) return 2;\\n\\tif(n==2) return m==1?3:4;\\n\\treturn m==1?4:m==2?7:8;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint flipLights(int n, int m) {\\n\\tif (m==0) return 1;\\n\\tif(n==1) return 2;\\n\\tif(n==2) return m==1?3:4;\\n\\treturn m==1?4:m==2?7:8;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028988,
                "title": "bulb-switcher-python-implementation",
                "content": "class Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \\n        # when there are no presses, the status will stay\\n        if presses == 0: return 1\\n        \\n        # when there is one bulb, whatever be the no. of presses : possibilities = [off, on]\\n        if n == 1: return 2\\n        \\n        # when there are two bulbs, if no. of presses is 1 : possibilities = [(on,off), (off,on),(off,off)]\\n        # when there are two bulbs, if no. of presses is not 1 : possibilities = [(on, off), (off, on), (off, off), (on, on)]\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            return 4\\n        \\n        # when there are three bulbs, if no. of presses is 1: possibilities = [(off, off, off), (on, off, on), (off, on, off), (off, on, on)]\\n        # this status remains the same for bulbs greater than 4 (check it out with n = 4)\\n        if presses == 1: return 4\\n        \\n        # when there are more than 2 bulbs with 2 presses, it will have 7 possibilities (check it out with n = 3 and presses = 2)\\n        if presses == 2:\\n            return 7\\n        # else\\n        return 8",
                "solutionTags": [],
                "code": "class Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \\n        # when there are no presses, the status will stay\\n        if presses == 0: return 1\\n        \\n        # when there is one bulb, whatever be the no. of presses : possibilities = [off, on]\\n        if n == 1: return 2\\n        \\n        # when there are two bulbs, if no. of presses is 1 : possibilities = [(on,off), (off,on),(off,off)]\\n        # when there are two bulbs, if no. of presses is not 1 : possibilities = [(on, off), (off, on), (off, off), (on, on)]\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            return 4\\n        \\n        # when there are three bulbs, if no. of presses is 1: possibilities = [(off, off, off), (on, off, on), (off, on, off), (off, on, on)]\\n        # this status remains the same for bulbs greater than 4 (check it out with n = 4)\\n        if presses == 1: return 4\\n        \\n        # when there are more than 2 bulbs with 2 presses, it will have 7 possibilities (check it out with n = 3 and presses = 2)\\n        if presses == 2:\\n            return 7\\n        # else\\n        return 8",
                "codeTag": "Java"
            },
            {
                "id": 2024121,
                "title": "rust-solution-with-pattern-match",
                "content": "```rust\\nimpl Solution {\\n    pub fn flip_lights(n: i32, presses: i32) -> i32 {\\n        match (n, presses) {\\n            (_, 0) => 1,\\n            (1, _) => 2,\\n            (2, 1) => 3,\\n            (2, _) => 4,\\n            (_, 1) => 4,\\n            (_, 2) => 7,\\n            (_, presses @ _) if presses > 3 => 8,\\n            (_, _) => 8,\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn flip_lights(n: i32, presses: i32) -> i32 {\\n        match (n, presses) {\\n            (_, 0) => 1,\\n            (1, _) => 2,\\n            (2, 1) => 3,\\n            (2, _) => 4,\\n            (_, 1) => 4,\\n            (_, 2) => 7,\\n            (_, presses @ _) if presses > 3 => 8,\\n            (_, _) => 8,\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008515,
                "title": "kotlin-brute-force-and-math-solution",
                "content": "Please, let me know if you have any questions.\\n\\n```\\nclass Solution {\\n    class BruteForceSolution {\\n        // This was the first idea: generate all possible combinations of button presses\\n        // and simulate it on given bulbs. Clearly it does\\'t fit any time limits :D\\n        fun flipLights(n: Int, presses: Int): Int {\\n            val states = HashSet<MutableList<Boolean>>()\\n\\n            val combinations = mutableListOf<MutableList<Int>>()\\n            generatePressesCombinations(combinations, MutableList(presses) { -1 }, presses)\\n\\n            for (combination in combinations) {\\n                val lights = MutableList(n) { true }\\n                for (button in combination) {\\n                    when (button) {\\n                        1 -> {\\n                            for (i in 1..lights.size) {\\n                                toggle(lights, i)\\n                            }\\n                        }\\n                        2 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        3 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 1) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        4 -> {\\n                            for (i in 1..lights.size) {\\n                                if ((i - 1) % 3 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                states.add(lights)\\n            }\\n\\n            return states.count()\\n        }\\n\\n        private fun toggle(lights: MutableList<Boolean>, i: Int) {\\n            lights[i - 1] = lights[i - 1].not()\\n        }\\n\\n        private fun generatePressesCombinations(\\n            combinations: MutableList<MutableList<Int>>,\\n            combination: MutableList<Int>,\\n            pressesRemaining: Int\\n        ) {\\n            if (pressesRemaining > 0) {\\n                for (button in 1..4) {\\n                    val tempCombination = mutableListOf(*combination.toTypedArray())\\n                    tempCombination[tempCombination.size - pressesRemaining] = button\\n                    generatePressesCombinations(combinations, tempCombination, pressesRemaining - 1)\\n                }\\n            } else {\\n                combinations.add(combination)\\n            }\\n        }\\n    }\\n\\n    class GodHelpMeSolution { // I\\'m crying xD\\n        // This solution came to my mind when I realised there is a finite number of states for given bulbs for every n.\\n        // For different n it is different. So I built a table/graph representing this state machine.\\n        // What bulbs are switched on:\\n        // A - all\\n        // N - none\\n        // E - evens\\n        // O - odds\\n        // A# - all but thirds\\n        // N# - none but thirds\\n        // E# - evens except thirds\\n        // O# - odds except thirds\\n        // ___| 1B | 2B | 3B | 4B |\\n        // A  | N  | O  | E  | A# |\\n        // N  | A  | E  | O  | N# |\\n        // O  | E  | N  | A  | O# |\\n        // E  | O  | A  | N  | E# |\\n        // A# | N# | O# | E# | A  |\\n        // N# | A# | E# | O# | N  |\\n        // O# | E# | N# | A# | O  |\\n        // E# | O# | A# | N# | E  |\\n        // Starting from 3 bulbs and 3 presses this system can be in 8 different states described in this table.\\n        // When bulbs and presses are lower than 3 we can count number of states we can reach with use of table above.\\n        fun flipLights(bulbs: Int, presses: Int): Int {\\n            return when (bulbs) {\\n                0 -> 1\\n                1 -> when (presses) {\\n                    0 -> 1\\n                    else -> 2\\n                }\\n                2 -> when (presses) {\\n                    0 -> 1\\n                    1 -> 3\\n                    else -> 4\\n                }\\n                else -> when (presses) {\\n                    0 -> 1\\n                    1 -> 4\\n                    2 -> 7\\n                    else -> 8\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    class BruteForceSolution {\\n        // This was the first idea: generate all possible combinations of button presses\\n        // and simulate it on given bulbs. Clearly it does\\'t fit any time limits :D\\n        fun flipLights(n: Int, presses: Int): Int {\\n            val states = HashSet<MutableList<Boolean>>()\\n\\n            val combinations = mutableListOf<MutableList<Int>>()\\n            generatePressesCombinations(combinations, MutableList(presses) { -1 }, presses)\\n\\n            for (combination in combinations) {\\n                val lights = MutableList(n) { true }\\n                for (button in combination) {\\n                    when (button) {\\n                        1 -> {\\n                            for (i in 1..lights.size) {\\n                                toggle(lights, i)\\n                            }\\n                        }\\n                        2 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        3 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 1) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        4 -> {\\n                            for (i in 1..lights.size) {\\n                                if ((i - 1) % 3 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                states.add(lights)\\n            }\\n\\n            return states.count()\\n        }\\n\\n        private fun toggle(lights: MutableList<Boolean>, i: Int) {\\n            lights[i - 1] = lights[i - 1].not()\\n        }\\n\\n        private fun generatePressesCombinations(\\n            combinations: MutableList<MutableList<Int>>,\\n            combination: MutableList<Int>,\\n            pressesRemaining: Int\\n        ) {\\n            if (pressesRemaining > 0) {\\n                for (button in 1..4) {\\n                    val tempCombination = mutableListOf(*combination.toTypedArray())\\n                    tempCombination[tempCombination.size - pressesRemaining] = button\\n                    generatePressesCombinations(combinations, tempCombination, pressesRemaining - 1)\\n                }\\n            } else {\\n                combinations.add(combination)\\n            }\\n        }\\n    }\\n\\n    class GodHelpMeSolution { // I\\'m crying xD\\n        // This solution came to my mind when I realised there is a finite number of states for given bulbs for every n.\\n        // For different n it is different. So I built a table/graph representing this state machine.\\n        // What bulbs are switched on:\\n        // A - all\\n        // N - none\\n        // E - evens\\n        // O - odds\\n        // A# - all but thirds\\n        // N# - none but thirds\\n        // E# - evens except thirds\\n        // O# - odds except thirds\\n        // ___| 1B | 2B | 3B | 4B |\\n        // A  | N  | O  | E  | A# |\\n        // N  | A  | E  | O  | N# |\\n        // O  | E  | N  | A  | O# |\\n        // E  | O  | A  | N  | E# |\\n        // A# | N# | O# | E# | A  |\\n        // N# | A# | E# | O# | N  |\\n        // O# | E# | N# | A# | O  |\\n        // E# | O# | A# | N# | E  |\\n        // Starting from 3 bulbs and 3 presses this system can be in 8 different states described in this table.\\n        // When bulbs and presses are lower than 3 we can count number of states we can reach with use of table above.\\n        fun flipLights(bulbs: Int, presses: Int): Int {\\n            return when (bulbs) {\\n                0 -> 1\\n                1 -> when (presses) {\\n                    0 -> 1\\n                    else -> 2\\n                }\\n                2 -> when (presses) {\\n                    0 -> 1\\n                    1 -> 3\\n                    else -> 4\\n                }\\n                else -> when (presses) {\\n                    0 -> 1\\n                    1 -> 4\\n                    2 -> 7\\n                    else -> 8\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934254,
                "title": "simple-c",
                "content": "\\tpublic class Solution {\\n    public int FlipLights(int n, int m) {\\n\\n         if (n == 1 && m > 0) {\\n                return 2;\\n            } else if (n == 2 && m == 1) {\\n                return 3;\\n            } else if ((n > 2 && m == 1) || (n == 2 && m > 1)) {\\n                return 4;\\n            } else if (n > 2 && m == 2) {\\n                return 7;\\n            } else if (n > 2 && m > 2) {\\n                return 8;\\n            } else {\\n                return 1;\\n            }\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int FlipLights(int n, int m) {\\n\\n         if (n == 1 && m > 0) {\\n                return 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1817884,
                "title": "is-it-just-me-or-anyone-feel-this-problem-should-be-hard",
                "content": "I feel this problem is pretty hard to be medium, lots of brain power, no typical algo/DS",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1449424,
                "title": "javascript-simple-4-line-logic",
                "content": "```\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) return 1;\\n    if (presses === 1) return n <= 2 ? n + 1 : 4;\\n    if (n <= 2) return 2 * n;\\n    return 7 + (presses >= 3);\\n};",
                "solutionTags": [],
                "code": "```\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) return 1;\\n    if (presses === 1) return n <= 2 ? n + 1 : 4;\\n    if (n <= 2) return 2 * n;\\n    return 7 + (presses >= 3);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1371395,
                "title": "simple-math-c-solution",
                "content": "Problem is similar to Bul Switcher 1 in the aspect, that we can work out a pattern in the bulbs and presses. If n==0 or presses == 0, there is only 1 state = all ON.\\nIf n == 1, then (as we have already accounted for presses==0), then with atleast 1 press, that one bulb can be ON or OFF. \\nIf n==2, if presses==1, the odd switch and 3k+1 switch will produce same result and hence, will give 2^2 - 1 = 3 patters. If presses is >=1, then states can be 4.\\nNow for any n>2, if presses = 1, there can be 4 states (each switch producing different states). If presses=2, we there can be only 7 unique states and for presses>2, there can be 8.\\nThere cant be any more unique states for the sequence as patterns are repeated between bulbs and if presses are >=3, then we are guaranteed atleast one of the bulb toggled by previous operations will return back to same state, hence keeping number of unique states same as before.\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0 || n==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return (presses==1)?3:4;\\n        if(presses==1) return 4;\\n        return (presses==2)?7:8;\\n    }\\n};\\n```\\nTime complexity = O(1)\\nSpace complexity = O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0 || n==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return (presses==1)?3:4;\\n        if(presses==1) return 4;\\n        return (presses==2)?7:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307308,
                "title": "sollution-in-c",
                "content": "```\\nint flipLights(int n, int presses){\\n    int val = n >=3 ? 3 : n;\\n    if (presses == 0){\\n        return 1;\\n    } else if (presses == 1){\\n        return val == 1 ? 2 : val == 2 ? 3 : 4;\\n    } else if (presses == 2){\\n        return val == 1 ? 2 : val == 2 ? 4 : 7;\\n    } \\n    return val == 1? 2 : val == 2 ? 4 : 8;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint flipLights(int n, int presses){\\n    int val = n >=3 ? 3 : n;\\n    if (presses == 0){\\n        return 1;\\n    } else if (presses == 1){\\n        return val == 1 ? 2 : val == 2 ? 3 : 4;\\n    } else if (presses == 2){\\n        return val == 1 ? 2 : val == 2 ? 4 : 7;\\n    } \\n    return val == 1? 2 : val == 2 ? 4 : 8;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291782,
                "title": "javascript-set-thinking-faster-than-100",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function(n, m) {\\n    if (m === 0)    return 1\\n\\n    \\n    const sets = {\\n        NONE: \\'\\',\\n        A: \\'A\\',\\n        B: \\'B\\',\\n        C: \\'C\\',\\n        D: \\'D\\',\\n    }\\n    if (n === 1) {\\n        sets.B = sets.A\\n    }\\n    if (n <= 2) {\\n        sets.D = sets.B\\n    }\\n    \\n    \\n    function getSet(...list) {\\n        let set = new Set()\\n        for (const ch of list) {\\n            if (set.has(ch))    set.delete(ch)\\n            else set.add(ch)\\n        }\\n        \\n        const chs = [...set]\\n        chs.sort()\\n        \\n        return chs.join(\\'\\')\\n    }\\n    \\n    \\n    const results = []\\n    results[0] = new Set([sets.NONE])\\n    results[1] = new Set([sets.A, sets.B, sets.C, sets.D])\\n    results[2] = new Set([...results[0], getSet(sets.A, sets.B), getSet(sets.A, sets.C), getSet(sets.A, sets.D), getSet(sets.B, sets.C), getSet(sets.B, sets.D), getSet(sets.C, sets.D)])\\n    results[3] = new Set([...results[1], getSet(sets.A, sets.B, sets.C), getSet(sets.A, sets.B, sets.D), getSet(sets.A, sets.C, sets.D), getSet(sets.B, sets.C, sets.D)])\\n    results[4] = new Set([...results[2], getSet(sets.A, sets.B, sets.C, sets.D)])\\n    \\n    \\n    let result\\n    if (m <= 4) result = results[m]\\n    else {\\n        if (m & 1)  result = results[3]\\n        else result = results[4]\\n    }\\n    \\n\\n    result = result.size\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function(n, m) {\\n    if (m === 0)    return 1\\n\\n    \\n    const sets = {\\n        NONE: \\'\\',\\n        A: \\'A\\',\\n        B: \\'B\\',\\n        C: \\'C\\',\\n        D: \\'D\\',\\n    }\\n    if (n === 1) {\\n        sets.B = sets.A\\n    }\\n    if (n <= 2) {\\n        sets.D = sets.B\\n    }\\n    \\n    \\n    function getSet(...list) {\\n        let set = new Set()\\n        for (const ch of list) {\\n            if (set.has(ch))    set.delete(ch)\\n            else set.add(ch)\\n        }\\n        \\n        const chs = [...set]\\n        chs.sort()\\n        \\n        return chs.join(\\'\\')\\n    }\\n    \\n    \\n    const results = []\\n    results[0] = new Set([sets.NONE])\\n    results[1] = new Set([sets.A, sets.B, sets.C, sets.D])\\n    results[2] = new Set([...results[0], getSet(sets.A, sets.B), getSet(sets.A, sets.C), getSet(sets.A, sets.D), getSet(sets.B, sets.C), getSet(sets.B, sets.D), getSet(sets.C, sets.D)])\\n    results[3] = new Set([...results[1], getSet(sets.A, sets.B, sets.C), getSet(sets.A, sets.B, sets.D), getSet(sets.A, sets.C, sets.D), getSet(sets.B, sets.C, sets.D)])\\n    results[4] = new Set([...results[2], getSet(sets.A, sets.B, sets.C, sets.D)])\\n    \\n    \\n    let result\\n    if (m <= 4) result = results[m]\\n    else {\\n        if (m & 1)  result = results[3]\\n        else result = results[4]\\n    }\\n    \\n\\n    result = result.size\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1257539,
                "title": "c-using-a-bit-of-thinking",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        int val = min(3,n);\\n        if(m == 0)\\n        {\\n           return 1; \\n        }\\n        else if(m==1)\\n        {\\n            return val == 1?2:val == 2?3:4;\\n        }\\n        else if(m == 2)\\n            return val == 1?2:val == 2?4:7;\\n        return val == 1?2:val == 2?4:8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        int val = min(3,n);\\n        if(m == 0)\\n        {\\n           return 1; \\n        }\\n        else if(m==1)\\n        {\\n            return val == 1?2:val == 2?3:4;\\n        }\\n        else if(m == 2)\\n            return val == 1?2:val == 2?4:7;\\n        return val == 1?2:val == 2?4:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253549,
                "title": "not-much-thinking-required-just-do-it-in-python",
                "content": "Observation 1. Order of button pressing is irrelevant.\\nObservation 2. Pressing a button two times is exactly equivalent of pressing it zero times. So, we must only consider pressing each button either 0 or 1 times. As we have 4 buttons, we need to consider 16 combinations. We\\'ll use bitmasks for that.\\nObservation 3. We only need to simulate no more than 6 first bulbs, beacause it\\'s a repeating pattern after that.\\nObservation 4. Starting from presses==3, the only thing we need to know is whether presses is even or odd number.\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(n, 6)\\n        Possibilities = {\\n            0: {0},\\n            1: {1},\\n            2: {0,2},\\n            3: {1,3},\\n            4: {0,2,4}\\n        }\\n        if presses>4:\\n            presses = 4-presses%2\\n        on_counts = Possibilities[presses]\\n        outcomes = set()\\n        for x in range(16):\\n            cnt = bool(x&1)+bool(x&2)+bool(x&4)+bool(x&8)\\n            if cnt not in on_counts:\\n                continue\\n            state = [0]*n\\n            if x&1:\\n                # press button 1\\n                state = [v^1 for v in state]\\n            if x&2:\\n                # press button 2\\n                state = [v^(i&1) for i,v in enumerate(state)]\\n            if x&4:\\n                # press button 3\\n                state = [v^(i&1)^1 for i,v in enumerate(state)]\\n            if x&8:\\n                # press button 4\\n                if n>0: state[0] ^= 1\\n                if n>3: state[3] ^= 1\\n            \\n            outcomes.add(tuple(state))\\n        return len(outcomes)\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(n, 6)\\n        Possibilities = {\\n            0: {0},\\n            1: {1},\\n            2: {0,2},\\n            3: {1,3},\\n            4: {0,2,4}\\n        }\\n        if presses>4:\\n            presses = 4-presses%2\\n        on_counts = Possibilities[presses]\\n        outcomes = set()\\n        for x in range(16):\\n            cnt = bool(x&1)+bool(x&2)+bool(x&4)+bool(x&8)\\n            if cnt not in on_counts:\\n                continue\\n            state = [0]*n\\n            if x&1:\\n                # press button 1\\n                state = [v^1 for v in state]\\n            if x&2:\\n                # press button 2\\n                state = [v^(i&1) for i,v in enumerate(state)]\\n            if x&4:\\n                # press button 3\\n                state = [v^(i&1)^1 for i,v in enumerate(state)]\\n            if x&8:\\n                # press button 4\\n                if n>0: state[0] ^= 1\\n                if n>3: state[3] ^= 1\\n            \\n            outcomes.add(tuple(state))\\n        return len(outcomes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104036,
                "title": "c-solution-0ms",
                "content": "Run-time is `O(1)`, space is `O(1)`. \\n\\nThis is just a counting problem where you first realize that there is limited possibilities then you just check what is possible for different combinations of `n` and `m`. \\n\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        else if(m == 1) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 3;\\n                default: return 4;\\n            }\\n        } else if(m == 2) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 4;\\n                default: return 7;\\n            }\\n        }\\n        \\n        if(n == 1) return 2;\\n        else if(n == 2) return 4;      \\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        else if(m == 1) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 3;\\n                default: return 4;\\n            }\\n        } else if(m == 2) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 4;\\n                default: return 7;\\n            }\\n        }\\n        \\n        if(n == 1) return 2;\\n        else if(n == 2) return 4;      \\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057233,
                "title": "c-o-1",
                "content": "```\\nclass Solution {\\n    /*\\n        4=>4\\n        44=>44\\n        444=>4\\n        4444=>44\\n        ....\\n        (combinations of 4 => only 44 and 4)\\n        \\n        2=>2\\n        22=>3\\n        222=>2\\n        ....\\n        \\n        3=>3\\n        33=>2\\n        333=>3\\n        ...\\n\\t\\t(combinations of 2 and 3 => only 2 and 3)\\n        (for any odd m and even m  2 or 3 can be used)\\n   \\n        13=>2\\n        12=>3\\n        (1,3) will be combined to (2)\\n        (2,3) will be combined to (3)\\n\\t\\t(so don\\'t consider 13 or 23 case)\\n        11=>cancel\\n     -------------------------------------------------------   \\n        summary\\n        if m is odd \\n                consider 1,2,3,4\\n            if (m,n>=3)\\n                consider 42,43,442,443,441 (duplicated 1 so only add extra 4 count)\\n        if m is even\\n                consider 2,3,11\\n            if (m,n>=2)\\n                condsider 44 42 43 41\\n            if (m,n>=3)\\n                consider 442 443 (duplicated 1 so only add extra 1 count)\\n      -------------------------------------------------------   \\n    */\\npublic:\\n    int flipLights(int n, int m) {\\n        int c = 0;\\n        if (m==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2) return m == 1?3:4;\\n        if (m%2 == 0)\\n        {\\n            c += 3;\\n            if (m>=2)\\n                c+=4;\\n            if (m>=3)\\n                c+=1;\\n        }\\n        else\\n        {\\n            c += 4;\\n            if (m>=3)\\n                c+=4;\\n        }\\n        return c;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n        4=>4\\n        44=>44\\n        444=>4\\n        4444=>44\\n        ....\\n        (combinations of 4 => only 44 and 4)\\n        \\n        2=>2\\n        22=>3\\n        222=>2\\n        ....\\n        \\n        3=>3\\n        33=>2\\n        333=>3\\n        ...\\n\\t\\t(combinations of 2 and 3 => only 2 and 3)\\n        (for any odd m and even m  2 or 3 can be used)\\n   \\n        13=>2\\n        12=>3\\n        (1,3) will be combined to (2)\\n        (2,3) will be combined to (3)\\n\\t\\t(so don\\'t consider 13 or 23 case)\\n        11=>cancel\\n     -------------------------------------------------------   \\n        summary\\n        if m is odd \\n                consider 1,2,3,4\\n            if (m,n>=3)\\n                consider 42,43,442,443,441 (duplicated 1 so only add extra 4 count)\\n        if m is even\\n                consider 2,3,11\\n            if (m,n>=2)\\n                condsider 44 42 43 41\\n            if (m,n>=3)\\n                consider 442 443 (duplicated 1 so only add extra 1 count)\\n      -------------------------------------------------------   \\n    */\\npublic:\\n    int flipLights(int n, int m) {\\n        int c = 0;\\n        if (m==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2) return m == 1?3:4;\\n        if (m%2 == 0)\\n        {\\n            c += 3;\\n            if (m>=2)\\n                c+=4;\\n            if (m>=3)\\n                c+=1;\\n        }\\n        else\\n        {\\n            c += 4;\\n            if (m>=3)\\n                c+=4;\\n        }\\n        return c;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905612,
                "title": "rust-0-ms-but-i-feel-it-is-too-verbose",
                "content": "```\\nimpl Solution {\\n    pub fn flip_lights(n: i32, m: i32) -> i32 {\\n        let mut real_n = std::cmp::min(3,n);\\n    if m == 0 {\\n        return 1;\\n    } else if m == 1 {\\n        real_n= if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            3\\n        } else {\\n            4\\n        };\\n        return real_n;\\n    } else if m == 2 {\\n        real_n = if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            4\\n        } else {\\n            7\\n        };\\n        return real_n;\\n    }\\n    real_n = if real_n == 1 {\\n        2\\n    } else if real_n == 2 {\\n        4\\n    } else {\\n        8\\n    };\\n    real_n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn flip_lights(n: i32, m: i32) -> i32 {\\n        let mut real_n = std::cmp::min(3,n);\\n    if m == 0 {\\n        return 1;\\n    } else if m == 1 {\\n        real_n= if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            3\\n        } else {\\n            4\\n        };\\n        return real_n;\\n    } else if m == 2 {\\n        real_n = if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            4\\n        } else {\\n            7\\n        };\\n        return real_n;\\n    }\\n    real_n = if real_n == 1 {\\n        2\\n    } else if real_n == 2 {\\n        4\\n    } else {\\n        8\\n    };\\n    real_n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883263,
                "title": "single-line-c-solution",
                "content": "\\n\\nint flipLights(int n, int m){\\n    return m==0?1:(n>2?(m==1?4:(m==2)?7:8):(n==1)?2:(m==1?3:4));   \\n}",
                "solutionTags": [],
                "code": "\\n\\nint flipLights(int n, int m){\\n    return m==0?1:(n>2?(m==1?4:(m==2)?7:8):(n==1)?2:(m==1?3:4));   \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 760639,
                "title": "python-slow-solution-but-accepted",
                "content": "```\\ndef f(x,m,d,h,n):\\n    s=int(x,2)\\n    if m==0:\\n        h.add(s)\\n        return\\n    if (s,m) in d:return\\n    a,b,c,e=\\'\\',\\'\\',\\'\\',\\'\\'\\n    g={\\'0\\':\\'1\\',\\'1\\':\\'0\\'}\\n    for i in range(min(4,n)):\\n        if i%2==0:a+=g[x[i]]\\n        else:a+=x[i]\\n        if i%2==1:b+=g[x[i]]\\n        else:b+=x[i]\\n        c+=g[x[i]]\\n        if i in (0,3):e+=g[x[i]]\\n        else:e+=x[i]\\n    f(a,m-1,d,h,n),f(b,m-1,d,h,n),f(c,m-1,d,h,n),f(e,m-1,d,h,n)\\n    d.add((s,m))\\n    return \\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        d=set()\\n        h=set()\\n        x=\"1\"*min(4,n)\\n        f(x,m,d,h,n)\\n        return len(h)\\n```",
                "solutionTags": [],
                "code": "```\\ndef f(x,m,d,h,n):\\n    s=int(x,2)\\n    if m==0:\\n        h.add(s)\\n        return\\n    if (s,m) in d:return\\n    a,b,c,e=\\'\\',\\'\\',\\'\\',\\'\\'\\n    g={\\'0\\':\\'1\\',\\'1\\':\\'0\\'}\\n    for i in range(min(4,n)):\\n        if i%2==0:a+=g[x[i]]\\n        else:a+=x[i]\\n        if i%2==1:b+=g[x[i]]\\n        else:b+=x[i]\\n        c+=g[x[i]]\\n        if i in (0,3):e+=g[x[i]]\\n        else:e+=x[i]\\n    f(a,m-1,d,h,n),f(b,m-1,d,h,n),f(c,m-1,d,h,n),f(e,m-1,d,h,n)\\n    d.add((s,m))\\n    return \\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        d=set()\\n        h=set()\\n        x=\"1\"*min(4,n)\\n        f(x,m,d,h,n)\\n        return len(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678466,
                "title": "c-simple-100-faster-solution-with-explation",
                "content": "```\\n/*x:the times use button1, y:the times use button2 z: the times use button3 w: the times use button4\\nthe order do not infulence the ans ;and the first 4 light will decide the ans; \\n\\nfor the light1 is always the same as light7 , light2 is always the same as light8... under different operations,\\nso we concentrate on the first 6 light ,but light2 is always the same as light6, light3 is always the same as 5,\\nso we only concentrate on the first 4 light;\\n\\nwe can list the equations:\\nx+y+z+w=m  \\nx+z+w=k1(mod2) (k1%2 decide the ans on light1)\\nx+y = k2(mod2) (k2%2 the ans on light2)\\nx+z=k3(mod2)  (k3%2 decide the ans on light3) \\nx+y+w=k4(mod2) (k4%2 decide the ans on light4) \\nso we can fix x,y,z(mod2), to get w(mod2) , and statistics the different ans of tuple [k1,k2,k3] !\\n*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        n=(n>4)?4:n;\\n        std::set<int> set;\\n        for(int i = 0;i<8;++i)\\n        {\\n            int x=i&1;\\n            int y=(i>>1)&1;\\n            int z = (i>>2)&1;\\n            int w=m-x-y-z;\\n            if(w>=0)\\n            {\\n                w=w%2;\\n                int b[4]={(x+z+w)%2,(x+y)%2,(x+z)%2,(x+y+w)%2};\\n                int k=0;\\n                for(int t=0;t<n;++t)\\n                {\\n                    k+=(b[t]<<t);\\n                }\\n                set.insert(k);\\n            }\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*x:the times use button1, y:the times use button2 z: the times use button3 w: the times use button4\\nthe order do not infulence the ans ;and the first 4 light will decide the ans; \\n\\nfor the light1 is always the same as light7 , light2 is always the same as light8... under different operations,\\nso we concentrate on the first 6 light ,but light2 is always the same as light6, light3 is always the same as 5,\\nso we only concentrate on the first 4 light;\\n\\nwe can list the equations:\\nx+y+z+w=m  \\nx+z+w=k1(mod2) (k1%2 decide the ans on light1)\\nx+y = k2(mod2) (k2%2 the ans on light2)\\nx+z=k3(mod2)  (k3%2 decide the ans on light3) \\nx+y+w=k4(mod2) (k4%2 decide the ans on light4) \\nso we can fix x,y,z(mod2), to get w(mod2) , and statistics the different ans of tuple [k1,k2,k3] !\\n*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        n=(n>4)?4:n;\\n        std::set<int> set;\\n        for(int i = 0;i<8;++i)\\n        {\\n            int x=i&1;\\n            int y=(i>>1)&1;\\n            int z = (i>>2)&1;\\n            int w=m-x-y-z;\\n            if(w>=0)\\n            {\\n                w=w%2;\\n                int b[4]={(x+z+w)%2,(x+y)%2,(x+z)%2,(x+y+w)%2};\\n                int k=0;\\n                for(int t=0;t<n;++t)\\n                {\\n                    k+=(b[t]<<t);\\n                }\\n                set.insert(k);\\n            }\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674865,
                "title": "c-simple-100-faster-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 2;\\n        }\\n        if(n==2){\\n            if(m==1){\\n                return 3;\\n            }\\n            return 4;\\n        }\\n        if(m==1){\\n            return 4;\\n        }\\n        if(m==2){\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 2;\\n        }\\n        if(n==2){\\n            if(m==1){\\n                return 3;\\n            }\\n            return 4;\\n        }\\n        if(m==1){\\n            return 4;\\n        }\\n        if(m==2){\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590061,
                "title": "java-math",
                "content": "```\\n    public int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2) {\\n            if(m == 1) return 3;\\n            else return 4;\\n        }\\n        if(n >= 3) {\\n            if(m == 1) return 4;\\n            if(m == 2) return 6 + 1;\\n            if(m % 1 == 1) return 4 + 4;\\n        }\\n        return 8;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2) {\\n            if(m == 1) return 3;\\n            else return 4;\\n        }\\n        if(n >= 3) {\\n            if(m == 1) return 4;\\n            if(m == 2) return 6 + 1;\\n            if(m % 1 == 1) return 4 + 4;\\n        }\\n        return 8;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573296,
                "title": "c-bit-manipulation-kind-silly-but-more-general-i-think",
                "content": "I didn\\'t think much about the swithes and their relations, therefore I came up with this.\\nBut I think for switches like: \\n```\\n\\tswitch1: flip lights k+1 (k in {0,1,2,3...}\\n\\tswitch2: flip lights 2k+1\\n\\tswitch3: flip lights 3k+1\\n\\t......\\n\\tswitchx: flip lights xk+1\\n```\\nmy idea should still work:\\n```c++\\nclass Solution {\\n private:\\n  // lights are numbered from right to left: 3..1\\n  // 1 means the swither can flip that light\\n  vector<int> switchers = {0b111, 0b010, 0b101, 0b001};\\n  int cnt_bits(int x) {\\n    int res = 0;\\n    while (x) {\\n      res += x & 1;\\n      x >>= 1;\\n    }\\n    return res;\\n  }\\n\\n public:\\n  // n and m both fit in range [0, 1000].\\n  int flipLights(int n, int m) {\\n    if (m == 0 || n == 0) return 1;\\n    // allocate m to four switchers/plates (only need to know the number is even\\n    // or odd) [0, 2**4) 0 0 0 0 ~ 1 1 1 1 printArr(switchers);\\n\\n    // for n, only need to consider n <= 3 \\n    int lights = 0b111;\\n    // if n less than 3, just consider n lights\\n    if (n < 3) lights = (1 << n) - 1;\\n    // if can reach status i (lights = i), statuses[i] = true\\n    vector<bool> statuses(lights + 1);\\n    for (int i = 0; i < 16; ++i) {\\n      int bit_cnt = cnt_bits(i);\\n      if (bit_cnt > m || (m - bit_cnt) & 1) continue;\\n      int switcher = 0;\\n      // total four switchers, combine the switches (which will be used odd\\n      // times)\\n      for (int j = 0; j < 4; ++j) {\\n        if ((1 << j) & i) switcher ^= switchers[j];\\n      }\\n      // flip lights use the combined swither, set the lights\\' status to true\\n      statuses[(lights ^ switcher) & lights] = true;\\n    }\\n\\n    int res = 0;\\n    for (bool status : statuses) {\\n      res += status;\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tswitch1: flip lights k+1 (k in {0,1,2,3...}\\n\\tswitch2: flip lights 2k+1\\n\\tswitch3: flip lights 3k+1\\n\\t......\\n\\tswitchx: flip lights xk+1\\n```\n```c++\\nclass Solution {\\n private:\\n  // lights are numbered from right to left: 3..1\\n  // 1 means the swither can flip that light\\n  vector<int> switchers = {0b111, 0b010, 0b101, 0b001};\\n  int cnt_bits(int x) {\\n    int res = 0;\\n    while (x) {\\n      res += x & 1;\\n      x >>= 1;\\n    }\\n    return res;\\n  }\\n\\n public:\\n  // n and m both fit in range [0, 1000].\\n  int flipLights(int n, int m) {\\n    if (m == 0 || n == 0) return 1;\\n    // allocate m to four switchers/plates (only need to know the number is even\\n    // or odd) [0, 2**4) 0 0 0 0 ~ 1 1 1 1 printArr(switchers);\\n\\n    // for n, only need to consider n <= 3 \\n    int lights = 0b111;\\n    // if n less than 3, just consider n lights\\n    if (n < 3) lights = (1 << n) - 1;\\n    // if can reach status i (lights = i), statuses[i] = true\\n    vector<bool> statuses(lights + 1);\\n    for (int i = 0; i < 16; ++i) {\\n      int bit_cnt = cnt_bits(i);\\n      if (bit_cnt > m || (m - bit_cnt) & 1) continue;\\n      int switcher = 0;\\n      // total four switchers, combine the switches (which will be used odd\\n      // times)\\n      for (int j = 0; j < 4; ++j) {\\n        if ((1 << j) & i) switcher ^= switchers[j];\\n      }\\n      // flip lights use the combined swither, set the lights\\' status to true\\n      statuses[(lights ^ switcher) & lights] = true;\\n    }\\n\\n    int res = 0;\\n    for (bool status : statuses) {\\n      res += status;\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538057,
                "title": "my-solution-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\nint flipLights(int n, int m) {\\n    int count = 0;\\n    set<string> s;\\n    string str;\\n    str.clear();\\n    for (int a = 0; a <= 1; ++a) {\\n        for (int b = 0; b <= 1; ++b) {\\n            for (int c = 0; c <= 1; ++c) {\\n                for (int d = 0; d <= 1; ++d) {\\n                    count = a + b + c + d;\\n                    if ((count % 2) != (m % 2) || count > m) continue;\\n                    if (n >= 1) {\\n                        str.append(to_string((a+c+d)%2)).append(\"_\");\\n                        if (n >= 2) {\\n                            str.append(to_string((a+b)%2)).append(\"_\");\\n                            if (n >= 3) {\\n                                str.append(to_string((a+c)%2)).append(\"_\");\\n                                if (n >= 4) {\\n                                    str.append(to_string((a+b+d)%2)).append(\"_\");\\n                                }\\n                            }\\n                        }\\n                    }\\n                    if (!str.empty()) {\\n                        s.insert(str);\\n                        str.clear();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return s.size();\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint flipLights(int n, int m) {\\n    int count = 0;\\n    set<string> s;\\n    string str;\\n    str.clear();\\n    for (int a = 0; a <= 1; ++a) {\\n        for (int b = 0; b <= 1; ++b) {\\n            for (int c = 0; c <= 1; ++c) {\\n                for (int d = 0; d <= 1; ++d) {\\n                    count = a + b + c + d;\\n                    if ((count % 2) != (m % 2) || count > m) continue;\\n                    if (n >= 1) {\\n                        str.append(to_string((a+c+d)%2)).append(\"_\");\\n                        if (n >= 2) {\\n                            str.append(to_string((a+b)%2)).append(\"_\");\\n                            if (n >= 3) {\\n                                str.append(to_string((a+c)%2)).append(\"_\");\\n                                if (n >= 4) {\\n                                    str.append(to_string((a+b+d)%2)).append(\"_\");\\n                                }\\n                            }\\n                        }\\n                    }\\n                    if (!str.empty()) {\\n                        s.insert(str);\\n                        str.clear();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return s.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524764,
                "title": "javascript-bitwize",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function (n, m) {\\n  // fist a*6 bulps always the same, we only need remember 1*6\\n  let total = n > 6 ? n % 6 + 6 : n, states = new Set()\\n  let inital = parseInt(\\'\\'.padEnd(total, \\'1\\'), 2),\\n    even = parseInt(\\'\\'.padEnd(total, \\'10\\'), 2),\\n    odd = parseInt(\\'\\'.padEnd(total, \\'01\\'), 2),\\n    k3p1 = parseInt(\\'\\'.padEnd(total, \\'100\\'), 2),\\n    all = inital, traveled = {}\\n\\n  r(inital, m)\\n  return states.size\\n\\n  function r(cur, left) {\\n    let key = cur + \\'_\\' + left\\n    if (traveled[key]) return\\n    traveled[key] = true\\n    if (left === 0) {\\n      states.add(cur)\\n      return\\n    }\\n    r(cur ^ all, left - 1)\\n    r(cur ^ even, left - 1)\\n    r(cur ^ odd, left - 1)\\n    r(cur ^ k3p1, left - 1)\\n  }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function (n, m) {\\n  // fist a*6 bulps always the same, we only need remember 1*6\\n  let total = n > 6 ? n % 6 + 6 : n, states = new Set()\\n  let inital = parseInt(\\'\\'.padEnd(total, \\'1\\'), 2),\\n    even = parseInt(\\'\\'.padEnd(total, \\'10\\'), 2),\\n    odd = parseInt(\\'\\'.padEnd(total, \\'01\\'), 2),\\n    k3p1 = parseInt(\\'\\'.padEnd(total, \\'100\\'), 2),\\n    all = inital, traveled = {}\\n\\n  r(inital, m)\\n  return states.size\\n\\n  function r(cur, left) {\\n    let key = cur + \\'_\\' + left\\n    if (traveled[key]) return\\n    traveled[key] = true\\n    if (left === 0) {\\n      states.add(cur)\\n      return\\n    }\\n    r(cur ^ all, left - 1)\\n    r(cur ^ even, left - 1)\\n    r(cur ^ odd, left - 1)\\n    r(cur ^ k3p1, left - 1)\\n  }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 403028,
                "title": "c-easy-to-understand-simple-solution",
                "content": "Assuming we have infinite bulbs and we operate infinite times.\\n* Without any operations, we can get 1 state:\\n\\t*  {all bulbs open}*(state 0)*\\n* In the first operation, we can get 4 different states by 4 different buttons:\\n\\t* {all bulbs close}*(state 1)*, *by button 1*\\n\\t*  {even bulbs close}*(state 2)*, *by button 2*\\n\\t*  {odd bulbs close}*(state 3)*, *by button 3*\\n\\t*  {3k+1 bulbs close}*(state 4)*, *by button 4*\\n* In the second operation, we can get another 3 states which do not appear in above:\\n\\t* {(odd\\u2229{3k+1})\\u222A(even - even\\u2229{3k+1})bulbs close}*(state 5)*, *by button 4 from state 2*\\n\\t* {(even\\u2229{3k+1})\\u222A(odd - odd\\u2229{3k+1})bulbs close}*(state 6)*, *by button 3 from state 3*\\n\\t* {3k+1 bulbs open}*(state 7)*, *by button 4 from state 1 OR  by button 1 from state 4*\\n\\tIn the second operation, we can get another 4 states which appear in above:\\n\\t* We can get back to the state 0 in the second operation by button {1,2,3,4} from state{1,2,3,4}\\n\\t* We can also get back to the state 1 in the second operation by button {2,3} from state{3,2}\\n\\t* We can also get back to the state 2 in the second operation by button 3 from state 1\\n\\t* We can also get back to the state 3 in the second operation by button 2 from state 1\\n* In the 3+ operation, we can get at most 8 states which appear in above:\\n\\tThere are no more states besides above which means at most we can get 8 states.\\n\\tMeanwhile, we can get state 4 by button {1,2,3,4} from state {7,5,6,0} so we can get at most all states when we operate more than twice .\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0){ // if there are no bulbs\\n            return 1; //  only 1 state\\n        }else if(m == 1){ // if there is at least one bulb & we operate only once\\n            return min(n+1,4); // we can get no more than 4 status (n+1 from the description which shows operate 1, 2, 3 bulbs once means 2, 3, 4 states)\\n        }else{ //if there is at least one bulb and we operate more than once\\n            int sum = 1;\\n            for(int i = 0; i < n && i < 3; i++){// we can get no more than pow(2,n) states (i < 3 means we do not need to calculate when i >= 3 because sum is more than 8 in that time)\\n                sum *=2;\\n            }\\n            int minn = 7; // if we operate only twice , we can NOT get one of 8 states. That state we cannot get  back in the second time , 7 = 8 - 1\\n            if(m > 2){\\n\\t\\t\\t\\t\\tminn = 8; // we can get no more than 8 states\\n            }\\n            return min(sum,minn);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0){ // if there are no bulbs\\n            return 1; //  only 1 state\\n        }else if(m == 1){ // if there is at least one bulb & we operate only once\\n            return min(n+1,4); // we can get no more than 4 status (n+1 from the description which shows operate 1, 2, 3 bulbs once means 2, 3, 4 states)\\n        }else{ //if there is at least one bulb and we operate more than once\\n            int sum = 1;\\n            for(int i = 0; i < n && i < 3; i++){// we can get no more than pow(2,n) states (i < 3 means we do not need to calculate when i >= 3 because sum is more than 8 in that time)\\n                sum *=2;\\n            }\\n            int minn = 7; // if we operate only twice , we can NOT get one of 8 states. That state we cannot get  back in the second time , 7 = 8 - 1\\n            if(m > 2){\\n\\t\\t\\t\\t\\tminn = 8; // we can get no more than 8 states\\n            }\\n            return min(sum,minn);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400425,
                "title": "bfs",
                "content": "bfs\\n1. careful about the lights being 1 indexed (turnoff every 3 and every 2 and every 1 could be a way to describe it)\\n2. repeats it self at minimal common multiple (tough point to visualize I find personally)\\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if n > 6: n = 6 + n % 6\\n        q = set([tuple([0] * n)])\\n        for _ in range(m):  q = set([n for e in q for n in self.neighbours(e)])\\n        #O(mn) = O(11m) = O(m)\\n        #the constant being < 11\\n        return len(q)\\n    def neighbours(self,el):\\n        return set([tuple([1 - e for e in el]), tuple([1 - e if i % 2 == 0 else e for i,e in enumerate(el)]),  tuple([e if i % 2 == 0 else 1 - e for i,e in enumerate(el)]), tuple([1 - e if i % 3 == 0 else e for i,e in enumerate(el)])])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if n > 6: n = 6 + n % 6\\n        q = set([tuple([0] * n)])\\n        for _ in range(m):  q = set([n for e in q for n in self.neighbours(e)])\\n        #O(mn) = O(11m) = O(m)\\n        #the constant being < 11\\n        return len(q)\\n    def neighbours(self,el):\\n        return set([tuple([1 - e for e in el]), tuple([1 - e if i % 2 == 0 else e for i,e in enumerate(el)]),  tuple([e if i % 2 == 0 else 1 - e for i,e in enumerate(el)]), tuple([1 - e if i % 3 == 0 else e for i,e in enumerate(el)])])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390418,
                "title": "cpp-o-1-case-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m==0) return 1;\\n        if (n==1)\\n            if (m>0)return 2;\\n\\n        if(n==2)\\n            if(m==1)return 3;\\n            else return 4;\\n        \\n        if (m==1)return 4;\\n        if(m==2)return 7;\\n            return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m==0) return 1;\\n        if (n==1)\\n            if (m>0)return 2;\\n\\n        if(n==2)\\n            if(m==1)return 3;\\n            else return 4;\\n        \\n        if (m==1)return 4;\\n        if(m==2)return 7;\\n            return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357812,
                "title": "same-input-passes-in-test-case-but-not-on-submission-n-3-m-1",
                "content": "```vector<string> result;\\n\\nvoid checkPresence(string s){\\n    vector<string> ::iterator it;\\n    it = find(result.begin(), result.end(), s);\\n    if(it == result.end()){\\n        // std::cout<<\"Entering String : \"<<s<<endl;\\n        result.push_back(s);\\n    }\\n}\\n\\n\\nvoid makePossible(int cases, string s){\\n    switch(cases){\\n        case 1:\\n            for(int i =0; i < s.length(); i++){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 2 :\\n            for(int i = 1; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 3 :\\n            for(int i = 0; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 4 :\\n            for(int i= 0; i <s.length(); i+=3){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n    }\\n    checkPresence(s);\\n}\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n == 1){\\n            return 2;\\n        }\\n        string s = \"\";\\n        while(n > 0){\\n            char ch = 1 + \\'0\\';\\n            s += ch;\\n            n--;\\n        }\\n        result.push_back(s);\\n        while(m){\\n            // std::cout<<\"Here\\\\n\";\\n            for(auto a : result){\\n                makePossible(1, a);\\n                makePossible(2, a);\\n                makePossible(3, a);\\n                makePossible(4, a);\\n            }\\n            m--;\\n        }\\n        return result.size() - 1  ;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```vector<string> result;\\n\\nvoid checkPresence(string s){\\n    vector<string> ::iterator it;\\n    it = find(result.begin(), result.end(), s);\\n    if(it == result.end()){\\n        // std::cout<<\"Entering String : \"<<s<<endl;\\n        result.push_back(s);\\n    }\\n}\\n\\n\\nvoid makePossible(int cases, string s){\\n    switch(cases){\\n        case 1:\\n            for(int i =0; i < s.length(); i++){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 2 :\\n            for(int i = 1; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 3 :\\n            for(int i = 0; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 4 :\\n            for(int i= 0; i <s.length(); i+=3){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n    }\\n    checkPresence(s);\\n}\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n == 1){\\n            return 2;\\n        }\\n        string s = \"\";\\n        while(n > 0){\\n            char ch = 1 + \\'0\\';\\n            s += ch;\\n            n--;\\n        }\\n        result.push_back(s);\\n        while(m){\\n            // std::cout<<\"Here\\\\n\";\\n            for(auto a : result){\\n                makePossible(1, a);\\n                makePossible(2, a);\\n                makePossible(3, a);\\n                makePossible(4, a);\\n            }\\n            m--;\\n        }\\n        return result.size() - 1  ;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 253846,
                "title": "do-you-like-for-in-javascript-here-it-is",
                "content": "```javascript\\nvar flipAll = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if(newLights[i] === 1) newLights[i] = 0;\\n        else newLights[i] = 1;\\n    }\\n    return newLights;\\n};\\n\\nvar flipEven = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 === 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipOdd = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 !== 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipNumber = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 3 === 1) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar deleteDuplicatedCase = function(cases) {\\n    var newCases = cases.slice();\\n    for(let i = 0; i < newCases.length; i++) {\\n        for(let j = i + 1; j < newCases.length; j++) {\\n            let isSame = true;\\n            for(let index = 0; index < newCases[i].length; index++) {\\n                if(newCases[i][index] !== newCases[j][index]) {\\n                    isSame = false;\\n                }\\n            }\\n            if(isSame) {\\n                newCases.splice(j, 1);\\n                j--;\\n            }\\n        }\\n    }\\n    return newCases;\\n};\\n\\nvar flipLights = function(n, m) {\\n    var lights = []\\n    var cases = []\\n    if(m === 0) {\\n        return 1;\\n    }\\n    for(let i = 0; i < n; i++) {\\n        lights.push(1);\\n    }\\n    for(let i = 0; i < m; i++) {\\n        const casesLength = cases.length\\n        if(i === 0) {\\n            cases.push(flipAll(lights));\\n            cases.push(flipEven(lights));\\n            cases.push(flipOdd(lights));\\n            cases.push(flipNumber(lights));\\n        } else {\\n            for(let j = 0; j < casesLength; j++) {\\n                cases.push(flipAll(cases[j]));\\n                cases.push(flipEven(cases[j]));\\n                cases.push(flipOdd(cases[j]));\\n                cases.push(flipNumber(cases[j]));\\n            }\\n        }\\n        cases.splice(0, casesLength)\\n        cases = deleteDuplicatedCase(cases).slice();\\n    }\\n    return cases.length;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```javascript\\nvar flipAll = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if(newLights[i] === 1) newLights[i] = 0;\\n        else newLights[i] = 1;\\n    }\\n    return newLights;\\n};\\n\\nvar flipEven = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 === 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipOdd = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 !== 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipNumber = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 3 === 1) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar deleteDuplicatedCase = function(cases) {\\n    var newCases = cases.slice();\\n    for(let i = 0; i < newCases.length; i++) {\\n        for(let j = i + 1; j < newCases.length; j++) {\\n            let isSame = true;\\n            for(let index = 0; index < newCases[i].length; index++) {\\n                if(newCases[i][index] !== newCases[j][index]) {\\n                    isSame = false;\\n                }\\n            }\\n            if(isSame) {\\n                newCases.splice(j, 1);\\n                j--;\\n            }\\n        }\\n    }\\n    return newCases;\\n};\\n\\nvar flipLights = function(n, m) {\\n    var lights = []\\n    var cases = []\\n    if(m === 0) {\\n        return 1;\\n    }\\n    for(let i = 0; i < n; i++) {\\n        lights.push(1);\\n    }\\n    for(let i = 0; i < m; i++) {\\n        const casesLength = cases.length\\n        if(i === 0) {\\n            cases.push(flipAll(lights));\\n            cases.push(flipEven(lights));\\n            cases.push(flipOdd(lights));\\n            cases.push(flipNumber(lights));\\n        } else {\\n            for(let j = 0; j < casesLength; j++) {\\n                cases.push(flipAll(cases[j]));\\n                cases.push(flipEven(cases[j]));\\n                cases.push(flipOdd(cases[j]));\\n                cases.push(flipNumber(cases[j]));\\n            }\\n        }\\n        cases.splice(0, casesLength)\\n        cases = deleteDuplicatedCase(cases).slice();\\n    }\\n    return cases.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237966,
                "title": "c-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0||m==0) return 1;\\n        else if(n==1)return 2;\\n        else if(n==2) return m==1?3:4;\\n        else if(m==1) return 4;\\n        else return m==2?7:8;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0||m==0) return 1;\\n        else if(n==1)return 2;\\n        else if(n==2) return m==1?3:4;\\n        else if(m==1) return 4;\\n        else return m==2?7:8;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223202,
                "title": "pointless-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        return \"1111122213441478\"[(min(n, 3) * 4) + min(m, 3)] - \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        return \"1111122213441478\"[(min(n, 3) * 4) + min(m, 3)] - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133044,
                "title": "built-recursion-tree-tle",
                "content": "**Idea**\\nI believe this question is more of a Math problem than programming. I tried building a recursion tree without realizing the pattern.\\nAlthough the following approach resulted in TLE, just wanted to put it out there in case if there are no patterns in the solution.\\nPlease comment if you find any pruning I can do for this recursion tree.\\n\\n```\\n    Set<Integer> seen = new HashSet<>();\\n    public int flipLights(int n, int m) {\\n        int[] lights = new int[n+1];\\n        flipLights(lights, 0, m);\\n        return seen.size();\\n    }\\n    private void flipLights(int[] lights, int count, int m){\\n        if(count == m){\\n            seen.add(toInteger(lights));\\n            return;\\n        }\\n        for(int i=1; i <= 4; i++){\\n            int[] tmp = Arrays.copyOf(lights, lights.length);\\n            perform(lights, i);\\n            flipLights(lights, count+1, m);\\n            //reset for new recursion path\\n            lights = Arrays.copyOf(tmp, tmp.length);\\n        }\\n    }\\n    private void perform(int[] lights, int op){\\n        if(op == 1)\\n            for(int i=1; i < lights.length; i++)\\n                lights[i] ^= 1;\\n        else if(op == 2)\\n            for(int i=2; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else if(op == 3)\\n            for(int i=1; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else\\n            for(int k=0; 3*k+1 < lights.length; k++)\\n                lights[3*k+1] ^= 1;\\n    }\\n    private int toInteger(int[] nums){\\n        int sum = 0;\\n        for(int i=1; i < nums.length; i++)\\n            sum = sum*2+nums[i];\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Set<Integer> seen = new HashSet<>();\\n    public int flipLights(int n, int m) {\\n        int[] lights = new int[n+1];\\n        flipLights(lights, 0, m);\\n        return seen.size();\\n    }\\n    private void flipLights(int[] lights, int count, int m){\\n        if(count == m){\\n            seen.add(toInteger(lights));\\n            return;\\n        }\\n        for(int i=1; i <= 4; i++){\\n            int[] tmp = Arrays.copyOf(lights, lights.length);\\n            perform(lights, i);\\n            flipLights(lights, count+1, m);\\n            //reset for new recursion path\\n            lights = Arrays.copyOf(tmp, tmp.length);\\n        }\\n    }\\n    private void perform(int[] lights, int op){\\n        if(op == 1)\\n            for(int i=1; i < lights.length; i++)\\n                lights[i] ^= 1;\\n        else if(op == 2)\\n            for(int i=2; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else if(op == 3)\\n            for(int i=1; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else\\n            for(int k=0; 3*k+1 < lights.length; k++)\\n                lights[3*k+1] ^= 1;\\n    }\\n    private int toInteger(int[] nums){\\n        int sum = 0;\\n        for(int i=1; i < nums.length; i++)\\n            sum = sum*2+nums[i];\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128006,
                "title": "python-o-1-beat-100",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        if m == 0: return 1\\n        if n == 1: return 2\\n        if n == 2:\\n            if m == 1: return 3\\n            return 4\\n        if n >= 3:\\n            if m == 1: return 4\\n            if m == 2: return 7        \\n    \\n        return 8\\n        ",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        if m == 0: return 1\\n        if n == 1: return 2\\n        if n == 2:\\n            if m == 1: return 3\\n            return 4\\n        if n >= 3:\\n            if m == 1: return 4\\n            if m == 2: return 7        \\n    \\n        return 8\\n        ",
                "codeTag": "Java"
            },
            {
                "id": 123343,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0 || m == 0) return 1;\\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else  return (m == 1) ? 4 : (m == 2) ? 7 : 8;\\n    }\\n}\\n\\n/** 1 + 2 -> 3;\\n *  1 + 3 -> 2;\\n *  2 + 3 -> 1;\\n *  so all cases are: all_on, 1, 2, 3, 4, 1+4, 2+4, 3+4;\\n *  when m == 1, can only have 4 states ( 1, 2, 3, 4)\\n *  when m == 2, can only have 7states (all_on, 1, 2, 3, 1+4, 2+4, 3+4)\\n *  when m == 3, can get all 8 states\\n *  special case analysis required when n < 3;\\n */",
                "solutionTags": [],
                "code": "class Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0 || m == 0) return 1;\\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else  return (m == 1) ? 4 : (m == 2) ? 7 : 8;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 116911,
                "title": "why-is-n-before-m-in-the-function-signature",
                "content": "Is it just me or would it be better practice to put them in alphabetical order, or call them something more informative like `n.lights` and `n.operations`?\n\n```\n    def flipLights(self, n, m):\n```",
                "solutionTags": [],
                "code": "```\n    def flipLights(self, n, m):\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113976,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nint flipLights(int n, int m) {\\n    if(m==0){return 1;}\\n    if(n==1){return 2;}\\n    if(n==2&&m==1){return 3;}\\n    if(n==2){return 4;}\\n    if(m==1){return 4;}\\n    if(m==2){return 7;}\\n    if(m>=3){return 8;}\\n    return 0;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nint flipLights(int n, int m) {\\n    if(m==0){return 1;}\\n    if(n==1){return 2;}\\n    if(n==2&&m==1){return 3;}\\n    if(n==2){return 4;}\\n    if(m==1){return 4;}\\n    if(m==2){return 7;}\\n    if(m>=3){return 8;}\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107268,
                "title": "java-o-1-solution-detail-explaination",
                "content": "for four switches , there are 16 combinations:\\n0000\\n0001\\n0010\\n0011\\n....\\n1110\\n1111\\n\\nas @woshifumingyuan have explained 1+2 = 3, 1+3 = 2, 2+3 = 1\\n\\nso :\\n1. all on        0000 = 1110\\n2. turn on 4   0001 = 1111\\n3. turn on 3   0010 = 1100\\n4. turn on 2   0100 = 1010\\n5.turn on 2+4      0101 = 1011\\n 6.turn on 1         0110 = 1000\\n7.turn on 1+4     0111 = 1001\\n 8.turn on 1+4     0011 = 1101\\ntotally, there are only 8 cases. we reduce 16 cases into 8 cases. \\n\\nbut n <= 2 and m < 3 cases needed to be considered individually because:\\n1. when there is only one light, there will be two status: on and off\\n2. when there are two lights:\\n                                            1. m = 1, only have 3 status: off off, off, on, off on\\n   2 . m >= 2, will have four status: off off, off on, on off, off off.\\n3. when n > 2 && m == 1, will have four status: 0001, 0010, 0100, 1000\\n4. when n > 2 && m == 2, will have 7 status: 0000, 1100, 1010, 0101, 0110, 1001, 0001\\n5. other cases will have 8 status.\\n```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n       return 8;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n       return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107275,
                "title": "simple-thought-process-code",
                "content": "It seems that there are many states resulted from different operation sequences, however, if we look at operation sequences more closely(denoted 1,2,3,4 for each operation, 0 for \"no change\"):\\n\\nWhen m = 1:\\n1=1,2=2,3=3,4=4\\n\\nWhen m = 2:\\n11=0,12=3,13=2,14=14\\n21=3,22=0,23=1,24=24\\n31=2,32=1,33=0,34=34\\n41=14,42=24,43=34,44=0\\n\\nso actually, when m = 2:\\n0,1,2,3,4,14,24,34\\n\\nWhen m >=3:\\nI try out when m=3, the sequences are also 0,1,2,3,4,14,24,34, after cancelling the same operations(like 12=3 etc). I then made a guess when m > 3 the case would be the same. \\n\\nAnd also list out some corner cases when n < 3 and m < 3, we get:\\n\\n```\\nclass Solution {\\npublic:\\n    // 1,2,3,4,11=22=33=44,14,24,34\\n    int flipLights(int n, int m) \\n    {\\n        if (!m) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2 && m >= 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1,2,3,4,11=22=33=44,14,24,34\\n    int flipLights(int n, int m) \\n    {\\n        if (!m) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2 && m >= 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107276,
                "title": "python-hard-code-o-1-solution",
                "content": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if m == 0 or n == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if m == 1:\\n                return 3\\n            return 4\\n        if n > 2:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            return 8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if m == 0 or n == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if m == 1:\\n                return 3\\n            return 4\\n        if n > 2:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107283,
                "title": "java-verbose-solution-using-hashmap-just-do-the-flip-step-by-step",
                "content": "The idea is to use hashmap to store the visited pattern of the bulbs. So you do not need to do the 4 different flips again. And the usage of set can make sure there is no duplicates.\\n\\n    public int flipLights(int n, int m) {     \\n        StringBuilder status = new StringBuilder();\\n        Map<String, String[]> memo = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            status.append(1);\\n        }\\n        Queue<String> current = new LinkedList<>();\\n        current.offer(status.toString());\\n        for (int i = 0; i < m; i++) {\\n            Set<String> visited = new HashSet<>();\\n            while (current.peek() != null) {\\n                String cs = current.poll();\\n                if (memo.containsKey(cs)) {\\n                    for (int j = 0; j < 4; j++) {\\n                        visited.add(memo.get(cs)[j]);\\n                    }\\n                }\\n                else {\\n                    char[] c1 = cs.toCharArray();\\n                    char[] c2 = cs.toCharArray();\\n                    char[] c3 = cs.toCharArray();\\n                    char[] c4 = cs.toCharArray();\\n                    for (int j = 0; j < n; j++) {\\n                        c1[j] = flip(c1[j]);\\n                        if (j%2 == 0) {\\n                            c2[j] = flip(c2[j]);\\n                        }\\n                        if (j%2 == 1) {\\n                            c3[j] = flip(c3[j]);\\n                        }\\n                        if ( j % 3 == 0) {\\n                            c4[j] = flip(c4[j]);\\n                        }\\n                    }\\n                    StringBuilder s1 = new StringBuilder();\\n                    StringBuilder s2 = new StringBuilder();\\n                    StringBuilder s3 = new StringBuilder();\\n                    StringBuilder s4 = new StringBuilder();\\n                    for (int j = 0; j < n; j++) {\\n                        s1.append(c1[j]);\\n                        s2.append(c2[j]);\\n                        s3.append(c3[j]);\\n                        s4.append(c4[j]);\\n                    }\\n                    visited.add(s1.toString());\\n                    visited.add(s2.toString());\\n                    visited.add(s3.toString());\\n                    visited.add(s4.toString());\\n                    String[] temp = {s1.toString(),s2.toString(),s3.toString(),s4.toString()};\\n                    memo.put(cs, temp);\\n                }\\n            }\\n            for (String str: visited) {\\n                current.offer(str);\\n            }\\n        }\\n        return current.size();\\n    }\\n    private char flip(char i) {\\n        if (i == '1') return '0';\\n        else return '1';\\n    }",
                "solutionTags": [],
                "code": "The idea is to use hashmap to store the visited pattern of the bulbs. So you do not need to do the 4 different flips again. And the usage of set can make sure there is no duplicates.\\n\\n    public int flipLights(int n, int m) {     \\n        StringBuilder status = new StringBuilder();\\n        Map<String, String[]> memo = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            status.append(1);\\n        }\\n        Queue<String> current = new LinkedList<>();\\n        current.offer(status.toString());\\n        for (int i = 0; i < m; i++) {\\n            Set<String> visited = new HashSet<>();\\n            while (current.peek() != null) {\\n                String cs = current.poll();\\n                if (memo.containsKey(cs)) {\\n                    for (int j = 0; j < 4; j++) {\\n                        visited.add(memo.get(cs)[j]);\\n                    }\\n                }\\n                else {\\n                    char[] c1 = cs.toCharArray();\\n                    char[] c2 = cs.toCharArray();\\n                    char[] c3 = cs.toCharArray();\\n                    char[] c4 = cs.toCharArray();\\n                    for (int j = 0; j < n; j++) {\\n                        c1[j] = flip(c1[j]);\\n                        if (j%2 == 0) {\\n                            c2[j] = flip(c2[j]);\\n                        }\\n                        if (j%2 == 1) {\\n                            c3[j] = flip(c3[j]);\\n                        }\\n                        if ( j % 3 == 0) {\\n                            c4[j] = flip(c4[j]);\\n                        }\\n                    }\\n                    StringBuilder s1 = new StringBuilder();\\n                    StringBuilder s2 = new StringBuilder();\\n                    StringBuilder s3 = new StringBuilder();\\n                    StringBuilder s4 = new StringBuilder();\\n                    for (int j = 0; j < n; j++) {\\n                        s1.append(c1[j]);\\n                        s2.append(c2[j]);\\n                        s3.append(c3[j]);\\n                        s4.append(c4[j]);\\n                    }\\n                    visited.add(s1.toString());\\n                    visited.add(s2.toString());\\n                    visited.add(s3.toString());\\n                    visited.add(s4.toString());\\n                    String[] temp = {s1.toString(),s2.toString(),s3.toString(),s4.toString()};\\n                    memo.put(cs, temp);\\n                }\\n            }\\n            for (String str: visited) {\\n                current.offer(str);\\n            }\\n        }\\n        return current.size();\\n    }\\n    private char flip(char i) {\\n        if (i == '1') return '0';\\n        else return '1';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107284,
                "title": "java-o-1-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        // for the 4 operations(labeled 1-4, also suppose the original condition is 0):\\n        // 1 + 2 -> 3\\n        // 1 + 3 -> 2\\n        // 2 + 3 -> 1\\n        // So if n <= 2 and m == 1, the conditions are 1,2,3\\n        // if m >= 2, the conditions are 0,1,2,3\\n        // if n > 2, we need to also count condition 4\\n        // if m == 1, the conditions are 1,2,3,4\\n        // if m == 2, the conditions are 0,1,2,3,1+4,2+4,3+4\\n        // if m > 2, the conditions are 0,1,2,3,0+4,1+4,2+4,3+4\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n <= 2) {\\n            if (m == 1) return 3;\\n            else return 4;\\n        }\\n        else if (m == 1) return 4;\\n        else if (m == 2) return 7;\\n        else return 8;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        // for the 4 operations(labeled 1-4, also suppose the original condition is 0):\\n        // 1 + 2 -> 3\\n        // 1 + 3 -> 2\\n        // 2 + 3 -> 1\\n        // So if n <= 2 and m == 1, the conditions are 1,2,3\\n        // if m >= 2, the conditions are 0,1,2,3\\n        // if n > 2, we need to also count condition 4\\n        // if m == 1, the conditions are 1,2,3,4\\n        // if m == 2, the conditions are 0,1,2,3,1+4,2+4,3+4\\n        // if m > 2, the conditions are 0,1,2,3,0+4,1+4,2+4,3+4\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n <= 2) {\\n            if (m == 1) return 3;\\n            else return 4;\\n        }\\n        else if (m == 1) return 4;\\n        else if (m == 2) return 7;\\n        else return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107285,
                "title": "java-solution",
                "content": "Analysis the operations at first:\\n0. Do nothing (dummy rules)\\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n\\nWe can found some rules:\\n1. Do the same operations twice means we do nothing.\\n1 + 1 = 2 + 2 = 3 + 3 = 4 + 4 = 0\\n2. Operations 1, 2, 3 have the relationship:\\n1 + 2 = 3, 1 + 3 = 2, 2 + 3 = 1\\ne..g, we do operations 1 and 2, the result is the same as we just do operation 3.\\n3. Operations 4 is independantly.\\n\\nLet's say n is the number of lights, m is the number of operations.\\nWhen n <= 2, actually operation 4 equals to operation 3. When n = 3, op4 is different with any other operations. So if n > 3, we can just consider as n = 3.\\nWhen m >= 3, whatever the operations are, the results cannot contains any two of operation [0, 1, 2, 3] because of the rule 2. e.g., if the operations are {1, 2, 4}, it would just equal to [3, 4].\\nAll the possible results can be listed : [0+4, 1+4, 2+4, 3+4, 0, 1, 2, 3]. So the result is 8.\\nWhen m == 2, the operation 0+4 cannot happened. So the result is 7.\\n\\n```\\npublic int flipLights(int n, int m) {\\n    int[][] tab = new int[][]{\\n            {1, 1, 1, 1},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}};\\n    if (n > 3) n = 3;\\n    if (m > 3) m = 3;\\n    return tab[n][m];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n    int[][] tab = new int[][]{\\n            {1, 1, 1, 1},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}};\\n    if (n > 3) n = 3;\\n    if (m > 3) m = 3;\\n    return tab[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107286,
                "title": "dfs-bfs-swift",
                "content": "```\\nclass Solution {\\n    func flipLights_BFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var queue = [[String]]()\\n        var level = 0\\n        var result = 0\\n        \\n        queue.append(status)\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var visited = Set<String>()\\n            level += 1\\n            for _ in 0..<count {\\n                let status = queue.removeFirst()\\n                let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n                \\n                for status in statusArray {\\n                    if !visited.contains(status.joined()) {\\n                        if level != m {\\n                            queue.append(status)\\n                        }\\n                        visited.insert(status.joined())\\n                    }\\n                }\\n                \\n                if level == m {\\n                    result = visited.count\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func flipLights_DFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var kinds = Set<String>()\\n        var cache = Set<String>()\\n        \\n        helper(m, status, &kinds, &cache)\\n        \\n        return kinds.count\\n    }\\n    \\n    private func helper(_ remain: Int, _ status: [String], _ kinds: inout Set<String>, _ cache: inout Set<String>) {\\n        if remain == 0 {\\n            kinds.insert(status.joined())\\n            return\\n        }\\n        \\n        let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n        \\n        for status in statusArray {\\n            if !cache.contains(\"\\\\(remain)_\\\\(status.joined())\") {\\n                helper(remain - 1, status, &kinds, &cache)\\n                cache.insert(\"\\\\(remain)_\\\\(status.joined())\")\\n            }\\n        }\\n    }\\n    \\n    private func action1(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            result.append(flip(status[i]))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action2(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 0 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action3(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action4(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 3 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func flip(_ status: String) -> String {\\n        return status == \"1\" ? \"0\" : \"1\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func flipLights_BFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var queue = [[String]]()\\n        var level = 0\\n        var result = 0\\n        \\n        queue.append(status)\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var visited = Set<String>()\\n            level += 1\\n            for _ in 0..<count {\\n                let status = queue.removeFirst()\\n                let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n                \\n                for status in statusArray {\\n                    if !visited.contains(status.joined()) {\\n                        if level != m {\\n                            queue.append(status)\\n                        }\\n                        visited.insert(status.joined())\\n                    }\\n                }\\n                \\n                if level == m {\\n                    result = visited.count\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func flipLights_DFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var kinds = Set<String>()\\n        var cache = Set<String>()\\n        \\n        helper(m, status, &kinds, &cache)\\n        \\n        return kinds.count\\n    }\\n    \\n    private func helper(_ remain: Int, _ status: [String], _ kinds: inout Set<String>, _ cache: inout Set<String>) {\\n        if remain == 0 {\\n            kinds.insert(status.joined())\\n            return\\n        }\\n        \\n        let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n        \\n        for status in statusArray {\\n            if !cache.contains(\"\\\\(remain)_\\\\(status.joined())\") {\\n                helper(remain - 1, status, &kinds, &cache)\\n                cache.insert(\"\\\\(remain)_\\\\(status.joined())\")\\n            }\\n        }\\n    }\\n    \\n    private func action1(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            result.append(flip(status[i]))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action2(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 0 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action3(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action4(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 3 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func flip(_ status: String) -> String {\\n        return status == \"1\" ? \"0\" : \"1\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107287,
                "title": "o-1-java-bit-operation",
                "content": "Java O(1) solution:\\n\\nExplain: \\n\\n*  for n > 3, result is same as n = 3, if same series of operations apply on 3 bulbs generate k distinct result, apply them on more than 3 bulbs would also generate k distinct result.\\n*  only even and odd matters for each operation. So the total possible op series would be [0,0,0,0], [0,0,0,1]...to [1,1,1,1], 16 total\\n*  order of operations doesn't matter\\n\\n```\\npublic int flipLights(int n, int m) {\\n        int odd = 0b101;\\n        int even = 0b010;\\n        int three = 0b001;\\n        if (n > 3) n = 3;\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < 16; ++i) {\\n            int cnt = 0;\\n\\n            for (int k = 0; k < 4; ++k) if ((i&(1<<k)) != 0)++cnt;\\n            if (cnt % 2 != m % 2 || m < cnt) continue;\\n            int v = (1 << n) - 1;\\n            int mask = v;\\n            if ((i & 1) != 0) v = ~v;\\n            if ((i & 2) != 0) v = even&~v|v&~even;\\n            if ((i & 4) != 0) v = odd&~v|v&~odd;\\n            if ((i & 8) != 0) v = three&~v|v&~three;\\n            res.add(v&mask);\\n        }\\n        return res.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n        int odd = 0b101;\\n        int even = 0b010;\\n        int three = 0b001;\\n        if (n > 3) n = 3;\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < 16; ++i) {\\n            int cnt = 0;\\n\\n            for (int k = 0; k < 4; ++k) if ((i&(1<<k)) != 0)++cnt;\\n            if (cnt % 2 != m % 2 || m < cnt) continue;\\n            int v = (1 << n) - 1;\\n            int mask = v;\\n            if ((i & 1) != 0) v = ~v;\\n            if ((i & 2) != 0) v = even&~v|v&~even;\\n            if ((i & 4) != 0) v = odd&~v|v&~odd;\\n            if ((i & 8) != 0) v = three&~v|v&~three;\\n            res.add(v&mask);\\n        }\\n        return res.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107289,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int FlipLights(int n, int m) {\\n        if(m == 0)\\n            return 1;\\n        if(n == 0)\\n            return 1;\\n        else if(n == 1)\\n            return 2;\\n        \\n        if(n > 4)\\n            n=4;\\n        \\n        HashSet<int> pool = new HashSet<int>();\\n        int max = 1 << n;\\n        pool.Add(max-1);\\n        int b1 = 15 >> (4-n);\\n        int b2 = 10 >> (4-n);\\n        int b3 = 5 >> (4-n);\\n        int b4 = 9 >> (4-n);\\n        while(m > 0 && pool.Count() < max){\\n            HashSet<int> newpool = new HashSet<int>();\\n            foreach(var item in pool){\\n                newpool.Add(item ^ b1);\\n                newpool.Add(item ^ b2);\\n                newpool.Add(item ^ b3);\\n                newpool.Add(item ^ b4);\\n            }\\n            pool = newpool;\\n            m--;\\n        }\\n        \\n        return pool.Count();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FlipLights(int n, int m) {\\n        if(m == 0)\\n            return 1;\\n        if(n == 0)\\n            return 1;\\n        else if(n == 1)\\n            return 2;\\n        \\n        if(n > 4)\\n            n=4;\\n        \\n        HashSet<int> pool = new HashSet<int>();\\n        int max = 1 << n;\\n        pool.Add(max-1);\\n        int b1 = 15 >> (4-n);\\n        int b2 = 10 >> (4-n);\\n        int b3 = 5 >> (4-n);\\n        int b4 = 9 >> (4-n);\\n        while(m > 0 && pool.Count() < max){\\n            HashSet<int> newpool = new HashSet<int>();\\n            foreach(var item in pool){\\n                newpool.Add(item ^ b1);\\n                newpool.Add(item ^ b2);\\n                newpool.Add(item ^ b3);\\n                newpool.Add(item ^ b4);\\n            }\\n            pool = newpool;\\n            m--;\\n        }\\n        \\n        return pool.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565085,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            },
            {
                "id": 1568010,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            },
            {
                "id": 1569148,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            },
            {
                "id": 2042249,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Longest Increasing Subsequence",
        "question_content": "<p>Given an integer array&nbsp;<code>nums</code>, return <em>the number of longest increasing subsequences.</em></p>\n\n<p><strong>Notice</strong> that the sequence has to be <strong>strictly</strong> increasing.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,4,7]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 107293,
                "title": "java-c-simple-dp-solution-with-explanation",
                "content": "The idea is to use two arrays ```len[n]``` and ```cnt[n]``` to record the maximum length of Increasing Subsequence and the coresponding number of these sequence which ends with ```nums[i]```, respectively. That is:\\n\\n```len[i]```: the length of the Longest Increasing Subsequence which ends with ```nums[i]```.\\n```cnt[i]```: the number of the Longest Increasing Subsequence which ends with ```nums[i]```.\\n\\nThen, the result is the sum of each ```cnt[i]``` while its corresponding ```len[i]``` is the maximum length.\\n\\nJava version:\\n```\\npublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, max_len = 0;\\n        int[] len =  new int[n], cnt = new int[n];\\n        for(int i = 0; i<n; i++){\\n            len[i] = cnt[i] = 1;\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(len[i] == len[j] + 1)cnt[i] += cnt[j];\\n                    if(len[i] < len[j] + 1){\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                }\\n            }\\n            if(max_len == len[i])res += cnt[i];\\n            if(max_len < len[i]){\\n                max_len = len[i];\\n                res = cnt[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nC++ version: (use ```vector<pair<int, int>> dp``` to combine ```len[]``` and ```cnt[]```)\\n```\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), res = 0, max_len = 0;\\n        vector<pair<int,int>> dp(n,{1,1});            //dp[i]: {length, number of LIS which ends with nums[i]}\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(dp[i].first == dp[j].first + 1)dp[i].second += dp[j].second;\\n                    if(dp[i].first < dp[j].first + 1)dp[i] = {dp[j].first + 1, dp[j].second};\\n                }\\n            }\\n            if(max_len == dp[i].first)res += dp[i].second;\\n            if(max_len < dp[i].first){\\n                max_len = dp[i].first;\\n                res = dp[i].second;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```len[n]```\n```cnt[n]```\n```nums[i]```\n```len[i]```\n```nums[i]```\n```cnt[i]```\n```nums[i]```\n```cnt[i]```\n```len[i]```\n```\\npublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, max_len = 0;\\n        int[] len =  new int[n], cnt = new int[n];\\n        for(int i = 0; i<n; i++){\\n            len[i] = cnt[i] = 1;\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(len[i] == len[j] + 1)cnt[i] += cnt[j];\\n                    if(len[i] < len[j] + 1){\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                }\\n            }\\n            if(max_len == len[i])res += cnt[i];\\n            if(max_len < len[i]){\\n                max_len = len[i];\\n                res = cnt[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```vector<pair<int, int>> dp```\n```len[]```\n```cnt[]```\n```\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), res = 0, max_len = 0;\\n        vector<pair<int,int>> dp(n,{1,1});            //dp[i]: {length, number of LIS which ends with nums[i]}\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(dp[i].first == dp[j].first + 1)dp[i].second += dp[j].second;\\n                    if(dp[i].first < dp[j].first + 1)dp[i] = {dp[j].first + 1, dp[j].second};\\n                }\\n            }\\n            if(max_len == dp[i].first)res += dp[i].second;\\n            if(max_len < dp[i].first){\\n                max_len = dp[i].first;\\n                res = dp[i].second;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230468,
                "title": "c-clean-dp-solution-easy-and-explained",
                "content": "Let\\'s have a look on the implementation-\\n\\n\\u2714**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  // stores length of longest sequence till i-th position\\n        vector<int> count(n,1);  // stores count of longest sequence of length lis[i]\\n        int maxLen = 1;  // maximum length of lis\\n\\t\\t\\n\\t\\t// O(N^2) DP Solution\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ // strictly increasing\\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\t // this means there are more subsequences of same length ending at length lis[i]\\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        // count all the subseq of length maxLen\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```\\n\\n# Kindly Upvote :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  // stores length of longest sequence till i-th position\\n        vector<int> count(n,1);  // stores count of longest sequence of length lis[i]\\n        int maxLen = 1;  // maximum length of lis\\n\\t\\t\\n\\t\\t// O(N^2) DP Solution\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ // strictly increasing\\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\t // this means there are more subsequences of same length ending at length lis[i]\\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        // count all the subseq of length maxLen\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107295,
                "title": "9ms-c-explanation-dp-binary-search-prefix-sums-o-nlogn-time-o-n-space",
                "content": "The idea is to modify classic [LIS solution which uses binary search]( https://en.wikipedia.org/wiki/Longest_increasing_subsequence) to find the \"insertion point\" of a currently processed value. At ```dyn[k]``` we **don\\'t store** a single number representing the smallest value such that there exists a LIS of length ```k+1``` as in classic LIS solution. Instead, at ```dyn[k]``` we store all such values that were once endings of a ```k+1``` LIS (so we keep the history as well). \\nThese values are held in the first part of the pairs in  ```vector<pair<int,int>>``` which we get by indexing ```dyn``` vector. So for example in a pair ```x = {a, b}``` the first part -- ```a```, indicates that there exists a LIS of length ```k+1``` such that it ends with a value ```a```. The second part -- ```b```, represents the number of possible options for which LIS of length ```k+1``` ends with a value equal to or greater than ```a```. This is the place where we use prefix sums. \\nIf we want to know how many options do we have to end a LIS of length ```m``` with value ```y```, we just binary search for the index ```i``` of a pair with first part strictly less than ```y``` in ```dyn[m-2]```. Then the number of options is ```dyn[m-2].back().second - dyn[m-2][i-1].second``` or just ```dyn[m-2].back()``` if ```i``` is ```0```.\\nThat is the basic idea, the running time is O(NlogN), because we just do 2 binary searches for every element of the input. Space complexity is O(N), as every element of the input will be contained in the ```dyn``` vector exactly once.\\nFeel free to post any corrections or simpler explanations :)\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // bsearch insertion point\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            \\n            // bsearch number of options\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                \\n                options = dyn[row].back().second;\\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            \\n            \\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        \\n        return dyn[max_so_far-1].back().second;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```dyn[k]```\n```k+1```\n```dyn[k]```\n```k+1```\n```vector<pair<int,int>>```\n```dyn```\n```x = {a, b}```\n```a```\n```k+1```\n```a```\n```b```\n```k+1```\n```a```\n```m```\n```y```\n```i```\n```y```\n```dyn[m-2]```\n```dyn[m-2].back().second - dyn[m-2][i-1].second```\n```dyn[m-2].back()```\n```i```\n```0```\n```dyn```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // bsearch insertion point\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            \\n            // bsearch number of options\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                \\n                options = dyn[row].back().second;\\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            \\n            \\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        \\n        return dyn[max_so_far-1].back().second;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835323,
                "title": "python-3-dp-explanation",
                "content": "### Intuition\\n- To find the frequency of the longest increasing sequence, we need \\n\\t- First, know how long is the longest increasing sequence\\n\\t- Second, count the frequency\\n- Thus, we create 2 lists with length `n`\\n\\t- `dp[i]`: meaning length of longest increasing sequence\\n\\t- `cnt[i]`: meaning frequency of longest increasing sequence\\n- If `dp[i] < dp[j] + 1` meaning we found a longer sequence and `dp[i]` need to be updated, then `cnt[i]` need to be updated to `cnt[j]`\\n- If `dp[i] == dp[j] + 1` meaning `dp[j] + 1` is one way to reach longest increasing sequence to `i`, so simple increment by `cnt[j]` like this `cnt[i] = cnt[i] + cnt[j]`\\n- Finally, sum up `cnt` of all longest increase sequence will be the solution\\n- This is a pretty standard DP question. Just like most sequence type of DP question, we need to loop over each element and check all previous stored information to update current. \\n- Time complexity is `O(n*n)`\\n### Implementation\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916196,
                "title": "python-short-o-n-log-n-solution-beats-100-explained",
                "content": "The idea of my solution is to use so-called Patience sort: https://en.wikipedia.org/wiki/Patience_sorting\\n\\nThe idea is to keep several `decks`, where numbers in each deck are decreasing. Also when we see new card, we need to put it to the end of the leftest possible deck. Also we have `paths`: corresponing number of LIS, ending with given `num`. That is in `paths[0]` we keep number of LIS with length `1`, in `paths[k]` we keep number of LIS with length `k+1`. (we keep cumulative sums) Also we keep `ends_decks` list to have quick access to end of our decks.\\n\\n**Property**: It can be proved, that each LIS can be formed as choosing not more than one number from each deck and choosing them, looking at decks from left to right.\\n\\nImagine, that we have `nums = [1,3,5,4,7,10,8,2,8]`, then we have the following `decks` and `paths` step by step:\\n\\n`decks =  [[-1]] paths =  [[0, 1]]`\\n`decks =  [[-1], [-3]] paths =  [[0, 1], [0, 1]]`\\n`decks =  [[-1], [-3], [-5]] paths =  [[0, 1], [0, 1], [0, 1]]`\\n`decks =  [[-1], [-3], [-5, -4]] paths =  [[0, 1], [0, 1], [0, 1, 2]]`\\n`decks =  [[-1], [-3], [-5, -4], [-7]] paths =  [[0, 1], [0, 1], [0, 1, 2], [0, 2]]`\\n`decks =  [[-1], [-3], [-5, -4], [-7], [-10]] paths =  [[0, 1], [0, 1], [0, 1, 2], [0, 2], [0, 2]]`\\n`decks =  [[-1], [-3], [-5, -4], [-7], [-10, -8]] paths =  [[0, 1], [0, 1], [0, 1, 2], [0, 2], [0, 2, 4]]`\\n`decks =  [[-1], [-3, -2], [-5, -4], [-7], [-10, -8]] paths =  [[0, 1], [0, 1, 2], [0, 1, 2], [0, 2], [0, 2, 4]]`\\n`decks =  [[-1], [-3, -2], [-5, -4], [-7], [-10, -8, -8]] paths =  [[0, 1], [0, 1, 2], [0, 1, 2], [0, 2], [0, 2, 4, 6]]`\\n\\n\\nWe use negative numbers, so each deck is sorted in increasing way instead of decreasing.\\n\\nWhen we see new `num`, then we first find `deck_idx`: number of deck we need to put this `num`. Now, we want to find number of LIS, ending with this `num`: for this we need to look at previous deck and find the place of `num` inside this deck: here we use our **property**, we update our `n_path`.\\n\\nNow, we need to decide where we put this number:\\n1. If our `deck_idx` is equal to `len(decks)`, it means, that we need to create new `deck`: we create new deck with one element, update `ends_decks` and also append `n_paths` to our `paths`.\\n2. In opposite case, we need to add `nums` to the end of corresponding deck, again update `ends_decks`  and update our `pathcs[deck_idx]`: it will consist of two parts: `n_paths`: number of paths, such that previous element is from previous or before decks. Also we have `paths[deck_idx][-1]`, because we keep cumulative sums inside.\\n\\nFinally, we return `paths[-1][-1]`, it is number of LIS with the biggest length.\\n\\n**Complexity** is `O(n log n)`, because for each new `num` we process it in `O(log n)`. Space complexity is `O(n)`. When I run it, i have times, I have times from 60ms to 72ms, where `60`ms beats 100% of python solutions.\\n\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\\n\\n**Shorter version** it can be written in shorter version, if we prefill our `decks`, `decks_ends` and `paths` first. However I do no know if we can do binary search in python by **key**: if we can, we can remove `ends_decks` at all and simplify it even more. Can somebody help me with it?\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        n = len(nums) + 1\\n    \\n        decks, ends_decks, paths = [[] for _ in range(n)], [float(\"inf\")]*n, [[0] for _ in range(n)]\\n        for num in nums:\\n            idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if idx > 0:\\n                l = bisect.bisect(decks[idx-1], -num)\\n                n_paths = paths[idx-1][-1] - paths[idx-1][l]\\n            \\n            decks[idx].append(-num)\\n            ends_decks[idx] = num\\n            paths[idx].append(n_paths + paths[idx][-1])\\n                \\n        return paths[paths.index([0]) - 1][-1]\\n```\\n\\n\\n**PS**: see also my solution of problem 300: Longest Increasing Subsequence: https://leetcode.com/problems/longest-increasing-subsequence/discuss/667975/Python-3-Lines-dp-with-binary-search-explained\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        n = len(nums) + 1\\n    \\n        decks, ends_decks, paths = [[] for _ in range(n)], [float(\"inf\")]*n, [[0] for _ in range(n)]\\n        for num in nums:\\n            idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if idx > 0:\\n                l = bisect.bisect(decks[idx-1], -num)\\n                n_paths = paths[idx-1][-1] - paths[idx-1][l]\\n            \\n            decks[idx].append(-num)\\n            ends_decks[idx] = num\\n            paths[idx].append(n_paths + paths[idx][-1])\\n                \\n        return paths[paths.index([0]) - 1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107318,
                "title": "c-dp-with-explanation-o-n-2",
                "content": "The solution is based on DP. \\n```\\nFor a sequence of numbers,\\ncnt[k] is total number of longest subsequence ending with nums[k];\\nlen[k] is the length of longest subsequence ending with nums[k];\\n```\\nThen we have following equations \\n```\\nlen[k+1] = max(len[k+1], len[i]+1) for all i <= k and nums[i] < nums[k+1];\\ncnt[k+1] = sum(cnt[i]) for all i <= k and nums[i] < nums[k+1] and len[i] = len[k+1]-1;\\n```\\nStarting case and default case: cnt[0] = len[0] = 1;\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        // find the longest increasing subsequence of the whole sequence\\n       // sum valid counts\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nFor a sequence of numbers,\\ncnt[k] is total number of longest subsequence ending with nums[k];\\nlen[k] is the length of longest subsequence ending with nums[k];\\n```\n```\\nlen[k+1] = max(len[k+1], len[i]+1) for all i <= k and nums[i] < nums[k+1];\\ncnt[k+1] = sum(cnt[i]) for all i <= k and nums[i] < nums[k+1] and len[i] = len[k+1]-1;\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        // find the longest increasing subsequence of the whole sequence\\n       // sum valid counts\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107320,
                "title": "python-dp-with-explanation-beats-88",
                "content": "If you have not solved the [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) problem, you should do so before attempting this question. The approach is very similar and only requires augmentation of the DP array.\\n\\nIn the Longest Increasing Subsequence problem, the DP array simply had to store the longest length. In this variant, each element in the DP array needs to store two things: (1) Length of longest subsequence ending at this index and (2) Number of longest subsequences that end at this index. I use a two element list for this purpose.\\n\\nIn each loop as we build up the DP array, find the longest length for this index and then sum up the numbers at these indices that contribute to this longest length.\\n\\nHere I provide two versions: (1) A slower but easier to understand version and (2) Much faster and optimized version\\n\\n**\\uD83D\\uDCAF Check out https://techinterviewhandbook.org for more tips and tricks to ace your technical interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n^2)\\n        # Space: O(n)\\n        dp, longest = [[1, 1] for i in range(len(nums))], 1\\n        for i, num in enumerate(nums):\\n            curr_longest, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    curr_longest = max(curr_longest, dp[j][0] + 1)\\n            for j in range(i):\\n                if dp[j][0] == curr_longest - 1 and nums[j] < num:\\n                    count += dp[j][1]\\n            dp[i] = [curr_longest, max(count, dp[i][1])]\\n            longest = max(curr_longest, longest)\\n        return sum([item[1] for item in dp if item[0] == longest])\\n```\\n\\nThe counting step can be optimized such that we don\\'t count from the start when we find a longer `max_len`. This improved the speed from 10% to 88%.\\n\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1, 1] for i in range(len(nums))]\\n        max_for_all = 1\\n        for i, num in enumerate(nums):\\n            max_len, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    if dp[j][0] + 1 > max_len:\\n                        max_len = dp[j][0] + 1\\n                        count = 0 \\n                    if dp[j][0] == max_len - 1:\\n                        count += dp[j][1]\\n            dp[i] = [max_len, max(count, dp[i][1])]\\n            max_for_all = max(max_len, max_for_all)\\n        return sum([item[1] for item in dp if item[0] == max_for_all])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n^2)\\n        # Space: O(n)\\n        dp, longest = [[1, 1] for i in range(len(nums))], 1\\n        for i, num in enumerate(nums):\\n            curr_longest, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    curr_longest = max(curr_longest, dp[j][0] + 1)\\n            for j in range(i):\\n                if dp[j][0] == curr_longest - 1 and nums[j] < num:\\n                    count += dp[j][1]\\n            dp[i] = [curr_longest, max(count, dp[i][1])]\\n            longest = max(curr_longest, longest)\\n        return sum([item[1] for item in dp if item[0] == longest])\\n```\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1, 1] for i in range(len(nums))]\\n        max_for_all = 1\\n        for i, num in enumerate(nums):\\n            max_len, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    if dp[j][0] + 1 > max_len:\\n                        max_len = dp[j][0] + 1\\n                        count = 0 \\n                    if dp[j][0] == max_len - 1:\\n                        count += dp[j][1]\\n            dp[i] = [max_len, max(count, dp[i][1])]\\n            max_for_all = max(max_len, max_for_all)\\n        return sum([item[1] for item in dp if item[0] == max_for_all])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794723,
                "title": "efficient-dp-solution-lis-beats-98-4",
                "content": "# Intuition\\nThe given problem can be efficiently solved using a dynamic programming approach. We maintain two arrays, dp and count, to keep track of the length of the longest increasing subsequence and the count of such subsequences, respectively. The idea is to iterate through the input array, updating these arrays as we go along.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the dp and count arrays with all elements set to 1, as each element is a valid subsequence of length 1.\\n2. For each element at index i in the input array, iterate through all elements before it (index j from 0 to i-1).\\n3. Compare the values of nums[i] and nums[j]:\\n    - If nums[i] is greater than nums[j], we have a potential increasing subsequence.\\n    - Check if dp[j] + 1 (the length of the LIS ending at index j plus the current element) is greater than dp[i] (the current length of the LIS ending at index i). If so, update dp[i] to dp[j] + 1, and set count[i] to count[j] since we have found a new longer subsequence ending at i.\\n    - If dp[j] + 1 is equal to dp[i], it means we have found another subsequence with the same length as the one ending at i. In this case, we add count[j] to the existing count[i], as we have multiple ways to form subsequences with the same length.\\n4. Keep track of the maxLength of the LIS encountered during the process.\\n5. Finally, iterate through the dp array again, and for each index i, if dp[i] equals maxLength, add the corresponding count[i] to the result.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n\\n        int[] dp = new int[n]; \\n        int[] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n\\n        int maxLength = 1; \\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLength) {\\n                result += count[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n\\n        vector<int> lengths(n, 1); \\n        vector<int> counts(n, 1); \\n        vector<int> bit(n + 1, 0); \\n\\n        int max_length = 1; \\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            max_length = max(max_length, lengths[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (lengths[i] == max_length) {\\n                result += counts[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```\\n```C []\\nint findNumberOfLIS(int* nums, int numsSize) {\\n    if (numsSize == 0) return 0;\\n\\n    int dp[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = 1;\\n    }\\n\\n    int maxLength = 1;\\n    int result = 0;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[i] > nums[j]) {\\n                if (dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        if (dp[i] > maxLength) {\\n            maxLength = dp[i];\\n        }\\n    }\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (dp[i] == maxLength) {\\n            result++;\\n        }\\n    }\\n\\n    return result;\\n}\\n```\\n\\n> If you find my solution helpful, I would greatly appreciate your one upvote.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n\\n        int[] dp = new int[n]; \\n        int[] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n\\n        int maxLength = 1; \\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLength) {\\n                result += count[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n\\n        vector<int> lengths(n, 1); \\n        vector<int> counts(n, 1); \\n        vector<int> bit(n + 1, 0); \\n\\n        int max_length = 1; \\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            max_length = max(max_length, lengths[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (lengths[i] == max_length) {\\n                result += counts[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\n```Python3 []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```\n```C []\\nint findNumberOfLIS(int* nums, int numsSize) {\\n    if (numsSize == 0) return 0;\\n\\n    int dp[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = 1;\\n    }\\n\\n    int maxLength = 1;\\n    int result = 0;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[i] > nums[j]) {\\n                if (dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        if (dp[i] > maxLength) {\\n            maxLength = dp[i];\\n        }\\n    }\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (dp[i] == maxLength) {\\n            result++;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643753,
                "title": "python-o-nlogn-solution-w-detailed-explanation-of-how-to-develop-a-binary-search-solution-from-300",
                "content": "Though it is rather easier to get a DP solution with O(n^2), I\\'ve been thinking for days how to develop an answer based on Binary Search solution for leetcode 300: https://leetcode.com/problems/longest-increasing-subsequence/. I\\'ve read several post to help develop the thoughts but some are not very intuitive to understand. After thinking more on my own, I finally got a comprehensive understanding. So I\\'m writing the post to share a Python O(nlogn) solution based on Binary Search with detailed explanation how I develop the thought, and hope it will help people that have the same confusion as me.\\n\\nReferences:\\nhttps://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107295/9ms-C%2B%2B-Explanation%3A-DP-%2B-Binary-search-%2B-prefix-sums-O(NlogN)-time-O(N)-space\\n\\nTo come up with the solution, we need to answer a few questions.\\n\\n\\n# Quesiton 1: how to record all the possible paths based on the original sub_list array for Leetcode 300?\\n\\n\\nThe first important idea is: \\n**Instead of \"updating\" when we find the idx by binary search, we record every time when trying to update a position.**\\n*(Another way to understand this thought: previously at each position i, the number works as a \"snapshot\", now we want to get a time serie of how the number get updated)*\\n\\nConsider an example:  [1, 3, 2, 5, 4, 7]\\n![image](https://assets.leetcode.com/users/images/7452a6ec-8f7b-4817-a7ca-5b61ebf0768f_1641368843.5299492.png)\\n\\n\\nIt is easy to figure out, we change each position as an array, which records the updated value each time when a new element comes in. \\n**In this pocess, we only care about the last element of each array, which redueces the dimensions of this new array to exactly the same as LIS problem. **\\n\\nFor instance, as for step 4, we know 5 > 2, so it should be inserted in a new array at position 1.\\n\\nSo here, we can define: \\nbuild an array called `sub_list`, where `sub_list[k + 1]` records all the elements that can be a tail of an increasing subsequence with length k.\\nFor instance, in the example above, [3, 2] at position 1 records element = 3 or 2, that can form an increasing subsequence of length 2\\n\\nHowever, based on this example, we will find there is another problem: \\n**an element can be a tail of mutiple increasing subsequence with the same length**. \\n\\nFor this example, [1, 3, 2, 5, 4, 7]\\nWe will actually find the answer is 4:\\n`[1, 3, 5, 7], [1, 3, 4, 7], [1, 2, 5, 7], [1, 2, 4, 7]`\\nAnd this is hard to be directly figured out from the array `sub_list`.\\n\\n\\nHere we come to next question:\\n# Question 2: how to handle this situation of an element can be a tail of multiple lists?\\nTo solve this problem, we add another dimension for each element: a number record how many increasing subsequence is ended by this particular element.\\nThen for this example, we will get:\\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\\nFor instance, 5 follows with a number 2 since there are actually 2 increasing subsequences ended with 5: `[1, 3, 5], [1, 2, 5]`\\n\\n\\nBased on this design, we get to our 3rd qustion:\\n# Qustion 3: how could we update to get this number?\\n*(As described above, this added number represents the total number of possible increasing subsequence ending with a particular value)*\\n\\nHere we use a thought similar to the **dynamic programing** solution: \\nTo get current status, we can use the status getting from the previous loop. \\nI.E, when updating at position `k` for element `x`, we only need to sum the count of subsequence ending with smaller elements at position` k - 1`, or previous row. \\n\\nOK, based on these steps, we can actually write a solution that with a similar structure to the answer of Leetcode#300 now:\\n\\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = sum([x[1] for x in sub_list[-1] if val > x[0]]) if len(sub_list) != 0 else 1\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                # if pos == 0, means it is smallest, no need to look the previous level and set it to be 1\\n                cur_count = sum([x[1] for x in sub_list[pos - 1] if val > x[0]]) if pos > 0 else 1\\n                sub_list[pos].append((val, cur_count))\\n      \\n        return sum([x[1] for x in sub_list[-1]])\\n```\\n\\nNote: unless other posts, here I use the exactly the same Binary Search implementation for 1-d array, to emphasize the connection of this solution to the original method. As it has been pointed out in Qustion 1:\\n> we only care about the last element of each array, which redueces the dimensions of this new array to exactly the same as LIS problem. \\n\\nHowever, this is not the final version, since we will find another problem:\\nthough it is `O(logn)` for find_pos, the process of going to the previous level and seach for `val > x[0]`,  is still an `O(n)` operation, which causes the total complexity is still O(n^2). \\n\\n\\nIt leads to a 4th question:\\n# Question 4: How could we possibly optimze this process, to find the elements smaller than current element? \\n\\nTo answer this question, we need to realize there is an important property of previously defined `sub_list`:\\n\\n**For every ` 0 <= k < len(sub_list)`,  the value of elements in `sub_list[k]` should form a non-increasing array.**\\n\\nStill take this example:\\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\\nWe can notice that `[1]`, `[3, 2]`, `[5, 4]`, `[7]` are all non-increasing arrays. This property comes from how we update each position, since we target at forming a longer increasing array. And it also is easy to use contradictionay to prove: \\n>if we get an array like [3, 2, 5] at position 1, it is obviously wrong since 5 can form a longer subsequence.\\n\\nSince these arrays are all in order, we can use Binary Search to figure out how many elements are strictly smaller than current value.\\n\\nBefore we can further develop the solution, we\\'ll find here is another problem: we need to get the `sum` of all the elements smaller than current value from the previous status. So here is our 5th question to answer:\\n\\n\\n# Question 5: how to get the sum of all the possible increasing subsequence of the smaller elements than current value? \\n\\nHere we use the concept of **prefix sum**:\\nWe change the number at the second dimension to represent counts of increasing subsequences ending at all elements **equal or greater than current element**.\\nThat is to say, assume we have tuple `(a, x)` at position `k + 1,` where` x = sum( number_of_IS(bi) )` where `bi >= a`, and `bi` can be the tails of these increasing subsequences that has length `k`\\n\\n\\nFor instance, the previous example will change to:\\n\\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, ** 2 **)],  \\n     [ (5, 2), (4, **4**)], \\n     [ (7, 4) ] \\n] \\n```\\n\\nSo if we know on the previous row, we can get an `idx` where `[0, \\u2026 idx - 1]` are all `number >= current_val`, and `[idx, \\u2026. n]` is all `number < current_val`,\\nThen we can get the number of path by:\\n`Sequence_number_greater_or_equal_to(n) - Sequence_number_greater_or_euqal_to(idx - 1)`\\n\\nIf this is not clear enough, we can use another way to explain this process: \\n\\nRemebering that as previous definition, we make the second dimension represents** number of increasing subsequences ending with an element**. \\nNow since we know at each row, the element list shoud be **non-increasing**, so we can make the second dimension updated to represent number of increasing subsequences ending with **great or equal to current element** by building a prefix sum array:\\n\\n```\\nfor i in range(1, len(row)):\\n    prefix_sum[i][1] = prefix_sum[i - 1][1] + row[i][1]\\n```\\n\\nSo, if we want to know `row[idx] + row[idx + 1] + \\u2026 + row[n]`:\\nSince \\n```\\nprefix_sum[i][n] = prefix_sum[i][idx - 1] + row[idx] + row[idx + 1] + ... + row[n]\\n```\\n\\nTherefore, \\n```\\nrow[idx] + row[idx + 1] + ... + row[n] = prefix_sum[i][n] - prefix_sum[i][idx - 1]\\n```\\n\\nCertainly, if `idx = 0`, the value prefix_sum[i][n] should directly be the answer .\\n\\nHere is also an example to help understand this thought of \\u201Cprefix sum\":\\n\\n> Assume we\\'re looking at a previous row like: [(5, n0), (4, n1), (2, n2), (1, n3)] \\nAnd we have a current value as val = 3, \\nBased on previous thought, we want to know the sum of path smaller than 3.\\nWe can use Binary Search to get an idx = 2: when idx < 2 or equally idx <= 1, we have elements >= current_val, which can not form an increasing list; and when idx >= 2, here we get the number we want, so the actual value is n3 - n1. \\n\\nBy far, we got the solution and we can modify our previous solution implemented in Question 3 to optimze the process of searching for smaller numbers to `O(logn)`:\\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n        \\n        def find_smaller(sub, val):\\n            left = 0\\n            right = len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                # [x > val | x = val | x < val]\\n                if sub[mid] < val: # find the first point < val\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n                    \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = 1\\n                if len(sub_list) > 0:\\n                    last_row = [x[0] for x in sub_list[-1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[-1][-1][1] - sub_list[-1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[-1][-1][1]\\n                    \\n                # since there is no element in this current row, no need to add previous counts\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                cur_count = 1\\n                if pos > 0:\\n                    last_row = [x[0] for x in sub_list[pos - 1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[pos - 1][-1][1]\\n                \\n                # if current row is not empty, add previous value, else set it to be current count\\n                sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 else cur_count))\\n        \\n        return sub_list[-1][-1][1]\\n```\\n\\nWe can further optimize the for-loop part to avoid duplications:\\n\\n```Python\\nfor val in nums:\\n    if len(sub_list) == 0:\\n        sub_list.append([(val, 1)])\\n    else: \\n        pos = 0\\n        if val > sub_list[-1][-1][0]:\\n            # init a new line \\n            sub_list.append([]) \\n            pos = len(sub_list) - 1\\n        else:\\n            cur_sub = [arr[-1][0] for arr in sub_list]\\n            pos = find_pos(cur_sub, val)\\n            \\n        cur_count = 1\\n        if pos > 0:\\n            last_row = [x[0] for x in sub_list[pos - 1]]\\n            idx = find_smaller(last_row, val)\\n            cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                        else sub_list[pos - 1][-1][1]\\n        \\n        # if current row is not empty, add previous value, else set it to be current count\\n        sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 \\\\\\n                                else cur_count))\\nreturn sub_list[-1][-1][1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = sum([x[1] for x in sub_list[-1] if val > x[0]]) if len(sub_list) != 0 else 1\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                # if pos == 0, means it is smallest, no need to look the previous level and set it to be 1\\n                cur_count = sum([x[1] for x in sub_list[pos - 1] if val > x[0]]) if pos > 0 else 1\\n                sub_list[pos].append((val, cur_count))\\n      \\n        return sum([x[1] for x in sub_list[-1]])\\n```\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, ** 2 **)],  \\n     [ (5, 2), (4, **4**)], \\n     [ (7, 4) ] \\n] \\n```\n```\\nfor i in range(1, len(row)):\\n    prefix_sum[i][1] = prefix_sum[i - 1][1] + row[i][1]\\n```\n```\\nprefix_sum[i][n] = prefix_sum[i][idx - 1] + row[idx] + row[idx + 1] + ... + row[n]\\n```\n```\\nrow[idx] + row[idx + 1] + ... + row[n] = prefix_sum[i][n] - prefix_sum[i][idx - 1]\\n```\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n        \\n        def find_smaller(sub, val):\\n            left = 0\\n            right = len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                # [x > val | x = val | x < val]\\n                if sub[mid] < val: # find the first point < val\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n                    \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = 1\\n                if len(sub_list) > 0:\\n                    last_row = [x[0] for x in sub_list[-1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[-1][-1][1] - sub_list[-1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[-1][-1][1]\\n                    \\n                # since there is no element in this current row, no need to add previous counts\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                cur_count = 1\\n                if pos > 0:\\n                    last_row = [x[0] for x in sub_list[pos - 1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[pos - 1][-1][1]\\n                \\n                # if current row is not empty, add previous value, else set it to be current count\\n                sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 else cur_count))\\n        \\n        return sub_list[-1][-1][1]\\n```\n```Python\\nfor val in nums:\\n    if len(sub_list) == 0:\\n        sub_list.append([(val, 1)])\\n    else: \\n        pos = 0\\n        if val > sub_list[-1][-1][0]:\\n            # init a new line \\n            sub_list.append([]) \\n            pos = len(sub_list) - 1\\n        else:\\n            cur_sub = [arr[-1][0] for arr in sub_list]\\n            pos = find_pos(cur_sub, val)\\n            \\n        cur_count = 1\\n        if pos > 0:\\n            last_row = [x[0] for x in sub_list[pos - 1]]\\n            idx = find_smaller(last_row, val)\\n            cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                        else sub_list[pos - 1][-1][1]\\n        \\n        # if current row is not empty, add previous value, else set it to be current count\\n        sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 \\\\\\n                                else cur_count))\\nreturn sub_list[-1][-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389782,
                "title": "heavily-commented-easy-to-read-faster-than-93",
                "content": "Hi All,\\nI found a most of the javascript solutions posted in discussion board a bit hard to understand so I decided to heavily commment my solution to make it easier to follow why each decision was made. \\nHope this helps!\\n\\n```\\nvar findNumberOfLIS = function(nums) {\\n    // We initialize an array named \"tracker\" to track the longest increasing subsequence ending at each\\n    // index and initialize all positions with 1 as each item in nums can be considered as subsequence in\\n    // itself.\\n    let tracker = new Array(nums.length).fill(1);\\n    \\n    \\n    // While tracking, we will realize that at times there is more than one set of preceding items in nums\\n    // that can make the longest increasing subsequence that end at the index we are currently processing.\\n    // The best way to track this is in a seperate array called frequency. Each element will here is\\n    // initialized to 1. This signifies that initially, there can only be a single longest\\n    // subsequence ending at any index.\\n    let frequency = new Array(nums.length).fill(1);\\n    \\n    // Now let\\'s start processing from left to right, starting with the second element at index 1\\n    // Skipping first element as we cannot find a subsequence longer than 1 that can end at index 0.\\n    for(let i = 0; i < nums.length; i++){\\n        // Now let\\'s compare it with every element before it\\n        for(let j = 0; j < i; j++){\\n\\n            // VERIFY: Quick verification that j can be a part of a strictly increasing subsequence ending\\n            // at i\\n            if(nums[j] < nums[i]){\\n\\n                // CASE 1: Is Connecting i to the subsequence ending at j makes a subsequence larger that\\n                // any other subsequence that has ended at i. This increases the subsequence ending at j\\n                // by just 1 hence the addition.\\n                if(tracker[i] < tracker[j]+1){\\n                    // we update longest subsequence ending at i\\n                    tracker[i] = tracker[j]  + 1;\\n                    \\n                    // The new longest subsequence length is created by any and every path that could have\\n                    // ended at the jth index. Hence we set i\\'s frequency same as j.\\n                    frequency[i] = frequency[j];\\n                } else if(tracker[i] === tracker[j]  + 1){\\n\\n                    // CASE 2: This means this is not the first time we found a j that helps make the\\n                    // longest subsequence ending at i. Since length of subsequence itself didn\\'t change,\\n                    // no updates have to be made to the tracker array.\\n                    \\n                    // But this still needs to be tracked in our frequency array. So we add frequency of\\n                    // all longest subsequences that end at j to our frequency tracker for i.\\n                    frequency[i] += frequency[j];\\n                }\\n            }\\n        }\\n    }\\n    \\n    // FINALLY: \\n    // 1. We find the longest path we ever saw using our tracker array\\n    const longestPath = Math.max(...tracker);\\n    \\n    // 2. For each index/element that had the longest path end at it, we add it\\'s frequency to our \\n    // overall result\\n    let result = 0;\\n    for(let k = 0; k < nums.length; k++){\\n        if(tracker[k] === longestPath) result += frequency[k];\\n    }\\n    \\n    return result;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar findNumberOfLIS = function(nums) {\\n    // We initialize an array named \"tracker\" to track the longest increasing subsequence ending at each\\n    // index and initialize all positions with 1 as each item in nums can be considered as subsequence in\\n    // itself.\\n    let tracker = new Array(nums.length).fill(1);\\n    \\n    \\n    // While tracking, we will realize that at times there is more than one set of preceding items in nums\\n    // that can make the longest increasing subsequence that end at the index we are currently processing.\\n    // The best way to track this is in a seperate array called frequency. Each element will here is\\n    // initialized to 1. This signifies that initially, there can only be a single longest\\n    // subsequence ending at any index.\\n    let frequency = new Array(nums.length).fill(1);\\n    \\n    // Now let\\'s start processing from left to right, starting with the second element at index 1\\n    // Skipping first element as we cannot find a subsequence longer than 1 that can end at index 0.\\n    for(let i = 0; i < nums.length; i++){\\n        // Now let\\'s compare it with every element before it\\n        for(let j = 0; j < i; j++){\\n\\n            // VERIFY: Quick verification that j can be a part of a strictly increasing subsequence ending\\n            // at i\\n            if(nums[j] < nums[i]){\\n\\n                // CASE 1: Is Connecting i to the subsequence ending at j makes a subsequence larger that\\n                // any other subsequence that has ended at i. This increases the subsequence ending at j\\n                // by just 1 hence the addition.\\n                if(tracker[i] < tracker[j]+1){\\n                    // we update longest subsequence ending at i\\n                    tracker[i] = tracker[j]  + 1;\\n                    \\n                    // The new longest subsequence length is created by any and every path that could have\\n                    // ended at the jth index. Hence we set i\\'s frequency same as j.\\n                    frequency[i] = frequency[j];\\n                } else if(tracker[i] === tracker[j]  + 1){\\n\\n                    // CASE 2: This means this is not the first time we found a j that helps make the\\n                    // longest subsequence ending at i. Since length of subsequence itself didn\\'t change,\\n                    // no updates have to be made to the tracker array.\\n                    \\n                    // But this still needs to be tracked in our frequency array. So we add frequency of\\n                    // all longest subsequences that end at j to our frequency tracker for i.\\n                    frequency[i] += frequency[j];\\n                }\\n            }\\n        }\\n    }\\n    \\n    // FINALLY: \\n    // 1. We find the longest path we ever saw using our tracker array\\n    const longestPath = Math.max(...tracker);\\n    \\n    // 2. For each index/element that had the longest path end at it, we add it\\'s frequency to our \\n    // overall result\\n    let result = 0;\\n    for(let k = 0; k < nums.length; k++){\\n        if(tracker[k] === longestPath) result += frequency[k];\\n    }\\n    \\n    return result;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107302,
                "title": "python-dp-solution",
                "content": "```\\ndef findNumberOfLIS(nums):\\n    # dp solution, 2 arrays\\n    # length[i] stores the longest length ending at nums[i]\\n    # count[i] counts the number of paths with length length[i]\\n\\n    if not nums:\\n        return 0\\n\\n    n = len(nums)\\n    length = [1] * n\\n    count  = [1] * n\\n\\n    for i in range(1, n):\\n        for j in range(i):\\n            if nums[i] > nums[j]:\\n                # length[i] = max(length[j]+1, length[i]) \\n                # but we need to compute count also\\n                if length[i] == length[j]:\\n                    length[i] = length[j]+1\\n                    count[i]  = count[j]\\n                elif length[i] == length[j]+1:\\n                    count[i] += count[j]\\n\\n    maxLength = max(length)\\n    return sum([count[i] for i in range(n) if length[i] == maxLength])\\n```",
                "solutionTags": [],
                "code": "```\\ndef findNumberOfLIS(nums):\\n    # dp solution, 2 arrays\\n    # length[i] stores the longest length ending at nums[i]\\n    # count[i] counts the number of paths with length length[i]\\n\\n    if not nums:\\n        return 0\\n\\n    n = len(nums)\\n    length = [1] * n\\n    count  = [1] * n\\n\\n    for i in range(1, n):\\n        for j in range(i):\\n            if nums[i] > nums[j]:\\n                # length[i] = max(length[j]+1, length[i]) \\n                # but we need to compute count also\\n                if length[i] == length[j]:\\n                    length[i] = length[j]+1\\n                    count[i]  = count[j]\\n                elif length[i] == length[j]+1:\\n                    count[i] += count[j]\\n\\n    maxLength = max(length)\\n    return sum([count[i] for i in range(n) if length[i] == maxLength])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3794724,
                "title": "lis-beats-99-with-single-array-easy-to-understand-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDp lis standard problem.But,here Here we are also storing how many longest increasing subsequence is present at particular index at last we are iterating all over the frequency array (fq) and counting the how many inceasing subsequence is of max size .\\n\\nps: You can also use one array of pair instead of two array.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/NlKS8wFiWHE\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n\\n1. Initialize the necessary variables:\\n   - `n`: The size of the input vector `nums`.\\n   - `lisfq`: A vector of pairs, where each pair represents the length of the LIS ending at the index `i` (first element) and the count of such LIS (second element).\\n   - Initialize the first element of `lisfq` at index 0 with 1 as the LIS ending at index 0 with length 1 is just the element itself, and the count is 1.\\n   - Initialize `lo` (longest LIS length found so far) with 1.\\n\\n2. Iterate through the elements of the input vector `nums` starting from index 1.\\n   - For each element at index `i`, initialize `mx` to 0 (maximum LIS length found so far) and `c` to 1 (count of LIS ending at index `i`).\\n   - Compare the current element with all the elements before it (from index 0 to index `i - 1`).\\n   - If an element at index `j` is smaller than the element at index `i`, check if the LIS ending at index `j` has a longer length (`lisfq[j].first > mx`). If it does, update `mx` and `c` accordingly.\\n   - If the LIS ending at index `j` has the same length as the current maximum (`lisfq[j].first == mx`), add its count `lisfq[j].second` to `c`.\\n\\n3. Update `lisfq[i]` with the found maximum length `mx + 1` and the count `c`. This represents the LIS ending at index `i`.\\n\\n4. Update the longest LIS length found so far (`lo`) if the LIS ending at index `i` has a longer length.\\n\\n5. After iterating through all elements, we have `lo`, the length of the longest LIS found in the entire vector.\\n\\n6. Finally, iterate through the `lisfq` vector again and count the number of LIS that have a length equal to `lo`. Accumulate the counts to get the total number of longest increasing subsequences.\\n\\n7. Return the total count, which represents the number of longest increasing subsequences in the given vector.\\n\\nThe approach utilizes dynamic programming to efficiently calculate the length and count of LIS for each index in the vector `nums`. By doing so, the algorithm avoids redundant calculations and provides an optimal solution to the problem.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code 1(Single Array)\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<pair<int,int>>lisfq(n);\\n        lisfq[0].first=1;\\n        lisfq[0].second=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lisfq[j].first>mx){\\n                        mx=lisfq[j].first;\\n                        c=lisfq[j].second;\\n                    }\\n                    else if(lisfq[j].first==mx){\\n                      c=c+lisfq[j].second;\\n                    }\\n                }\\n            }\\n           lisfq[i].second=c;\\n            lisfq[i].first=mx+1;\\n            if(lo<lisfq[i].first){\\n               lo=lisfq[i].first; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lisfq[i].first==lo){\\n                count+=lisfq[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The solution uses two arrays, `lis` and `fq`, to keep track of the length of the longest increasing subsequence ending at each index and the count of such subsequences respectively.\\n\\n2. Initialize the `lis` array with all elements set to 0, and set the first element of `lis` and `fq` to 1 since the LIS for a single element is always 1, and there is one such subsequence.\\n\\n3. Iterate through the `nums` vector from index 1 to the end:\\n\\n   a. For each element at index `i`, find the maximum length of the LIS ending at index `i` and store it in `lis[i]`. Also, keep track of the count of such LIS in the `fq[i]` array.\\n\\n   b. To find `lis[i]` and `fq[i]`, loop through the elements before index `i` (j varies from 0 to `i-1`):\\n\\n      - If the element at index `j` is less than the element at index `i`, it means we can form a longer LIS ending at index `i` by appending the element at index `i` to the LIS ending at index `j`.\\n      \\n      - Update `lis[i]` and `fq[i]` based on the maximum LIS found so far and the count of LIS ending at index `j`.\\n\\n      - If the LIS ending at index `j` has the same length as the current maximum (`lis[j] == mx`), update the count of LIS ending at index `i` by adding the count of LIS ending at index `j`.\\n\\n4. After the iteration, the variable `lo` will store the length of the longest increasing subsequence present in the given vector `nums`.\\n\\n5. Iterate through the `lis` array again to find the count of LIS with length `lo`, and accumulate the count in the `count` variable.\\n\\n6. Return the value of `count` as the final result, representing the number of Longest Increasing Subsequences in the input vector.\\n\\nOverall, the solution uses dynamic programming to efficiently compute the count of Longest Increasing Subsequences. It finds the length of the LIS and its count for each element in the `nums` vector, and then calculates the total count of the longest increasing subsequences with the maximum length. \\n\\n# Code 2\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<int>lis(n,0),fq(n,0);\\n        lis[0]=1;\\n        fq[0]=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[j]>mx){\\n                        mx=lis[j];\\n                        c=fq[j];\\n                    }\\n                    else if(lis[j]==mx){\\n                      c=c+fq[j];\\n                    }\\n                }\\n            }\\n           fq[i]=c;\\n            lis[i]=mx+1;\\n            if(lo<lis[i]){\\n               lo=lis[i]; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lis[i]==lo){\\n                count+=fq[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        int[] fq = new int[n];\\n        lis[0] = 1;\\n        fq[0] = 1;\\n        int lo = 1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int mx = 0;\\n            int c = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (lis[j] > mx) {\\n                        mx = lis[j];\\n                        c = fq[j];\\n                    } else if (lis[j] == mx) {\\n                        c += fq[j];\\n                    }\\n                }\\n            }\\n            fq[i] = c;\\n            lis[i] = mx + 1;\\n            if (lo < lis[i]) {\\n                lo = lis[i];\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (lis[i] == lo) {\\n                count += fq[i];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        n = len(nums)\\n        lis = [0] * n\\n        fq = [0] * n\\n        lis[0] = 1\\n        fq[0] = 1\\n        lo = 1\\n\\n        for i in range(1, len(nums)):\\n            mx = 0\\n            c = 1\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if lis[j] > mx:\\n                        mx = lis[j]\\n                        c = fq[j]\\n                    elif lis[j] == mx:\\n                        c += fq[j]\\n            fq[i] = c\\n            lis[i] = mx + 1\\n            if lo < lis[i]:\\n                lo = lis[i]\\n\\n        count = 0\\n        for i in range(len(nums)):\\n            if lis[i] == lo:\\n                count += fq[i]\\n\\n        return count\\n\\n```\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<pair<int,int>>lisfq(n);\\n        lisfq[0].first=1;\\n        lisfq[0].second=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lisfq[j].first>mx){\\n                        mx=lisfq[j].first;\\n                        c=lisfq[j].second;\\n                    }\\n                    else if(lisfq[j].first==mx){\\n                      c=c+lisfq[j].second;\\n                    }\\n                }\\n            }\\n           lisfq[i].second=c;\\n            lisfq[i].first=mx+1;\\n            if(lo<lisfq[i].first){\\n               lo=lisfq[i].first; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lisfq[i].first==lo){\\n                count+=lisfq[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<int>lis(n,0),fq(n,0);\\n        lis[0]=1;\\n        fq[0]=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[j]>mx){\\n                        mx=lis[j];\\n                        c=fq[j];\\n                    }\\n                    else if(lis[j]==mx){\\n                      c=c+fq[j];\\n                    }\\n                }\\n            }\\n           fq[i]=c;\\n            lis[i]=mx+1;\\n            if(lo<lis[i]){\\n               lo=lis[i]; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lis[i]==lo){\\n                count+=fq[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        int[] fq = new int[n];\\n        lis[0] = 1;\\n        fq[0] = 1;\\n        int lo = 1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int mx = 0;\\n            int c = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (lis[j] > mx) {\\n                        mx = lis[j];\\n                        c = fq[j];\\n                    } else if (lis[j] == mx) {\\n                        c += fq[j];\\n                    }\\n                }\\n            }\\n            fq[i] = c;\\n            lis[i] = mx + 1;\\n            if (lo < lis[i]) {\\n                lo = lis[i];\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (lis[i] == lo) {\\n                count += fq[i];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        n = len(nums)\\n        lis = [0] * n\\n        fq = [0] * n\\n        lis[0] = 1\\n        fq[0] = 1\\n        lo = 1\\n\\n        for i in range(1, len(nums)):\\n            mx = 0\\n            c = 1\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if lis[j] > mx:\\n                        mx = lis[j]\\n                        c = fq[j]\\n                    elif lis[j] == mx:\\n                        c += fq[j]\\n            fq[i] = c\\n            lis[i] = mx + 1\\n            if lo < lis[i]:\\n                lo = lis[i]\\n\\n        count = 0\\n        for i in range(len(nums)):\\n            if lis[i] == lo:\\n                count += fq[i]\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500880,
                "title": "java-dp-with-explanation",
                "content": "````\\n\\tpublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, max = 0; \\n        \\n        // the longest increasing subsequence that ends at i\\n        int[] len = new int[n];\\n        \\n        // the number of the longest increasing subsequence that ends at i\\n        int[] cnt = new int[n];        \\n        \\n        for (int i = 0; i < n; i++) {             \\n            for (int j = i-1; j >= 0; j--) {\\n                \\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) {\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j]+1 == len[i]) {\\n                        cnt[i] += cnt[j];    \\n                    }                                        \\n                }\\n            }\\n            \\n            // if the current nums[i] is the minimum value so far\\n            if (len[i] == 0) {\\n                len[i] = 1;\\n                cnt[i] = 1;\\n            }\\n            \\n            // update the longest length\\n            max = Math.max(max, len[i]);            \\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (len[i] == max) {\\n                res += cnt[i];\\n            }\\n        }\\n        return res;                \\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, max = 0; \\n        \\n        // the longest increasing subsequence that ends at i\\n        int[] len = new int[n];\\n        \\n        // the number of the longest increasing subsequence that ends at i\\n        int[] cnt = new int[n];        \\n        \\n        for (int i = 0; i < n; i++) {             \\n            for (int j = i-1; j >= 0; j--) {\\n                \\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) {\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j]+1 == len[i]) {\\n                        cnt[i] += cnt[j];    \\n                    }                                        \\n                }\\n            }\\n            \\n            // if the current nums[i] is the minimum value so far\\n            if (len[i] == 0) {\\n                len[i] = 1;\\n                cnt[i] = 1;\\n            }\\n            \\n            // update the longest length\\n            max = Math.max(max, len[i]);            \\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (len[i] == max) {\\n                res += cnt[i];\\n            }\\n        }\\n        return res;                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199093,
                "title": "short-python-50ms-beats-100-with-binary-search",
                "content": "the idea is basicly the same with LIS prolem, create one extra hashtable, dp[k][x]  will help us store the number of LIS  (which has a length of k) ends with number x. So each time after we found the index to replace the current number x in table by binary search just increase the number of lcs which ends with current number and has a length of index + 1 equal to sum(dp[index-1][j]  for j in dp[index-1] if j < x).\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        dp = collections.defaultdict(collections.Counter)\\n        dp[-1][-1e9] = 1\\n        table = []\\n        for i in nums:\\n            index = bisect.bisect_left(table, i)\\n            if index == len(table):\\n                table.append(i)\\n            else:\\n                table[index] = i \\n            dp[index][i] += sum(dp[index-1][j] for j in dp[index-1] if j < i)\\n        return sum(dp[max(0, len(table)-1)].values()) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        dp = collections.defaultdict(collections.Counter)\\n        dp[-1][-1e9] = 1\\n        table = []\\n        for i in nums:\\n            index = bisect.bisect_left(table, i)\\n            if index == len(table):\\n                table.append(i)\\n            else:\\n                table[index] = i \\n            dp[index][i] += sum(dp[index-1][j] for j in dp[index-1] if j < i)\\n        return sum(dp[max(0, len(table)-1)].values()) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341428,
                "title": "c-easy-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp; // dp[i]={a,b} represents that if we take ith element of nums as the last element in a increasing sequence then a is the length of the biggest sequence and there can be b such sequence of length a and last element as nums[i]\\n        dp.push_back({1,1});     //base case\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int len=0;\\n            int count=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])  // to make sure that sequence is increasing\\n                {                                         //this part can be written in more readable way .this is basically to find the maximum length subsequence and find how many such sequences are possible\\n                    if(len==dp[j].first)   //if max length we found till now is equal to current length\\n                    {\\n                        count+=dp[j].second;// we increment count( no. of combinations)\\n                    }\\n                    else if(dp[j].first>len) //if greater len is found\\n                    {\\n                        count=dp[j].second; \\n                        len=dp[j].first;         //then we set count to this seq count and len(maximum len) to its length \\n                    }\\n                }\\n            }\\n            if(count==0)//  in case we dont find any smaller element before it \\n            {\\n                dp.push_back({len+1,1});\\n            }\\n            else \\n                dp.push_back({len+1,count});\\n        }\\n        int len=0;\\n        int count=0;\\n        for(int i=0;i<dp.size();i++)// answer would be number of maximum length sequences    \\n        {\\n            if(len<dp[i].first)\\n            {\\n                len=dp[i].first;\\n                count=dp[i].second;\\n            }\\n            else if(len==dp[i].first)\\n            {\\n                count+=dp[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nAll explanation is done in comments in the code itself",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp; // dp[i]={a,b} represents that if we take ith element of nums as the last element in a increasing sequence then a is the length of the biggest sequence and there can be b such sequence of length a and last element as nums[i]\\n        dp.push_back({1,1});     //base case\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int len=0;\\n            int count=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])  // to make sure that sequence is increasing\\n                {                                         //this part can be written in more readable way .this is basically to find the maximum length subsequence and find how many such sequences are possible\\n                    if(len==dp[j].first)   //if max length we found till now is equal to current length\\n                    {\\n                        count+=dp[j].second;// we increment count( no. of combinations)\\n                    }\\n                    else if(dp[j].first>len) //if greater len is found\\n                    {\\n                        count=dp[j].second; \\n                        len=dp[j].first;         //then we set count to this seq count and len(maximum len) to its length \\n                    }\\n                }\\n            }\\n            if(count==0)//  in case we dont find any smaller element before it \\n            {\\n                dp.push_back({len+1,1});\\n            }\\n            else \\n                dp.push_back({len+1,count});\\n        }\\n        int len=0;\\n        int count=0;\\n        for(int i=0;i<dp.size();i++)// answer would be number of maximum length sequences    \\n        {\\n            if(len<dp[i].first)\\n            {\\n                len=dp[i].first;\\n                count=dp[i].second;\\n            }\\n            else if(len==dp[i].first)\\n            {\\n                count+=dp[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697315,
                "title": "java-simple-dp-solution-with-explanataion",
                "content": "A tricky problem :)\\n\\nIn LIS problem, we maintain the length of LIS at any index \\'i\\' by comparing the elements at index \\'i\\' to all the elements occuring before it(index \\'0\\' to index \\'i-1\\'). We\\'ll use the same approach for this problem too, except now we will try to maintain a count of subsequences ending with element nums[i].\\n\\nWhile you\\'re iterating over all the elements from \\'0\\' to \\'i-1\\',\\n\\nFirst check whether the addition of the current element will form a LIS or not.\\n*(This statements denotes to check condition of nums[i] > nums[j])*\\n\\nIf a LIS is forming with the inclusion of element nums[i], then only a simple problem remains - **Whether a subsequece of an equal length is already present or not.**\\n\\nTo resolve this problem, check whether you\\'ve already acheived a LIS of that length or not by simply comparing with the count[i]. \\n\\n1. If yes, the count all the subsequences that have been formed at index \\'j\\' and add them to the subsequences formed without subsequences ending at nums[j].\\n*(This statement denotes - length[j] + 1 == length[i])*\\n\\n2. If not, then count all the subsequences formed with the subsequences ending at nums[j]\\n*(This statement denotes - length[j] + 1 > length[i])*\\n\\nOnce you have this much data, simply find the length of longest LIS and then find all the subsequences of that length and adding thier count.\\n\\nA rough explanation can be found at this video - https://www.youtube.com/watch?v=2m0NxgW2_pc\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int N = nums.length;\\n\\n        int[] length = new int[N];\\n        int[] count = new int[N];\\n        \\n        Arrays.fill(length,1);//each number is a subsequence\\n        Arrays.fill(count,1);//since each number is a subsequence, the LIS for a single element array is 1\\n\\n        for(int i = 1 ; i < nums.length; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j]){\\n                    if(1 + length[j] > length[i]){\\n                        length[i] = 1 + length[j];\\n                        count[i] = count[j];\\n                    }else if(1 + length[j] == length[i]){\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i: length){\\n            max = Math.max(i,max);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < N; ++i){\\n            if(length[i] == max){\\n                ans += count[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int N = nums.length;\\n\\n        int[] length = new int[N];\\n        int[] count = new int[N];\\n        \\n        Arrays.fill(length,1);//each number is a subsequence\\n        Arrays.fill(count,1);//since each number is a subsequence, the LIS for a single element array is 1\\n\\n        for(int i = 1 ; i < nums.length; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j]){\\n                    if(1 + length[j] > length[i]){\\n                        length[i] = 1 + length[j];\\n                        count[i] = count[j];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3795225,
                "title": "simple-c-memoization-recursion-code-lis-variant-commented-dp",
                "content": "**Simple C++ Memoization+Recursion**\\n\\nUpvote if you like my Solution... ;)\\n```\\nclass Solution\\n{\\n    public:\\n\\n pair<int, int> f(vector<int>& nums, int i, int prev,vector<vector<pair<int, int>>>& dp) {\\n    if (i >= nums.size())\\n        return {0, 1}; // The length of LIS is 0, and there is one such LIS (an empty LIS).\\n\\n    if (dp[prev + 1][i].first != -1)\\n        return dp[prev + 1][i];\\n     \\n//    in this qn. we are storing in \\'a\\' is by taking that value and storing the length of the subsequence in a.first\\n     // and storing the frequency of that suseq. in a.second\\n     \\n//   and \\'b\\' is storing the then length of subseq. in b.first and freq. of that subseq. in b.second by not taking that value (means by skipping) ... \\n\\n    std::pair<int, int> a = {0, 0}, b = {0, 0};\\n\\n    if (prev == -1 || nums[i] > nums[prev]) {\\n        a = f(nums, i + 1, i, dp);\\n        a.first++;\\n    }\\n\\n    b = f(nums, i + 1, prev, dp);\\n     \\n     \\n//   in this condn. if my length of longest subseq. by taking ele. and not taking that ele. are equal then we just add up the freq.   \\n    if (a.first == b.first) {\\n        dp[prev + 1][i] = {a.first, a.second + b.second};\\n    }\\n//   if a has longest subseq. lenght then we take a   \\n     else if (a.first > b.first) {\\n        dp[prev + 1][i] = a;\\n    } else {\\n        dp[prev + 1][i] = b;\\n    }\\n\\n    return dp[prev + 1][i];\\n}\\n\\nint findNumberOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(n, {-1, -1}));\\n\\n    return f(nums, 0, -1, dp).second;\\n}\\n\\n   \\n    \\n    \\n\\n\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3155f22d-f957-49bb-9d23-ff276e1e3a08_1689926729.3244627.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n\\n pair<int, int> f(vector<int>& nums, int i, int prev,vector<vector<pair<int, int>>>& dp) {\\n    if (i >= nums.size())\\n        return {0, 1}; // The length of LIS is 0, and there is one such LIS (an empty LIS).\\n\\n    if (dp[prev + 1][i].first != -1)\\n        return dp[prev + 1][i];\\n     \\n//    in this qn. we are storing in \\'a\\' is by taking that value and storing the length of the subsequence in a.first\\n     // and storing the frequency of that suseq. in a.second\\n     \\n//   and \\'b\\' is storing the then length of subseq. in b.first and freq. of that subseq. in b.second by not taking that value (means by skipping) ... \\n\\n    std::pair<int, int> a = {0, 0}, b = {0, 0};\\n\\n    if (prev == -1 || nums[i] > nums[prev]) {\\n        a = f(nums, i + 1, i, dp);\\n        a.first++;\\n    }\\n\\n    b = f(nums, i + 1, prev, dp);\\n     \\n     \\n//   in this condn. if my length of longest subseq. by taking ele. and not taking that ele. are equal then we just add up the freq.   \\n    if (a.first == b.first) {\\n        dp[prev + 1][i] = {a.first, a.second + b.second};\\n    }\\n//   if a has longest subseq. lenght then we take a   \\n     else if (a.first > b.first) {\\n        dp[prev + 1][i] = a;\\n    } else {\\n        dp[prev + 1][i] = b;\\n    }\\n\\n    return dp[prev + 1][i];\\n}\\n\\nint findNumberOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(n, {-1, -1}));\\n\\n    return f(nums, 0, -1, dp).second;\\n}\\n\\n   \\n    \\n    \\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639132,
                "title": "c-dp-lis-variant-using-pair-of-count-and-length",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n         /* count and length */\\n        vector<pair<int, int>>LIS(n, {1, 1}); \\n        int maxlen = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (LIS[i].second == 1 + LIS[j].second) {\\n                        LIS[i].first += LIS[j].first;\\n                    } else if (LIS[i].second < 1 + LIS[j].second) {\\n                        LIS[i].first = LIS[j].first;\\n                        LIS[i].second = 1 + LIS[j].second;\\n                    }\\n                }\\n            }\\n            maxlen = max(maxlen, LIS[i].second);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (LIS[i].second == maxlen)\\n                ans += LIS[i].first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n         /* count and length */\\n        vector<pair<int, int>>LIS(n, {1, 1}); \\n        int maxlen = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (LIS[i].second == 1 + LIS[j].second) {\\n                        LIS[i].first += LIS[j].first;\\n                    } else if (LIS[i].second < 1 + LIS[j].second) {\\n                        LIS[i].first = LIS[j].first;\\n                        LIS[i].second = 1 + LIS[j].second;\\n                    }\\n                }\\n            }\\n            maxlen = max(maxlen, LIS[i].second);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (LIS[i].second == maxlen)\\n                ans += LIS[i].first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228019,
                "title": "c-sorting-and-segment-tree-solution-with-explanation",
                "content": "```\\n/*Preparation:\\nfor example, nums={1, 3, 5, 4, 7}\\nFor every index i of nums, we will consider the longest increasing subsequence(LIS) up to nums[i].\\nWe will capture (1) number of these LISs up to nums[i], and (2) there length. Let \\n    acc[i] = largest accumulated length of an increasing sequence up to nums[i]\\n    ways[i] = number of ways getting a LIS up to nums[i]\\n\\nIn the above case, \\n    {1(acc=1, ways=1), 3(acc=2, ways=1), 5(acc=3, ways=1), 4(acc=3, ways=1), 7(acc=4, ways=2)}\\nFinding number of LIS in this problem would mean finding the maximal \"acc\", \\nand then return its total \"ways\" as answer\\n*/\\n\\n/*Using segment tree to solve for acc\\'s and ways\\'s\\ne.g. nums={1, 3, 5, 2 ,4, 7}\\nsort nums in ascending order => v={1, 2, 3, 4, 5, 7}\\nthe new index of nums[i] is given by indexMap={0, 2, 4, 1, 3, 5}\\n\\ncreate a segment tree (sgTree) of vector v.\\nA leaf node of sgTree captures the pair (acc, ways) of the number v[j].\\nAn interior node tree[x] has two children, tree[2*x] and tree[2*x+1].\\n    if the acc\\'s of tree[2*x] and tree[2*x+1] differ from the other, \\n    tree[x]= (larger acc, the corresponding ways) between tree[2*x] & tree[2*x+1],\\n    since only the longest LIS\\'s concern us.\\n    \\n    if (tree[2*x].first==tree[2*x+1]), we get to tree[x]=(acc[2*x], ways[2*x]+ways[2*x+1])\\n    since number of ways would add up in this case\\n    \\n(i=0) sgTree is of nodes written in (acc/ways) as in the following diagram.\\nFrom left to right, each leaf node represents an entry v[i] of vector v.\\n\\n                  (0/0)\\n               /         \\\\\\n            (0/0)        (0/0)\\n             /  \\\\         /  \\\\\\n         (0/0)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (0/0)   (0/0)  (0/0)  (0/0)\\n\\nx=nums[0]=1=v[0] => acc/ways=1/1. We update the first leaf node (j=0):\\n\\n                  (1/1)\\n               /         \\\\\\n            (1/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n\\n--------------------------------------------------------------------------------\\n(i=1) x=nums[1]=3=v[2]\\nTo find acc/ways of nums[1], we consider all visited previous leaf nodes of value<x.\\nSo, acc = maximum acc[j] of these leaf nodes,\\nways = sum of ways[j]\\'s of leaf nodes having the maximal acc[j] (as above).\\nIn practice, we trace from the root of sgTree following these principles:\\n\\n(1) when tree[x] represents the range [left, right] of v,\\nif v[right]<x, then every leaf node in [left, right] is of value<x\\n=> take tree[x]=(acc[x], ways[x]) into consideration directly\\n\\n(2) the children of tree[x] are tree[2*x] and tree[2*x+1], \\nrepresenting the ranges [left,mid] and [mid+1,right] respectively.\\nIf (x<=v[mid]), we pass to tree[2*x] directly\\nif (x>v[mid]), every leaf node under tree[2*x] is of value<x\\n    so we have to look at tree[2*x]=(acc[2*x], ways[2*x])\\n    and then compare it with what we get from query at tree[2*x+1].\\n\\nin this case, x=3 means that we look at ...\\n    the range [0,1]: tree[x] = (1, 1)\\n=> acc=1+1, ways=1 (i.e. {1,3})=> update the 3rd leaf node (j=2) by 2/1:\\n\\n                  (2/1)\\n               /         \\\\\\n            (2/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=2) x=5=nums[2]=v[4]\\nquery: v[2]=3<x => range [0,2]: tree[x]=(2, 1)\\n       v[3]=4<x => range [3]: tree[x]=(0, 0) \\n=> acc=3, ways=1, i.e. {1,3,5}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/1)        (3/1)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=3) x=2=nums[3]=v[1]\\nquery: v[0]=1<x => range [0]: tree[x]=(1,1)\\n=> acc=2, ways=1, i.e. {1,2}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/2)        (3/1)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=4) x=4=nums[4]=v[3]\\nquery: v[2]=3<4 => range [0,2]: tree[x]=(2, 2)\\n=> acc=3, ways=2, i.e. {1,2,4} and {1,3,4}\\nupdate:\\n                  (3/3)\\n               /         \\\\\\n            (2/2)        (3/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n\\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=5) x=7=nums[5]=v[5]\\nquery: v[2]=3<7 => range [0,2]: tree[x]=(2,2)\\nquery: v[4]=5<7 => range [3,4]: tree[x]=(3,3)\\n=> acc=4, ways=3, i.e. {1,3,4,7}, {1,2,4,7}, {1,3,5,7}\\nupdate: \\n                  (4/3)\\n               /         \\\\\\n            (2/2)        (4/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (4/3)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n--------------------------------------------------------------------------------\\n\\nreturn the information of tree[1] as result\\n*/\\n\\nstruct segmentTree{\\n    std::vector<std::pair<int,int>> tree;\\n    //tree[x] = {acc[x], ways[x]}\\n    std::vector<int> u;\\n    int N;\\n    segmentTree(std::vector<int>& v){\\n        N = v.size();\\n        tree.resize(4*N, std::pair<int,int>(0,0));\\n        for (int i=0; i<N; i++)\\n            u.push_back(v[i]);\\n        return;\\n    }\\n    \\n    void update(int x, int left, int right, int index, int acc, int ways){\\n        if (left==right){\\n            tree[x].first = acc;\\n            tree[x].second = ways;\\n            return;\\n        }\\n        int mid = (left+right)/2;\\n        if (index<=mid){\\n            update(2*x, left, mid, index, acc, ways);\\n        }else{\\n            update(2*x+1, mid+1, right, index, acc, ways);\\n        }\\n        if (tree[2*x].first>tree[2*x+1].first){\\n            tree[x] = tree[2*x];\\n        }else if (tree[2*x+1].first>tree[2*x].first){\\n            tree[x] = tree[2*x+1];\\n        }else{\\n            tree[x].first = tree[2*x].first;\\n            tree[x].second = tree[2*x].second + tree[2*x+1].second;\\n        }\\n        return;\\n    }\\n    \\n    std::pair<int,int> query(int x, int left, int right, int value){\\n        if (u[right]<value){\\n            return tree[x];\\n        }\\n        if (value<=u[left]){\\n            return std::pair<int,int>(0,0);\\n        }\\n        \\n        int mid = (left+right)/2;\\n        std::pair<int, int> temp;\\n        std::pair<int, int> result;\\n        \\n        if (value<=u[mid]){\\n            result = query(2*x, left, mid, value);\\n            \\n        }else{\\n            temp = query(2*x+1, mid+1, right, value);\\n            if (temp.first>tree[2*x].first){\\n                result.first = temp.first;\\n                result.second = temp.second;\\n                \\n            }else if (tree[2*x].first>temp.first){\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second;\\n            \\n            }else{\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second + temp.second;\\n            }\\n        }        \\n        return result;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        std::vector<std::pair<int,int>> numsPair;\\n        std::vector<int> indexMap(n, 0);\\n        std::vector<int> v(n, 0);\\n        for (int i=0; i<n; i++){\\n            numsPair.push_back(std::make_pair(nums[i], i));\\n        }\\n        std::sort(numsPair.begin(), numsPair.end());\\n        for (int j=0; j<n; j++){\\n            v[j] = numsPair[j].first;\\n            indexMap[numsPair[j].second] = j;\\n        }\\n        \\n        segmentTree sgTree = segmentTree(v);\\n        std::pair<int, int> myPair;\\n        int acc, ways;\\n        // i=0\\n        sgTree.update(1, 0, n-1, indexMap[0], 1, 1);\\n        \\n        for (int i=1; i<n; i++){\\n            myPair = sgTree.query(1, 0, n-1, nums[i]);\\n            acc = myPair.first+1;\\n            ways = std::max(1, myPair.second);\\n            //std::cout<<\"acc=\"<<acc<<\", ways=\"<<ways<<\"\\\\n\";\\n            sgTree.update(1, 0, n-1, indexMap[i], acc, ways);\\n        }\\n        \\n        //std::cout<<\"(\"<<sgTree.tree[1].first<<\", \"<<sgTree.tree[1].second<<\")\\\\n\";\\n        return sgTree.tree[1].second;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\n/*Preparation:\\nfor example, nums={1, 3, 5, 4, 7}\\nFor every index i of nums, we will consider the longest increasing subsequence(LIS) up to nums[i].\\nWe will capture (1) number of these LISs up to nums[i], and (2) there length. Let \\n    acc[i] = largest accumulated length of an increasing sequence up to nums[i]\\n    ways[i] = number of ways getting a LIS up to nums[i]\\n\\nIn the above case, \\n    {1(acc=1, ways=1), 3(acc=2, ways=1), 5(acc=3, ways=1), 4(acc=3, ways=1), 7(acc=4, ways=2)}\\nFinding number of LIS in this problem would mean finding the maximal \"acc\", \\nand then return its total \"ways\" as answer\\n*/\\n\\n/*Using segment tree to solve for acc\\'s and ways\\'s\\ne.g. nums={1, 3, 5, 2 ,4, 7}\\nsort nums in ascending order => v={1, 2, 3, 4, 5, 7}\\nthe new index of nums[i] is given by indexMap={0, 2, 4, 1, 3, 5}\\n\\ncreate a segment tree (sgTree) of vector v.\\nA leaf node of sgTree captures the pair (acc, ways) of the number v[j].\\nAn interior node tree[x] has two children, tree[2*x] and tree[2*x+1].\\n    if the acc\\'s of tree[2*x] and tree[2*x+1] differ from the other, \\n    tree[x]= (larger acc, the corresponding ways) between tree[2*x] & tree[2*x+1],\\n    since only the longest LIS\\'s concern us.\\n    \\n    if (tree[2*x].first==tree[2*x+1]), we get to tree[x]=(acc[2*x], ways[2*x]+ways[2*x+1])\\n    since number of ways would add up in this case\\n    \\n(i=0) sgTree is of nodes written in (acc/ways) as in the following diagram.\\nFrom left to right, each leaf node represents an entry v[i] of vector v.\\n\\n                  (0/0)\\n               /         \\\\\\n            (0/0)        (0/0)\\n             /  \\\\         /  \\\\\\n         (0/0)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (0/0)   (0/0)  (0/0)  (0/0)\\n\\nx=nums[0]=1=v[0] => acc/ways=1/1. We update the first leaf node (j=0):\\n\\n                  (1/1)\\n               /         \\\\\\n            (1/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n\\n--------------------------------------------------------------------------------\\n(i=1) x=nums[1]=3=v[2]\\nTo find acc/ways of nums[1], we consider all visited previous leaf nodes of value<x.\\nSo, acc = maximum acc[j] of these leaf nodes,\\nways = sum of ways[j]\\'s of leaf nodes having the maximal acc[j] (as above).\\nIn practice, we trace from the root of sgTree following these principles:\\n\\n(1) when tree[x] represents the range [left, right] of v,\\nif v[right]<x, then every leaf node in [left, right] is of value<x\\n=> take tree[x]=(acc[x], ways[x]) into consideration directly\\n\\n(2) the children of tree[x] are tree[2*x] and tree[2*x+1], \\nrepresenting the ranges [left,mid] and [mid+1,right] respectively.\\nIf (x<=v[mid]), we pass to tree[2*x] directly\\nif (x>v[mid]), every leaf node under tree[2*x] is of value<x\\n    so we have to look at tree[2*x]=(acc[2*x], ways[2*x])\\n    and then compare it with what we get from query at tree[2*x+1].\\n\\nin this case, x=3 means that we look at ...\\n    the range [0,1]: tree[x] = (1, 1)\\n=> acc=1+1, ways=1 (i.e. {1,3})=> update the 3rd leaf node (j=2) by 2/1:\\n\\n                  (2/1)\\n               /         \\\\\\n            (2/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=2) x=5=nums[2]=v[4]\\nquery: v[2]=3<x => range [0,2]: tree[x]=(2, 1)\\n       v[3]=4<x => range [3]: tree[x]=(0, 0) \\n=> acc=3, ways=1, i.e. {1,3,5}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/1)        (3/1)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=3) x=2=nums[3]=v[1]\\nquery: v[0]=1<x => range [0]: tree[x]=(1,1)\\n=> acc=2, ways=1, i.e. {1,2}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/2)        (3/1)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=4) x=4=nums[4]=v[3]\\nquery: v[2]=3<4 => range [0,2]: tree[x]=(2, 2)\\n=> acc=3, ways=2, i.e. {1,2,4} and {1,3,4}\\nupdate:\\n                  (3/3)\\n               /         \\\\\\n            (2/2)        (3/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n\\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=5) x=7=nums[5]=v[5]\\nquery: v[2]=3<7 => range [0,2]: tree[x]=(2,2)\\nquery: v[4]=5<7 => range [3,4]: tree[x]=(3,3)\\n=> acc=4, ways=3, i.e. {1,3,4,7}, {1,2,4,7}, {1,3,5,7}\\nupdate: \\n                  (4/3)\\n               /         \\\\\\n            (2/2)        (4/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (4/3)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n--------------------------------------------------------------------------------\\n\\nreturn the information of tree[1] as result\\n*/\\n\\nstruct segmentTree{\\n    std::vector<std::pair<int,int>> tree;\\n    //tree[x] = {acc[x], ways[x]}\\n    std::vector<int> u;\\n    int N;\\n    segmentTree(std::vector<int>& v){\\n        N = v.size();\\n        tree.resize(4*N, std::pair<int,int>(0,0));\\n        for (int i=0; i<N; i++)\\n            u.push_back(v[i]);\\n        return;\\n    }\\n    \\n    void update(int x, int left, int right, int index, int acc, int ways){\\n        if (left==right){\\n            tree[x].first = acc;\\n            tree[x].second = ways;\\n            return;\\n        }\\n        int mid = (left+right)/2;\\n        if (index<=mid){\\n            update(2*x, left, mid, index, acc, ways);\\n        }else{\\n            update(2*x+1, mid+1, right, index, acc, ways);\\n        }\\n        if (tree[2*x].first>tree[2*x+1].first){\\n            tree[x] = tree[2*x];\\n        }else if (tree[2*x+1].first>tree[2*x].first){\\n            tree[x] = tree[2*x+1];\\n        }else{\\n            tree[x].first = tree[2*x].first;\\n            tree[x].second = tree[2*x].second + tree[2*x+1].second;\\n        }\\n        return;\\n    }\\n    \\n    std::pair<int,int> query(int x, int left, int right, int value){\\n        if (u[right]<value){\\n            return tree[x];\\n        }\\n        if (value<=u[left]){\\n            return std::pair<int,int>(0,0);\\n        }\\n        \\n        int mid = (left+right)/2;\\n        std::pair<int, int> temp;\\n        std::pair<int, int> result;\\n        \\n        if (value<=u[mid]){\\n            result = query(2*x, left, mid, value);\\n            \\n        }else{\\n            temp = query(2*x+1, mid+1, right, value);\\n            if (temp.first>tree[2*x].first){\\n                result.first = temp.first;\\n                result.second = temp.second;\\n                \\n            }else if (tree[2*x].first>temp.first){\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second;\\n            \\n            }else{\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second + temp.second;\\n            }\\n        }        \\n        return result;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        std::vector<std::pair<int,int>> numsPair;\\n        std::vector<int> indexMap(n, 0);\\n        std::vector<int> v(n, 0);\\n        for (int i=0; i<n; i++){\\n            numsPair.push_back(std::make_pair(nums[i], i));\\n        }\\n        std::sort(numsPair.begin(), numsPair.end());\\n        for (int j=0; j<n; j++){\\n            v[j] = numsPair[j].first;\\n            indexMap[numsPair[j].second] = j;\\n        }\\n        \\n        segmentTree sgTree = segmentTree(v);\\n        std::pair<int, int> myPair;\\n        int acc, ways;\\n        // i=0\\n        sgTree.update(1, 0, n-1, indexMap[0], 1, 1);\\n        \\n        for (int i=1; i<n; i++){\\n            myPair = sgTree.query(1, 0, n-1, nums[i]);\\n            acc = myPair.first+1;\\n            ways = std::max(1, myPair.second);\\n            //std::cout<<\"acc=\"<<acc<<\", ways=\"<<ways<<\"\\\\n\";\\n            sgTree.update(1, 0, n-1, indexMap[i], acc, ways);\\n        }\\n        \\n        //std::cout<<\"(\"<<sgTree.tree[1].first<<\", \"<<sgTree.tree[1].second<<\")\\\\n\";\\n        return sgTree.tree[1].second;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 917456,
                "title": "python-dp-memo",
                "content": "\\uD83D\\uDEA8 It\\'s not a fast enough solution. (But at least it\\'s easy for me to explain and implement in an interview.)\\n\\nThe idea is similar to [another bottom-up DP solution](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107303/python-DP-solution-with-DETAILED-explanation). We need to keep track **length** and **times**. **length** is the same as [LIS](https://leetcode.com/problems/longest-increasing-subsequence/). In addition, we need to track **times**, everytime we meet at the same length from both take and not take, we combine their times.\\n\\nFor example, for case `[1,3,6,8,4,5]`, when traversing to 3...\\n* if taking 6, it ends to be also taking 8 and done with length 2 (from 3\\'s pseceptive).\\n* if not taking 6, it ends to be not taking 8 but taking 4 and 5 with length 2 too.\\nSince the length is same, we combine the **times** of `[6, 8]` and `[4, 5]` for 3.\\n\\n```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def helper(self, idx, hold):\\n        if idx == len(self.nums):\\n            return 0, 1\\n        elif hold is None or hold < self.nums[idx]:\\n            # take\\n            length1, times1 = self.helper(idx+1, self.nums[idx])\\n            length1 += 1\\n            \\n            # not take\\n            length2, times2 = self.helper(idx+1, hold)\\n            \\n            # if both take and not take are same length, pick both\\n            # otherwise, pick the longer LIS one\\n            if length1 == length2:\\n                return length2, times1 + times2\\n            elif length1 > length2:\\n                return length1, times1\\n            else:\\n                return length2, times2\\n        else:\\n            return self.helper(idx+1, hold)\\n    \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0  # special case, no LIS\\n        self.nums = nums\\n        return self.helper(0, None)[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def helper(self, idx, hold):\\n        if idx == len(self.nums):\\n            return 0, 1\\n        elif hold is None or hold < self.nums[idx]:\\n            # take\\n            length1, times1 = self.helper(idx+1, self.nums[idx])\\n            length1 += 1\\n            \\n            # not take\\n            length2, times2 = self.helper(idx+1, hold)\\n            \\n            # if both take and not take are same length, pick both\\n            # otherwise, pick the longer LIS one\\n            if length1 == length2:\\n                return length2, times1 + times2\\n            elif length1 > length2:\\n                return length1, times1\\n            else:\\n                return length2, times2\\n        else:\\n            return self.helper(idx+1, hold)\\n    \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0  # special case, no LIS\\n        self.nums = nums\\n        return self.helper(0, None)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470089,
                "title": "java-7ms-beats-99-83-tc-o-nlogn-sc-o-n-dp-binary-search-prefix-sums",
                "content": "# Why this work\\nDon\\'t ask me(Built on top of nlogn solution of problem 300):\\n[[Python] Short O(n log n) solution, beats 100%, explained](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/916196/Python-Short-O(n-log-n)-solution-beats-100-explained)\\n[9ms [C++] Explanation: DP + Binary search + prefix sums O(NlogN) time; O(N) space](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107295/9ms-C%2B%2B-Explanation%3A-DP-%2B-Binary-search-%2B-prefix-sums-O(NlogN)-time-O(N)-space)\\n[Patience sorting on wikipedia](https://en.wikipedia.org/wiki/Patience_sorting)\\n\\n```java\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int n = a.length, max = 1;\\n        // need to maintain list of decks for each length\\n        // in the list we need list of ending values (bottom up descending), and its counts prefix sum (bottom up)\\n        List<List<int[]>> decks = new ArrayList<>(); // int[0]: tail value, int[1]: count\\'s prefix sum\\n\\n        // step1 push\\n        for (int i = 0; i < n; i++) {\\n            int idx4insert = bs(a[i], decks); // key logic of 300, find where I(a[i]) belongs\\n\\n            // find cnt from previous list\\n            int cnt = idx4insert == 0 ? 1 : getCount(decks.get(idx4insert-1), a[i]);\\n\\n            // create the new element\\n            int[] cur = new int[] {a[i], cnt};\\n            List<int[]> deck;\\n            if (idx4insert == decks.size()) {\\n                decks.add(deck = new ArrayList<>());\\n            } else {\\n                deck = decks.get(idx4insert); // find the right deck\\n                cur[1] += deck.get(deck.size() - 1)[1]; // [1] is prefix sum of count\\n            }\\n            deck.add(cur);\\n        }\\n\\n        // System.out.printf(\"Input Array:\\\\n%s\\\\nDecks:\\\\n%s\\\\n\", Arrays.toString(a), toString(decks));\\n\\n        var deck = decks.get(decks.size() - 1);\\n        return deck.get(deck.size() - 1)[1];\\n    }\\n\\n    private int getCount(List<int[]> deck, int x) { // in a descending order list find largest smaller (no equal) 5 4 4 3: 4        \\n        int l = 0, r = deck.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (deck.get(m)[0] >= x) l = m + 1;\\n            else r = m;\\n        }\\n        if (l == deck.size()) return 1; // first # of LIS, so count is 1;\\n        return deck.get(deck.size() - 1)[1] - (l == 0 ? 0 : deck.get(l-1)[1]);\\n    }\\n\\n    private int bs(int x, List<List<int[]>> decks) { // smallest >=, i.e. insertion index, 1 3 4 4 5: 4\\n        int l = 0, r = decks.size();\\n        while (l < r) { // find smallest larger\\n            int m = l + (r - l) / 2;\\n            var deck = decks.get(m);\\n            int cur = deck.get(deck.size() - 1)[0];\\n            if (cur < x) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n\\n    private StringBuilder toString(List<List<int[]>> decks) {\\n        return toString(decks, 1);\\n    }\\n    private StringBuilder toString(List<List<int[]>> decks, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\"[\\\\n\");\\n        for (var deck : decks)\\n            sb.append(decktosb(deck, w));\\n\\n        sb.append(\"]\\\\n\");\\n        return sb;\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck) {\\n        return decktosb(deck, 1);\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'[\\');\\n        for (var arr : deck)\\n            sb.append(String.format(\"[%\"+ w + \"d, %\"+ w + \"d], \", arr[0], arr[1]));\\n\\n        sb.setLength(sb.length() - 2);\\n        return sb.append(\"]\\\\n\");\\n    }\\n}\\n```\\n\\nI printed out the decks for a few examples for better understanding:\\n```\\nInput Array:\\n[1, 3, 5, 4, 7]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1]]\\n[[5, 1], [4, 2]]\\n[[7, 2]]\\n]\\n\\nInput Array:\\n[1, 3, 5, 4, 7, 5, 6, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1], [2, 2]]\\n[[5, 1], [4, 2]]\\n[[7, 2], [5, 3]]\\n[[6, 1]]\\n]\\n\\nInput Array:\\n[1, 2, 4, 3, 5, 4, 7, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[2, 1], [2, 2]]\\n[[4, 1], [3, 2]]\\n[[5, 2], [4, 3]]\\n[[7, 3]]\\n]\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int n = a.length, max = 1;\\n        // need to maintain list of decks for each length\\n        // in the list we need list of ending values (bottom up descending), and its counts prefix sum (bottom up)\\n        List<List<int[]>> decks = new ArrayList<>(); // int[0]: tail value, int[1]: count\\'s prefix sum\\n\\n        // step1 push\\n        for (int i = 0; i < n; i++) {\\n            int idx4insert = bs(a[i], decks); // key logic of 300, find where I(a[i]) belongs\\n\\n            // find cnt from previous list\\n            int cnt = idx4insert == 0 ? 1 : getCount(decks.get(idx4insert-1), a[i]);\\n\\n            // create the new element\\n            int[] cur = new int[] {a[i], cnt};\\n            List<int[]> deck;\\n            if (idx4insert == decks.size()) {\\n                decks.add(deck = new ArrayList<>());\\n            } else {\\n                deck = decks.get(idx4insert); // find the right deck\\n                cur[1] += deck.get(deck.size() - 1)[1]; // [1] is prefix sum of count\\n            }\\n            deck.add(cur);\\n        }\\n\\n        // System.out.printf(\"Input Array:\\\\n%s\\\\nDecks:\\\\n%s\\\\n\", Arrays.toString(a), toString(decks));\\n\\n        var deck = decks.get(decks.size() - 1);\\n        return deck.get(deck.size() - 1)[1];\\n    }\\n\\n    private int getCount(List<int[]> deck, int x) { // in a descending order list find largest smaller (no equal) 5 4 4 3: 4        \\n        int l = 0, r = deck.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (deck.get(m)[0] >= x) l = m + 1;\\n            else r = m;\\n        }\\n        if (l == deck.size()) return 1; // first # of LIS, so count is 1;\\n        return deck.get(deck.size() - 1)[1] - (l == 0 ? 0 : deck.get(l-1)[1]);\\n    }\\n\\n    private int bs(int x, List<List<int[]>> decks) { // smallest >=, i.e. insertion index, 1 3 4 4 5: 4\\n        int l = 0, r = decks.size();\\n        while (l < r) { // find smallest larger\\n            int m = l + (r - l) / 2;\\n            var deck = decks.get(m);\\n            int cur = deck.get(deck.size() - 1)[0];\\n            if (cur < x) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n\\n    private StringBuilder toString(List<List<int[]>> decks) {\\n        return toString(decks, 1);\\n    }\\n    private StringBuilder toString(List<List<int[]>> decks, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\"[\\\\n\");\\n        for (var deck : decks)\\n            sb.append(decktosb(deck, w));\\n\\n        sb.append(\"]\\\\n\");\\n        return sb;\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck) {\\n        return decktosb(deck, 1);\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'[\\');\\n        for (var arr : deck)\\n            sb.append(String.format(\"[%\"+ w + \"d, %\"+ w + \"d], \", arr[0], arr[1]));\\n\\n        sb.setLength(sb.length() - 2);\\n        return sb.append(\"]\\\\n\");\\n    }\\n}\\n```\n```\\nInput Array:\\n[1, 3, 5, 4, 7]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1]]\\n[[5, 1], [4, 2]]\\n[[7, 2]]\\n]\\n\\nInput Array:\\n[1, 3, 5, 4, 7, 5, 6, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1], [2, 2]]\\n[[5, 1], [4, 2]]\\n[[7, 2], [5, 3]]\\n[[6, 1]]\\n]\\n\\nInput Array:\\n[1, 2, 4, 3, 5, 4, 7, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[2, 1], [2, 2]]\\n[[4, 1], [3, 2]]\\n[[5, 2], [4, 3]]\\n[[7, 3]]\\n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795760,
                "title": "recursion-memoization-easy-to-understand-beginner-friendly-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\n# Approach\\n\\n### Feel free to post you doubts in the comments\\n<!-- Describe your approach to solving the problem. -->\\n1. **solveMem Function**:\\nThe solveMem function is a recursive function that uses memoization to avoid redundant calculations. It takes the following parameters:\\nnums: The input array of integers representing the sequence.\\ncurr: The current index in the nums array that we are considering.\\nprev: The index of the previous element in the current potential LIS.\\ndp: A 2D vector used for memoization. dp[curr][prev + 1] stores the memoized result for the current state.\\nThe function returns a pair of integers: the length of the LIS ending at the current index curr and the count of such subsequences.\\n\\n2. **Base Case**:\\nThe **base case** of the recursion is when **curr == nums.size()**, which means we have reached the end of the array. In this case, we return make_pair(0, 1) to indicate that we have found a valid LIS of length 0 and count 1.\\n\\n3. **Memoization**:\\nBefore making any recursive calls, the function checks if the result for the current state (dp[curr][prev + 1]) is already computed. If so, it directly returns the stored result, avoiding redundant calculations.\\n\\n4. **Recursive Calls**:\\nThe function considers two possibilities to form a LIS:\\n- Include the current element (nums[curr]) in the LIS if it is greater than the previous element (nums[prev]). We make a recursive call to solveMem with **curr + 1 as the new index and curr as the new previous index**.\\n- Exclude the current element from the LIS. We make a recursive call to solveMem with **curr + 1 as the new index and prev remains the same**.\\nWe store the returned results from both recursive calls in variables include and exclude.\\n\\n5. **Update Length and Count**:\\nAfter the recursive calls, we compare the lengths of the LIS from both inclusion and exclusion cases. If the length from the inclusion case is greater than the current LIS length, we **update the current LIS length and reset the count**. If the lengths are the same, we **accumulate the count**.\\n\\n6. **Memoization and Return**:\\nWe store the calculated LIS length and count in the memoization table dp[curr][prev + 1]. Finally, the function returns the pair (length, count).\\n\\n7. **countLIS Function**:\\nThe countLIS function acts as a wrapper function. It initializes the variables curr and prev, creates a memoization table dp, and makes a call to the solveMem function with the initial parameters. The function then returns the count of LIS for the entire array.\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(2^n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n^2)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> solveMem(vector<int>& nums, int curr, int prev, vector<vector<pair<int, int>>>& dp) {\\n        if (curr == nums.size()) return make_pair(0, 1);\\n\\n        if (dp[curr][prev + 1].first != -1) return dp[curr][prev + 1];\\n\\n        int length = 0, count = 0;\\n\\n        if (prev == -1 || nums[prev] < nums[curr]){\\n            pair<int, int> include = solveMem(nums, curr + 1, curr, dp);\\n            int includeLength = 1 + include.first;\\n            if (includeLength > length){\\n                length = includeLength;\\n                count = include.second;\\n            } \\n            else if (includeLength == length){\\n                count += include.second;\\n            }\\n        }\\n\\n        pair<int, int> exclude = solveMem(nums, curr + 1, prev, dp);\\n        if (exclude.first > length){\\n            length = exclude.first;\\n            count = exclude.second;\\n        } \\n        else if (exclude.first == length){\\n            count += exclude.second;\\n        }\\n\\n        dp[curr][prev + 1] = make_pair(length, count);\\n\\n        return dp[curr][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int curr = 0, prev = -1;\\n        vector<vector<pair<int, int>>> dp(nums.size(), vector<pair<int, int>>(nums.size() + 1, make_pair(-1, -1)));\\n        pair<int, int> result = solveMem(nums, curr, prev, dp);\\n        return result.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> solveMem(vector<int>& nums, int curr, int prev, vector<vector<pair<int, int>>>& dp) {\\n        if (curr == nums.size()) return make_pair(0, 1);\\n\\n        if (dp[curr][prev + 1].first != -1) return dp[curr][prev + 1];\\n\\n        int length = 0, count = 0;\\n\\n        if (prev == -1 || nums[prev] < nums[curr]){\\n            pair<int, int> include = solveMem(nums, curr + 1, curr, dp);\\n            int includeLength = 1 + include.first;\\n            if (includeLength > length){\\n                length = includeLength;\\n                count = include.second;\\n            } \\n            else if (includeLength == length){\\n                count += include.second;\\n            }\\n        }\\n\\n        pair<int, int> exclude = solveMem(nums, curr + 1, prev, dp);\\n        if (exclude.first > length){\\n            length = exclude.first;\\n            count = exclude.second;\\n        } \\n        else if (exclude.first == length){\\n            count += exclude.second;\\n        }\\n\\n        dp[curr][prev + 1] = make_pair(length, count);\\n\\n        return dp[curr][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int curr = 0, prev = -1;\\n        vector<vector<pair<int, int>>> dp(nums.size(), vector<pair<int, int>>(nums.size() + 1, make_pair(-1, -1)));\\n        pair<int, int> result = solveMem(nums, curr, prev, dp);\\n        return result.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450979,
                "title": "python-dp-solution-with-explanation",
                "content": "Define `dp_l(i)` as the length of the longest increasing subsequence in `nums[:i + 1]`.\\nAlso, define `dp_c(i)` as the number of the longest increasing subsequence in `nums[:i + 1]`.\\nThen we\\'ll get the recursion below:\\n`dp_l(i) = max(dp_l(j) + 1, dp_l(i)) for j in range(i)`\\n`dp_c(i) += dp_c(j) if dp_l(i) == dp_l(j) + 1`\\n\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n = len(nums)\\n        dp_l = [1] * n\\n        dp_c = [1] * n\\n        for i, num in enumerate(nums):\\n            for j in range(i):\\n                if nums[i] <= nums[j]:\\n                    continue\\n                if dp_l[j] + 1 > dp_l[i]:\\n                    dp_l[i] = dp_l[j] + 1\\n                    dp_c[i] = dp_c[j]\\n                elif dp_l[j] + 1 == dp_l[i]:\\n                    dp_c[i] += dp_c[j]\\n        max_length = max(x for x in dp_l)\\n        count = 0\\n        for l, c in zip(dp_l, dp_c):\\n            if l == max_length:\\n                count += c\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n = len(nums)\\n        dp_l = [1] * n\\n        dp_c = [1] * n\\n        for i, num in enumerate(nums):\\n            for j in range(i):\\n                if nums[i] <= nums[j]:\\n                    continue\\n                if dp_l[j] + 1 > dp_l[i]:\\n                    dp_l[i] = dp_l[j] + 1\\n                    dp_c[i] = dp_c[j]\\n                elif dp_l[j] + 1 == dp_l[i]:\\n                    dp_c[i] += dp_c[j]\\n        max_length = max(x for x in dp_l)\\n        count = 0\\n        for l, c in zip(dp_l, dp_c):\\n            if l == max_length:\\n                count += c\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107303,
                "title": "python-dp-solution-with-detailed-explanation",
                "content": "Well this question is based on problem [#300 Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) problem. In problem #300, dp solution is quite easy to come forward, which can be written as follow:\\n\\n```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp,ans = [1]* len(nums),1\\n        for i in range(1,len(nums)):\\n            dp[i]=max([dp[j]+1 for j in range(i) if nums[i]>nums[j]]+[1])\\n            ans=max(ans,dp[i])\\n        return ans\\n```\\n\\nHere ```dp[i]``` represents ```the length of the longest subsequence  in nums[:i+1] && ended with index i```. And when I calculate array ```dp```, I just update the result, stored in ```ans```.\\n\\nSo now let's back to this problem, the biggest difference here is that **we also need to find the number of the longest subsequence**. A basic idea is to use another array to memorize the number, so the code is as follow:\\n\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        dp1,dp2 = [1]* len(nums),[1]*len(nums)\\n        count,maxval=1,1\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if dp1[j]+1>dp1[i]:\\n                        dp1[i],dp2[i]=dp1[j]+1,dp2[j]\\n                    elif dp1[j]+1==dp1[i]:\\n                        dp2[i]+=dp2[j]\\n\\n            if dp1[i]>maxval:\\n                maxval,count=dp1[i],dp2[i]\\n            elif dp1[i]==maxval:\\n                count+=dp2[i]\\n\\n        return count\\n\\n```\\n ```dp1```  works the same as  ```dp```  in problem #300: it represents ```the length of the longest subsequence  in nums[:i+1] && ended with index i```. \\n\\n```dp2``` represents ```the number of the subsequences which are satisfied the conditions mentioned in above```.\\n\\nAnd also as problem #300, I also update the final result, stored in ```count``` in the loop.\\n\\n```maxval``` represents ```the length of the longest increasing subsequence```.\\n\\n```count``` represents ```the number of the increasing subsequence with length equals to maxval```.\\n\\nThe time complexity is O(n^2)---time,O(n)---space.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp,ans = [1]* len(nums),1\\n        for i in range(1,len(nums)):\\n            dp[i]=max([dp[j]+1 for j in range(i) if nums[i]>nums[j]]+[1])\\n            ans=max(ans,dp[i])\\n        return ans\\n```\n```dp[i]```\n```the length of the longest subsequence  in nums[:i+1] && ended with index i```\n```dp```\n```ans```\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        dp1,dp2 = [1]* len(nums),[1]*len(nums)\\n        count,maxval=1,1\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if dp1[j]+1>dp1[i]:\\n                        dp1[i],dp2[i]=dp1[j]+1,dp2[j]\\n                    elif dp1[j]+1==dp1[i]:\\n                        dp2[i]+=dp2[j]\\n\\n            if dp1[i]>maxval:\\n                maxval,count=dp1[i],dp2[i]\\n            elif dp1[i]==maxval:\\n                count+=dp2[i]\\n\\n        return count\\n\\n```\n```dp1```\n```dp```\n```the length of the longest subsequence  in nums[:i+1] && ended with index i```\n```dp2```\n```the number of the subsequences which are satisfied the conditions mentioned in above```\n```count```\n```maxval```\n```the length of the longest increasing subsequence```\n```count```\n```the number of the increasing subsequence with length equals to maxval```",
                "codeTag": "Java"
            },
            {
                "id": 3794936,
                "title": "video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/-VJeXNH3gAQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count,1);\\n        int max = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            count[i] = count[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            count[i] += count[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        count = [1] * n\\n        maxLen = 1\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[j] + 1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        count[i] = count[j]\\n                    elif dp[j] + 1 == dp[i]:\\n                        count[i] += count[j]\\n                maxLen = max(maxLen, dp[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            if dp[i] == maxLen:\\n                ans += count[i]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count,1);\\n        int max = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            count[i] = count[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            count[i] += count[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        count = [1] * n\\n        maxLen = 1\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[j] + 1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        count[i] = count[j]\\n                    elif dp[j] + 1 == dp[i]:\\n                        count[i] += count[j]\\n                maxLen = max(maxLen, dp[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            if dp[i] == maxLen:\\n                ans += count[i]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367666,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int[] c=new int[n];\\n        \\n        Arrays.fill(dp,1);\\n        Arrays.fill(c,1);\\n        \\n        int max=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                   if(dp[j]+1 > dp[i])//same subsequence\\n                   {\\n                       dp[i]=dp[j]+1;\\n                       c[i]=c[j];\\n                   }\\n                    else if(dp[j]+1==dp[i])//different subsequence\\n                    {\\n                        c[i]+=c[j];\\n                    }\\n                        \\n                }\\n            }\\n            max=Math.max(dp[i],max);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i]==max)\\n                count+=c[i];\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int[] c=new int[n];\\n        \\n        Arrays.fill(dp,1);\\n        Arrays.fill(c,1);\\n        \\n        int max=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                   if(dp[j]+1 > dp[i])//same subsequence\\n                   {\\n                       dp[i]=dp[j]+1;\\n                       c[i]=c[j];\\n                   }\\n                    else if(dp[j]+1==dp[i])//different subsequence\\n                    {\\n                        c[i]+=c[j];\\n                    }\\n                        \\n                }\\n            }\\n            max=Math.max(dp[i],max);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i]==max)\\n                count+=c[i];\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921821,
                "title": "python-by-2d-dp-w-video",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=ya4r7LZRl7E)\\n\\nPython by 2D DP\\n\\n---\\n\\n**Implementation** by 2D DP\\n\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        if not nums:\\n            # Quick response for empty list\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        # record of length of increasing subsequence\\n        length = [1 for _ in range(n)]\\n        \\n        # record the path count of increasing subsequence\\n        count = [1 for _ in range(n)]\\n            \\n        # scan each number, where increasing subsequence ending in nums[i]\\n        for i in range(n):\\n            \\n            # for every number before nums[i]\\n            for k in range(i):\\n                \\n                \\n                if nums[k] < nums[i]:\\n                    # nums[k] can add to increasing subsequence ending in nums[i]\\n                    \\n                    if (length[k] + 1) > length[i]:\\n                        # nums[k] make it longer to increasing subsequence ending in nums[i]\\n                        length[i], count[i] = length[k]+1, count[k]\\n                \\n                    elif (length[k] + 1) == length[i]:\\n                        # nums[k] add some new paths of increasing subsequence ending in nums[i]\\n                        count[i] += count[k]\\n        \\n        \\n\\t\\t# get the length of lonest increasing subsequence\\n        max_length = max(length)\\n        \\n        # report total path count of longest increasing subsequence\\n        return sum( count for length, count in zip(length, count) if length == max_length )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        if not nums:\\n            # Quick response for empty list\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        # record of length of increasing subsequence\\n        length = [1 for _ in range(n)]\\n        \\n        # record the path count of increasing subsequence\\n        count = [1 for _ in range(n)]\\n            \\n        # scan each number, where increasing subsequence ending in nums[i]\\n        for i in range(n):\\n            \\n            # for every number before nums[i]\\n            for k in range(i):\\n                \\n                \\n                if nums[k] < nums[i]:\\n                    # nums[k] can add to increasing subsequence ending in nums[i]\\n                    \\n                    if (length[k] + 1) > length[i]:\\n                        # nums[k] make it longer to increasing subsequence ending in nums[i]\\n                        length[i], count[i] = length[k]+1, count[k]\\n                \\n                    elif (length[k] + 1) == length[i]:\\n                        # nums[k] add some new paths of increasing subsequence ending in nums[i]\\n                        count[i] += count[k]\\n        \\n        \\n\\t\\t# get the length of lonest increasing subsequence\\n        max_length = max(length)\\n        \\n        # report total path count of longest increasing subsequence\\n        return sum( count for length, count in zip(length, count) if length == max_length )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740365,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 17 ms, faster than 91.22% of Java online submissions for Number of Longest Increasing Subsequence.\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        //dp[i] will store the length of Longest Increasing Subsequence, ending at nums[i].\\n        int[] dp = new int[n];\\n        //count[i] will store the total number of Longest Increasing Subsequences, ending at nums[i].\\n        int[] count = new int[n];\\n        \\n        //lis : length of Longest Increasing Subsequence.\\n        int lis = 0;\\n        //res : total number of subsequences of length lis.\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = 1;\\n            count[i] = 1;\\n            \\n            //Checking it\\'s previous values.\\n            for (int j = 0; j < i; j++) {\\n                //If any previous value of nums[i] is less than it, then only it can be appended(as we know the \\n\\t\\t\\t\\t//subsequence would have ended at nums[j]).\\n                if (nums[j] < nums[i]) {\\n                    //If dp[i] is equal to dp[j] + 1, meaning a different sequence has been found of same \\n\\t\\t\\t\\t\\t//length, so increase count[i] by count[j].\\n                    if (dp[i] == dp[j] + 1) {\\n                        count[i] += count[j];\\n                    }\\n                    //Else, if dp[i] is less than dp[j] + 1, meaning length will increase as sequence will have a \\n\\t\\t\\t\\t\\t//new element, so store dp[j] + 1 in dp[i] and count[j] in count[i].\\n                    else if (dp[i] < dp[j] + 1) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    }\\n                }\\n            }\\n            \\n            //If lis is equal to dp[i], meaning a new sequence is found of same length, so add count[i] in res.\\n            if (lis == dp[i]) {\\n                res += count[i];\\n            }\\n            //Else if lis is less than dp[i], meaning a new sequence is formed of greater length, so store the \\n\\t\\t\\t//new increased length in lis and count[i] in res.\\n            else if (lis < dp[i]) {\\n                lis = dp[i];\\n                res = count[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        //dp[i] will store the length of Longest Increasing Subsequence, ending at nums[i].\\n        int[] dp = new int[n];\\n        //count[i] will store the total number of Longest Increasing Subsequences, ending at nums[i].\\n        int[] count = new int[n];\\n        \\n        //lis : length of Longest Increasing Subsequence.\\n        int lis = 0;\\n        //res : total number of subsequences of length lis.\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = 1;\\n            count[i] = 1;\\n            \\n            //Checking it\\'s previous values.\\n            for (int j = 0; j < i; j++) {\\n                //If any previous value of nums[i] is less than it, then only it can be appended(as we know the \\n\\t\\t\\t\\t//subsequence would have ended at nums[j]).\\n                if (nums[j] < nums[i]) {\\n                    //If dp[i] is equal to dp[j] + 1, meaning a different sequence has been found of same \\n\\t\\t\\t\\t\\t//length, so increase count[i] by count[j].\\n                    if (dp[i] == dp[j] + 1) {\\n                        count[i] += count[j];\\n                    }\\n                    //Else, if dp[i] is less than dp[j] + 1, meaning length will increase as sequence will have a \\n\\t\\t\\t\\t\\t//new element, so store dp[j] + 1 in dp[i] and count[j] in count[i].\\n                    else if (dp[i] < dp[j] + 1) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    }\\n                }\\n            }\\n            \\n            //If lis is equal to dp[i], meaning a new sequence is found of same length, so add count[i] in res.\\n            if (lis == dp[i]) {\\n                res += count[i];\\n            }\\n            //Else if lis is less than dp[i], meaning a new sequence is formed of greater length, so store the \\n\\t\\t\\t//new increased length in lis and count[i] in res.\\n            else if (lis < dp[i]) {\\n                lis = dp[i];\\n                res = count[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357851,
                "title": "c-o-n-logn-binary-searches",
                "content": "There are lots of O(n^2) solutions posted in the discussion forum. **I wonder if the interviewer woud really expect the optimal solution.** I am providing the O(n log(n)) solution here, with binary seaches on indexes. There are a lot of tricks played here.\\n\\nThe idea is simple; we keep track of the longest increasing sequence (LIS) as well as the number of LIS sequences ending with the current element. \\n\\nFor example, [1, 3, 5, 4, 7]\\nI assume it is easy to see LIS for the first 3 elements is [1, 3, 5].\\nWhen we see 4, we can update LIS to have [1,3,4], but we should not discard the sequence [1, 3, 5] since it may contribute to later LIS sequences. This LIS has a length 3 (maximum index is 2), so we keep a vector:\\ntable[2] = {[5,1], [4,1]}, indicating at LIS index 2 we could have 1 sequence ending with 5, and another sequence ending with 4.\\n\\nThen we see 7. We see 7 has to be added to the end of the previous LIS, but it could be added to the LIS ending with 5 or 4. So we will have table[3] = {[7, 2]}.\\n\\nIn general, for any current element, we will need to find out the index just before its insert point in LIS. In the previous example, for number 7 to be inserted at index 3, we need to check table[2] to update the number of possible paths for the current number. In my program, this is what `k` is.\\n\\nAlso, for each LIS insertion at index i, we are inserting it in desceding order, so it would be easy to find out the exact place in table[i] using binary search. In my program, I used negative number for easy binary search.\\n\\nAnother trick is I am only keeping the prefix sum of all paths for table[i]. In this way, the number of paths `k` can be obtained in O(1).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> table(n, vector<int>{});\\n        vector<vector<int>> paths;\\n        vector<int> lis;\\n        int i, j, k, ans = 0;\\n        for (auto num: nums){\\n            i = lower_bound(lis.begin(), \\n                            lis.end(),\\n                            num) - lis.begin();\\n            k = 1;\\n            if (i > 0){\\n                j = upper_bound(table[i-1].begin(), \\n                                table[i-1].end(), \\n                                -num) - table[i-1].begin();\\n                k = paths[i-1].back() - paths[i-1][j];\\n            }\\n\\n            table[i].push_back(-num);\\n\\n            if (i == lis.size()){\\n                lis.push_back(num);\\n                paths.push_back({0, k});\\n            }\\n            else {\\n                lis[i] = num;\\n                paths[i].push_back(paths[i].back() + k);\\n            }\\n        }\\n        return paths.back().back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> table(n, vector<int>{});\\n        vector<vector<int>> paths;\\n        vector<int> lis;\\n        int i, j, k, ans = 0;\\n        for (auto num: nums){\\n            i = lower_bound(lis.begin(), \\n                            lis.end(),\\n                            num) - lis.begin();\\n            k = 1;\\n            if (i > 0){\\n                j = upper_bound(table[i-1].begin(), \\n                                table[i-1].end(), \\n                                -num) - table[i-1].begin();\\n                k = paths[i-1].back() - paths[i-1][j];\\n            }\\n\\n            table[i].push_back(-num);\\n\\n            if (i == lis.size()){\\n                lis.push_back(num);\\n                paths.push_back({0, k});\\n            }\\n            else {\\n                lis[i] = num;\\n                paths[i].push_back(paths[i].back() + k);\\n            }\\n        }\\n        return paths.back().back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469612,
                "title": "java-o-n-log-n-solution-with-explanation-ft-patience-sorting",
                "content": "It took me several days to fully understand and grasp all the concepts, so don\\'t be overwhelmed when you don\\'t understand others\\' solutions at one go. I used patience sorting strategy to solve the problem. https://en.wikipedia.org/wiki/Patience_sorting\\n\\nI tried to be as verbose as possible, defining each Card/Pile class to help those of you who are having difficulties understanding the problem understand, while using available helper functions when needed. (e.g. I used java\\'s `Collections.binarySearch` to avoid implementing searching logic).\\n\\nPlease let me know if this solution helped you understanding the problem.\\n\\n```\\nclass Solution {\\n    //Use patience sorting algorithm to find all available LIS.\\n    \\n    //Patience sorting in a nutshell:\\n    //1. Initially, there are no piles. The first card dealt forms a new pile consisting of the single card.\\n    //2. Each subsequent card is placed on the leftmost existing pile whose top card has a value greater than or \\n    //   equal to the new card\\'s value, or to the right of all of the existing piles, thus forming a new pile.\\n    //3. When there are no more cards remaining to deal, the game ends.\\n    //4. When the game ends, # of piles is equal to the length of the LIS.\\n    \\n    // In our case, we are also adding a concept of `counts` to each card in order to track total number of LIS.\\n    \\n    class Card implements Comparable<Card> {\\n        //Num represents\\' card\\'s value.\\n        int num;\\n        \\n        //Counts represents cumulative counts, or LIS encountered so far for this card.\\n        //Card always belongs to a pile of cards, and top card will have cumulative counts for all cards below. (e.g. prefix sum)\\n        int counts;\\n        \\n        public Card(int num, int counts) {\\n            this.num = num;\\n            this.counts = counts;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Card o) {\\n            // By definition of patience sorting, smaller card will be placed on top of a greater card, so return negative value.\\n            // In some other solutions, people use negative value as card value to do something similar. This is doing the same thing.\\n            return o.num-num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return \"{\"+num+\",\"+counts+\"}\";\\n        }\\n    }\\n    \\n    class Pile implements Comparable<Pile> {\\n        //You can think of cards as a stack of cards where the last element is on the top of cards, \\n\\t\\t//and the first element is at the bottom of cards.\\n        public List<Card> cards = new ArrayList<>();\\n        \\n        // Pile has at least one card with it.\\n        public Pile(Card first){\\n            cards.add(first);\\n        }\\n        \\n        // Helper method to return the last card (top card) in the pile.\\n        public Card getLastCard(){\\n            if(cards.isEmpty()){ //should never happen.\\n                return null;\\n            } else {\\n                return cards.get(cards.size()-1);\\n            }\\n        }\\n        \\n        // Get cumulative counts in the current pile that is smaller than provided number.\\n        // When a new card A is added to the pile after this pile instance, this function\\n        // can be invoked to fetch the cumulative counts for the card A.\\n\\n        // e.g. [Pile[Card(4,1),Card(1,2)], Pile[Card(3,?)]] - where x is number and y is counts in Card(x,y) format.\\n\\t\\t// In above case, when Card(3,?) is put on to a second pile, `?`\\'s value should be 2-1, which is 1.\\n        public int getCounts(int smallerThan) {\\n\\t\\t    //Build a card stub to use it in the search.\\n\\t\\t\\t//`compareTo` doesn\\'t use counts, so 0 for counts is fine.\\n            Card card = new Card(smallerThan, 0);\\n\\t\\t\\t\\n            int limitIdx = Collections.binarySearch(cards, card);\\n            int x = getLastCard().counts; //Top card\\'s count, which is cumulative counts for this whole pile.\\n            int y = 0; //y will hold a count of a card whose value is equal or greater than `smallerThan`.\\n            if(limitIdx < 0) {\\n                //Negative idx means exact match was not found, so insertion point was returned instead.\\n                //Negating the negative value gives us an index which has value that is greater than what we searched for.\\n                limitIdx = ~limitIdx;\\n                if(limitIdx > 0) {\\n                    y = cards.get(limitIdx-1).counts;\\n                }\\n            } else { \\n                //Exact match was found. \\n                //This means that There exists a card in this pile whose value is equal to `smallerThan`.\\n                //So we just need to subtract that found card\\'s counts from the top card\\'s count.\\n                //This is because we are interested in strictly increasing subsequence.\\n                y = cards.get(limitIdx).counts;\\n            }\\n            // We subtract counts of a card that is not smaller than the provided `smallerThan` arg from the top card\\'s count\\n            return x-y;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Pile o) {\\n            // Piles can be compared/sorted based on what is on the top of the cards in each pile.\\n            return getLastCard().num - o.getLastCard().num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            // We are only interested in cards contents.\\n            return cards.toString();\\n        }\\n    }\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n        \\n        //There are multiple piles in the deck where each pile\\'s last card (top card) is always greater than previous piles\\' last cards.\\n\\t\\t//and those last cards in the piles are in strictly increasing order.\\n        List<Pile> deck = new ArrayList<>();\\n        for(int i=0; i < nums.length;i++) {\\n            \\n            // Build a stub pile/card. a.k.a current card.\\n            Card card = new Card(nums[i], 1);\\n            // A stub pile that may/may not be added to the deck.\\n            Pile pile = new Pile(card);\\n            \\n            // Let\\'s find a location/index in the deck where this pile has to be put in.\\n            int idx = Collections.binarySearch(deck, pile);\\n            \\n            if(idx < 0) {\\n                //No exact match found, which means none of the piles in the deck has the top card value that is equivalent to the current card\\'s value.\\n                //Instead, insertion point has been returned in two\\'s complement, aka negative value.\\n\\t\\t\\t\\t//Read JavaDoc for `Collections binarysearch` for better understanding if needed.\\n                \\n                //Negate to insertion point value to get the index in the list where above card/pile has to be put in.\\n                idx = ~idx;\\n            }\\n            \\n            if(idx == deck.size()){ \\n                // Deck\\'s last element should have index of (deck.size()-1) as array/list index starts at 0 in computer science.\\n                // However, if result of `Collections.binarySearch` is equal to (deck.size()) which is nonexistent index, \\n                // that means that new pile has to be added to the deck.\\n                // It also means that current card\\'s number is greater than all other piles\\' top card.\\n                \\n                if(idx > 0) {\\n                    //If there exists a prev pile, get prev pile (currently last pile, but soon to be second to the last after this pile gets added)\\n                    //and fetch counts from the prev pile.\\n                    Pile prevPile = deck.get(idx-1);\\n                    \\n                    //Assign counts from the prev pile to the current card.\\n                    card.counts = prevPile.getCounts(card.num);\\n                }\\n                deck.add(pile);\\n            } else { \\n                //There exists a pile where card can be added to.\\n                pile = deck.get(idx);\\n                Card lastCard = pile.getLastCard();\\n                \\n                //The last card (top card) in the pile is always the smallest card in the given pile by definition of patience sorting.\\n                //Therefore, compare if the last card\\'s number is greater than the current card\\'s number or equal to the current card\\'number.\\n                \\n                //The last card will never be smaller than the current card\\'s number because `Collections.binarySearch` should have given us\\n                //an index of a pile whose top card is greater than or equal to the current card.\\n                if(lastCard.num > card.num) {\\n                    //Last card is greater than current card. \\n                    //This means that we just need to add current card to the top of a pile following patience sorting algorithm.\\n                    \\n                    if(idx == 0) {\\n                        //If current pile is the first pile in the deck, there is no previous pile and no counts to fetch from the previous pile\\'s top card.\\n                        //Therefore, set the card\\'s initial count to 1.\\n                        card.counts = 1;\\n                    } else {\\n                        //Otherwise, get counts from previous pile.\\n                        card.counts = deck.get(idx-1).getCounts(card.num);    \\n                    }\\n                    // Also add the pile\\'s current last card\\'s count to the current card, since we want to keep cumulative counts.\\n                    card.counts += pile.getLastCard().counts;\\n                    \\n                    // Add a new card to the cards in the deck like a stack.\\n                    pile.cards.add(card);\\n                } else { \\n                    //Last card\\'s num is equal to the current card.\\n                    //This means that we only need to update the card\\'s counts.\\n                    if(idx > 0) {\\n                        //If there is a previous pile, add counts from the previous pile.\\n                        lastCard.counts += deck.get(idx-1).getCounts(lastCard.num);\\n                    } else {\\n                        //Otherwise, just add one more count.\\n                        lastCard.counts +=1;\\n                    }\\n                }\\n            }\\n        }\\n        //At the end of patience sorting algorithm, length of the piles is equal to the length of the longest increasing subsequence.\\n        //And it is possible to get longest LIS by putting backward pointers to the previous pile\\'s top card whenever new card is put onto a pile.\\n        \\n        //In our case, we have been tracking cumulative LIS counts whenever we put a new card into a pile, (instead of putting back-pointers)\\n        //Therefore, last pile, the pile with the longest increasing subsequence, will contain all possible LIS, and the top card in the last pile will have a cumulative counts for \\n        //all possible LIS.\\n        return deck.get(deck.size()-1).getLastCard().counts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //Use patience sorting algorithm to find all available LIS.\\n    \\n    //Patience sorting in a nutshell:\\n    //1. Initially, there are no piles. The first card dealt forms a new pile consisting of the single card.\\n    //2. Each subsequent card is placed on the leftmost existing pile whose top card has a value greater than or \\n    //   equal to the new card\\'s value, or to the right of all of the existing piles, thus forming a new pile.\\n    //3. When there are no more cards remaining to deal, the game ends.\\n    //4. When the game ends, # of piles is equal to the length of the LIS.\\n    \\n    // In our case, we are also adding a concept of `counts` to each card in order to track total number of LIS.\\n    \\n    class Card implements Comparable<Card> {\\n        //Num represents\\' card\\'s value.\\n        int num;\\n        \\n        //Counts represents cumulative counts, or LIS encountered so far for this card.\\n        //Card always belongs to a pile of cards, and top card will have cumulative counts for all cards below. (e.g. prefix sum)\\n        int counts;\\n        \\n        public Card(int num, int counts) {\\n            this.num = num;\\n            this.counts = counts;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Card o) {\\n            // By definition of patience sorting, smaller card will be placed on top of a greater card, so return negative value.\\n            // In some other solutions, people use negative value as card value to do something similar. This is doing the same thing.\\n            return o.num-num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return \"{\"+num+\",\"+counts+\"}\";\\n        }\\n    }\\n    \\n    class Pile implements Comparable<Pile> {\\n        //You can think of cards as a stack of cards where the last element is on the top of cards, \\n\\t\\t//and the first element is at the bottom of cards.\\n        public List<Card> cards = new ArrayList<>();\\n        \\n        // Pile has at least one card with it.\\n        public Pile(Card first){\\n            cards.add(first);\\n        }\\n        \\n        // Helper method to return the last card (top card) in the pile.\\n        public Card getLastCard(){\\n            if(cards.isEmpty()){ //should never happen.\\n                return null;\\n            } else {\\n                return cards.get(cards.size()-1);\\n            }\\n        }\\n        \\n        // Get cumulative counts in the current pile that is smaller than provided number.\\n        // When a new card A is added to the pile after this pile instance, this function\\n        // can be invoked to fetch the cumulative counts for the card A.\\n\\n        // e.g. [Pile[Card(4,1),Card(1,2)], Pile[Card(3,?)]] - where x is number and y is counts in Card(x,y) format.\\n\\t\\t// In above case, when Card(3,?) is put on to a second pile, `?`\\'s value should be 2-1, which is 1.\\n        public int getCounts(int smallerThan) {\\n\\t\\t    //Build a card stub to use it in the search.\\n\\t\\t\\t//`compareTo` doesn\\'t use counts, so 0 for counts is fine.\\n            Card card = new Card(smallerThan, 0);\\n\\t\\t\\t\\n            int limitIdx = Collections.binarySearch(cards, card);\\n            int x = getLastCard().counts; //Top card\\'s count, which is cumulative counts for this whole pile.\\n            int y = 0; //y will hold a count of a card whose value is equal or greater than `smallerThan`.\\n            if(limitIdx < 0) {\\n                //Negative idx means exact match was not found, so insertion point was returned instead.\\n                //Negating the negative value gives us an index which has value that is greater than what we searched for.\\n                limitIdx = ~limitIdx;\\n                if(limitIdx > 0) {\\n                    y = cards.get(limitIdx-1).counts;\\n                }\\n            } else { \\n                //Exact match was found. \\n                //This means that There exists a card in this pile whose value is equal to `smallerThan`.\\n                //So we just need to subtract that found card\\'s counts from the top card\\'s count.\\n                //This is because we are interested in strictly increasing subsequence.\\n                y = cards.get(limitIdx).counts;\\n            }\\n            // We subtract counts of a card that is not smaller than the provided `smallerThan` arg from the top card\\'s count\\n            return x-y;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Pile o) {\\n            // Piles can be compared/sorted based on what is on the top of the cards in each pile.\\n            return getLastCard().num - o.getLastCard().num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            // We are only interested in cards contents.\\n            return cards.toString();\\n        }\\n    }\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n        \\n        //There are multiple piles in the deck where each pile\\'s last card (top card) is always greater than previous piles\\' last cards.\\n\\t\\t//and those last cards in the piles are in strictly increasing order.\\n        List<Pile> deck = new ArrayList<>();\\n        for(int i=0; i < nums.length;i++) {\\n            \\n            // Build a stub pile/card. a.k.a current card.\\n            Card card = new Card(nums[i], 1);\\n            // A stub pile that may/may not be added to the deck.\\n            Pile pile = new Pile(card);\\n            \\n            // Let\\'s find a location/index in the deck where this pile has to be put in.\\n            int idx = Collections.binarySearch(deck, pile);\\n            \\n            if(idx < 0) {\\n                //No exact match found, which means none of the piles in the deck has the top card value that is equivalent to the current card\\'s value.\\n                //Instead, insertion point has been returned in two\\'s complement, aka negative value.\\n\\t\\t\\t\\t//Read JavaDoc for `Collections binarysearch` for better understanding if needed.\\n                \\n                //Negate to insertion point value to get the index in the list where above card/pile has to be put in.\\n                idx = ~idx;\\n            }\\n            \\n            if(idx == deck.size()){ \\n                // Deck\\'s last element should have index of (deck.size()-1) as array/list index starts at 0 in computer science.\\n                // However, if result of `Collections.binarySearch` is equal to (deck.size()) which is nonexistent index, \\n                // that means that new pile has to be added to the deck.\\n                // It also means that current card\\'s number is greater than all other piles\\' top card.\\n                \\n                if(idx > 0) {\\n                    //If there exists a prev pile, get prev pile (currently last pile, but soon to be second to the last after this pile gets added)\\n                    //and fetch counts from the prev pile.\\n                    Pile prevPile = deck.get(idx-1);\\n                    \\n                    //Assign counts from the prev pile to the current card.\\n                    card.counts = prevPile.getCounts(card.num);\\n                }\\n                deck.add(pile);\\n            } else { \\n                //There exists a pile where card can be added to.\\n                pile = deck.get(idx);\\n                Card lastCard = pile.getLastCard();\\n                \\n                //The last card (top card) in the pile is always the smallest card in the given pile by definition of patience sorting.\\n                //Therefore, compare if the last card\\'s number is greater than the current card\\'s number or equal to the current card\\'number.\\n                \\n                //The last card will never be smaller than the current card\\'s number because `Collections.binarySearch` should have given us\\n                //an index of a pile whose top card is greater than or equal to the current card.\\n                if(lastCard.num > card.num) {\\n                    //Last card is greater than current card. \\n                    //This means that we just need to add current card to the top of a pile following patience sorting algorithm.\\n                    \\n                    if(idx == 0) {\\n                        //If current pile is the first pile in the deck, there is no previous pile and no counts to fetch from the previous pile\\'s top card.\\n                        //Therefore, set the card\\'s initial count to 1.\\n                        card.counts = 1;\\n                    } else {\\n                        //Otherwise, get counts from previous pile.\\n                        card.counts = deck.get(idx-1).getCounts(card.num);    \\n                    }\\n                    // Also add the pile\\'s current last card\\'s count to the current card, since we want to keep cumulative counts.\\n                    card.counts += pile.getLastCard().counts;\\n                    \\n                    // Add a new card to the cards in the deck like a stack.\\n                    pile.cards.add(card);\\n                } else { \\n                    //Last card\\'s num is equal to the current card.\\n                    //This means that we only need to update the card\\'s counts.\\n                    if(idx > 0) {\\n                        //If there is a previous pile, add counts from the previous pile.\\n                        lastCard.counts += deck.get(idx-1).getCounts(lastCard.num);\\n                    } else {\\n                        //Otherwise, just add one more count.\\n                        lastCard.counts +=1;\\n                    }\\n                }\\n            }\\n        }\\n        //At the end of patience sorting algorithm, length of the piles is equal to the length of the longest increasing subsequence.\\n        //And it is possible to get longest LIS by putting backward pointers to the previous pile\\'s top card whenever new card is put onto a pile.\\n        \\n        //In our case, we have been tracking cumulative LIS counts whenever we put a new card into a pile, (instead of putting back-pointers)\\n        //Therefore, last pile, the pile with the longest increasing subsequence, will contain all possible LIS, and the top card in the last pile will have a cumulative counts for \\n        //all possible LIS.\\n        return deck.get(deck.size()-1).getLastCard().counts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849276,
                "title": "c-dp-o-n-2-solution-with-comments",
                "content": "Runtime: 68 ms, faster than 86.74% of C++ online submissions for Number of Longest Increasing Subsequence.\\nMemory Usage: 12.8 MB, less than 72.33% of C++ online submissions for Number of Longest Increasing Subsequence.\\n\\n`TestCase : [1,3,5,4,4,6,7,8,9,1,3,5,4,4,6,7,8,10,9]\\nAnswer : 7`\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        \\n        // DP list tracks the LIS of nums from start to ith index\\n        // Every value in nums has LIS 1\\n        vector<int>dp(n,1);\\n        \\n        // Stores the count of the number of LIS of nums from start to ith index\\n        // Every value in nums has LIS 1 and they have at least 1 combination of LIS \\n        vector<int>count(n,1);\\n        \\n         // Max LIS length\\n        int maxL = 1;\\n        \\n        // Final result of number of max LIS\\n        int res = 0;\\n        \\n        int current = 0;\\n        \\n        // Loop through the elements starting from second element\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // Stores the LIS length till ith index in DP which statisfies below conditions\\n            current = 0;\\n            \\n            // Compare all values from start till the current index\\n            for(int j=0;j<i;j++)\\n            {\\n                // Check if the jth index value is less than the current index value cause it satisfies the\\n                // condition for IS and if so then check whether the jth index LIS value is greater than \\n                // or equal current LIS value, if yes then update current LIS with dp[j] cause we want to get the maxLength LIS\\n                \\n                // If above condition satisfied, we also update count[i] with count[j] if dp[j] > current \\n                // cause we got larger LIS value so we need to update the number of LIS of \\n                // jth index to ith index which is count[i] = count[j];\\n                // Otherwise we add count[j] with count[i] because we found another LIS equal to current LIS\\n                // which can generate another combination of max LIS till ith index\\n                \\n                if(nums[j]<nums[i] && dp[j] >= current)\\n                {\\n                    if(dp[j]==current)count[i]+=count[j];\\n                    else count[i] = count[j];\\n                    current = dp[j];                    \\n                }                \\n            }\\n                     \\n            // We add 1 with current cause current holds the LIS till the current index and as \\n            // current index is included we add 1 with it \\n            dp[i] = current + 1;\\n            maxL = max(maxL,dp[i]);\\n        }\\n        \\n\\n        // We go through the dp list and check ith index which has value of max LIS \\n        // and we add their number of LIS of ith index from count list with the result\\n        for(int i=0;i<nums.size();i++)\\n            if(dp[i]==maxL)res+=count[i];            \\n\\n        return res;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        \\n        // DP list tracks the LIS of nums from start to ith index\\n        // Every value in nums has LIS 1\\n        vector<int>dp(n,1);\\n        \\n        // Stores the count of the number of LIS of nums from start to ith index\\n        // Every value in nums has LIS 1 and they have at least 1 combination of LIS \\n        vector<int>count(n,1);\\n        \\n         // Max LIS length\\n        int maxL = 1;\\n        \\n        // Final result of number of max LIS\\n        int res = 0;\\n        \\n        int current = 0;\\n        \\n        // Loop through the elements starting from second element\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // Stores the LIS length till ith index in DP which statisfies below conditions\\n            current = 0;\\n            \\n            // Compare all values from start till the current index\\n            for(int j=0;j<i;j++)\\n            {\\n                // Check if the jth index value is less than the current index value cause it satisfies the\\n                // condition for IS and if so then check whether the jth index LIS value is greater than \\n                // or equal current LIS value, if yes then update current LIS with dp[j] cause we want to get the maxLength LIS\\n                \\n                // If above condition satisfied, we also update count[i] with count[j] if dp[j] > current \\n                // cause we got larger LIS value so we need to update the number of LIS of \\n                // jth index to ith index which is count[i] = count[j];\\n                // Otherwise we add count[j] with count[i] because we found another LIS equal to current LIS\\n                // which can generate another combination of max LIS till ith index\\n                \\n                if(nums[j]<nums[i] && dp[j] >= current)\\n                {\\n                    if(dp[j]==current)count[i]+=count[j];\\n                    else count[i] = count[j];\\n                    current = dp[j];                    \\n                }                \\n            }\\n                     \\n            // We add 1 with current cause current holds the LIS till the current index and as \\n            // current index is included we add 1 with it \\n            dp[i] = current + 1;\\n            maxL = max(maxL,dp[i]);\\n        }\\n        \\n\\n        // We go through the dp list and check ith index which has value of max LIS \\n        // and we add their number of LIS of ith index from count list with the result\\n        for(int i=0;i<nums.size();i++)\\n            if(dp[i]==maxL)res+=count[i];            \\n\\n        return res;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194561,
                "title": "tc-o-n-n-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,1),curr(n,1);\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(nums[i]>nums[prev] && 1+dp[prev]>dp[i])\\n                {\\n                    dp[i]=1+dp[prev];\\n                    curr[i]=curr[prev];\\n                }\\n                else if(nums[prev]<nums[i] && dp[prev]+1==dp[i])\\n                {\\n                    curr[i]+=curr[prev];\\n                }   \\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==maxi)\\n                count+=curr[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Segment Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,1),curr(n,1);\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(nums[i]>nums[prev] && 1+dp[prev]>dp[i])\\n                {\\n                    dp[i]=1+dp[prev];\\n                    curr[i]=curr[prev];\\n                }\\n                else if(nums[prev]<nums[i] && dp[prev]+1==dp[i])\\n                {\\n                    curr[i]+=curr[prev];\\n                }   \\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==maxi)\\n                count+=curr[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572950,
                "title": "c-fast-comprehensible-o-nlogn-time-o-n-space",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/799176896/\\n\\nYou can uncomment the code and look for the detailed run. I can also explain concept and code flow if required.\\nPlease Upvote! \\nThanks :)\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         int n = nums.size();\\n        vector<pair<int, int>> v[n + 1];\\n        vector<int> vv;\\n        int len = 0;\\n        for (int x : nums) {\\n            if (vv.size()) {\\n                if (x > vv.back()) {\\n                    len++; vv.push_back(x);\\n                    //v[len].emplace_back(x, v[len - 1].back().second);\\n                    int lo = 0, hi = v[len - 1].size() - 1;\\n                    while (lo < hi) {\\n                        int mid = (lo + hi) / 2;\\n                        if (v[len - 1][mid].first >= x) {\\n                            lo = mid + 1;\\n                        }\\n                        else {\\n                            hi = mid;\\n                        }\\n                    }\\n                    v[len].emplace_back(x, v[len - 1].back().second - (hi > 0 ? v[len - 1][hi - 1].second : 0) );\\n                }\\n                else {\\n                    int it = lower_bound(vv.begin(), vv.end(), x) - vv.begin();\\n                    vv[it] = x;\\n                    int val = 0;\\n                    //calculate val\\n                    if (it == 0) {\\n                        val = 1;\\n                    }\\n                    else {\\n                        int lo = 0, hi = v[it].size() - 1;\\n                        while (lo < hi) {\\n                            int mid = (lo + hi) / 2;\\n                            if (v[it][mid].first >= x) {\\n                                lo = mid + 1;\\n                            }\\n                            else {\\n                                hi = mid;\\n                            }\\n                        }\\n                        //cout << it << endl;\\n                        val = v[it].back().second - (hi > 0 ? v[it][hi - 1].second : 0);\\n                    }\\n                    v[it + 1].emplace_back(x, val + v[it + 1].back().second);\\n                }\\n            }\\n            else {\\n                len++;\\n                vv.push_back(x);\\n                v[len].emplace_back(x, 1);\\n            }\\n            /*       for (int xx : vv) {\\n                       cout << xx << \" \";\\n                   }\\n                   cout << endl;*/\\n        }\\n        /*    for (int i = 1; i <= vv.size(); i++) {\\n                for (auto it : v[i]) {\\n                    cout << it.first << \" \" << it.second << endl;\\n                }\\n                cout << endl;\\n            }*/\\n        return v[vv.size()].back().second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         int n = nums.size();\\n        vector<pair<int, int>> v[n + 1];\\n        vector<int> vv;\\n        int len = 0;\\n        for (int x : nums) {\\n            if (vv.size()) {\\n                if (x > vv.back()) {\\n                    len++; vv.push_back(x);\\n                    //v[len].emplace_back(x, v[len - 1].back().second);\\n                    int lo = 0, hi = v[len - 1].size() - 1;\\n                    while (lo < hi) {\\n                        int mid = (lo + hi) / 2;\\n                        if (v[len - 1][mid].first >= x) {\\n                            lo = mid + 1;\\n                        }\\n                        else {\\n                            hi = mid;\\n                        }\\n                    }\\n                    v[len].emplace_back(x, v[len - 1].back().second - (hi > 0 ? v[len - 1][hi - 1].second : 0) );\\n                }\\n                else {\\n                    int it = lower_bound(vv.begin(), vv.end(), x) - vv.begin();\\n                    vv[it] = x;\\n                    int val = 0;\\n                    //calculate val\\n                    if (it == 0) {\\n                        val = 1;\\n                    }\\n                    else {\\n                        int lo = 0, hi = v[it].size() - 1;\\n                        while (lo < hi) {\\n                            int mid = (lo + hi) / 2;\\n                            if (v[it][mid].first >= x) {\\n                                lo = mid + 1;\\n                            }\\n                            else {\\n                                hi = mid;\\n                            }\\n                        }\\n                        //cout << it << endl;\\n                        val = v[it].back().second - (hi > 0 ? v[it][hi - 1].second : 0);\\n                    }\\n                    v[it + 1].emplace_back(x, val + v[it + 1].back().second);\\n                }\\n            }\\n            else {\\n                len++;\\n                vv.push_back(x);\\n                v[len].emplace_back(x, 1);\\n            }\\n            /*       for (int xx : vv) {\\n                       cout << xx << \" \";\\n                   }\\n                   cout << endl;*/\\n        }\\n        /*    for (int i = 1; i <= vv.size(); i++) {\\n                for (auto it : v[i]) {\\n                    cout << it.first << \" \" << it.second << endl;\\n                }\\n                cout << endl;\\n            }*/\\n        return v[vv.size()].back().second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1122110,
                "title": "c-segment-tree-o-nlogn-12ms-99-89-faster",
                "content": "It\\'s a litter bit hard to understand the offical solution explaining. \\n### Before we use the Segment tree\\nI think the logic is simple:\\nWe need to build an array x so that x[i] record two number which is lenth of LIS ending on value \\u201C**i**\\u201D(value, not the index in nums) and the number of such LIS. \\nTo build this array **x**,  we can update the array **x** when we visit the original array **nums** from left to right.\\n\\nWhen we visit nums[i], \\nwe need to update x[num[i]] = 1 + max(x[i]) (from x[min(nums)] to x[nums[i]-1])  (To be noticed again, this is different with dp array normally we used to solve LIS in N^2)\\n\\nYeah, so that\\'s it, then we just need to maintain this array x in the segment tree way. So that every operation done in log time.\\n\\n### Meaning of the node \\nSo basically our segment tree node if his range is from value \"l\" to value \"r\", then it will record length of the longest LIS ending in \"i\"( l<=i <= r) \\n(It\\'s easy to misunderstand that the node is representing the LIS within the range from l to r, that not correct, only the ending point is within that range)\\n\\n### For speed \\nDon\\'t forget to make it discrete first otherwise the NlogN  \\'s N will be 10^6 not the 2005\\n```\\n#define ll long long\\n#define lc (u<<1)\\n#define rc (u<<1|1)\\nconst int maxn = 2005;\\n\\ntypedef struct V {\\n    ll len, cnt;\\n}V;\\n\\ntypedef struct node {\\n    ll l, r; \\n    V v;\\n}node;\\nnode tree[maxn << 2];\\n\\nstruct IntervalTree {\\n    void build(ll u, ll l, ll r) {\\n        tree[u].l = l, tree[u].r = r; tree[u].v = (V) {0, 1};\\n        if (l == r) {\\n            tree[u].v.len = 0, tree[u].v.cnt = 1; return ;\\n        }\\n        ll m = l + (r - l) / 2;\\n        build(lc, l, m); build(rc, m+1, r);\\n    }\\n    \\n    V merge(V v1, V v2) {\\n        if (v2.len == v1.len) {\\n            if (v1.len == 0) return (V) {0, 1};\\n            return (V) {v1.len, v1.cnt + v2.cnt};\\n        }\\n        return v1.len > v2.len ? v1 : v2;\\n    }\\n    \\n    void update(ll u, int l, int r, V v) {\\n        if (tree[u].l > r || tree[u].r < l) return;\\n        if (l <= tree[u].l && tree[u].r <= r) {\\n            tree[u].v = merge(v, tree[u].v); return;\\n        }\\n        update(lc, l, r, v), update(rc, l, r, v);\\n        tree[u].v = merge(tree[lc].v, tree[rc].v);\\n    }\\n    \\n    V query(ll u, ll l, ll r) {\\n        if (r < tree[u].l || l > tree[u].r) return (V) {0, 1};\\n        if (l <= tree[u].l && tree[u].r <= r) return tree[u].v;\\n        return merge(query(lc, l, r), query(rc, l, r));\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // make it discrete\\n        vector<pair<int, int>> a;\\n        for (int i = 0; i < nums.size(); ++i) a.push_back(make_pair(nums[i], i));\\n        sort(a.begin(), a.end());  \\n        int end = unique(a.begin(), a.end()) - a.begin();\\n        unordered_map<int, int> rec;\\n        for (int i = 0; i < end; ++i) rec[a[i].first] = i; \\n        for (int i = 0; i < nums.size(); ++i) nums[i] = rec[nums[i]];\\n        \\n        // interval tree update and query\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto &num : nums) minn = min(minn, num), maxx = max(maxx, num);\\n        IntervalTree t;\\n        t.build(1, minn, maxx);\\n        for (auto &num : nums) {\\n            V v = t.query(1, minn, num-1);\\n            t.update(1, num, num, (V){v.len+1, v.cnt});\\n        }\\n        return tree[1].v.cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define lc (u<<1)\\n#define rc (u<<1|1)\\nconst int maxn = 2005;\\n\\ntypedef struct V {\\n    ll len, cnt;\\n}V;\\n\\ntypedef struct node {\\n    ll l, r; \\n    V v;\\n}node;\\nnode tree[maxn << 2];\\n\\nstruct IntervalTree {\\n    void build(ll u, ll l, ll r) {\\n        tree[u].l = l, tree[u].r = r; tree[u].v = (V) {0, 1};\\n        if (l == r) {\\n            tree[u].v.len = 0, tree[u].v.cnt = 1; return ;\\n        }\\n        ll m = l + (r - l) / 2;\\n        build(lc, l, m); build(rc, m+1, r);\\n    }\\n    \\n    V merge(V v1, V v2) {\\n        if (v2.len == v1.len) {\\n            if (v1.len == 0) return (V) {0, 1};\\n            return (V) {v1.len, v1.cnt + v2.cnt};\\n        }\\n        return v1.len > v2.len ? v1 : v2;\\n    }\\n    \\n    void update(ll u, int l, int r, V v) {\\n        if (tree[u].l > r || tree[u].r < l) return;\\n        if (l <= tree[u].l && tree[u].r <= r) {\\n            tree[u].v = merge(v, tree[u].v); return;\\n        }\\n        update(lc, l, r, v), update(rc, l, r, v);\\n        tree[u].v = merge(tree[lc].v, tree[rc].v);\\n    }\\n    \\n    V query(ll u, ll l, ll r) {\\n        if (r < tree[u].l || l > tree[u].r) return (V) {0, 1};\\n        if (l <= tree[u].l && tree[u].r <= r) return tree[u].v;\\n        return merge(query(lc, l, r), query(rc, l, r));\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // make it discrete\\n        vector<pair<int, int>> a;\\n        for (int i = 0; i < nums.size(); ++i) a.push_back(make_pair(nums[i], i));\\n        sort(a.begin(), a.end());  \\n        int end = unique(a.begin(), a.end()) - a.begin();\\n        unordered_map<int, int> rec;\\n        for (int i = 0; i < end; ++i) rec[a[i].first] = i; \\n        for (int i = 0; i < nums.size(); ++i) nums[i] = rec[nums[i]];\\n        \\n        // interval tree update and query\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto &num : nums) minn = min(minn, num), maxx = max(maxx, num);\\n        IntervalTree t;\\n        t.build(1, minn, maxx);\\n        for (auto &num : nums) {\\n            V v = t.query(1, minn, num-1);\\n            t.update(1, num, num, (V){v.len+1, v.cnt});\\n        }\\n        return tree[1].v.cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916236,
                "title": "c-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (nums.size() <= 1)\\n            return nums.size();\\n        \\n        vector<int> dp_len(n, 1);\\n        vector<int> dp_count(n, 1);\\n        \\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (dp_len[i] <= dp_len[j]){\\n                        dp_len[i] = dp_len[j]+1;\\n                        dp_count[i] = dp_count[j];\\n                    }\\n                    else if (dp_len[j]+1 == dp_len[i])\\n                        dp_count[i] += dp_count[j];\\n                }\\n            }\\n        }\\n        \\n        int max_length = *max_element(dp_len.begin(), dp_len.end());\\n        int res = 0;\\n        for (int i=0; i<n; i++) {\\n            if (dp_len[i] == max_length)\\n                res += dp_count[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (nums.size() <= 1)\\n            return nums.size();\\n        \\n        vector<int> dp_len(n, 1);\\n        vector<int> dp_count(n, 1);\\n        \\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (dp_len[i] <= dp_len[j]){\\n                        dp_len[i] = dp_len[j]+1;\\n                        dp_count[i] = dp_count[j];\\n                    }\\n                    else if (dp_len[j]+1 == dp_len[i])\\n                        dp_count[i] += dp_count[j];\\n                }\\n            }\\n        }\\n        \\n        int max_length = *max_element(dp_len.begin(), dp_len.end());\\n        int res = 0;\\n        for (int i=0; i<n; i++) {\\n            if (dp_len[i] == max_length)\\n                res += dp_count[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228153,
                "title": "c-8ms-o-n-log-n-beats-100-queue-easy-to-understand",
                "content": "Here is how it works. Suppose the input array is **A** (not using **nums** to make code shorter), and the length of the input array is **m**. Using LIS algorithm, when sweeping the **A** from left to right, we can calculate the length of longest LIS eding at each index **i**. Assume the longest LIS ending at **i** is **L[i]**, and the number of LISs ending at **i** with length being **L[i]** is **F[i]**. \\nThen **F[i]**  is a summation of all **F[j]**\\'s such that **j<i** and **A[j]<A[i]** and **L[j]**=**L[i]-1**. As you can see that here we are imposing three constraints simulataneously. A naive DP method would run **j** from 0 to **i-1** so that to calculate **F[i]**. The trick that makes my algorithm diverge from the naive method is to define a vector of queues, i.e. vector<queue<int>> **vq**. The length of **vq** when we are sweeping at **i** is the length of the longest LISs we have got so far (not necessary **L[i]**). **vq[len-1]** is a queue of indices such that the length of longest LISs ending at these indices is **len**. Since we are sweeping **i** from **0** to **m-1**, the indices in the queue have an increasing order, but the values of **A** at these indices are decreasing. This stems from the fact that if **i<j** and **L[i]==L[j]**, then we must have **A[i]>=A[j]**. Since all the queues are used to store indices, therefore the total memory for **vq** is O(N).\\nLet **sumq** be an arrary, **sumq[len-1]** is the summation of all **F[k]** such that **k** runs over the indices stored within the queue denoted by **vq[len-1]**. At index **i**, our LIS length is **len**, to calculate **F[i]**, we need to sum up **vq[len-2]**. We may have to pop the front element in **vq[len-2]** since **A[vq[len-2].front()]** may be no smaller than **A[i]**. Because the queue is monotonic, the popped indices will never need to come back, that why this algorithm is faster. \\nThe other part of the code is easily understandable. After having **F[i]**, we push **i** as an index into **vq[len-1]**, and it contributes to **sumq[len-1]**.\\n\\nHaving run through the array **A**, we just need to return the last element of **sumq**, which is by definition the number of longest LISs in the array.\\n\\n    int helper(const vector<int> & A){\\n        const int m = A.size();\\n        if(m<2)\\n            return m;\\n        \\n        vector<int> B;\\n        vector<int> F(m,0);\\n        vector<int> sumq;\\n        vector<queue<int>> vq;\\n        \\n        for(int i = 0; i < m; i++){\\n            int len = 0;\\n            auto it = lower_bound(B.begin(),B.end(),A[i]);\\n            if(it==B.end())\\n                B.push_back(A[i]), len = B.size();\\n            else\\n                *it = A[i], len = (int)(it-B.begin())+1;\\n            \\n            if(len>vq.size())\\n                vq.push_back(queue<int>()), sumq.push_back(0);\\n            \\n            while(len>1&&A[vq[len-2].front()]>=A[i])\\n                sumq[len-2]-=F[vq[len-2].front()],vq[len-2].pop();\\n            F[i] = (len==1)? 1 : sumq[len-2];\\n            vq[len-1].push(i);\\n            sumq[len-1] += F[i];\\n        }\\n        \\n        return sumq.back();\\n    }",
                "solutionTags": [],
                "code": "Here is how it works. Suppose the input array is **A** (not using **nums** to make code shorter), and the length of the input array is **m**. Using LIS algorithm, when sweeping the **A** from left to right, we can calculate the length of longest LIS eding at each index **i**. Assume the longest LIS ending at **i** is **L[i]**, and the number of LISs ending at **i** with length being **L[i]** is **F[i]**. \\nThen **F[i]**  is a summation of all **F[j]**\\'s such that **j<i** and **A[j]<A[i]** and **L[j]**=**L[i]-1**. As you can see that here we are imposing three constraints simulataneously. A naive DP method would run **j** from 0 to **i-1** so that to calculate **F[i]**. The trick that makes my algorithm diverge from the naive method is to define a vector of queues, i.e. vector<queue<int>> **vq**. The length of **vq** when we are sweeping at **i** is the length of the longest LISs we have got so far (not necessary **L[i]**). **vq[len-1]** is a queue of indices such that the length of longest LISs ending at these indices is **len**. Since we are sweeping **i** from **0** to **m-1**, the indices in the queue have an increasing order, but the values of **A** at these indices are decreasing. This stems from the fact that if **i<j** and **L[i]==L[j]**, then we must have **A[i]>=A[j]**. Since all the queues are used to store indices, therefore the total memory for **vq** is O(N).\\nLet **sumq** be an arrary, **sumq[len-1]** is the summation of all **F[k]** such that **k** runs over the indices stored within the queue denoted by **vq[len-1]**. At index **i**, our LIS length is **len**, to calculate **F[i]**, we need to sum up **vq[len-2]**. We may have to pop the front element in **vq[len-2]** since **A[vq[len-2].front()]** may be no smaller than **A[i]**. Because the queue is monotonic, the popped indices will never need to come back, that why this algorithm is faster. \\nThe other part of the code is easily understandable. After having **F[i]**, we push **i** as an index into **vq[len-1]**, and it contributes to **sumq[len-1]**.\\n\\nHaving run through the array **A**, we just need to return the last element of **sumq**, which is by definition the number of longest LISs in the array.\\n\\n    int helper(const vector<int> & A){\\n        const int m = A.size();\\n        if(m<2)\\n            return m;\\n        \\n        vector<int> B;\\n        vector<int> F(m,0);\\n        vector<int> sumq;\\n        vector<queue<int>> vq;\\n        \\n        for(int i = 0; i < m; i++){\\n            int len = 0;\\n            auto it = lower_bound(B.begin(),B.end(),A[i]);\\n            if(it==B.end())\\n                B.push_back(A[i]), len = B.size();\\n            else\\n                *it = A[i], len = (int)(it-B.begin())+1;\\n            \\n            if(len>vq.size())\\n                vq.push_back(queue<int>()), sumq.push_back(0);\\n            \\n            while(len>1&&A[vq[len-2].front()]>=A[i])\\n                sumq[len-2]-=F[vq[len-2].front()],vq[len-2].pop();\\n            F[i] = (len==1)? 1 : sumq[len-2];\\n            vq[len-1].push(i);\\n            sumq[len-1] += F[i];\\n        }\\n        \\n        return sumq.back();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3794819,
                "title": "c-recursive-iterative-dp-beats-81-1-92-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlone LIS is easy, but the number of LIS is much harder. Use DP to solve! It needs 2 arrays. One for LIS, the other for counting!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe recursive solution is not slow and beats 81.1%. The iterative one is a little bit faster, beats 92.9%.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS(int i, vector<int>& nums){\\n        if (i==0){\\n            dp[0]=1;\\n            count[0]=1;\\n            return ;\\n        }\\n        if (count[i]!=-1) return;\\n        dp[i]=1;\\n        count[i]=1;\\n        for(int j=0; j<i; j++){\\n            if(nums[i]>nums[j]){\\n                LIS(j, nums);\\n                if (dp[i]<dp[j]+1) {\\n                    dp[i]=dp[j]+1;\\n                    count[i]=count[j];\\n                }\\n                else if (dp[i]==dp[j]+1){\\n                    count[i]+=count[j];   \\n                }    \\n            }      \\n        }\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        dp.assign(n,-1);\\n        count.assign(n, -1);\\n        for(int i=0; i<n; i++)\\n            LIS(i, nums);\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```\\n# code for buttom up solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS_bottom_up(vector<int>& nums, int n){\\n        dp.assign(n, 1);\\n        count.assign(n, 1);\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j]){\\n                    if (dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if (dp[i]==dp[j]+1){\\n                        count[i]+=count[j];   \\n                    }    \\n                }      \\n            }\\n        } \\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        LIS_bottom_up(nums, n);\\n\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS(int i, vector<int>& nums){\\n        if (i==0){\\n            dp[0]=1;\\n            count[0]=1;\\n            return ;\\n        }\\n        if (count[i]!=-1) return;\\n        dp[i]=1;\\n        count[i]=1;\\n        for(int j=0; j<i; j++){\\n            if(nums[i]>nums[j]){\\n                LIS(j, nums);\\n                if (dp[i]<dp[j]+1) {\\n                    dp[i]=dp[j]+1;\\n                    count[i]=count[j];\\n                }\\n                else if (dp[i]==dp[j]+1){\\n                    count[i]+=count[j];   \\n                }    \\n            }      \\n        }\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        dp.assign(n,-1);\\n        count.assign(n, -1);\\n        for(int i=0; i<n; i++)\\n            LIS(i, nums);\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS_bottom_up(vector<int>& nums, int n){\\n        dp.assign(n, 1);\\n        count.assign(n, 1);\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j]){\\n                    if (dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if (dp[i]==dp[j]+1){\\n                        count[i]+=count[j];   \\n                    }    \\n                }      \\n            }\\n        } \\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        LIS_bottom_up(nums, n);\\n\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3317146,
                "title": "673-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize two arrays, dp and count, of length equal to the length of nums, with values of 1.\\n2. Iterate over each index i in the range 0 to the length of nums.\\n3. For each index i, iterate over all indices j before i in the range 0 to i.\\n4. Check if the element at index i in nums is greater than the element at index j in nums.\\n5. If the element at index i is greater than the element at index j, check if the length of the longest increasing subsequence ending at j plus 1 is greater than the length of the longest increasing subsequence ending at i. If it is, update the length of the longest increasing subsequence ending at i to dp[j] + 1 and update the number of such subsequences ending at i to count[j].\\n6. If the length of the longest increasing subsequence ending at j plus 1 is equal to the length of the longest increasing subsequence ending at i, add the number of such subsequences ending at j to the number of such subsequences ending at i.\\n7. Find the maximum value in the dp array and assign it to the variable max_len.\\n8. Return the sum of the values in the count array for all indices i where dp[i] is equal to max_len.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findNumberOfLIS(self, nums: List[int]) -> int:\\n    # initialize two arrays to store the length of the longest increasing subsequence\\n    # and the number of such subsequences ending at each index\\n    dp = [1] * len(nums)\\n    count = [1] * len(nums)\\n    # iterate over the input array\\n    for i in range(len(nums)):\\n        # iterate over all indices before i\\n        for j in range(i):\\n            # check if the current element at i is greater than the element at j\\n            if nums[i] > nums[j]:\\n                # if the length of the LIS ending at j plus 1 is greater than\\n                # the length of the LIS ending at i, update the length of the LIS ending at i\\n                if dp[j] + 1 > dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    # update the number of subsequences ending at i\\n                    count[i] = count[j]\\n                # if the length of the LIS ending at j plus 1 is equal to\\n                # the length of the LIS ending at i, add the number of subsequences\\n                # ending at j to the number of subsequences ending at i\\n                elif dp[j] + 1 == dp[i]:\\n                    count[i] += count[j]\\n\\n    # find the length of the longest increasing subsequence\\n    max_len = max(dp)\\n    # find the number of subsequences with length equal to the length of the longest increasing subsequence\\n    return sum([count[i] for i in range(len(nums)) if dp[i] == max_len])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n  def findNumberOfLIS(self, nums: List[int]) -> int:\\n    # initialize two arrays to store the length of the longest increasing subsequence\\n    # and the number of such subsequences ending at each index\\n    dp = [1] * len(nums)\\n    count = [1] * len(nums)\\n    # iterate over the input array\\n    for i in range(len(nums)):\\n        # iterate over all indices before i\\n        for j in range(i):\\n            # check if the current element at i is greater than the element at j\\n            if nums[i] > nums[j]:\\n                # if the length of the LIS ending at j plus 1 is greater than\\n                # the length of the LIS ending at i, update the length of the LIS ending at i\\n                if dp[j] + 1 > dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    # update the number of subsequences ending at i\\n                    count[i] = count[j]\\n                # if the length of the LIS ending at j plus 1 is equal to\\n                # the length of the LIS ending at i, add the number of subsequences\\n                # ending at j to the number of subsequences ending at i\\n                elif dp[j] + 1 == dp[i]:\\n                    count[i] += count[j]\\n\\n    # find the length of the longest increasing subsequence\\n    max_len = max(dp)\\n    # find the number of subsequences with length equal to the length of the longest increasing subsequence\\n    return sum([count[i] for i in range(len(nums)) if dp[i] == max_len])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099341,
                "title": "dp-with-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // vector dp stores length of lonegst inc subseq ending with nums[i]\\n        // vector cnt stores the number of subsequences of length dp[i]\\n        vector<int>dp(nums.size(),1),cnt(nums.size(),1);\\n        int mxLen=1,res=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            for(int j = 0; j < i; j++){\\n                \\n                // if nums[j] < nums[i] we are sure that we can append nums[i] \\n                if(nums[i] > nums[j]){\\n                    \\n                    // append nums[i] only if length is incresed\\n                    if(dp[j]+1 > dp[i]){\\n                    dp[i] = dp[j]+1;\\n                    cnt[i] = cnt[j];\\n                    }\\n                    // if appending nums[i] after nums[j] gives length equal to dp[i] -> means there exists more number of ways to design subseq of this length so adding them to cnt[i]\\n                    else if(dp[j]+1 == dp[i])\\n                        cnt[i] += cnt[j];\\n                    }\\n            }\\n            // to store maxLen\\n            mxLen = max(mxLen, dp[i]);\\n        }\\n        //counting total number of ways to design subseq of length mxLen\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i] == mxLen)\\n                res += cnt[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // vector dp stores length of lonegst inc subseq ending with nums[i]\\n        // vector cnt stores the number of subsequences of length dp[i]\\n        vector<int>dp(nums.size(),1),cnt(nums.size(),1);\\n        int mxLen=1,res=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            for(int j = 0; j < i; j++){\\n                \\n                // if nums[j] < nums[i] we are sure that we can append nums[i] \\n                if(nums[i] > nums[j]){\\n                    \\n                    // append nums[i] only if length is incresed\\n                    if(dp[j]+1 > dp[i]){\\n                    dp[i] = dp[j]+1;\\n                    cnt[i] = cnt[j];\\n                    }\\n                    // if appending nums[i] after nums[j] gives length equal to dp[i] -> means there exists more number of ways to design subseq of this length so adding them to cnt[i]\\n                    else if(dp[j]+1 == dp[i])\\n                        cnt[i] += cnt[j];\\n                    }\\n            }\\n            // to store maxLen\\n            mxLen = max(mxLen, dp[i]);\\n        }\\n        //counting total number of ways to design subseq of length mxLen\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i] == mxLen)\\n                res += cnt[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107298,
                "title": "java-with-explanation-easy-to-understand",
                "content": "\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n        int[] maxLens = new int[nums.length];// length of longest increasing sequence start from i\\n        int[] counts = new int[nums.length]; // number of length of longest increasing sequence start from i\\n        int maxLen = 1; // length of longest increasing subsequnce\\n        maxLens[nums.length-1] = 1;\\n        counts[nums.length-1] = 1;\\n\\n        for(int i = nums.length -2; i>=0; i--){//Backward iteration, i is used as the first character\\n            int curMax = 1;\\n            int count = 1;\\n            for(int j = i+1; j < nums.length; j++) {//j is used as the second character\\n                if(nums[i] < nums[j]){//increasing number\\n                    if (curMax == maxLens[j]+1)//means have another way to reach the same max length increasing sequence\\n                        count += counts[j];  //Important: not ++\\n                    else if (curMax < maxLens[j]+1){\\n                        count = counts[j]; \\n                        curMax = maxLens[j]+1; \\n                    }\\n                }\\n            }\\n            maxLens[i] = curMax;\\n            counts[i] = count;\\n            maxLen = Math.max(maxLen, curMax);\\n        }\\n        int count = 0;\\n        for(int i = 0; i< maxLens.length; i++){//check each possible start position\\n            if (maxLens[i] == maxLen)\\n                count += counts[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n        int[] maxLens = new int[nums.length];// length of longest increasing sequence start from i\\n        int[] counts = new int[nums.length]; // number of length of longest increasing sequence start from i\\n        int maxLen = 1; // length of longest increasing subsequnce\\n        maxLens[nums.length-1] = 1;\\n        counts[nums.length-1] = 1;\\n\\n        for(int i = nums.length -2; i>=0; i--){//Backward iteration, i is used as the first character\\n            int curMax = 1;\\n            int count = 1;\\n            for(int j = i+1; j < nums.length; j++) {//j is used as the second character\\n                if(nums[i] < nums[j]){//increasing number\\n                    if (curMax == maxLens[j]+1)//means have another way to reach the same max length increasing sequence\\n                        count += counts[j];  //Important: not ++\\n                    else if (curMax < maxLens[j]+1){\\n                        count = counts[j]; \\n                        curMax = maxLens[j]+1; \\n                    }\\n                }\\n            }\\n            maxLens[i] = curMax;\\n            counts[i] = count;\\n            maxLen = Math.max(maxLen, curMax);\\n        }\\n        int count = 0;\\n        for(int i = 0; i< maxLens.length; i++){//check each possible start position\\n            if (maxLens[i] == maxLen)\\n                count += counts[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798081,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing Dynamic Programming to keep longest subsequences every iteration.\\nThis solution beats 97%. \\n\\n![Screen Shot 2023-07-22 at 2.26.47.png](https://assets.leetcode.com/users/images/4be94a80-06ec-46af-980a-56e4df41c2f0_1689960430.558125.png)\\n\\n---\\n\\n# Solution Video\\n*** Please upvote for this article. *** \\n\\nhttps://youtu.be/EP4CeEoxkwY\\n\\n# Subscribe to my channel from here. I have 226 videos as of July 22th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other languages might be different.\\n\\n1. Initialize the `dp` dictionary with a `defaultdict` of `Counter`. This dictionary will store the number of increasing subsequences (LIS) of different lengths, and each LIS length will be associated with a Counter object that counts the occurrences of different ending numbers for that LIS length.\\n\\n2. Initialize `dp[-1][-float(\"inf\")] = 1`. This is a special entry in the `dp` dictionary to handle the case when the LIS length is 0. Here, `-float(\"inf\")` is used as a unique key to represent LIS length 0, and the count is set to 1, as there is only one empty LIS.\\n\\n3. Initialize an empty list `sorted_nums`. This list will be used to keep track of the elements of the input `nums` list in sorted order, to find the correct insertion position for each number.\\n\\n4. Loop through each number `num` in the `nums` list:\\n   a. Find the index `insert_index` using `bisect.bisect_left(sorted_nums, num)` where `sorted_nums` is treated as a sorted list. This index represents the correct position to insert the current number `num` to maintain the sorted order.\\n   b. If `insert_index` is equal to the length of `sorted_nums`, it means the current number is greater than all elements in `sorted_nums`, so we append it to the end of `sorted_nums`.\\n   c. Otherwise, if `insert_index` is within the range of `sorted_nums`, it means the current number needs to be inserted at a specific position in `sorted_nums`, so we update the element at `insert_index` with the current number.\\n   d. Initialize `total` to 0, which will be used to store the count of all possible LIS of length `insert_index` ending with the current number `num`.\\n   e. Loop through each previous number `prev_num` in the LIS of length `insert_index - 1`:\\n      - If `prev_num` is less than the current number `num`, then it can be a valid ending number for the LIS of length `insert_index`.\\n      - We add the count of LIS of length `insert_index - 1` ending with `prev_num` to the `total`.\\n   f. Update the `dp[insert_index][num]` entry by adding the `total` to it. This represents the count of LIS of length `insert_index` ending with the current number `num`.\\n\\n5. Finally, return the sum of all values in the `dp` dictionary for the last length `len(sorted_nums) - 1`, which represents the total count of all possible LIS of the longest length.\\n\\nIn summary, the algorithm dynamically computes the number of increasing subsequences of different lengths using a combination of `sorted_nums` to find the correct position for each number and the `dp` dictionary to store the counts. The approach efficiently calculates the number of LIS by considering the increasing property and reusing the counts of shorter subsequences to determine the counts of longer subsequences.\\n\\n# Complexity\\nThis is based on Python code. Other languages might be different.\\n\\n- Time complexity: O(n log n) or O(n^2)\\nTheoretically, O(n^2) but in reality O(n log n). I didn\\'t come up with O(n^2) case. Let me know if you find the case.\\n\\n- Space complexity: O(n)\\nThere is possiblity that I put data into dp and sorted_nums at most n.\\n\\n```python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = defaultdict(Counter)\\n        dp[-1][-float(\"inf\")] = 1\\n        sorted_nums = []\\n\\n        for num in nums:\\n            insert_index = bisect.bisect_left(sorted_nums, num)\\n            if insert_index == len(sorted_nums):\\n                sorted_nums.append(num)\\n            else:\\n                sorted_nums[insert_index] = num\\n\\n            total = 0\\n            for prev_num in dp[insert_index - 1]:\\n                if prev_num < num:\\n                    total += dp[insert_index - 1][prev_num]\\n            \\n            dp[insert_index][num] += total\\n        \\n        return sum(dp[len(sorted_nums) - 1].values())\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNumberOfLIS = function(nums) {\\n    var dp = new Map();\\n    dp.set(-1, new Map());\\n    dp.get(-1).set(-Infinity, 1);\\n    var sortedNums = [];\\n\\n    for (var num of nums) {\\n        var insertIndex = bisectLeft(sortedNums, num);\\n        if (insertIndex === sortedNums.length) {\\n            sortedNums.push(num);\\n        } else {\\n            sortedNums[insertIndex] = num;\\n        }\\n\\n        var total = 0;\\n        for (var [prevNum, count] of dp.get(insertIndex - 1).entries()) {\\n            if (prevNum < num) {\\n                total += count;\\n            }\\n        }\\n        dp.set(insertIndex, dp.get(insertIndex) || new Map());\\n        dp.get(insertIndex).set(num, (dp.get(insertIndex).get(num) || 0) + total);\\n    }\\n\\n    var result = 0;\\n    for (var count of dp.get(sortedNums.length - 1).values()) {\\n        result += count;\\n    }\\n    return result;    \\n};\\n\\nvar bisectLeft = function(arr, target) {\\n    var left = 0;\\n    var right = arr.length;\\n\\n    while (left < right) {\\n        var mid = Math.floor((left + right) / 2);\\n        if (arr[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return left;\\n};\\n```\\n```java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        Map<Integer, Map<Integer, Integer>> dp = new HashMap<>();\\n        dp.put(-1, new HashMap<>());\\n        dp.get(-1).put(Integer.MIN_VALUE, 1);\\n        List<Integer> sortedNums = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.add(num);\\n            } else {\\n                sortedNums.set(insertIndex, num);\\n            }\\n\\n            int total = 0;\\n            for (Map.Entry<Integer, Integer> entry : dp.getOrDefault(insertIndex - 1, new HashMap<>()).entrySet()) {\\n                int prevNum = entry.getKey();\\n                int count = entry.getValue();\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp.putIfAbsent(insertIndex, new HashMap<>());\\n            dp.get(insertIndex).put(num, dp.getOrDefault(insertIndex, new HashMap<>()).getOrDefault(num, 0) + total);\\n        }\\n\\n        int result = 0;\\n        for (int count : dp.getOrDefault(sortedNums.size() - 1, new HashMap<>()).values()) {\\n            result += count;\\n        }\\n        return result; \\n    }\\n\\n    private int bisectLeft(List<Integer> arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr.get(mid) < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }  \\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        std::unordered_map<int, std::map<int, int>> dp;\\n        dp[-1][-INT_MAX] = 1;\\n        std::vector<int> sortedNums;\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.push_back(num);\\n            } else {\\n                sortedNums[insertIndex] = num;\\n            }\\n\\n            int total = 0;\\n            for (const auto& entry : dp[insertIndex - 1]) {\\n                int prevNum = entry.first;\\n                int count = entry.second;\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp[insertIndex][num] += total;\\n        }\\n\\n        int result = 0;\\n        for (const auto& entry : dp[sortedNums.size() - 1]) {\\n            result += entry.second;\\n        }\\n        return result;        \\n    }\\n\\nprivate:\\n    int bisectLeft(const std::vector<int>& arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = defaultdict(Counter)\\n        dp[-1][-float(\"inf\")] = 1\\n        sorted_nums = []\\n\\n        for num in nums:\\n            insert_index = bisect.bisect_left(sorted_nums, num)\\n            if insert_index == len(sorted_nums):\\n                sorted_nums.append(num)\\n            else:\\n                sorted_nums[insert_index] = num\\n\\n            total = 0\\n            for prev_num in dp[insert_index - 1]:\\n                if prev_num < num:\\n                    total += dp[insert_index - 1][prev_num]\\n            \\n            dp[insert_index][num] += total\\n        \\n        return sum(dp[len(sorted_nums) - 1].values())\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNumberOfLIS = function(nums) {\\n    var dp = new Map();\\n    dp.set(-1, new Map());\\n    dp.get(-1).set(-Infinity, 1);\\n    var sortedNums = [];\\n\\n    for (var num of nums) {\\n        var insertIndex = bisectLeft(sortedNums, num);\\n        if (insertIndex === sortedNums.length) {\\n            sortedNums.push(num);\\n        } else {\\n            sortedNums[insertIndex] = num;\\n        }\\n\\n        var total = 0;\\n        for (var [prevNum, count] of dp.get(insertIndex - 1).entries()) {\\n            if (prevNum < num) {\\n                total += count;\\n            }\\n        }\\n        dp.set(insertIndex, dp.get(insertIndex) || new Map());\\n        dp.get(insertIndex).set(num, (dp.get(insertIndex).get(num) || 0) + total);\\n    }\\n\\n    var result = 0;\\n    for (var count of dp.get(sortedNums.length - 1).values()) {\\n        result += count;\\n    }\\n    return result;    \\n};\\n\\nvar bisectLeft = function(arr, target) {\\n    var left = 0;\\n    var right = arr.length;\\n\\n    while (left < right) {\\n        var mid = Math.floor((left + right) / 2);\\n        if (arr[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return left;\\n};\\n```\n```java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        Map<Integer, Map<Integer, Integer>> dp = new HashMap<>();\\n        dp.put(-1, new HashMap<>());\\n        dp.get(-1).put(Integer.MIN_VALUE, 1);\\n        List<Integer> sortedNums = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.add(num);\\n            } else {\\n                sortedNums.set(insertIndex, num);\\n            }\\n\\n            int total = 0;\\n            for (Map.Entry<Integer, Integer> entry : dp.getOrDefault(insertIndex - 1, new HashMap<>()).entrySet()) {\\n                int prevNum = entry.getKey();\\n                int count = entry.getValue();\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp.putIfAbsent(insertIndex, new HashMap<>());\\n            dp.get(insertIndex).put(num, dp.getOrDefault(insertIndex, new HashMap<>()).getOrDefault(num, 0) + total);\\n        }\\n\\n        int result = 0;\\n        for (int count : dp.getOrDefault(sortedNums.size() - 1, new HashMap<>()).values()) {\\n            result += count;\\n        }\\n        return result; \\n    }\\n\\n    private int bisectLeft(List<Integer> arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr.get(mid) < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }  \\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        std::unordered_map<int, std::map<int, int>> dp;\\n        dp[-1][-INT_MAX] = 1;\\n        std::vector<int> sortedNums;\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.push_back(num);\\n            } else {\\n                sortedNums[insertIndex] = num;\\n            }\\n\\n            int total = 0;\\n            for (const auto& entry : dp[insertIndex - 1]) {\\n                int prevNum = entry.first;\\n                int count = entry.second;\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp[insertIndex][num] += total;\\n        }\\n\\n        int result = 0;\\n        for (const auto& entry : dp[sortedNums.size() - 1]) {\\n            result += entry.second;\\n        }\\n        return result;        \\n    }\\n\\nprivate:\\n    int bisectLeft(const std::vector<int>& arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795913,
                "title": "0-1-knapsack-dp-memoization-java-clean-code",
                "content": "# Approach\\nSubsequence problems can be done by pick or not-pick approach. I found everyone solving it using tabulation so I gave memoiation a try. It worked. Do upvote if you understood.\\n\\n# Complexity\\n- Time complexity: $$O(n * n)$$ (Recursion)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * n * 2)$$ (DP) + $$O(n)$$ (Stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private record Pair(int length, int count) {}\\n    private int n;\\n    private Pair[][] dp;\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        n = nums.length;\\n        dp = new Pair[n][n+1];\\n        return solve(0, -1, nums).count();\\n    }\\n\\n    private Pair solve(int idx, int prev, int[] nums) {\\n        if(idx == n) return new Pair(0, 1);\\n        if(dp[idx][prev + 1] != null) return dp[idx][prev + 1];\\n        Pair notPick = solve(idx + 1, prev, nums);\\n        int notPickLen = notPick.length();\\n        int notPickCount = notPick.count();\\n        int pickLen = 0;\\n        int pickCount = 0;\\n        if(prev == -1 || nums[idx] > nums[prev]) {\\n            Pair pick = solve(idx + 1, idx, nums);\\n            pickLen = pick.length() + 1;\\n            pickCount = pick.count();\\n        }\\n        Pair res = null;\\n        if(pickLen == notPickLen) {\\n            res = new Pair(pickLen, pickCount + notPickCount);\\n        }\\n        else if(pickLen > notPickLen) {\\n            res = new Pair(pickLen, pickCount);\\n        }\\n        else {\\n            res = new Pair(notPickLen, notPickCount);\\n        }\\n        return dp[idx][prev + 1] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private record Pair(int length, int count) {}\\n    private int n;\\n    private Pair[][] dp;\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        n = nums.length;\\n        dp = new Pair[n][n+1];\\n        return solve(0, -1, nums).count();\\n    }\\n\\n    private Pair solve(int idx, int prev, int[] nums) {\\n        if(idx == n) return new Pair(0, 1);\\n        if(dp[idx][prev + 1] != null) return dp[idx][prev + 1];\\n        Pair notPick = solve(idx + 1, prev, nums);\\n        int notPickLen = notPick.length();\\n        int notPickCount = notPick.count();\\n        int pickLen = 0;\\n        int pickCount = 0;\\n        if(prev == -1 || nums[idx] > nums[prev]) {\\n            Pair pick = solve(idx + 1, idx, nums);\\n            pickLen = pick.length() + 1;\\n            pickCount = pick.count();\\n        }\\n        Pair res = null;\\n        if(pickLen == notPickLen) {\\n            res = new Pair(pickLen, pickCount + notPickCount);\\n        }\\n        else if(pickLen > notPickLen) {\\n            res = new Pair(pickLen, pickCount);\\n        }\\n        else {\\n            res = new Pair(notPickLen, notPickCount);\\n        }\\n        return dp[idx][prev + 1] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795332,
                "title": "c-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every index store the longest subsequence & also the count of all ways to reach that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGo to every index (1st loop) and look for the longest subsequence from the start (2nd loop). Check for the strictly increasing number and store the longest count (up until that index) in dp. (Every time we get a better length, increase the dp count by 1) And in count, store number of ways to reach that count (this shows number of subsequences can be formed). Keep track of the longest subsequence and update it and store the total number in your answer and return.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008255,
                "title": "simple-java-solution-using-lis-logic-with-comments",
                "content": "Can refer for classic lis ->\\nhttps://leetcode.com/problems/longest-increasing-subsequence/solutions/1778046/detailed-java-solution-from-brute-force-to-iterative-with-explaination/\\n\\nFor this problem ->\\ndp[i]: the length of the Longest Increasing Subsequence which ends with nums[i].\\ndp array will work as similar to lis.\\n\\ncount[i]: the number of the Longest Increasing Subsequence which ends with nums[i].\\n\\nmaxLength will hold overall length of the Longest Increasing Subsequence.\\n\\nIdea is to prepare count array side by side and at last once both loop finishes, we have maxLength ready. just count the values present at ith index which has maxLength in dp array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        int[] count = new int[nums.length];\\n        int maxLength=0;\\n        for(int i=0;i<nums.length;i++) {\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=0;j<i;j++) {\\n                if(nums[i]>nums[j]) {\\n                    //if current element can be added to dp array.\\n                    if(dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        //count is copied directly bcz, it is creating new sequence by adding jth element. and hence whatever the count of lis j has, now i will also has\\n                        count[i]=count[j];\\n                    } else if(dp[i]==dp[j]+1) {\\n                        //it means same length lis found again. hence update count wih total occurence of jth element.\\n                        count[i]+=count[j];\\n                    } \\n                }\\n            }\\n            //hold overall max length lis\\n            maxLength=Math.max(maxLength,dp[i]);\\n        }\\n    //once we have maxLength ready. we can check which indexes has same max length. and just add count of such indexes.\\n        int ans=0;\\n        for(int i=0;i<dp.length;i++) {\\n            if(dp[i]==maxLength) {\\n                ans+=count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nCan refer below video for detail explaination ->\\n\\nhttps://www.youtube.com/watch?v=cKVl1TFdNXg",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        int[] count = new int[nums.length];\\n        int maxLength=0;\\n        for(int i=0;i<nums.length;i++) {\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=0;j<i;j++) {\\n                if(nums[i]>nums[j]) {\\n                    //if current element can be added to dp array.\\n                    if(dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        //count is copied directly bcz, it is creating new sequence by adding jth element. and hence whatever the count of lis j has, now i will also has\\n                        count[i]=count[j];\\n                    } else if(dp[i]==dp[j]+1) {\\n                        //it means same length lis found again. hence update count wih total occurence of jth element.\\n                        count[i]+=count[j];\\n                    } \\n                }\\n            }\\n            //hold overall max length lis\\n            maxLength=Math.max(maxLength,dp[i]);\\n        }\\n    //once we have maxLength ready. we can check which indexes has same max length. and just add count of such indexes.\\n        int ans=0;\\n        for(int i=0;i<dp.length;i++) {\\n            if(dp[i]==maxLength) {\\n                ans+=count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182375,
                "title": "detailed-line-by-line-explanation-with-comments-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    public:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size(); //finding the size of nums\\n        \\n        if(n <= 1) return n; //less than one length return n\\n        \\n        vector<int> dp(n+1, 1); //will count the length of the LIS till the current index\\n        vector<int> cnt(n+1, 1);// number of LIS till this index\\n        \\n        dp[0] = 1; //the length can be only 1 until the first element obviously\\n        int maxLen = 1; //maximum length will start at 1\\n        \\n        for(int i = 1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n        \\n                if(nums[j] < nums[i]) //from j to i is an increasing subsequence\\n                {\\n                    if(dp[j] == dp[i]) //lenght of lis ill j is same as length of lis till i as of yet\\n                    {\\n                        \\n                        dp[i] = dp[j] + 1; //this is one length extra since i is a new element now included in the lis uptill j to becoome lis till i\\n                        cnt[i] = cnt[j];\\n                        //the lis till j will be same as lis till i as this is not a new lis but an extension of lis till j, a new element is added in the same lis\\n                    }\\n                    else if (dp[j] + 1 == dp[i])\\n                    {\\n                        cnt[i] += cnt[j];\\n                        //all this lis till j will now be lis till i since this is a new lis not just an addition to previous lis, the lis uptill i wasof some length from some other jth element, this is another addition to the same lis\\n                    }                      \\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n;i++){\\n            if(dp[i] == maxLen) ans+= cnt[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    public:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size(); //finding the size of nums\\n        \\n        if(n <= 1) return n; //less than one length return n\\n        \\n        vector<int> dp(n+1, 1); //will count the length of the LIS till the current index\\n        vector<int> cnt(n+1, 1);// number of LIS till this index\\n        \\n        dp[0] = 1; //the length can be only 1 until the first element obviously\\n        int maxLen = 1; //maximum length will start at 1\\n        \\n        for(int i = 1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n        \\n                if(nums[j] < nums[i]) //from j to i is an increasing subsequence\\n                {\\n                    if(dp[j] == dp[i]) //lenght of lis ill j is same as length of lis till i as of yet\\n                    {\\n                        \\n                        dp[i] = dp[j] + 1; //this is one length extra since i is a new element now included in the lis uptill j to becoome lis till i\\n                        cnt[i] = cnt[j];\\n                        //the lis till j will be same as lis till i as this is not a new lis but an extension of lis till j, a new element is added in the same lis\\n                    }\\n                    else if (dp[j] + 1 == dp[i])\\n                    {\\n                        cnt[i] += cnt[j];\\n                        //all this lis till j will now be lis till i since this is a new lis not just an addition to previous lis, the lis uptill i wasof some length from some other jth element, this is another addition to the same lis\\n                    }                      \\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n;i++){\\n            if(dp[i] == maxLen) ans+= cnt[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397031,
                "title": "intuitive-o-n-2-dp-solution-w-detailed-comments",
                "content": "```py\\nclass Solution:\\n    # well-commented version, study it \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\n        len_ = len(nums)\\n\\n        # lens[i]: record the length of LIS (might not be the global longest one)\\n        # that ends at nums[i]\\n        lens = [1] * len_\\n\\n        # counts[i]: record the number of LIS (whose length is lens[i]) that ends\\n        # at nums[i]\\n        counts = [1] * len_\\n\\n        # keep track of length of global LIS\\n        max_lis_len = 1\\n        # keep track of number of such global LIS\\n        count = 1\\n\\n        for i in range(1, len_):\\n            curr = nums[i]\\n            # total: number of LIS ending at nums[i] seen so far\\n            # l: length of LIS ending at nums[i] seen so far\\n            total, l = 0, 0\\n            # go to check all values before current value\\n            for j in range(i):\\n                prev = nums[j]\\n\\n                # in case previous value >= current value, no IS can be formed\\n                if prev >= curr:\\n                    continue\\n\\n                # in case current IS\\'s length > length of LIS seen so far\\n                if lens[j] + 1 > l:\\n                    l = lens[j] + 1\\n                    total = counts[j]\\n\\n                # in case current IS\\'s length == length of LIS seen so far\\n                elif lens[j] + 1 == l:\\n                    total += counts[j]\\n\\n            # update lens[i] and counts[i]\\n            lens[i] = max(1, l)\\n            counts[i] = max(1, total)\\n\\n            # update global LIS and count\\n            if lens[i] > max_lis_len:\\n                max_lis_len = lens[i]\\n                count = counts[i]\\n            elif lens[i] == max_lis_len:\\n                count += counts[i]\\n\\n        return count\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    # well-commented version, study it \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\n        len_ = len(nums)\\n\\n        # lens[i]: record the length of LIS (might not be the global longest one)\\n        # that ends at nums[i]\\n        lens = [1] * len_\\n\\n        # counts[i]: record the number of LIS (whose length is lens[i]) that ends\\n        # at nums[i]\\n        counts = [1] * len_\\n\\n        # keep track of length of global LIS\\n        max_lis_len = 1\\n        # keep track of number of such global LIS\\n        count = 1\\n\\n        for i in range(1, len_):\\n            curr = nums[i]\\n            # total: number of LIS ending at nums[i] seen so far\\n            # l: length of LIS ending at nums[i] seen so far\\n            total, l = 0, 0\\n            # go to check all values before current value\\n            for j in range(i):\\n                prev = nums[j]\\n\\n                # in case previous value >= current value, no IS can be formed\\n                if prev >= curr:\\n                    continue\\n\\n                # in case current IS\\'s length > length of LIS seen so far\\n                if lens[j] + 1 > l:\\n                    l = lens[j] + 1\\n                    total = counts[j]\\n\\n                # in case current IS\\'s length == length of LIS seen so far\\n                elif lens[j] + 1 == l:\\n                    total += counts[j]\\n\\n            # update lens[i] and counts[i]\\n            lens[i] = max(1, l)\\n            counts[i] = max(1, total)\\n\\n            # update global LIS and count\\n            if lens[i] > max_lis_len:\\n                max_lis_len = lens[i]\\n                count = counts[i]\\n            elif lens[i] == max_lis_len:\\n                count += counts[i]\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107307,
                "title": "python-dp-segment-tree-o-nlogn",
                "content": "First, calculate the length of LIS endswith index i, we call it dp[n].\\ndp[i]  = max{dp[j]} + 1 where j < i and a[j] < a[i]. We can use a segment tree to make dp transfer faster.\\nMoreover, for counting job, we just save it in segment tree, so we can solve the problem in O(nlogn) time-complexity.\\n```\\ndef merge(x, y):\\n    if x[0] == y[0]:\\n        if x[0] == 0:\\n            return (0, 1)\\n        return (x[0], x[1] + y[1])\\n    return max(x, y)\\n\\nclass TreeNode(object):\\n    def __init__(self, start, end):\\n        self.left = start\\n        self.right = end\\n        self._lchild = self._rchild = None\\n        self.max_val = 0\\n        self.max_cnt = 1\\n    def push_up(self):\\n        self.val_tuple = merge(self.lchild.val_tuple, self.rchild.val_tuple)\\n    @property\\n    def mid(self):\\n        return (self.left + self.right) / 2\\n    @property\\n    def val_tuple(self):\\n        return (self.max_val, self.max_cnt)\\n    @val_tuple.setter\\n    def val_tuple(self, val):\\n        self.max_val, self.max_cnt = val\\n    @property\\n    def lchild(self):\\n        if not self._lchild:\\n            self._lchild = TreeNode(self.left, self.mid)\\n        return self._lchild\\n    @property\\n    def rchild(self):\\n        if not self._rchild:\\n            self._rchild = TreeNode(self.mid + 1, self.right)\\n        return self._rchild\\nclass SegmentTree(object):\\n    def __init__(self, start, end):\\n        self.root = TreeNode(start, end)\\n\\n    def query(self, key, cur):\\n        if cur.right <= key:\\n            return cur.val_tuple\\n        elif cur.left > key:\\n            return (0, 1)\\n        else:\\n            return merge(self.query(key, cur.lchild), self.query(key, cur.rchild))\\n\\n    def insert(self, key, val, val_cnt, cur):\\n        if cur.left == cur.right:\\n            cur.val_tuple = merge((val, val_cnt), cur.val_tuple)\\n            return\\n        if key <= cur.mid:\\n            self.insert(key, val, val_cnt, cur.lchild)\\n        else:\\n            self.insert(key, val, val_cnt, cur.rchild)\\n        cur.push_up()\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        st = SegmentTree(min(nums), max(nums))\\n        for num in nums:\\n            res = st.query(num - 1, st.root)\\n            st.insert(num, res[0] + 1, res[1], st.root)\\n        return st.root.max_cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef merge(x, y):\\n    if x[0] == y[0]:\\n        if x[0] == 0:\\n            return (0, 1)\\n        return (x[0], x[1] + y[1])\\n    return max(x, y)\\n\\nclass TreeNode(object):\\n    def __init__(self, start, end):\\n        self.left = start\\n        self.right = end\\n        self._lchild = self._rchild = None\\n        self.max_val = 0\\n        self.max_cnt = 1\\n    def push_up(self):\\n        self.val_tuple = merge(self.lchild.val_tuple, self.rchild.val_tuple)\\n    @property\\n    def mid(self):\\n        return (self.left + self.right) / 2\\n    @property\\n    def val_tuple(self):\\n        return (self.max_val, self.max_cnt)\\n    @val_tuple.setter\\n    def val_tuple(self, val):\\n        self.max_val, self.max_cnt = val\\n    @property\\n    def lchild(self):\\n        if not self._lchild:\\n            self._lchild = TreeNode(self.left, self.mid)\\n        return self._lchild\\n    @property\\n    def rchild(self):\\n        if not self._rchild:\\n            self._rchild = TreeNode(self.mid + 1, self.right)\\n        return self._rchild\\nclass SegmentTree(object):\\n    def __init__(self, start, end):\\n        self.root = TreeNode(start, end)\\n\\n    def query(self, key, cur):\\n        if cur.right <= key:\\n            return cur.val_tuple\\n        elif cur.left > key:\\n            return (0, 1)\\n        else:\\n            return merge(self.query(key, cur.lchild), self.query(key, cur.rchild))\\n\\n    def insert(self, key, val, val_cnt, cur):\\n        if cur.left == cur.right:\\n            cur.val_tuple = merge((val, val_cnt), cur.val_tuple)\\n            return\\n        if key <= cur.mid:\\n            self.insert(key, val, val_cnt, cur.lchild)\\n        else:\\n            self.insert(key, val, val_cnt, cur.rchild)\\n        cur.push_up()\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        st = SegmentTree(min(nums), max(nums))\\n        for num in nums:\\n            res = st.query(num - 1, st.root)\\n            st.insert(num, res[0] + 1, res[1], st.root)\\n        return st.root.max_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794904,
                "title": "simple-dp-solution-c-o-n-2",
                "content": "# Intution\\nWe can see that this is a subsequence question, and there are 2^n subsequences in an array, and here according to constraints, we have to do it in O(n^2), So DP is the way to think towards.\\n# Approach\\nNow Here in my answer with each ```dp[i] pair```, in the ```first``` value I stored the ```longest subsequence length ending at ith index```, and in ```second``` value I stored the ```freq of subsequences with dp[i].first length(basically the longest)``` and ending at ith index.\\nAn unordered map is used to store all the relevant required subsequences frequency. We keep track of the longest subsequence length also.\\nIn the end just ```return the longest subsequence length from the map```. Easy.\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int max_seq = 1;\\n        unordered_map<int,int> mp;\\n        vector<pair<int,int>> dp(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int sub_ans = 0; //longest subsequence ending at i index\\n            int f = 1; // freq of the longest subsequences ending at i index\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(sub_ans<dp[j].first){\\n                        sub_ans = dp[j].first;\\n                        f = dp[j].second; \\n                    }\\n                    else if(sub_ans==dp[j].first) f+=dp[j].second;\\n                }\\n            }\\n            dp[i] = {1+sub_ans,f};\\n            mp[dp[i].first] += f; //adding the relevant freq in map\\n            max_seq = max(max_seq,dp[i].first);\\n        }\\n        return mp[max_seq];\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please upvote for your continuous support \\uD83D\\uDE0A. If you have any doubt feel free to comment down below, I will try my best to reply and explain. Thank you for reading my answer.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```dp[i] pair```\n```first```\n```longest subsequence length ending at ith index```\n```second```\n```freq of subsequences with dp[i].first length(basically the longest)```\n```return the longest subsequence length from the map```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int max_seq = 1;\\n        unordered_map<int,int> mp;\\n        vector<pair<int,int>> dp(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int sub_ans = 0; //longest subsequence ending at i index\\n            int f = 1; // freq of the longest subsequences ending at i index\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(sub_ans<dp[j].first){\\n                        sub_ans = dp[j].first;\\n                        f = dp[j].second; \\n                    }\\n                    else if(sub_ans==dp[j].first) f+=dp[j].second;\\n                }\\n            }\\n            dp[i] = {1+sub_ans,f};\\n            mp[dp[i].first] += f; //adding the relevant freq in map\\n            max_seq = max(max_seq,dp[i].first);\\n        }\\n        return mp[max_seq];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794877,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[1]*n\\n        count=[1]*n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if 1+dp[j]>dp[i]:\\n                        dp[i]=dp[j]+1\\n\\n                        count[i]=count[j]\\n\\n                    elif dp[j]+1==dp[i]:\\n                        count[i]+=count[j]\\n        longest_len=max(dp)\\n        return sum([count[i] for i in range(n) if dp[i]==longest_len])                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[1]*n\\n        count=[1]*n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if 1+dp[j]>dp[i]:\\n                        dp[i]=dp[j]+1\\n\\n                        count[i]=count[j]\\n\\n                    elif dp[j]+1==dp[i]:\\n                        count[i]+=count[j]\\n        longest_len=max(dp)\\n        return sum([count[i] for i in range(n) if dp[i]==longest_len])                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794797,
                "title": "c-o-n-2-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n        int n=a.size();\\n        \\n        vector<int> dp(n,1), count(n,1);\\n        int max_len=0;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(a[i]>a[j]){\\n                    if(dp[i]<1+dp[j]){ // longer subsequence is possible than just inc in 1 by addition of a[i]\\n                        count[i]=count[j]; // becoming part of this new subsequence\\n                    }else if(dp[i]==1+dp[j]){\\n                        count[i]+=count[j]; // summing up all possible subequences ending at a[i] with same length\\n                    }\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            max_len=max(max_len,dp[i]);\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max_len) c += count[i];\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n        int n=a.size();\\n        \\n        vector<int> dp(n,1), count(n,1);\\n        int max_len=0;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(a[i]>a[j]){\\n                    if(dp[i]<1+dp[j]){ // longer subsequence is possible than just inc in 1 by addition of a[i]\\n                        count[i]=count[j]; // becoming part of this new subsequence\\n                    }else if(dp[i]==1+dp[j]){\\n                        count[i]+=count[j]; // summing up all possible subequences ending at a[i] with same length\\n                    }\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            max_len=max(max_len,dp[i]);\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max_len) c += count[i];\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197544,
                "title": "c-easy-solution-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n,1),c(n,1);\\n        int maxi=1;\\n        // sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(arr[i]>arr[prev] && dp[i]<1+dp[prev]){\\n                    dp[i]=1+dp[prev];\\n                    c[i]=c[prev];\\n                }\\n                else if(dp[i]==(1+dp[prev])){\\n                    c[i]+=c[prev];\\n                }\\n            }\\n            if(maxi<dp[i]){\\n                    maxi=dp[i];\\n                }\\n            // cout<<dp[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi) \\n            res+=c[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n,1),c(n,1);\\n        int maxi=1;\\n        // sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(arr[i]>arr[prev] && dp[i]<1+dp[prev]){\\n                    dp[i]=1+dp[prev];\\n                    c[i]=c[prev];\\n                }\\n                else if(dp[i]==(1+dp[prev])){\\n                    c[i]+=c[prev];\\n                }\\n            }\\n            if(maxi<dp[i]){\\n                    maxi=dp[i];\\n                }\\n            // cout<<dp[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi) \\n            res+=c[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2805203,
                "title": "dfs-different-approach-dp-o-n-2-simple",
                "content": "\\nRuntime: 150 ms, faster than 92.49% of C++ online submissions for Number of Longest Increasing Subsequence.\\n# *Intuition:*\\n\\n**Finding LIS:**\\nFirst of all we need to find the LIS of the given array. For that need to iterate from left to right.\\nLets Take a number (suppose index i ). As we are trying to find Longest Strictly increasing Subsequence, we will try to place our number after every number from index 0 to i-1 which is less than our current number.Then we choose the index which gives us the longest chain of number and store that number in that particular index and the path in the Route vector.\\n\\n**EXAMPLE:**\\n\\n**nums = [1,3,5,4,7]**\\n**dp = [0,0,0,0,0]**\\n**Route vector:\\n0- >\\n1 ->\\n2 ->\\n3 ->\\n4 ->**\\n\\n1. We take 1, as it is the first number we can\\'t put it after any number. So, we put value = 1 in 0th index.\\n **nums = [1,3,5,4,7]**\\n **dp = [1,0,0,0,0]**\\n **Route vector (Index -> Path):\\n0- >\\n1 ->\\n2 ->\\n3 ->\\n4 ->**\\n \\n2. We take 3. As 3 is greater than 1, we can place it after 1. So, our value of **1st index = 0th index + 1 = 2** and we **push 0 in the 1st index** of the Route vector because this is our desired path to current LIS.\\n **dp = [1,2,0,0,0]**\\n **nums = [1,3,5,4,7]**\\n **Route vector (Index -> Path):\\n0- >\\n1 -> 0\\n2 ->\\n3 ->\\n4 ->**\\n \\n3. We take 5 and try to place after 3. As 3<5 we can place it and our value of **2nd index = 1st index + 1 = 3** and** push 1 in the 2nd index** of the Route vector. Now we try to place it before 1. As 1<5, we can place it their and our value will become **0th index + 1 = 2** . As we already have value = 3 in our current index, we will not take the new value.\\n**dp = [1,2,3,0,0]**\\n**nums = [1,3,5,4,7]**\\n**Route vector (Index -> Path):\\n0- >\\n1 ->0\\n2 ->1\\n3 ->\\n4 ->**\\n\\n 4. We take 4 and try to place it after 5. As 5>4 we can\\'t place it here. \\nThen we take 3. As 3<4, we can place it here and the new value becomes **1st index + 1 = 2+1 = 3** and we **push 1 in the 3rd index** of the Route vector.\\n Then we take 1. As 1 < 4 we can place it here and the new value will be = 1+1 = 2. As we already have value = 3, we won\\'t take anything smaller than our current value.\\n**dp = [1,2,3,3,0]**\\n**nums = [1,3,5,4,7]**\\n**Route vector (Index -> Path):\\n0- >\\n1 ->0\\n2 ->1\\n3 ->1\\n4 ->**\\n \\n5. We take 7 and try to place it after 4. As 4<7 we can place it here and the new value becomes **3rd index + 1 = 3+1 = 4** and we **push 3 in the 4th index** of the Route vector. \\nThen we take 5 and as 5<7 we can place our number after it and the value becomes **2nd index + 1 = 3+1 = 4.** As our **curr value = new found value** so we won\\'t be updating our answer but we will **push 2 in in the 4th index** of our Route vector. After that we take 3 , 1 one by one but none of them will give us greater or equal value compare to our current value.\\n**dp = [1,2,3,3,4]**\\n**nums = [1,3,5,4,7]**\\n**Route vector (Index -> Path):\\n0- >\\n1 ->0\\n2 ->1\\n3 ->1\\n4 -> 3 -> 2**\\n\\n\\n**DFS:**\\n\\nNow from our dp array we know that, our LIS is 4. So will iterate through our dp array and if we find any LIS value = 4 , we can certain say that a **Longest strictly increasing subsequence ends here**. So, as we already created a graph using our **route vector**, we can start a dfs taking the **index value of dp as a root**.\\n\\n![image](https://assets.leetcode.com/users/images/57f1d9c5-f734-40cd-bc53-bf752c71494c_1668220623.598379.png)\\n\\nAs running a dfs will be time consuming, we will be storing (**memoization**) the value of the subtree in a array named SAVE. Using this save array, we won\\'t have to go through the same subtree again. The code will provide a better and clear view.\\n\\n# CODE (C++):\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int>Route_vector[2002];\\n    \\n    int save[2003];\\n    int dfs(int x){\\n        if(Route_vector[x].size() == 0) // We cant go any further, so thats a complete path\\n            return 1;\\n        \\n        if(save[x]!=0) // We already went through this subPath earlier, so we saved it\\n            return save[x];\\n        \\n        for(int i=0;i<Route_vector[x].size();i++)\\n            save[x]+=dfs(Route_vector[x][i]); \\n        return save[x];\\n    }\\n    \\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        int ans = 0;\\n     \\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]) // We found a number which is less than our choosen number\\n                {\\n                    if(dp[i] == dp[j]+1) // If our current dp[] value is equal to new value, we will just update our path\\n                        Route_vector[i].push_back(j);\\n                    \\n                    else if(dp[j]+1>dp[i]){ // If our current dp[] value is less than new value, we erase our path and start a new path\\n                        dp[i] = dp[j]+1;\\n                        Route_vector[i].clear();\\n                        Route_vector[i].push_back(j);\\n                    }\\n                }    \\n            }\\n            ans = max(ans,dp[i]); // Keeping track of the maximum LIS length\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i] == ans) // we will run dfs and take iTH index as a root if dp[i] = longest LIS\\n                res+=dfs(i);\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>Route_vector[2002];\\n    \\n    int save[2003];\\n    int dfs(int x){\\n        if(Route_vector[x].size() == 0) // We cant go any further, so thats a complete path\\n            return 1;\\n        \\n        if(save[x]!=0) // We already went through this subPath earlier, so we saved it\\n            return save[x];\\n        \\n        for(int i=0;i<Route_vector[x].size();i++)\\n            save[x]+=dfs(Route_vector[x][i]); \\n        return save[x];\\n    }\\n    \\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        int ans = 0;\\n     \\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]) // We found a number which is less than our choosen number\\n                {\\n                    if(dp[i] == dp[j]+1) // If our current dp[] value is equal to new value, we will just update our path\\n                        Route_vector[i].push_back(j);\\n                    \\n                    else if(dp[j]+1>dp[i]){ // If our current dp[] value is less than new value, we erase our path and start a new path\\n                        dp[i] = dp[j]+1;\\n                        Route_vector[i].clear();\\n                        Route_vector[i].push_back(j);\\n                    }\\n                }    \\n            }\\n            ans = max(ans,dp[i]); // Keeping track of the maximum LIS length\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i] == ans) // we will run dfs and take iTH index as a root if dp[i] = longest LIS\\n                res+=dfs(i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779914,
                "title": "pure-recursion-java-need-to-write-dp-based-for-this",
                "content": "Intution here is for every number you can have 2 choices\\n1) Select it and increase your count\\n2) ignore the current number\\n\\nso basically your solution comes to \\nrecusrion(len+1, i+1) --> decided to select the current number and increase the length by 1\\nrecursion(len, i+1) --> decided to ignore the current number, so length wont increase.\\n\\nHowever the trick here is, we dont need the max length. Instead we want number of possible max lengths. so store the lengths in an array every time. so we will get counts of each length  \\n\\n``` public static int findNumberOfLIS(int[] nums) {\\n    int[] count = new int[nums.length + 1];\\n    recursion(nums, 0, Integer.MIN_VALUE, count, 0);\\n\\t// once we found counts for all the possible lengths, return the maximum length count\\n    for (int i = count.length - 1; i >= 0; i--) {\\n      if (count[i] > 0) return count[i];\\n    }\\n    return 0;\\n  }\\n\\n  static void recursion(int[] nums, int i, int curMax, int[] count, int ans) {\\n  // exit condition also store the length count\\n    if (i >= nums.length) {\\n      count[ans] = count[ans] + 1;\\n      return;\\n    }\\n\\t// if your value is greater than prevoius value continue with ans++\\n    if (curMax < nums[i]) {\\n      recursion(nums, i + 1, nums[i], count, ans + 1);\\n    }\\n\\t//just continue with prevoius values\\n    recursion(nums, i + 1, curMax, count, ans);\\n  }\\n  ```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` public static int findNumberOfLIS(int[] nums) {\\n    int[] count = new int[nums.length + 1];\\n    recursion(nums, 0, Integer.MIN_VALUE, count, 0);\\n\\t// once we found counts for all the possible lengths, return the maximum length count\\n    for (int i = count.length - 1; i >= 0; i--) {\\n      if (count[i] > 0) return count[i];\\n    }\\n    return 0;\\n  }\\n\\n  static void recursion(int[] nums, int i, int curMax, int[] count, int ans) {\\n  // exit condition also store the length count\\n    if (i >= nums.length) {\\n      count[ans] = count[ans] + 1;\\n      return;\\n    }\\n\\t// if your value is greater than prevoius value continue with ans++\\n    if (curMax < nums[i]) {\\n      recursion(nums, i + 1, nums[i], count, ans + 1);\\n    }\\n\\t//just continue with prevoius values\\n    recursion(nums, i + 1, curMax, count, ans);\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779673,
                "title": "python-dp-o-n-2",
                "content": "Use tuple to keep track of (length, number of subsequences).\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        record = [(1,1)]*len(nums)\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j]<nums[i]:\\n                    if record[j][0]+1 > record[i][0]:\\n                        record[i] = (record[j][0]+1, record[j][1])\\n                    elif record[j][0]+1 == record[i][0]:\\n                        record[i] = (record[i][0], record[j][1]+record[i][1])\\n        \\n        longest = max(length for length, _ in record)\\n        longest_count = 0\\n        for length, count in record:\\n            if length==longest:\\n                longest_count += count\\n        return longest_count\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        record = [(1,1)]*len(nums)\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j]<nums[i]:\\n                    if record[j][0]+1 > record[i][0]:\\n                        record[i] = (record[j][0]+1, record[j][1])\\n                    elif record[j][0]+1 == record[i][0]:\\n                        record[i] = (record[i][0], record[j][1]+record[i][1])\\n        \\n        longest = max(length for length, _ in record)\\n        longest_count = 0\\n        for length, count in record:\\n            if length==longest:\\n                longest_count += count\\n        return longest_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516922,
                "title": "python-dp-solution-with-explanation-and-execution-examples",
                "content": "Python Solution\\n```\\nclass Solution:\\n    \"\"\"\\n    Longest Increasing Subsequence: LIS\\n    \"\"\"\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        ls = len(nums)\\n        \\n        # length, count: record lengths and counts of LIS ending at index i inclusive\\n        length, count = [1] * ls, [1] * ls\\n        \\n        # scan each number where IS ending at nums[i]\\n        for i in range(ls):\\n            # for each number before nums[i]\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    # nums[j] can add to IS ending at nums[i]\\n                    \\n                    # case 1. nums[j] makes it longer to IS ending at nums[i]\\n                    if length[j] + 1 > length[i]:\\n                        length[i], count[i] = length[j] + 1, count[j]\\n                     \\n                    # case 2. nums[j] adds some new paths of IS ending in nums[i]\\n                    elif length[j] + 1 == length[i]:\\n                        count[i] += count[j]\\n        max_length = max(length)\\n        \\n        return sum(cnt for l, cnt in zip(length, count) if l == max_length)\\n                        \\n```\\n\\nSee also these problems:\\n\\n435.\\xA0Non-overlapping Intervals\\n(https://leetcode.com/problems/non-overlapping-intervals/)\\n\\n300.\\xA0Longest Increasing Subsequence\\n(https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\n646.\\xA0Maximum Length of Pair Chain\\n(https://leetcode.com/problems/maximum-length-of-pair-chain/)\\n\\n452.\\xA0Minimum Number of Arrows to Burst Balloons\\n(https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)\\n\\n\\n674.\\xA0Longest Continuous Increasing Subsequence [Easy]\\n(https://leetcode.com/problems/longest-continuous-increasing-subsequence/)\\n\\n\\n\\n673.\\xA0Number of Longest Increasing Subsequence\\n(https://leetcode.com/problems/number-of-longest-increasing-subsequence/)\\n\\n\\n\\nExecution Procedure:\\n```\\nnums = [1,3,5,4,7]\\n\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 2, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 2, 2, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 2, 3, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 2, 3, 2, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 3, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 2, 3, 3, 2]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 2, 3, 3, 3]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 2]\\nlength: [1, 2, 3, 3, 4]; count: [1, 1, 1, 1, 2]\\n\\n---\\n```\\n\\n```\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Longest Increasing Subsequence: LIS\\n    \"\"\"\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        ls = len(nums)\\n        \\n        # length, count: record lengths and counts of LIS ending at index i inclusive\\n        length, count = [1] * ls, [1] * ls\\n        \\n        # scan each number where IS ending at nums[i]\\n        for i in range(ls):\\n            # for each number before nums[i]\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    # nums[j] can add to IS ending at nums[i]\\n                    \\n                    # case 1. nums[j] makes it longer to IS ending at nums[i]\\n                    if length[j] + 1 > length[i]:\\n                        length[i], count[i] = length[j] + 1, count[j]\\n                     \\n                    # case 2. nums[j] adds some new paths of IS ending in nums[i]\\n                    elif length[j] + 1 == length[i]:\\n                        count[i] += count[j]\\n        max_length = max(length)\\n        \\n        return sum(cnt for l, cnt in zip(length, count) if l == max_length)\\n                        \\n```\n```\\nnums = [1,3,5,4,7]\\n\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 2, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 2, 2, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 2, 3, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 2, 3, 2, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 3, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 2, 3, 3, 2]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 2, 3, 3, 3]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 2]\\nlength: [1, 2, 3, 3, 4]; count: [1, 1, 1, 1, 2]\\n\\n---\\n```\n```\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230585,
                "title": "c-easy-dp",
                "content": "116 ms\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n  \\n        int n=nums.size();   \\n        if(n == 0) return 0;       \\n        vector<int> length(n+1 ,1);\\n        vector<int> count(n +1,1);\\n        int maxlen = 1;\\n        \\n                \\n        for(int i= 1;i<n;i++)\\n        {\\n            for( int j = 0 ; j < i ; j++){\\n                \\n                if(nums[i] > nums[j]){   \\n                    \\n                    if(length[j]+1 > length[i]){ // adding one to j will improve the length    \\n                        length[i] = length[i]+1;  // length[i] = max (length[i],length[j]+1)  \\n                        count[i] = count[j];         \\n                    }\\n                    \\n                    //means we are ruuning a loop and some other value is also smaller than this i value \\n                    // so just inc the count as they are having the same length \\n                    // length is updated in the above once\\n                    // if same length appers again then we have to inc the count\\n                    else if(length[j]+1 == length[i]){ \\n                         count[i] += count[j];\\n                    }\\n                }\\n            }       \\n           maxlen = max(maxlen,length[i]);\\n        }\\n       int ans = 0;\\n     \\n\\n    for(int i = 0 ; i < n ; i++){\\n        if(length[i] == maxlen){\\n            ans+= count[i];     // How many have same max lengths\\n            \\n        }\\n    }\\n         return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n  \\n        int n=nums.size();   \\n        if(n == 0) return 0;       \\n        vector<int> length(n+1 ,1);\\n        vector<int> count(n +1,1);\\n        int maxlen = 1;\\n        \\n                \\n        for(int i= 1;i<n;i++)\\n        {\\n            for( int j = 0 ; j < i ; j++){\\n                \\n                if(nums[i] > nums[j]){   \\n                    \\n                    if(length[j]+1 > length[i]){ // adding one to j will improve the length    \\n                        length[i] = length[i]+1;  // length[i] = max (length[i],length[j]+1)  \\n                        count[i] = count[j];         \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1206526,
                "title": "easy-dp-js-solution",
                "content": "```\\nvar findNumberOfLIS = function(nums) {  \\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    // dp[i] is the length of longest increasing subsequence ending at index i\\n    let dp = new Array(nums.length);\\n    // freq[i] is the number of LISs ending at index i\\n    let freq = new Array(nums.length);\\n    for (let i = 0; i < nums.length; i++) {\\n        // Obtain length of LISs ending at i\\n        let lenOfLIS = 1;\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                lenOfLIS = Math.max(lenOfLIS, dp[j] + 1);\\n            }\\n        }\\n        \\n        // Obtain number of LISs ending at i\\n        let freqAtI = 0\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i] && dp[j] + 1 === lenOfLIS) {\\n                freqAtI += freq[j];\\n            }\\n        }\\n        \\n        // Record them to arrays\\n        dp[i] = lenOfLIS;\\n        freq[i] = freqAtI === 0 ? 1 : freqAtI;\\n    }\\n\\n    // Obtain the length of LIS out of all possible increasing sequences\\n    let maxLen = Math.max(...dp);\\n    \\n    // Obtain the total number of LISs\\n    let maxFreq = 0;\\n    for (let i = 0; i < dp.length; i++) {\\n        if (dp[i] === maxLen) {\\n            maxFreq += freq[i];\\n        }\\n    }\\n    return maxFreq;\\n    // T.C: O(N^2)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findNumberOfLIS = function(nums) {  \\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    // dp[i] is the length of longest increasing subsequence ending at index i\\n    let dp = new Array(nums.length);\\n    // freq[i] is the number of LISs ending at index i\\n    let freq = new Array(nums.length);\\n    for (let i = 0; i < nums.length; i++) {\\n        // Obtain length of LISs ending at i\\n        let lenOfLIS = 1;\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                lenOfLIS = Math.max(lenOfLIS, dp[j] + 1);\\n            }\\n        }\\n        \\n        // Obtain number of LISs ending at i\\n        let freqAtI = 0\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i] && dp[j] + 1 === lenOfLIS) {\\n                freqAtI += freq[j];\\n            }\\n        }\\n        \\n        // Record them to arrays\\n        dp[i] = lenOfLIS;\\n        freq[i] = freqAtI === 0 ? 1 : freqAtI;\\n    }\\n\\n    // Obtain the length of LIS out of all possible increasing sequences\\n    let maxLen = Math.max(...dp);\\n    \\n    // Obtain the total number of LISs\\n    let maxFreq = 0;\\n    for (let i = 0; i < dp.length; i++) {\\n        if (dp[i] === maxLen) {\\n            maxFreq += freq[i];\\n        }\\n    }\\n    return maxFreq;\\n    // T.C: O(N^2)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1100297,
                "title": "c-dp-with-production-level-variable-naming-for-easier-understanding",
                "content": "This problem is an absolute monster, and I\\'m actually amazed I solved it because I\\'m horrible at DP so I\\'m insanely proud of this one.\\n\\nMost solutions in Leetcode have really non descriptive variable names which makes it tough to figure out what is happening (although granted everyone writing those solutions is absolutely brilliant, and I\\'m also nearly always guilty of this in LC). But after finishing the algorithm this time I rewrote it with proper variable naming so that if anyone does come across this post, there\\'s hopefully more clarity provided in the different relationships between variables and how the logic comes into place.\\n\\n```\\nint findNumberOfLIS(vector<int>& nums) {\\n\\tconst int SIZE = nums.size();\\n\\tvector<int> longestSubsetAtIndex(SIZE, 1), longestSubsetCountsAtIndex(SIZE, 1);\\n\\tint longestSubset = 1, prevLongest, newLongest, longestSubsetCount = 0;\\n\\tfor (int i = 1; i < SIZE; i++) {\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\tprevLongest = longestSubsetAtIndex[i];\\n\\t\\t\\t\\tnewLongest = longestSubsetAtIndex[j] + 1;\\n\\t\\t\\t\\tif (prevLongest == newLongest) {\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] += longestSubsetCountsAtIndex[j];                        \\n\\t\\t\\t\\t} else if (newLongest > prevLongest) {\\n\\t\\t\\t\\t\\tif (prevLongest == longestSubset)\\n\\t\\t\\t\\t\\t\\tlongestSubset = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetAtIndex[i] = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] = longestSubsetCountsAtIndex[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < SIZE; i++) {\\n\\t\\tif (longestSubsetAtIndex[i] == longestSubset)\\n\\t\\t\\tlongestSubsetCount += longestSubsetCountsAtIndex[i];\\n\\t}\\n\\treturn longestSubsetCount;\\n}\\n```\\n\\nAnd if you suck at DP as much as I do, go through this: https://leetcode.com/discuss/general-discussion/662866/dp-for-beginners-problems-patterns-sample-solutions/870893\\n\\nIt\\'s a brilliant post that I\\'ve been working through in order that allowed me to solve this, hopefully this all helps someone.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint findNumberOfLIS(vector<int>& nums) {\\n\\tconst int SIZE = nums.size();\\n\\tvector<int> longestSubsetAtIndex(SIZE, 1), longestSubsetCountsAtIndex(SIZE, 1);\\n\\tint longestSubset = 1, prevLongest, newLongest, longestSubsetCount = 0;\\n\\tfor (int i = 1; i < SIZE; i++) {\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\tprevLongest = longestSubsetAtIndex[i];\\n\\t\\t\\t\\tnewLongest = longestSubsetAtIndex[j] + 1;\\n\\t\\t\\t\\tif (prevLongest == newLongest) {\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] += longestSubsetCountsAtIndex[j];                        \\n\\t\\t\\t\\t} else if (newLongest > prevLongest) {\\n\\t\\t\\t\\t\\tif (prevLongest == longestSubset)\\n\\t\\t\\t\\t\\t\\tlongestSubset = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetAtIndex[i] = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] = longestSubsetCountsAtIndex[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < SIZE; i++) {\\n\\t\\tif (longestSubsetAtIndex[i] == longestSubset)\\n\\t\\t\\tlongestSubsetCount += longestSubsetCountsAtIndex[i];\\n\\t}\\n\\treturn longestSubsetCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076562,
                "title": "12ms-99-fenwick-tree-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, a[2001];\\n    pair<int, int> bit[2001];\\n\\n    void Update(int i, int len, int cnt) {\\n        while (i <= n) {\\n            if (bit[i].first < len) {\\n                bit[i] = {len, cnt};\\n            }\\n            else if (bit[i].first == len) {\\n                bit[i].second += cnt;\\n            }\\n            i += i & -i;\\n        }\\n    }\\n\\n    pair<int, int> Get(int i) {\\n        pair<int, int> ans = {0, 0};\\n        while (i > 0) {\\n            if (ans.first < bit[i].first) {\\n                ans = bit[i];\\n            }\\n            else if (bit[i].first == ans.first) {\\n                ans.second += bit[i].second;\\n            }\\n            i -= i & -i;\\n        }\\n        return ans;\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        n = nums.size();\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = nums[i - 1];\\n        }\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin() + 1;\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            auto [len, cnt] = Get(a[i] - 1);\\n            if (len == 0) {\\n                cnt = 1;\\n            }\\n            Update(a[i], ++len, cnt);\\n        }\\n        return Get(n).second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, a[2001];\\n    pair<int, int> bit[2001];\\n\\n    void Update(int i, int len, int cnt) {\\n        while (i <= n) {\\n            if (bit[i].first < len) {\\n                bit[i] = {len, cnt};\\n            }\\n            else if (bit[i].first == len) {\\n                bit[i].second += cnt;\\n            }\\n            i += i & -i;\\n        }\\n    }\\n\\n    pair<int, int> Get(int i) {\\n        pair<int, int> ans = {0, 0};\\n        while (i > 0) {\\n            if (ans.first < bit[i].first) {\\n                ans = bit[i];\\n            }\\n            else if (bit[i].first == ans.first) {\\n                ans.second += bit[i].second;\\n            }\\n            i -= i & -i;\\n        }\\n        return ans;\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        n = nums.size();\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = nums[i - 1];\\n        }\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin() + 1;\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            auto [len, cnt] = Get(a[i] - 1);\\n            if (len == 0) {\\n                cnt = 1;\\n            }\\n            Update(a[i], ++len, cnt);\\n        }\\n        return Get(n).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916531,
                "title": "c-dp-and-2-pointer-scan",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return  n;\\n        vector<int> lens(n, 1); // lens[i]: length of LIS ends with nums[i]\\n        vector<int> cnts(n, 1); // cnts[i]: counts of LIS ends with nums[i]\\n        for(int i = 1; i < n; i++)    // i: right pointer\\n            for(int j = 0; j < i; j++) // j: left pointer\\n                if(nums[j] < nums[i]){ // left_item < right_item\\n                    if(lens[j] + 1 > lens[i]){//key point: if newly longer subsequence ending with nums[i] found, then\\n                        lens[i] = lens[j] + 1;\\n                        cnts[i] = cnts[j];\\n                    }else if(lens[j] + 1 == lens[i]){\\n                        cnts[i] += cnts[j];\\n                    }\\n                }\\n        int maxLen = *max_element(lens.begin(), lens.end());        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            if(lens[i] == maxLen)\\n                ans += cnts[i];\\n        return ans;\\n    }\\n};\\n```\\n//inpsired by huahua",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return  n;\\n        vector<int> lens(n, 1); // lens[i]: length of LIS ends with nums[i]\\n        vector<int> cnts(n, 1); // cnts[i]: counts of LIS ends with nums[i]\\n        for(int i = 1; i < n; i++)    // i: right pointer\\n            for(int j = 0; j < i; j++) // j: left pointer\\n                if(nums[j] < nums[i]){ // left_item < right_item\\n                    if(lens[j] + 1 > lens[i]){//key point: if newly longer subsequence ending with nums[i] found, then\\n                        lens[i] = lens[j] + 1;\\n                        cnts[i] = cnts[j];\\n                    }else if(lens[j] + 1 == lens[i]){\\n                        cnts[i] += cnts[j];\\n                    }\\n                }\\n        int maxLen = *max_element(lens.begin(), lens.end());        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            if(lens[i] == maxLen)\\n                ans += cnts[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394534,
                "title": "clean-c-dp-o-n-2-time-o-n-space-with-comments",
                "content": "```cpp\\n    int findNumberOfLIS(vector<int>& nums) {\\n      int n = nums.size();\\n      if (n == 0) return 0;\\n      \\n      vector<int> len(n, 1); // len[i]: length of LIS ending with nums[i]\\n      vector<int> cnt(n, 1); // cnt[i]: number of LIS ending with nums[i]\\n      \\n      // len[i] = max(len[j]+1: j<i && nums[j]<nums[i])\\n      // cnt[i] = sum(cnt[j]:   j<i && nums[j]<nums[i] && len[j]==len[i]+1)      \\n      for (int i = 1; i < n; ++i) {\\n        for (int j = 0; j < i ; ++j) {\\n          if (nums[j] < nums[i]) {\\n            if (len[i] < len[j]+1) {\\n              len[i] = len[j]+1;\\n              cnt[i] = cnt[j];\\n            }\\n            else if (len[i] == len[j]+1) {\\n              cnt[i] += cnt[j];\\n            }\\n          }\\n        }        \\n      }\\n      \\n      // find length of LIS for nums[]\\n      int maxLen = *max_element(len.begin(), len.end());\\n      \\n      // compute number of LIS for nums[]\\n      // cnt_maxLen = sum(len[i]: if len[i] == maxLen)\\n      int cnt_maxLen = 0;\\n      for (int i = 0; i < n; ++i)\\n        if (len[i] == maxLen) cnt_maxLen += cnt[i];\\n      \\n      return cnt_maxLen;        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n    int findNumberOfLIS(vector<int>& nums) {\\n      int n = nums.size();\\n      if (n == 0) return 0;\\n      \\n      vector<int> len(n, 1); // len[i]: length of LIS ending with nums[i]\\n      vector<int> cnt(n, 1); // cnt[i]: number of LIS ending with nums[i]\\n      \\n      // len[i] = max(len[j]+1: j<i && nums[j]<nums[i])\\n      // cnt[i] = sum(cnt[j]:   j<i && nums[j]<nums[i] && len[j]==len[i]+1)      \\n      for (int i = 1; i < n; ++i) {\\n        for (int j = 0; j < i ; ++j) {\\n          if (nums[j] < nums[i]) {\\n            if (len[i] < len[j]+1) {\\n              len[i] = len[j]+1;\\n              cnt[i] = cnt[j];\\n            }\\n            else if (len[i] == len[j]+1) {\\n              cnt[i] += cnt[j];\\n            }\\n          }\\n        }        \\n      }\\n      \\n      // find length of LIS for nums[]\\n      int maxLen = *max_element(len.begin(), len.end());\\n      \\n      // compute number of LIS for nums[]\\n      // cnt_maxLen = sum(len[i]: if len[i] == maxLen)\\n      int cnt_maxLen = 0;\\n      for (int i = 0; i < n; ++i)\\n        if (len[i] == maxLen) cnt_maxLen += cnt[i];\\n      \\n      return cnt_maxLen;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796196,
                "title": "easiest-c-code-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n         int i,j,k,c=0,s=0,ml=1,ans=0;\\n        int n=a.size();\\n        int  l[n];\\n        int b[n];\\n        for(i=0;i<n;i++)\\n        {\\n            l[i]=1;\\n            b[i]=1;\\n        }\\n        \\n        for(i=1;i<a.size();i++)\\n        {\\n            \\n            for(j=0;j<i;j++)\\n            {\\n                if(a[i]>a[j] and l[j]+1>l[i])\\n                {\\n                    l[i]=l[j]+1;\\n                    b[i]=b[j];\\n                }\\n                else if(a[i]>a[j] and l[j]+1==l[i])\\n                {\\n                    b[i]+=b[j];\\n                }\\n            }\\n            ml=max(ml,l[i]);\\n\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(l[i]==ml){\\n            c+=b[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n         int i,j,k,c=0,s=0,ml=1,ans=0;\\n        int n=a.size();\\n        int  l[n];\\n        int b[n];\\n        for(i=0;i<n;i++)\\n        {\\n            l[i]=1;\\n            b[i]=1;\\n        }\\n        \\n        for(i=1;i<a.size();i++)\\n        {\\n            \\n            for(j=0;j<i;j++)\\n            {\\n                if(a[i]>a[j] and l[j]+1>l[i])\\n                {\\n                    l[i]=l[j]+1;\\n                    b[i]=b[j];\\n                }\\n                else if(a[i]>a[j] and l[j]+1==l[i])\\n                {\\n                    b[i]+=b[j];\\n                }\\n            }\\n            ml=max(ml,l[i]);\\n\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(l[i]==ml){\\n            c+=b[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795160,
                "title": "python3-dp-time-o-n-2-space-o-n-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use dynamic programming to break down the problem into smaller subproblems, find the length and count of LIS ending at each index, and then combine this information to find the total number of longest increasing subsequences in the given array \\'nums\\'.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function findNumberOfLIS takes an array nums as input and returns the number of longest increasing subsequences.\\n2. We initialize a variable n to store the length of the input array nums.\\n3. The variable dp is a 2D list to store the dynamic programming results. Each element dp[i] represents the information for the subsequence ending at index i. It is a list containing two values: [length, cnt], where length represents the length of the longest increasing subsequence ending at index i, and cnt represents the count of such subsequences.\\n4. We initialize max_length to 0 to keep track of the length of the longest increasing subsequence found so far.\\n5. We iterate over each index i in the range [0, n-1]:\\n    - Initialize dp[i] as [1, 1] (length 1 and count 1) because every element is an LIS of length 1 by itself.\\n    - For each index j in the range [0, i-1]:\\n        - If the element at j is less than the element at i (nums[j] < nums[i]), we have found a potential longer subsequence.\\n        - Compare the length of the LIS ending at j with the current length of LIS ending at i. If dp[j][0] + 1 is greater than dp[i][0], it means we have found a longer subsequence ending at i, so we update dp[i] accordingly. If dp[j][0] + 1 is equal to dp[i][0], it means we have found another subsequence with the same length as the current longest one, so we increment the count dp[i][1] by dp[j][1].\\n    - Update max_length to be the maximum of the current max_length and the length of the LIS ending at index i.\\n6. After finding the max_length, we iterate over dp again to count the number of longest increasing subsequences. We add the count dp[i][1] to res for each index i where the length of LIS is equal to max_length.\\n7. Finally, we return the value of res, which represents the number of longest increasing subsequences.\\n\\n### Time Complexity:\\n- The outer loop runs for n iterations, and the inner loop runs for at most i iterations for each index i. Therefore, the total number of comparisons and updates done in the inner loop is roughly proportional to the sum of the first n positive integers, which is O(n^2).\\n- The subsequent loop that counts the number of longest increasing subsequences also runs in O(n) time.\\n- Overall, the time complexity of the algorithm is O(n^2).\\n\\n### Space Complexity:\\n- The space complexity is O(n) to store the dp list.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[1, 1] for _ in range(n)] # length, cnt\\n        max_length = 0\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[j][0] + 1 > dp[i][0]:\\n                        dp[i] = [dp[j][0] + 1, dp[j][1]]\\n                    elif dp[j][0] + 1 == dp[i][0]:\\n                        dp[i][1] = dp[i][1] + dp[j][1]\\n            max_length = max(max_length, dp[i][0])\\n        res = 0\\n        for idx, (length, cnt) in enumerate(dp):\\n            if length == max_length:\\n                res += cnt\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[1, 1] for _ in range(n)] # length, cnt\\n        max_length = 0\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[j][0] + 1 > dp[i][0]:\\n                        dp[i] = [dp[j][0] + 1, dp[j][1]]\\n                    elif dp[j][0] + 1 == dp[i][0]:\\n                        dp[i][1] = dp[i][1] + dp[j][1]\\n            max_length = max(max_length, dp[i][0])\\n        res = 0\\n        for idx, (length, cnt) in enumerate(dp):\\n            if length == max_length:\\n                res += cnt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794898,
                "title": "recursion-top-down-bottom-up-c",
                "content": "## RECURSION [TLE]\\n```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, int currIdx)\\n    {   \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        //===============================================================\\n        for (int start = 0; start < n; start++)  //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\\n//=============================================================================================================\\n## TOP-DOWN [MEMOIZATION]\\n```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, vector<int>&length, vector<int>&count, int currIdx)\\n    {\\n        if (length[currIdx] != -1) return {length[currIdx], count[currIdx]};\\n        \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, length, count, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        length[currIdx] = LISLen; count[currIdx] = LISCount;\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        vector<int>length(n, -1), count(n, -1);\\n        //===============================================================\\n        for (int start = 0; start < n; start++) //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, length, count, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\\n//=============================================================================================================\\n## BOTTOM UP \\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        vector<int>length(n, -1), count(n, -1); //DP\\n        //===================================================================================\\n        for (int start = n - 1; start >= 0; start--)\\n        {\\n            int LISLen = 1, LISCount = 1;\\n            //=======================================================\\n            for (int i = start + 1; i < nums.size(); i++)\\n            {\\n                if (nums[i] > nums[start])\\n                {\\n                    int currLen = 1 + length[i]; //1 + nextLen\\n                    if (currLen > LISLen)\\n                    {\\n                        LISLen = currLen;\\n                        LISCount = count[i]; //nextCount\\n                    }\\n                    else if (currLen == LISLen) \\n                        LISCount = LISCount + count[i];\\n                }\\n            }\\n            //=============================================================\\n            length[start] = LISLen; \\n            count[start] = LISCount;\\n            maxLISLen = max(maxLISLen, length[start]);\\n        }\\n        //========================================================================================\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (length[i] == maxLISLen) \\n                ans += count[i];\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, int currIdx)\\n    {   \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        //===============================================================\\n        for (int start = 0; start < n; start++)  //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, vector<int>&length, vector<int>&count, int currIdx)\\n    {\\n        if (length[currIdx] != -1) return {length[currIdx], count[currIdx]};\\n        \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, length, count, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        length[currIdx] = LISLen; count[currIdx] = LISCount;\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        vector<int>length(n, -1), count(n, -1);\\n        //===============================================================\\n        for (int start = 0; start < n; start++) //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, length, count, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        vector<int>length(n, -1), count(n, -1); //DP\\n        //===================================================================================\\n        for (int start = n - 1; start >= 0; start--)\\n        {\\n            int LISLen = 1, LISCount = 1;\\n            //=======================================================\\n            for (int i = start + 1; i < nums.size(); i++)\\n            {\\n                if (nums[i] > nums[start])\\n                {\\n                    int currLen = 1 + length[i]; //1 + nextLen\\n                    if (currLen > LISLen)\\n                    {\\n                        LISLen = currLen;\\n                        LISCount = count[i]; //nextCount\\n                    }\\n                    else if (currLen == LISLen) \\n                        LISCount = LISCount + count[i];\\n                }\\n            }\\n            //=============================================================\\n            length[start] = LISLen; \\n            count[start] = LISCount;\\n            maxLISLen = max(maxLISLen, length[start]);\\n        }\\n        //========================================================================================\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (length[i] == maxLISLen) \\n                ans += count[i];\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241697,
                "title": "java-dynamic-programming-solution-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Number of Longest Increasing Subsequence involves finding the total number of longest increasing subsequence in a given sequence of numbers.\\n\\nThere are also more advance algorithms, such as the Patience Sorting, that can solve the problem in $$O(n*log(n))$$ time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne common approach to solve this problem is Dynamic Programming. We create 2 auxiliary arrays `dp` and `count` of the same length as the input array. `dp[i]` will store the length of the longest increasing subsequence ending at index i of the given array, and `count[i]` will store the number of longest increasing subsequences ending at index i.\\n\\nWe then fill the auxiliary arrays by comparing each element in the sequence to all preceding elements, and updating the value in both arrays as needed. The length of the longest increasing subsequence can then be found by taking the maximum value in the `dp` array.\\n\\nFinally, using the maximum value in the `dp` array, we traverse the `count` array to find the sum of all elements where `dp[i]` is equal to the maximum value.\\n\\n\\n#### \\u2705 Iterative - Tabulation - Bottom Up \\u2705\\n\\nHere\\'s the steps to solve this problem:\\n\\n1. Initialize two arrays `dp and count` of the same size as the given array. `dp[k]` will store the length of the longest increasing subsequence ending at index `k`, and `count[k]` will store the number of longest increasing subsequences ending at index `k`.\\n\\n2. Initialize all elements of `dp and count` to 1, as every element is a longest increasing subsequence of length 1, and there is only one longest increasing subsequence ending at each index.\\n\\n3. Traverse the array, and for each index `k`, traverse the subarray from `0 to k-1`. \\n\\n4. If the element at index `j` is less than the element at index `k` and `dp[j] + 1 > dp[k]`, means that we can extend the subsequence ending at `nums[j]`, set `dp[k]` to the maximum of `dp[j] + 1` and `dp[k]`.\\n\\n\\n5. If the element at index `j` is less than the element at index `k` and `dp[j]+1 == dp[i]`, means that there is a new longest increasing subsequence that ends at `nums[k]`. We then add `count[j]` to `count[k]`.\\n\\n6. We keep track of the maximum length of the LIS in the variable `maxLen`, which is update in each iteration. \\n\\n7. Finally, we initialize a variable call `result = 0`. Then iterate over all elements in `count` array to check if the current value is equal to `maxLen`, it it does, add to `result`, means that we found more combination of LIS.\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int maxLen = 1;\\n        //Step 1\\n        int [] dp = new int[nums.length];\\n        int [] count = new int[nums.length];\\n\\n        //Step 2\\n        Arrays.fill(dp,1);\\n        Arrays.fill(count,1);\\n\\n        //Step 3\\n        for(int k = 1; k < nums.length; k++)\\n        {\\n            for(int j = 0; j < k; j++)\\n            {\\n                if(nums[k] > nums[j])\\n                {\\n                    //Step 4\\n                    if(dp[k] < dp[j] + 1)\\n                    {\\n                        dp[k] = dp[j] + 1;\\n                        count[k] = count[j];\\n                    }\\n\\n                    //Step 5\\n                    else if(dp[k] == dp[j] + 1)\\n                    {\\n                        count[k] += count[j];\\n                    }\\n                }\\n            }\\n            //Step 6\\n            maxLen = Math.max(maxLen,dp[k]);\\n        }\\n\\n        //Step 7\\n        int result = 0;\\n        for(int k = 0; k < nums.length;k++)\\n        {\\n            if(maxLen == dp[k]) result += count[k];\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where n is the length of the input array. As we need to iterate through the input array twice.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ as we using 2 arrays of length nums.length to store the results.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n###### The Number of Longest Increasing Subsequence problem have several real-life applications, including the following: \\n\\n1. Game theory: analyze the optimal strategy in a sequential decision-making game. This involves identifying the longest increasing subsequence of optimal decisions, which can help to determine the best course of action in various scenarios, such as in a game of chess or poker.\\n\\n2. Stock Market Analysis: Analyzing stock prices over a period of time to make a profitable investment opportunity.\\n\\n3. Image processing: help identify objects and shapes, and can also help in image compression.\\n\\n4. Speech recognition: identify patterns in speech, and can also be used to improve the accuracy of speech recognition algorithms.\\n\\n5. Computer graphics: Identify the longest increasing subsequence of vertices in a graph can help in constructing smooth and aesthetically pleasing curves and surfaces.\\n\\n6. DNA sequencing: determine the longest common subsequence (LCS) of two DNA sequences, which provides information about genetic similarities between two organisms.\\n\\n7. Text analysis: identify the longest increasing subsequence of characters, words, or phrases in a text corpus. This can help in various natural language processing tasks such as sentiment analysis, summarization, and topic modeling.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int maxLen = 1;\\n        //Step 1\\n        int [] dp = new int[nums.length];\\n        int [] count = new int[nums.length];\\n\\n        //Step 2\\n        Arrays.fill(dp,1);\\n        Arrays.fill(count,1);\\n\\n        //Step 3\\n        for(int k = 1; k < nums.length; k++)\\n        {\\n            for(int j = 0; j < k; j++)\\n            {\\n                if(nums[k] > nums[j])\\n                {\\n                    //Step 4\\n                    if(dp[k] < dp[j] + 1)\\n                    {\\n                        dp[k] = dp[j] + 1;\\n                        count[k] = count[j];\\n                    }\\n\\n                    //Step 5\\n                    else if(dp[k] == dp[j] + 1)\\n                    {\\n                        count[k] += count[j];\\n                    }\\n                }\\n            }\\n            //Step 6\\n            maxLen = Math.max(maxLen,dp[k]);\\n        }\\n\\n        //Step 7\\n        int result = 0;\\n        for(int k = 0; k < nums.length;k++)\\n        {\\n            if(maxLen == dp[k]) result += count[k];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934074,
                "title": "easy-to-understand-c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    \\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<p> memo(n+1, make_pair(-1, -1));\\n        return helper(nums, memo, 0, -1).second;\\n    }\\nprivate:\\n    p helper(vector<int>& nums, vector<p>& memo, int idx, int prev)\\n    {\\n        if (idx == nums.size()) return make_pair(0, 1);\\n        if (memo[prev+1] != make_pair(-1, -1)) return memo[prev+1];\\n        p a = make_pair(0, 0), b = make_pair(0, 0);\\n        if (prev==-1 || nums[idx] > nums[prev]) \\n        {\\n            a = helper(nums, memo, idx+1, idx);\\n            a.first++;\\n        }\\n        b = helper(nums, memo, idx+1, prev);\\n        if (a.first == b.first) return memo[prev+1] = make_pair(a.first, a.second+b.second);\\n        else if (a.first > b.first) return memo[prev+1] = a;\\n        return memo[prev+1] = b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    \\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<p> memo(n+1, make_pair(-1, -1));\\n        return helper(nums, memo, 0, -1).second;\\n    }\\nprivate:\\n    p helper(vector<int>& nums, vector<p>& memo, int idx, int prev)\\n    {\\n        if (idx == nums.size()) return make_pair(0, 1);\\n        if (memo[prev+1] != make_pair(-1, -1)) return memo[prev+1];\\n        p a = make_pair(0, 0), b = make_pair(0, 0);\\n        if (prev==-1 || nums[idx] > nums[prev]) \\n        {\\n            a = helper(nums, memo, idx+1, idx);\\n            a.first++;\\n        }\\n        b = helper(nums, memo, idx+1, prev);\\n        if (a.first == b.first) return memo[prev+1] = make_pair(a.first, a.second+b.second);\\n        else if (a.first > b.first) return memo[prev+1] = a;\\n        return memo[prev+1] = b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580705,
                "title": "java-96-faster",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        int count[]=new int[nums.length];\\n        dp[0]=1;\\n        count[0]=1;\\n        int result=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(dp[i]<dp[j]+1)\\n                    {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1)\\n                    {\\n                        count[i]+=count[j];\\n                    }\\n                        \\n                }\\n            }\\n            \\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(max<dp[i])\\n            {\\n                result=count[i];\\n                max=dp[i];\\n            }\\n            else if(max==dp[i])\\n                result+=count[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        int count[]=new int[nums.length];\\n        dp[0]=1;\\n        count[0]=1;\\n        int result=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(dp[i]<dp[j]+1)\\n                    {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1)\\n                    {\\n                        count[i]+=count[j];\\n                    }\\n                        \\n                }\\n            }\\n            \\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(max<dp[i])\\n            {\\n                result=count[i];\\n                max=dp[i];\\n            }\\n            else if(max==dp[i])\\n                result+=count[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557324,
                "title": "java-o-n-2-time-o-n-space-with-comments",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        // in dp we store the LIS if last number of seq is i\\n        int[] dp = new int[nums.length];\\n        // in mul we store in how many ways we can obtain the LIS with last element i\\n        int[] mul = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++){\\n            dp[i] = 1;\\n            mul[i] = 1;\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] < nums[i]){ \\n                    // if equals: we have found a new way to obtain max mult\\n                    if(dp[j] + 1 == dp[i]) mul[i] += mul[j];\\n                    // else we need to rethink: there is a longest subsequence\\n                    else if(dp[j] + 1 > dp[i]){\\n                        mul[i] = mul[j];\\n                        dp[i] = dp[j] + 1;\\n                    }\\n                }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] > max) max = dp[i];\\n        }\\n        int sol = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] == max) sol += mul[i];\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        // in dp we store the LIS if last number of seq is i\\n        int[] dp = new int[nums.length];\\n        // in mul we store in how many ways we can obtain the LIS with last element i\\n        int[] mul = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++){\\n            dp[i] = 1;\\n            mul[i] = 1;\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] < nums[i]){ \\n                    // if equals: we have found a new way to obtain max mult\\n                    if(dp[j] + 1 == dp[i]) mul[i] += mul[j];\\n                    // else we need to rethink: there is a longest subsequence\\n                    else if(dp[j] + 1 > dp[i]){\\n                        mul[i] = mul[j];\\n                        dp[i] = dp[j] + 1;\\n                    }\\n                }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] > max) max = dp[i];\\n        }\\n        int sol = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] == max) sol += mul[i];\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505027,
                "title": "python-simple",
                "content": "O(N^2) - 2 nested loops\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N, max_len = len(A), 1\\n        dp, counts = [1] * N, [1] * N\\n        \\n        for i in range(1, N):\\n            for j in range(i, -1, -1):\\n                if A[i] > A[j]:\\n                    if 1 + dp[j] > dp[i]:\\n                        dp[i] = 1 + dp[j]\\n                        counts[i] = counts[j]\\n                    elif 1 + dp[j] == dp[i]:\\n                        counts[i] += counts[j]\\n        \\n            max_len = max(max_len, dp[i])\\n\\n        \\n        return sum(counts[i] for i in range(N) if dp[i] == max_len)\\n```\\nO(NlogN) - modified LIS\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N = len(A)     \\n        lis = []\\n        frequency_of_this_length = defaultdict(list)\\n        frequency_of_this_length[-1].append((1, -math.inf))\\n        \\n        max_len = 1\\n\\n        for val in A:\\n            \\n            length = bisect_left(lis, val)\\n\\n            if length >= len(lis): \\n                lis.append(val)\\n            else: \\n                lis[length] = val\\n\\n            curr_lis_count = 0\\n            \\n\\n            for count, a in frequency_of_this_length[length-1]:\\n                if val > a: \\n                    curr_lis_count += count\\n            \\n            frequency_of_this_length[length].append((curr_lis_count, val))\\n            \\n            max_len = max(max_len, length)\\n       \\n        if len(lis) == 1: return N\\n        \\n        return sum(count for count, _ in frequency_of_this_length[max_len])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N, max_len = len(A), 1\\n        dp, counts = [1] * N, [1] * N\\n        \\n        for i in range(1, N):\\n            for j in range(i, -1, -1):\\n                if A[i] > A[j]:\\n                    if 1 + dp[j] > dp[i]:\\n                        dp[i] = 1 + dp[j]\\n                        counts[i] = counts[j]\\n                    elif 1 + dp[j] == dp[i]:\\n                        counts[i] += counts[j]\\n        \\n            max_len = max(max_len, dp[i])\\n\\n        \\n        return sum(counts[i] for i in range(N) if dp[i] == max_len)\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N = len(A)     \\n        lis = []\\n        frequency_of_this_length = defaultdict(list)\\n        frequency_of_this_length[-1].append((1, -math.inf))\\n        \\n        max_len = 1\\n\\n        for val in A:\\n            \\n            length = bisect_left(lis, val)\\n\\n            if length >= len(lis): \\n                lis.append(val)\\n            else: \\n                lis[length] = val\\n\\n            curr_lis_count = 0\\n            \\n\\n            for count, a in frequency_of_this_length[length-1]:\\n                if val > a: \\n                    curr_lis_count += count\\n            \\n            frequency_of_this_length[length].append((curr_lis_count, val))\\n            \\n            max_len = max(max_len, length)\\n       \\n        if len(lis) == 1: return N\\n        \\n        return sum(count for count, _ in frequency_of_this_length[max_len])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492606,
                "title": "python-2-solutions-dp-binary-search-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DP**\\n- Let `dp[i]` (where 0 <= i < n) be the longest increasing subsequence ends at `nums[i]`.\\n- Let `cnt[i]` (where 0 <= i < n) be the number of longest subsequence ends at `nums[i]`.\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        cnt = [1] * n\\n        maxLen = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[i] < dp[j] + 1:\\n                        dp[i] = dp[j] + 1\\n                        cnt[i] = cnt[j]\\n                    elif dp[i] == dp[j] + 1:\\n                        cnt[i] += cnt[j]\\n                        \\n            maxLen = max(maxLen, dp[i])\\n        \\n        return sum(cnt[i] for i in range(n) if dp[i] == maxLen)\\n```\\nComplexity:\\n- Time: `O(N^2)`, where `N <= 2000` is the number of elements in `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Binary Search**\\n```python\\n# Todo implementation!\\n```\\nComplexity:\\n- Time: `O(NlogN)`, where `N <= 2000` is the number of elements in `nums` array.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        cnt = [1] * n\\n        maxLen = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[i] < dp[j] + 1:\\n                        dp[i] = dp[j] + 1\\n                        cnt[i] = cnt[j]\\n                    elif dp[i] == dp[j] + 1:\\n                        cnt[i] += cnt[j]\\n                        \\n            maxLen = max(maxLen, dp[i])\\n        \\n        return sum(cnt[i] for i in range(n) if dp[i] == maxLen)\\n```\n```python\\n# Todo implementation!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467477,
                "title": "easy-c-solution-o-n-2-solution-explained-beautifully",
                "content": "class Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         \\n        int n = nums.size(), length = 0, ans = 0;\\n        \\n        // Now if we are given an array of size 0 , then no of subsequence formed is 0\\n        // with one element its 1\\n        \\n        vector< int > DP( n, 1 );\\n        vector< int > Count( n, 1 );\\n        \\n        // DP[ i ] -> Length of longest subsequence ending at ith index\\n        // Count[ i ] -> Count of no of subsequences ending at ith index\\n    \\n        for( int i=0; i<n ; i++ ){\\n            \\n            for( int j=0 ; j<i ; j++ ){\\n                \\n                if( nums[j] < nums[i] ){\\n                    \\n                    // Now 2 situations arises\\n                    //   i) The i-th element gets added to the subsequence at index j\\n                    \\n                    if( DP[ j ]+1 > DP[i] ){\\n                        \\n                        DP[ i ] = 1 + DP[ j ];\\n                        Count[ i ] = Count[ j ];\\n                    }\\n                    \\n                    //  ii) Increases the number of subsequences as the length of that longest subsequence already achieved for that element\\n                    \\n                    else if( DP[ j ]+1 == DP[ i ] )\\n                        Count[ i ] += Count[j];\\n                }\\n            }\\n          \\n            length = max( length , DP[ i ] );\\n        }\\n        \\n        // count of all longest increasing subsequence that end with ith indexes\\n        for( int i=0 ; i<n ; i++ ){\\n            \\n            if( length==DP[i] )\\n                 ans += Count[ i ];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         \\n        int n = nums.size(), length = 0, ans = 0;\\n        \\n        // Now if we are given an array of size 0 , then no of subsequence formed is 0\\n        // with one element its 1\\n        \\n        vector< int > DP( n, 1 );\\n        vector< int > Count( n, 1 );\\n        \\n        // DP[ i ] -> Length of longest subsequence ending at ith index\\n        // Count[ i ] -> Count of no of subsequences ending at ith index\\n    \\n        for( int i=0; i<n ; i++ ){\\n            \\n            for( int j=0 ; j<i ; j++ ){\\n                \\n                if( nums[j] < nums[i] ){\\n                    \\n                    // Now 2 situations arises\\n                    //   i) The i-th element gets added to the subsequence at index j\\n                    \\n                    if( DP[ j ]+1 > DP[i] ){\\n                        \\n                        DP[ i ] = 1 + DP[ j ];\\n                        Count[ i ] = Count[ j ];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1308609,
                "title": "java-n-2-solution-dp",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if(nums==null || nums.length==0) return 0;\\n        \\n        int n=nums.length;\\n        \\n        int length[]=new int [n];\\n        int count[]=new int [n];\\n        \\n        Arrays.fill(length,1);\\n        Arrays.fill(count,1);\\n        \\n        int maxLen=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(length[i]==length[j]+1){\\n                        count[i]+=count[j];\\n                    }\\n                }\\n            }\\n            maxLen=Math.max(maxLen,length[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLen) ans+=count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if(nums==null || nums.length==0) return 0;\\n        \\n        int n=nums.length;\\n        \\n        int length[]=new int [n];\\n        int count[]=new int [n];\\n        \\n        Arrays.fill(length,1);\\n        Arrays.fill(count,1);\\n        \\n        int maxLen=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(length[i]==length[j]+1){\\n                        count[i]+=count[j];\\n                    }\\n                }\\n            }\\n            maxLen=Math.max(maxLen,length[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLen) ans+=count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262254,
                "title": "java-dp-solution-with-clean-code",
                "content": "I believe this question should be hard level. At least for me!\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, maxLen = 0;\\n\\n        // len[i] denote the length of the longest increasing subsequence which ends with nums[i]\\n        int[] len = new int[n];\\n        // cnt[i] denote the number of the longest increasing subsequence which ends with nums[i]\\n        int[] cnt = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            len[i] = cnt[i] = 1; // init\\n\\n            for (int j = 0; j < i; j++) {\\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) { // find a valid pattern\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j] + 1 > len[i]) {\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    } \\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j] + 1 == len[i]) {\\n                        cnt[i] += cnt[j];\\n                    }\\n                }\\n            }\\n\\n            // update res and maxLen\\n            if (maxLen < len[i]) {\\n                maxLen = len[i];\\n                res = cnt[i];\\n            } else if (maxLen == len[i]) {\\n                res += cnt[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, maxLen = 0;\\n\\n        // len[i] denote the length of the longest increasing subsequence which ends with nums[i]\\n        int[] len = new int[n];\\n        // cnt[i] denote the number of the longest increasing subsequence which ends with nums[i]\\n        int[] cnt = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            len[i] = cnt[i] = 1; // init\\n\\n            for (int j = 0; j < i; j++) {\\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) { // find a valid pattern\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j] + 1 > len[i]) {\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    } \\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j] + 1 == len[i]) {\\n                        cnt[i] += cnt[j];\\n                    }\\n                }\\n            }\\n\\n            // update res and maxLen\\n            if (maxLen < len[i]) {\\n                maxLen = len[i];\\n                res = cnt[i];\\n            } else if (maxLen == len[i]) {\\n                res += cnt[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225374,
                "title": "simple-dp-solution-o-n-2-built-upon-lis-problem",
                "content": "This problem is based on Longest Increasing Subsequence, and uses the same DP technique. Instead of 1D array used in LIS, here we make use of an array currMax with 2 columns - one for storing the LIS including current element and other for storing the count of such subsequences. \\nFor instance currMax[2] = [2,1] means that including nums[2], we get an LIS of length 2 and the number of such subsequences of length 2 is 1.\\n\\nEach time the length of LIS is updated, the corresponding count column also gets updated.\\n\\nThe code is :\\n```\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        currMax = [[1 , 1] for _ in range(len(nums))]\\n        \\n        for i in range(1 , len(nums)):\\n            for j in range(i) :\\n                \\n                if nums[i] > nums[j] :\\n                    if currMax[i][0] < currMax[j][0] + 1 :\\n                        currMax[i][0] = currMax[j][0] + 1\\n                        currMax[i][1] = currMax[j][1]\\n                    elif currMax[i][0] == currMax[j][0] + 1:\\n                        currMax[i][1] += currMax[j][1]\\n                        \\n        result = 0\\n        \\n        maxlength = max(currMax, key = lambda x: x[0])[0]\\n\\n        for i in range(len(nums)):\\n            if currMax[i][0] == maxlength :\\n                result = result + currMax[i][1]\\n            \\n        return result\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        currMax = [[1 , 1] for _ in range(len(nums))]\\n        \\n        for i in range(1 , len(nums)):\\n            for j in range(i) :\\n                \\n                if nums[i] > nums[j] :\\n                    if currMax[i][0] < currMax[j][0] + 1 :\\n                        currMax[i][0] = currMax[j][0] + 1\\n                        currMax[i][1] = currMax[j][1]\\n                    elif currMax[i][0] == currMax[j][0] + 1:\\n                        currMax[i][1] += currMax[j][1]\\n                        \\n        result = 0\\n        \\n        maxlength = max(currMax, key = lambda x: x[0])[0]\\n\\n        for i in range(len(nums)):\\n            if currMax[i][0] == maxlength :\\n                result = result + currMax[i][1]\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1091864,
                "title": "c-dp-solution-using-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& v) {\\n        // finding length of LIS\\n        \\n        vector<int> dp(v.size());\\n        int lis = 1;\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<dp.size(); i++){\\n            int currMax = 0;\\n            \\n            for(int j=0; j<i; j++){\\n                if(v[j] < v[i]){\\n                    currMax = max(currMax, dp[j]);\\n                }\\n            }\\n            \\n            dp[i] = currMax + 1;\\n            lis = max(lis, dp[i]);\\n        }\\n        \\n        // counting number of LIS\\n        \\n        // create a count vector to count number of subseqeunces\\n        vector<int> count(dp.size());\\n        \\n        for(int i=0; i<count.size(); i++){\\n            if(dp[i] == 1) count[i] = 1;\\n            else{\\n                for(int j=0; j<i; j++){\\n                    if(dp[j] + 1 == dp[i] and v[j] < v[i]){\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // add number of subsequences that has length equal to LIS length\\n        int ores = 0;\\n        for(int i=0; i<dp.size(); i++){\\n            if(dp[i] == lis){\\n                ores += count[i];\\n            }\\n        }\\n        \\n        return ores;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& v) {\\n        // finding length of LIS\\n        \\n        vector<int> dp(v.size());\\n        int lis = 1;\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<dp.size(); i++){\\n            int currMax = 0;\\n            \\n            for(int j=0; j<i; j++){\\n                if(v[j] < v[i]){\\n                    currMax = max(currMax, dp[j]);\\n                }\\n            }\\n            \\n            dp[i] = currMax + 1;\\n            lis = max(lis, dp[i]);\\n        }\\n        \\n        // counting number of LIS\\n        \\n        // create a count vector to count number of subseqeunces\\n        vector<int> count(dp.size());\\n        \\n        for(int i=0; i<count.size(); i++){\\n            if(dp[i] == 1) count[i] = 1;\\n            else{\\n                for(int j=0; j<i; j++){\\n                    if(dp[j] + 1 == dp[i] and v[j] < v[i]){\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // add number of subsequences that has length equal to LIS length\\n        int ores = 0;\\n        for(int i=0; i<dp.size(); i++){\\n            if(dp[i] == lis){\\n                ores += count[i];\\n            }\\n        }\\n        \\n        return ores;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050444,
                "title": "straightforward-javascript-dp-solution-faster-than-90-time-and-space",
                "content": "```\\n/**\\n* @param {number[]} nums\\n* @return {number}\\n*/\\nvar findNumberOfLIS = function(nums) {\\n    let dp = Array(nums.length).fill(1);\\n    let count = Array(nums.length).fill(1);\\n    \\n    let maxLen = 0;\\n    for(let i = 0; i < nums.length; i++) { // current one\\n        for(let j = 0; j < i; j++) { // compare to previous ones\\n            if(nums[j] < nums[i] && dp[j]+1 > dp[i]) {\\n                dp[i] = dp[j]+1;\\n                count[i] = count[j];\\n            } else if(nums[j] < nums[i] && dp[j]+1 === dp[i]) {\\n                count[i] += count[j];\\n            } \\n        }\\n        maxLen = Math.max(dp[i], maxLen);\\n    }\\n    \\n    let res = 0;\\n    for(let i = 0; i < count.length; i++) {\\n        if(dp[i] === maxLen) res += count[i];\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nComplexity:\\ntime: O(N^2)\\nspace: O(N)\\n\\nSimilar to https://leetcode.com/problems/longest-increasing-subsequence/.\\n\\n**Basic Idea:** Compare each index i with each previous index j\\n1. Find the longest increasing subsequence\\n\\t\\n\\ta. At each interaction, check whether the longest subsequence ending up with index j is \\'extendable\\', i.e. whether nums[j] < nums[i]\\n\\t\\n\\tb. If so, then dp[i] = Math.max(dp[j]+1, dp[i])\\n\\n2. Count the number of longest increasing subsequence\\n\\t\\n\\ta. At each interation, if the dp[i] can be updated to a greater value, that means we have longer increasing subsequence(s) by extending from index j. The number of them is equal to the number of subsequence at j, i.e. count[i] = count[j].\\n\\t\\n\\tb. If the dp[i] is equal to \\'the greatest value\\' we currently have, then count[i] += count[j]\\n\\t\\n\\tc. The total count is equal to the sum of count of longest increasing subsequence\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n* @param {number[]} nums\\n* @return {number}\\n*/\\nvar findNumberOfLIS = function(nums) {\\n    let dp = Array(nums.length).fill(1);\\n    let count = Array(nums.length).fill(1);\\n    \\n    let maxLen = 0;\\n    for(let i = 0; i < nums.length; i++) { // current one\\n        for(let j = 0; j < i; j++) { // compare to previous ones\\n            if(nums[j] < nums[i] && dp[j]+1 > dp[i]) {\\n                dp[i] = dp[j]+1;\\n                count[i] = count[j];\\n            } else if(nums[j] < nums[i] && dp[j]+1 === dp[i]) {\\n                count[i] += count[j];\\n            } \\n        }\\n        maxLen = Math.max(dp[i], maxLen);\\n    }\\n    \\n    let res = 0;\\n    for(let i = 0; i < count.length; i++) {\\n        if(dp[i] === maxLen) res += count[i];\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924013,
                "title": "fast-12ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(const vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        int n = nums.size();\\n\\n        vector<vector<int>> deck(n + 1);\\n        vector<vector<int>> path(n + 1);\\n\\n        int max_so_far = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // bsearch insertion point\\n            // sorted from l to r\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (nums[i] > deck[mid].back()) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            \\n            // bsearch number of options\\n            int options = 1;\\n            int row = l - 1; // closest row with elements not greater than nums[i]\\n            if (row >= 0) {\\n                int l1 = 0, r1 = deck[row].size();\\n                // sorted from r to l\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (nums[i] > deck[row][mid]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                \\n                options = path[row].back();\\n                if (l1 != 0) // in a row was found element greater than nums[i]\\n                    options -= path[row][l1 - 1];\\n                //cout << nums[i] << \\' \\' << options << \\' \\' << l1 << endl;\\n            }\\n            \\n            deck[l].push_back(nums[i]);\\n            if (path[l].empty())\\n                path[l].push_back(options);\\n            else\\n                path[l].push_back(path[l].back() + options);\\n            \\n            if (l == max_so_far)\\n                max_so_far++;\\n        }\\n\\n        return path[max_so_far - 1].back();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findNumberOfLIS(const vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        int n = nums.size();\\n\\n        vector<vector<int>> deck(n + 1);\\n        vector<vector<int>> path(n + 1);\\n\\n        int max_so_far = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // bsearch insertion point\\n            // sorted from l to r\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (nums[i] > deck[mid].back()) {\\n                    l = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 916696,
                "title": "the-art-of-dynamic-programming",
                "content": "**Synopsis:**\\n\\n[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nThese solutions incrementally build upon the previous [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/The-ART-of-Dynamic-Programming) solutions.  Track the `best` LIS candidate `cand` ending at each index `j` of the input array `A`.  And also track the count `cnt` of each LIS ending at each index `j` of the input array `A`.  Whenever a new LIS candidate `cand` is found to be the `best` candidate ending at `j`, then we add onto the count of best LIS ending at `j` the count of best LIS ending at `i`, ie. `cnt[j] += cnt[i]`.  Return the highest `hi` count of the LIS.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            var best = 1\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    var cand = 1 + go(i)\\n                    if (best < cand) {\\n                        best = cand\\n                        cnt[j] = 0\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            return best\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            if (!m.contains(j)) {\\n                var best = 1\\n                for (i in 0 until j) {\\n                    if (A[i] < A[j]) {\\n                        var cand = 1 + go(i)\\n                        if (best < cand) {\\n                            best = cand\\n                            cnt[j] = 0\\n                        }\\n                        if (best == cand)\\n                            cnt[j] += cnt[i]\\n                    }\\n                }\\n                m[j] = best\\n            }\\n            return m[j]!!\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        var dp = IntArray(N) { 1 }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j]\\n                hi = 0\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = (j, best = 1) => {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                let cand = 1 + go(i);\\n                if (best < cand) {\\n                    best = cand;\\n                    cnt[j] = 0;\\n                }\\n                if (best == cand)\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        return best;\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet findNumberOfLIS = (A, m = new Map(), best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = j => {\\n        if (!j)\\n            return 1;\\n        if (!m.has(j)) {\\n            let best = 1;\\n            for (let i = 0; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    let cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            m.set(j, best);\\n        }\\n        return m.get(j);\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let dp = Array(N).fill(1);\\n    for (let j = 0; j < N; ++j) {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                if (dp[j] < 1 + dp[i]) {\\n                    dp[j] = 1 + dp[i];\\n                    cnt[j] = 0;\\n                }\\n                if (dp[j] == 1 + dp[i])\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        if (best < dp[j]) {\\n            best = dp[j];\\n            hi = 0;\\n        }\\n        if (best == dp[j])\\n            hi += cnt[j]\\n    }\\n    return hi;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        @cache\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        dp = [1] * N\\n        for j in range(0, N):\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    if dp[j] < 1 + dp[i]:\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    if dp[j] == 1 + dp[i]:\\n                        cnt[j] += cnt[i]\\n            if best < dp[j]:\\n                best = dp[j]\\n                hi = 0\\n            if best == dp[j]:\\n                hi += cnt[j]\\n        return hi\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            auto best = 1;\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    auto cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand) {\\n                        cnt[j] += cnt[i];\\n                    }\\n                }\\n            }\\n            return best;\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int findNumberOfLIS(VI& A, Map m = {}, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            if (m.find(j) == m.end()) {\\n                auto best = 1;\\n                for (auto i{ 0 }; i < j; ++i) {\\n                    if (A[i] < A[j]) {\\n                        auto cand = 1 + go(i);\\n                        if (best < cand) {\\n                            best = cand;\\n                            cnt[j] = 0;\\n                        }\\n                        if (best == cand) {\\n                            cnt[j] += cnt[i];\\n                        }\\n                    }\\n                }\\n                m[j] = best;\\n            }\\n            return m[j];\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        VI dp(N, 1);\\n        for (auto j{ 0 }; j < N; ++j) {\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i];\\n                        cnt[j] = 0;\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j];\\n                hi = 0;\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            var best = 1\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    var cand = 1 + go(i)\\n                    if (best < cand) {\\n                        best = cand\\n                        cnt[j] = 0\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            return best\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            if (!m.contains(j)) {\\n                var best = 1\\n                for (i in 0 until j) {\\n                    if (A[i] < A[j]) {\\n                        var cand = 1 + go(i)\\n                        if (best < cand) {\\n                            best = cand\\n                            cnt[j] = 0\\n                        }\\n                        if (best == cand)\\n                            cnt[j] += cnt[i]\\n                    }\\n                }\\n                m[j] = best\\n            }\\n            return m[j]!!\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        var dp = IntArray(N) { 1 }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j]\\n                hi = 0\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = (j, best = 1) => {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                let cand = 1 + go(i);\\n                if (best < cand) {\\n                    best = cand;\\n                    cnt[j] = 0;\\n                }\\n                if (best == cand)\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        return best;\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\n```\\nlet findNumberOfLIS = (A, m = new Map(), best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = j => {\\n        if (!j)\\n            return 1;\\n        if (!m.has(j)) {\\n            let best = 1;\\n            for (let i = 0; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    let cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            m.set(j, best);\\n        }\\n        return m.get(j);\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let dp = Array(N).fill(1);\\n    for (let j = 0; j < N; ++j) {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                if (dp[j] < 1 + dp[i]) {\\n                    dp[j] = 1 + dp[i];\\n                    cnt[j] = 0;\\n                }\\n                if (dp[j] == 1 + dp[i])\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        if (best < dp[j]) {\\n            best = dp[j];\\n            hi = 0;\\n        }\\n        if (best == dp[j])\\n            hi += cnt[j]\\n    }\\n    return hi;\\n};\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        @cache\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        dp = [1] * N\\n        for j in range(0, N):\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    if dp[j] < 1 + dp[i]:\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    if dp[j] == 1 + dp[i]:\\n                        cnt[j] += cnt[i]\\n            if best < dp[j]:\\n                best = dp[j]\\n                hi = 0\\n            if best == dp[j]:\\n                hi += cnt[j]\\n        return hi\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            auto best = 1;\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    auto cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand) {\\n                        cnt[j] += cnt[i];\\n                    }\\n                }\\n            }\\n            return best;\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int findNumberOfLIS(VI& A, Map m = {}, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            if (m.find(j) == m.end()) {\\n                auto best = 1;\\n                for (auto i{ 0 }; i < j; ++i) {\\n                    if (A[i] < A[j]) {\\n                        auto cand = 1 + go(i);\\n                        if (best < cand) {\\n                            best = cand;\\n                            cnt[j] = 0;\\n                        }\\n                        if (best == cand) {\\n                            cnt[j] += cnt[i];\\n                        }\\n                    }\\n                }\\n                m[j] = best;\\n            }\\n            return m[j];\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        VI dp(N, 1);\\n        for (auto j{ 0 }; j < N; ++j) {\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i];\\n                        cnt[j] = 0;\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j];\\n                hi = 0;\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480476,
                "title": "c-recursive-top-down-with-memoization-and-iterative-bottom-up-dp",
                "content": "Top Down :- \\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp;\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        dp.resize(nums.size(),{-1,1});\\n        int LIS = 0,ans = 0;\\n        f(nums.size() - 1,nums);\\n        for(auto x:dp) LIS = max(LIS,x.first);\\n        for(auto x:dp) if(x.first == LIS) ans += x.second;\\n        return ans;\\n    }\\n    \\n    int f(int i,vector<int>& nums){\\n        if(dp[i].first != -1) return dp[i].first;\\n        int ans = 1;\\n        for(int j = 0;j < i;j++){\\n            int val = f(j,nums);\\n            if(nums[i] > nums[j] and ans <= val + 1){\\n                if(ans == val + 1){\\n                    dp[i].second += dp[j].second;\\n                }\\n                else{\\n                    ans = val + 1;\\n                    dp[i].second = dp[j].second;\\n                }\\n            }\\n        }\\n        return dp[i].first = ans;\\n    }\\n};\\n```\\n\\nBottom Up :-\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp(nums.size(),{1,1});\\n        int maxSize = 1,ans = 0;\\n        for(int i = 0;i < nums.size();i++){\\n            for(int j = 0;j < i;j++){\\n                if(nums[j] < nums[i] and dp[i].first <= dp[j].first + 1){\\n                    if(dp[i].first == dp[j].first + 1) dp[i].second += dp[j].second;\\n                    else{\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                }\\n            }\\n            maxSize = max(maxSize,dp[i].first);\\n        }\\n        for(auto x:dp) if(x.first == maxSize) ans += x.second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp;\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        dp.resize(nums.size(),{-1,1});\\n        int LIS = 0,ans = 0;\\n        f(nums.size() - 1,nums);\\n        for(auto x:dp) LIS = max(LIS,x.first);\\n        for(auto x:dp) if(x.first == LIS) ans += x.second;\\n        return ans;\\n    }\\n    \\n    int f(int i,vector<int>& nums){\\n        if(dp[i].first != -1) return dp[i].first;\\n        int ans = 1;\\n        for(int j = 0;j < i;j++){\\n            int val = f(j,nums);\\n            if(nums[i] > nums[j] and ans <= val + 1){\\n                if(ans == val + 1){\\n                    dp[i].second += dp[j].second;\\n                }\\n                else{\\n                    ans = val + 1;\\n                    dp[i].second = dp[j].second;\\n                }\\n            }\\n        }\\n        return dp[i].first = ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp(nums.size(),{1,1});\\n        int maxSize = 1,ans = 0;\\n        for(int i = 0;i < nums.size();i++){\\n            for(int j = 0;j < i;j++){\\n                if(nums[j] < nums[i] and dp[i].first <= dp[j].first + 1){\\n                    if(dp[i].first == dp[j].first + 1) dp[i].second += dp[j].second;\\n                    else{\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                }\\n            }\\n            maxSize = max(maxSize,dp[i].first);\\n        }\\n        for(auto x:dp) if(x.first == maxSize) ans += x.second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294274,
                "title": "stupid-solution-but-work-p",
                "content": "Stupid solution, but work ;p\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n        // populate longest dp\\n        int[] dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        \\n        int[] counts = new int[nums.length + 1];\\n        counts[0] = 1;\\n        \\n        int longest = 1;\\n        for (int i = 1; i < nums.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (nums[j] < nums[i]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    longest = Math.max(longest, dp[i]);\\n                }\\n            }\\n            // init counts\\n            if (dp[i] == 1) {\\n                counts[i] = 1;\\n            }\\n        }\\n        \\n        // populate longest path count\\n        dp[nums.length] = longest + 1;\\n        \\n        for (int i = 1; i < dp.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (dp[j] + 1 == dp[i] \\n                    && (i == nums.length || nums[j] < nums[i])) {\\n                    counts[i] += counts[j];\\n                }\\n            }\\n        }\\n        return counts[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n        // populate longest dp\\n        int[] dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        \\n        int[] counts = new int[nums.length + 1];\\n        counts[0] = 1;\\n        \\n        int longest = 1;\\n        for (int i = 1; i < nums.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (nums[j] < nums[i]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    longest = Math.max(longest, dp[i]);\\n                }\\n            }\\n            // init counts\\n            if (dp[i] == 1) {\\n                counts[i] = 1;\\n            }\\n        }\\n        \\n        // populate longest path count\\n        dp[nums.length] = longest + 1;\\n        \\n        for (int i = 1; i < dp.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (dp[j] + 1 == dp[i] \\n                    && (i == nums.length || nums[j] < nums[i])) {\\n                    counts[i] += counts[j];\\n                }\\n            }\\n        }\\n        return counts[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259427,
                "title": "c-dp-solution-updating-both-dp-length-and-dp-frequency",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size<2) return size;\\n        \\n        int result = 0;\\n        int longest = 0;\\n        vector<int> dp(size,1);\\n        vector<int> dpfreq(size,1);\\n        \\n        for (int i=1 ; i<size ; i++) {\\n            int freq = 1;\\n            for (int j=0 ; j<i ; j++) {\\n                if (nums[i]>nums[j]) {\\n                    if (dp[i]==dp[j]+1) {\\n                        dpfreq[i] += dpfreq[j];\\n                    }\\n                    else if (dp[i]<dp[j]+1) {\\n                        dp[i] = dp[j]+1;\\n                        dpfreq[i] = dpfreq[j];\\n                    }\\n                }\\n            }\\n            if (longest==dp[i]) {\\n                result+=dpfreq[i];\\n            }\\n            else if (longest<dp[i]) {\\n                longest = dp[i];\\n                result = dpfreq[i];\\n            }\\n        }\\n        if (longest==1) \\n            return size;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size<2) return size;\\n        \\n        int result = 0;\\n        int longest = 0;\\n        vector<int> dp(size,1);\\n        vector<int> dpfreq(size,1);\\n        \\n        for (int i=1 ; i<size ; i++) {\\n            int freq = 1;\\n            for (int j=0 ; j<i ; j++) {\\n                if (nums[i]>nums[j]) {\\n                    if (dp[i]==dp[j]+1) {\\n                        dpfreq[i] += dpfreq[j];\\n                    }\\n                    else if (dp[i]<dp[j]+1) {\\n                        dp[i] = dp[j]+1;\\n                        dpfreq[i] = dpfreq[j];\\n                    }\\n                }\\n            }\\n            if (longest==dp[i]) {\\n                result+=dpfreq[i];\\n            }\\n            else if (longest<dp[i]) {\\n                longest = dp[i];\\n                result = dpfreq[i];\\n            }\\n        }\\n        if (longest==1) \\n            return size;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987207,
                "title": "time-o-n-logn-dp-with-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEX: a1= [1,3,5,4,7]\\n   normalise this to a2= [0,1,3,2,4]\\nanswer for a1 = answer for a2 .\\nwhy? because only quantity changed,but not relative order.\\nconsider this a part 1.\\nuse sorting, map to normalise.\\nNow u have part 1 .\\nlet us define our dp state.\\n   dp[i]= stores  two values \\n      1) len of longest strictly increasing subsequence ending at i.\\n      2) How many sequences of this above length are there, which    are ending at index i.\\n\\nHow to fill this dp table .\\n  two ways \\n   1) O(n*n)  , for each i , check the dp[j] \\'s where 0<=j<i and a2[j]<a2[i].  and fill correspondingly.,\\n   2) O(n*logn) , use segment tree \\n     \\n    for dp[i] , find(the max len and count of those max len sequences. which are ending with value strictly less than a2[i])\\n\\n\\nLastly why even part1?\\n   i am storing their values in segment trees , so to minimise the space of segment trees.\\n\\nThis is the idea.\\n  think for a minute and implement yourself in you way.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsegment trees to fill dp[i] in log(n)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*logn)$$\\n \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*logn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   static const int N=4*2*1e3;\\n    pair<int,int> seg[N];\\n    vector<int> arr;\\n    pair<int,int> helperUpdateMax(pair<int,int> a, pair<int,int> b)\\n    {\\n        if(a.first>b.first)\\n           return a;\\n        else if(a.first==b.first)\\n          {\\n              a.second+= b.second;\\n              return a;\\n          }\\n          return b;\\n    }\\n    void update(int i,int lo,int hi, int ind, pair<int,int> x)\\n    {\\n        if(ind<lo || ind>hi) return;\\n        if(lo==hi && lo==ind)\\n        {\\n            seg[i]=helperUpdateMax(seg[i],x);\\n            return;\\n        }\\n        int mid= (lo+hi)/2;\\n        update(2*i+1,lo,mid,ind,x);\\n        update(2*i+2,mid+1,hi,ind,x);\\n        seg[i]=helperUpdateMax(seg[2*i+1],seg[2*i+2]);\\n    \\n    }\\n    pair<int,int>  sum(int i,int lo,int hi , int l, int r)\\n    {\\n        if(l<=lo && r>=hi)\\n        {\\n            return seg[i];\\n        }\\n        if(r<lo || l>hi) return make_pair(0,0);\\n        int mid= (lo+hi)/2;\\n        return helperUpdateMax(sum(2*i+1,lo,mid,l,r),sum(2*i+2,mid+1,hi,l,r));\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n      \\n        vector<int> vec=nums;\\n        sort(vec.begin(),vec.end());\\n        map<int,int> mp;\\n        int ind=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(vec[i])==mp.end())\\n            {\\n                 mp[vec[i]]=ind++;\\n            }\\n        \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=mp[nums[i]];\\n        }\\n        for(int i=0;i<4*ind;i++)\\n        {\\n            seg[i]=make_pair(0,0);\\n        }\\n        int mx=1;\\n         pair<int,int> dp[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n             pair<int,int> x=sum(0,0,ind-1,0,nums[i]-1);\\n            dp[i]=x;\\n            dp[i].first++;\\n            if(dp[i].second==0) dp[i].second=1;\\n\\n            }\\n            else\\n            {\\n                dp[i]={1,1};\\n            }\\n            mx=max(mx,dp[i].first);\\n            update(0,0,ind-1,nums[i],dp[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i].first==mx) cnt+=dp[i].second;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static const int N=4*2*1e3;\\n    pair<int,int> seg[N];\\n    vector<int> arr;\\n    pair<int,int> helperUpdateMax(pair<int,int> a, pair<int,int> b)\\n    {\\n        if(a.first>b.first)\\n           return a;\\n        else if(a.first==b.first)\\n          {\\n              a.second+= b.second;\\n              return a;\\n          }\\n          return b;\\n    }\\n    void update(int i,int lo,int hi, int ind, pair<int,int> x)\\n    {\\n        if(ind<lo || ind>hi) return;\\n        if(lo==hi && lo==ind)\\n        {\\n            seg[i]=helperUpdateMax(seg[i],x);\\n            return;\\n        }\\n        int mid= (lo+hi)/2;\\n        update(2*i+1,lo,mid,ind,x);\\n        update(2*i+2,mid+1,hi,ind,x);\\n        seg[i]=helperUpdateMax(seg[2*i+1],seg[2*i+2]);\\n    \\n    }\\n    pair<int,int>  sum(int i,int lo,int hi , int l, int r)\\n    {\\n        if(l<=lo && r>=hi)\\n        {\\n            return seg[i];\\n        }\\n        if(r<lo || l>hi) return make_pair(0,0);\\n        int mid= (lo+hi)/2;\\n        return helperUpdateMax(sum(2*i+1,lo,mid,l,r),sum(2*i+2,mid+1,hi,l,r));\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n      \\n        vector<int> vec=nums;\\n        sort(vec.begin(),vec.end());\\n        map<int,int> mp;\\n        int ind=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(vec[i])==mp.end())\\n            {\\n                 mp[vec[i]]=ind++;\\n            }\\n        \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=mp[nums[i]];\\n        }\\n        for(int i=0;i<4*ind;i++)\\n        {\\n            seg[i]=make_pair(0,0);\\n        }\\n        int mx=1;\\n         pair<int,int> dp[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n             pair<int,int> x=sum(0,0,ind-1,0,nums[i]-1);\\n            dp[i]=x;\\n            dp[i].first++;\\n            if(dp[i].second==0) dp[i].second=1;\\n\\n            }\\n            else\\n            {\\n                dp[i]={1,1};\\n            }\\n            mx=max(mx,dp[i].first);\\n            update(0,0,ind-1,nums[i],dp[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i].first==mx) cnt+=dp[i].second;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803164,
                "title": "top-down-dfs-caching",
                "content": "\\n\\n# Brute Force\\n```python\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        cnt = defaultdict(int)\\n        dp = {}\\n        def dfs(i, prev, length, ignored):\\n            if not ignored:\\n                cnt[length] += 1\\n            # Base case\\n            if i >= len(nums):\\n                return 0\\n            # can only choose if s-increasing\\n            choose = 0\\n            if nums[i] > prev:\\n                choose = 1 + dfs(i+1, nums[i], length + 1, 0)\\n            ignore = dfs(i+1, prev, length, 1)\\n            return max(ignore, choose)\\n        \\n        ans = dfs(0, -float(\\'inf\\'), 0, 0)\\n        return cnt[ans]\\n```\\n# Optimal(Caching)\\n```\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        @cache\\n        def dfs(i, prev):\\n            # Base cases\\n            if i >= len(nums):\\n                return 0, 1\\n            # can only choose if s-increasing\\n            choose, choose_cnt = 0, 0\\n            if nums[i] > prev:\\n                choose, choose_cnt = dfs(i+1, nums[i])\\n                choose += 1\\n            ignore, ignore_cnt = dfs(i+1, prev)\\n            if ignore == choose:\\n                return choose, choose_cnt + ignore_cnt\\n            elif choose > ignore:\\n                return choose, choose_cnt\\n            return ignore, ignore_cnt\\n        \\n        ans, ans_cnt = dfs(0, -float(\\'inf\\'))\\n        return ans_cnt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        cnt = defaultdict(int)\\n        dp = {}\\n        def dfs(i, prev, length, ignored):\\n            if not ignored:\\n                cnt[length] += 1\\n            # Base case\\n            if i >= len(nums):\\n                return 0\\n            # can only choose if s-increasing\\n            choose = 0\\n            if nums[i] > prev:\\n                choose = 1 + dfs(i+1, nums[i], length + 1, 0)\\n            ignore = dfs(i+1, prev, length, 1)\\n            return max(ignore, choose)\\n        \\n        ans = dfs(0, -float(\\'inf\\'), 0, 0)\\n        return cnt[ans]\\n```\n```\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        @cache\\n        def dfs(i, prev):\\n            # Base cases\\n            if i >= len(nums):\\n                return 0, 1\\n            # can only choose if s-increasing\\n            choose, choose_cnt = 0, 0\\n            if nums[i] > prev:\\n                choose, choose_cnt = dfs(i+1, nums[i])\\n                choose += 1\\n            ignore, ignore_cnt = dfs(i+1, prev)\\n            if ignore == choose:\\n                return choose, choose_cnt + ignore_cnt\\n            elif choose > ignore:\\n                return choose, choose_cnt\\n            return ignore, ignore_cnt\\n        \\n        ans, ans_cnt = dfs(0, -float(\\'inf\\'))\\n        return ans_cnt\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797231,
                "title": "best-python-solution-full-explanation-100",
                "content": "# Intuition\\n\\nTo solve this problem, we can use dynamic programming to find the number of longest increasing subsequences (LIS) in the input list nums. We can maintain two arrays, dp1 and dp2, where dp1[i] represents the length of the LIS ending at index i, and dp2[i] represents the count of such LIS. We initialize both arrays with all 1\\'s, as the minimum length of an LIS is 1, and each element can form an LIS of length 1.\\n\\n# Approach\\n\\nInitialize two arrays, dp1 and dp2, with all 1\\'s to store the length and count of LIS respectively.\\nInitialize count and maxval variables to track the maximum length and count of LIS found so far.\\nLoop through the elements of the nums list starting from the second element.\\nCompare the current element with all the previous elements (from 0 to i-1).\\nIf the current element is greater than a previous element, it can be part of an increasing subsequence. Update the dp1 and dp2 arrays accordingly to keep track of the length and count of LIS ending at each index.\\nTrack the maximum length of LIS (maxval) and the count of LIS of that length (count) found so far.\\nIf we encounter an LIS of greater length, update maxval and reset the count to the count of LIS for the current element. If we encounter an LIS of the same length, add the count of LIS for the current element to the existing count.\\nFinally, return the final count of longest increasing subsequences, which is stored in the count variable.\\nComplexity\\n\\n# Time complexity: The time complexity of this approach is O(n^2), where n is the length of the input list nums. This is because we have nested loops to compare each element with all previous elements.\\nSpace complexity: The space complexity is O(n) since we use two arrays, dp1 and dp2, to store the length and count of LIS, each of size n.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        # Check if the input list \\'nums\\' is empty\\n        if not nums:\\n            return 0\\n        \\n        # Initialize two arrays, dp1 and dp2, with all 1\\'s to store the length and count of LIS respectively\\n        dp1, dp2 = [1] * len(nums), [1] * len(nums)\\n        \\n        # Initialize \\'count\\' and \\'maxval\\' variables to track the maximum length and count of LIS found so far\\n        count, maxval = 1, 1\\n        \\n        # Loop through the \\'nums\\' list starting from the second element\\n        for i in range(1, len(nums)):\\n            # Compare the current element with all the previous elements (from 0 to i-1)\\n            for j in range(i):\\n                # If the current element is greater than the previous element, it can be part of the LIS\\n                if nums[i] > nums[j]:\\n                    # If the LIS ending at the current element (i) is longer than the LIS ending at the previous element (j),\\n                    # update the length and count of LIS for the current element (i)\\n                    if dp1[j] + 1 > dp1[i]:\\n                        dp1[i], dp2[i] = dp1[j] + 1, dp2[j]\\n                    # If the LIS ending at the current element (i) has the same length as the LIS ending at the previous element (j),\\n                    # add the count of LIS ending at the previous element (j) to the count of LIS for the current element (i)\\n                    elif dp1[j] + 1 == dp1[i]:\\n                        dp2[i] += dp2[j]\\n\\n            # Update \\'maxval\\' and \\'count\\' if the length of LIS for the current element (i) is greater than or equal to \\'maxval\\'\\n            if dp1[i] > maxval:\\n                maxval, count = dp1[i], dp2[i]\\n            elif dp1[i] == maxval:\\n                count += dp2[i]\\n\\n        # Return the final count of longest increasing subsequences\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        # Check if the input list \\'nums\\' is empty\\n        if not nums:\\n            return 0\\n        \\n        # Initialize two arrays, dp1 and dp2, with all 1\\'s to store the length and count of LIS respectively\\n        dp1, dp2 = [1] * len(nums), [1] * len(nums)\\n        \\n        # Initialize \\'count\\' and \\'maxval\\' variables to track the maximum length and count of LIS found so far\\n        count, maxval = 1, 1\\n        \\n        # Loop through the \\'nums\\' list starting from the second element\\n        for i in range(1, len(nums)):\\n            # Compare the current element with all the previous elements (from 0 to i-1)\\n            for j in range(i):\\n                # If the current element is greater than the previous element, it can be part of the LIS\\n                if nums[i] > nums[j]:\\n                    # If the LIS ending at the current element (i) is longer than the LIS ending at the previous element (j),\\n                    # update the length and count of LIS for the current element (i)\\n                    if dp1[j] + 1 > dp1[i]:\\n                        dp1[i], dp2[i] = dp1[j] + 1, dp2[j]\\n                    # If the LIS ending at the current element (i) has the same length as the LIS ending at the previous element (j),\\n                    # add the count of LIS ending at the previous element (j) to the count of LIS for the current element (i)\\n                    elif dp1[j] + 1 == dp1[i]:\\n                        dp2[i] += dp2[j]\\n\\n            # Update \\'maxval\\' and \\'count\\' if the length of LIS for the current element (i) is greater than or equal to \\'maxval\\'\\n            if dp1[i] > maxval:\\n                maxval, count = dp1[i], dp2[i]\\n            elif dp1[i] == maxval:\\n                count += dp2[i]\\n\\n        # Return the final count of longest increasing subsequences\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796953,
                "title": "beats-99-4-video-cracking-the-code-dp-longest-increasing-subsequences",
                "content": "# Intuition\\nUpon seeing this problem, I realized that it was a classic dynamic programming problem. It\\'s about finding the number of longest strictly increasing subsequences in an array. A sequence is increasing if every number is larger than the one before. The intuition here was to keep track of two lists: one for the length of the longest increasing subsequence ending at each index, and another for the count of such subsequences.\\n\\nhttps://youtu.be/yqAwQtoT9jk\\n\\n# Approach\\nMy approach involves initializing two lists: `dp` and `count`, both filled initially with ones, representing the length and count of the longest subsequence ending at each index. \\n\\nThen, using a nested loop, every pair of indices are compared. If a number larger than the current one is found, it means we can extend the subsequence. In this case, `dp` and `count` lists are updated accordingly. \\n\\nFinally, the maximum length of the subsequences is found using the `max` function on the `dp` list. Then the counts of subsequences that have this maximum length are summed up, which yields our final answer.\\n\\n# Complexity\\n- Time complexity: \\nThe time complexity for this approach is O(n^2), where n is the size of the input list. This is due to the nested loop comparing each pair of indices.\\n\\n- Space complexity: \\nThe space complexity is O(n), which is used to store the `dp` and `count` lists.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums) \\n        count = [1] * len(nums) \\n        for i in range(len(nums)): \\n            for j in range(i): \\n                if nums[i] > nums[j]: \\n                    if dp[j] >= dp[i]: \\n                        dp[i] = dp[j] + 1  \\n                        count[i] = count[j]  \\n                    elif dp[j] + 1 == dp[i]:  \\n                        count[i] += count[j]  \\n        max_length = max(dp) \\n        return sum(c for d, c in zip(dp, count) if d == max_length)\\n```\\n``` JavaScript []\\nvar findNumberOfLIS = function(nums) {\\n    let n = nums.length, res = 0, max_len = 0; \\n    let len = new Array(n).fill(0), cnt = new Array(n).fill(0); \\n    for(let i = 0; i < n; i++){ \\n            len[i] = cnt[i] = 1; \\n        for(let j = 0; j < i; j++){ \\n            if(nums[i] > nums[j]){ \\n                if(len[i] == len[j] + 1) \\n                    cnt[i] += cnt[j]; \\n                if(len[i] < len[j] + 1){ \\n                    len[i] = len[j] + 1; \\n                    cnt[i] = cnt[j]; \\n                } \\n            } \\n        } \\n        if(max_len == len[i]) \\n            res += cnt[i]; \\n        if(max_len < len[i]){ \\n            max_len = len[i]; \\n            res = cnt[i]; \\n        } \\n    } \\n    return res;            \\n};\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size(), res = 0, max_len = 0; \\n        vector<int> len(n, 0), cnt(n, 0); \\n        for(int i=0; i<n; i++){ \\n            len[i] = cnt[i] = 1; \\n            for(int j=0; j <i; j++){ \\n                if(nums[i] > nums[j]){ \\n                    if(len[i] == len[j] + 1) \\n                        cnt[i] += cnt[j]; \\n                    if(len[i] < len[j] + 1){ \\n                        len[i] = len[j] + 1; \\n                        cnt[i] = cnt[j]; \\n                    } \\n                } \\n            } \\n            if(max_len == len[i]) \\n                res += cnt[i]; \\n            if(max_len < len[i]){ \\n                max_len = len[i]; \\n                res = cnt[i]; \\n            } \\n        } \\n        return res; \\n                                                                                                                                                                                                                                                                                                                                              \\n    }\\n};\\n```\\nI hope this approach provides a clear solution to the problem. Please comment below if you have any questions!",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums) \\n        count = [1] * len(nums) \\n        for i in range(len(nums)): \\n            for j in range(i): \\n                if nums[i] > nums[j]: \\n                    if dp[j] >= dp[i]: \\n                        dp[i] = dp[j] + 1  \\n                        count[i] = count[j]  \\n                    elif dp[j] + 1 == dp[i]:  \\n                        count[i] += count[j]  \\n        max_length = max(dp) \\n        return sum(c for d, c in zip(dp, count) if d == max_length)\\n```\n``` JavaScript []\\nvar findNumberOfLIS = function(nums) {\\n    let n = nums.length, res = 0, max_len = 0; \\n    let len = new Array(n).fill(0), cnt = new Array(n).fill(0); \\n    for(let i = 0; i < n; i++){ \\n            len[i] = cnt[i] = 1; \\n        for(let j = 0; j < i; j++){ \\n            if(nums[i] > nums[j]){ \\n                if(len[i] == len[j] + 1) \\n                    cnt[i] += cnt[j]; \\n                if(len[i] < len[j] + 1){ \\n                    len[i] = len[j] + 1; \\n                    cnt[i] = cnt[j]; \\n                } \\n            } \\n        } \\n        if(max_len == len[i]) \\n            res += cnt[i]; \\n        if(max_len < len[i]){ \\n            max_len = len[i]; \\n            res = cnt[i]; \\n        } \\n    } \\n    return res;            \\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size(), res = 0, max_len = 0; \\n        vector<int> len(n, 0), cnt(n, 0); \\n        for(int i=0; i<n; i++){ \\n            len[i] = cnt[i] = 1; \\n            for(int j=0; j <i; j++){ \\n                if(nums[i] > nums[j]){ \\n                    if(len[i] == len[j] + 1) \\n                        cnt[i] += cnt[j]; \\n                    if(len[i] < len[j] + 1){ \\n                        len[i] = len[j] + 1; \\n                        cnt[i] = cnt[j]; \\n                    } \\n                } \\n            } \\n            if(max_len == len[i]) \\n                res += cnt[i]; \\n            if(max_len < len[i]){ \\n                max_len = len[i]; \\n                res = cnt[i]; \\n            } \\n        } \\n        return res; \\n                                                                                                                                                                                                                                                                                                                                              \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796150,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn this problem, we are given an integer array nums, we need to return the number of longest increasing subsequences. We use dynamic programming to find the number of longest increasing subsequences (LIS) in the vector nums. We do this by maintaining two vectors, length and count, to track the length and count of LIS ending at each index. The solution then finds the maximum length and counts the number of subsequences with that length.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe explanation is as follows:\\n- Create two vectors length and count, both of size n, initialized with 1.\\n- Iterate through nums to update length and count for each index by considering previous elements.\\n- Find the maxLength of the LIS by taking the maximum value from the length vector.\\n- Count the number of subsequences with length equal to maxLength.\\n- Return the count of longest increasing subsequences.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> length(n,1);\\n        vector<int> count(n,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=0;\\n                    }\\n                    if(length[j]+1==length[i]) count[i]+=count[j];\\n                }\\n            }\\n        }\\n        int maxLength= *max_element(length.begin(),length.end());\\n        int result=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLength) result+=count[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> length(n,1);\\n        vector<int> count(n,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=0;\\n                    }\\n                    if(length[j]+1==length[i]) count[i]+=count[j];\\n                }\\n            }\\n        }\\n        int maxLength= *max_element(length.begin(),length.end());\\n        int result=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLength) result+=count[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794909,
                "title": "c-solution-for-number-of-longest-increasing-subsequence-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the number of longest increasing subsequences. We can use dynamic programming to solve this problem efficiently. The idea is to maintain two arrays to track the length of the longest increasing subsequence ending at each index and the count of such subsequences. By updating these arrays while iterating through the array, we can find the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize two arrays lengths and counts of the same length as the input array nums. These arrays will be used to track the length of the longest increasing subsequence ending at each index and the count of such subsequences.\\n- Initialize each element in both arrays to 1, as each element itself is an increasing subsequence of length 1.\\n- Iterate through the array nums starting from the second element (index 1).\\n- For each element nums[i], compare it with all the previous elements in the array (indices 0 to i-1).\\n- If nums[i] is greater than the previous element nums[j], it can be part of a longer increasing subsequence. We update lengths[i] and counts[i] accordingly:\\n1. If lengths[j] + 1 > lengths[i], it means we found a longer increasing subsequence ending at nums[i]. So, update lengths[i] = lengths[j] + 1 and set counts[i] = counts[j].\\n1. If lengths[j] + 1 == lengths[i], it means we found another increasing subsequence of the same length as the current longest ending at nums[i]. So, increment counts[i] by counts[j].\\n- Keep track of the maximum length found so far (maxLength).\\n- After iterating through the array, we will have the length of the longest increasing subsequence (maxLength). Now, iterate through the lengths array again to count the number of subsequences with length equal to maxLength. Sum up the counts for such subsequences to get the final result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n^2), where n is the length of the input array nums. This is because we use two nested loops to compare each element with all previous elements.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) as we use two arrays of size n (lengths and counts) to keep track of the length of subsequences and their counts.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        int n = nums.Length;\\n        if (n == 0) return 0;\\n        \\n        int[] lengths = new int[n]; // To store the length of the longest increasing subsequence ending at each index\\n        int[] counts = new int[n];  // To store the count of such subsequences\\n        \\n        // Initialize lengths and counts arrays with default values\\n        for (int i = 0; i < n; i++) {\\n            lengths[i] = 1; // Each element is an increasing subsequence of length 1\\n            counts[i] = 1;  // Each element itself is a subsequence\\n        }\\n        \\n        int maxLength = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.Max(maxLength, lengths[i]);\\n        }\\n        \\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (lengths[i] == maxLength) {\\n                result += counts[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        int n = nums.Length;\\n        if (n == 0) return 0;\\n        \\n        int[] lengths = new int[n]; // To store the length of the longest increasing subsequence ending at each index\\n        int[] counts = new int[n];  // To store the count of such subsequences\\n        \\n        // Initialize lengths and counts arrays with default values\\n        for (int i = 0; i < n; i++) {\\n            lengths[i] = 1; // Each element is an increasing subsequence of length 1\\n            counts[i] = 1;  // Each element itself is a subsequence\\n        }\\n        \\n        int maxLength = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.Max(maxLength, lengths[i]);\\n        }\\n        \\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (lengths[i] == maxLength) {\\n                result += counts[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794850,
                "title": "c-dp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n       int n=nums.size();\\n\\n       vector<int>dp(n,1),ct(n,1); \\n       int mx_len=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=i-1;j>=0;j--){\\n               if(nums[i]>nums[j]){\\n                   if(dp[i]<1+dp[j]){\\n                       ct[i]=ct[j];\\n                   }else if(dp[i]==1+dp[j]){\\n                       ct[i]+=ct[j];\\n                   }\\n                   dp[i]=max(dp[i],1+dp[j]);\\n               }\\n           }\\n           mx_len=max(mx_len,dp[i]);\\n       }\\n       int ans=0;\\n       for(int i=0;i<n;i++)if(dp[i]==mx_len)ans+=ct[i];\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n       int n=nums.size();\\n\\n       vector<int>dp(n,1),ct(n,1); \\n       int mx_len=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=i-1;j>=0;j--){\\n               if(nums[i]>nums[j]){\\n                   if(dp[i]<1+dp[j]){\\n                       ct[i]=ct[j];\\n                   }else if(dp[i]==1+dp[j]){\\n                       ct[i]+=ct[j];\\n                   }\\n                   dp[i]=max(dp[i],1+dp[j]);\\n               }\\n           }\\n           mx_len=max(mx_len,dp[i]);\\n       }\\n       int ans=0;\\n       for(int i=0;i<n;i++)if(dp[i]==mx_len)ans+=ct[i];\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606978,
                "title": "longest-increasing-subsequence-variant",
                "content": "# Intuition\\nThe problem asks us to find the number of longest increasing subsequences in the given array. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the size of the input array nums. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we are using two additional vectors, dp and cnt, both of size n, to store the lengths of subsequences and their counts.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426984,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty()) {\\n            return 0;\\n        }\\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                options = dyn[row].back().second; \\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        return dyn[max_so_far-1].back().second;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom typing import List\\nimport bisect\\n\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n       int num = nums.length;\\n       List<int[]>[] len = new ArrayList[num];\\n       for(int i = 0; i< num ; i++){\\n           len[i] = new ArrayList<>();\\n       }\\n       int size = 0;\\n       for(int n : nums){\\n           int index = bSearchLength(len,size,n);\\n           int count = 1;\\n\\n           if(index > 0){\\n               List<int[]> t = len[index-1];\\n               int p = bSearchIndex(t,n);\\n               count = t.get(t.size()-1)[1] - (p == 0 ? 0 : t.get(p-1)[1]);\\n           }\\n           if(len[index].size()==0){\\n               len[index].add(new int[]{n,count});\\n               size++;\\n           } else {\\n               List<int[]> t = len[index];\\n               int[] last = t.get(t.size()-1);\\n               int ch = last[1]+count;\\n               if(last[0] == n){\\n                   last[1]+=count;\\n               } else {\\n                   t.add(new int[]{n,last[1]+count});\\n               }\\n           }\\n       }\\n       return len[size-1].get(len[size-1].size()-1)[1];\\n    }\\n    public int bSearchLength(List<int[]>[] len,int right,int n){\\n        int left = 0;\\n         while(left<right){\\n                int mid = (left+right)/2;\\n                if(n > len[mid].get(len[mid].size()-1)[0])\\n                    left = mid + 1;\\n                else\\n                    right = mid;\\n        }\\n        return left;\\n    }\\n    public int bSearchIndex(List<int[]> t,int num){\\n        int left = 0 , right = t.size()-1;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(num <= t.get(mid)[0])\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty()) {\\n            return 0;\\n        }\\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                options = dyn[row].back().second; \\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        return dyn[max_so_far-1].back().second;\\n    }\\n};\\n```\n```Python3 []\\nfrom typing import List\\nimport bisect\\n\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n       int num = nums.length;\\n       List<int[]>[] len = new ArrayList[num];\\n       for(int i = 0; i< num ; i++){\\n           len[i] = new ArrayList<>();\\n       }\\n       int size = 0;\\n       for(int n : nums){\\n           int index = bSearchLength(len,size,n);\\n           int count = 1;\\n\\n           if(index > 0){\\n               List<int[]> t = len[index-1];\\n               int p = bSearchIndex(t,n);\\n               count = t.get(t.size()-1)[1] - (p == 0 ? 0 : t.get(p-1)[1]);\\n           }\\n           if(len[index].size()==0){\\n               len[index].add(new int[]{n,count});\\n               size++;\\n           } else {\\n               List<int[]> t = len[index];\\n               int[] last = t.get(t.size()-1);\\n               int ch = last[1]+count;\\n               if(last[0] == n){\\n                   last[1]+=count;\\n               } else {\\n                   t.add(new int[]{n,last[1]+count});\\n               }\\n           }\\n       }\\n       return len[size-1].get(len[size-1].size()-1)[1];\\n    }\\n    public int bSearchLength(List<int[]>[] len,int right,int n){\\n        int left = 0;\\n         while(left<right){\\n                int mid = (left+right)/2;\\n                if(n > len[mid].get(len[mid].size()-1)[0])\\n                    left = mid + 1;\\n                else\\n                    right = mid;\\n        }\\n        return left;\\n    }\\n    public int bSearchIndex(List<int[]> t,int num){\\n        int left = 0 , right = t.size()-1;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(num <= t.get(mid)[0])\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311369,
                "title": "c-dp-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n, 1), cnt(n, 1);\\n        int maxi=1, ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[i]>nums[j] && dp[i]==1+dp[j]){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi, dp[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n, 1), cnt(n, 1);\\n        int maxi=1, ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[i]>nums[j] && dp[i]==1+dp[j]){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi, dp[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288914,
                "title": "c-simplest-solution-lis-pattern-dp-striver",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), cut(n, 1);\\n        int maxi = INT_MIN;\\n        int ans = 0;\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (arr[prev] < arr[ind] && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                    cut[ind] = cut[prev];\\n                }\\n                else if(arr[prev] < arr[ind] && 1 + dp[prev] == dp[ind]) {\\n                    cut[ind] += cut[prev];\\n                }\\n            }\\n            maxi = max(maxi, dp[ind]);\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] == maxi) ans += cut[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), cut(n, 1);\\n        int maxi = INT_MIN;\\n        int ans = 0;\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (arr[prev] < arr[ind] && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                    cut[ind] = cut[prev];\\n                }\\n                else if(arr[prev] < arr[ind] && 1 + dp[prev] == dp[ind]) {\\n                    cut[ind] += cut[prev];\\n                }\\n            }\\n            maxi = max(maxi, dp[ind]);\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] == maxi) ans += cut[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217439,
                "title": "binary-indexed-tree-fenwick-tree-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://leetcode.com/problems/number-of-longest-increasing-subsequence/solutions/112521/c-short-binary-indexed-tree-beats-98-54-with-comments/\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        class BIT:\\n            # There are 2 binary index trees\\n            # one to store the longest increasing subsequence up until a given index\\n            # second to store the count of this lic at given index \\n            def __init__(self, size) -> None:\\n                self.size = size + 1\\n                self.lic = [0] * self.size\\n                self.count = [0] * self.size\\n\\n            def update(self, idx, lic, count):\\n                idx += 1\\n                while idx < self.size:\\n                    if self.lic[idx] == lic:\\n                        self.count[idx] += count\\n                    elif self.lic[idx] < lic:\\n                        self.lic[idx] = lic\\n                        self.count[idx] = count\\n                    idx += idx & (-idx)\\n\\n            def query(self, idx):\\n                lic = 0\\n                count = 0\\n                idx += 1\\n                while idx > 0:\\n                    if self.lic[idx] == lic:\\n                        count += self.count[idx]\\n                    elif self.lic[idx] > lic:\\n                        lic = self.lic[idx]\\n                        count = self.count[idx]\\n                    idx -= idx & (-idx)\\n                return lic, count \\n\\n        def solve(nums):\\n            temp = sorted(set(nums))\\n            n = len(temp)\\n            bit = BIT(n)\\n            maxlength = 0\\n            total = 0\\n            for num in nums:\\n                idx = bisect.bisect_left(temp, num)\\n                # get the values up until this index\\n                lic, count = bit.query(idx - 1)\\n                # add the inclusion of this iterated value in its lic\\n                lic += 1\\n                if lic == 1:\\n                    count = 1\\n                if lic == maxlength:\\n                    total += count\\n                elif lic > maxlength:\\n                    maxlength = lic\\n                    total = count\\n                bit.update(idx, lic, count)\\n            return total\\n\\n        return solve(nums)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        class BIT:\\n            # There are 2 binary index trees\\n            # one to store the longest increasing subsequence up until a given index\\n            # second to store the count of this lic at given index \\n            def __init__(self, size) -> None:\\n                self.size = size + 1\\n                self.lic = [0] * self.size\\n                self.count = [0] * self.size\\n\\n            def update(self, idx, lic, count):\\n                idx += 1\\n                while idx < self.size:\\n                    if self.lic[idx] == lic:\\n                        self.count[idx] += count\\n                    elif self.lic[idx] < lic:\\n                        self.lic[idx] = lic\\n                        self.count[idx] = count\\n                    idx += idx & (-idx)\\n\\n            def query(self, idx):\\n                lic = 0\\n                count = 0\\n                idx += 1\\n                while idx > 0:\\n                    if self.lic[idx] == lic:\\n                        count += self.count[idx]\\n                    elif self.lic[idx] > lic:\\n                        lic = self.lic[idx]\\n                        count = self.count[idx]\\n                    idx -= idx & (-idx)\\n                return lic, count \\n\\n        def solve(nums):\\n            temp = sorted(set(nums))\\n            n = len(temp)\\n            bit = BIT(n)\\n            maxlength = 0\\n            total = 0\\n            for num in nums:\\n                idx = bisect.bisect_left(temp, num)\\n                # get the values up until this index\\n                lic, count = bit.query(idx - 1)\\n                # add the inclusion of this iterated value in its lic\\n                lic += 1\\n                if lic == 1:\\n                    count = 1\\n                if lic == maxlength:\\n                    total += count\\n                elif lic > maxlength:\\n                    maxlength = lic\\n                    total = count\\n                bit.update(idx, lic, count)\\n            return total\\n\\n        return solve(nums)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093617,
                "title": "c-dp-solution-with-explanation-in-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int sol(vector<int>& nums,int n){\\n        vector<int>list(n);//lenght of LIS ending at index i\\n        vector<int>count(n,1);//number of LIS that can be generated at index i\\n        list[0]=1;\\n        for(int i=1;i<n;i++){\\n            list[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && list[i]<list[j]+1)\\n                {\\n                    list[i]=list[j]+1;//Since we are encountering a new LIS  we will not increase the count\\n                    count[i]=count[j];\\n                }   \\n                else if(nums[i]>nums[j] && list[i]==list[j]+1){\\n                    //we are getting more than one lis since we already have a lenght of that particular lis present in our list array\\n                    count[i]=count[j]+count[i];//count array will store no of lis ending at i possible\\n//list array will store the length of lis ending at index i so count will store no of ways to get that particular LIS\\n                }\\n            }\\n    }\\n    \\n   int maxi=*max_element(list.begin(),list.end());\\n   int q=0;\\n   for(int i=0;i<list.size();i++){\\n       if(list[i]==maxi)\\n       q+=count[i];\\n   }\\n    return q;\\n}\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        return sol(nums,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol(vector<int>& nums,int n){\\n        vector<int>list(n);//lenght of LIS ending at index i\\n        vector<int>count(n,1);//number of LIS that can be generated at index i\\n        list[0]=1;\\n        for(int i=1;i<n;i++){\\n            list[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && list[i]<list[j]+1)\\n                {\\n                    list[i]=list[j]+1;//Since we are encountering a new LIS  we will not increase the count\\n                    count[i]=count[j];\\n                }   \\n                else if(nums[i]>nums[j] && list[i]==list[j]+1){\\n                    //we are getting more than one lis since we already have a lenght of that particular lis present in our list array\\n                    count[i]=count[j]+count[i];//count array will store no of lis ending at i possible\\n//list array will store the length of lis ending at index i so count will store no of ways to get that particular LIS\\n                }\\n            }\\n    }\\n    \\n   int maxi=*max_element(list.begin(),list.end());\\n   int q=0;\\n   for(int i=0;i<list.size();i++){\\n       if(list[i]==maxi)\\n       q+=count[i];\\n   }\\n    return q;\\n}\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        return sol(nums,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863465,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  \\n        vector<int> count(n,1);  \\n        int maxLen = 1;  \\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ \\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  \\n        vector<int> count(n,1);  \\n        int maxLen = 1;  \\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ \\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718014,
                "title": "easy-and-explained-in-detail-java-solution-with-a-small-tweak-in-lis-must-refer",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int size = a.length;\\n        int[] dp = new int[size];\\n        int[] count = new int[size];\\n        Arrays.fill(dp , 1);\\n        Arrays.fill(count , 1);\\n        int maxLen = 0;\\n        \\n        for( int i=0 ; i<size ; i++ ){\\n            for( int prev=0 ; prev<i ; prev++ ){\\n                if(a[i] > a[prev]){\\n                    if(1 + dp[prev] > dp[i]){\\n                       dp[i] = 1 + dp[prev];\\n                       count[i] = count[prev]; // As LIS till i is now adding the LIS till prev. So no. of LIS of this length till i will become the no. of LIS at prev . Since count[prev] is holding the no. of LIS of length dp[prev] till prev index and we are just adding a[i] in our LIS till i. So count[i] becomes equal to count[prev]\\n                    }else if(1 + dp[prev] == dp[i]){  \\n                        count[i] += count[prev] ; // Since, no of LIS of this length \"1 + dp[prev]\" is already here at count[i]. Therefore count of LIS of this length increases by no of LIS of that length at count[prev].\\n                    }\\n                }\\n            }\\n            \\n            if(dp[i] > maxLen){\\n                maxLen = dp[i];\\n            }\\n        }\\n        \\n        int noOfLIS = 0;\\n        for( int i=0 ; i<size ; i++ ){\\n            if(dp[i] == maxLen) noOfLIS += count[i];\\n        }\\n        \\n        return noOfLIS;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int size = a.length;\\n        int[] dp = new int[size];\\n        int[] count = new int[size];\\n        Arrays.fill(dp , 1);\\n        Arrays.fill(count , 1);\\n        int maxLen = 0;\\n        \\n        for( int i=0 ; i<size ; i++ ){\\n            for( int prev=0 ; prev<i ; prev++ ){\\n                if(a[i] > a[prev]){\\n                    if(1 + dp[prev] > dp[i]){\\n                       dp[i] = 1 + dp[prev];\\n                       count[i] = count[prev]; // As LIS till i is now adding the LIS till prev. So no. of LIS of this length till i will become the no. of LIS at prev . Since count[prev] is holding the no. of LIS of length dp[prev] till prev index and we are just adding a[i] in our LIS till i. So count[i] becomes equal to count[prev]\\n                    }else if(1 + dp[prev] == dp[i]){  \\n                        count[i] += count[prev] ; // Since, no of LIS of this length \"1 + dp[prev]\" is already here at count[i]. Therefore count of LIS of this length increases by no of LIS of that length at count[prev].\\n                    }\\n                }\\n            }\\n            \\n            if(dp[i] > maxLen){\\n                maxLen = dp[i];\\n            }\\n        }\\n        \\n        int noOfLIS = 0;\\n        for( int i=0 ; i<size ; i++ ){\\n            if(dp[i] == maxLen) noOfLIS += count[i];\\n        }\\n        \\n        return noOfLIS;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584413,
                "title": "java-lis-technique-easy-intuitive",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n];\\n        int cnt[]=new int[n]; /*For count array*/\\n        Arrays.fill(dp,1);\\n        Arrays.fill(cnt,1);\\n        int max=1;\\n        int res=0;\\n        for(int ind=0;ind<n;ind++){\\n            for(int prev=0;prev<ind;prev++){\\n                if(nums[ind]>nums[prev] && 1+dp[prev]>dp[ind]){\\n                    dp[ind]=1+dp[prev];\\n                    cnt[ind]=cnt[prev]; /*If its largest then inherit or copy the count\\n\\t\\t\\t\\t\\t                      from previous element*/\\n                }\\n                else if(nums[ind]>nums[prev] && 1+dp[prev]==dp[ind]){\\n                    cnt[ind]=cnt[ind]+cnt[prev]; /*If the lis length is same then count the \\n\\t\\t\\t\\t\\t                               different occurences of same length by adding \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   the current count and previous count so that \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   we can know the number of occurences \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   of same length. */\\n                }\\n            }\\n            if(dp[ind]>max){\\n                max=dp[ind];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max) /*After finding the length of lis which is in max, we just traverse the dp array \\n\\t\\t\\t                 and whichever element has same max length, their corresponding \\n\\t\\t\\t\\t\\t\\t\\t count from cnt will be added.*/ \\n                res+=cnt[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n];\\n        int cnt[]=new int[n]; /*For count array*/\\n        Arrays.fill(dp,1);\\n        Arrays.fill(cnt,1);\\n        int max=1;\\n        int res=0;\\n        for(int ind=0;ind<n;ind++){\\n            for(int prev=0;prev<ind;prev++){\\n                if(nums[ind]>nums[prev] && 1+dp[prev]>dp[ind]){\\n                    dp[ind]=1+dp[prev];\\n                    cnt[ind]=cnt[prev]; /*If its largest then inherit or copy the count\\n\\t\\t\\t\\t\\t                      from previous element*/\\n                }\\n                else if(nums[ind]>nums[prev] && 1+dp[prev]==dp[ind]){\\n                    cnt[ind]=cnt[ind]+cnt[prev]; /*If the lis length is same then count the \\n\\t\\t\\t\\t\\t                               different occurences of same length by adding \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   the current count and previous count so that \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   we can know the number of occurences \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   of same length. */\\n                }\\n            }\\n            if(dp[ind]>max){\\n                max=dp[ind];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max) /*After finding the length of lis which is in max, we just traverse the dp array \\n\\t\\t\\t                 and whichever element has same max length, their corresponding \\n\\t\\t\\t\\t\\t\\t\\t count from cnt will be added.*/ \\n                res+=cnt[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314035,
                "title": "c-dp-lis-variation",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size(), maxi=1;\\n        vector<int> dp(n,1), cnt(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                \\n                if(nums[j]<nums[i] && dp[j]+1>dp[i]){\\n                    dp[i]=dp[j]+1;\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[j]<nums[i] && dp[i]==dp[j]+1){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size(), maxi=1;\\n        vector<int> dp(n,1), cnt(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                \\n                if(nums[j]<nums[i] && dp[j]+1>dp[i]){\\n                    dp[i]=dp[j]+1;\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[j]<nums[i] && dp[i]==dp[j]+1){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2188960,
                "title": "c-dp-solution-longest-increasing-subsequence-array-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // O(N^2) DP Solution\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(N^2) DP Solution\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881188,
                "title": "python-dp-solution-explained",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums)\\n        ct = [1] * len(nums)\\n        maxLen, maxCt = 0, 0\\n        \\n        # same as the LIS code, iterate\\n        # over all the elements once and then\\n        # from 0 -> i again to compute LISs\\n        for i in range(len(nums)):\\n            for j in range(i):\\n                # If it\\'s a valid LIS\\n                if nums[i] > nums[j]:\\n                    # and if the length\\n                    # of LIS at i wrt j\\n                    # is going to be increased\\n                    # update the length dp\\n                    # and since this is just one\\n                    # continous LIS, count of i\\n                    # will become same as that of j\\n                    if dp[j]+1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        ct[i] = ct[j]\\n                    # if on the other hand, the\\n                    # length of the LIS at i becomes\\n                    # the same as it was, it means\\n                    # there\\'s another LIS of this same\\n                    # length, in this case, add the LIS\\n                    # count of j to i, because the current\\n                    # LIS count at i consists of ways to get\\n                    # to this LIS from another path, and now\\n                    # we\\'re at a new path, so sum thse up\\n                    # there\\'s no point\\n                    # in updating the length LIS here.\\n                    elif dp[i] == dp[j] + 1:\\n                        ct[i] += ct[j]\\n            \\n            # at any point, keep track\\n            # of the maxLen and maxCt\\n            # we\\'ll use it to compute our result\\n            if dp[i] > maxLen:\\n                maxLen = dp[i]\\n                \\n        # now, we have the maxLength\\n        # of the given nums, we can iterate\\n        # over all 3 arrays (hypothetically)\\n        # and just add up the count of all those\\n        # LIS which are the longest (maxLen)\\n        # and that\\'s the result\\n        for i in range(len(nums)):\\n            if maxLen == dp[i]:\\n                maxCt += ct[i]\\n    \\n \\n        return maxCt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums)\\n        ct = [1] * len(nums)\\n        maxLen, maxCt = 0, 0\\n        \\n        # same as the LIS code, iterate\\n        # over all the elements once and then\\n        # from 0 -> i again to compute LISs\\n        for i in range(len(nums)):\\n            for j in range(i):\\n                # If it\\'s a valid LIS\\n                if nums[i] > nums[j]:\\n                    # and if the length\\n                    # of LIS at i wrt j\\n                    # is going to be increased\\n                    # update the length dp\\n                    # and since this is just one\\n                    # continous LIS, count of i\\n                    # will become same as that of j\\n                    if dp[j]+1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        ct[i] = ct[j]\\n                    # if on the other hand, the\\n                    # length of the LIS at i becomes\\n                    # the same as it was, it means\\n                    # there\\'s another LIS of this same\\n                    # length, in this case, add the LIS\\n                    # count of j to i, because the current\\n                    # LIS count at i consists of ways to get\\n                    # to this LIS from another path, and now\\n                    # we\\'re at a new path, so sum thse up\\n                    # there\\'s no point\\n                    # in updating the length LIS here.\\n                    elif dp[i] == dp[j] + 1:\\n                        ct[i] += ct[j]\\n            \\n            # at any point, keep track\\n            # of the maxLen and maxCt\\n            # we\\'ll use it to compute our result\\n            if dp[i] > maxLen:\\n                maxLen = dp[i]\\n                \\n        # now, we have the maxLength\\n        # of the given nums, we can iterate\\n        # over all 3 arrays (hypothetically)\\n        # and just add up the count of all those\\n        # LIS which are the longest (maxLen)\\n        # and that\\'s the result\\n        for i in range(len(nums)):\\n            if maxLen == dp[i]:\\n                maxCt += ct[i]\\n    \\n \\n        return maxCt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853678,
                "title": "c-easy-to-understand-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n            return 0;\\n        vector<int>dp(n,1);\\n        vector<int>count(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(1+dp[j]>dp[i])\\n                    {\\n                        dp[i]=1+dp[j];\\n                        count[i]=count[j];\\n                    }\\n                    else if(1+dp[j]==dp[i])\\n                        count[i]+=count[j];     \\n                }\\n                    \\n            }\\n            ans = max(ans,dp[i]);\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==ans)\\n                res+=count[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\nThe main idea is that we have to count no. of ways to get the max value of LIS.For that we will traverse our dp array.Search for all the places where max lis is.Also we will keep a count array and when we check nums[i]>nums[j],there we also check the dp value.If 1+dp[j]==dp[i] then we will add the count of j to count of i.\\nCode is simple to understand.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n            return 0;\\n        vector<int>dp(n,1);\\n        vector<int>count(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(1+dp[j]>dp[i])\\n                    {\\n                        dp[i]=1+dp[j];\\n                        count[i]=count[j];\\n                    }\\n                    else if(1+dp[j]==dp[i])\\n                        count[i]+=count[j];     \\n                }\\n                    \\n            }\\n            ans = max(ans,dp[i]);\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==ans)\\n                res+=count[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853107,
                "title": "python-dp-basically-another-climbing-stairs",
                "content": "We have two goals: \\n1. For a position i in nums, we want to first know which position j (could be many of them) has the longest subsequence for j < i and nums[j] < nums[i]. This follows the idea from #300 longest increasing subsequence https://leetcode.com/problems/longest-increasing-subsequence/ \\n2. Then I want to know like climbing stairs, for each j, how many ways are there to get to j from the begining, adding these ways up gives me the ways to get to i with longest steps. Here we are not limited by \"taking 1 or 2 stairs at a time\" like in climbing stairs, instead we find out steps possible by looking at positions having the longest subsequence \\n\\nTo do this we create two dp list: \\n1. dpl for the length of longest subsequence ending on index i\\n2. dpw for number of ways to generate longest subsequence ending on index i\\n\\n\\n\\t\\tdef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tdpl = [1 for _ in range(len(nums))] # length  \\n\\t\\t\\tdpw = [0 for _ in range(len(nums))] # ways \\n\\t\\t\\tdpw[0] = 1 \\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\t# create a list for all the lengths before i\\n\\t\\t\\t\\tpredpl = [dpl[j] if nums[j] < nums[i] else 0 for j in range(i)] \\n\\t\\t\\t\\tpremax = max(predpl)\\n\\t\\t\\t\\tdpl[i] = premax + 1\\n\\n\\t\\t\\t\\tif premax == 0: # handle the edge case where there is no possible j before i\\n\\t\\t\\t\\t\\tdpw[i] = 1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tfor j in range(len(predpl)):\\n\\t\\t\\t\\t\\t\\t# find the longest subsequence and add up their \"ways\"\\n\\t\\t\\t\\t\\t\\t# similar to climb_stair(n) = climb_stair(n-1) + climb_stair(n-2) \\n\\t\\t\\t\\t\\t\\tif predpl[j] == premax: \\n\\t\\t\\t\\t\\t\\t\\tdpw[i] += dpw[j]\\n\\n\\t\\t\\tdpmax = max(dpl)\\n\\t\\t\\tcounter = 0 \\n\\t\\t\\tfor i in range(len(dpl)): \\n\\t\\t\\t\\tif dpl[i] == dpmax: \\n\\t\\t\\t\\t\\tcounter += dpw[i]\\n\\n\\t\\t\\treturn counter",
                "solutionTags": [],
                "code": "We have two goals: \\n1. For a position i in nums, we want to first know which position j (could be many of them) has the longest subsequence for j < i and nums[j] < nums[i]. This follows the idea from #300 longest increasing subsequence https://leetcode.com/problems/longest-increasing-subsequence/ \\n2. Then I want to know like climbing stairs, for each j, how many ways are there to get to j from the begining, adding these ways up gives me the ways to get to i with longest steps. Here we are not limited by \"taking 1 or 2 stairs at a time\" like in climbing stairs, instead we find out steps possible by looking at positions having the longest subsequence \\n\\nTo do this we create two dp list: \\n1. dpl for the length of longest subsequence ending on index i\\n2. dpw for number of ways to generate longest subsequence ending on index i\\n\\n\\n\\t\\tdef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tdpl = [1 for _ in range(len(nums))] # length  \\n\\t\\t\\tdpw = [0 for _ in range(len(nums))] # ways \\n\\t\\t\\tdpw[0] = 1 \\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\t# create a list for all the lengths before i\\n\\t\\t\\t\\tpredpl = [dpl[j] if nums[j] < nums[i] else 0 for j in range(i)] \\n\\t\\t\\t\\tpremax = max(predpl)\\n\\t\\t\\t\\tdpl[i] = premax + 1\\n\\n\\t\\t\\t\\tif premax == 0: # handle the edge case where there is no possible j before i\\n\\t\\t\\t\\t\\tdpw[i] = 1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tfor j in range(len(predpl)):\\n\\t\\t\\t\\t\\t\\t# find the longest subsequence and add up their \"ways\"\\n\\t\\t\\t\\t\\t\\t# similar to climb_stair(n) = climb_stair(n-1) + climb_stair(n-2) \\n\\t\\t\\t\\t\\t\\tif predpl[j] == premax: \\n\\t\\t\\t\\t\\t\\t\\tdpw[i] += dpw[j]\\n\\n\\t\\t\\tdpmax = max(dpl)\\n\\t\\t\\tcounter = 0 \\n\\t\\t\\tfor i in range(len(dpl)): \\n\\t\\t\\t\\tif dpl[i] == dpmax: \\n\\t\\t\\t\\t\\tcounter += dpw[i]\\n\\n\\t\\t\\treturn counter",
                "codeTag": "Python3"
            },
            {
                "id": 1603381,
                "title": "recursion-python",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        def helper(prev_num=float(\\'-inf\\'), curr_i=0):\\n            if curr_i == len(nums):\\n                return 0, 1\\n            if (prev_num, curr_i) in memo:\\n                return memo[(prev_num, curr_i)]\\n            if prev_num == float(\\'-inf\\') or prev_num < nums[curr_i]:\\n                length_1, count_1 = helper(nums[curr_i], curr_i + 1)\\n                length_2, count_2 = helper(prev_num, curr_i + 1)\\n                if length_1 + 1 > length_2:\\n                    memo[(prev_num, curr_i)] = length_1 + 1, count_1\\n                elif length_2 > length_1 + 1:\\n                    memo[(prev_num, curr_i)] = length_2, count_2\\n                else:\\n                    memo[(prev_num, curr_i)] = length_2, count_1 + count_2\\n\\n            else:\\n                memo[(prev_num, curr_i)] = helper(prev_num, curr_i + 1)\\n            return memo[(prev_num, curr_i)]\\n\\n        l, c = helper()\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        def helper(prev_num=float(\\'-inf\\'), curr_i=0):\\n            if curr_i == len(nums):\\n                return 0, 1\\n            if (prev_num, curr_i) in memo:\\n                return memo[(prev_num, curr_i)]\\n            if prev_num == float(\\'-inf\\') or prev_num < nums[curr_i]:\\n                length_1, count_1 = helper(nums[curr_i], curr_i + 1)\\n                length_2, count_2 = helper(prev_num, curr_i + 1)\\n                if length_1 + 1 > length_2:\\n                    memo[(prev_num, curr_i)] = length_1 + 1, count_1\\n                elif length_2 > length_1 + 1:\\n                    memo[(prev_num, curr_i)] = length_2, count_2\\n                else:\\n                    memo[(prev_num, curr_i)] = length_2, count_1 + count_2\\n\\n            else:\\n                memo[(prev_num, curr_i)] = helper(prev_num, curr_i + 1)\\n            return memo[(prev_num, curr_i)]\\n\\n        l, c = helper()\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596517,
                "title": "c-lis-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> lis(nums.size(),1),f(nums.size(),1);\\n        int mx=1,ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[i]<lis[j]+1){\\n                        lis[i]=1+lis[j];\\n                        f[i]=f[j];\\n                    }\\n                    else if(lis[i]==1+lis[j])f[i]+=f[j];\\n                }\\n            }\\n            mx=max(mx,lis[i]);\\n        }\\n        for(int j=0;j<nums.size();j++)if(lis[j]==mx)ans+=f[j];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> lis(nums.size(),1),f(nums.size(),1);\\n        int mx=1,ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[i]<lis[j]+1){\\n                        lis[i]=1+lis[j];\\n                        f[i]=f[j];\\n                    }\\n                    else if(lis[i]==1+lis[j])f[i]+=f[j];\\n                }\\n            }\\n            mx=max(mx,lis[i]);\\n        }\\n        for(int j=0;j<nums.size();j++)if(lis[j]==mx)ans+=f[j];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518162,
                "title": "c-clean-solution-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> len(nums.size(),1),times(nums.size(),1);\\n        int maxlen=0;\\n        for(int i=1;i<nums.size();++i){\\n            for(int j=0;j<i;++j){\\n                if(nums[j] < nums[i]){\\n                    if(len[j]+1 > len[i]){\\n                        len[i]=len[j]+1;\\n                        times[i] = times[j];\\n                    }\\n                    else if(len[j]+1 ==len[i])\\n                        times[i]+=times[j];\\n                }\\n                maxlen=max(maxlen,len[i]);\\n            }\\n        }\\n       int count=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(len[i] == maxlen)\\n                count+=times[i];\\n        }\\n        if(count==0) return 1;\\n        return count;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> len(nums.size(),1),times(nums.size(),1);\\n        int maxlen=0;\\n        for(int i=1;i<nums.size();++i){\\n            for(int j=0;j<i;++j){\\n                if(nums[j] < nums[i]){\\n                    if(len[j]+1 > len[i]){\\n                        len[i]=len[j]+1;\\n                        times[i] = times[j];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1493942,
                "title": "java-o-n-logn-segment-tree-array-based-and-tree-based-versions-beats-98",
                "content": "Tree-based version (6 ms):\\n```\\nclass Solution {\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        Segment root = new Segment((int) -1e6, (int) 1e6);\\n        for (int num : nums) {\\n            Sequence s = root.query(num - 1);\\n            root.update(num, new Sequence(s.length + 1, s.count));\\n        }\\n        return root.sequence.count;\\n    }\\n\\n    private static class Segment {\\n        final int left;\\n        final int middle;\\n        final int right;\\n        \\n        Segment leftChild;\\n        Segment rightChild;\\n        \\n        Sequence sequence = Sequence.EMPTY;\\n        \\n        Segment(int left, int right) {\\n            this.left = left;\\n            this.middle = left + (right - left) / 2;\\n            this.right = right;\\n        }\\n        \\n        void update(int value, Sequence s) {\\n            this.sequence = this.sequence.merge(s);\\n            \\n            if (this.left == this.middle) {\\n                return;\\n            }\\n            \\n            if (value < this.middle) {\\n                if (this.leftChild == null) {\\n                    this.leftChild = new Segment(this.left, this.middle);\\n                }\\n                this.leftChild.update(value, s);\\n            } else {\\n                if (this.rightChild == null) {\\n                    this.rightChild = new Segment(this.middle, this.right);\\n                }\\n                this.rightChild.update(value, s);\\n            }\\n        }\\n        \\n        Sequence query(int value) {\\n            if (this.left == this.middle) {\\n                return this.sequence;\\n            }\\n            \\n            if (value < this.middle) {\\n                return this.leftChild != null ? this.leftChild.query(value) : Sequence.EMPTY;\\n\\n            } else {\\n                Sequence left = this.leftChild != null ? this.leftChild.sequence : Sequence.EMPTY;\\n                Sequence right = this.rightChild != null ? this.rightChild.query(value) : Sequence.EMPTY;\\n                return left.merge(right);\\n            }\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```\\n\\nArray-based version (with coordinate compression, 9ms):\\n```\\nclass Solution {\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n        \\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 1;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i++]] = coordinate;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates to build the tree\\n        SegmentTree tree = new SegmentTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = tree.query(coordinates[i] - 1);\\n            tree.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n        return tree.query(coordinate - 1).count;\\n    }\\n    \\n    private static class SegmentTree {\\n        \\n        private final int n;\\n        private final Sequence[] tree;\\n        \\n        SegmentTree(int n) {\\n            this.n = n;\\n            this.tree = new Sequence[n * 2];\\n            Arrays.fill(tree, Sequence.EMPTY);\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx += n;\\n            tree[idx] = tree[idx].merge(s);\\n            \\n            while (idx > 1) {\\n                tree[idx >> 1] = tree[idx].merge(tree[idx ^ 1]);\\n                idx >>= 1;\\n            }\\n        }\\n        \\n        Sequence query(int r) {\\n            int l = n;\\n            r += n;\\n\\n            Sequence s = Sequence.EMPTY;\\n            while (l <= r) {\\n                if ((l & 1) == 1) {\\n                    s = s.merge(tree[l++]);\\n                }\\n                if ((r & 1) == 0) {\\n                    s = s.merge(tree[r--]);\\n                }\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            return s;\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        Segment root = new Segment((int) -1e6, (int) 1e6);\\n        for (int num : nums) {\\n            Sequence s = root.query(num - 1);\\n            root.update(num, new Sequence(s.length + 1, s.count));\\n        }\\n        return root.sequence.count;\\n    }\\n\\n    private static class Segment {\\n        final int left;\\n        final int middle;\\n        final int right;\\n        \\n        Segment leftChild;\\n        Segment rightChild;\\n        \\n        Sequence sequence = Sequence.EMPTY;\\n        \\n        Segment(int left, int right) {\\n            this.left = left;\\n            this.middle = left + (right - left) / 2;\\n            this.right = right;\\n        }\\n        \\n        void update(int value, Sequence s) {\\n            this.sequence = this.sequence.merge(s);\\n            \\n            if (this.left == this.middle) {\\n                return;\\n            }\\n            \\n            if (value < this.middle) {\\n                if (this.leftChild == null) {\\n                    this.leftChild = new Segment(this.left, this.middle);\\n                }\\n                this.leftChild.update(value, s);\\n            } else {\\n                if (this.rightChild == null) {\\n                    this.rightChild = new Segment(this.middle, this.right);\\n                }\\n                this.rightChild.update(value, s);\\n            }\\n        }\\n        \\n        Sequence query(int value) {\\n            if (this.left == this.middle) {\\n                return this.sequence;\\n            }\\n            \\n            if (value < this.middle) {\\n                return this.leftChild != null ? this.leftChild.query(value) : Sequence.EMPTY;\\n\\n            } else {\\n                Sequence left = this.leftChild != null ? this.leftChild.sequence : Sequence.EMPTY;\\n                Sequence right = this.rightChild != null ? this.rightChild.query(value) : Sequence.EMPTY;\\n                return left.merge(right);\\n            }\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n        \\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 1;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i++]] = coordinate;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates to build the tree\\n        SegmentTree tree = new SegmentTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = tree.query(coordinates[i] - 1);\\n            tree.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n        return tree.query(coordinate - 1).count;\\n    }\\n    \\n    private static class SegmentTree {\\n        \\n        private final int n;\\n        private final Sequence[] tree;\\n        \\n        SegmentTree(int n) {\\n            this.n = n;\\n            this.tree = new Sequence[n * 2];\\n            Arrays.fill(tree, Sequence.EMPTY);\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx += n;\\n            tree[idx] = tree[idx].merge(s);\\n            \\n            while (idx > 1) {\\n                tree[idx >> 1] = tree[idx].merge(tree[idx ^ 1]);\\n                idx >>= 1;\\n            }\\n        }\\n        \\n        Sequence query(int r) {\\n            int l = n;\\n            r += n;\\n\\n            Sequence s = Sequence.EMPTY;\\n            while (l <= r) {\\n                if ((l & 1) == 1) {\\n                    s = s.merge(tree[l++]);\\n                }\\n                if ((r & 1) == 0) {\\n                    s = s.merge(tree[r--]);\\n                }\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            return s;\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491691,
                "title": "java-o-n-logn-binary-indexed-tree-beats-98",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first the coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n\\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 0;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i]] = coordinate;\\n                i++;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates in a BIT\\n        BinaryIndexedTree bit = new BinaryIndexedTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = bit.query(coordinates[i] - 1);\\n            bit.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n    \\n        return bit.query(coordinate - 1).count;\\n    }\\n    \\n    private static final class BinaryIndexedTree {\\n        private final Sequence[] a;\\n        \\n        BinaryIndexedTree(int n) {\\n            this.a = new Sequence[n + 1];\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx++;\\n            \\n            while (idx < a.length) {\\n                if (a[idx] == null || a[idx].length < s.length) {\\n                    a[idx] = s;\\n                } else if (a[idx].length == s.length) {\\n                    a[idx] = new Sequence(s.length, s.count + a[idx].count);\\n                }\\n                idx += idx & -idx;\\n            }\\n        }\\n        \\n        Sequence query(int idx) {\\n            idx++;\\n            Sequence s = new Sequence(0, 1);\\n            \\n            while (idx > 0) {\\n                if (a[idx] != null) {\\n                    if (a[idx].length > s.length) {\\n                        s = a[idx];\\n                    } else if (a[idx].length == s.length) {\\n                        s = new Sequence(s.length, s.count + a[idx].count);\\n                    }\\n                }\\n                idx -= idx & -idx;\\n            }\\n            \\n            return s;\\n        }\\n    }\\n    \\n    private static final class Sequence {\\n        private final int length;\\n        private final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first the coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n\\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 0;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i]] = coordinate;\\n                i++;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates in a BIT\\n        BinaryIndexedTree bit = new BinaryIndexedTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = bit.query(coordinates[i] - 1);\\n            bit.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n    \\n        return bit.query(coordinate - 1).count;\\n    }\\n    \\n    private static final class BinaryIndexedTree {\\n        private final Sequence[] a;\\n        \\n        BinaryIndexedTree(int n) {\\n            this.a = new Sequence[n + 1];\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx++;\\n            \\n            while (idx < a.length) {\\n                if (a[idx] == null || a[idx].length < s.length) {\\n                    a[idx] = s;\\n                } else if (a[idx].length == s.length) {\\n                    a[idx] = new Sequence(s.length, s.count + a[idx].count);\\n                }\\n                idx += idx & -idx;\\n            }\\n        }\\n        \\n        Sequence query(int idx) {\\n            idx++;\\n            Sequence s = new Sequence(0, 1);\\n            \\n            while (idx > 0) {\\n                if (a[idx] != null) {\\n                    if (a[idx].length > s.length) {\\n                        s = a[idx];\\n                    } else if (a[idx].length == s.length) {\\n                        s = new Sequence(s.length, s.count + a[idx].count);\\n                    }\\n                }\\n                idx -= idx & -idx;\\n            }\\n            \\n            return s;\\n        }\\n    }\\n    \\n    private static final class Sequence {\\n        private final int length;\\n        private final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445893,
                "title": "c-dp-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<pair<int,int>>dp(n,{1,1});\\n        \\n        dp[0].first=1;\\n        dp[0].second=1;\\n        int l=1,r=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(dp[i].first<1+dp[j].first)\\n                    {\\n                        dp[i].first=1+dp[j].first;\\n                        dp[i].second=dp[j].second;\\n                    }\\n                    else if(dp[i].first==dp[j].first+1)\\n                    {\\n                        dp[i].second+=dp[j].second;\\n                    }\\n                }\\n            }\\n            if(dp[i].first>l)\\n            {\\n                l=dp[i].first;\\n                r=dp[i].second;\\n            }\\n            else if(dp[i].first==l)\\n            {\\n                r+=dp[i].second;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<pair<int,int>>dp(n,{1,1});\\n        \\n        dp[0].first=1;\\n        dp[0].second=1;\\n        int l=1,r=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(dp[i].first<1+dp[j].first)\\n                    {\\n                        dp[i].first=1+dp[j].first;\\n                        dp[i].second=dp[j].second;\\n                    }\\n                    else if(dp[i].first==dp[j].first+1)\\n                    {\\n                        dp[i].second+=dp[j].second;\\n                    }\\n                }\\n            }\\n            if(dp[i].first>l)\\n            {\\n                l=dp[i].first;\\n                r=dp[i].second;\\n            }\\n            else if(dp[i].first==l)\\n            {\\n                r+=dp[i].second;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307093,
                "title": "number-of-lis-o-nlogn-c-100-explained",
                "content": "Before you read this, please make sure you already know the LIS O(NlogN) solution!\\n\\nRefer : https://leetcode.com/problems/longest-increasing-subsequence/discuss/1303416/longest-increasing-subsequence-in-onlogn\\n\\nSo in the O(NlogN) solution, we created a DP array where the index at which we landed on using lower_bound function gave us the length of the Longest Increasing Subsequence ending current element.\\n\\nNow Here, we will modify this approach to solve for number of LIS by (read this carefully) : Storing the counts of LIS ending at current element.  \\n\\nSuppose the current element is 4 and lower_bound gives us 3, that mean LIS of length 3 can be formed by ending at 4. To get count, We know that we can place 4 after any of the LIS of length 2 that end with an element smaller than 4. \\n\\nWe can create a List of List of Pairs, vector<vector< pair<int,int> >> LISbylen(N+1); in which we store the ( count of LIS end at current element, and the current element ). So to get the count we can add up the counts of LIS of len-1 where the last element is smaller than current element.\\n\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> dp(n+1, INT_MAX);\\n        vector<vector< pair<int,int> >> LISbylen(n+1);\\n        \\n        dp[0] = INT_MIN;\\n        LISbylen[0] = { {1, INT_MIN} };\\n        \\n        int max_len = 1;\\n        for(auto &ele: nums){\\n            \\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele;\\n            \\n            int ele_count = 0;\\n            for(auto &[count, last]: LISbylen[len-1])\\n                if(ele>last) ele_count+=count;\\n            \\n            LISbylen[len].push_back({ele_count, ele});\\n            max_len = max(max_len, len);\\n            \\n        }\\n        \\n        int num_lis = 0;\\n        for(auto &[count, last]: LISbylen[max_len])\\n            num_lis += count;\\n        \\n        return num_lis;\\n        \\n    }",
                "solutionTags": [],
                "code": "Before you read this, please make sure you already know the LIS O(NlogN) solution!\\n\\nRefer : https://leetcode.com/problems/longest-increasing-subsequence/discuss/1303416/longest-increasing-subsequence-in-onlogn\\n\\nSo in the O(NlogN) solution, we created a DP array where the index at which we landed on using lower_bound function gave us the length of the Longest Increasing Subsequence ending current element.\\n\\nNow Here, we will modify this approach to solve for number of LIS by (read this carefully) : Storing the counts of LIS ending at current element.  \\n\\nSuppose the current element is 4 and lower_bound gives us 3, that mean LIS of length 3 can be formed by ending at 4. To get count, We know that we can place 4 after any of the LIS of length 2 that end with an element smaller than 4. \\n\\nWe can create a List of List of Pairs, vector<vector< pair<int,int> >> LISbylen(N+1); in which we store the ( count of LIS end at current element, and the current element ). So to get the count we can add up the counts of LIS of len-1 where the last element is smaller than current element.\\n\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> dp(n+1, INT_MAX);\\n        vector<vector< pair<int,int> >> LISbylen(n+1);\\n        \\n        dp[0] = INT_MIN;\\n        LISbylen[0] = { {1, INT_MIN} };\\n        \\n        int max_len = 1;\\n        for(auto &ele: nums){\\n            \\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele;\\n            \\n            int ele_count = 0;\\n            for(auto &[count, last]: LISbylen[len-1])\\n                if(ele>last) ele_count+=count;\\n            \\n            LISbylen[len].push_back({ele_count, ele});\\n            max_len = max(max_len, len);\\n            \\n        }\\n        \\n        int num_lis = 0;\\n        for(auto &[count, last]: LISbylen[max_len])\\n            num_lis += count;\\n        \\n        return num_lis;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1284688,
                "title": "swift-o-nlogn-100-dp-bs-prefix-sum",
                "content": "Based on this [wonderful post](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107295/9ms-C%2B%2B-Explanation%3A-DP-%2B-Binary-search-%2B-prefix-sums-O(NlogN)-time-O(N)-space).\\n\\nIf you\\'re trying to solve it in O(nlogn), this problem would be one of the craziest, in a good way, problem in Leetcode.\\n\\n**DP(Patience Sorting) + BS + Prefix Sum**\\n\\n```\\nclass Solution {\\n    func findNumberOfLIS(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 0 else { return 0 }\\n        var list = [[(Int, Int)]]()\\n\\t\\t// by inserting the first number, list.first & list.last becomes much easier\\n        list.append([(nums[0], 1)])\\n        for n in nums[1..<nums.count] {\\n\\t\\t\\t// if the n and the last pile of value is the same, we merge them so we can BS easier\\n            var index = bs(list, n)\\n\\t\\t\\t// no need to caculate because it is the first element of sequence.\\n            if index == 0 {\\n                if list.first!.last!.0 == n {\\n                    list[0][list[index].count - 1].1 += 1\\n                } else {\\n                    list[0].append((n, list.first!.last!.1 + 1))\\n                }\\n                continue\\n            }\\n            var before = list[index - 1]\\n            var index2 = bs2(before, n)\\n\\t\\t\\t// prefix sum. sum(a~b) = sum(b~0) - sum(a-1~0)\\n            var sum = before.last!.1 - (index2 == -1 ? 0 : before[index2].1)\\n            if index < list.count  {\\n                if list[index].last!.0 == n {\\n                    list[index][list[index].count - 1].1 += sum\\n                } else {\\n                    list[index].append((n, list[index].last!.1 + sum))\\n                }\\n            } else {\\n                list.append([(n, sum)])\\n            }\\n        }\\n\\t\\t// last is already the sum of possible options so no need to sum up\\n        return list.last!.last!.1\\n    }\\n\\t\\n    // BS for prefix sum. decreasing order\\n    func bs2(_ nums:[(Int, Int)], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].0 == target {\\n\\t\\t\\t    // if the target is in this array, \\n                // we have to minus the value because the sequence is strictly increasing\\n                return mid\\n            } else if nums[mid].0 < target {\\n                M = mid\\n            } else {\\n                m = mid + 1\\n            }\\n        }\\n\\t\\t// if we dont have the target, we need index - 1. think and let it sink in\\n        return m - 1\\n    }\\n\\t\\n    // normal BS for patience sorting. increasing order\\n    func bs(_ nums:[[(Int, Int)]], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].last!.0 == target {\\n                return mid\\n            } else if nums[mid].last!.0 < target {\\n                m = mid + 1\\n            } else {\\n                M = mid\\n            }\\n        }\\n        return m\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findNumberOfLIS(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 0 else { return 0 }\\n        var list = [[(Int, Int)]]()\\n\\t\\t// by inserting the first number, list.first & list.last becomes much easier\\n        list.append([(nums[0], 1)])\\n        for n in nums[1..<nums.count] {\\n\\t\\t\\t// if the n and the last pile of value is the same, we merge them so we can BS easier\\n            var index = bs(list, n)\\n\\t\\t\\t// no need to caculate because it is the first element of sequence.\\n            if index == 0 {\\n                if list.first!.last!.0 == n {\\n                    list[0][list[index].count - 1].1 += 1\\n                } else {\\n                    list[0].append((n, list.first!.last!.1 + 1))\\n                }\\n                continue\\n            }\\n            var before = list[index - 1]\\n            var index2 = bs2(before, n)\\n\\t\\t\\t// prefix sum. sum(a~b) = sum(b~0) - sum(a-1~0)\\n            var sum = before.last!.1 - (index2 == -1 ? 0 : before[index2].1)\\n            if index < list.count  {\\n                if list[index].last!.0 == n {\\n                    list[index][list[index].count - 1].1 += sum\\n                } else {\\n                    list[index].append((n, list[index].last!.1 + sum))\\n                }\\n            } else {\\n                list.append([(n, sum)])\\n            }\\n        }\\n\\t\\t// last is already the sum of possible options so no need to sum up\\n        return list.last!.last!.1\\n    }\\n\\t\\n    // BS for prefix sum. decreasing order\\n    func bs2(_ nums:[(Int, Int)], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].0 == target {\\n\\t\\t\\t    // if the target is in this array, \\n                // we have to minus the value because the sequence is strictly increasing\\n                return mid\\n            } else if nums[mid].0 < target {\\n                M = mid\\n            } else {\\n                m = mid + 1\\n            }\\n        }\\n\\t\\t// if we dont have the target, we need index - 1. think and let it sink in\\n        return m - 1\\n    }\\n\\t\\n    // normal BS for patience sorting. increasing order\\n    func bs(_ nums:[[(Int, Int)]], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].last!.0 == target {\\n                return mid\\n            } else if nums[mid].last!.0 < target {\\n                m = mid + 1\\n            } else {\\n                M = mid\\n            }\\n        }\\n        return m\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932836,
                "title": "c-dp-readable-and-easy-to-understand-i-mean-it",
                "content": "The core concept is the same as everyone, the only difference is that this code is more READABLE which makes it easy to understand.\\n\\n```\\n        public static int FindNumberOfLIS(int[] nums)\\n        {\\n\\n            int[] lisLength = new int[nums.Length];\\n            int[] countOfLIS = new int[nums.Length];\\n            int longestSequenceLength = 0;\\n            int numberOfLIS = 0;\\n\\n            for(var right = 0; right < nums.Length; right++)\\n            {\\n                lisLength[right] = 1;\\n                countOfLIS[right] = 1;\\n\\n                for(var left = right - 1; left >= 0; left--)\\n                {\\n                    if(nums[left] < nums[right])\\n                    {\\n                        if (lisLength[right] < lisLength[left] + 1)\\n                        {\\n                            lisLength[right] = lisLength[left] + 1;\\n                            countOfLIS[right] = countOfLIS[left];\\n                        }\\n                        else if(lisLength[right] == lisLength[left] + 1)\\n                        {\\n                            countOfLIS[right] += countOfLIS[left];\\n                        }\\n                    }\\n                }\\n\\n                if (lisLength[right] > longestSequenceLength)\\n                {\\n                    longestSequenceLength = lisLength[right];\\n                    numberOfLIS = countOfLIS[right];\\n                }\\n                else if (lisLength[right] == longestSequenceLength)\\n                    numberOfLIS += countOfLIS[right];                                                 \\n            }\\n\\n            return numberOfLIS;\\n        }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n        public static int FindNumberOfLIS(int[] nums)\\n        {\\n\\n            int[] lisLength = new int[nums.Length];\\n            int[] countOfLIS = new int[nums.Length];\\n            int longestSequenceLength = 0;\\n            int numberOfLIS = 0;\\n\\n            for(var right = 0; right < nums.Length; right++)\\n            {\\n                lisLength[right] = 1;\\n                countOfLIS[right] = 1;\\n\\n                for(var left = right - 1; left >= 0; left--)\\n                {\\n                    if(nums[left] < nums[right])\\n                    {\\n                        if (lisLength[right] < lisLength[left] + 1)\\n                        {\\n                            lisLength[right] = lisLength[left] + 1;\\n                            countOfLIS[right] = countOfLIS[left];\\n                        }\\n                        else if(lisLength[right] == lisLength[left] + 1)\\n                        {\\n                            countOfLIS[right] += countOfLIS[left];\\n                        }\\n                    }\\n                }\\n\\n                if (lisLength[right] > longestSequenceLength)\\n                {\\n                    longestSequenceLength = lisLength[right];\\n                    numberOfLIS = countOfLIS[right];\\n                }\\n                else if (lisLength[right] == longestSequenceLength)\\n                    numberOfLIS += countOfLIS[right];                                                 \\n            }\\n\\n            return numberOfLIS;\\n        }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919430,
                "title": "top-down-dp-based-on-brute-force",
                "content": "The idea is simple just try every single possibility in every index and re-use the value.\\n\\n```\\npublic static int findNumberOfLIS(int[] nums) {\\n        // first index for the subsequence max length and second is for total combination\\n        int [] result = new int[]{0,0};\\n        int [][] memo = new int[nums.length][2];\\n        // Try at index\\n        for (int x = 0; x < nums.length; x++){\\n            int [] temp = findNumberOfLISHelper(nums, memo, x);\\n            if (temp[0] > result[0]){\\n                result = temp;\\n                continue;\\n            }\\n            if (temp[0] == result[0])\\n                result[1] += temp[1];\\n        }\\n\\n        return result[1];\\n    }\\n\\n    public static int[] findNumberOfLISHelper(int [] nums, int [][]memo, int index){\\n        if (memo[index][0] != 0)\\n            return memo[index];\\n        // set the base value\\n        int [] currentLIS = new int[]{0,1};\\n        for (int x = index+1; x < nums.length; x++){\\n            if (nums[index] < nums[x]){\\n                int[] temp = findNumberOfLISHelper(nums, memo, x);\\n                // if the dfs result is bigger need to change the value\\n                // use new array to avoid reference in java\\n                if (temp[0] > currentLIS[0]){\\n                    currentLIS = new int[]{temp[0], temp[1]};\\n                    continue;\\n                }\\n                // add it if the length is the same\\n                if (temp[0] ==currentLIS[0])\\n                    currentLIS[1] += temp[1];\\n            }\\n        }\\n        // increase the length\\n        currentLIS[0] += 1;\\n        return memo[index] = currentLIS;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int findNumberOfLIS(int[] nums) {\\n        // first index for the subsequence max length and second is for total combination\\n        int [] result = new int[]{0,0};\\n        int [][] memo = new int[nums.length][2];\\n        // Try at index\\n        for (int x = 0; x < nums.length; x++){\\n            int [] temp = findNumberOfLISHelper(nums, memo, x);\\n            if (temp[0] > result[0]){\\n                result = temp;\\n                continue;\\n            }\\n            if (temp[0] == result[0])\\n                result[1] += temp[1];\\n        }\\n\\n        return result[1];\\n    }\\n\\n    public static int[] findNumberOfLISHelper(int [] nums, int [][]memo, int index){\\n        if (memo[index][0] != 0)\\n            return memo[index];\\n        // set the base value\\n        int [] currentLIS = new int[]{0,1};\\n        for (int x = index+1; x < nums.length; x++){\\n            if (nums[index] < nums[x]){\\n                int[] temp = findNumberOfLISHelper(nums, memo, x);\\n                // if the dfs result is bigger need to change the value\\n                // use new array to avoid reference in java\\n                if (temp[0] > currentLIS[0]){\\n                    currentLIS = new int[]{temp[0], temp[1]};\\n                    continue;\\n                }\\n                // add it if the length is the same\\n                if (temp[0] ==currentLIS[0])\\n                    currentLIS[1] += temp[1];\\n            }\\n        }\\n        // increase the length\\n        currentLIS[0] += 1;\\n        return memo[index] = currentLIS;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903156,
                "title": "python-easy-to-understand-top-down-o-n-2",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        max_len, count = 0, 0\\n        for i in range(len(nums)):\\n            curr_max, curr_count = self.helper(i, nums)\\n            if curr_max == max_len:\\n                count += curr_count\\n            elif curr_max > max_len:\\n                max_len = curr_max\\n                count = curr_count\\n        return count\\n    \\n    def helper(self, i, nums):\\n        if i in self.memo:\\n            return self.memo[i]\\n        \\n        max_length = 1; count = 0\\n        \\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i]:\\n                \\n                max_length_j, count_j = self.helper(j, nums)\\n                \\n                if max_length == 1 + max_length_j:\\n                    count += count_j\\n                \\n                elif 1 + max_length_j > max_length:\\n                    count = count_j\\n                    max_length = 1 + max_length_j\\n        \\n        count = max(1, count)\\n        self.memo[i] = (max_length, count)\\n        return self.memo[i]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        max_len, count = 0, 0\\n        for i in range(len(nums)):\\n            curr_max, curr_count = self.helper(i, nums)\\n            if curr_max == max_len:\\n                count += curr_count\\n            elif curr_max > max_len:\\n                max_len = curr_max\\n                count = curr_count\\n        return count\\n    \\n    def helper(self, i, nums):\\n        if i in self.memo:\\n            return self.memo[i]\\n        \\n        max_length = 1; count = 0\\n        \\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i]:\\n                \\n                max_length_j, count_j = self.helper(j, nums)\\n                \\n                if max_length == 1 + max_length_j:\\n                    count += count_j\\n                \\n                elif 1 + max_length_j > max_length:\\n                    count = count_j\\n                    max_length = 1 + max_length_j\\n        \\n        count = max(1, count)\\n        self.memo[i] = (max_length, count)\\n        return self.memo[i]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 901593,
                "title": "99-31-o-n-log-n-solution-in-python",
                "content": "Please, first take a look at my solution for [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/901573/O(n-log-n)-Solution-in-Python) as we build upon it here. In that question, we kept a `dp` array to remember the length of the longest possible subsequeces.\\n\\nHere, we use the same `dp` array and employ the same binary search algorithm to remember the length of the longest subsequences. Furthermore, here we introudce a new data structure `num_sequences_of_length` that remembers:\\n\\n- the number of sequences *that matter* at a length\\n- and the largest i.e. tha last number of those sequences\\n\\n\\n```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        dp = []\\n        num_sequences_of_length = collections.defaultdict(list)\\n        for i in range(len(nums)):\\n            pos = bisect_left(dp, nums[i])\\n            if pos == len(dp):\\n                dp.append(nums[i])\\n            else:\\n                dp[pos] = nums[i]\\n            total = 0\\n            for count, last in num_sequences_of_length[pos]:\\n                if last < nums[i]:\\n                    total += count\\n            num_sequences_of_length[pos+1].append((max(1, total), nums[i]))\\n        return sum([count for count,_ in num_sequences_of_length[len(dp)-1]])\\n```\\n\\nFor example for `[1,3,5,4,7]` input `num_sequences_of_length` will be as\\n```\\n1: [(1, 1)]\\n2: [(1, 3)]\\n3: [(1, 5), (1, 4)]\\n4: [(2, 7)]\\n```\\nbecause there\\'s\\n- 1 possible subsequence of length 1 and it ends with 1 i.e. [1] *that matter*\\n- 1 possible subsequence of length 2 and it ends with 1 i.e. [1, 3] *that matter*\\n- 2 possible subsequence of length 3 and those end with 4 i.e. [1, 3, 4] and 5 i.e. [1, 3, 5] *that matter*\\n- 2 possible subsequence of length 4 and those end with 7 i.e. [1, 3, 4, 7] and [1, 3, 5, 7] *that matter*\\n\\nAs you may noticed in above example, the somewhat mystic criteria of \"matter\"ing is actually based on enabling longer subsequences later.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        dp = []\\n        num_sequences_of_length = collections.defaultdict(list)\\n        for i in range(len(nums)):\\n            pos = bisect_left(dp, nums[i])\\n            if pos == len(dp):\\n                dp.append(nums[i])\\n            else:\\n                dp[pos] = nums[i]\\n            total = 0\\n            for count, last in num_sequences_of_length[pos]:\\n                if last < nums[i]:\\n                    total += count\\n            num_sequences_of_length[pos+1].append((max(1, total), nums[i]))\\n        return sum([count for count,_ in num_sequences_of_length[len(dp)-1]])\\n```\n```\\n1: [(1, 1)]\\n2: [(1, 3)]\\n3: [(1, 5), (1, 4)]\\n4: [(2, 7)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815161,
                "title": "c-dp-o-n-2",
                "content": "```csharp\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        var dp = nums.Select(_ => new[] {1, 1}).ToArray(); //[0]: length, [1]: count\\n        var max = 1;\\n        for (int i = 1; i < nums.Length; i++) \\n            for (int j = 0, last = 0; j < i; j++) {\\n                if (nums[i] <= nums[j] || dp[j][0] + 1 < dp[i][0]) continue;\\n                if (last == dp[j][0]) dp[i][1] += dp[j][1];\\n                else dp[i] = new [] { dp[j][0] + 1, dp[j][1] };\\n                (max, last) = (Math.Max(max, dp[i][0]), dp[j][0]);\\n            }\\n        return dp.Sum(e => e[0] == max ? e[1] : 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        var dp = nums.Select(_ => new[] {1, 1}).ToArray(); //[0]: length, [1]: count\\n        var max = 1;\\n        for (int i = 1; i < nums.Length; i++) \\n            for (int j = 0, last = 0; j < i; j++) {\\n                if (nums[i] <= nums[j] || dp[j][0] + 1 < dp[i][0]) continue;\\n                if (last == dp[j][0]) dp[i][1] += dp[j][1];\\n                else dp[i] = new [] { dp[j][0] + 1, dp[j][1] };\\n                (max, last) = (Math.Max(max, dp[i][0]), dp[j][0]);\\n            }\\n        return dp.Sum(e => e[0] == max ? e[1] : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789878,
                "title": "c-dp-intuitive-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int maxlen = 1, ret = 0;\\n        vector<int> cnt(nums.size(), 1), dp(nums.size(), 1);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j]+1 > dp[i]) dp[i] = dp[j]+1, cnt[i] = cnt[j];\\n                    else if (dp[i] == dp[j]+1) cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, dp[i]);\\n        }\\n        for (int i=0;i < dp.size();++i) \\n            if (dp[i] == maxlen) ret += cnt[i];\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int maxlen = 1, ret = 0;\\n        vector<int> cnt(nums.size(), 1), dp(nums.size(), 1);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j]+1 > dp[i]) dp[i] = dp[j]+1, cnt[i] = cnt[j];\\n                    else if (dp[i] == dp[j]+1) cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, dp[i]);\\n        }\\n        for (int i=0;i < dp.size();++i) \\n            if (dp[i] == maxlen) ret += cnt[i];\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770271,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \\n        if not nums:\\n            return 0\\n        \\n        longest = [1] * len(nums)\\n        number = [1] * len(nums)\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if longest[j] + 1 > longest[i]:\\n                        longest[i] = longest[j] + 1\\n                        number[i] = number[j]\\n                    elif longest[j] + 1 == longest[i]:\\n                        number[i] += number[j]\\n        \\n        longestSub = max(longest)\\n        ans = 0\\n        for num in range(len(number)):\\n            if longest[num] == longestSub:\\n                ans+=number[num]\\n    \\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \\n        if not nums:\\n            return 0\\n        \\n        longest = [1] * len(nums)\\n        number = [1] * len(nums)\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if longest[j] + 1 > longest[i]:\\n                        longest[i] = longest[j] + 1\\n                        number[i] = number[j]\\n                    elif longest[j] + 1 == longest[i]:\\n                        number[i] += number[j]\\n        \\n        longestSub = max(longest)\\n        ans = 0\\n        for num in range(len(number)):\\n            if longest[num] == longestSub:\\n                ans+=number[num]\\n    \\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743049,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        vector<pair<int, int>> dp(nums.size(), {1,1});\\n        int res = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if( dp[j].first + 1 > dp[i].first) {\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                    else if (dp[j].first + 1 == dp[i].first) {\\n                        dp[i].second += dp[j].second;\\n                    }\\n                }\\n                res = max(res, dp[i].first);\\n            }\\n        }\\n        int count = 0;\\n        for(auto &pair : dp) {\\n            if(res == pair.first)\\n                count += pair.second;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        vector<pair<int, int>> dp(nums.size(), {1,1});\\n        int res = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if( dp[j].first + 1 > dp[i].first) {\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                    else if (dp[j].first + 1 == dp[i].first) {\\n                        dp[i].second += dp[j].second;\\n                    }\\n                }\\n                res = max(res, dp[i].first);\\n            }\\n        }\\n        int count = 0;\\n        for(auto &pair : dp) {\\n            if(res == pair.first)\\n                count += pair.second;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721640,
                "title": "python-o-nlogn-patience-sort-beats-97-84ms",
                "content": "```\\ndef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\t# decks is the typical list of list of int used in patience sort\\n\\t# paths is the number of paths of each element in decks\\n\\tdecks, paths = [], []\\n\\tfor n in nums:\\n\\t    # binary search to find deck to append to\\n\\t\\tl, r = 0, len(decks)-1\\n\\t\\twhile l <= r:\\n\\t\\t\\tm = (l+r)//2\\n\\t\\t\\tif decks[m][-1] < n:\\n\\t\\t\\t\\tl = m+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m-1\\n\\t\\tdeck_idx = l\\n\\t\\tif deck_idx > 0:\\n\\t\\t    # binary search to find position within deck[deck_idx] below which all values are less than n\\n\\t\\t\\tl, r = 0, len(decks[deck_idx-1])-1\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tm = (l+r)//2\\n\\t\\t\\t\\tif decks[deck_idx-1][m] >= n:\\n\\t\\t\\t\\t\\tl = m+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = m-1\\n\\t\\t\\tn_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n\\t\\telse:\\n\\t\\t\\tn_paths = 1\\n\\t\\tif deck_idx == len(decks):\\n\\t\\t\\tdecks.append([n])\\n\\t\\t\\tpaths.append([0,n_paths])\\n\\t\\telse:\\n\\t\\t\\tdecks[deck_idx].append(n)\\n\\t\\t\\tpaths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n\\treturn paths[-1][-1]\\n```\\n\\n[1] Patience Sort explained on youtube: https://www.youtube.com/watch?v=22s1xxRvy28",
                "solutionTags": [],
                "code": "```\\ndef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\t# decks is the typical list of list of int used in patience sort\\n\\t# paths is the number of paths of each element in decks\\n\\tdecks, paths = [], []\\n\\tfor n in nums:\\n\\t    # binary search to find deck to append to\\n\\t\\tl, r = 0, len(decks)-1\\n\\t\\twhile l <= r:\\n\\t\\t\\tm = (l+r)//2\\n\\t\\t\\tif decks[m][-1] < n:\\n\\t\\t\\t\\tl = m+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m-1\\n\\t\\tdeck_idx = l\\n\\t\\tif deck_idx > 0:\\n\\t\\t    # binary search to find position within deck[deck_idx] below which all values are less than n\\n\\t\\t\\tl, r = 0, len(decks[deck_idx-1])-1\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tm = (l+r)//2\\n\\t\\t\\t\\tif decks[deck_idx-1][m] >= n:\\n\\t\\t\\t\\t\\tl = m+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = m-1\\n\\t\\t\\tn_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n\\t\\telse:\\n\\t\\t\\tn_paths = 1\\n\\t\\tif deck_idx == len(decks):\\n\\t\\t\\tdecks.append([n])\\n\\t\\t\\tpaths.append([0,n_paths])\\n\\t\\telse:\\n\\t\\t\\tdecks[deck_idx].append(n)\\n\\t\\t\\tpaths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n\\treturn paths[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 625925,
                "title": "self-explanatory-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        int ind=0;\\n        int dp[n]; dp[0]=1;\\n        int mx=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            mx=max(mx,dp[i]);\\n        }\\n        if(mx==1) return n;\\n        vector<int> ways(n,0); ways[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(dp[i]==1) ways[i]=1;\\n            else\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(dp[j]==dp[i]-1&&nums[j]<nums[i])\\n                        ways[i]+=ways[j];\\n                }\\n            }\\n        }\\n        \\n        int tot_ways=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==mx)\\n                tot_ways+=ways[i];\\n        }\\n        \\n        return tot_ways;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        int ind=0;\\n        int dp[n]; dp[0]=1;\\n        int mx=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            mx=max(mx,dp[i]);\\n        }\\n        if(mx==1) return n;\\n        vector<int> ways(n,0); ways[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(dp[i]==1) ways[i]=1;\\n            else\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(dp[j]==dp[i]-1&&nums[j]<nums[i])\\n                        ways[i]+=ways[j];\\n                }\\n            }\\n        }\\n        \\n        int tot_ways=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==mx)\\n                tot_ways+=ways[i];\\n        }\\n        \\n        return tot_ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603110,
                "title": "lengthy-descriptive-javascript-solution",
                "content": "```\\n\\nvar findNumberOfLIS = function(nums) {\\n    // saftey check that nums has length and is not null\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    \\n    // initialise array to record the length of the longest increasing subsequence at each i\\n    const LISRecord = new Array(nums.length).fill(1);\\n\\n    // initialise array to record the number of LIS of length LISRecord[i]\\n    const numberOfLISRecord = new Array(nums.length).fill(1);\\n\\n    // iterate i from 0 to nums.length\\n    for(let i=0; i<nums.length; i++) {\\n        // for each i in nums, iterate j from 0 up to i-1\\n        for(let j=0; j<i; j++) {\\n\\n            // if nums[i] is greater than nums[j]\\n            // i.e. putting nums[i] after nums[j] would continue a increasing subsequence\\n            if (nums[i] > nums[j]) {\\n\\n                // if the longest possible subsequence up to nums[i] is less than that up to nums[j]+1\\n                // which it will be in the first iteration at least because all of LISRecord is initialised\\n                // to 1\\n                if (LISRecord[i] < LISRecord[j] + 1) {\\n                    // since nums[i] is less than nums[j] the possible longest increasing subsequence to\\n                    // i is atleast one longer\\n                    LISRecord[i] = LISRecord[j] + 1;\\n                    // and how ever many ways there were to make LISRecord[j] \\n                    // there are an equal many ways to make LISRecrod[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[j];\\n                }\\n                // if i is a LIS one larger than j - meaning the longest possible subsequence up\\n                // to nums[i] is one larger than nums[j+1]\\n                else if(LISRecord[i] === LISRecord[j] + 1) {\\n                    // then the amount of ways of of making LISRecord[i] is the number of ways of\\n                    // making LISRecord[i] that we have already calculated plus\\n                    // the number of ways of making LISRecord[j] since\\n                    // nums[j] is less than nums[i] and thus all the sequences that end\\n                    // at nums[j] can be extended by one to end at nums[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[i] + numberOfLISRecord[j];\\n                }\\n            }\\n        }\\n    }\\n\\n    // then using the information we have tabulated it is easy to to find the answer\\n    // the number of ways of creating the longest increasing subsequence is\\n    // the sum of the values in numberOfLISRecord at each i, where i is the largest\\n    // number in LISRecord\\n    // i.e. LISRecord - shows us the LIS we can make - and numberOFLISRecord tells us\\n    // how many ways to make that\\n    // so for each occurrence of the LIS in LISrecord, we just get the corresponding number\\n    // from numberOfLISRecord (recorded at the same index)\\n    let longestLIS = Math.max(...LISRecord, 0);\\n    let occurrencesOfLongestLIS = 0;\\n    for(let index=0; index<numberOfLISRecord.length; index++) {\\n        if (LISRecord[index] === longestLIS) {\\n            occurrencesOfLongestLIS = occurrencesOfLongestLIS + numberOfLISRecord[index];\\n        }\\n    }\\n\\n    // console.log(nums);\\n    // console.log(LISRecord);\\n    // console.log(numberOfLISRecord);\\n    return occurrencesOfLongestLIS;\\n};\\n\\nconsole.log(\\n    findNumberOfLIS(\\n        [2,2,2,2,2]\\n    )\\n);\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar findNumberOfLIS = function(nums) {\\n    // saftey check that nums has length and is not null\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    \\n    // initialise array to record the length of the longest increasing subsequence at each i\\n    const LISRecord = new Array(nums.length).fill(1);\\n\\n    // initialise array to record the number of LIS of length LISRecord[i]\\n    const numberOfLISRecord = new Array(nums.length).fill(1);\\n\\n    // iterate i from 0 to nums.length\\n    for(let i=0; i<nums.length; i++) {\\n        // for each i in nums, iterate j from 0 up to i-1\\n        for(let j=0; j<i; j++) {\\n\\n            // if nums[i] is greater than nums[j]\\n            // i.e. putting nums[i] after nums[j] would continue a increasing subsequence\\n            if (nums[i] > nums[j]) {\\n\\n                // if the longest possible subsequence up to nums[i] is less than that up to nums[j]+1\\n                // which it will be in the first iteration at least because all of LISRecord is initialised\\n                // to 1\\n                if (LISRecord[i] < LISRecord[j] + 1) {\\n                    // since nums[i] is less than nums[j] the possible longest increasing subsequence to\\n                    // i is atleast one longer\\n                    LISRecord[i] = LISRecord[j] + 1;\\n                    // and how ever many ways there were to make LISRecord[j] \\n                    // there are an equal many ways to make LISRecrod[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[j];\\n                }\\n                // if i is a LIS one larger than j - meaning the longest possible subsequence up\\n                // to nums[i] is one larger than nums[j+1]\\n                else if(LISRecord[i] === LISRecord[j] + 1) {\\n                    // then the amount of ways of of making LISRecord[i] is the number of ways of\\n                    // making LISRecord[i] that we have already calculated plus\\n                    // the number of ways of making LISRecord[j] since\\n                    // nums[j] is less than nums[i] and thus all the sequences that end\\n                    // at nums[j] can be extended by one to end at nums[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[i] + numberOfLISRecord[j];\\n                }\\n            }\\n        }\\n    }\\n\\n    // then using the information we have tabulated it is easy to to find the answer\\n    // the number of ways of creating the longest increasing subsequence is\\n    // the sum of the values in numberOfLISRecord at each i, where i is the largest\\n    // number in LISRecord\\n    // i.e. LISRecord - shows us the LIS we can make - and numberOFLISRecord tells us\\n    // how many ways to make that\\n    // so for each occurrence of the LIS in LISrecord, we just get the corresponding number\\n    // from numberOfLISRecord (recorded at the same index)\\n    let longestLIS = Math.max(...LISRecord, 0);\\n    let occurrencesOfLongestLIS = 0;\\n    for(let index=0; index<numberOfLISRecord.length; index++) {\\n        if (LISRecord[index] === longestLIS) {\\n            occurrencesOfLongestLIS = occurrencesOfLongestLIS + numberOfLISRecord[index];\\n        }\\n    }\\n\\n    // console.log(nums);\\n    // console.log(LISRecord);\\n    // console.log(numberOfLISRecord);\\n    return occurrencesOfLongestLIS;\\n};\\n\\nconsole.log(\\n    findNumberOfLIS(\\n        [2,2,2,2,2]\\n    )\\n);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197067,
                "title": "my-o-n-2-java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length], counts = new int[nums.length];\\n        int max = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int temp = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    temp = Math.max(temp, dp[j] + 1); // get the temp max length until this position\\n                }\\n            }\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i] && temp == dp[j] + 1) {\\n                    counts[i] += counts[j]; // get the ways to get this temp max length\\n                }\\n            }\\n            dp[i] = temp;\\n            counts[i] = Math.max(counts[i], 1);\\n            max = Math.max(max, temp); // get the global max\\n        }\\n        int result = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            if (dp[i] == max) {\\n                result += counts[i]; // if we get global max, add the ways to get that length on our result\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length], counts = new int[nums.length];\\n        int max = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int temp = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    temp = Math.max(temp, dp[j] + 1); // get the temp max length until this position\\n                }\\n            }\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i] && temp == dp[j] + 1) {\\n                    counts[i] += counts[j]; // get the ways to get this temp max length\\n                }\\n            }\\n            dp[i] = temp;\\n            counts[i] = Math.max(counts[i], 1);\\n            max = Math.max(max, temp); // get the global max\\n        }\\n        int result = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            if (dp[i] == max) {\\n                result += counts[i]; // if we get global max, add the ways to get that length on our result\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196685,
                "title": "python-100",
                "content": "```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        m=min(nums)-1\\n        a,b=[{m:1}],[m]\\n        for x in nums:\\n            i,t=bisect_left(b,x)-1,0\\n            if i==len(a)-1:\\n                a.append({})\\n                b.append(x)\\n            for y in list(a[i].keys()):\\n                if y<x: t+=a[i][y]\\n                else: del a[i][y]\\n            a[i+1][x]=a[i+1].get(x,0)+t\\n            b[i+1]=min(b[i+1],x)\\n        return sum(a[-1].values())\\n```\\n\\nBased on O(n log n) solution of 300. Longest Increasing Subsequence (https://leetcode.com/problems/longest-increasing-subsequence/description/). \\n```\\nfrom bisect import bisect_left\\n    def lengthOfLIS(self, nums):\\n        a=[]\\n        for x in nums:\\n            i=bisect_left(a,x)\\n            if i==len(a): a.append(x)\\n            else: a[i]=x\\n        return len(a)\\n```\\n\\nHere a[i] is a dict, where i is the length of increasing subsequence, the same as question 300. Keys of a[i] are different ending integers, and the corresponding values are the number of increasing subsequence ended with that interger. \\n\\nA key optimization is\\n```\\nelse: del a[i][y]\\n```\\nwhere redundant keys are deleted, so that they would no longer be further looped.\\n\\nFor example, nums=[1,8,5,7,6]\\n```\\nprint(x,i,a,b)\\n```\\nadded at the end of the loop. It would output\\n\\n1 0 [{0: 1}, {1: 1}] [0, 1]\\n8 1 [{0: 1}, {1: 1}, {8: 1}] [0, 1, 8]\\n5 1 [{0: 1}, {1: 1}, {8: 1, 5: 1}] [0, 1, 5]\\n7 2 [{0: 1}, {1: 1}, {5: 1}, {7: 1}] [0, 1, 5, 7]\\n6 2 [{0: 1}, {1: 1}, {5: 1}, {6: 1, 7: 1}] [0, 1, 5, 6]\\n\\nNote that when x==7, 8:1 in a[2] was deleted, which would no longer be unnecessarily checked when x==6.",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        m=min(nums)-1\\n        a,b=[{m:1}],[m]\\n        for x in nums:\\n            i,t=bisect_left(b,x)-1,0\\n            if i==len(a)-1:\\n                a.append({})\\n                b.append(x)\\n            for y in list(a[i].keys()):\\n                if y<x: t+=a[i][y]\\n                else: del a[i][y]\\n            a[i+1][x]=a[i+1].get(x,0)+t\\n            b[i+1]=min(b[i+1],x)\\n        return sum(a[-1].values())\\n```\n```\\nfrom bisect import bisect_left\\n    def lengthOfLIS(self, nums):\\n        a=[]\\n        for x in nums:\\n            i=bisect_left(a,x)\\n            if i==len(a): a.append(x)\\n            else: a[i]=x\\n        return len(a)\\n```\n```\\nelse: del a[i][y]\\n```\n```\\nprint(x,i,a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147870,
                "title": "c-easy-to-understand-solution-with-explanation-accepted",
                "content": "**Basic Idea:**\\n* Great [Video](https://www.youtube.com/watch?v=Ns4LCeeOFS4).\\n* The idea is to use two arrays lengthOfLisAtIndex[n] and numberOfLisAtIndex[n] to record the maximum length of Increasing Subsequence and the coresponding number of these sequence which ends with nums[i], respectively. \\n* That is:\\n\\t* lengthOfLisAtIndex[i]: the length of the Longest Increasing Subsequence which ends with nums[i].\\n\\t* numberOfLisAtIndex[i]: the number of the Longest Increasing Subsequence which ends with nums[i].\\n* Then, the result is the sum of each numberOfLisAtIndex[i] while its corresponding lengthOfLisAtIndex[i] is the maximum length.\\n```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        if (null == nums || nums.Length == 0) return 0;\\n        int[] lengthOfLisAtIndex = new int[nums.Length];   //Length of the Longest Increasing Subsequence which ends with nums[i].\\n        int[] numberOfLisAtIndex = new int[nums.Length];   //Number of the Longest Increasing Subsequence which ends with nums[i].\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            lengthOfLisAtIndex[i] = 1;\\n            numberOfLisAtIndex[i] = 1;\\n        }\\n\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (nums[j] < nums[i])\\n                {\\n                    if (lengthOfLisAtIndex[j] + 1 > lengthOfLisAtIndex[i])\\n                    {\\n                        lengthOfLisAtIndex[i] = lengthOfLisAtIndex[j] + 1;\\n                        numberOfLisAtIndex[i] = numberOfLisAtIndex[j];\\n                    }\\n                    else if (lengthOfLisAtIndex[j] + 1 == lengthOfLisAtIndex[i])\\n                    {\\n                        numberOfLisAtIndex[i] += numberOfLisAtIndex[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxlen = lengthOfLisAtIndex.Max();\\n        int ans = 0;\\n        for (int i = 0; i < lengthOfLisAtIndex.Length; i++)\\n            if (lengthOfLisAtIndex[i] == maxlen)\\n                ans += numberOfLisAtIndex[i];\\n\\n        return ans; \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        if (null == nums || nums.Length == 0) return 0;\\n        int[] lengthOfLisAtIndex = new int[nums.Length];   //Length of the Longest Increasing Subsequence which ends with nums[i].\\n        int[] numberOfLisAtIndex = new int[nums.Length];   //Number of the Longest Increasing Subsequence which ends with nums[i].\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            lengthOfLisAtIndex[i] = 1;\\n            numberOfLisAtIndex[i] = 1;\\n        }\\n\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (nums[j] < nums[i])\\n                {\\n                    if (lengthOfLisAtIndex[j] + 1 > lengthOfLisAtIndex[i])\\n                    {\\n                        lengthOfLisAtIndex[i] = lengthOfLisAtIndex[j] + 1;\\n                        numberOfLisAtIndex[i] = numberOfLisAtIndex[j];\\n                    }\\n                    else if (lengthOfLisAtIndex[j] + 1 == lengthOfLisAtIndex[i])\\n                    {\\n                        numberOfLisAtIndex[i] += numberOfLisAtIndex[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxlen = lengthOfLisAtIndex.Max();\\n        int ans = 0;\\n        for (int i = 0; i < lengthOfLisAtIndex.Length; i++)\\n            if (lengthOfLisAtIndex[i] == maxlen)\\n                ans += numberOfLisAtIndex[i];\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112522,
                "title": "java-cleanest-dp",
                "content": "```\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)\\n            return 0;\\n        \\n        int[] len = new int[n + 1];\\n        int[] cnt = new int[n + 1];\\n        \\n        for(int i = 0; i <= n; i++) {\\n            cnt[i] = 1;\\n            len[i] = 1;\\n            \\n            for(int j = 0; j < i; j++) {\\n                if(len[j] + 1 < len[i])\\n                    continue;\\n                \\n                if(i != n && nums[i] <= nums[j])\\n                    continue;\\n                \\n                if(len[j] + 1 > len[i])\\n                    cnt[i] = 0;\\n                \\n                len[i] = len[j] + 1;\\n                cnt[i] += cnt[j];\\n            }\\n        }\\n        \\n        return cnt[n];\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)\\n            return 0;\\n        \\n        int[] len = new int[n + 1];\\n        int[] cnt = new int[n + 1];\\n        \\n        for(int i = 0; i <= n; i++) {\\n            cnt[i] = 1;\\n            len[i] = 1;\\n            \\n            for(int j = 0; j < i; j++) {\\n                if(len[j] + 1 < len[i])\\n                    continue;\\n                \\n                if(i != n && nums[i] <= nums[j])\\n                    continue;\\n                \\n                if(len[j] + 1 > len[i])\\n                    cnt[i] = 0;\\n                \\n                len[i] = len[j] + 1;\\n                cnt[i] += cnt[j];\\n            }\\n        }\\n        \\n        return cnt[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107331,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Number of Longest Increasing Subsequence** https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/\\n\\n**DP Solution**\\n* Use the DP solution for LIS. Maintain an array called LIS and cnt. LIS[i] is the length of longest subsequence ending at index i. cnt[i] is the number of longest subsequences ending at index i.\\n* When we find a new LIS for index i, update cnt[i] with cnt[j]. Otherwise if the LIS[i] is the same as LIS[j]+1, simply add cnt[j] to cnt[i].\\n* Return the sum of frequencies of the maximum LIS.\\n* Time complexity is O(N^2) and Space complexity is O(N).\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if nums == []:\\n            return 0\\n        LIS, cnt = [1]*len(nums), [1]*len(nums)\\n        for i in range(1, len(nums)):\\n            for j in range(0,i):\\n                if nums[i] > nums[j]:\\n                    if LIS[i] == LIS[j]+1:\\n                        cnt[i] += cnt[j]\\n                    elif LIS[i] < LIS[j]+1:\\n                        cnt[i] = cnt[j]\\n                        LIS[i] = LIS[j]+1\\n        return sum((y for x,y in zip(LIS, cnt) if x==max(LIS)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if nums == []:\\n            return 0\\n        LIS, cnt = [1]*len(nums), [1]*len(nums)\\n        for i in range(1, len(nums)):\\n            for j in range(0,i):\\n                if nums[i] > nums[j]:\\n                    if LIS[i] == LIS[j]+1:\\n                        cnt[i] += cnt[j]\\n                    elif LIS[i] < LIS[j]+1:\\n                        cnt[i] = cnt[j]\\n                        LIS[i] = LIS[j]+1\\n        return sum((y for x,y in zip(LIS, cnt) if x==max(LIS)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107299,
                "title": "java-solution-dp",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        \\n        int[] dp = new int[n];\\n        int[] next = new int[n];\\n        dp[n - 1] = 1; next[n - 1] = 1;\\n        int len = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            int max = 0, cnt = 0;\\n            for (int j = i + 1; j < n; j++){\\n                if (nums[j] > nums[i]){\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n            dp[i] = max + 1;\\n            len = Math.max(len, dp[i]);\\n            if (dp[i] == 1) next[i] = 1;\\n            else {\\n                for(int j = i + 1; j < n; ++j){\\n                    if(nums[j] > nums[i] && dp[j] == max){\\n                        next[i] += next[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == len){\\n                res += next[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        \\n        int[] dp = new int[n];\\n        int[] next = new int[n];\\n        dp[n - 1] = 1; next[n - 1] = 1;\\n        int len = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            int max = 0, cnt = 0;\\n            for (int j = i + 1; j < n; j++){\\n                if (nums[j] > nums[i]){\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n            dp[i] = max + 1;\\n            len = Math.max(len, dp[i]);\\n            if (dp[i] == 1) next[i] = 1;\\n            else {\\n                for(int j = i + 1; j < n; ++j){\\n                    if(nums[j] > nums[i] && dp[j] == max){\\n                        next[i] += next[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == len){\\n                res += next[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981425,
                "title": "c-clean-code-space-95-speed-75",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int ans = INT_MIN, n = nums.size();\\n        vector<pair<int, int>> dp (n, {1, 1});\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if(dp[i].first < dp[j].first + 1) dp[i].second = 0;\\n                    \\n                    dp[i].first = max(dp[i].first, dp[j].first + 1);\\n                    if(dp[i].first <= dp[j].first + 1) dp[i].second += dp[j].second;\\n\\n                    ans = max(ans, dp[i].first);\\n                }\\n            }\\n        }\\n    \\n        if(ans == INT_MIN) return nums.size(); \\n        int res = 0;\\n      \\n        for(auto [sub, count]: dp) \\n            if(sub == ans) res += count;\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int ans = INT_MIN, n = nums.size();\\n        vector<pair<int, int>> dp (n, {1, 1});\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if(dp[i].first < dp[j].first + 1) dp[i].second = 0;\\n                    \\n                    dp[i].first = max(dp[i].first, dp[j].first + 1);\\n                    if(dp[i].first <= dp[j].first + 1) dp[i].second += dp[j].second;\\n\\n                    ans = max(ans, dp[i].first);\\n                }\\n            }\\n        }\\n    \\n        if(ans == INT_MIN) return nums.size(); \\n        int res = 0;\\n      \\n        for(auto [sub, count]: dp) \\n            if(sub == ans) res += count;\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940178,
                "title": "python-using-the-concept-of-lis-easy",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)           \\n        dp=[1]*n\\n        maxi=1\\n        ct=[1]*n\\n        c=0\\n        for i in range(1,n):\\n            for prev in range(i): \\n                if nums[i]>nums[prev] and dp[prev]+1>dp[i]:\\n                    dp[i]=dp[prev]+1\\n                    ct[i]=ct[prev]\\n                elif nums[i]>nums[prev] and dp[prev]+1==dp[i]:\\n                    ct[i]+=ct[prev]\\n            maxi=max(maxi,dp[i])\\n        for i in range(n):\\n            if dp[i]==maxi:\\n                c+=ct[i]\\n        return c\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)           \\n        dp=[1]*n\\n        maxi=1\\n        ct=[1]*n\\n        c=0\\n        for i in range(1,n):\\n            for prev in range(i): \\n                if nums[i]>nums[prev] and dp[prev]+1>dp[i]:\\n                    dp[i]=dp[prev]+1\\n                    ct[i]=ct[prev]\\n                elif nums[i]>nums[prev] and dp[prev]+1==dp[i]:\\n                    ct[i]+=ct[prev]\\n            maxi=max(maxi,dp[i])\\n        for i in range(n):\\n            if dp[i]==maxi:\\n                c+=ct[i]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915533,
                "title": "o-n-logn-solution-100-faster-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Binary search\\n\\n# Complexity\\n- Time complexity:O(N * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Create DP array to track smallest ending element of increasing subsequences\\n        vector<int> dp(n+1, INT_MAX);\\n        \\n        // Create 2D vector to store information about increasing subsequences of different lengths\\n        vector<vector<pair<int,int>>> LISbylen(n+1);//count,last ele of that len\\n        \\n        // Initialize base case for DP and LISbylen\\n        dp[0] = INT_MIN;\\n        LISbylen[0] = {{1, INT_MIN}};\\n        \\n        int max_len = 1; // Track the maximum length of increasing subsequences\\n        \\n        // Iterate through each element in the input array\\n        for(auto &ele: nums){\\n            // Find the length of the LIS ending at ele\\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele; // Update the DP array\\n            \\n            int ele_count = 0; // Count of subsequences ending at ele\\n            \\n            // Iterate through previous subsequences of length len-1\\n            for(auto &[count, last]: LISbylen[len-1]){\\n                if(ele > last) {\\n                    ele_count += count; // Increment count for valid extensions\\n                }\\n            }\\n            \\n            // Store the information about the new subsequence ending at ele\\n            LISbylen[len].push_back({ele_count, ele});\\n            \\n            // Update the maximum length of increasing subsequences\\n            max_len = max(max_len, len);\\n        }\\n        \\n        int num_lis = 0; // Total number of Longest Increasing Subsequences\\n        \\n        // Count the number of LIS by summing counts of subsequences of maximum length\\n        for(auto &[count, last]: LISbylen[max_len]){\\n            num_lis += count;\\n        }\\n        \\n        return num_lis;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Create DP array to track smallest ending element of increasing subsequences\\n        vector<int> dp(n+1, INT_MAX);\\n        \\n        // Create 2D vector to store information about increasing subsequences of different lengths\\n        vector<vector<pair<int,int>>> LISbylen(n+1);//count,last ele of that len\\n        \\n        // Initialize base case for DP and LISbylen\\n        dp[0] = INT_MIN;\\n        LISbylen[0] = {{1, INT_MIN}};\\n        \\n        int max_len = 1; // Track the maximum length of increasing subsequences\\n        \\n        // Iterate through each element in the input array\\n        for(auto &ele: nums){\\n            // Find the length of the LIS ending at ele\\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele; // Update the DP array\\n            \\n            int ele_count = 0; // Count of subsequences ending at ele\\n            \\n            // Iterate through previous subsequences of length len-1\\n            for(auto &[count, last]: LISbylen[len-1]){\\n                if(ele > last) {\\n                    ele_count += count; // Increment count for valid extensions\\n                }\\n            }\\n            \\n            // Store the information about the new subsequence ending at ele\\n            LISbylen[len].push_back({ele_count, ele});\\n            \\n            // Update the maximum length of increasing subsequences\\n            max_len = max(max_len, len);\\n        }\\n        \\n        int num_lis = 0; // Total number of Longest Increasing Subsequences\\n        \\n        // Count the number of LIS by summing counts of subsequences of maximum length\\n        for(auto &[count, last]: LISbylen[max_len]){\\n            num_lis += count;\\n        }\\n        \\n        return num_lis;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798520,
                "title": "python-short-and-clean-3-solutions-o-n-log-n-functional-programming",
                "content": "# Approach 1: Recursive DP\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        @cache\\n        def lis_len_count(i: int) -> tuple[int, int]: # Index -> (LIS length, LIS count) ending at Index\\n            len_counts = [lis_len_count(j) for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            return m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1)\\n        \\n        return lis_len_count(n)[1]\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: Iterative DP\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        lis_len_count = [(0, 0)] * (n + 1) # Index -> (LIS length, LIS count) ending at Index\\n        lis_len_count[0] = (1, 1)\\n\\n        for i in range(n + 1):\\n            len_counts = [lis_len_count[j] for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            lis_len_count[i] = (m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1))\\n        \\n        return lis_len_count[-1][1]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: Segment tree\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\cdot log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        default_value = (0, 1) # (lts_length, lts_count)\\n        \\n        def merge(x, y):\\n            return (x[0], x[1] + y[1]) if x[0] == y[0] and x[0] != 0 else max(x, y)\\n \\n        if not nums: return 0\\n        \\n        start, end = min(nums), max(nums)\\n        st = SegmentTree(start, end, default_value, merge)\\n        for num in nums:\\n            res = st.query(start, num - 1)\\n            st.insert(num, (res[0] + 1, res[1]))\\n        return st.root.value[1]\\n        \\n\\nfrom typing import Callable, TypeVar\\n\\nT = TypeVar(\"T\")\\n\\n\\nclass SegmentTree:\\n    class Node:\\n        def __init__(self, value: T, start: int, end: int, left=None, right=None):\\n            self.value = value\\n            self.start = start\\n            self.end = end\\n            self.left = left\\n            self.right = right\\n\\n        @property\\n        def mid(self):\\n            return (self.start + self.end) // 2\\n\\n    def __init__(\\n        self, start: int, end: int, default_value: T, func: Callable[[T, T], T]\\n    ):\\n        self.func = func\\n        self.default_value = default_value\\n        self.root = SegmentTree.Node(default_value, start, end)\\n\\n    def safe_left(self, node: Node):\\n        node.left = (\\n            node.left\\n            if node.left\\n            else SegmentTree.Node(self.default_value, node.start, node.mid)\\n        )\\n        return node.left\\n\\n    def safe_right(self, node: Node):\\n        node.right = (\\n            node.right\\n            if node.right\\n            else SegmentTree.Node(self.default_value, node.mid + 1, node.end)\\n        )\\n        return node.right\\n\\n    def insert(self, key: int, value: T) -> None:\\n        def insert_segment(node: SegmentTree.Node):\\n            if node.start == node.end:\\n                node.value = self.func(value, node.value)\\n                return\\n\\n            if key <= node.mid:\\n                insert_segment(self.safe_left(node))\\n            elif key > node.mid:\\n                insert_segment(self.safe_right(node))\\n\\n            node.value = self.func(\\n                self.safe_left(node).value, self.safe_right(node).value\\n            )\\n\\n        insert_segment(self.root)\\n\\n    def update(self, key: int, value: T) -> None:\\n        self.insert(key, value)\\n\\n    def query(self, start: int, end: int) -> int:\\n        def query_segment(node: SegmentTree.Node):\\n            if start <= node.start <= node.end <= end:\\n                return node.value\\n\\n            if end < start or end < node.start or node.end < start:\\n                return self.default_value\\n\\n            left_value = query_segment(self.safe_left(node))\\n            right_value = query_segment(self.safe_right(node))\\n\\n            return self.func(left_value, right_value)\\n\\n        return query_segment(self.root)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        @cache\\n        def lis_len_count(i: int) -> tuple[int, int]: # Index -> (LIS length, LIS count) ending at Index\\n            len_counts = [lis_len_count(j) for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            return m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1)\\n        \\n        return lis_len_count(n)[1]\\n\\n\\n```\n```python\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        lis_len_count = [(0, 0)] * (n + 1) # Index -> (LIS length, LIS count) ending at Index\\n        lis_len_count[0] = (1, 1)\\n\\n        for i in range(n + 1):\\n            len_counts = [lis_len_count[j] for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            lis_len_count[i] = (m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1))\\n        \\n        return lis_len_count[-1][1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        default_value = (0, 1) # (lts_length, lts_count)\\n        \\n        def merge(x, y):\\n            return (x[0], x[1] + y[1]) if x[0] == y[0] and x[0] != 0 else max(x, y)\\n \\n        if not nums: return 0\\n        \\n        start, end = min(nums), max(nums)\\n        st = SegmentTree(start, end, default_value, merge)\\n        for num in nums:\\n            res = st.query(start, num - 1)\\n            st.insert(num, (res[0] + 1, res[1]))\\n        return st.root.value[1]\\n        \\n\\nfrom typing import Callable, TypeVar\\n\\nT = TypeVar(\"T\")\\n\\n\\nclass SegmentTree:\\n    class Node:\\n        def __init__(self, value: T, start: int, end: int, left=None, right=None):\\n            self.value = value\\n            self.start = start\\n            self.end = end\\n            self.left = left\\n            self.right = right\\n\\n        @property\\n        def mid(self):\\n            return (self.start + self.end) // 2\\n\\n    def __init__(\\n        self, start: int, end: int, default_value: T, func: Callable[[T, T], T]\\n    ):\\n        self.func = func\\n        self.default_value = default_value\\n        self.root = SegmentTree.Node(default_value, start, end)\\n\\n    def safe_left(self, node: Node):\\n        node.left = (\\n            node.left\\n            if node.left\\n            else SegmentTree.Node(self.default_value, node.start, node.mid)\\n        )\\n        return node.left\\n\\n    def safe_right(self, node: Node):\\n        node.right = (\\n            node.right\\n            if node.right\\n            else SegmentTree.Node(self.default_value, node.mid + 1, node.end)\\n        )\\n        return node.right\\n\\n    def insert(self, key: int, value: T) -> None:\\n        def insert_segment(node: SegmentTree.Node):\\n            if node.start == node.end:\\n                node.value = self.func(value, node.value)\\n                return\\n\\n            if key <= node.mid:\\n                insert_segment(self.safe_left(node))\\n            elif key > node.mid:\\n                insert_segment(self.safe_right(node))\\n\\n            node.value = self.func(\\n                self.safe_left(node).value, self.safe_right(node).value\\n            )\\n\\n        insert_segment(self.root)\\n\\n    def update(self, key: int, value: T) -> None:\\n        self.insert(key, value)\\n\\n    def query(self, start: int, end: int) -> int:\\n        def query_segment(node: SegmentTree.Node):\\n            if start <= node.start <= node.end <= end:\\n                return node.value\\n\\n            if end < start or end < node.start or node.end < start:\\n                return self.default_value\\n\\n            left_value = query_segment(self.safe_left(node))\\n            right_value = query_segment(self.safe_right(node))\\n\\n            return self.func(left_value, right_value)\\n\\n        return query_segment(self.root)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798495,
                "title": "easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int findNumberOfLIS(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>dp(n,1);\\n        int mx=1;\\n        vector<int>ct(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(v[i]>v[j]){\\n                    if(dp[i]<dp[j]+1){\\n                        dp[i]=dp[j]+1;\\n                        ct[i]=ct[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1){\\n                        ct[i]+=ct[j];\\n                    }\\n                }\\n                mx=max(mx,dp[i]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<ct[i]<<\" \";\\n            if(dp[i]==mx)ans+=ct[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int findNumberOfLIS(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>dp(n,1);\\n        int mx=1;\\n        vector<int>ct(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(v[i]>v[j]){\\n                    if(dp[i]<dp[j]+1){\\n                        dp[i]=dp[j]+1;\\n                        ct[i]=ct[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1){\\n                        ct[i]+=ct[j];\\n                    }\\n                }\\n                mx=max(mx,dp[i]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<ct[i]<<\" \";\\n            if(dp[i]==mx)ans+=ct[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3798321,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int max=1;\\n        Arrays.fill(arr,1);\\n        int count[]=new int[nums.length];\\n        Arrays.fill(count , 1);\\n        int ans=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[j]<nums[i]){\\n                    if(arr[i]==arr[j]+1){\\n                        count[i]+=count[j];\\n                    }else if(arr[i]<arr[j]+1){\\n                        arr[i]=arr[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            max=Math.max(arr[i] , max);\\n        }\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==max){\\n                ans=count[i]+ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int max=1;\\n        Arrays.fill(arr,1);\\n        int count[]=new int[nums.length];\\n        Arrays.fill(count , 1);\\n        int ans=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[j]<nums[i]){\\n                    if(arr[i]==arr[j]+1){\\n                        count[i]+=count[j];\\n                    }else if(arr[i]<arr[j]+1){\\n                        arr[i]=arr[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            max=Math.max(arr[i] , max);\\n        }\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==max){\\n                ans=count[i]+ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797844,
                "title": "python3-92-faster-beats-984ms-different-from-other-popular-answers",
                "content": "![image.png](https://assets.leetcode.com/users/images/f9924688-f2d5-4df7-a5b6-45f4a5904fb2_1689959631.708924.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        ct = defaultdict(list)\\n        ct[0] = [1,1]\\n        length,longest,ans = len(nums),1,1\\n\\n        for right in range(1,length):\\n            map,cur_longest = defaultdict(lambda:1),1\\n            for left in range(right-1,-1,-1):\\n                if nums[right] > nums[left] and ct[left][0]+1>=cur_longest:\\n                    temp_long,temp_ct = ct[left]\\n                    cur_longest = temp_long+1\\n                    map[cur_longest] += temp_ct\\n            if map:\\n                map[cur_longest]-=1\\n                ct[right] = [cur_longest,map[cur_longest]]\\n            else:\\n                ct[right] = ct[0]\\n            if cur_longest > longest:\\n                longest,ans = cur_longest,map[cur_longest]\\n            elif cur_longest == longest:\\n                ans += map[cur_longest]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        ct = defaultdict(list)\\n        ct[0] = [1,1]\\n        length,longest,ans = len(nums),1,1\\n\\n        for right in range(1,length):\\n            map,cur_longest = defaultdict(lambda:1),1\\n            for left in range(right-1,-1,-1):\\n                if nums[right] > nums[left] and ct[left][0]+1>=cur_longest:\\n                    temp_long,temp_ct = ct[left]\\n                    cur_longest = temp_long+1\\n                    map[cur_longest] += temp_ct\\n            if map:\\n                map[cur_longest]-=1\\n                ct[right] = [cur_longest,map[cur_longest]]\\n            else:\\n                ct[right] = ct[0]\\n            if cur_longest > longest:\\n                longest,ans = cur_longest,map[cur_longest]\\n            elif cur_longest == longest:\\n                ans += map[cur_longest]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797763,
                "title": "easy-dp-solution-in-c-java-javascript",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1), count(n, 1);\\n        int res = 0, maxi = 1;\\n\\n        for(int i = 0; i < n; ++i){\\n            for(int prev = 0; prev < i; ++prev){\\n                if(nums[prev] < nums[i] && 1 + dp[prev] > dp[i]){\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if(nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi)\\n                res += count[i];\\n\\n        return res;\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n], count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n        int res = 0, maxi = 1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int prev = 0; prev < i; ++prev) {\\n                if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i])\\n                    count[i] += count[prev];\\n            }\\n            maxi = Math.max(maxi, dp[i]);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == maxi)\\n                res += count[i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n# JAVASCRIPT\\n```\\nvar findNumberOfLIS = function (nums) {\\n    let n = nums.length;\\n    let dp = new Array(n).fill(1), count = new Array(n).fill(1);\\n    let res = 0, maxi = 1;\\n\\n    for (let i = 0; i < n; ++i) {\\n        for (let prev = 0; prev < i; ++prev) {\\n            if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                dp[i] = 1 + dp[prev];\\n                count[i] = count[prev];\\n            } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n        }\\n        maxi = Math.max(maxi, dp[i]);\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (maxi == dp[i])\\n            res += count[i];\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1), count(n, 1);\\n        int res = 0, maxi = 1;\\n\\n        for(int i = 0; i < n; ++i){\\n            for(int prev = 0; prev < i; ++prev){\\n                if(nums[prev] < nums[i] && 1 + dp[prev] > dp[i]){\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if(nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi)\\n                res += count[i];\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n], count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n        int res = 0, maxi = 1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int prev = 0; prev < i; ++prev) {\\n                if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i])\\n                    count[i] += count[prev];\\n            }\\n            maxi = Math.max(maxi, dp[i]);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == maxi)\\n                res += count[i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nvar findNumberOfLIS = function (nums) {\\n    let n = nums.length;\\n    let dp = new Array(n).fill(1), count = new Array(n).fill(1);\\n    let res = 0, maxi = 1;\\n\\n    for (let i = 0; i < n; ++i) {\\n        for (let prev = 0; prev < i; ++prev) {\\n            if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                dp[i] = 1 + dp[prev];\\n                count[i] = count[prev];\\n            } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n        }\\n        maxi = Math.max(maxi, dp[i]);\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (maxi == dp[i])\\n            res += count[i];\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797416,
                "title": "673-number-of-longest-increasing-subsequence-java",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] cnt = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(cnt,1);\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            cnt[i] = cnt[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            cnt[i] += cnt[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] cnt = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(cnt,1);\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            cnt[i] = cnt[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            cnt[i] += cnt[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797256,
                "title": "c-java-easy-and-clean-code-dp-bottom-up-beats",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n<!-- > **Please do UpVote** it took lot of time to figure out these solutions -->\\n\\n# Complexity \\n<!-- - Please check the code, as every solution have different complexity -->\\n- Time complexity: $$O(N^2)$$ where `N = nums.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), lenLis = 1;\\n        vector<int> dp(n, 1), cnt(n, 1);\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, lenLis = 1;\\n        int dp[] = new int[n], cnt[] = new int[n];\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            dp[i] = cnt[i] = 1;\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = Math.max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), lenLis = 1;\\n        vector<int> dp(n, 1), cnt(n, 1);\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, lenLis = 1;\\n        int dp[] = new int[n], cnt[] = new int[n];\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            dp[i] = cnt[i] = 1;\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = Math.max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797143,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  result = [[[-Float::INFINITY,1]]]\\n  \\n  nums.each do |num|\\n    reference_index = result.bsearch_index {|arr| arr.first.first >= num}\\n\\n    unless reference_index\\n      reference_index = result.size\\n      result << [[num, 0]]\\n    end\\n\\n    unless result[reference_index].first.first == num\\n      result[reference_index].unshift [num, 0]\\n    end\\n\\n    sum = result[reference_index - 1].select {|arr| arr.first < num}.sum(&:last)\\n    result[reference_index].first[1] += sum\\n  end\\n  \\n  result.last.sum(&:last)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  result = [[[-Float::INFINITY,1]]]\\n  \\n  nums.each do |num|\\n    reference_index = result.bsearch_index {|arr| arr.first.first >= num}\\n\\n    unless reference_index\\n      reference_index = result.size\\n      result << [[num, 0]]\\n    end\\n\\n    unless result[reference_index].first.first == num\\n      result[reference_index].unshift [num, 0]\\n    end\\n\\n    sum = result[reference_index - 1].select {|arr| arr.first < num}.sum(&:last)\\n    result[reference_index].first[1] += sum\\n  end\\n  \\n  result.last.sum(&:last)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3796978,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\nWe will use a dynamic programming approach to track the lengths and counts of increasing subsequences ending at each position in the array. The final answer will be the sum of the counts of subsequences with the maximum length.\\n\\n# Approach\\n\\n\\n1. We initialize two lists `lengths` and `counts`, each with a length equal to the number of elements in the input array `nums`.\\n2. We iterate through the array with two nested loops. For each element at index `i`, we compare it with all previous elements at indices `j < i`.\\n3. If `nums[i] > nums[j]`, it means we can extend the increasing subsequence ending at index `j` by adding element `i`. We then check if this extension results in a longer subsequence (`lengths[j] + 1 > lengths[i]`), and update the `lengths` and `counts` lists accordingly.\\n4. After the iteration, we have the length of the longest increasing subsequence in the variable `max_length`. We then calculate the total count of subsequences with that length and return it.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n == 0:\\n            return 0\\n        \\n        lengths = [1] * n\\n        counts = [1] * n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        \\n        max_length= max(lengths)\\n        total_count= sum(count for length , count in zip(lengths,counts) if length == max_length)\\n\\n        return total_count\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n == 0:\\n            return 0\\n        \\n        lengths = [1] * n\\n        counts = [1] * n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        \\n        max_length= max(lengths)\\n        total_count= sum(count for length , count in zip(lengths,counts) if length == max_length)\\n\\n        return total_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796920,
                "title": "easy-begineer-friendly",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/47b0286e-43c1-4f87-a09f-327ece584735_1689943499.6379132.jpeg)\\nPlease Upvote me :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796763,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) \\n        {\\n            for (int j = 0; j < i; j++) \\n            {\\n                if (nums[i] > nums[j]) \\n                {\\n                    if (len[j]+1 > len[i]) \\n                    {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) \\n        {\\n            for (int j = 0; j < i; j++) \\n            {\\n                if (nums[i] > nums[j]) \\n                {\\n                    if (len[j]+1 > len[i]) \\n                    {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796020,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Recursive    \\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLIS(vector<int>& nums,int prev,int curr){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLIS(nums,curr,curr+1);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLIS(nums,prev,curr+1);\\n        if(include.first==exclude.first){\\n            return {include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            return include;\\n        }\\n        else{\\n            return exclude;\\n        }\\n    }\\n\\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLISMemoization(vector<int>& nums,int prev,int curr,vector<vector<pair<int,int>>> &dp){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n        if(dp[prev+1][curr].first!=-1){\\n            return dp[prev+1][curr];\\n        }\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLISMemoization(nums,curr,curr+1,dp);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLISMemoization(nums,prev,curr+1,dp);\\n        if(include.first==exclude.first){\\n            dp[prev+1][curr]={include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            dp[prev+1][curr]= include;\\n        }\\n        else{\\n            dp[prev+1][curr]= exclude;\\n        }\\n        return dp[prev+1][curr];\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<vector<pair<int,int>>> dp(nums.size()+1,vector<pair<int,int>>(nums.size()+1,{-1,-1}));\\n        //return calculateNoOfLIS(nums,-1,0).second;\\n        return calculateNoOfLISMemoization(nums,-1,0,dp).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Recursive    \\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLIS(vector<int>& nums,int prev,int curr){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLIS(nums,curr,curr+1);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLIS(nums,prev,curr+1);\\n        if(include.first==exclude.first){\\n            return {include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            return include;\\n        }\\n        else{\\n            return exclude;\\n        }\\n    }\\n\\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLISMemoization(vector<int>& nums,int prev,int curr,vector<vector<pair<int,int>>> &dp){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n        if(dp[prev+1][curr].first!=-1){\\n            return dp[prev+1][curr];\\n        }\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLISMemoization(nums,curr,curr+1,dp);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLISMemoization(nums,prev,curr+1,dp);\\n        if(include.first==exclude.first){\\n            dp[prev+1][curr]={include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            dp[prev+1][curr]= include;\\n        }\\n        else{\\n            dp[prev+1][curr]= exclude;\\n        }\\n        return dp[prev+1][curr];\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<vector<pair<int,int>>> dp(nums.size()+1,vector<pair<int,int>>(nums.size()+1,{-1,-1}));\\n        //return calculateNoOfLIS(nums,-1,0).second;\\n        return calculateNoOfLISMemoization(nums,-1,0,dp).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795799,
                "title": "ruby-solution-with-tests-beats-100-and-100",
                "content": "# Approach\\nDynamic Programming\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  n = nums.length\\n  return 0 if n == 0\\n  dp = Array.new(n, 1)\\n  count = Array.new(n, 1)\\n\\n  (0...n).each do |i|\\n    (0...i).each do |j|\\n      if nums[i] > nums[j]\\n        if dp[i] == dp[j] + 1\\n          count[i] += count[j]\\n        elsif dp[i] < dp[j] + 1\\n          dp[i] = dp[j] + 1\\n          count[i] = count[j]\\n        end\\n      end\\n    end\\n  end\\n\\n  max_length = dp.max\\n  count.select.with_index { |_, i| dp[i] == max_length }.sum\\nend\\n\\n# **************** #\\n#       TEST       #\\n# **************** #\\n\\nrequire \"test/unit\"\\nclass Test_find_number_of_lis < Test::Unit::TestCase\\n  def test_\\n    assert_equal 2, find_number_of_lis([1, 3, 5, 4, 7])\\n    assert_equal 5, find_number_of_lis([2, 2, 2, 2, 2])\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  n = nums.length\\n  return 0 if n == 0\\n  dp = Array.new(n, 1)\\n  count = Array.new(n, 1)\\n\\n  (0...n).each do |i|\\n    (0...i).each do |j|\\n      if nums[i] > nums[j]\\n        if dp[i] == dp[j] + 1\\n          count[i] += count[j]\\n        elsif dp[i] < dp[j] + 1\\n          dp[i] = dp[j] + 1\\n          count[i] = count[j]\\n        end\\n      end\\n    end\\n  end\\n\\n  max_length = dp.max\\n  count.select.with_index { |_, i| dp[i] == max_length }.sum\\nend\\n\\n# **************** #\\n#       TEST       #\\n# **************** #\\n\\nrequire \"test/unit\"\\nclass Test_find_number_of_lis < Test::Unit::TestCase\\n  def test_\\n    assert_equal 2, find_number_of_lis([1, 3, 5, 4, 7])\\n    assert_equal 5, find_number_of_lis([2, 2, 2, 2, 2])\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795268,
                "title": "step-by-step-explanation-short-and-optimize-code",
                "content": "# Intuition\\nThe problem requires finding the number of longest increasing subsequences in the given array of numbers. We can use a dynamic programming approach to solve this problem.\\n\\n# Approach\\nWe will use two arrays lis and cnt. The lis array will keep track of the length of the longest increasing subsequence ending at each index, and the cnt array will keep track of the count of the longest increasing subsequences ending at each index.\\n\\nTo fill these arrays, we will iterate through the array from right to left. For each index i, we will find the length of the longest increasing subsequence ending at that index and store it in the lis array. We will also keep track of the count of such subsequences and store it in the cnt array.\\n\\nTo compute the lis value at each index i, we will iterate through the array from i + 1 to the end. For each index j, if the element at index j is greater than the element at index i, we can extend the increasing subsequence ending at index i by one, and the length of the longest increasing subsequence ending at index j will be lis[j] + 1. We will take the maximum of all such values to get the lis value for index i.\\n\\nWhile calculating the lis value, we will also keep track of the count of such subsequences. If the lis value for index j plus one is greater than the current lis value for index i, it means we have found a new longer subsequence, so we set the cnt value for index i to the cnt value for index j. If the lis value for index j plus one is equal to the current lis value for index i, it means we have found another subsequence of the same length, so we add the cnt value for index j to the cnt value for index i.\\n\\nAfter filling the lis and cnt arrays, we find the maximum value in the lis array, which represents the length of the longest increasing subsequence. Then we iterate through the lis array and add up the cnt values for all indices where the lis value matches the maximum value. This will give us the total count of the longest increasing subsequences in the array.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n^2), where n is the number of elements in the array. We iterate through the array twice, once to compute the lis and cnt arrays, and then to find the count of longest increasing subsequences.\\n- Space complexity: The space complexity is O(n) as we use two arrays lis and cnt of length n to store the intermediate results.\\n\\n# Code\\n```\\nfunction findNumberOfLIS(nums: number[]): number {\\n    let n = nums.length, lis = new Array(n).fill(1), cnt = new Array(n).fill(1);\\n    for( let i = n - 2 ; i >= 0 ; i-- ){\\n        let max = 1, c = 1;\\n        for( let j = i + 1 ; j < n ; j++ ){\\n            if( nums[i] < nums[j] ){\\n                if( max < lis[j] + 1 ){\\n                    max = lis[j] + 1;\\n                    c = cnt[j]\\n                }\\n                else if( max === lis[j] + 1 )c += cnt[j];\\n            }\\n        }\\n        lis[i] = max;\\n        cnt[i] = c;\\n    }\\n    let max = Math.max(...lis), res = 0;\\n    for( let i = 0 ; i < n ; i++ )if( max === lis[i])res += cnt[i];\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction findNumberOfLIS(nums: number[]): number {\\n    let n = nums.length, lis = new Array(n).fill(1), cnt = new Array(n).fill(1);\\n    for( let i = n - 2 ; i >= 0 ; i-- ){\\n        let max = 1, c = 1;\\n        for( let j = i + 1 ; j < n ; j++ ){\\n            if( nums[i] < nums[j] ){\\n                if( max < lis[j] + 1 ){\\n                    max = lis[j] + 1;\\n                    c = cnt[j]\\n                }\\n                else if( max === lis[j] + 1 )c += cnt[j];\\n            }\\n        }\\n        lis[i] = max;\\n        cnt[i] = c;\\n    }\\n    let max = Math.max(...lis), res = 0;\\n    for( let i = 0 ; i < n ; i++ )if( max === lis[i])res += cnt[i];\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795256,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1), cnt(n,1);\\n        int maxi = 1;\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j] && dp[i] < dp[j] + 1)\\n                {\\n                    dp[i] = 1 + dp[j];\\n                    cnt[i] = cnt[j];\\n                }\\n                else if(nums[i] > nums[j] && dp[i] == 1 + dp[j])\\n                    cnt[i] += cnt[j];     \\n                maxi = max(maxi,dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1), cnt(n,1);\\n        int maxi = 1;\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j] && dp[i] < dp[j] + 1)\\n                {\\n                    dp[i] = 1 + dp[j];\\n                    cnt[i] = cnt[j];\\n                }\\n                else if(nums[i] > nums[j] && dp[i] == 1 + dp[j])\\n                    cnt[i] += cnt[j];     \\n                maxi = max(maxi,dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795253,
                "title": "c-solution-dynamic-programming-supereasy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                         `Bottom-up Dynamic Programming`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Firstly, a dynamic programming (DP) array `dp` of pairs is created. Each element of dp is a pair of integers, denoting `{length_of_lis, count_of_lis}`. Initially, the length of the longest increasing subsequence (LIS) ending at each index is set to 1, and the count of such subsequences is also set to 1.\\n\\n2. The variables `maxi` and `cnt` will be used to keep track of the maximum LIS length found so far and the count of such LIS.\\n\\n3. The nested loops that follow perform a DP calculation to find the length of the LIS ending at each index of the input array nums. The outer loop runs from i = 0 to i = n-1, representing the current index, and the inner loop runs from j = 0 to j = i-1, representing all previous indices.\\n\\n4. Inside the nested loops, the code checks if the element at index i `nums[i]` is greater than the element at index j `nums[j]`. If this condition is true, it means that we can extend the LIS ending at index j with the element at index i.\\n\\n5. If the length of LIS ending at index i `dp[i].first` is equal to the length of LIS ending at index j plus one `dp[j].first + 1`, then we can simply add the count of LIS ending at index j `dp[j].second` to the count of LIS ending at index i `dp[i].second` since we are extending the existing LIS.\\n\\n6. If the length of LIS ending at index i is less than the length of LIS ending at index j plus one, then we have found a longer LIS ending at index i. In this case, we update the length and count of LIS at index i to be the length of LIS at index j plus one and the count of LIS at index j, respectively.\\n\\n7. After the nested loops, the code updates the `maxi` and cnt variables to keep track of the maximum LIS length found so far and the count of such LIS. The count`cnt` is calculated based on the length and count of LIS at each index of the dp array.\\n\\n8. Finally, the function returns the count of the longest increasing subsequences found in the input vector nums as `cnt`.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        vector<pair<int,int>> dp(n,{1,1});\\n\\n        int maxi=0,cnt=0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n\\n                if(nums[i]>nums[j]){\\n            // //we have found another subsequence with the same length as the one ending at i\\n                    if(dp[i].first==dp[j].first+1){\\n                        dp[i].second+=dp[j].second;\\n                    }\\n            //we have found a new longer subsequence ending at i\\n                    else if(dp[i].first<dp[j].first+1){\\n                        dp[i].second=dp[j].second;\\n                        dp[i].first=dp[j].first+1;\\n                    }\\n                }\\n            }\\n\\n            if(dp[i].first==maxi) cnt+=dp[i].second;\\n\\n            else if(dp[i].first>maxi){\\n                maxi=dp[i].first;\\n                cnt=dp[i].second;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        vector<pair<int,int>> dp(n,{1,1});\\n\\n        int maxi=0,cnt=0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n\\n                if(nums[i]>nums[j]){\\n            // //we have found another subsequence with the same length as the one ending at i\\n                    if(dp[i].first==dp[j].first+1){\\n                        dp[i].second+=dp[j].second;\\n                    }\\n            //we have found a new longer subsequence ending at i\\n                    else if(dp[i].first<dp[j].first+1){\\n                        dp[i].second=dp[j].second;\\n                        dp[i].first=dp[j].first+1;\\n                    }\\n                }\\n            }\\n\\n            if(dp[i].first==maxi) cnt+=dp[i].second;\\n\\n            else if(dp[i].first>maxi){\\n                maxi=dp[i].first;\\n                cnt=dp[i].second;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795051,
                "title": "python-easy-to-understand-medium-problem-673-number-of-longest-increasing-subsequence",
                "content": "# Python | Easy to Understand | Medium Problem | 673. Number of Longest Increasing Subsequence\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795040,
                "title": "c-dynamic-programming-easy-to-understand-medium-number-of-longest-increasing-subsequence",
                "content": "# C++ | Dynamic Programming | Easy to Understand | Medium Problem | Optimal Solution | 673. Number of Longest Increasing Subsequence\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> size(n, 1);\\n        vector<int> ways(n, 1);\\n\\n        int maxL = 1;\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(nums[i] > nums[j] && size[j] + 1 > size[i]) {\\n                    size[i] = size[j] + 1;\\n                    ways[i] = ways[j];\\n                }\\n                else if(nums[i] > nums[j] && size[j] + 1 == size[i]) {\\n                    ways[i] += ways[j];\\n                }\\n                \\n                maxL = max(maxL, size[i]);\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++) {\\n            if(size[i] == maxL){\\n                res += ways[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> size(n, 1);\\n        vector<int> ways(n, 1);\\n\\n        int maxL = 1;\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(nums[i] > nums[j] && size[j] + 1 > size[i]) {\\n                    size[i] = size[j] + 1;\\n                    ways[i] = ways[j];\\n                }\\n                else if(nums[i] > nums[j] && size[j] + 1 == size[i]) {\\n                    ways[i] += ways[j];\\n                }\\n                \\n                maxL = max(maxL, size[i]);\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++) {\\n            if(size[i] == maxL){\\n                res += ways[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794978,
                "title": "c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>res(n,1);  //stores len\\n        vector<int>count(n,1);  //stores count\\n        int mxlen=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]<nums[j]) continue;\\n                if(nums[i]>nums[j]){\\n                    if(res[j]+1 > res[i]){\\n                        res[i]=res[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(res[j]+1==res[i]){\\n                        count[i]+=count[j];\\n\\n                    }    \\n                }\\n            }\\n            mxlen=max(mxlen,res[i]);\\n        }\\n        int no_of_lis=0;\\n        for(int i=0;i<n;i++){\\n            if(res[i]==mxlen){\\n                no_of_lis+=count[i];\\n            }\\n        }\\n        return no_of_lis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>res(n,1);  //stores len\\n        vector<int>count(n,1);  //stores count\\n        int mxlen=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]<nums[j]) continue;\\n                if(nums[i]>nums[j]){\\n                    if(res[j]+1 > res[i]){\\n                        res[i]=res[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(res[j]+1==res[i]){\\n                        count[i]+=count[j];\\n\\n                    }    \\n                }\\n            }\\n            mxlen=max(mxlen,res[i]);\\n        }\\n        int no_of_lis=0;\\n        for(int i=0;i<n;i++){\\n            if(res[i]==mxlen){\\n                no_of_lis+=count[i];\\n            }\\n        }\\n        return no_of_lis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794840,
                "title": "commented-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n),count(n);\\n        int ans = 0;\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            count[i] = 1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && dp[j] + 1 > dp[i]){ // Basic LIS conditions\\n                    dp[i] = dp[j] + 1;\\n                    count[i] = count[j];\\n                }\\n                else if(1 + dp[j] == dp[i]) // Modification\\u2019s for keeping up the count\\n                    count[i] += count[j];\\n            }\\n            maxLen = max(maxLen,dp[i]); // Store max length of LIS\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(dp[i] == maxLen) // Add every LIS possible\\n                ans += count[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n),count(n);\\n        int ans = 0;\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            count[i] = 1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && dp[j] + 1 > dp[i]){ // Basic LIS conditions\\n                    dp[i] = dp[j] + 1;\\n                    count[i] = count[j];\\n                }\\n                else if(1 + dp[j] == dp[i]) // Modification\\u2019s for keeping up the count\\n                    count[i] += count[j];\\n            }\\n            maxLen = max(maxLen,dp[i]); // Store max length of LIS\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(dp[i] == maxLen) // Add every LIS possible\\n                ans += count[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1979267,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980086,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979489,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979352,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979252,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1571800,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979641,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980079,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979778,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1569668,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979267,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980086,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979489,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979352,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979252,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1571800,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979641,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980079,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979778,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1569668,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980045,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979875,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1925878,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979810,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979597,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979334,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979323,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1576414,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1571801,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 2068385,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 2047539,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1990368,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1983352,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980599,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980497,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980246,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980221,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980197,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980027,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1979902,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Continuous Increasing Subsequence",
        "question_content": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest <strong>continuous increasing subsequence</strong> (i.e. subarray)</em>. The subsequence must be <strong>strictly</strong> increasing.</p>\n\n<p>A <strong>continuous increasing subsequence</strong> is defined by two indices <code>l</code> and <code>r</code> (<code>l &lt; r</code>) such that it is <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> and for each <code>l &lt;= i &lt; r</code>, <code>nums[i] &lt; nums[i + 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,4,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5] with length 3.\nEven though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\nincreasing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 107365,
                "title": "java-c-clean-solution",
                "content": "The idea is to use ```cnt``` to record the length of the current continuous increasing subsequence which ends with ```nums[i]```, and use ```res``` to record the maximum ```cnt```.\\n\\nJava version:\\n```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = Math.max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```\\n\\nC++ version:\\n```\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cnt```\n```nums[i]```\n```res```\n```cnt```\n```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = Math.max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199080,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp = [1] * len(nums)\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp = [1] * len(nums)\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107392,
                "title": "python-simple-solution",
                "content": "A continuous subsequence is essentially a subarray. Hence this question is asking for the longest increasing subarray and I have no idea why the question calls it continuous subsequence to confuse the readers. \\n\\nAnyway, we can make one pass of the array and keep track of the current streak of increasing elements, reset it when it does not increase.\\n\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        max_len = i = 0\\n        while i < len(nums):\\n            curr = 1\\n            while i + 1 < len(nums) and nums[i] < nums[i + 1]:\\n                curr, i = curr + 1, i + 1\\n            max_len = max(max_len, curr)\\n            i += 1\\n        return max_len\\n```\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        max_len = i = 0\\n        while i < len(nums):\\n            curr = 1\\n            while i + 1 < len(nums) and nums[i] < nums[i + 1]:\\n                curr, i = curr + 1, i + 1\\n            max_len = max(max_len, curr)\\n            i += 1\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669734,
                "title": "c-simple-solution",
                "content": "***Pls upvote if you find this helpful  :)***\\nKeep the length of each increasing sequence in a variable and one global variable for updating it with all the lengths of increasing sequences.\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107352,
                "title": "java-code-6-liner",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535268,
                "title": "python-o-n-solution-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        cur_len = 1\\n        max_len = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1\\n            else:\\n                max_len = max(max_len,cur_len)\\n                cur_len = 1\\n        \\n        return max(max_len,cur_len)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        cur_len = 1\\n        max_len = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1\\n            else:\\n                max_len = max(max_len,cur_len)\\n                cur_len = 1\\n        \\n        return max(max_len,cur_len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577001,
                "title": "easy-c-2-lines",
                "content": "Always set r and c as 1 cause subsequence length can\\'t be smaller than 1.\\n```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int r=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n            r=max(r,nums[i]>nums[i-1]?++c:c=1);\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int r=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n            r=max(r,nums[i]>nums[i-1]?++c:c=1);\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107351,
                "title": "java-solution-dp",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        \\n        int max = 1;\\n        dp[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n            else {\\n                dp[i] = 1;\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        \\n        int max = 1;\\n        dp[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n            else {\\n                dp[i] = 1;\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107389,
                "title": "c-java-clean-code-3-liner-2-pointers",
                "content": "**C++ record length**\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n};\\n```\\n**C++ 2 pointer**\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); j++) {\\n            if (j == 0 || a[j] <= a[j - 1]) i = j;\\n            mx = max(mx, j - (i - 1))\\n        }\\n        return mx;\\n    }\\n};\\n```\\n3 liner\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = max(mx, j - (i - 1)), j++) { }\\n        return mx;\\n    }\\n};\\n```\\n**Java - 2 pointer**\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.length; i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = Math.max(mx, j - i + 1), j++) { }\\n        return mx;\\n    }\\n}\\n```\\n\\n**Java length variable**\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = Math.max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); j++) {\\n            if (j == 0 || a[j] <= a[j - 1]) i = j;\\n            mx = max(mx, j - (i - 1))\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = max(mx, j - (i - 1)), j++) { }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.length; i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = Math.max(mx, j - i + 1), j++) { }\\n        return mx;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = Math.max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394570,
                "title": "1-ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979680,
                "title": "java-100-faster-simple-o-n-time-and-o-1-space-simple-and-only-few-lines",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) \\n{\\n\\tint maximum = 1;\\n\\tint currentMax = 1;\\n\\tfor(int i = 1; i < nums.length; i++)\\n\\t{\\n\\t\\tcurrentMax = nums[i] > nums[i - 1] ? currentMax + 1 : 1;   \\n\\t\\tmaximum = Math.max(maximum, currentMax);\\n\\t}\\n\\n\\treturn nums.length == 0 ? 0 : maximum;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) \\n{\\n\\tint maximum = 1;\\n\\tint currentMax = 1;\\n\\tfor(int i = 1; i < nums.length; i++)\\n\\t{\\n\\t\\tcurrentMax = nums[i] > nums[i - 1] ? currentMax + 1 : 1;   \\n\\t\\tmaximum = Math.max(maximum, currentMax);\\n\\t}\\n\\n\\treturn nums.length == 0 ? 0 : maximum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445685,
                "title": "two-python-solutions-using-dp-and-a-straightforward-soln",
                "content": "1. DP solution.\\n```class Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        dp=[1]*len(nums)\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                dp[i]+=dp[i-1]\\n        return max(dp)\\n ```\\n2\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        counter=1\\n        temp=1\\n        for i in range(0,len(nums)-1):\\n            if nums[i]<nums[i+1]:\\n                temp+=1\\n                if temp>counter:\\n                    counter=temp\\n            else:\\n                temp=1\\n        return counter",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        dp=[1]*len(nums)\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                dp[i]+=dp[i-1]\\n        return max(dp)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 541419,
                "title": "python-3-three-solutions-using-stack-and-sliding-window-and-dp",
                "content": "**Using Stack**\\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums)==1:\\n            return 1\\n        st = []\\n        max_len = float(\\'-inf\\')\\n        for i in range(len(nums)):\\n            if not st:\\n                st.append(nums[i])\\n            elif st and st[-1]<nums[i]:\\n                st.append(nums[i])\\n            elif st and st[-1]>=nums[i]:\\n                st = []\\n                st.append(nums[i])\\n            max_len = max(max_len,len(st))\\n        return max_len\\n```\\n\\n**Sliding Window**\\n```python \\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 1\\n        ans = 0 \\n        ind = 0\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                ind = i\\n            ans = max(ans,i-ind+1)\\n        return ans\\n```\\n\\n\\n**Dp Approach**\\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        dp = [1] * len(nums)\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums)==1:\\n            return 1\\n        st = []\\n        max_len = float(\\'-inf\\')\\n        for i in range(len(nums)):\\n            if not st:\\n                st.append(nums[i])\\n            elif st and st[-1]<nums[i]:\\n                st.append(nums[i])\\n            elif st and st[-1]>=nums[i]:\\n                st = []\\n                st.append(nums[i])\\n            max_len = max(max_len,len(st))\\n        return max_len\\n```\n```python \\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 1\\n        ans = 0 \\n        ind = 0\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                ind = i\\n            ans = max(ans,i-ind+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015293,
                "title": "python-easy-solution-without-sliding-window-o-n-54ms-beats-93-23-with-explanation",
                "content": "**Explanation**\\n1. Edge case if there is only one element in nums\\n2. add a counter and a max counter (in case the maximum is at beginning)\\n3. iterate through nums:\\n\\t4. if it\\'s the first element, continue (no previous, will evoke error)\\n\\t5. each time the element is greater than the previous one (increasing), add 1 to counter\\n\\t6. if not, check if the counter is the largest one yet (if it\\'s largest subarray yet)\\n\\t\\t7. if yes, update max counter\\n\\t\\t8. reset counter to 1\\n7. check if last counter is max (edge case)\\n8. return max counter\\n\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:\\n            return 1\\n        \\n        counter = 1\\n        max_counter = 0\\n        for i in range(len(nums)):\\n            if i == 0:\\n                continue\\n            else:  \\n                if nums[i] > nums[i-1]:\\n                    counter += 1\\n                else:\\n                    if counter > max_counter:\\n                        max_counter = counter\\n                    counter = 1\\n        if counter > max_counter:\\n            max_counter = counter\\n        \\n        return max_counter\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:\\n            return 1\\n        \\n        counter = 1\\n        max_counter = 0\\n        for i in range(len(nums)):\\n            if i == 0:\\n                continue\\n            else:  \\n                if nums[i] > nums[i-1]:\\n                    counter += 1\\n                else:\\n                    if counter > max_counter:\\n                        max_counter = counter\\n                    counter = 1\\n        if counter > max_counter:\\n            max_counter = counter\\n        \\n        return max_counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670447,
                "title": "javascript-clean-2-sliding-window-approaches",
                "content": "## Solution 1\\n\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    let len = 1, maxLen = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1]) len++;\\n        else len = 1;\\n        maxLen = Math.max(len, maxLen);\\n    }\\n    return maxLen;  \\n};\\n```\\n\\n## Solution 2\\n\\n```javascript\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length < 2) return nums.length;\\n    let left = 0, right = 1, maxLen = 0;\\n    \\n    while(right < nums.length) {\\n        if(nums[right-1] >= nums[right]) left = right;\\n        right++;\\n        maxLen = Math.max(right - left, maxLen);\\n    }\\n    return maxLen    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar findLengthOfLCIS = function(nums) {\\n    let len = 1, maxLen = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1]) len++;\\n        else len = 1;\\n        maxLen = Math.max(len, maxLen);\\n    }\\n    return maxLen;  \\n};\\n```\n```javascript\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length < 2) return nums.length;\\n    let left = 0, right = 1, maxLen = 0;\\n    \\n    while(right < nums.length) {\\n        if(nums[right-1] >= nums[right]) left = right;\\n        right++;\\n        maxLen = Math.max(right - left, maxLen);\\n    }\\n    return maxLen    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3118835,
                "title": "simple-java-solution-using-2-pointer-approach-time-beats-100-of-the-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are to find the longest continuous increasing subsequence(LCIS), for that, what I thought was that, if we are checking the length from an element at any index, and if we reach a point that now our subsequence is not increasing, then we need not to check the length of longest cont. inc. subsequence.\\n\\nFor eg:\\n[1,3,5,4,***2,3,4,5***]\\n\\nhere 2,3,4,5 is our LCIS, what I mean to say in above paragraph was, when we check the LCIS from element at index 0, it ends at element at index 2, now we need not to look for LCIS from element at index 1 and 2, as there length will always be lesser than that of element at index 0.\\n\\nI checked the length of each such part of array and returned the maximum one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use 2 pointers to solve this problem, we will keep the track of previous element and j will keep track of current element. \\n\\nWe will compare nums[i] and nums[j] if nums[j]>nums[i], then currentCount(variable to store the length of current LCIS) will be incremented. \\n\\nIf nums[j]>nums[i] is false, means this was the end of current LCIS and we now need to check the next LCIS means, we will now chance i to j, increament j and make currentCount to 1.\\n\\nIn every iteration we are also updating maxCount if currentCount gets greater than it. \\n\\nAt last we are returning the maxCount.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n            \\n        }  \\n        return maxCount;  \\n    }\\n}\\n```\\n\\n\\n****Do Upvote if found useful.**** \\u2B06\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n            \\n        }  \\n        return maxCount;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317161,
                "title": "674-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We handle the base cases where the input list is empty or has only one element. In both cases, the length of the longest continuous in1.creasing subsequence is the length of the input list itself, so we simply return that length.\\n\\n2. We initialize two variables cur_len and max_len to keep track of the length of the current increasing subsequence and the maximum length seen so far, respectively. We set both variables to 1 because the first element of the input list is always part of a subsequence of length 1.\\n\\n3. We iterate through the input list starting from the second element. For each element, we check if it is greater than the previous element. If it is, then it is part of the current increasing subsequence, so we increase the length of the subsequence by 1 (cur_len += 1). We also update the maximum length seen so far (max_len = max(max_len, cur_len)) if necessary. If the current element is not greater than the previous element, then it is the start of a new increasing subsequence, so we reset the length of the subsequence to 1 (cur_len = 1).\\n\\n4. After iterating through the entire input list, we return the maximum length of any increasing subsequence seen (return max_len).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        # Base case: empty list or single element list\\n        if len(nums) == 0 or len(nums) == 1:\\n            return len(nums)\\n        \\n        # Initialize variables to keep track of current length and max length\\n        cur_len = 1  # current length of increasing subsequence\\n        max_len = 1  # maximum length of increasing subsequence\\n        \\n        # Iterate through the list starting from the second element\\n        for i in range(1, len(nums)):\\n            # If the current element is greater than the previous element, it is part of the increasing subsequence\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1  # increase the length of the subsequence\\n                max_len = max(max_len, cur_len)  # update the maximum length if necessary\\n            else:\\n                cur_len = 1  # reset the length of the subsequence if the current element is not greater than the previous element\\n        \\n        return max_len\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        # Base case: empty list or single element list\\n        if len(nums) == 0 or len(nums) == 1:\\n            return len(nums)\\n        \\n        # Initialize variables to keep track of current length and max length\\n        cur_len = 1  # current length of increasing subsequence\\n        max_len = 1  # maximum length of increasing subsequence\\n        \\n        # Iterate through the list starting from the second element\\n        for i in range(1, len(nums)):\\n            # If the current element is greater than the previous element, it is part of the increasing subsequence\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1  # increase the length of the subsequence\\n                max_len = max(max_len, cur_len)  # update the maximum length if necessary\\n            else:\\n                cur_len = 1  # reset the length of the subsequence if the current element is not greater than the previous element\\n        \\n        return max_len\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197563,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxi=1;\\n        int c=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=1;\\n            }\\n            if(maxi<c){\\n                maxi=c;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxi=1;\\n        int c=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=1;\\n            }\\n            if(maxi<c){\\n                maxi=c;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488316,
                "title": "js-faster-than-100-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/2abfa80c-dc20-4da7-8002-ca5d2ad5a50f_1661569790.2926805.png)\\n\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    let output = 0;\\n    let count = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!count || nums[i] > nums[i - 1]) {\\n            count++;\\n        } else {\\n            output = Math.max(output, count);\\n            count = 1;\\n        }\\n    }\\n    \\n    return Math.max(output, count);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLengthOfLCIS = function(nums) {\\n    let output = 0;\\n    let count = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!count || nums[i] > nums[i - 1]) {\\n            count++;\\n        } else {\\n            output = Math.max(output, count);\\n            count = 1;\\n        }\\n    }\\n    \\n    return Math.max(output, count);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 752266,
                "title": "python-o-n-greedy",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n        max_length = 0\\n        cur_length = 0\\n        cur_max = float(\\'-inf\\')\\n        for num in nums:\\n            if num > cur_max:\\n                cur_length += 1\\n                cur_max = num\\n            else:\\n                max_length = max(max_length, cur_length)\\n                cur_length = 1\\n                cur_max = num\\n        return max(max_length, cur_length)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n        max_length = 0\\n        cur_length = 0\\n        cur_max = float(\\'-inf\\')\\n        for num in nums:\\n            if num > cur_max:\\n                cur_length += 1\\n                cur_max = num\\n            else:\\n                max_length = max(max_length, cur_length)\\n                cur_length = 1\\n                cur_max = num\\n        return max(max_length, cur_length)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 715456,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let max = 0;\\n  let curr = 0;\\n  let prev = -Infinity;\\n  for (let n of nums){\\n    if(n > prev){\\n      max = Math.max(max, ++curr)      \\n    }else{\\n      curr = 1;\\n    }\\n    prev = n\\n  }\\n  return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let max = 0;\\n  let curr = 0;\\n  let prev = -Infinity;\\n  for (let n of nums){\\n    if(n > prev){\\n      max = Math.max(max, ++curr)      \\n    }else{\\n      curr = 1;\\n    }\\n    prev = n\\n  }\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432416,
                "title": "straight-forward-and-fast-python",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 2:\\n            return len(nums)\\n        tmp, max_l = 1, 0\\n        for i in range(len(nums) - 1):         \\n            if nums[i] < nums[i + 1]:\\n                tmp += 1\\n            else:\\n                max_l = max(max_l, tmp)\\n                tmp = 1\\n        return max(max_l, tmp)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 2:\\n            return len(nums)\\n        tmp, max_l = 1, 0\\n        for i in range(len(nums) - 1):         \\n            if nums[i] < nums[i + 1]:\\n                tmp += 1\\n            else:\\n                max_l = max(max_l, tmp)\\n                tmp = 1\\n        return max(max_l, tmp)",
                "codeTag": "Java"
            },
            {
                "id": 3521788,
                "title": "o-n-longest-continuous-increasing-subsequence-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i, len=1, maxlen=1;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                len++;\\n            }\\n            else if(len>maxlen)\\n            {\\n                maxlen = len;\\n                len=1;\\n            }\\n            else\\n            {\\n                len=1;\\n            }\\n        }\\n        if(len>maxlen)\\n            maxlen = len;\\n        return maxlen;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/db35f119-6d56-413c-aeac-389431744144_1684034399.839135.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i, len=1, maxlen=1;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                len++;\\n            }\\n            else if(len>maxlen)\\n            {\\n                maxlen = len;\\n                len=1;\\n            }\\n            else\\n            {\\n                len=1;\\n            }\\n        }\\n        if(len>maxlen)\\n            maxlen = len;\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426987,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxlength = 1;\\n        int length = 1;\\n        int n = nums.size();\\n        for(int i= 1; i<n;i++){\\n            if (nums[i-1]<nums[i]){\\n                length++;\\n            }\\n            else{\\n                if(maxlength<length){\\n                    maxlength = length;\\n                }\\n                length = 1;\\n            }\\n        }\\n        return max(length, maxlength);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        l, r, curMax = 0, 1, 1\\n        while r < len(nums):\\n            if nums[r] > nums[r-1]:\\n                curMax = max(curMax, r-l+1)\\n            else:\\n                l = r\\n            r += 1\\n        return curMax\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n        }  \\n        return maxCount;  \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxlength = 1;\\n        int length = 1;\\n        int n = nums.size();\\n        for(int i= 1; i<n;i++){\\n            if (nums[i-1]<nums[i]){\\n                length++;\\n            }\\n            else{\\n                if(maxlength<length){\\n                    maxlength = length;\\n                }\\n                length = 1;\\n            }\\n        }\\n        return max(length, maxlength);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        l, r, curMax = 0, 1, 1\\n        while r < len(nums):\\n            if nums[r] > nums[r-1]:\\n                curMax = max(curMax, r-l+1)\\n            else:\\n                l = r\\n            r += 1\\n        return curMax\\n```\n```Java []\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n        }  \\n        return maxCount;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160913,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                ans=max(ans,c);\\n                c=1;\\n            }\\n        }\\n        ans=max(ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                ans=max(ans,c);\\n                c=1;\\n            }\\n        }\\n        ans=max(ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454483,
                "title": "o-n-with-go",
                "content": "```\\nfunc findLengthOfLCIS(nums []int) int {\\n    res, current := 1, 1\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            current++            \\n        } else {\\n            if current > res {\\n                res = current\\n            }\\n            \\n            current = 1\\n        }\\n    }\\n    \\n    if current > res {\\n        res = current\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findLengthOfLCIS(nums []int) int {\\n    res, current := 1, 1\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            current++            \\n        } else {\\n            if current > res {\\n                res = current\\n            }\\n            \\n            current = 1\\n        }\\n    }\\n    \\n    if current > res {\\n        res = current\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402115,
                "title": "easy-java-solution-1ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i = 1 ; i < nums.length; i++) {\\n            if (nums[i - 1] < nums[i]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (max < count) {\\n                max = count;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i = 1 ; i < nums.length; i++) {\\n            if (nums[i - 1] < nums[i]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (max < count) {\\n                max = count;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053719,
                "title": "o-n-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        maxLen = count = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                count = 1\\n                \\n            maxLen = max(count, maxLen)\\n                \\n        return maxLen\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        maxLen = count = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                count = 1\\n                \\n            maxLen = max(count, maxLen)\\n                \\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957587,
                "title": "simple-and-easy-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int findLengthOfLCIS(vector<int> &nums)\\n    {\\n        int mn = INT_MIN, cnt = 0, mx = 0;\\n        for (auto it : nums)\\n        {\\n            if (it > mn)\\n            {\\n                mn = it;\\n                cnt++;\\n            }\\n            else\\n            {\\n                mx = max(cnt, mx);\\n                mn = it;\\n                cnt = 1;\\n            }\\n        }\\n        mx = max(cnt, mx);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findLengthOfLCIS(vector<int> &nums)\\n    {\\n        int mn = INT_MIN, cnt = 0, mx = 0;\\n        for (auto it : nums)\\n        {\\n            if (it > mn)\\n            {\\n                mn = it;\\n                cnt++;\\n            }\\n            else\\n            {\\n                mx = max(cnt, mx);\\n                mn = it;\\n                cnt = 1;\\n            }\\n        }\\n        mx = max(cnt, mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881861,
                "title": "longest-continuous-increasing-subsequence-solution-java",
                "content": "class Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int ans = 0;\\n\\n    for (int l = 0, r = 0; r < nums.length; ++r) {\\n      if (r > 0 && nums[r] <= nums[r - 1])\\n        l = r;\\n      ans = Math.max(ans, r - l + 1);\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int ans = 0;\\n\\n    for (int l = 0, r = 0; r < nums.length; ++r) {\\n      if (r > 0 && nums[r] <= nums[r - 1])\\n        l = r;\\n      ans = Math.max(ans, r - l + 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1626383,
                "title": "python-single-pass-simplest-self-explanatory-code",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        lcis, cis = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cis += 1\\n            else:\\n                cis = 1\\n            lcis = max(lcis, cis)\\n        return lcis\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        lcis, cis = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cis += 1\\n            else:\\n                cis = 1\\n            lcis = max(lcis, cis)\\n        return lcis\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526297,
                "title": "c-4ms-simple-solution",
                "content": "class Solution {\\npublic:\\n\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int ct = 1, count=0;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count = max(count,ct);\\n                ct=1;\\n            }\\n            else ct++;\\n        }\\n        count = max(count,ct);\\n        return count;\\n    }\\n};\\n\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int ct = 1, count=0;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count = max(count,ct);\\n                ct=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1401477,
                "title": "easy-java-solution",
                "content": "class Solution {\\n\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1, count = 1;\\n        \\n        for(int i = 1; i<nums.length; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                count++;\\n                max = Math.max(max, count);\\n            }\\n            else\\n                count = 1;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1, count = 1;\\n        \\n        for(int i = 1; i<nums.length; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                count++;\\n                max = Math.max(max, count);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1125400,
                "title": "js-easy-to-understand-for-beginners-as-well-2-solutions",
                "content": "```\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1,\\n    max = 0;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] > nums[i - 1]) {\\n      count++;\\n      max = Math.max(max, count);\\n    } else {\\n      count = 1;\\n    }\\n  }\\n  return nums.length >= 1 ? (max > 0 ? max : count) : 0;\\n};\\n\\n```\\n\\nSecond solution:\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length==0) return 0\\n    let count=1,max=1;\\n    for(let i=0;i<nums.length-1;i++){\\n        if(nums[i]<nums[i+1]){\\n            count++;\\n            max=Math.max(count,max);\\n        }else{\\n            count=1;\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\nIgnore the below solution(this is for the guy who asked another ques in the comment)\\n```\\nconst longestIncreaseWithInBoundary = (arr, indices) => {\\n  // converting 2D array to 1D\\n  // [[0, 5],[1, 5],[2, 5],[2, 2]] will be [0, 5, 1, 5, 2, 5, 2, 2]\\n  const flatIndices = indices.flat();\\n\\n  const findLongest = (sliced) => {\\n    // this is the old method which is used in this question\\n    let count = 1,\\n      max = 0;\\n    for (let i = 1; i < sliced.length; i++) {\\n      if (sliced[i] > sliced[i - 1]) {\\n        count++;\\n        max = Math.max(count, max);\\n      } else {\\n        count = 1;\\n      }\\n    }\\n    return max > 0 ? max : count;\\n  };\\n\\n let res = [],\\n    map = new Map();\\n  // iterating the 1D(which we converted...we converted because we can avoid inner for loop)\\n  for (let i = 0; i < flatIndices.length; i += 2) {\\n    // this takes a part of given nums\\n    // for example, part of [2,1,3,5,4,7] with  boundary [2,5] is [3,5,4,7]\\n    const slicedArr = arr.slice(flatIndices[i], flatIndices[i + 1] + 1);\\n    // if that value is already stored we can take from that map(no need to pass to the helper func)\\n    if (map.has(flatIndices[i] + \"\" + flatIndices[i + 1])) {\\n      res.push(map.get(flatIndices[i] + \"\" + flatIndices[i + 1]));\\n    } else {\\n      // passing that sliceArr into the helper function(name whatever u want)\\n      const length = findLongest(slicedArr);\\n      // storing that returned value in the map\\n      map.set(flatIndices[i] + \"\" + flatIndices[i + 1], length);\\n      // pushing the returned max subarray value\\n      res.push(length);\\n    }\\n  }\\n  // returning the array which holds the max subarray correspondingly.\\n  // [3,3,2,1]\\n  return res;\\n};\\nconsole.log(\\n  longestIncreaseWithInBoundary(\\n    [2, 1, 3, 5, 4, 7],\\n    [\\n      [0, 5],\\n      [1, 5],\\n      [2, 5],\\n      [2, 2],\\n    ]\\n  )\\n);\\n```\\nBut still Im not giving you assurance that this will work if large number of data is passed.Try it and let me know.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1,\\n    max = 0;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] > nums[i - 1]) {\\n      count++;\\n      max = Math.max(max, count);\\n    } else {\\n      count = 1;\\n    }\\n  }\\n  return nums.length >= 1 ? (max > 0 ? max : count) : 0;\\n};\\n\\n```\n```\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length==0) return 0\\n    let count=1,max=1;\\n    for(let i=0;i<nums.length-1;i++){\\n        if(nums[i]<nums[i+1]){\\n            count++;\\n            max=Math.max(count,max);\\n        }else{\\n            count=1;\\n        }\\n    }\\n    return max;\\n};\\n```\n```\\nconst longestIncreaseWithInBoundary = (arr, indices) => {\\n  // converting 2D array to 1D\\n  // [[0, 5],[1, 5],[2, 5],[2, 2]] will be [0, 5, 1, 5, 2, 5, 2, 2]\\n  const flatIndices = indices.flat();\\n\\n  const findLongest = (sliced) => {\\n    // this is the old method which is used in this question\\n    let count = 1,\\n      max = 0;\\n    for (let i = 1; i < sliced.length; i++) {\\n      if (sliced[i] > sliced[i - 1]) {\\n        count++;\\n        max = Math.max(count, max);\\n      } else {\\n        count = 1;\\n      }\\n    }\\n    return max > 0 ? max : count;\\n  };\\n\\n let res = [],\\n    map = new Map();\\n  // iterating the 1D(which we converted...we converted because we can avoid inner for loop)\\n  for (let i = 0; i < flatIndices.length; i += 2) {\\n    // this takes a part of given nums\\n    // for example, part of [2,1,3,5,4,7] with  boundary [2,5] is [3,5,4,7]\\n    const slicedArr = arr.slice(flatIndices[i], flatIndices[i + 1] + 1);\\n    // if that value is already stored we can take from that map(no need to pass to the helper func)\\n    if (map.has(flatIndices[i] + \"\" + flatIndices[i + 1])) {\\n      res.push(map.get(flatIndices[i] + \"\" + flatIndices[i + 1]));\\n    } else {\\n      // passing that sliceArr into the helper function(name whatever u want)\\n      const length = findLongest(slicedArr);\\n      // storing that returned value in the map\\n      map.set(flatIndices[i] + \"\" + flatIndices[i + 1], length);\\n      // pushing the returned max subarray value\\n      res.push(length);\\n    }\\n  }\\n  // returning the array which holds the max subarray correspondingly.\\n  // [3,3,2,1]\\n  return res;\\n};\\nconsole.log(\\n  longestIncreaseWithInBoundary(\\n    [2, 1, 3, 5, 4, 7],\\n    [\\n      [0, 5],\\n      [1, 5],\\n      [2, 5],\\n      [2, 2],\\n    ]\\n  )\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765674,
                "title": "c-greed-is-best-easy-to-understand",
                "content": "***Runtime: 24 ms, faster than 54.02% of C++ online submissions for Longest Continuous Increasing Subsequence.\\nMemory Usage: 11 MB, less than 94.51% of C++ online submissions for Longest Continuous Increasing Subsequence.***\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)    \\n            return 0;\\n        int result = 1;\\n        int current = 1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > nums[i-1]){\\n                current++;\\n            }else{\\n                current = 1;\\n            }\\n            result = max(result, current);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)    \\n            return 0;\\n        int result = 1;\\n        int current = 1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > nums[i-1]){\\n                current++;\\n            }else{\\n                current = 1;\\n            }\\n            result = max(result, current);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463513,
                "title": "simple-java-beats-100",
                "content": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums==null || nums.length ==0)\\n            return 0;\\n        int count = 1;\\n        int max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n            }else{\\n                max = Math.max(max,count);\\n                count=1;\\n            }\\n        }\\n        \\n        return Math.max(max,count); // if the complete sequence is monotonically increasing",
                "solutionTags": [],
                "code": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums==null || nums.length ==0)\\n            return 0;\\n        int count = 1;\\n        int max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n            }else{\\n                max = Math.max(max,count);\\n                count=1;\\n            }\\n        }\\n        \\n        return Math.max(max,count); // if the complete sequence is monotonically increasing",
                "codeTag": "Unknown"
            },
            {
                "id": 328133,
                "title": "divide-and-conquer-recursive-solution-accepted",
                "content": "Below is a classic divide-and-conquer approach to solve this problem using recursion in C#. Although a little complex than the linear solution presented in Solution tab, its intuitive and a common approach for \"longest subsequence\" kind of problems.\\n\\n```\\npublic class Solution {\\n    int FindLCIS_Iter(int[] a, int start, int end) {\\n        if (start == end) {\\n            return 1;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        int leftLcis = FindLCIS_Iter(a, start, mid);\\n        int rightLcis = FindLCIS_Iter(a, mid + 1, end);\\n\\t\\t\\n        int currentLcis = FindLCIS(a, start, end, mid);\\n        List<int> lcisList = new List<int>() { leftLcis, rightLcis, currentLcis };\\n        lcisList.Sort();\\n        return lcisList[lcisList.Count - 1];\\n    }\\n    \\n    int FindLCIS(int[] a, int start, int end, int mid) {\\n        int i = mid, j = mid;\\n        while (i > start && a[i] > a[i - 1]) i -= 1;\\n        while (j < end && a[j] < a[j + 1]) j += 1;\\n        return j - i + 1;\\n    }\\n    \\n    public int FindLengthOfLCIS(int[] nums) {\\n        if (nums.Length < 2) return nums.Length;\\n        return FindLCIS_Iter(nums, 0, nums.Length - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int FindLCIS_Iter(int[] a, int start, int end) {\\n        if (start == end) {\\n            return 1;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        int leftLcis = FindLCIS_Iter(a, start, mid);\\n        int rightLcis = FindLCIS_Iter(a, mid + 1, end);\\n\\t\\t\\n        int currentLcis = FindLCIS(a, start, end, mid);\\n        List<int> lcisList = new List<int>() { leftLcis, rightLcis, currentLcis };\\n        lcisList.Sort();\\n        return lcisList[lcisList.Count - 1];\\n    }\\n    \\n    int FindLCIS(int[] a, int start, int end, int mid) {\\n        int i = mid, j = mid;\\n        while (i > start && a[i] > a[i - 1]) i -= 1;\\n        while (j < end && a[j] < a[j + 1]) j += 1;\\n        return j - i + 1;\\n    }\\n    \\n    public int FindLengthOfLCIS(int[] nums) {\\n        if (nums.Length < 2) return nums.Length;\\n        return FindLCIS_Iter(nums, 0, nums.Length - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304294,
                "title": "python-easy-solution",
                "content": "\\n\\n        max_res = 0\\n        count = 0\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                count += 1\\n                max_res = max(max_res, count)\\n            else:\\n                count = 1\\n        return max_res",
                "solutionTags": [],
                "code": "\\n\\n        max_res = 0\\n        count = 0\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                count += 1\\n                max_res = max(max_res, count)\\n            else:\\n                count = 1\\n        return max_res",
                "codeTag": "Unknown"
            },
            {
                "id": 125498,
                "title": "dp-is-powerfull",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n        for(int i = 1;i < nums.length;++i) {\\n            if(nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            } else {\\n                dp[i] = 1;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < nums.length;++i) {\\n            if(dp[i] > max) {\\n                max = dp[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n        for(int i = 1;i < nums.length;++i) {\\n            if(nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            } else {\\n                dp[i] = 1;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < nums.length;++i) {\\n            if(dp[i] > max) {\\n                max = dp[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107366,
                "title": "python",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        ans, pre = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                ans = max(ans, i - pre)\\n            else:\\n                pre = 1\\n            ans = max(ans, pre)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        ans, pre = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                ans = max(ans, i - pre)\\n            else:\\n                pre = 1\\n            ans = max(ans, pre)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003991,
                "title": "beginners-python-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 1\\n        curr_len = 1\\n        for i in range(1,n):\\n            if nums[i] > nums[i-1]:\\n                curr_len = curr_len + 1\\n                ans = max(ans,curr_len)\\n            else:\\n                curr_len = 1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 1\\n        curr_len = 1\\n        for i in range(1,n):\\n            if nums[i] > nums[i-1]:\\n                curr_len = curr_len + 1\\n                ans = max(ans,curr_len)\\n            else:\\n                curr_len = 1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898082,
                "title": "starting-and-ending-indexes-of-longest-continuous-increasing-subsequence",
                "content": "# Intuition\\nAs soon as I read the problem statement, I thought of storing the starting and ending indexes of the  increasing longest continuous.subsequence.\\n\\n# Approach\\nThe starting and ending indexes are found and the length of the maximum subsequence is updated.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n= nums.size();\\n        int start=0, end=0, ans=1;\\n        for (int i=1; i<n;i++){\\n            if (nums[i]> nums[end]){\\n            end=i;\\n            ans=max(ans, end-start+1);\\n            }\\n            else {\\n                start=i, end=i;\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n= nums.size();\\n        int start=0, end=0, ans=1;\\n        for (int i=1; i<n;i++){\\n            if (nums[i]> nums[end]){\\n            end=i;\\n            ans=max(ans, end-start+1);\\n            }\\n            else {\\n                start=i, end=i;\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840679,
                "title": "c-easy-solution-lis-slight-modification",
                "content": "Just the ***Longest Increasing Subsequence Code+ Slight modification.***\\nWe need ***continuous LIS*** which means difference between adjacent index should be 1. That\\'s it \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int prev_ind=ind-1;prev_ind>=-1;prev_ind--){\\n                int len=dp[ind+1][prev_ind+1];\\n                if(prev_ind==-1 || nums[ind]>nums[prev_ind]) {\\n                    if(ind-prev==1)   // Here we add the condition, rest code is same as of LIS\\n                    len= max(len,1+dp[ind+1][ind+1]);\\n                }\\n                dp[ind][prev_ind+1]=len;\\n            }\\n        }\\n                \\n        return dp[0][0];\\n    }\\n};\\n```\\nThanks \\nNitin Manoj",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int prev_ind=ind-1;prev_ind>=-1;prev_ind--){\\n                int len=dp[ind+1][prev_ind+1];\\n                if(prev_ind==-1 || nums[ind]>nums[prev_ind]) {\\n                    if(ind-prev==1)   // Here we add the condition, rest code is same as of LIS\\n                    len= max(len,1+dp[ind+1][ind+1]);\\n                }\\n                dp[ind][prev_ind+1]=len;\\n            }\\n        }\\n                \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796383,
                "title": "python-short-1-liner-functional-programming",
                "content": "# Approach\\n1. For each adjacent `pairwise` numbers in `nums` check if $$nums_i < nums_{i + 1}$$ to form a boolean array. (Useful to see bools as 1 and 0).\\n`lt_bools = starmap(lt, pairwise(nums))`\\n\\n2. Calculate `running_sums` on the array of bools and reset every time a `0` is found.\\n`run_sums = accumulate(lt_bools, lambda a, x: a * x + 1, initial=1)`\\n\\n3. Return the `max(run_sums) + 1`\\n\\nExample:\\n```python\\nnums     = [1, 3, 5, 4, 7, 2, 4, 5, 7, 9]\\nlt_bools =   [1, 1, 0, 1, 0, 1, 1, 1, 1]\\nrun_sums = [1, 2, 3, 1, 2, 1, 2, 3, 4, 5] # Extra 1 added at the beginning\\nlcis_len = 5\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: list[int]) -> int:\\n        return max(accumulate(starmap(lt, pairwise(nums)), lambda a, x: a * x + 1, initial=1))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```python\\nnums     = [1, 3, 5, 4, 7, 2, 4, 5, 7, 9]\\nlt_bools =   [1, 1, 0, 1, 0, 1, 1, 1, 1]\\nrun_sums = [1, 2, 3, 1, 2, 1, 2, 3, 4, 5] # Extra 1 added at the beginning\\nlcis_len = 5\\n```\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: list[int]) -> int:\\n        return max(accumulate(starmap(lt, pairwise(nums)), lambda a, x: a * x + 1, initial=1))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519879,
                "title": "very-easy-and-simple-solution-in-javascript-wow-just-watch-it",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let max = 0, curr = 0\\n    for(let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] < nums[i + 1]) {\\n            curr++\\n            max = Math.max(max, curr)\\n        } else {\\n            curr = 0\\n        }\\n    }\\n    return max > 0 ? max + 1 : 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let max = 0, curr = 0\\n    for(let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] < nums[i + 1]) {\\n            curr++\\n            max = Math.max(max, curr)\\n        } else {\\n            curr = 0\\n        }\\n    }\\n    return max > 0 ? max + 1 : 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416848,
                "title": "c-solution-87-72-time-94-70-space-update-max-length-on-the-fly",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums);\\n};\\n/*********************************************************/\\nint Solution::findLengthOfLCIS(vector<int>& nums) {\\n    int maxLength=1, length=1, i, size = nums.size();\\n    for (i = 1; i < size; ++i) {\\n        if (nums[i-1] < nums[i]) {\\n            ++length;\\n            if (length > maxLength) {\\n                maxLength = length;\\n            }\\n        } else {\\n            length = 1;\\n        }\\n    }\\n    return maxLength;\\n}\\n/*********************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums);\\n};\\n/*********************************************************/\\nint Solution::findLengthOfLCIS(vector<int>& nums) {\\n    int maxLength=1, length=1, i, size = nums.size();\\n    for (i = 1; i < size; ++i) {\\n        if (nums[i-1] < nums[i]) {\\n            ++length;\\n            if (length > maxLength) {\\n                maxLength = length;\\n            }\\n        } else {\\n            length = 1;\\n        }\\n    }\\n    return maxLength;\\n}\\n/*********************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349814,
                "title": "javascript-easy-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    increasing the counter by comparing elements in an array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncompare two elements nums[i] and nums[i-1], if i is greater we include it, so count++, if not we reset counter to 1 and count again for any better LCIS in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1;\\n  let max = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i - 1] < nums[i]) {\\n      count++;\\n    } else {\\n      count = 1;\\n    }\\n    max = Math.max(max, count);\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1;\\n  let max = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i - 1] < nums[i]) {\\n      count++;\\n    } else {\\n      count = 1;\\n    }\\n    max = Math.max(max, count);\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089340,
                "title": "2-dp-approach-c-beats-95-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# 1st APPROACH: \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10001];\\n    int solve(vector<int>& nums, int i, int n){\\n        if(i==n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int k=i;\\n        while(k<n-1 && nums[k]<nums[k+1]){\\n            k++;\\n        }\\n        int cnt1=k-i+1;\\n        int cnt2=solve(nums, k+1, n);\\n        \\n        return dp[i]=max(cnt1, cnt2);\\n    }\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(nums, 0, nums.size());\\n    }\\n};\\n```\\n# 2nd APPROACH: (TLE)\\n# Code\\n```\\nclass Solution {\\n    int solveTab(vector<int>& nums, int n){  \\n         vector<vector<int>> dp(n+1, vector<int> (n+1, 0));  \\n        int ans=0;\\n        for(int curr=n-1; curr>=0; curr--){\\n            for(int prev=curr-1; prev>=-1; prev--){\\n               if(prev==-1 || (nums[curr] > nums[prev]))\\n                    dp[curr][prev+1]=1+dp[curr+1][curr+1];\\n               \\n                ans=max(ans, dp[curr][prev+1]);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n  \\n    int findLengthOfLCIS(vector<int>& nums) {\\n        return solveTab(nums,nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001];\\n    int solve(vector<int>& nums, int i, int n){\\n        if(i==n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int k=i;\\n        while(k<n-1 && nums[k]<nums[k+1]){\\n            k++;\\n        }\\n        int cnt1=k-i+1;\\n        int cnt2=solve(nums, k+1, n);\\n        \\n        return dp[i]=max(cnt1, cnt2);\\n    }\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(nums, 0, nums.size());\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int solveTab(vector<int>& nums, int n){  \\n         vector<vector<int>> dp(n+1, vector<int> (n+1, 0));  \\n        int ans=0;\\n        for(int curr=n-1; curr>=0; curr--){\\n            for(int prev=curr-1; prev>=-1; prev--){\\n               if(prev==-1 || (nums[curr] > nums[prev]))\\n                    dp[curr][prev+1]=1+dp[curr+1][curr+1];\\n               \\n                ans=max(ans, dp[curr][prev+1]);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n  \\n    int findLengthOfLCIS(vector<int>& nums) {\\n        return solveTab(nums,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863469,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763468,
                "title": "two-simple-python-solutions",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        prev, cur, res = 0, 0, 0\\n        \\n        for n in nums:\\n            cur = cur + 1 if prev < n else 1\\n            res = max(res, cur)\\n            prev = n\\n\\n        return res\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\\n\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        \\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i-1] + dp[i]\\n        \\n        return max(dp)\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        prev, cur, res = 0, 0, 0\\n        \\n        for n in nums:\\n            cur = cur + 1 if prev < n else 1\\n            res = max(res, cur)\\n            prev = n\\n\\n        return res\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        \\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i-1] + dp[i]\\n        \\n        return max(dp)\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570263,
                "title": "rust-0-ms-linear-scan-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/798332889/) employs a simple loop to count the number of characters in the longest continuous increasing subsequence. It demonstrated **0 ms runtime (100.00%)** and used **2.0 MB memory (100.00%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 \\n    {\\n        let mut max_len : i32 = 0;\\n        let mut cur_len : i32 = 0;\\n        let mut prev    : i32 = -1_000_000_001;\\n        \\n        // [1] we keep track of current length \\'cur_len\\' of subsequence\\n\\t\\t//     and update \\'max_len\\' every time the continuous sequence is broken\\n        for n in nums\\n        {\\n            if n > prev { cur_len += 1; }\\n            else        { max_len = max_len.max(cur_len); cur_len = 1; }\\n            prev = n;\\n        }\\n        \\n        // [2] update \\'max_len\\' for the last continuous sequence\\n        max_len.max(cur_len)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 \\n    {\\n        let mut max_len : i32 = 0;\\n        let mut cur_len : i32 = 0;\\n        let mut prev    : i32 = -1_000_000_001;\\n        \\n        // [1] we keep track of current length \\'cur_len\\' of subsequence\\n\\t\\t//     and update \\'max_len\\' every time the continuous sequence is broken\\n        for n in nums\\n        {\\n            if n > prev { cur_len += 1; }\\n            else        { max_len = max_len.max(cur_len); cur_len = 1; }\\n            prev = n;\\n        }\\n        \\n        // [2] update \\'max_len\\' for the last continuous sequence\\n        max_len.max(cur_len)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2565636,
                "title": "clean-0ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max =0;\\n        int count =0;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =0;\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max =0;\\n        int count =0;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =0;\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545784,
                "title": "easy-to-understand",
                "content": "```\\n    int findLengthOfLCIS(vector<int>& nums) \\n    {\\n        int mx=0;\\n        int n=nums.size();\\n        int count=1;\\n        int i=0,j=1;\\n        if(n==1) return 1;\\n        \\n        while(j<n)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n                mx=max(mx,count);\\n            }\\n            else\\n            {\\n                mx=max(mx,count);\\n                count=1;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int findLengthOfLCIS(vector<int>& nums) \\n    {\\n        int mx=0;\\n        int n=nums.size();\\n        int count=1;\\n        int i=0,j=1;\\n        if(n==1) return 1;\\n        \\n        while(j<n)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n                mx=max(mx,count);\\n            }\\n            else\\n            {\\n                mx=max(mx,count);\\n                count=1;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526918,
                "title": "c-2-ways-brute-force-vs-optimal",
                "content": "```\\n/*\\n\\tBrute Force\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint i = 0;\\n\\twhile(i < nums.size()) {\\n\\t\\tint m = 1;\\n\\t\\tfor (int j = i + 1; j < nums.size(); ++j) {\\n\\t\\t\\tif (nums[j] > nums[j - 1]) {\\n\\t\\t\\t\\tm++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans = max(ans, m);\\n\\t\\ti += m;\\n\\t}\\n\\treturn ans;\\n}\\n\\n/*\\n\\tOptimal\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint count = 1;\\n\\tfor (int i = 1; i < nums.size(); ++i) {\\n\\t\\tif (nums[i] > nums[i - 1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n\\tBrute Force\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint i = 0;\\n\\twhile(i < nums.size()) {\\n\\t\\tint m = 1;\\n\\t\\tfor (int j = i + 1; j < nums.size(); ++j) {\\n\\t\\t\\tif (nums[j] > nums[j - 1]) {\\n\\t\\t\\t\\tm++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans = max(ans, m);\\n\\t\\ti += m;\\n\\t}\\n\\treturn ans;\\n}\\n\\n/*\\n\\tOptimal\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint count = 1;\\n\\tfor (int i = 1; i < nums.size(); ++i) {\\n\\t\\tif (nums[i] > nums[i - 1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2237415,
                "title": "fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int len=1,max=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n                len++;\\n            else\\n            {\\n                max=Math.max(len,max);\\n                len=1;\\n            }\\n        }\\n        return Math.max(max,len);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int len=1,max=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n                len++;\\n            else\\n            {\\n                max=Math.max(len,max);\\n                len=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2182572,
                "title": "java-1ms-easy-solution",
                "content": "\\t\\tint n=nums.length;\\n        int c=0;\\n        int maxx=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i+1]>nums[i]){\\n                c++;\\n                maxx=Math.max(maxx,c);\\n            }else{\\n                c=0;\\n            }\\n        }\\n        return maxx+1;\\n",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "\\t\\tint n=nums.length;\\n        int c=0;\\n        int maxx=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i+1]>nums[i]){\\n                c++;\\n                maxx=Math.max(maxx,c);\\n            }else{\\n                c=0;\\n            }\\n        }\\n        return maxx+1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2168019,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int curr=1, ans=1;\\n        for(int i=1; i<nums.size(); ++i){\\n            if(nums[i]>nums[i-1]) ++curr;\\n            else curr=1;\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int curr=1, ans=1;\\n        for(int i=1; i<nums.size(); ++i){\\n            if(nums[i]>nums[i-1]) ++curr;\\n            else curr=1;\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060291,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0;\\n        int temp=1;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]>nums[i])\\n                temp++;\\n            else\\n            {  \\n                ans=max(ans,temp);\\n                temp=1;\\n            }\\n        }\\n        ans=max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0;\\n        int temp=1;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]>nums[i])\\n                temp++;\\n            else\\n            {  \\n                ans=max(ans,temp);\\n                temp=1;\\n            }\\n        }\\n        ans=max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885033,
                "title": "very-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count =1;\\n        int maxi =1;\\n        \\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i+1] > nums[i]){\\n                count++;\\n                maxi = max(maxi, count); \\n            }\\n            else{\\n                count =1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n// Upvote please if you like it.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count =1;\\n        int maxi =1;\\n        \\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i+1] > nums[i]){\\n                count++;\\n                maxi = max(maxi, count); \\n            }\\n            else{\\n                count =1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n// Upvote please if you like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800682,
                "title": "6-lines-solution-python-dp-self-explanantory",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len( nums)\\n        d = [1 for i in range (n)]\\n        for i in range (1,n):\\n            if nums[i] > nums[i-1]:\\n                d[i] += d[i-1]\\n        return max(d) \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len( nums)\\n        d = [1 for i in range (n)]\\n        for i in range (1,n):\\n            if nums[i] > nums[i-1]:\\n                d[i] += d[i-1]\\n        return max(d) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793680,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         int ans = 1;\\n         int n = nums.size();\\n         if(n == 1) return 1;\\n        \\n         int i=0, j = 1;\\n         while( j < n ){\\n             if(nums[j] > nums[j-1]){\\n                 ans = max(ans, (j - i + 1));\\n                 j++;\\n             }\\n             else{\\n                 i = j;\\n                 j++;\\n             }\\n         }\\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         int ans = 1;\\n         int n = nums.size();\\n         if(n == 1) return 1;\\n        \\n         int i=0, j = 1;\\n         while( j < n ){\\n             if(nums[j] > nums[j-1]){\\n                 ans = max(ans, (j - i + 1));\\n                 j++;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1744859,
                "title": "o-n-time-and-o-1-space-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int result=0;\\n        int curr = nums[0];\\n        int count=1;\\n        if(nums.size()==1)\\n            return 1;\\n        if(nums.size()==0)\\n            return 0;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>curr)\\n                count+=1;\\n            else\\n                count=1;\\n            result = max(count,result);\\n            curr = nums[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int result=0;\\n        int curr = nums[0];\\n        int count=1;\\n        if(nums.size()==1)\\n            return 1;\\n        if(nums.size()==0)\\n            return 0;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>curr)\\n                count+=1;\\n            else\\n                count=1;\\n            result = max(count,result);\\n            curr = nums[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646129,
                "title": "rust-windows",
                "content": "```\\npub struct Solution {}\\n\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        let mut max = 0;\\n        let accum = nums\\n            .windows(2)\\n            .fold(1, |accum, w| {\\n                if w[0] < w[1] {\\n                    accum + 1\\n                } else {\\n                    if accum > max {\\n                        max = accum;\\n                    }\\n                    1\\n                }\\n            });\\n\\n        max.max(accum)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        assert_eq!(3, Solution::find_length_of_lcis(vec![1,3,5,4,7]));\\n        assert_eq!(1, Solution::find_length_of_lcis(vec![1]));\\n        assert_eq!(4, Solution::find_length_of_lcis(vec![4,3,1,2,3,4]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct Solution {}\\n\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        let mut max = 0;\\n        let accum = nums\\n            .windows(2)\\n            .fold(1, |accum, w| {\\n                if w[0] < w[1] {\\n                    accum + 1\\n                } else {\\n                    if accum > max {\\n                        max = accum;\\n                    }\\n                    1\\n                }\\n            });\\n\\n        max.max(accum)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        assert_eq!(3, Solution::find_length_of_lcis(vec![1,3,5,4,7]));\\n        assert_eq!(1, Solution::find_length_of_lcis(vec![1]));\\n        assert_eq!(4, Solution::find_length_of_lcis(vec![4,3,1,2,3,4]));\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597437,
                "title": "best-solution-c",
                "content": "class Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>cnt(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                cnt[i]=cnt[i-1]+1;\\n            }\\n            ans=max(ans,cnt[i]);\\n        }\\n        return ans;\\n    }\\n};\\n//PLEASE UPVOTE",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>cnt(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                cnt[i]=cnt[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1557653,
                "title": "c-98-89-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        \\n            int count = 0, i= 0, maxa=INT_MIN;\\n        \\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n               if(j == nums.size()-1)\\n               {\\n                   count = j-i+1;\\n               }\\n               else if(nums[j] >= nums[j+1])\\n               {\\n                   count = j - i + 1;\\n                   i = j+1;\\n               }\\n               maxa =max(maxa, count);\\n            }\\n        return maxa;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        \\n            int count = 0, i= 0, maxa=INT_MIN;\\n        \\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n               if(j == nums.size()-1)\\n               {\\n                   count = j-i+1;\\n               }\\n               else if(nums[j] >= nums[j+1])\\n               {\\n                   count = j - i + 1;\\n                   i = j+1;\\n               }\\n               maxa =max(maxa, count);\\n            }\\n        return maxa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540177,
                "title": "using-sliding-window-of-dynamic-size-easy-c-better-than-99-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i = 0;\\n        int ml = 1;\\n        int j = 1;\\n        for(j;j<nums.size();j++){\\n            if(nums[j]<=nums[j-1]){\\n                ml = max(ml,j-i);\\n                i= j;\\n            }\\n        }\\n        if(nums[j-1]>nums[i])\\n            ml = max(ml,j-i);\\n        return ml;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i = 0;\\n        int ml = 1;\\n        int j = 1;\\n        for(j;j<nums.size();j++){\\n            if(nums[j]<=nums[j-1]){\\n                ml = max(ml,j-i);\\n                i= j;\\n            }\\n        }\\n        if(nums[j-1]>nums[i])\\n            ml = max(ml,j-i);\\n        return ml;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477660,
                "title": "easy-java-solution-one-pass-on-time-o1-space",
                "content": "```\\nclass Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int res = 0, temp = 1;\\n\\n    for (int i = 1; i < nums.length; i++) {\\n      int curr = nums[i];\\n      int prev = nums[i-1];\\n\\n      if (prev < curr) {\\n        temp++;\\n      } else {\\n        res = Math.max(res, temp);\\n        temp = 1;\\n      }\\n    }\\n    return  Math.max(res, temp);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int res = 0, temp = 1;\\n\\n    for (int i = 1; i < nums.length; i++) {\\n      int curr = nums[i];\\n      int prev = nums[i-1];\\n\\n      if (prev < curr) {\\n        temp++;\\n      } else {\\n        res = Math.max(res, temp);\\n        temp = 1;\\n      }\\n    }\\n    return  Math.max(res, temp);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470624,
                "title": "python3-solution",
                "content": "\\'\\'\\'\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        msf = 0  # maxim so far\\n        meh = 1  # maxim ending here\\n        n = len(nums)\\n        if n == 1: return 1\\n        last = nums[0]\\n        for i in range(1, n):\\n            if nums[i] > last:\\n                last = nums[i]\\n                meh += 1\\n            else:\\n                meh = 1\\n                last = nums[i] \\n            if msf < meh:\\n                msf = meh\\n        return msf\\n                \\n```\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        msf = 0  # maxim so far\\n        meh = 1  # maxim ending here\\n        n = len(nums)\\n        if n == 1: return 1\\n        last = nums[0]\\n        for i in range(1, n):\\n            if nums[i] > last:\\n                last = nums[i]\\n                meh += 1\\n            else:\\n                meh = 1\\n                last = nums[i] \\n            if msf < meh:\\n                msf = meh\\n        return msf\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469705,
                "title": "python3-stack-fast-easy-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        stack = [nums[0]]\\n        ret = 1\\n        for i in range(1, len(nums)):\\n            if stack and stack[-1] >= nums[i]: stack.clear()\\n            stack.append(nums[i])\\n            ret = max(ret, len(stack))\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        stack = [nums[0]]\\n        ret = 1\\n        for i in range(1, len(nums)):\\n            if stack and stack[-1] >= nums[i]: stack.clear()\\n            stack.append(nums[i])\\n            ret = max(ret, len(stack))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467381,
                "title": "c-o-n-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1, res = 1;\\n        \\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] > nums[i-1])\\n                count++;\\n            else{\\n                res = max(res, count);\\n                count = 1;\\n            }\\n        }\\n        \\n        res = max(count, res);\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if my solution helped !!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1, res = 1;\\n        \\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] > nums[i-1])\\n                count++;\\n            else{\\n                res = max(res, count);\\n                count = 1;\\n            }\\n        }\\n        \\n        res = max(count, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405855,
                "title": "python-solution-faster-o-n",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) <= 1:\\n            return len(nums)\\n        \\n        so_far_longest = 1\\n        current_longest = 1\\n        for i in xrange(1, len(nums)):\\n            if nums[i-1] < nums[i]:\\n                current_longest +=1\\n            else:\\n                current_longest = 1\\n            so_far_longest = max(so_far_longest, current_longest)\\n\\n        return so_far_longest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) <= 1:\\n            return len(nums)\\n        \\n        so_far_longest = 1\\n        current_longest = 1\\n        for i in xrange(1, len(nums)):\\n            if nums[i-1] < nums[i]:\\n                current_longest +=1\\n            else:\\n                current_longest = 1\\n            so_far_longest = max(so_far_longest, current_longest)\\n\\n        return so_far_longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399272,
                "title": "c-simple-solution",
                "content": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n , 1);\\n        for(int i=1 ; i<n  ; i++){\\n            dp[i]=nums[i]>nums[i-1]?dp[i-1]+dp[i]:dp[i];\\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n , 1);\\n        for(int i=1 ; i<n  ; i++){\\n            dp[i]=nums[i]>nums[i-1]?dp[i-1]+dp[i]:dp[i];\\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392045,
                "title": "python-simplest-solution",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tmaxSub = 1\\n\\ttempSub = 1\\n\\tfor i in range(len(nums)-1): \\n\\t\\tif nums[i] < nums[i+1]: \\n\\t\\t\\ttempSub +=1 \\n\\t\\telse: \\n\\t\\t\\tmaxSub = max(maxSub,tempSub)\\n\\t\\t\\ttempSub = 1\\n\\treturn max(maxSub,tempSub)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tmaxSub = 1\\n\\ttempSub = 1\\n\\tfor i in range(len(nums)-1): \\n\\t\\tif nums[i] < nums[i+1]: \\n\\t\\t\\ttempSub +=1 \\n\\t\\telse: \\n\\t\\t\\tmaxSub = max(maxSub,tempSub)\\n\\t\\t\\ttempSub = 1\\n\\treturn max(maxSub,tempSub)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1388944,
                "title": "python-simple-solution-0-n",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        first = nums[0]\\n        curC = 1\\n        maxC = curC\\n        for i in range(1, len(nums)):\\n          if nums[i] > first: curC += 1\\n          else: curC = 1\\n          first = nums[i]\\n          maxC = max(maxC, curC)\\n          \\n        return maxC\\n          \\n          \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        first = nums[0]\\n        curC = 1\\n        maxC = curC\\n        for i in range(1, len(nums)):\\n          if nums[i] > first: curC += 1\\n          else: curC = 1\\n          first = nums[i]\\n          maxC = max(maxC, curC)\\n          \\n        return maxC\\n          \\n          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337511,
                "title": "rust-with-fold-0ms-and-simple-recursive-racket",
                "content": "Rust:\\n```rust\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        nums.iter().skip(1).fold((nums[0], 1, 1), |(prev, acc, max), i| {\\n            let acc = if *i > prev { acc + 1 } else { 1 };\\n            (*i, acc, acc.max(max))\\n        }).2\\n    }\\n}\\n```\\nRacket:\\n```scheme\\n(define/contract (find-length-of-lcis nums)\\n  (-> (listof exact-integer?) exact-integer?)\\n  (letrec ([go (lambda (xs prev acc max-so-far)\\n                 (cond [(null? xs) (max acc max-so-far)]\\n                       [(<= (car xs) prev) (go (cdr xs) (car xs) 1 (max acc max-so-far))]\\n                       [else (go (cdr xs) (car xs) (+ acc 1) max-so-far)]))])\\n    (go (cdr nums) (car nums) 1 1))\\n  )\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        nums.iter().skip(1).fold((nums[0], 1, 1), |(prev, acc, max), i| {\\n            let acc = if *i > prev { acc + 1 } else { 1 };\\n            (*i, acc, acc.max(max))\\n        }).2\\n    }\\n}\\n```\n```scheme\\n(define/contract (find-length-of-lcis nums)\\n  (-> (listof exact-integer?) exact-integer?)\\n  (letrec ([go (lambda (xs prev acc max-so-far)\\n                 (cond [(null? xs) (max acc max-so-far)]\\n                       [(<= (car xs) prev) (go (cdr xs) (car xs) 1 (max acc max-so-far))]\\n                       [else (go (cdr xs) (car xs) (+ acc 1) max-so-far)]))])\\n    (go (cdr nums) (car nums) 1 1))\\n  )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266954,
                "title": "python-easy-o-n-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef findLengthOfLCIS(self, nums):\\n\\t\\t\\tcount=1\\n\\t\\t\\tmaxi=1\\n\\t\\t\\tfor i in range(1,len(nums)):\\n\\t\\t\\t\\tif(nums[i]>nums[i-1]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcount=1\\n\\t\\t\\t\\tmaxi=max(maxi,count)\\n\\n\\t\\t\\treturn maxi\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef findLengthOfLCIS(self, nums):\\n\\t\\t\\tcount=1\\n\\t\\t\\tmaxi=1\\n\\t\\t\\tfor i in range(1,len(nums)):\\n\\t\\t\\t\\tif(nums[i]>nums[i-1]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcount=1\\n\\t\\t\\t\\tmaxi=max(maxi,count)\\n\\n\\t\\t\\treturn maxi\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1256674,
                "title": "one-pass-sliding-window-simple-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length==1)return 1;\\n        \\n        int start = 0;\\n        int end = 1;\\n        int max_so_far = 1;\\n        int max = 1;\\n        while(end<nums.length){\\n            if(nums[end]>nums[end-1]){\\n                max =Math.max(max,(end-start+1));\\n            }else{\\n                max = 1;\\n                start = end;\\n            }\\n            ++end;\\n            max_so_far = Math.max(max_so_far,max);\\n        }\\n        return max_so_far;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length==1)return 1;\\n        \\n        int start = 0;\\n        int end = 1;\\n        int max_so_far = 1;\\n        int max = 1;\\n        while(end<nums.length){\\n            if(nums[end]>nums[end-1]){\\n                max =Math.max(max,(end-start+1));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1256099,
                "title": "faster-code-easy",
                "content": "**Do upvote if you like it :)**\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1;\\n        int res = 1;\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n            res = max(res , count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1;\\n        int res = 1;\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n            res = max(res , count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238061,
                "title": "python-3-noob-solution-easy-97-68-fast",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tk=1\\n\\tli=[]\\n\\tfor i in range(0,len(nums)):\\n\\t\\tif i==len(nums)-1:\\n\\t\\t\\tli.append(k)\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tif nums[i]<nums[i+1]:\\n\\t\\t\\t\\tk+=1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telse:\\n\\t\\t\\t\\tli.append(k)\\n\\t\\t\\t\\tk=1\\n\\t\\t\\t\\tcontinue\\n\\tmax=-1\\n\\tfor i in li:\\n\\t\\tif max<i:\\n\\t\\t\\tmax=i\\n\\treturn max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tk=1\\n\\tli=[]\\n\\tfor i in range(0,len(nums)):\\n\\t\\tif i==len(nums)-1:\\n\\t\\t\\tli.append(k)\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tif nums[i]<nums[i+1]:\\n\\t\\t\\t\\tk+=1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telse:\\n\\t\\t\\t\\tli.append(k)\\n\\t\\t\\t\\tk=1\\n\\t\\t\\t\\tcontinue\\n\\tmax=-1\\n\\tfor i in li:\\n\\t\\tif max<i:\\n\\t\\t\\tmax=i\\n\\treturn max\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1213844,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int max = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i -1]){\\n                count++;\\n            }else{   \\n                count = 1;\\n            }\\n            max = Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int max = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i -1]){\\n                count++;\\n            }else{   \\n                count = 1;\\n            }\\n            max = Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202497,
                "title": "c-clean-solution",
                "content": "class Solution {\\npublic:\\n*     int findLengthOfLCIS(vector<int>& nums) {\\n        int maxm , cnt;\\n\\t\\tmaxm  = cnt = 1;\\n        for(int i=1; i<nums.size(); i++) {\\n\\t\\t\\tcnt = (nums[i] > nums[i-1]) ? ++cnt : 1;\\n\\t\\t\\tmaxm = max(cnt, maxm);\\n        }\\n        return maxm;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n*     int findLengthOfLCIS(vector<int>& nums) {\\n        int maxm , cnt;\\n\\t\\tmaxm  = cnt = 1;\\n        for(int i=1; i<nums.size(); i++) {\\n\\t\\t\\tcnt = (nums[i] > nums[i-1]) ? ++cnt : 1;\\n\\t\\t\\tmaxm = max(cnt, maxm);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1142338,
                "title": "python-3-easy-solution",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tl = len(nums)\\n\\tres = 0\\n\\ti = 0\\n\\n\\twhile i<l:\\n\\t\\tj = i+1\\n\\n\\t\\twhile j<l and nums[j]>nums[j-1]:\\n\\t\\t\\tj+=1\\n\\t\\tres = max(res, j-i)\\n\\t\\ti = j\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tl = len(nums)\\n\\tres = 0\\n\\ti = 0\\n\\n\\twhile i<l:\\n\\t\\tj = i+1\\n\\n\\t\\twhile j<l and nums[j]>nums[j-1]:\\n\\t\\t\\tj+=1\\n\\t\\tres = max(res, j-i)\\n\\t\\ti = j\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087180,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int result = 1;\\n        int count = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i-1])  count++;\\n            else    count = 1;\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int result = 1;\\n        int count = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i-1])  count++;\\n            else    count = 1;\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048476,
                "title": "java-simple-o-n-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int length = nums.length;\\n        if (length <= 1) return length;\\n        \\n        int curMax = 1;\\n        int max = 1;\\n        \\n        for (int i = 0; i < length - 1; i++) {\\n            if (nums[i] < nums[i + 1]) {\\n                curMax++;\\n                \\n                if (curMax > max) {\\n                   max = curMax; \\n                }\\n            } else {\\n                curMax = 1;\\n            }\\n        }\\n        \\n        if (curMax > max) {\\n            max = curMax;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int length = nums.length;\\n        if (length <= 1) return length;\\n        \\n        int curMax = 1;\\n        int max = 1;\\n        \\n        for (int i = 0; i < length - 1; i++) {\\n            if (nums[i] < nums[i + 1]) {\\n                curMax++;\\n                \\n                if (curMax > max) {\\n                   max = curMax; \\n                }\\n            } else {\\n                curMax = 1;\\n            }\\n        }\\n        \\n        if (curMax > max) {\\n            max = curMax;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977461,
                "title": "java-5-liner",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tint result = 0, currentCount = 0;\\n\\tfor (int i=0;i<nums.length;i++) {\\n\\t\\tcurrentCount = (i==0 || nums[i] > nums[i-1]) ? currentCount + 1 : 1;\\n\\t\\tresult = Math.max(result, currentCount);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tint result = 0, currentCount = 0;\\n\\tfor (int i=0;i<nums.length;i++) {\\n\\t\\tcurrentCount = (i==0 || nums[i] > nums[i-1]) ? currentCount + 1 : 1;\\n\\t\\tresult = Math.max(result, currentCount);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917208,
                "title": "java-beats-99-6",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length == 0) return 0;\\n        \\n        int length = 1;\\n        int maxLength = 1;\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            \\n            if (nums[i] > nums[i-1]) length++;\\n            else length = 1;\\n            \\n            if(length > maxLength) maxLength = length;\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length == 0) return 0;\\n        \\n        int length = 1;\\n        int maxLength = 1;\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            \\n            if (nums[i] > nums[i-1]) length++;\\n            else length = 1;\\n            \\n            if(length > maxLength) maxLength = length;\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884630,
                "title": "python-64ms-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if nums==[]:\\n            return 0\\n        mc=0\\n        c=1 \\n        v=nums[0]\\n        for i in nums[1:]:\\n            if i>v:\\n                v=i \\n                c+=1 \\n            else:\\n                mc=max(mc,c)\\n                v=i\\n                c=1\\n        return max(mc,c)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if nums==[]:\\n            return 0\\n        mc=0\\n        c=1 \\n        v=nums[0]\\n        for i in nums[1:]:\\n            if i>v:\\n                v=i \\n                c+=1 \\n            else:\\n                mc=max(mc,c)\\n                v=i\\n                c=1\\n        return max(mc,c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881811,
                "title": "simple-c-solution-99-15-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=0;\\n        int maxCount=0;\\n        if(nums.size()<=1) return nums.size();\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n            }\\n            else\\n                count=0;\\n            maxCount = max(maxCount,count);\\n        }\\n        return maxCount+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=0;\\n        int maxCount=0;\\n        if(nums.size()<=1) return nums.size();\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n            }\\n            else\\n                count=0;\\n            maxCount = max(maxCount,count);\\n        }\\n        return maxCount+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879766,
                "title": "kotlin-greedy-is-good",
                "content": "Solution - [github](https://github.com/An7One/leetcode-solutions-kotlin-an7one/tree/main/src/main/kotlin/com/an7one/leetcode/lvl2/lc0674)\\n\\n<b>By Tag</b>\\n#Subsequence - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/dynamic_programming/by_topic/subsequence)\\n\\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/\\n *\\n * Time Complexity:     O(`nNums`)\\n * Space Complexity:    O(1)\\n *\\n * Reference:\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/discuss/107365/JavaC%2B%2BClean-solution\\n */\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        // sanity check\\n        if(nums.isEmpty()) return 0\\n        \\n        val nNums = nums.size\\n        \\n        var longest = 1\\n        var len = 1\\n        \\n        for(i in 1 until nNums){\\n            if(i == 0 || nums[i - 1] < nums[i]){\\n                longest = maxOf(longest, ++len)\\n            }else{\\n                len = 1\\n            }\\n        }\\n        \\n        return longest\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/\\n *\\n * Time Complexity:     O(`nNums`)\\n * Space Complexity:    O(1)\\n *\\n * Reference:\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/discuss/107365/JavaC%2B%2BClean-solution\\n */\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        // sanity check\\n        if(nums.isEmpty()) return 0\\n        \\n        val nNums = nums.size\\n        \\n        var longest = 1\\n        var len = 1\\n        \\n        for(i in 1 until nNums){\\n            if(i == 0 || nums[i - 1] < nums[i]){\\n                longest = maxOf(longest, ++len)\\n            }else{\\n                len = 1\\n            }\\n        }\\n        \\n        return longest\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861131,
                "title": "java-dp-solution-o-n-time-complexity-o-1-space-complexity",
                "content": "The idea is straightforward, we use a variable `max_length` to track longest continuous increasing subsequence ending at `nums[i]`(inclusive) . To update `max_length`, there has 2 sceanarios:\\n1. If `nums[i-1]` < `nums[i]`,  we use previous `max_length` at `i-1` and add 1 to it as current `max_length` at index `i`.\\n2. If `nums[i-1]` >= `nums[i]`, the `max_length` at index `i` is just itself, which means 1.\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n        int l = nums.length;\\n        if(l <= 1) return l;\\n        int res = 1;\\n        int max_length = 1;\\n        for(int i=1; i<l; i++) {\\n            max_length = nums[i] > nums[i-1] ? max_length + 1 : 1;\\n            res = Math.max(res, max_length);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        int l = nums.length;\\n        if(l <= 1) return l;\\n        int res = 1;\\n        int max_length = 1;\\n        for(int i=1; i<l; i++) {\\n            max_length = nums[i] > nums[i-1] ? max_length + 1 : 1;\\n            res = Math.max(res, max_length);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859540,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums):\\n\\t    \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n      count = 1\\n      max_len = 1\\n      if len(nums) == 0:\\n        return 0\\n      for i in range(len(nums)-1):\\n        if nums[i] < nums[i+1]:\\n          count+=1\\n          max_len = max(max_len, count)\\n        else:\\n          max_len = max(max_len, count)\\n          count = 1    \\n      return max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums):\\n\\t    \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n      count = 1\\n      max_len = 1\\n      if len(nums) == 0:\\n        return 0\\n      for i in range(len(nums)-1):\\n        if nums[i] < nums[i+1]:\\n          count+=1\\n          max_len = max(max_len, count)\\n        else:\\n          max_len = max(max_len, count)\\n          count = 1    \\n      return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858026,
                "title": "easy-simple-cpp-easy-to-understand-simple-intiutive",
                "content": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1 || nums.size()==0)\\n            return nums.size();\\n        int count=0;\\n        int max=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                count++;\\n            else\\n                count=0;\\n            if(max<count)\\n                max=count;\\n        }\\n        return max+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1 || nums.size()==0)\\n            return nums.size();\\n        int count=0;\\n        int max=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                count++;\\n            else\\n                count=0;\\n            if(max<count)\\n                max=count;\\n        }\\n        return max+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854613,
                "title": "python-simple-and-easy-to-understand-approx-99",
                "content": "~64ms Speed (~ 99% faster)\\n\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return len(nums)\\n        maxi = 1\\n        cnt = 1\\n        prev = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] > prev:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            maxi = max(maxi,cnt)\\n            prev = nums[i]\\n        return maxi\\n                \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return len(nums)\\n        maxi = 1\\n        cnt = 1\\n        prev = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] > prev:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            maxi = max(maxi,cnt)\\n            prev = nums[i]\\n        return maxi\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844191,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0) return 0;\\n        \\n        int current =1;\\n        int maxLength = 1;\\n\\n        // expand the length of window by 1, and reset it back to 1 if found a small number\\n        for (int i=1; i < nums.length; i++){\\n            if (nums[i-1]>=nums[i])\\n                {current =1;}\\n            else\\n            {   current +=1;\\n                maxLength = Math.max(current, maxLength);}\\n        }\\n        return maxLength;\\n\\n    }\\n}\\n\\n```\\n# \\u53E6\\u5916\\u4E00\\u4E2ASliding Window \\u7684\\u95EE\\u9898\\uFF1Aquestion #346\\n# 346\\tMoving Average from Data Stream    \\n\\n```\\nclass MovingAverage {\\n    int mysize;\\n    int[] mylist;\\n    int mysum = 0;\\n     int count = 0;\\n\\n    /** Initialize your data structure here. */\\n    public MovingAverage(int size) {\\n        mysize = size;\\n        mylist = new int[size];\\n\\n    }\\n    \\n    public double next(int val) {\\n        count +=1;\\n        int index = count % mysize;\\n        mysum = mysum - mylist[index]+val;\\n        mylist[index]=val;\\n        if (count < mysize) \\n            {return mysum * 1.0 / count;}\\n        else \\n            {return (mysum * 1.0 / mysize);}\\n\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0) return 0;\\n        \\n        int current =1;\\n        int maxLength = 1;\\n\\n        // expand the length of window by 1, and reset it back to 1 if found a small number\\n        for (int i=1; i < nums.length; i++){\\n            if (nums[i-1]>=nums[i])\\n                {current =1;}\\n            else\\n            {   current +=1;\\n                maxLength = Math.max(current, maxLength);}\\n        }\\n        return maxLength;\\n\\n    }\\n}\\n\\n```\n```\\nclass MovingAverage {\\n    int mysize;\\n    int[] mylist;\\n    int mysum = 0;\\n     int count = 0;\\n\\n    /** Initialize your data structure here. */\\n    public MovingAverage(int size) {\\n        mysize = size;\\n        mylist = new int[size];\\n\\n    }\\n    \\n    public double next(int val) {\\n        count +=1;\\n        int index = count % mysize;\\n        mysum = mysum - mylist[index]+val;\\n        mylist[index]=val;\\n        if (count < mysize) \\n            {return mysum * 1.0 / count;}\\n        else \\n            {return (mysum * 1.0 / mysize);}\\n\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761294,
                "title": "100-faster-java-easy-solution",
                "content": "class Solution {\\n       public int findLengthOfLCIS(int[] nums) {\\n        \\n      if(nums.length==0)\\n         return 0;  \\n     \\n     int max=1,count=1;\\n     for(int i=1;i<nums.length;i++)\\n     {\\n        if(nums[i]<=nums[i-1])\\n        {\\n           if(count>max) \\n             max=count;\\n           count=1; \\n        }\\n         \\n        else\\n        count++;   \\n     }\\n        \\n      return max<count ? count : max;  \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public int findLengthOfLCIS(int[] nums) {\\n        \\n      if(nums.length==0)\\n         return 0;  \\n     \\n     int max=1,count=1;\\n     for(int i=1;i<nums.length;i++)\\n     {\\n        if(nums[i]<=nums[i-1])\\n        {\\n           if(count>max) \\n             max=count;\\n           count=1; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 742911,
                "title": "easiest-java-version-using-sliding-window",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        // edge case\\n        if(nums == null || nums.length == 0)\\n            return 0;\\n        \\n        int res = 1; // min longest subsequence length\\n        int curr = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {\\n                curr++;\\n            }\\n            else {\\n                res = Math.max(res, curr);\\n                curr = 1;\\n            }            \\n        }\\n        \\n        res = Math.max(res, curr);\\n        return res;\\n    }\\n}\\n\\n```\\n\\n// Time complexity: O(N)\\n// Space complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        // edge case\\n        if(nums == null || nums.length == 0)\\n            return 0;\\n        \\n        int res = 1; // min longest subsequence length\\n        int curr = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {\\n                curr++;\\n            }\\n            else {\\n                res = Math.max(res, curr);\\n                curr = 1;\\n            }            \\n        }\\n        \\n        res = Math.max(res, curr);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738650,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        largest = count = 1\\n        if len(nums) == 0:\\n            return 0   \\n        for idx in range(len(nums) - 1):\\n            if nums[idx] < nums[idx+1]:\\n                count += 1\\n                if count > largest:\\n                    largest = count\\n            else:\\n                count = 1\\n        return largest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        largest = count = 1\\n        if len(nums) == 0:\\n            return 0   \\n        for idx in range(len(nums) - 1):\\n            if nums[idx] < nums[idx+1]:\\n                count += 1\\n                if count > largest:\\n                    largest = count\\n            else:\\n                count = 1\\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672341,
                "title": "idiomatic-simple-rust",
                "content": "* Handle edge cases.\\n* Cache previous value.\\n* Iterate over values from second entry for bootstrapping cache.\\n\\n```\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return nums.len() as i32;\\n        }\\n        let mut longest = 1;\\n        let mut current = 1;\\n        let mut previous_val = nums[0];\\n        for n in nums.iter().skip(1) {\\n            if *n > previous_val {\\n                current += 1;            \\n            } else {\\n                current = 1;\\n            }\\n            longest = std::cmp::max(longest, current);\\n            previous_val = *n;\\n        }\\n        longest\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return nums.len() as i32;\\n        }\\n        let mut longest = 1;\\n        let mut current = 1;\\n        let mut previous_val = nums[0];\\n        for n in nums.iter().skip(1) {\\n            if *n > previous_val {\\n                current += 1;            \\n            } else {\\n                current = 1;\\n            }\\n            longest = std::cmp::max(longest, current);\\n            previous_val = *n;\\n        }\\n        longest\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672251,
                "title": "c-cpp-sliding-window-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int left=0;\\n        int right=0;\\n        int maxi = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){right++;}\\n            else{\\n                maxi = max(right-left+1,maxi);\\n                left = i;\\n                right = i;\\n            }\\n        }\\n        maxi = max(right-left+1,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int left=0;\\n        int right=0;\\n        int maxi = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){right++;}\\n            else{\\n                maxi = max(right-left+1,maxi);\\n                left = i;\\n                right = i;\\n            }\\n        }\\n        maxi = max(right-left+1,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655606,
                "title": "cpp-sol-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        int k=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]>0) c++;\\n            else\\n            {\\n                k=max(k,c);c=1;\\n            }\\n        }\\n         k=max(k,c);\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        int k=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]>0) c++;\\n            else\\n            {\\n                k=max(k,c);c=1;\\n            }\\n        }\\n         k=max(k,c);\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645918,
                "title": "c-dp",
                "content": "```\\nint findLengthOfLCIS( vector<int>& nums ) {\\n\\tint n = nums.size();\\n\\tif( n == 0 ) return 0;\\n\\n\\tvector<int> dp( n, 0 );\\n\\tdp[0] = 1;\\n\\n\\tint longest = 1;\\n\\tfor( int i=1; i < n; i++ ) {\\n\\t\\tif( nums[i] > nums[i-1] )\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\telse\\n\\t\\t\\tdp[i] = 1;\\n\\t\\tlongest = max( longest, dp[i] );\\n\\t}\\n\\treturn longest;\\n}\\n```\\n\\nThis can be further improved to use O(1) space. The else block can also be avoided.",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS( vector<int>& nums ) {\\n\\tint n = nums.size();\\n\\tif( n == 0 ) return 0;\\n\\n\\tvector<int> dp( n, 0 );\\n\\tdp[0] = 1;\\n\\n\\tint longest = 1;\\n\\tfor( int i=1; i < n; i++ ) {\\n\\t\\tif( nums[i] > nums[i-1] )\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\telse\\n\\t\\t\\tdp[i] = 1;\\n\\t\\tlongest = max( longest, dp[i] );\\n\\t}\\n\\treturn longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523059,
                "title": "easy-javascript-solution-1-pass-52ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let curr = 1;\\n  let max = 0;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] < nums[i + 1]) curr++;\\n    if (curr > max) max = curr;\\n    if (nums[i] >= nums[i + 1]) curr = 1;\\n  }\\n  \\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let curr = 1;\\n  let max = 0;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] < nums[i + 1]) curr++;\\n    if (curr > max) max = curr;\\n    if (nums[i] >= nums[i + 1]) curr = 1;\\n  }\\n  \\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502686,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null) {\\n            return 0;\\n        }\\n        if(nums.length <= 1) {\\n            return nums.length;\\n        }\\n        \\n        int maxSoFar = 1, maxCurr = 1;\\n        \\n        for(int i=1; i< nums.length; i++) {\\n            \\n            if(nums[i] > nums[i-1]){\\n                maxCurr++;\\n            } else {\\n                maxCurr = 1;\\n            }\\n            maxSoFar = Math.max(maxSoFar, maxCurr);\\n        }\\n        return maxSoFar;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null) {\\n            return 0;\\n        }\\n        if(nums.length <= 1) {\\n            return nums.length;\\n        }\\n        \\n        int maxSoFar = 1, maxCurr = 1;\\n        \\n        for(int i=1; i< nums.length; i++) {\\n            \\n            if(nums[i] > nums[i-1]){\\n                maxCurr++;\\n            } else {\\n                maxCurr = 1;\\n            }\\n            maxSoFar = Math.max(maxSoFar, maxCurr);\\n        }\\n        return maxSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485169,
                "title": "python-o-n-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        maxx = 1\\n        cur = 1\\n        for i in range(1,len(nums)):\\n            if nums[i]> nums[i-1]:\\n                cur+=1\\n                maxx = max(cur,maxx)\\n            else:\\n                cur=1    \\n        return maxx\\n```\\n\\nSince the smallest increasing subsequence has lenght of 1, we start with this value.\\nWhen an element is bigger than the previous one, we increase the length of the current longest subsequence. \\nIf we encounter an element that doesnt obey the rule we set cur as 1.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        maxx = 1\\n        cur = 1\\n        for i in range(1,len(nums)):\\n            if nums[i]> nums[i-1]:\\n                cur+=1\\n                maxx = max(cur,maxx)\\n            else:\\n                cur=1    \\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476274,
                "title": "go-solution-4ms-100-faster-100-memory-usage",
                "content": "// n - previous number (starts with math.MinInt32)\\n// cc - current count\\n// max - maximum increasing sub array size\\n/* \\n\\tCompare nums[i] with previous (n) and if previous value is smaller than current,\\n\\tincrement current count(cc) . If not, reset the current count(cc) to 1.\\n\\tIf max happens to be smaller than current count (cc) assign cc to max.\\n*/\\n\\t\\n```golang\\nfunc findLengthOfLCIS(nums []int) int {\\n\\tn, cc, max := math.MinInt32, 0, 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif n < nums[i] {\\n\\t\\t\\tcc++\\n\\t\\t} else if n >= nums[i] {\\n\\t\\t\\tcc = 1\\n\\t\\t}\\n\\t\\tif max < cc {\\n\\t\\t\\tmax = cc\\n\\t\\t}\\n\\t\\tn = nums[i]\\n\\t}\\n\\treturn max\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc findLengthOfLCIS(nums []int) int {\\n\\tn, cc, max := math.MinInt32, 0, 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif n < nums[i] {\\n\\t\\t\\tcc++\\n\\t\\t} else if n >= nums[i] {\\n\\t\\t\\tcc = 1\\n\\t\\t}\\n\\t\\tif max < cc {\\n\\t\\t\\tmax = cc\\n\\t\\t}\\n\\t\\tn = nums[i]\\n\\t}\\n\\treturn max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452536,
                "title": "java-o-n-solution-beats-100-time-memory",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0)return 0;\\n        int sum = 1;\\n        int current = 1;\\n        for (int i=1;i<nums.length;i++){\\n            if (nums[i]>nums[i-1])current++;\\n            else {\\n                sum=Math.max(sum, current);\\n                current=1;\\n            }\\n        }\\n        sum=Math.max(sum, current);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0)return 0;\\n        int sum = 1;\\n        int current = 1;\\n        for (int i=1;i<nums.length;i++){\\n            if (nums[i]>nums[i-1])current++;\\n            else {\\n                sum=Math.max(sum, current);\\n                current=1;\\n            }\\n        }\\n        sum=Math.max(sum, current);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437811,
                "title": "5-lines-java-100-sliding-window",
                "content": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int n = nums.length; \\n        if(n == 0) return n;        \\n        int i=0, j=0, max = 1;\\n        while(++i < n)\\n            if(nums[i-1] < nums[i]) max = Math.max(max, i-j+1);\\n            else j=i;                \\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int n = nums.length; \\n        if(n == 0) return n;        \\n        int i=0, j=0, max = 1;\\n        while(++i < n)\\n            if(nums[i-1] < nums[i]) max = Math.max(max, i-j+1);\\n            else j=i;                \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430855,
                "title": "simple-easy-to-understand-faster-javascript-submission",
                "content": "**Please do upvote this solution, this motivates me to write better posts\\uD83D\\uDE04**\\n\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    let longest = 0,\\n        count = 0;\\n    let prev = -Infinity;\\n    for(let i of nums){\\n        if(i>prev){\\n            count++;\\n        }\\n        else{\\n            count = 1;\\n        }\\n        prev = i;\\n        longest = Math.max(longest, count)\\n    }\\n    return longest\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLengthOfLCIS = function(nums) {\\n    let longest = 0,\\n        count = 0;\\n    let prev = -Infinity;\\n    for(let i of nums){\\n        if(i>prev){\\n            count++;\\n        }\\n        else{\\n            count = 1;\\n        }\\n        prev = i;\\n        longest = Math.max(longest, count)\\n    }\\n    return longest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359262,
                "title": "simple-java-dp-solution",
                "content": "The idea is similar to Maximum contagious subarray sum, here we maintain the max length found including index i;\\n\\n\\tdp[i] = (nums[i]>nums[i-1] ? dp[i-1] +1 : 1)\\n\\tSolution is max of all dp[i] , i belongs to 0->n\\n\\t\\n\\t`class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int[] dp = new int[nums.length];\\n        \\n        if(nums.length==0)\\n            return 0;\\n        \\n        dp[0]=1;\\n        int max=1;\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n                dp[i]=dp[i-1]+1;\\n            else\\n                dp[i]=1;\\n            max = Math.max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}`\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int[] dp = new int[nums.length];\\n        \\n        if(nums.length==0)\\n            return 0;\\n        \\n        dp[0]=1;\\n        int max=1;\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n                dp[i]=dp[i-1]+1;\\n            else\\n                dp[i]=1;\\n            max = Math.max(max,dp[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 351277,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        int count = 1;\\n        int sum = 1;\\n        int ini = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(ini<nums[i]){\\n                count++;\\n            }\\n            else{\\n                count = 1;\\n            }\\n            sum = Math.max(sum,count);\\n            ini = nums[i];\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 244256,
                "title": "faster-java-solution",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        int count = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i< nums.length - 1; i++)\\n        {\\n            if(nums[i+1] > nums[i])\\n                count++;\\n            else\\n                count = 1;\\n\\n            max = Math.max(max,count);\\n        }\\n        return Math.max(max,count);\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        int count = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i< nums.length - 1; i++)\\n        {\\n            if(nums[i+1] > nums[i])\\n                count++;\\n            else\\n                count = 1;\\n\\n            max = Math.max(max,count);\\n        }\\n        return Math.max(max,count);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 243304,
                "title": "three-java-solutions-two-pointers-dp-optimized-dp",
                "content": "Two pointers. Time: O(n), Space: O(1)\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint left = 0;\\n\\tint right = 1;\\n\\tint ans = 0;\\n\\twhile (right < nums.length) {\\n\\t\\tif (nums[right] <= nums[right - 1]) {\\n\\t\\t\\tans = Math.max(ans, right - left);\\n\\t\\t\\tleft = right;\\n\\t\\t}\\n\\t\\tright++;\\n\\t}\\n\\n\\tans = Math.max(ans, right - left);\\n\\n\\treturn ans;\\n}\\n```\\nDP, Time: O(n), Space: O(n)\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = 1;\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < dp.length; i++) {\\n\\t\\tans = Math.max(ans, dp[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\nOptimized DP, Time: O(n), Space: O(1)\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint count = 1;\\n\\tint ans = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint left = 0;\\n\\tint right = 1;\\n\\tint ans = 0;\\n\\twhile (right < nums.length) {\\n\\t\\tif (nums[right] <= nums[right - 1]) {\\n\\t\\t\\tans = Math.max(ans, right - left);\\n\\t\\t\\tleft = right;\\n\\t\\t}\\n\\t\\tright++;\\n\\t}\\n\\n\\tans = Math.max(ans, right - left);\\n\\n\\treturn ans;\\n}\\n```\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = 1;\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < dp.length; i++) {\\n\\t\\tans = Math.max(ans, dp[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint count = 1;\\n\\tint ans = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235376,
                "title": "c-short-o-1-space-dp",
                "content": "Define `dp[i]` to be the length of the longest increasing subarray (LIS) ending at `nums[i]`. Initially, `dp[i] = 1`. For each `i > 0`, if `nums[i] > nums[i - 1]`, update `dp[i] = dp[i - 1] + 1`. Return the maximum value of `dp`.\\n\\nSince `dp[i]` only depends on `dp[i - 1]`, we can just use a single variable and update it. Another key point to make the codes clean is how to handle empty array.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0, l = 0; i < nums.size(); i++) {\\n            i && nums[i] > nums[i - 1] ? l++ : l = 1;\\n            ans = max(ans, l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0, l = 0; i < nums.size(); i++) {\\n            i && nums[i] > nums[i - 1] ? l++ : l = 1;\\n            ans = max(ans, l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202735,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int FindLengthOfLCIS(int[] nums) {\\n        if(nums.Length == 0) return 0;\\n\\t\\t\\n\\t\\tvar max = int.MinValue;\\n        \\n        var si = 0;\\n        \\n        for(var i = 1; i < nums.Length; i++){\\n            if(nums[i] > nums[i - 1]) continue;\\n            \\n            max = Math.Max(max, i - si);\\n            \\n            si = i;\\n        }\\n        \\n        max = Math.Max(max, nums.Length - si);\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindLengthOfLCIS(int[] nums) {\\n        if(nums.Length == 0) return 0;\\n\\t\\t\\n\\t\\tvar max = int.MinValue;\\n        \\n        var si = 0;\\n        \\n        for(var i = 1; i < nums.Length; i++){\\n            if(nums[i] > nums[i - 1]) continue;\\n            \\n            max = Math.Max(max, i - si);\\n            \\n            si = i;\\n        }\\n        \\n        max = Math.Max(max, nums.Length - si);\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187481,
                "title": "c-100",
                "content": "```\nint findLengthOfLCIS(int* nums, int numsSize) {\n    if (numsSize == 0)\n        return 0;\n    int longest = 0;\n    int continuous = 1;\n    for (int i = 1; i < numsSize; i++){\n        if (nums[i] > nums[i-1]){\n            ++continuous;\n        } else {\n            if (continuous > longest){\n                longest = continuous;\n            }\n            continuous = 1;\n        }\n    }\n    if (continuous > longest){\n        longest = continuous;\n    }\n    return longest;\n}\n```",
                "solutionTags": [],
                "code": "```\nint findLengthOfLCIS(int* nums, int numsSize) {\n    if (numsSize == 0)\n        return 0;\n    int longest = 0;\n    int continuous = 1;\n    for (int i = 1; i < numsSize; i++){\n        if (nums[i] > nums[i-1]){\n            ++continuous;\n        } else {\n            if (continuous > longest){\n                longest = continuous;\n            }\n            continuous = 1;\n        }\n    }\n    if (continuous > longest){\n        longest = continuous;\n    }\n    return longest;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186895,
                "title": "simple-java-100",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n                if (nums.length==0) return 0;\\n        int max = 1;\\n        int count =1;\\n        for (int i = 1; i <nums.length ; i++) {\\n            if (nums[i] >nums[i-1]){\\n                count++;\\n                if (count>max){\\n                    max=count;\\n                }\\n            }else {\\n                count=1;\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n                if (nums.length==0) return 0;\\n        int max = 1;\\n        int count =1;\\n        for (int i = 1; i <nums.length ; i++) {\\n            if (nums[i] >nums[i-1]){\\n                count++;\\n                if (count>max){\\n                    max=count;\\n                }\\n            }else {\\n                count=1;\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178688,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        crrcnt = 1\\n        fnlcnt =1\\n        if len(nums) == 0:\\n            return 0\\n        \\n        for i in range(0,len(nums)-1,1):\\n            if nums[i] < nums[i+1]:\\n                crrcnt = crrcnt + 1\\n            else:\\n                fnlcnt = max(crrcnt,fnlcnt)\\n                crrcnt = 1\\n            \\n        return max(fnlcnt,crrcnt)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        crrcnt = 1\\n        fnlcnt =1\\n        if len(nums) == 0:\\n            return 0\\n        \\n        for i in range(0,len(nums)-1,1):\\n            if nums[i] < nums[i+1]:\\n                crrcnt = crrcnt + 1\\n            else:\\n                fnlcnt = max(crrcnt,fnlcnt)\\n                crrcnt = 1\\n            \\n        return max(fnlcnt,crrcnt)",
                "codeTag": "Java"
            },
            {
                "id": 164524,
                "title": "python-super-simple-and-very-intuitive-also-beats-100-at-the-moment",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        \\n        count = 1\\n        maxcount = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                count+=1\\n            else:\\n                count = 1\\n            if count > maxcount:\\n                maxcount = count\\n        return maxcount\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        \\n        count = 1\\n        maxcount = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                count+=1\\n            else:\\n                count = 1\\n            if count > maxcount:\\n                maxcount = count\\n        return maxcount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150197,
                "title": "python-solution-beats-98-27ms",
                "content": "I have seen some solutions but since I have seen my solution is lesser lines of code and easier,I will post it here for reference.\\nThere is no need to have to while loops(according to me it is an additional overhead of maintenance and prone to bugs because of corner cases and boundary conditions)\\nWe keep two pointer `prev` , `cur_max` and `tot_val` . \\nInitially `prev` is the first element and we loop from first index to check increasing continuous pattern.\\nWhen the increasing subsequence breaks, we just update the `cur_max` to be 1 and continue.\\n\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not nums:\\n            return 0\\n        \\n        prev = nums[0]\\n        cur_max = 1\\n        tot_val = 1\\n        \\n        for i in xrange(1,len(nums)):\\n            if nums[i] > prev:\\n                cur_max+=1\\n                tot_val = max(cur_max,tot_val)\\n            else:\\n                cur_max = 1\\n                \\n            prev = nums[i]\\n            \\n        return tot_val\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not nums:\\n            return 0\\n        \\n        prev = nums[0]\\n        cur_max = 1\\n        tot_val = 1\\n        \\n        for i in xrange(1,len(nums)):\\n            if nums[i] > prev:\\n                cur_max+=1\\n                tot_val = max(cur_max,tot_val)\\n            else:\\n                cur_max = 1\\n                \\n            prev = nums[i]\\n            \\n        return tot_val\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148838,
                "title": "java-3ms",
                "content": " public int findLengthOfLCIS(int[] nums) {\\n     int i=1;\\n    int j=0;\\n        \\n     int count=1;\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length==0){\\n            return 0;\\n        }\\n       \\n     while(i<nums.length){\\n         if(nums[i]>nums[j]){\\n             count++;\\n             max=Math.max(max, count);\\n              i++;\\n             j++;\\n         } else {\\n             j=i;\\n             i++;\\n             count=1;\\n         }\\n    }  \\n        return max>0 ? max : 1;\\n    }",
                "solutionTags": [],
                "code": " public int findLengthOfLCIS(int[] nums) {\\n     int i=1;\\n    int j=0;\\n        \\n     int count=1;\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length==0){\\n            return 0;\\n        }\\n       \\n     while(i<nums.length){\\n         if(nums[i]>nums[j]){\\n             count++;\\n             max=Math.max(max, count);\\n              i++;\\n             j++;\\n         } else {\\n             j=i;\\n             i++;\\n             count=1;\\n         }\\n    }  \\n        return max>0 ? max : 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107346,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nint findLengthOfLCIS(int* nums, int numsSize) {\\n    if(numsSize==0)\\n    {\\n        return 0;\\n    }\\n    int temp=1;\\n    int result=1;\\n    for(int i=1;i<numsSize;i++)\\n    {\\n        if(nums[i]>nums[i-1])\\n        {temp++;}\\n        else\\n        {\\n            if(result<temp)\\n            {result=temp;}\\n            temp=1;\\n        }\\n    }    \\n    if(result<temp)\\n    {result=temp;}\\n    return result;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(int* nums, int numsSize) {\\n    if(numsSize==0)\\n    {\\n        return 0;\\n    }\\n    int temp=1;\\n    int result=1;\\n    for(int i=1;i<numsSize;i++)\\n    {\\n        if(nums[i]>nums[i-1])\\n        {temp++;}\\n        else\\n        {\\n            if(result<temp)\\n            {result=temp;}\\n            temp=1;\\n        }\\n    }    \\n    if(result<temp)\\n    {result=temp;}\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107386,
                "title": "python-anchor-approach",
                "content": "Let's remember the smallest value `prev` in our current chain, and the length `count` of the current chain.\\n\\n```\\ndef findLengthOfLCIS(self, nums):\\n    prev = float('-inf')\\n    ans = count = 0\\n    for x in nums:\\n        if x > prev:\\n            count += 1\\n            ans = max(ans, count)\\n        else:\\n            count = 1\\n        prev = x\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef findLengthOfLCIS(self, nums):\\n    prev = float('-inf')\\n    ans = count = 0\\n    for x in nums:\\n        if x > prev:\\n            count += 1\\n            ans = max(ans, count)\\n        else:\\n            count = 1\\n        prev = x\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4085462,
                "title": "easy-understanding-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int findLengthOfLCIS(int[] nums) {\\n\\n\\n\\t\\t\\tint maxCount = 0;\\n\\t\\t\\tint start = 0;\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++){\\n\\t\\t\\t\\tif(i > 0 && nums[i - 1] >= nums[i]){\\n\\t\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxCount = Math.max(maxCount,i-start+1);\\n\\t\\t\\t}\\n\\t\\t\\treturn maxCount;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findLengthOfLCIS(int[] nums) {\\n\\n\\n\\t\\t\\tint maxCount = 0;\\n\\t\\t\\tint start = 0;\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++){\\n\\t\\t\\t\\tif(i > 0 && nums[i - 1] >= nums[i]){\\n\\t\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4084024,
                "title": "simple-java-solution-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        Stack<Integer>stack=new Stack<>();\\n        int max=0;\\n        for(int i:nums){\\n            if(stack.isEmpty() || (!stack.isEmpty() && stack.peek()<i)) stack.push(i);\\n            else{\\n                max=Math.max(max,stack.size());\\n                stack.clear();\\n                stack.push(i);\\n            }\\n        }\\n        if(stack.size()>max) return stack.size();\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        Stack<Integer>stack=new Stack<>();\\n        int max=0;\\n        for(int i:nums){\\n            if(stack.isEmpty() || (!stack.isEmpty() && stack.peek()<i)) stack.push(i);\\n            else{\\n                max=Math.max(max,stack.size());\\n                stack.clear();\\n                stack.push(i);\\n            }\\n        }\\n        if(stack.size()>max) return stack.size();\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082521,
                "title": "java-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int res = 0;\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                count++;\\n            }else{\\n                res = Math.max(res, count);\\n                count = 1;\\n            }\\n        }\\n        return Math.max(res, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int res = 0;\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                count++;\\n            }else{\\n                res = Math.max(res, count);\\n                count = 1;\\n            }\\n        }\\n        return Math.max(res, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078830,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int length = nums.size();\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        for(int i =1; i <length; i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n            {\\n                currentCount++;\\n                if(currentCount>maxCount)\\n                {\\n                    maxCount = currentCount;\\n                }\\n            }\\n            else\\n            {\\n                currentCount = 1;\\n            }\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int length = nums.size();\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        for(int i =1; i <length; i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n            {\\n                currentCount++;\\n                if(currentCount>maxCount)\\n                {\\n                    maxCount = currentCount;\\n                }\\n            }\\n            else\\n            {\\n                currentCount = 1;\\n            }\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078570,
                "title": "kotlin",
                "content": "O(n) beat 100% runtime\\n\\n# Code\\n```\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        var prev:Int = Int.MIN_VALUE\\n        var cont:Int = 0\\n        var maxcont :Int = 0\\n        for (n in nums){\\n            if (n> prev){\\n                cont++\\n                prev = n\\n            }\\n            else{\\n                maxcont = maxOf(maxcont,cont)\\n                cont = 1\\n                prev = n\\n            }\\n        }\\n        maxcont = maxOf(maxcont,cont)\\n        return maxcont\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        var prev:Int = Int.MIN_VALUE\\n        var cont:Int = 0\\n        var maxcont :Int = 0\\n        for (n in nums){\\n            if (n> prev){\\n                cont++\\n                prev = n\\n            }\\n            else{\\n                maxcont = maxOf(maxcont,cont)\\n                cont = 1\\n                prev = n\\n            }\\n        }\\n        maxcont = maxOf(maxcont,cont)\\n        return maxcont\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060819,
                "title": "easy-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=1,i=0;\\n        int ans=1;\\n        while(i<nums.size()-1){\\n            if(nums[i+1]>nums[i]){\\n                count++;\\n                ans=max(ans,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=1,i=0;\\n        int ans=1;\\n        while(i<nums.size()-1){\\n            if(nums[i+1]>nums[i]){\\n                count++;\\n                ans=max(ans,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058639,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n        int cnt=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                cnt++;\\n            }\\n            else{\\n                max=Math.max(max,cnt);\\n                cnt=0;\\n            }\\n        }\\n        if(cnt!=0)\\n        {\\n            max=Math.max(max,cnt);\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n        int cnt=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                cnt++;\\n            }\\n            else{\\n                max=Math.max(max,cnt);\\n                cnt=0;\\n            }\\n        }\\n        if(cnt!=0)\\n        {\\n            max=Math.max(max,cnt);\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057106,
                "title": "easy-way-to-understanding-for-beginner-level-friendly-0ms-easy-way",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n\\n      int k=0;\\n    \\tint []array=new int[a.length];\\n    \\tint count=1;\\n    \\tint []b=new int[a.length];\\n    \\t\\n    \\tfor(int i=0;i<a.length-1;i++)\\n    \\t{\\n    \\t\\tif(a[i]<a[i+1])\\n    \\t\\t{\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t\\tcount=1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(i==a.length-2)\\n    \\t\\t{\\n    \\t\\t\\t//System.out.println(\"connected\");\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tArrays.sort(b);\\n        if(b[b.length-1]==0)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n\\n    \\treturn b[b.length-1];\\n        }\\n    \\t\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n\\n      int k=0;\\n    \\tint []array=new int[a.length];\\n    \\tint count=1;\\n    \\tint []b=new int[a.length];\\n    \\t\\n    \\tfor(int i=0;i<a.length-1;i++)\\n    \\t{\\n    \\t\\tif(a[i]<a[i+1])\\n    \\t\\t{\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t\\tcount=1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(i==a.length-2)\\n    \\t\\t{\\n    \\t\\t\\t//System.out.println(\"connected\");\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tArrays.sort(b);\\n        if(b[b.length-1]==0)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n\\n    \\treturn b[b.length-1];\\n        }\\n    \\t\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052123,
                "title": "beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045173,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        if len(nums)==1:\\n            return 1\\n        for i in range(len(nums)-1):\\n            c=1\\n            last=nums[i]\\n            for j in range(i+1,len(nums)):\\n                if last<nums[j]:\\n                    last=nums[j]\\n                    c+=1\\n                else:\\n                    break\\n            count=max(count,c)\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        if len(nums)==1:\\n            return 1\\n        for i in range(len(nums)-1):\\n            c=1\\n            last=nums[i]\\n            for j in range(i+1,len(nums)):\\n                if last<nums[j]:\\n                    last=nums[j]\\n                    c+=1\\n                else:\\n                    break\\n            count=max(count,c)\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044813,
                "title": "the-js-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let i = 0;\\n    let currSubLength = 0;\\n    let ans = 0;\\n\\n    if(nums.length == 1) {\\n        return nums.length;\\n    }\\n\\n    while(i < nums.length - 1) {\\n        if(nums[i] >= nums[i+1]) {\\n            ans = ans < currSubLength ? currSubLength : ans;\\n            currSubLength = 0;\\n        } else {\\n            currSubLength++;\\n        }\\n\\n        i++;\\n    }\\n\\n    return ans < currSubLength ? currSubLength+1  : ans+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let i = 0;\\n    let currSubLength = 0;\\n    let ans = 0;\\n\\n    if(nums.length == 1) {\\n        return nums.length;\\n    }\\n\\n    while(i < nums.length - 1) {\\n        if(nums[i] >= nums[i+1]) {\\n            ans = ans < currSubLength ? currSubLength : ans;\\n            currSubLength = 0;\\n        } else {\\n            currSubLength++;\\n        }\\n\\n        i++;\\n    }\\n\\n    return ans < currSubLength ? currSubLength+1  : ans+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033826,
                "title": "java-1000-accepted-easy-kadane-s-implementation",
                "content": "# Intuition\\nKadane\\'s Algorithm\\nTC-O(n)\\nSC-O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int maxcount=1;\\n        int count=1;    //since a single digit will also be counted as an ans subsequence\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n                maxcount=Math.max(maxcount, count);\\n            }\\n            else count=1;   //since a single digit will also be counted as an ans subsequence\\n        }\\n        return maxcount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int maxcount=1;\\n        int count=1;    //since a single digit will also be counted as an ans subsequence\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n                maxcount=Math.max(maxcount, count);\\n            }\\n            else count=1;   //since a single digit will also be counted as an ans subsequence\\n        }\\n        return maxcount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027791,
                "title": "simple-beginner-s-friendly-code",
                "content": "# Intuition\\n*First we find the longest sequence till where the array is monotonically increasing*\\n# Approach\\n*Find the maximum longest sequence and store it in the variable until you don\\'t get the longest sequence bigger than that*\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         if (nums.empty()) return 0; // Handle empty input case\\n    int maxLen = 1; // Initialize the maximum length to 1 (minimum possible)\\n    int currentLen = 1; // Initialize the current length to 1\\n    \\n    for (int i = 0; i < nums.size() - 1; i++) {\\n        if (nums[i] < nums[i + 1]) {\\n            currentLen++;\\n            maxLen = max(maxLen, currentLen); // Update the maximum length\\n        } else {\\n            currentLen = 1; // Reset the current length\\n        }\\n    }\\n    \\n    return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         if (nums.empty()) return 0; // Handle empty input case\\n    int maxLen = 1; // Initialize the maximum length to 1 (minimum possible)\\n    int currentLen = 1; // Initialize the current length to 1\\n    \\n    for (int i = 0; i < nums.size() - 1; i++) {\\n        if (nums[i] < nums[i + 1]) {\\n            currentLen++;\\n            maxLen = max(maxLen, currentLen); // Update the maximum length\\n        } else {\\n            currentLen = 1; // Reset the current length\\n        }\\n    }\\n    \\n    return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027409,
                "title": "c-0-ms-100-faster-easy-to-understand-o-n",
                "content": "![leetcode-647.png](https://assets.leetcode.com/users/images/ee170410-2973-464f-978f-11f2dbca0929_1694358397.134127.png)\\n# Approach\\nTHe code initializes two volatile integer variables, \"l\" and \"m,\" with values. \"l\" is set to the size of the input vector \"nums\" minus 1, and \"m\" is set to 1. Additionally, it initializes a variable \"c\" with a value of 1.\\n\\nIt enters a for loop that iterates through the elements of the \"nums\" vector from index 0 to \"l-1.\"\\n\\nInside the loop, it checks if the current element at index \"i\" is less than the next element at index \"i+1.\" If this condition is true, it increments the \"c\" variable by 1, indicating the increasing subsequence length.\\n\\nIf the condition is false, it means the current subsequence has ended, and it updates the \"m\" variable with the maximum of its current value and the \"c\" variable (keeping track of the maximum increasing subsequence length found so far), and then resets \"c\" to 1 for the next potential increasing subsequence.\\n\\nAfter the loop finishes, it ensures that the \"m\" variable is updated one final time by taking the maximum of its current value and the \"c\" variable.\\n\\nFinally, the method returns the value of \"m,\" which represents the length of the longest continuous increasing subsequence in the \"nums\" vector.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        volatile int l = nums.size() - 1;\\n        volatile int m = 1,c = 1;\\n        for (int i = 0; i < l ; i++){\\n            if(nums[i] < nums[i+1])\\n                c += 1;\\n            else{\\n                m = max(c,m);\\n                c = 1;\\n            }\\n        }\\n        m = max(c,m);\\n        return m;\\n    }\\n};\\n```\\n![please upvote.jpg](https://assets.leetcode.com/users/images/369a6654-88b7-4f64-bb0d-1091a4c37629_1694358417.1025085.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        volatile int l = nums.size() - 1;\\n        volatile int m = 1,c = 1;\\n        for (int i = 0; i < l ; i++){\\n            if(nums[i] < nums[i+1])\\n                c += 1;\\n            else{\\n                m = max(c,m);\\n                c = 1;\\n            }\\n        }\\n        m = max(c,m);\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026778,
                "title": "1ms-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = Integer.MIN_VALUE, j = 0;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                if (max < i - j) {\\n                    max = i - j;\\n                }\\n                j = i;\\n            }\\n        }\\n\\n        return Math.max(max, nums.length - j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = Integer.MIN_VALUE, j = 0;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                if (max < i - j) {\\n                    max = i - j;\\n                }\\n                j = i;\\n            }\\n        }\\n\\n        return Math.max(max, nums.length - j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023717,
                "title": "simple-java-solution-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1,c1=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1])\\n                c++;\\n            else{\\n                if(c>c1)\\n                    c1=c;\\n                c=1;\\n                continue;\\n            }\\n        }\\n        return Math.max(c,c1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1,c1=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1])\\n                c++;\\n            else{\\n                if(c>c1)\\n                    c1=c;\\n                c=1;\\n                continue;\\n            }\\n        }\\n        return Math.max(c,c1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022896,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        int c=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=0;\\n            }\\n            if(max<c){\\n                max=c;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        int c=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=0;\\n            }\\n            if(max<c){\\n                max=c;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020423,
                "title": "elixir-reduce-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec find_length_of_lcis(nums :: [integer]) :: integer\\n  def find_length_of_lcis([h | t] = _nums) do\\n    t\\n    |> Enum.reduce([seq: [h], max: 0], fn num, seq: seq, max: max_length ->\\n      if num > hd(seq) do\\n        [seq: [num | seq], max: max_length]\\n      else\\n        [seq: [num], max: max(max_length, length(seq))]\\n      end\\n    end)\\n    |> then(fn seq: seq, max: max_length -> max(max_length, length(seq)) end)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_length_of_lcis(nums :: [integer]) :: integer\\n  def find_length_of_lcis([h | t] = _nums) do\\n    t\\n    |> Enum.reduce([seq: [h], max: 0], fn num, seq: seq, max: max_length ->\\n      if num > hd(seq) do\\n        [seq: [num | seq], max: max_length]\\n      else\\n        [seq: [num], max: max(max_length, length(seq))]\\n      end\\n    end)\\n    |> then(fn seq: seq, max: max_length -> max(max_length, length(seq)) end)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4013714,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findLengthOfLCIS = function(nums) {\\n    \\n    let maxCount = 1\\n    \\n    let count = 1\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {\\n            count++\\n            maxCount = Math.max(maxCount, count)\\n        } else {\\n            count = 1\\n        }\\n    }\\n    \\n    return maxCount\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findLengthOfLCIS = function(nums) {\\n    \\n    let maxCount = 1\\n    \\n    let count = 1\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {\\n            count++\\n            maxCount = Math.max(maxCount, count)\\n        } else {\\n            count = 1\\n        }\\n    }\\n    \\n    return maxCount\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013306,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n), n = length of the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n\\n        int left =0;\\n        int length = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n               length= Math.max(length, ((i+1)-left+1));\\n            }\\n            else\\n            {\\n                left=i+1;\\n            }\\n\\n        }\\n\\n        return length;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n\\n        int left =0;\\n        int length = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n               length= Math.max(length, ((i+1)-left+1));\\n            }\\n            else\\n            {\\n                left=i+1;\\n            }\\n\\n        }\\n\\n        return length;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010370,
                "title": "c-basic-solutoin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        vector<int> res;\\n        int ans=1;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]<nums[i]){\\n                ans+=1;\\n            } else{\\n                res.push_back(ans);\\n                ans=1;\\n            }\\n        }\\n        res.push_back(ans);\\n        int mx=INT_MIN;\\n        // int mx=0;\\n        for(int i=0; i<res.size(); i++){\\n            mx=max(mx, res[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        vector<int> res;\\n        int ans=1;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]<nums[i]){\\n                ans+=1;\\n            } else{\\n                res.push_back(ans);\\n                ans=1;\\n            }\\n        }\\n        res.push_back(ans);\\n        int mx=INT_MIN;\\n        // int mx=0;\\n        for(int i=0; i<res.size(); i++){\\n            mx=max(mx, res[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007939,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfunc findLengthOfLCIS(_ nums: [Int]) -> Int {\\n    guard nums.count != 1 else {return 1}\\n\\n    var count = 1\\n    var max = 0\\n    \\n    for i in 0...nums.count - 2 {\\n        if nums[i] < nums[i + 1] {\\n            count += 1\\n        } else {\\n            if max < count {\\n                max = count\\n            }\\n            count = 1\\n        }\\n    }\\n    \\n    return count < max ? max : count\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\nfunc findLengthOfLCIS(_ nums: [Int]) -> Int {\\n    guard nums.count != 1 else {return 1}\\n\\n    var count = 1\\n    var max = 0\\n    \\n    for i in 0...nums.count - 2 {\\n        if nums[i] < nums[i + 1] {\\n            count += 1\\n        } else {\\n            if max < count {\\n                max = count\\n            }\\n            count = 1\\n        }\\n    }\\n    \\n    return count < max ? max : count\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003551,
                "title": "beats-99-java-easy-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int max =1;\\n        int c = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                if(c>max)\\n                {\\n                    max = c;\\n                }\\n                c = 1;\\n            }\\n        }\\n        return Math.max(c,max);\\n        //return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int max =1;\\n        int c = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                if(c>max)\\n                {\\n                    max = c;\\n                }\\n                c = 1;\\n            }\\n        }\\n        return Math.max(c,max);\\n        //return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990842,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int FindLengthOfLCIS(int[] nums)\\n    {\\n        if (nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        var max = 1;\\n        var cur = 1;\\n\\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i] > nums[i - 1])\\n            {\\n                cur++;\\n            }\\n            else\\n            {\\n                max = Math.Max(max, cur);\\n                cur = 1;\\n            }\\n        }\\n\\n        return Math.Max(max, cur);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int FindLengthOfLCIS(int[] nums)\\n    {\\n        if (nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        var max = 1;\\n        var cur = 1;\\n\\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i] > nums[i - 1])\\n            {\\n                cur++;\\n            }\\n            else\\n            {\\n                max = Math.Max(max, cur);\\n                cur = 1;\\n            }\\n        }\\n\\n        return Math.Max(max, cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989764,
                "title": "beats-98-53-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1;\\n        int max=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                c++;\\n            }else{\\n                c=1;\\n            }\\n            max=Math.max(max,c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1;\\n        int max=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                c++;\\n            }else{\\n                c=1;\\n            }\\n            max=Math.max(max,c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988831,
                "title": "solved-in-tc-o-n-and-sc-1",
                "content": "# Intuition\\nThe problem asks to find the LCS. The idea is to calculate the size of each LCS and replace if found the max.\\n\\n# Approach\\nIterate over array while keeping two variables. One to store final result and other to replace final result if found max LCS. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int result = 1;\\n        int size = 1;\\n        for (int i =0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1]){\\n               size++;\\n            } else {\\n                size=1;\\n            }\\n            result = Math.max(result, size);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int result = 1;\\n        int size = 1;\\n        for (int i =0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1]){\\n               size++;\\n            } else {\\n                size=1;\\n            }\\n            result = Math.max(result, size);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985701,
                "title": "beats-99-at-time-o-1-space-complexity",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSLIDING WINDOW TECHNIQUE \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1)  return 1;\\n        int max=INT_MIN;\\n        int start=0;\\n        int end=0;\\n\\n        while(end<nums.size()-1){   \\n            if(nums[end+1]>nums[end])   end++;\\n            else{\\n                if(max<end-start+1) max=end-start+1;\\n                start=end+1;\\n                end++;\\n            }\\n        }\\n        if(max<end-start+1 && end==nums.size()-1)  max=end-start+1;\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1)  return 1;\\n        int max=INT_MIN;\\n        int start=0;\\n        int end=0;\\n\\n        while(end<nums.size()-1){   \\n            if(nums[end+1]>nums[end])   end++;\\n            else{\\n                if(max<end-start+1) max=end-start+1;\\n                start=end+1;\\n                end++;\\n            }\\n        }\\n        if(max<end-start+1 && end==nums.size()-1)  max=end-start+1;\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978882,
                "title": "accepted-solution-for-java-beats-100-online-submissions",
                "content": "![Screenshot 2023-08-30 at 9.51.48 AM.png](https://assets.leetcode.com/users/images/6f1fa2a8-20c2-4e57-ba14-39f39d9d46eb_1693369341.5921452.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int cnt=1,max=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            if(max<cnt)\\n                max=cnt;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int cnt=1,max=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            if(max<cnt)\\n                max=cnt;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572264,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1568768,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1794823,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 2017717,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1985892,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1765586,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1662311,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            }
        ]
    },
    {
        "title": "Cut Off Trees for Golf Event",
        "question_content": "<p>You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an <code>m x n</code> matrix. In this matrix:</p>\n\n<ul>\n\t<li><code>0</code> means the cell cannot be walked through.</li>\n\t<li><code>1</code> represents an empty cell that can be walked through.</li>\n\t<li>A number greater than <code>1</code> represents a tree in a cell that can be walked through, and this number is the tree&#39;s height.</li>\n</ul>\n\n<p>In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.</p>\n\n<p>You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes <code>1</code> (an empty cell).</p>\n\n<p>Starting from the point <code>(0, 0)</code>, return <em>the minimum steps you need to walk to cut off all the trees</em>. If you cannot cut off all the trees, return <code>-1</code>.</p>\n\n<p><strong>Note:</strong> The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> forest = [[1,2,3],[0,0,4],[7,6,5]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> forest = [[1,2,3],[0,0,0],[7,6,5]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The trees in the bottom row cannot be accessed as the middle row is blocked.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> forest = [[2,3,4],[0,0,5],[8,7,6]]\n<strong>Output:</strong> 6\n<b>Explanation:</b> You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == forest.length</code></li>\n\t<li><code>n == forest[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= forest[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>Heights of all trees are <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 107404,
                "title": "java-solution-priorityqueue-bfs",
                "content": "1. Since we have to cut trees in order of their height, we first put trees (int[] {row, col, height}) into a priority queue and sort by height.\\n2. Poll each tree from the queue and use BFS to find out steps needed.\\n\\nThe worst case time complexity could be O(m^2 * n^2) (m = number of rows, n = number of columns) since there are m * n trees and for each BFS worst case time complexity is O(m * n) too.\\n```\\nclass Solution {\\n    static int[][] dir = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0) return 0;\\n        int m = forest.size(), n = forest.get(0).size();\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (forest.get(i).get(j) > 1) {\\n                    pq.add(new int[] {i, j, forest.get(i).get(j)});\\n                }\\n            }\\n        }\\n\\n        int[] start = new int[2];\\n        int sum = 0;\\n        while (!pq.isEmpty()) {\\n            int[] tree = pq.poll();\\n            int step = minStep(forest, start, tree, m, n);\\n\\n            if (step < 0) return -1;\\n            sum += step;\\n\\n            start[0] = tree[0];\\n            start[1] = tree[1];\\n        }\\n\\n        return sum;\\n    }\\n\\n    private int minStep(List<List<Integer>> forest, int[] start, int[] tree, int m, int n) {\\n        int step = 0;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(start);\\n        visited[start[0]][start[1]] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.poll();\\n                if (curr[0] == tree[0] && curr[1] == tree[1]) return step;\\n\\n                for (int[] d : dir) {\\n                    int nr = curr[0] + d[0];\\n                    int nc = curr[1] + d[1];\\n                    if (nr < 0 || nr >= m || nc < 0 || nc >= n \\n                        || forest.get(nr).get(nc) == 0 || visited[nr][nc]) continue;\\n                    queue.add(new int[] {nr, nc});\\n                    visited[nr][nc] = true;\\n                }\\n            }\\n            step++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int[][] dir = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0) return 0;\\n        int m = forest.size(), n = forest.get(0).size();\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (forest.get(i).get(j) > 1) {\\n                    pq.add(new int[] {i, j, forest.get(i).get(j)});\\n                }\\n            }\\n        }\\n\\n        int[] start = new int[2];\\n        int sum = 0;\\n        while (!pq.isEmpty()) {\\n            int[] tree = pq.poll();\\n            int step = minStep(forest, start, tree, m, n);\\n\\n            if (step < 0) return -1;\\n            sum += step;\\n\\n            start[0] = tree[0];\\n            start[1] = tree[1];\\n        }\\n\\n        return sum;\\n    }\\n\\n    private int minStep(List<List<Integer>> forest, int[] start, int[] tree, int m, int n) {\\n        int step = 0;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(start);\\n        visited[start[0]][start[1]] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.poll();\\n                if (curr[0] == tree[0] && curr[1] == tree[1]) return step;\\n\\n                for (int[] d : dir) {\\n                    int nr = curr[0] + d[0];\\n                    int nc = curr[1] + d[1];\\n                    if (nr < 0 || nr >= m || nc < 0 || nc >= n \\n                        || forest.get(nr).get(nc) == 0 || visited[nr][nc]) continue;\\n                    queue.add(new int[] {nr, nc});\\n                    visited[nr][nc] = true;\\n                }\\n            }\\n            step++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148729,
                "title": "logical-thinking-with-java-code-beats-98-04",
                "content": "**Logical Thinking**\\nSince we always cut off the tree with lowest height first, we collect all trees and sort them by heights. \\nIf we **make sure we walk the minimum steps to cut off each tree**, the sum of these minimum steps will be the final answer.\\nFor cutting each tree `(aimX, aimY)`, we implement BFS once:\\n**Start point**: `(curX, curY)`\\n**Aim point**: `(aimX, aimY)`\\n**End point**: `(aimX, aimY)` or `we have no way out`.\\n**Transition**:  we try advancing by one step in 4 directions.\\n\\n**Clear Java Code**\\n```\\n    private static int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n\\n        List<int[]> treeHeights = getAllTreeHights(forest);\\n        Collections.sort(treeHeights, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[2] - o2[2];\\n            }\\n        });\\n        int minSteps = 0;\\n        int curX = 0, curY = 0;\\n        while (!treeHeights.isEmpty()) {\\n            int[] curTree = treeHeights.remove(0);\\n            int steps = getMinimumSteps(forest, curX, curY, curTree[0], curTree[1]);\\n            if (steps == -1) {\\n                return -1;\\n            }\\n            minSteps += steps;\\n            curX = curTree[0];\\n            curY = curTree[1];\\n            forest.get(curX).set(curY, 1);\\n        }\\n        return minSteps;\\n    }\\n\\n    private int getMinimumSteps(List<List<Integer>> forest, int curX, int curY, int aimX, int aimY) {\\n\\n        int minSteps = 0;\\n        int rows = forest.size(), cols = forest.get(0).size();\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        Queue<int[]> queue = new LinkedList<>();\\n        int startVal = forest.get(curX).get(curY);\\n        queue.offer(new int[]{curX, curY});\\n        visited[curX][curY] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] curCell = queue.poll();\\n                if (curCell[0] == aimX && curCell[1] == aimY) {\\n                    return minSteps;\\n                }\\n                for (int[] direction : directions) {\\n                    int nx = curCell[0] + direction[0];\\n                    int ny = curCell[1] + direction[1];\\n                    if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny] && forest.get(nx).get(ny) != 0) {\\n                        queue.add(new int[]{nx, ny});\\n                        visited[nx][ny] = true;\\n                    }\\n                }\\n            }\\n            minSteps++;\\n        }\\n        return -1;\\n    }\\n\\n    private List<int[]> getAllTreeHights(List<List<Integer>> forest) {\\n        List<int[]> treeHeights = new LinkedList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(0).size(); j++) {\\n                int tmpVal = forest.get(i).get(j);\\n                if (tmpVal > 1) {\\n                    int[] element = new int[3];\\n                    element[0] = i;\\n                    element[1] = j;\\n                    element[2] = tmpVal;\\n                    treeHeights.add(element);\\n                }\\n            }\\n        }\\n        return treeHeights;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    private static int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n\\n        List<int[]> treeHeights = getAllTreeHights(forest);\\n        Collections.sort(treeHeights, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[2] - o2[2];\\n            }\\n        });\\n        int minSteps = 0;\\n        int curX = 0, curY = 0;\\n        while (!treeHeights.isEmpty()) {\\n            int[] curTree = treeHeights.remove(0);\\n            int steps = getMinimumSteps(forest, curX, curY, curTree[0], curTree[1]);\\n            if (steps == -1) {\\n                return -1;\\n            }\\n            minSteps += steps;\\n            curX = curTree[0];\\n            curY = curTree[1];\\n            forest.get(curX).set(curY, 1);\\n        }\\n        return minSteps;\\n    }\\n\\n    private int getMinimumSteps(List<List<Integer>> forest, int curX, int curY, int aimX, int aimY) {\\n\\n        int minSteps = 0;\\n        int rows = forest.size(), cols = forest.get(0).size();\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        Queue<int[]> queue = new LinkedList<>();\\n        int startVal = forest.get(curX).get(curY);\\n        queue.offer(new int[]{curX, curY});\\n        visited[curX][curY] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] curCell = queue.poll();\\n                if (curCell[0] == aimX && curCell[1] == aimY) {\\n                    return minSteps;\\n                }\\n                for (int[] direction : directions) {\\n                    int nx = curCell[0] + direction[0];\\n                    int ny = curCell[1] + direction[1];\\n                    if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny] && forest.get(nx).get(ny) != 0) {\\n                        queue.add(new int[]{nx, ny});\\n                        visited[nx][ny] = true;\\n                    }\\n                }\\n            }\\n            minSteps++;\\n        }\\n        return -1;\\n    }\\n\\n    private List<int[]> getAllTreeHights(List<List<Integer>> forest) {\\n        List<int[]> treeHeights = new LinkedList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(0).size(); j++) {\\n                int tmpVal = forest.get(i).get(j);\\n                if (tmpVal > 1) {\\n                    int[] element = new int[3];\\n                    element[0] = i;\\n                    element[1] = j;\\n                    element[2] = tmpVal;\\n                    treeHeights.add(element);\\n                }\\n            }\\n        }\\n        return treeHeights;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107396,
                "title": "python-solution-based-on-wufangjie-s-hadlock-s-algorithm",
                "content": "Just my own very similar implementation of @wufangjie's [solution](https://discuss.leetcode.com/topic/103532/my-python-solution-inspired-by-a-algorithm) (and some terminology from the Hadlock algorithm which @awice mentioned to me), with some more explanation. Gets accepted in about 700 ms.\\n\\nBasically find the trees, sort them by order, find the distance from each tree to the next, and sum those distances. But how to find the distance from one cell to some other cell? BFS is far to slow for the current test suite. Instead use what's apparently known as \"Hadlock's Algorithm\" (though I've only seen high-level descriptions of that). First try paths with no detour (only try steps in the direction towards the goal), then if necessary try paths with one detour step, then paths with two detour steps, etc. The distance then is the Manhattan distance plus twice the number of detour steps (twice because you'll have to make up for a detour step with a later step back towards the goal).\\n\\nHow to implement that?\\n- Round 1: Run a DFS only on cells that you can reach from the start cell with no detour towards the goal, i.e., only walking in the direction towards the goal. If this reaches the goal, we're done. Otherwise...\\n- Round 2: Try again, but this time try starting from all those cells reachable with one detour step. Collect these in round 1.\\n- Round 3: If round 2 fails, try again but start from all those cells reachable with two detour steps. Collect these in round 2.\\n- And so on...\\n\\nIf there are no obstacles, then this directly walks a shortest path towards the goal, which is of course very fast. Much better than BFS which would waste time looking in all directions. With only a few obstacles, it's still close to optimal.\\n\\nMy `distance` function does this searching algorithm. I keep the current to-be-searched cells in my `now` stack. When I move to a neighbor that's closer to the goal, I also put it in `now`. If it's not closer, then that's a detour step so I just remember it on my `soon` stack for the next round.\\n\\n    def cutOffTree(self, forest):\\n\\n        # Add sentinels (a border of zeros) so we don't need index-checks later on.\\n        forest.append([0] * len(forest[0]))\\n        for row in forest:\\n            row.append(0)\\n\\n        # Find the trees.\\n        trees = [(height, i, j)\\n                 for i, row in enumerate(forest)\\n                 for j, height in enumerate(row)\\n                 if height > 1]\\n\\n        # Can we reach every tree? If not, return -1 right away.\\n        queue = [(0, 0)]\\n        reached = set()\\n        for i, j in queue:\\n            if (i, j) not in reached and forest[i][j]:\\n                reached.add((i, j))\\n                queue += (i+1, j), (i-1, j), (i, j+1), (i, j-1)\\n        if not all((i, j) in reached for (_, i, j) in trees):\\n            return -1\\n\\n        # Distance from (i, j) to (I, J).\\n        def distance(i, j, I, J):\\n            now, soon = [(i, j)], []\\n            expanded = set()\\n            manhattan = abs(i - I) + abs(j - J)\\n            detours = 0\\n            while True:\\n                if not now:\\n                    now, soon = soon, []\\n                    detours += 1\\n                i, j = now.pop()\\n                if (i, j) == (I, J):\\n                    return manhattan + 2 * detours\\n                if (i, j) not in expanded:\\n                    expanded.add((i, j))\\n                    for i, j, closer in (i+1, j, i < I), (i-1, j, i > I), (i, j+1, j < J), (i, j-1, j > J):\\n                        if forest[i][j]:\\n                            (now if closer else soon).append((i, j))\\n\\n        # Sum the distances from one tree to the next (sorted by height).\\n        trees.sort()\\n        return sum(distance(i, j, I, J) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees))",
                "solutionTags": [],
                "code": "Just my own very similar implementation of @wufangjie's [solution](https://discuss.leetcode.com/topic/103532/my-python-solution-inspired-by-a-algorithm) (and some terminology from the Hadlock algorithm which @awice mentioned to me), with some more explanation. Gets accepted in about 700 ms.\\n\\nBasically find the trees, sort them by order, find the distance from each tree to the next, and sum those distances. But how to find the distance from one cell to some other cell? BFS is far to slow for the current test suite. Instead use what's apparently known as \"Hadlock's Algorithm\" (though I've only seen high-level descriptions of that). First try paths with no detour (only try steps in the direction towards the goal), then if necessary try paths with one detour step, then paths with two detour steps, etc. The distance then is the Manhattan distance plus twice the number of detour steps (twice because you'll have to make up for a detour step with a later step back towards the goal).\\n\\nHow to implement that?\\n- Round 1: Run a DFS only on cells that you can reach from the start cell with no detour towards the goal, i.e., only walking in the direction towards the goal. If this reaches the goal, we're done. Otherwise...\\n- Round 2: Try again, but this time try starting from all those cells reachable with one detour step. Collect these in round 1.\\n- Round 3: If round 2 fails, try again but start from all those cells reachable with two detour steps. Collect these in round 2.\\n- And so on...\\n\\nIf there are no obstacles, then this directly walks a shortest path towards the goal, which is of course very fast. Much better than BFS which would waste time looking in all directions. With only a few obstacles, it's still close to optimal.\\n\\nMy `distance` function does this searching algorithm. I keep the current to-be-searched cells in my `now` stack. When I move to a neighbor that's closer to the goal, I also put it in `now`. If it's not closer, then that's a detour step so I just remember it on my `soon` stack for the next round.\\n\\n    def cutOffTree(self, forest):\\n\\n        # Add sentinels (a border of zeros) so we don't need index-checks later on.\\n        forest.append([0] * len(forest[0]))\\n        for row in forest:\\n            row.append(0)\\n\\n        # Find the trees.\\n        trees = [(height, i, j)\\n                 for i, row in enumerate(forest)\\n                 for j, height in enumerate(row)\\n                 if height > 1]\\n\\n        # Can we reach every tree? If not, return -1 right away.\\n        queue = [(0, 0)]\\n        reached = set()\\n        for i, j in queue:\\n            if (i, j) not in reached and forest[i][j]:\\n                reached.add((i, j))\\n                queue += (i+1, j), (i-1, j), (i, j+1), (i, j-1)\\n        if not all((i, j) in reached for (_, i, j) in trees):\\n            return -1\\n\\n        # Distance from (i, j) to (I, J).\\n        def distance(i, j, I, J):\\n            now, soon = [(i, j)], []\\n            expanded = set()\\n            manhattan = abs(i - I) + abs(j - J)\\n            detours = 0\\n            while True:\\n                if not now:\\n                    now, soon = soon, []\\n                    detours += 1\\n                i, j = now.pop()\\n                if (i, j) == (I, J):\\n                    return manhattan + 2 * detours\\n                if (i, j) not in expanded:\\n                    expanded.add((i, j))\\n                    for i, j, closer in (i+1, j, i < I), (i-1, j, i > I), (i, j+1, j < J), (i, j-1, j > J):\\n                        if forest[i][j]:\\n                            (now if closer else soon).append((i, j))\\n\\n        # Sum the distances from one tree to the next (sorted by height).\\n        trees.sort()\\n        return sum(distance(i, j, I, J) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees))",
                "codeTag": "Python3"
            },
            {
                "id": 107403,
                "title": "c-sort-bfs-with-explanation",
                "content": "The solution has two steps:\\n```\\n1) Sort tree positions based on tree height; \\n2) BFS to find shortest path between two points; \\n```\\nThe end point of current path is the starting point of next path. Priority_queue also works, but may be slower than simple sort due to both push and pop operations.\\n\\nThe run time is up to O(m^2 n^2) where m and n is the matrix size. \\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if (forest.empty() || forest[0].empty()) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        vector<vector<int>> trees;\\n        // get all the tree positions and sort based on height\\n        // trees[i][0] is height. The default comparison of vector compare first element before other elements.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (forest[i][j] > 1) trees.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        sort(trees.begin(), trees.end());\\n        int ans = 0;\\n        // accumulate all the paths\\n        for (int i = 0, cur_row = 0, cur_col = 0; i < trees.size(); i++) {\\n            int step = next_step(forest, cur_row, cur_col, trees[i][1], trees[i][2]);\\n            // if next tree cannot be reached, step = -1;\\n            if (step == -1) return -1;\\n            ans += step;\\n            cur_row = trees[i][1];\\n            cur_col = trees[i][2];\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // BFS to find shortest path to next tree; if cannot reach next tree, return -1\\n    int next_step(vector<vector<int>>& forest, int sr, int sc, int er, int ec) {\\n        if (sr == er && sc == ec) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        queue<pair<int, int>> myq;\\n        myq.push({sr, sc}); \\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        visited[sr][sc] = 1;\\n        int step = 0;\\n        vector<int> dir = {-1, 0, 1, 0, -1};\\n        while (!myq.empty()) {\\n            step++;\\n            int sz = myq.size();\\n            for (int i = 0; i < sz; i++) {\\n                int row = myq.front().first, col = myq.front().second;\\n                myq.pop();\\n                for (int i = 0; i < 4; i++) {\\n                    int r = row + dir[i], c = col + dir[i+1];\\n                    if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] == 1 || forest[r][c] == 0) continue;\\n                    if (r == er && c == ec) return step;\\n                    visited[r][c] = 1;\\n                    myq.push({r, c});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1) Sort tree positions based on tree height; \\n2) BFS to find shortest path between two points; \\n```\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if (forest.empty() || forest[0].empty()) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        vector<vector<int>> trees;\\n        // get all the tree positions and sort based on height\\n        // trees[i][0] is height. The default comparison of vector compare first element before other elements.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (forest[i][j] > 1) trees.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        sort(trees.begin(), trees.end());\\n        int ans = 0;\\n        // accumulate all the paths\\n        for (int i = 0, cur_row = 0, cur_col = 0; i < trees.size(); i++) {\\n            int step = next_step(forest, cur_row, cur_col, trees[i][1], trees[i][2]);\\n            // if next tree cannot be reached, step = -1;\\n            if (step == -1) return -1;\\n            ans += step;\\n            cur_row = trees[i][1];\\n            cur_col = trees[i][2];\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // BFS to find shortest path to next tree; if cannot reach next tree, return -1\\n    int next_step(vector<vector<int>>& forest, int sr, int sc, int er, int ec) {\\n        if (sr == er && sc == ec) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        queue<pair<int, int>> myq;\\n        myq.push({sr, sc}); \\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        visited[sr][sc] = 1;\\n        int step = 0;\\n        vector<int> dir = {-1, 0, 1, 0, -1};\\n        while (!myq.empty()) {\\n            step++;\\n            int sz = myq.size();\\n            for (int i = 0; i < sz; i++) {\\n                int row = myq.front().first, col = myq.front().second;\\n                myq.pop();\\n                for (int i = 0; i < 4; i++) {\\n                    int r = row + dir[i], c = col + dir[i+1];\\n                    if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] == 1 || forest[r][c] == 0) continue;\\n                    if (r == er && c == ec) return step;\\n                    visited[r][c] = 1;\\n                    myq.push({r, c});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107416,
                "title": "very-simple-python-bfs-but-why-tle",
                "content": "I thought it is a straightforward BFS search, so I write it like the following. \\nActually, I have the same question with `Number of Island` problem:\\nhttps://discuss.leetcode.com/topic/88586/why-python-bfs-get-time-exceed-error\\n\\n\\n```\\nimport collections\\nclass Solution(object):\\n    def cutOffTree(self, G):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not G or not G[0]: return -1\\n        m, n = len(G), len(G[0])\\n        trees = []\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if G[i][j] > 1:\\n                    trees.append((G[i][j], i, j))\\n        trees = sorted(trees)\\n        count = 0\\n        cx, cy = 0, 0\\n        for h, x, y in trees:\\n            step = self.BFS(G, cx, cy, x, y)\\n            if step == -1:\\n                return -1\\n            else:\\n                count += step\\n                G[x][y] = 1\\n                cx, cy = x, y\\n        return count\\n\\n    def BFS(self, G, cx, cy, tx, ty):\\n        m, n = len(G), len(G[0])\\n        visited = [[False for j in xrange(n)] for i in xrange(m)]\\n        Q = collections.deque()\\n        step = -1\\n        Q.append((cx, cy))\\n        while len(Q) > 0:\\n            size = len(Q)\\n            step += 1\\n            for i in xrange(size):\\n                x, y = Q.popleft()\\n                visited[x][y] = True\\n                if x == tx and y == ty:\\n                    return step\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y-1), (x, y + 1)]:\\n                    if nx < 0 or nx >= m or ny < 0 or ny >= n or G[nx][ny] == 0 or visited[nx][ny]:\\n                        continue\\n                    Q.append((nx, ny))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution(object):\\n    def cutOffTree(self, G):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not G or not G[0]: return -1\\n        m, n = len(G), len(G[0])\\n        trees = []\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if G[i][j] > 1:\\n                    trees.append((G[i][j], i, j))\\n        trees = sorted(trees)\\n        count = 0\\n        cx, cy = 0, 0\\n        for h, x, y in trees:\\n            step = self.BFS(G, cx, cy, x, y)\\n            if step == -1:\\n                return -1\\n            else:\\n                count += step\\n                G[x][y] = 1\\n                cx, cy = x, y\\n        return count\\n\\n    def BFS(self, G, cx, cy, tx, ty):\\n        m, n = len(G), len(G[0])\\n        visited = [[False for j in xrange(n)] for i in xrange(m)]\\n        Q = collections.deque()\\n        step = -1\\n        Q.append((cx, cy))\\n        while len(Q) > 0:\\n            size = len(Q)\\n            step += 1\\n            for i in xrange(size):\\n                x, y = Q.popleft()\\n                visited[x][y] = True\\n                if x == tx and y == ty:\\n                    return step\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y-1), (x, y + 1)]:\\n                    if nx < 0 or nx >= m or ny < 0 or ny >= n or G[nx][ny] == 0 or visited[nx][ny]:\\n                        continue\\n                    Q.append((nx, ny))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107415,
                "title": "my-python-solution-inspired-by-a-algorithm",
                "content": "The expected min distance between p1 and p2 is d = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]). \\nFrom p1 (or the following positions), we may have two choices, move a step towards p2 or a step far away from p2 (if we do this, the min distance we can expect is d + 2, so we needn't think about them until all the expected min distance way are blocked). \\nAnd I use stack to find the possible way greedily. \\nHere is my code:\\n```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        nrow, ncol = len(forest), len(forest[0])\\n        forest.append([0] * ncol)\\n        for row in forest:\\n            row.append(0)\\n\\n        trees = {(i, j) for i in range(nrow) for j in range(ncol)\\n                 if forest[i][j] > 1}\\n\\n        canReach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while stack:\\n            i, j = stack.pop()\\n            for i2, j2 in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if forest[i2][j2] != 0 and (i2, j2) not in canReach:\\n                    canReach.add((i2, j2))\\n                    stack.append((i2, j2))\\n\\n        if trees.difference(canReach):\\n            return -1\\n\\n        def get_sp(p1, p2):\\n            theMin = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\\n            stack1, stack2 = [p1], []\\n            used, visited = {p1}, {p1}\\n\\n            while 1:\\n                if not stack1:\\n                    stack1, stack2 = stack2, stack1\\n                    used.update(stack1)\\n                    theMin += 2\\n\\n                p = stack1.pop()\\n                if p == p2:\\n                    break\\n\\n                i, j = p\\n                add1, add2 = [], []\\n\\n                if i == p2[0]:\\n                    add2.append((i - 1, j))\\n                    add2.append((i + 1, j))\\n                elif i < p2[0]:\\n                    add2.append((i - 1, j))\\n                    add1.append((i + 1, j))\\n                else:\\n                    add1.append((i - 1, j))\\n                    add2.append((i + 1, j))\\n\\n                if j == p2[1]:\\n                    add2.append((i, j - 1))\\n                    add2.append((i, j + 1))\\n                elif j < p2[1]:\\n                    add2.append((i, j - 1))\\n                    add1.append((i, j + 1))\\n                else:\\n                    add1.append((i, j - 1))\\n                    add2.append((i, j + 1))\\n\\n                for v in add1:\\n                    if forest[v[0]][v[1]] != 0 and v not in used:\\n                        visited.add(v)\\n                        used.add(v)\\n                        stack1.append(v)\\n                for v in add2:\\n                    if forest[v[0]][v[1]] != 0 and v not in visited:\\n                        visited.add(v)\\n                        stack2.append(v)\\n\\n            return theMin\\n\\n        seq = sorted(trees, key=lambda x: forest[x[0]][x[1]])\\n        if seq[0] != (0, 0):\\n            seq.insert(0, (0, 0))\\n        return sum(get_sp(seq[i], seq[i + 1]) for i in range(len(seq) - 1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        nrow, ncol = len(forest), len(forest[0])\\n        forest.append([0] * ncol)\\n        for row in forest:\\n            row.append(0)\\n\\n        trees = {(i, j) for i in range(nrow) for j in range(ncol)\\n                 if forest[i][j] > 1}\\n\\n        canReach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while stack:\\n            i, j = stack.pop()\\n            for i2, j2 in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if forest[i2][j2] != 0 and (i2, j2) not in canReach:\\n                    canReach.add((i2, j2))\\n                    stack.append((i2, j2))\\n\\n        if trees.difference(canReach):\\n            return -1\\n\\n        def get_sp(p1, p2):\\n            theMin = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\\n            stack1, stack2 = [p1], []\\n            used, visited = {p1}, {p1}\\n\\n            while 1:\\n                if not stack1:\\n                    stack1, stack2 = stack2, stack1\\n                    used.update(stack1)\\n                    theMin += 2\\n\\n                p = stack1.pop()\\n                if p == p2:\\n                    break\\n\\n                i, j = p\\n                add1, add2 = [], []\\n\\n                if i == p2[0]:\\n                    add2.append((i - 1, j))\\n                    add2.append((i + 1, j))\\n                elif i < p2[0]:\\n                    add2.append((i - 1, j))\\n                    add1.append((i + 1, j))\\n                else:\\n                    add1.append((i - 1, j))\\n                    add2.append((i + 1, j))\\n\\n                if j == p2[1]:\\n                    add2.append((i, j - 1))\\n                    add2.append((i, j + 1))\\n                elif j < p2[1]:\\n                    add2.append((i, j - 1))\\n                    add1.append((i, j + 1))\\n                else:\\n                    add1.append((i, j - 1))\\n                    add2.append((i, j + 1))\\n\\n                for v in add1:\\n                    if forest[v[0]][v[1]] != 0 and v not in used:\\n                        visited.add(v)\\n                        used.add(v)\\n                        stack1.append(v)\\n                for v in add2:\\n                    if forest[v[0]][v[1]] != 0 and v not in visited:\\n                        visited.add(v)\\n                        stack2.append(v)\\n\\n            return theMin\\n\\n        seq = sorted(trees, key=lambda x: forest[x[0]][x[1]])\\n        if seq[0] != (0, 0):\\n            seq.insert(0, (0, 0))\\n        return sum(get_sp(seq[i], seq[i + 1]) for i in range(len(seq) - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107398,
                "title": "java-c-straightforward-solution-sorted-array-bfs",
                "content": "My idea to solve this problem is by two steps:\\n1. Save each ```{tree height, tree position}``` into an array ```heights```, and then sort this array based on  its ```tree height```. (You can also do this by using ```TreeMap``` or  ```PriorityQueue```);\\n2. Accumulate the shortest steps between each two adajacent points in ```heights[]```.\\n\\nJava version:\\n```\\nclass Solution {\\n    int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0) return -1;\\n        int m = forest.size(), n = forest.get(0).size(), res = 0;\\n        //first step: sort the tree position based on its height\\n        List<int[]> heights = new ArrayList<>();\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(forest.get(i).get(j) > 1)heights.add( new int[]{forest.get(i).get(j), i, j} );\\n            }\\n        }\\n        Collections.sort(heights, new Comparator<int[]>() {\\n            public int compare(int[] arr1, int[] arr2) {\\n                return Integer.compare(arr1[0], arr2[0]);\\n            }\\n        });\\n        //second step: accumulate the shortest steps between each two adajacent points in heights[].\\n        int start_x = 0, start_y = 0; \\n        for(int i = 0; i<heights.size(); i++){\\n            int cnt_steps = BFS(forest, m, n, start_x, start_y, heights.get(i)[1], heights.get(i)[2]); \\n            if(cnt_steps == -1)return -1;\\n            res += cnt_steps;\\n            start_x = heights.get(i)[1]; \\n            start_y = heights.get(i)[2];\\n        }\\n        return res;\\n    }\\n    \\n    public int BFS(List<List<Integer>> forest, int m, int n, int start_x, int start_y, int des_x, int des_y){\\n        if(start_x == des_x && start_y == des_y)return 0;\\n        int steps = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{start_x, start_y});\\n        int[][] visited = new int[m][n];\\n        visited[start_x][start_y] = 1;\\n        while(!q.isEmpty()){\\n            int qsize = q.size();\\n            steps++;\\n            while(qsize-- >0 ){\\n                int[] cur = q.poll();\\n                int cur_x = cur[0], cur_y = cur[1];\\n                for(int k = 0; k<4; k++){\\n                    int x = cur_x + dir[k][0], y = cur_y + dir[k][1];\\n                    if(x>=0 && x<m && y>=0 && y<n && forest.get(x).get(y) > 0 && visited[x][y] == 0){\\n                        if(x == des_x && y == des_y)return steps;\\n                        visited[x][y] = 1;\\n                        q.add(new int[]{x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nC++ version:\\n```\\nclass Solution {\\npublic:    \\n    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m = forest.size(), n , res = 0;\\n        if(m == 0)return -1;\\n        n = forest[0].size();\\n        //first step: sort the tree position based on its height\\n        vector<vector<int>> heights;\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(forest[i][j] > 1)heights.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        sort(heights.begin(), heights.end());\\n        //second step: accumulate the shortest steps between each two adajacent points in heights[].\\n        int start_x = 0, start_y = 0; \\n        for(int i = 0; i<heights.size(); i++){\\n            int cnt_steps = BFS(forest, m, n, start_x, start_y, heights[i][1], heights[i][2]); \\n            if(cnt_steps == -1)return -1;\\n            res += cnt_steps;\\n            start_x = heights[i][1], start_y = heights[i][2];\\n        }\\n        return res;\\n    }\\n    \\n    int BFS(vector<vector<int>>& forest, int m, int n, int start_x, int start_y, int des_x, int des_y){\\n        if(start_x == des_x && start_y == des_y)return 0;\\n        int steps = 0;\\n        queue<pair<int, int>> q;\\n        q.push({start_x, start_y});\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        visited[start_x][start_y] = 1;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            steps++;\\n            while(qsize-- >0 ){\\n                int cur_x = q.front().first, cur_y = q.front().second;\\n                q.pop();\\n                for(int k = 0; k<4; k++){\\n                    int x = cur_x + dir[k][0], y = cur_y + dir[k][1];\\n                    if(x>=0 && x<m && y>=0 && y<n && forest[x][y] > 0 && visited[x][y] == 0){\\n                        if(x == des_x && y == des_y)return steps;\\n                        visited[x][y] = 1;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```{tree height, tree position}```\n```heights```\n```tree height```\n```TreeMap```\n```PriorityQueue```\n```heights[]```\n```\\nclass Solution {\\n    int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0) return -1;\\n        int m = forest.size(), n = forest.get(0).size(), res = 0;\\n        //first step: sort the tree position based on its height\\n        List<int[]> heights = new ArrayList<>();\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(forest.get(i).get(j) > 1)heights.add( new int[]{forest.get(i).get(j), i, j} );\\n            }\\n        }\\n        Collections.sort(heights, new Comparator<int[]>() {\\n            public int compare(int[] arr1, int[] arr2) {\\n                return Integer.compare(arr1[0], arr2[0]);\\n            }\\n        });\\n        //second step: accumulate the shortest steps between each two adajacent points in heights[].\\n        int start_x = 0, start_y = 0; \\n        for(int i = 0; i<heights.size(); i++){\\n            int cnt_steps = BFS(forest, m, n, start_x, start_y, heights.get(i)[1], heights.get(i)[2]); \\n            if(cnt_steps == -1)return -1;\\n            res += cnt_steps;\\n            start_x = heights.get(i)[1]; \\n            start_y = heights.get(i)[2];\\n        }\\n        return res;\\n    }\\n    \\n    public int BFS(List<List<Integer>> forest, int m, int n, int start_x, int start_y, int des_x, int des_y){\\n        if(start_x == des_x && start_y == des_y)return 0;\\n        int steps = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{start_x, start_y});\\n        int[][] visited = new int[m][n];\\n        visited[start_x][start_y] = 1;\\n        while(!q.isEmpty()){\\n            int qsize = q.size();\\n            steps++;\\n            while(qsize-- >0 ){\\n                int[] cur = q.poll();\\n                int cur_x = cur[0], cur_y = cur[1];\\n                for(int k = 0; k<4; k++){\\n                    int x = cur_x + dir[k][0], y = cur_y + dir[k][1];\\n                    if(x>=0 && x<m && y>=0 && y<n && forest.get(x).get(y) > 0 && visited[x][y] == 0){\\n                        if(x == des_x && y == des_y)return steps;\\n                        visited[x][y] = 1;\\n                        q.add(new int[]{x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:    \\n    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m = forest.size(), n , res = 0;\\n        if(m == 0)return -1;\\n        n = forest[0].size();\\n        //first step: sort the tree position based on its height\\n        vector<vector<int>> heights;\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(forest[i][j] > 1)heights.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        sort(heights.begin(), heights.end());\\n        //second step: accumulate the shortest steps between each two adajacent points in heights[].\\n        int start_x = 0, start_y = 0; \\n        for(int i = 0; i<heights.size(); i++){\\n            int cnt_steps = BFS(forest, m, n, start_x, start_y, heights[i][1], heights[i][2]); \\n            if(cnt_steps == -1)return -1;\\n            res += cnt_steps;\\n            start_x = heights[i][1], start_y = heights[i][2];\\n        }\\n        return res;\\n    }\\n    \\n    int BFS(vector<vector<int>>& forest, int m, int n, int start_x, int start_y, int des_x, int des_y){\\n        if(start_x == des_x && start_y == des_y)return 0;\\n        int steps = 0;\\n        queue<pair<int, int>> q;\\n        q.push({start_x, start_y});\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        visited[start_x][start_y] = 1;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            steps++;\\n            while(qsize-- >0 ){\\n                int cur_x = q.front().first, cur_y = q.front().second;\\n                q.pop();\\n                for(int k = 0; k<4; k++){\\n                    int x = cur_x + dir[k][0], y = cur_y + dir[k][1];\\n                    if(x>=0 && x<m && y>=0 && y<n && forest[x][y] > 0 && visited[x][y] == 0){\\n                        if(x == des_x && y == des_y)return steps;\\n                        visited[x][y] = 1;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295156,
                "title": "a-star-search-algorithm-in-python-3-faster-than-90-solutions",
                "content": "1) Sort the trees by height.\\n2) Sum up the distance between successive trees. I have used A star search algorithm to find the distance between two trees.\\n\\n**Why Astar?**\\nWith BFS you circularly expand the explored area. With DFS, you pick a specific direction and explore in that direction until you reach the end, and then repeat the process. In Astar however, you move in the direction of the destination. The choice of the direction is based on two things. The distance g(n) from the source to current node, and h(n) a heuristic distance between current node and destination. Heuristic is a rough estimate, which can lead to a better solution. Here manhattan distance is used as the heuristic. \\n\\nMathematically, f(n) = g(n) + h(n)\\n\\nUse a priority queue (heap) to keep track of neighbouring nodes with smallest f(n) value and explore in that direction.\\n\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m,n = len(forest), len(forest[0])\\n        tree_order = []\\n        for i in range(m):\\n            for j in range(n):\\n                if(forest[i][j] > 1):\\n                    tree_order.append((forest[i][j],(i,j)))  # (tree height, cordinates)\\n        tree_order.sort()\\n        \\n        def manhattan(s,t):\\n            return abs(s[0] - t[0]) + abs(s[1] - t[1])\\n        \\n        def astar_search_distance(source, target):\\n            pq  = [(manhattan(source, target), 0, source)] # Tuple content: (f= g+h, g, cordinates)\\n            seen = set()\\n            while(pq):\\n                f,d,cur = heapq.heappop(pq)\\n                if(cur == target):\\n                    return d\\n                i,j = cur\\n                # Using for loop here will make the code cleaner, but will have extra boundary checks.\\n                # Adding the cords into seen node while offering to pq, is much faster than adding after polling.\\n                if(j+1<n and (i,j+1) not in seen and forest[i][j+1]!= 0): \\n                    heapq.heappush(pq, (manhattan((i,j+1),target)+d+1, d+1, (i,j+1)))\\n                    seen.add((i,j+1))\\n                if(i+1<m and (i+1,j) not in seen and forest[i+1][j]!= 0): \\n                    heapq.heappush(pq, (manhattan((i+1,j),target)+d+1, d+1, (i+1,j)))\\n                    seen.add((i+1,j))\\n                if(j-1>=0 and (i,j-1) not in seen and forest[i][j-1]!= 0): \\n                    heapq.heappush(pq, (manhattan((i,j-1),target)+d+1, d+1, (i,j-1)))\\n                    seen.add((i,j-1))\\n                if(i-1>=0 and (i-1,j) not in seen and forest[i-1][j]!= 0): \\n                    heapq.heappush(pq, (manhattan((i-1,j),target)+d+1, d+1, (i-1,j)))\\n                    seen.add((i-1,j))\\n                    \\n            return -1\\n\\t\\t\\t\\n        prev = (0,0)\\n        res = 0\\n        for tree in tree_order:\\n            d = astar_search_distance(prev, tree[1])\\n            if(d == -1): break\\n            res += d\\n            prev = tree[1]\\n            \\n        return res if d != -1 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m,n = len(forest), len(forest[0])\\n        tree_order = []\\n        for i in range(m):\\n            for j in range(n):\\n                if(forest[i][j] > 1):\\n                    tree_order.append((forest[i][j],(i,j)))  # (tree height, cordinates)\\n        tree_order.sort()\\n        \\n        def manhattan(s,t):\\n            return abs(s[0] - t[0]) + abs(s[1] - t[1])\\n        \\n        def astar_search_distance(source, target):\\n            pq  = [(manhattan(source, target), 0, source)] # Tuple content: (f= g+h, g, cordinates)\\n            seen = set()\\n            while(pq):\\n                f,d,cur = heapq.heappop(pq)\\n                if(cur == target):\\n                    return d\\n                i,j = cur\\n                # Using for loop here will make the code cleaner, but will have extra boundary checks.\\n                # Adding the cords into seen node while offering to pq, is much faster than adding after polling.\\n                if(j+1<n and (i,j+1) not in seen and forest[i][j+1]!= 0): \\n                    heapq.heappush(pq, (manhattan((i,j+1),target)+d+1, d+1, (i,j+1)))\\n                    seen.add((i,j+1))\\n                if(i+1<m and (i+1,j) not in seen and forest[i+1][j]!= 0): \\n                    heapq.heappush(pq, (manhattan((i+1,j),target)+d+1, d+1, (i+1,j)))\\n                    seen.add((i+1,j))\\n                if(j-1>=0 and (i,j-1) not in seen and forest[i][j-1]!= 0): \\n                    heapq.heappush(pq, (manhattan((i,j-1),target)+d+1, d+1, (i,j-1)))\\n                    seen.add((i,j-1))\\n                if(i-1>=0 and (i-1,j) not in seen and forest[i-1][j]!= 0): \\n                    heapq.heappush(pq, (manhattan((i-1,j),target)+d+1, d+1, (i-1,j)))\\n                    seen.add((i-1,j))\\n                    \\n            return -1\\n\\t\\t\\t\\n        prev = (0,0)\\n        res = 0\\n        for tree in tree_order:\\n            d = astar_search_distance(prev, tree[1])\\n            if(d == -1): break\\n            res += d\\n            prev = tree[1]\\n            \\n        return res if d != -1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604577,
                "title": "briefly-explained-approach",
                "content": "# EXPLANATION:-\\n*    We can only visit the whole tree if we can go from lower to higher value cells.\\n*    Therefore we have to do something like we can go from current cell to next greater cell.\\n*    So we will do something like \\n        1) Sort tree positions based on height of the tree \\n        2) Aplly BFS to find shortest path between two points \\n*  i.e we will first store all the cells in a 2D vector and sort them so that next cell to visit\\n    will be next greater of current cell. \\n* And then we will apply bfs in evry 2 pair of sorted new vector to see if we can reach to every current\\'s next greater or not. \\n* \\tIf in any of the case we cant then return -1 from there only, otherwise keep going.\\n* \\tAnd if we are able to finish all pairs then return total number of steps calculated from every pair.\\n*  Note:- All cell values stored in new array which was sorted after soring all cells values should be greater than 1 (should be a tree).\\n\\n* Example which may help:- [[1,2,3],[9,10,4],[7,6,5]]\\n\\n# CODE:-\\n```\\nclass Solution {\\n    int Solve(vector<vector<int>> &forest, int src_row, int src_col, int dst_row, int dst_col){\\n        int n = forest.size(), m = forest[0].size();\\n        \\n        if(src_row == dst_row && src_col == dst_col) {\\n            return 0;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({src_row, src_col});\\n        \\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        vis[src_row][src_col] = 1;\\n        \\n        int step = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int x = q.front().first, y = q.front().second;\\n                q.pop();\\n                \\n                if(x == dst_row && y == dst_col){\\n                    return step;\\n                }\\n            \\n                int dx[] = {0, -1, 0, 1}, dy[] = {1, 0, -1, 0};\\n            \\n                for(int k=0; k<4; k++){\\n                    int newx = x+dx[k], newy = y+dy[k];\\n                    if(newx>=0 && newy>=0 && newx<n && newy<m){\\n                        if(vis[newx][newy] || !forest[newx][newy]) {\\n                            continue;\\n                        }\\n                        vis[newx][newy] = 1;\\n                        q.push({newx, newy});\\n                    }\\n                }\\n            }\\n            step+=1;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n = forest.size();\\n        int m = forest[0].size();\\n        \\n        vector<vector<int>> trees;\\n        \\n        //storing all trees in a vector and sorting it\\n        //storing in the format of {tree height, position} --> {forest[i], i, j}\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(forest[i][j] > 1) \\n\\t\\t\\t\\t\\ttrees.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        \\n        sort(trees.begin(), trees.end());\\n        \\n        int total_steps = 0;\\n        int src_row = 0, src_col = 0;\\n        for(int i=0; i<trees.size(); i++){\\n            int dst_row = trees[i][1], dst_col = trees[i][2];\\n            \\n            //now bfs to find shorest distance from src to dst\\n            int steps = Solve(forest, src_row, src_col, dst_row, dst_col);\\n            \\n            // if next tree cannot be reached\\n            if(steps == -1) return -1;\\n            \\n            total_steps += steps;\\n            \\n            src_row = trees[i][1];\\n            src_col = trees[i][2];\\n        }\\n        return total_steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int Solve(vector<vector<int>> &forest, int src_row, int src_col, int dst_row, int dst_col){\\n        int n = forest.size(), m = forest[0].size();\\n        \\n        if(src_row == dst_row && src_col == dst_col) {\\n            return 0;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({src_row, src_col});\\n        \\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        vis[src_row][src_col] = 1;\\n        \\n        int step = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int x = q.front().first, y = q.front().second;\\n                q.pop();\\n                \\n                if(x == dst_row && y == dst_col){\\n                    return step;\\n                }\\n            \\n                int dx[] = {0, -1, 0, 1}, dy[] = {1, 0, -1, 0};\\n            \\n                for(int k=0; k<4; k++){\\n                    int newx = x+dx[k], newy = y+dy[k];\\n                    if(newx>=0 && newy>=0 && newx<n && newy<m){\\n                        if(vis[newx][newy] || !forest[newx][newy]) {\\n                            continue;\\n                        }\\n                        vis[newx][newy] = 1;\\n                        q.push({newx, newy});\\n                    }\\n                }\\n            }\\n            step+=1;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n = forest.size();\\n        int m = forest[0].size();\\n        \\n        vector<vector<int>> trees;\\n        \\n        //storing all trees in a vector and sorting it\\n        //storing in the format of {tree height, position} --> {forest[i], i, j}\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(forest[i][j] > 1) \\n\\t\\t\\t\\t\\ttrees.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        \\n        sort(trees.begin(), trees.end());\\n        \\n        int total_steps = 0;\\n        int src_row = 0, src_col = 0;\\n        for(int i=0; i<trees.size(); i++){\\n            int dst_row = trees[i][1], dst_col = trees[i][2];\\n            \\n            //now bfs to find shorest distance from src to dst\\n            int steps = Solve(forest, src_row, src_col, dst_row, dst_col);\\n            \\n            // if next tree cannot be reached\\n            if(steps == -1) return -1;\\n            \\n            total_steps += steps;\\n            \\n            src_row = trees[i][1];\\n            src_col = trees[i][2];\\n        }\\n        return total_steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252424,
                "title": "simple-java-solution-using-bfs-with-comments-and-explanation",
                "content": "The idea is: \\n1.  Create a list of int[] which contains ```x_coordinate, y_coordinate, and height of tree```\\n2.  Add all the trees which have height >1 to the list.\\n3.  Sort the given list based on their height, by using the Comparator class(or simply using Lambda expression from Java8)\\n4.  Then traverse through each tree by using a BFS\\n5.  In the BFS we are checking the distance needed to go to the tree from the current source coordinates(Since we have sorted the trees based on their height, our source coordinates will be different from the tree coordinates)\\nFor eg: Our input is like this [[1,0,0],[1,0,0],[1,1,5]], then\\ni) We have only 1 entry to be traversed, which is ```{x,y,height} = {2,2,5}```\\nii) Once we have sorted the input trees, we are going to apply BFS\\niii) Our source coordinates are (0,0) and our tree coordinates are (2,2) and then using BFS we are going to find out the shortest distance needed to to go from source to destination. \\n\\n\\n```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n        //create a list of int[] {x, y, Height}\\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(0).size(); j++) {\\n                int height = forest.get(i).get(j);\\n                if (height > 1)\\n                    trees.add(new int[]{i, j, height});\\n            }\\n        }\\n        \\n        //Sort all the trees based on their height\\n        Collections.sort(trees, (a, b)->(a[2]-b[2]));\\n        \\n        //Run thru each test tree given to us\\n        int res = 0, x = 0, y = 0;\\n        for (int[] tree: trees) {\\n        //Do a BFS traversal from current location(x,y) to that tree location(tree[0], tree[1])\\n            int dist = bfs(forest, x, y, tree[0], tree[1]);\\n            if (dist < 0) \\n                return -1;\\n            else\\n            {\\n                res = res + dist;\\n                x = tree[0];\\n                y = tree[1];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int bfs(List<List<Integer>> forest, int x, int y, int tx, int ty) \\n    {\\n        //A typical BFS approach that we use\\n        int m = forest.size(), n = forest.get(0).size();\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        //Add the current source coordinates to the queue and mark it as visited\\n        queue.add(new int[]{x, y});\\n        visited[x][y] = true;\\n        \\n        int dist = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n           \\n            for (int j = 0; j < size; j++) {\\n                int[] cur = queue.poll();\\n                \\n                 //If we have reached the tree at (tx,ty) through traversal then that means we can return the distance covered from (x,y) to (tx,ty)\\n                if (cur[0] == tx && cur[1] == ty) \\n                    return dist;\\n                \\n                //Traverse in all 4 directions and then process it if it meets the conditions\\n                for (int i = 0; i < 4; i++) \\n                {\\n                    int nx = cur[0]+dirs[i][0];\\n                    int ny = cur[1]+dirs[i][1];\\n                    \\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && \\n                        !visited[nx][ny] && forest.get(nx).get(ny) >= 1)\\n                    {\\n                      visited[nx][ny] = true;\\n                      queue.add(new int[]{nx, ny});\\n                   }\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```x_coordinate, y_coordinate, and height of tree```\n```{x,y,height} = {2,2,5}```\n```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n        //create a list of int[] {x, y, Height}\\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(0).size(); j++) {\\n                int height = forest.get(i).get(j);\\n                if (height > 1)\\n                    trees.add(new int[]{i, j, height});\\n            }\\n        }\\n        \\n        //Sort all the trees based on their height\\n        Collections.sort(trees, (a, b)->(a[2]-b[2]));\\n        \\n        //Run thru each test tree given to us\\n        int res = 0, x = 0, y = 0;\\n        for (int[] tree: trees) {\\n        //Do a BFS traversal from current location(x,y) to that tree location(tree[0], tree[1])\\n            int dist = bfs(forest, x, y, tree[0], tree[1]);\\n            if (dist < 0) \\n                return -1;\\n            else\\n            {\\n                res = res + dist;\\n                x = tree[0];\\n                y = tree[1];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int bfs(List<List<Integer>> forest, int x, int y, int tx, int ty) \\n    {\\n        //A typical BFS approach that we use\\n        int m = forest.size(), n = forest.get(0).size();\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        //Add the current source coordinates to the queue and mark it as visited\\n        queue.add(new int[]{x, y});\\n        visited[x][y] = true;\\n        \\n        int dist = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n           \\n            for (int j = 0; j < size; j++) {\\n                int[] cur = queue.poll();\\n                \\n                 //If we have reached the tree at (tx,ty) through traversal then that means we can return the distance covered from (x,y) to (tx,ty)\\n                if (cur[0] == tx && cur[1] == ty) \\n                    return dist;\\n                \\n                //Traverse in all 4 directions and then process it if it meets the conditions\\n                for (int i = 0; i < 4; i++) \\n                {\\n                    int nx = cur[0]+dirs[i][0];\\n                    int ny = cur[1]+dirs[i][1];\\n                    \\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && \\n                        !visited[nx][ny] && forest.get(nx).get(ny) >= 1)\\n                    {\\n                      visited[nx][ny] = true;\\n                      queue.add(new int[]{nx, ny});\\n                   }\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143658,
                "title": "how-come-same-python-solution-got-tle-again-again-are-you-kidding-me",
                "content": "Just translated https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-+-BFS into Python. Same time complexity I believe. How come I got TLE again? If you admins really hate python, you should ban python from available languages. \\n\\nremember, I pay 100+ dollars per year not for getting TLE for working out the optimal solution that will pass the actual interview.\\n\\n\\'\\'\\'\\n\\t\\n\\tfrom collections import deque\\n\\n\\tclass Solution(object):\\n\\t    def cutOffTree(self, forest):\\n\\n\\t        if not forest or not forest[0]:\\n\\t            return -1\\n\\t        \\n\\t        # cut the tree in reverse order of tree\\'s height\\n\\t        treeList = []\\n\\t        for i in xrange(len(forest)):\\n\\t            for j in xrange(len(forest[0])):\\n\\t                if forest[i][j] > 1:\\n\\t                    treeList.append([forest[i][j], [i, j]])\\n\\t        treeList.sort()\\n\\t        \\n\\t        totalSteps = self.minStep(forest, [0, 0], treeList[0][1])\\n\\t        k = 0\\n\\t        while k < len(treeList) - 1:\\n\\t            step = self.minStep(forest, treeList[k][1], treeList[k + 1][1])\\n\\t            if step == -1:\\n\\t                return -1\\n\\t            totalSteps += step\\n\\t            k += 1\\n\\t        \\n\\t        return totalSteps\\n\\t    \\n\\t    # do BFS to see if we can find a path from start to end\\n\\t    def minStep(self, forest, start, end):\\n\\t        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\\n\\t        step = 0\\n\\t        m, n = len(forest), len(forest[0])\\n\\t        visited = [[False for x in xrange(n)] for _ in xrange(m)]\\n\\t        visited[start[0]][start[1]] = True\\n\\t        queue = deque()\\n\\t        queue.append(start)\\n\\t        \\n\\t        while queue:\\n\\t            size = len(queue)\\n\\t            for i in xrange(size):\\n\\t                curr = queue.popleft()\\n\\t                if curr == end:\\n\\t                    return step\\n\\t                for direction in directions:\\n\\t                    nextRow = curr[0] + direction[0]\\n\\t                    nextCol = curr[1] + direction[1]\\n\\t                    if nextRow < 0 or nextRow >= m or nextCol < 0 or nextCol >= n or visited[nextRow][nextCol] or forest[nextRow][nextCol] == 0:\\n\\t                        continue\\n\\t                    queue.append([nextRow, nextCol])\\n\\t                    visited[nextRow][nextCol] = True\\n\\t            step += 1\\n\\t            \\n\\t        # here, it means we can never find the destination\\n\\t        return -1\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Just translated https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-+-BFS into Python. Same time complexity I believe. How come I got TLE again? If you admins really hate python, you should ban python from available languages. \\n\\nremember, I pay 100+ dollars per year not for getting TLE for working out the optimal solution that will pass the actual interview.\\n\\n\\'\\'\\'\\n\\t\\n\\tfrom collections import deque\\n\\n\\tclass Solution(object):\\n\\t    def cutOffTree(self, forest):\\n\\n\\t        if not forest or not forest[0]:\\n\\t            return -1\\n\\t        \\n\\t        # cut the tree in reverse order of tree\\'s height\\n\\t        treeList = []\\n\\t        for i in xrange(len(forest)):\\n\\t            for j in xrange(len(forest[0])):\\n\\t                if forest[i][j] > 1:\\n\\t                    treeList.append([forest[i][j], [i, j]])\\n\\t        treeList.sort()\\n\\t        \\n\\t        totalSteps = self.minStep(forest, [0, 0], treeList[0][1])\\n\\t        k = 0\\n\\t        while k < len(treeList) - 1:\\n\\t            step = self.minStep(forest, treeList[k][1], treeList[k + 1][1])\\n\\t            if step == -1:\\n\\t                return -1\\n\\t            totalSteps += step\\n\\t            k += 1\\n\\t        \\n\\t        return totalSteps\\n\\t    \\n\\t    # do BFS to see if we can find a path from start to end\\n\\t    def minStep(self, forest, start, end):\\n\\t        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\\n\\t        step = 0\\n\\t        m, n = len(forest), len(forest[0])\\n\\t        visited = [[False for x in xrange(n)] for _ in xrange(m)]\\n\\t        visited[start[0]][start[1]] = True\\n\\t        queue = deque()\\n\\t        queue.append(start)\\n\\t        \\n\\t        while queue:\\n\\t            size = len(queue)\\n\\t            for i in xrange(size):\\n\\t                curr = queue.popleft()\\n\\t                if curr == end:\\n\\t                    return step\\n\\t                for direction in directions:\\n\\t                    nextRow = curr[0] + direction[0]\\n\\t                    nextCol = curr[1] + direction[1]\\n\\t                    if nextRow < 0 or nextRow >= m or nextCol < 0 or nextCol >= n or visited[nextRow][nextCol] or forest[nextRow][nextCol] == 0:\\n\\t                        continue\\n\\t                    queue.append([nextRow, nextCol])\\n\\t                    visited[nextRow][nextCol] = True\\n\\t            step += 1\\n\\t            \\n\\t        # here, it means we can never find the destination\\n\\t        return -1\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 579131,
                "title": "python-3-solution-using-bfs",
                "content": "The Idea behind this is to \\n**Step 1 :**\\nGet all the trees from a matrix in sorted order. \\n**Step 2 :**\\nThen for every tree let\\'s know how many number of steps it takes from the previous node\\n(Initially for first tree we will start from (0,0)) \\nIf steps < 0 then we are unable to move further due to obstacle so return -1 else add these steps to the totalSteps. \\n**Step 3 :**\\nIn order to get steps we use bfs \\n\\nThanks to @CrisaGazzola for video explanation.\\nReference : https://youtu.be/HlBnTBLOPOw\\n\\n```class Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        noOfRows = len(forest)\\n        noOfColumns = len(forest[0])\\n\\t\\t\\n\\t\\t#step 1 \\n\\t\\t\\n        trees = [ (forest[i][j], i, j) for i in range(noOfRows) for j in range(noOfColumns) if forest[i][j] > 1 ]\\n        trees = sorted(trees)\\n\\t\\t\\n\\t\\t#Implementation of step 3 BFS\\n\\t\\t\\n        def bfs(row,col,treeX,treeY) :\\n            visited = [ [False for j in range(noOfColumns)] for i in range(noOfRows)]\\n            queue = deque([])\\n            queue.append( (row,col,0) )\\n            while queue :\\n                currX,currY,currSteps = queue.popleft()\\n                if (currX == treeX) and (currY == treeY) :\\n                    return currSteps \\n                for r,c in [ (currX + 1,currY), (currX - 1,currY), (currX,currY + 1), (currX,currY - 1) ] :  \\n                    if (r >= 0) and (r < noOfRows) and (c >= 0) and (c < noOfColumns) and (not visited[r][c]) and (forest[r][c] > 0) :\\n                        visited[r][c] = True \\n                        queue.append( ( r, c, currSteps + 1)  )\\n            return -1 \\n        \\n        x = 0\\n        y = 0 \\n        totalSteps = 0 \\n\\t\\t\\n\\t\\t#step 2 \\n\\t\\t\\n        for tree in trees :\\n            steps = bfs(x,y,tree[1],tree[2]) #step 3 \\n            if steps < 0 :\\n                return -1 \\n            totalSteps += steps \\n            x = tree[1]\\n            y = tree[2]\\n            \\n        return totalSteps \\n```\\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        noOfRows = len(forest)\\n        noOfColumns = len(forest[0])\\n\\t\\t\\n\\t\\t#step 1 \\n\\t\\t\\n        trees = [ (forest[i][j], i, j) for i in range(noOfRows) for j in range(noOfColumns) if forest[i][j] > 1 ]\\n        trees = sorted(trees)\\n\\t\\t\\n\\t\\t#Implementation of step 3 BFS\\n\\t\\t\\n        def bfs(row,col,treeX,treeY) :\\n            visited = [ [False for j in range(noOfColumns)] for i in range(noOfRows)]\\n            queue = deque([])\\n            queue.append( (row,col,0) )\\n            while queue :\\n                currX,currY,currSteps = queue.popleft()\\n                if (currX == treeX) and (currY == treeY) :\\n                    return currSteps \\n                for r,c in [ (currX + 1,currY), (currX - 1,currY), (currX,currY + 1), (currX,currY - 1) ] :  \\n                    if (r >= 0) and (r < noOfRows) and (c >= 0) and (c < noOfColumns) and (not visited[r][c]) and (forest[r][c] > 0) :\\n                        visited[r][c] = True \\n                        queue.append( ( r, c, currSteps + 1)  )\\n            return -1 \\n        \\n        x = 0\\n        y = 0 \\n        totalSteps = 0 \\n\\t\\t\\n\\t\\t#step 2 \\n\\t\\t\\n        for tree in trees :\\n            steps = bfs(x,y,tree[1],tree[2]) #step 3 \\n            if steps < 0 :\\n                return -1 \\n            totalSteps += steps \\n            x = tree[1]\\n            y = tree[2]\\n            \\n        return totalSteps \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033258,
                "title": "python-bfs-priorityqueue-w-comments-and-prints-for-visualization",
                "content": "Approach: \\nHave priority queue that stores (height,x,y) for each tree in order of min to max.\\nUse BFS to find the next available smallest height in priority queue.\\n\\nComplexity:\\nLet m=len(forest), n=len(forest[0])\\nO(mnlog(mn) + 3^(m+n)) runtime - 692ms (45.50%)\\nO(mn) space - 14.9MB (56.88%)\\n\\n```Python\\nfrom typing import List \\nimport heapq\\nimport collections\\nimport numpy as np #for printing\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        #print(\"forest at start: \\\\n{}\".format(np.array(forest)))\\n        m = len(forest)\\n        n = len(forest[0])\\n        \\n        #store all trees in priority queue in (height,x,y) format\\n        pq = []\\n        for x in range(m):\\n            for y in range(n):\\n                height = forest[x][y]\\n                if height > 1:\\n                    heapq.heappush(pq,(height,x,y))\\n        #print(\"heap: {}\".format(pq))\\n        \\n        #takes in starting position and next tree position, returns min steps to get to that next tree position\\n        def bfs(x,y,nextX,nextY) -> int:\\n            queue = collections.deque([(x,y,0)])\\n            seen = {(x,y)}\\n            #print(\"starting at: ({},{})\".format(x,y))\\n            #keep BFS searching until we find target tree or tried all paths\\n            while queue:\\n                x,y,steps = queue.popleft()\\n\\n                if x == nextX and y == nextY:\\n                    #found the next tree, chop it down and return depth\\n                    forest[x][y] = 1\\n                    #print(\"ending at: ({},{}) after {} steps\".format(x,y,steps))\\n                    return steps\\n\\n                #append adjacent nodes (if they are a valid position i.e. height >= 1, within bounds of forest, and not already used)\\n                for dx,dy in [(-1,0),(0,1),(0,-1),(1,0)]:\\n                    adjX,adjY = x+dx, y+dy\\n                    if (0 <= adjX < m and 0 <= adjY < n) and (forest[adjX][adjY] >= 1) and ((adjX,adjY) not in seen):\\n                        # if (nextX,nextY) == (0,0):\\n                        #     #print(\"seen for reaching {},{}: {}\".format(nextX,nextY,seen))\\n                        #     print(\"queue: {}\".format(queue))\\n                        queue.append((adjX,adjY,steps+1))\\n                        seen.add((adjX,adjY))\\n                #print(\"seen: {}\".format(seen))\\n\\n            #no such path exists\\n            return -1\\n        \\n        #start from 0,0 and have next be the first smallest tree, and use BFS for the others\\n        x,y = 0,0\\n        steps = 0\\n        #while there are still trees to cut\\n        while pq:\\n            _,nextX,nextY = heapq.heappop(pq)\\n            \\n            #find the shortest path to the next tree\\n            shortestPath = bfs(x,y,nextX,nextY)\\n            if shortestPath == -1:\\n                #print(\"forest: \\\\n{}\".format(np.array(forest)))\\n                return -1\\n            steps += shortestPath\\n            #print(\"total steps taken: {}\".format(steps))\\n            x,y = nextX,nextY\\n\\n        #print(\"forest at end: \\\\n{}\".format(np.array(forest)))\\n        return steps\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```Python\\nfrom typing import List \\nimport heapq\\nimport collections\\nimport numpy as np #for printing\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        #print(\"forest at start: \\\\n{}\".format(np.array(forest)))\\n        m = len(forest)\\n        n = len(forest[0])\\n        \\n        #store all trees in priority queue in (height,x,y) format\\n        pq = []\\n        for x in range(m):\\n            for y in range(n):\\n                height = forest[x][y]\\n                if height > 1:\\n                    heapq.heappush(pq,(height,x,y))\\n        #print(\"heap: {}\".format(pq))\\n        \\n        #takes in starting position and next tree position, returns min steps to get to that next tree position\\n        def bfs(x,y,nextX,nextY) -> int:\\n            queue = collections.deque([(x,y,0)])\\n            seen = {(x,y)}\\n            #print(\"starting at: ({},{})\".format(x,y))\\n            #keep BFS searching until we find target tree or tried all paths\\n            while queue:\\n                x,y,steps = queue.popleft()\\n\\n                if x == nextX and y == nextY:\\n                    #found the next tree, chop it down and return depth\\n                    forest[x][y] = 1\\n                    #print(\"ending at: ({},{}) after {} steps\".format(x,y,steps))\\n                    return steps\\n\\n                #append adjacent nodes (if they are a valid position i.e. height >= 1, within bounds of forest, and not already used)\\n                for dx,dy in [(-1,0),(0,1),(0,-1),(1,0)]:\\n                    adjX,adjY = x+dx, y+dy\\n                    if (0 <= adjX < m and 0 <= adjY < n) and (forest[adjX][adjY] >= 1) and ((adjX,adjY) not in seen):\\n                        # if (nextX,nextY) == (0,0):\\n                        #     #print(\"seen for reaching {},{}: {}\".format(nextX,nextY,seen))\\n                        #     print(\"queue: {}\".format(queue))\\n                        queue.append((adjX,adjY,steps+1))\\n                        seen.add((adjX,adjY))\\n                #print(\"seen: {}\".format(seen))\\n\\n            #no such path exists\\n            return -1\\n        \\n        #start from 0,0 and have next be the first smallest tree, and use BFS for the others\\n        x,y = 0,0\\n        steps = 0\\n        #while there are still trees to cut\\n        while pq:\\n            _,nextX,nextY = heapq.heappop(pq)\\n            \\n            #find the shortest path to the next tree\\n            shortestPath = bfs(x,y,nextX,nextY)\\n            if shortestPath == -1:\\n                #print(\"forest: \\\\n{}\".format(np.array(forest)))\\n                return -1\\n            steps += shortestPath\\n            #print(\"total steps taken: {}\".format(steps))\\n            x,y = nextX,nextY\\n\\n        #print(\"forest at end: \\\\n{}\".format(np.array(forest)))\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409906,
                "title": "c-simple-bfs-priorityqueue-solution-with-explanation",
                "content": "Approach:\\nWhat we are being told is we want to cut trees in such a manner:\\n1. We want to cut the trees in increasing order of their heights\\n2. We can traverse through nodes with value > 1 \\n\\nAnd we want to minimise the number of steps to cut all trees.\\nMin no. of steps to cut all trees = (min. no of steps from (0,0) to smallest tree + min. no of steps from smallest tree to second smallest tree+.... )\\n\\nIn order to find the next smallest tree, we use priority queue and\\nin order to find min. no. of steps from (i,j) to (u,v) we use BFS.\\n```\\n#define p pair<int,pair<int,int>>\\nclass Solution {\\npublic:\\n    int m,n;\\n    int bfs(int &i,int &j,int &u,int &v,vector<vector<int>>& nums){\\n        vector<vector<bool>>explored(m,vector<bool>(n,false));\\n        bool found=false;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        explored[i][j]=true;\\n        int cnt=0;\\n        while(!q.empty()){\\n            int l=q.size();\\n            while(l--){\\n                pair<int,int>a=q.front();\\n                int x=a.first,y=a.second;\\n                q.pop();\\n                if(x==u && y==v){\\n                    found=true;\\n                    break;\\n                }\\n                if(x>0 && nums[x-1][y] && !explored[x-1][y]){\\n                    explored[x-1][y]=true;\\n                    q.push({x-1,y});\\n                }\\n                if(y>0 && nums[x][y-1] && !explored[x][y-1]){\\n                    explored[x][y-1]=true;\\n                    q.push({x,y-1});\\n                }\\n                if(x<m-1 && nums[x+1][y] && !explored[x+1][y]){\\n                    explored[x+1][y]=true;\\n                    q.push({x+1,y});\\n                }\\n                if(y<n-1 && nums[x][y+1] && !explored[x][y+1]){\\n                    explored[x][y+1]=true;\\n                    q.push({x,y+1});\\n                }\\n            }\\n            if(found)\\n                break;\\n            cnt++;\\n        }\\n        return found?cnt:-1;\\n    }\\n    int cutOffTree(vector<vector<int>>& nums) {\\n        m=nums.size(),n=nums[0].size();\\n        priority_queue<p,vector<p>,greater<p>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[i][j]>1)\\n                    q.push({nums[i][j],{i,j}});\\n            }\\n        }\\n        int i=0,j=0,ans=0;\\n        while(!q.empty()){\\n            p a=q.top();\\n            int u=a.second.first,v=a.second.second;\\n            q.pop();\\n            int b=bfs(i,j,u,v,nums);\\n            if(b==-1)\\n                return -1;\\n            i=u,j=v;\\n            ans+=b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define p pair<int,pair<int,int>>\\nclass Solution {\\npublic:\\n    int m,n;\\n    int bfs(int &i,int &j,int &u,int &v,vector<vector<int>>& nums){\\n        vector<vector<bool>>explored(m,vector<bool>(n,false));\\n        bool found=false;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        explored[i][j]=true;\\n        int cnt=0;\\n        while(!q.empty()){\\n            int l=q.size();\\n            while(l--){\\n                pair<int,int>a=q.front();\\n                int x=a.first,y=a.second;\\n                q.pop();\\n                if(x==u && y==v){\\n                    found=true;\\n                    break;\\n                }\\n                if(x>0 && nums[x-1][y] && !explored[x-1][y]){\\n                    explored[x-1][y]=true;\\n                    q.push({x-1,y});\\n                }\\n                if(y>0 && nums[x][y-1] && !explored[x][y-1]){\\n                    explored[x][y-1]=true;\\n                    q.push({x,y-1});\\n                }\\n                if(x<m-1 && nums[x+1][y] && !explored[x+1][y]){\\n                    explored[x+1][y]=true;\\n                    q.push({x+1,y});\\n                }\\n                if(y<n-1 && nums[x][y+1] && !explored[x][y+1]){\\n                    explored[x][y+1]=true;\\n                    q.push({x,y+1});\\n                }\\n            }\\n            if(found)\\n                break;\\n            cnt++;\\n        }\\n        return found?cnt:-1;\\n    }\\n    int cutOffTree(vector<vector<int>>& nums) {\\n        m=nums.size(),n=nums[0].size();\\n        priority_queue<p,vector<p>,greater<p>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[i][j]>1)\\n                    q.push({nums[i][j],{i,j}});\\n            }\\n        }\\n        int i=0,j=0,ans=0;\\n        while(!q.empty()){\\n            p a=q.top();\\n            int u=a.second.first,v=a.second.second;\\n            q.pop();\\n            int b=bfs(i,j,u,v,nums);\\n            if(b==-1)\\n                return -1;\\n            i=u,j=v;\\n            ans+=b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522010,
                "title": "c-bfs-for-beginners-easy",
                "content": "WE CANNOT USE A SIMPLE RECURSION CONCEPT HERE, IT WILL TLE.  It is because this question is asking us to now find trees in increasing order, but cut trees in increasing order, so there will be cases when you will ignore the tree and will again return back to it. Kind of like a question where, minimum time to visit all nodes and return back to source question\\n\\nSEE THE BELOW MATRIX FOR EXAMPLE\\n\\n5        8       9\\n25    19      10\\n99     0       22\\n\\nOur start point will always be (0,0) but we wanna cut off the smallest tree first of all, so we try to find the walk count from 0,0 to the shortest tree height index, and then we make this tree index as our start index for the next greater tree height and continue on and on\\n\\n**If you are standing in a cell with a tree, you can choose whether to cut it off.**\\nThe important condition is to cut the shortest tree first, and move on to next greater\\n```\\nclass Solution {\\npublic:\\n    int BFS(vector<vector<int>> &forest, int sX, int sY, int dX, int dY){\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        int X[4]={1,-1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        queue<pair<int,int>> q;\\n        q.push({sX,sY});\\n        vis[sX][sY]=true;\\n        int res=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto curr=q.front();\\n                q.pop();\\n                if(curr.first==dX && curr.second==dY){\\n                    return res;\\n                }\\n                for(int dir=0;dir<4;dir++){\\n                    int newX=curr.first+X[dir];\\n                    int newY=curr.second+Y[dir];\\n                    if(newX<0 || newY<0 || newX==n || newY==m || forest[newX][newY]==0 || vis[newX][newY]==true){\\n                        continue;\\n                    }\\n                    vis[newX][newY]=true;\\n                    q.push({newX,newY});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        vector<vector<int>> trees;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(forest[i][j]>1){\\n                    trees.push_back({forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        sort(trees.begin(),trees.end());\\n        int res=0;\\n        int startX=0;\\n        int startY=0;\\n        for(auto tree: trees){\\n            int treeX=tree[1];\\n            int treeY=tree[2];\\n            int distance=BFS(forest,startX,startY,treeX,treeY);\\n            if(distance==-1){\\n                return -1;\\n            }\\n            res+=distance;\\n            startX=treeX;\\n            startY=treeY;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BFS(vector<vector<int>> &forest, int sX, int sY, int dX, int dY){\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        int X[4]={1,-1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        queue<pair<int,int>> q;\\n        q.push({sX,sY});\\n        vis[sX][sY]=true;\\n        int res=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto curr=q.front();\\n                q.pop();\\n                if(curr.first==dX && curr.second==dY){\\n                    return res;\\n                }\\n                for(int dir=0;dir<4;dir++){\\n                    int newX=curr.first+X[dir];\\n                    int newY=curr.second+Y[dir];\\n                    if(newX<0 || newY<0 || newX==n || newY==m || forest[newX][newY]==0 || vis[newX][newY]==true){\\n                        continue;\\n                    }\\n                    vis[newX][newY]=true;\\n                    q.push({newX,newY});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        vector<vector<int>> trees;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(forest[i][j]>1){\\n                    trees.push_back({forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        sort(trees.begin(),trees.end());\\n        int res=0;\\n        int startX=0;\\n        int startY=0;\\n        for(auto tree: trees){\\n            int treeX=tree[1];\\n            int treeY=tree[2];\\n            int distance=BFS(forest,startX,startY,treeX,treeY);\\n            if(distance==-1){\\n                return -1;\\n            }\\n            res+=distance;\\n            startX=treeX;\\n            startY=treeY;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909554,
                "title": "python3-min-heap-bfs",
                "content": "```\\n# Min Heap + BFS\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        # 1. use min heap to sort the tree by height\\n        heap = []\\n        for r in range(len(forest)):\\n            for c in range(len(forest[0])):\\n                if forest[r][c] > 1:\\n                    heapq.heappush(heap, (forest[r][c], r, c))\\n\\n        totalSteps, currR, currC = 0, 0, 0\\n        while heap:\\n            height, r, c = heapq.heappop(heap)\\n            steps = self.bfsGetMinSteps(forest, currR, currC, r, c)\\n            if steps == -1:\\n                return -1\\n            currR, currC = r, c\\n            totalSteps += steps    \\n        return totalSteps\\n    \\n    # 2. use BFS get min distance for tree to tree\\n    def bfsGetMinSteps(self, forest, currR, currC, targetR, targetC):\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        m, n = len(forest), len(forest[0])\\n        q  = collections.deque([(currR, currC)])\\n        visited = set([(currR, currC)])\\n        steps = 0\\n        \\n        while q:\\n            sameLevelCounts = len(q)\\n            for _ in range(sameLevelCounts):\\n                r, c = q.popleft()\\n                if r == targetR and c == targetC:\\n                    return steps\\n                for dr, dc in directions:\\n                    nextR, nextC = r + dr, c + dc\\n                    if 0 <= nextR < m and 0 <= nextC < n and (nextR, nextC) not in visited and forest[nextR][nextC] != 0:\\n                        visited.add((nextR, nextC))\\n                        q.append((nextR, nextC))\\n            steps += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# Min Heap + BFS\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        # 1. use min heap to sort the tree by height\\n        heap = []\\n        for r in range(len(forest)):\\n            for c in range(len(forest[0])):\\n                if forest[r][c] > 1:\\n                    heapq.heappush(heap, (forest[r][c], r, c))\\n\\n        totalSteps, currR, currC = 0, 0, 0\\n        while heap:\\n            height, r, c = heapq.heappop(heap)\\n            steps = self.bfsGetMinSteps(forest, currR, currC, r, c)\\n            if steps == -1:\\n                return -1\\n            currR, currC = r, c\\n            totalSteps += steps    \\n        return totalSteps\\n    \\n    # 2. use BFS get min distance for tree to tree\\n    def bfsGetMinSteps(self, forest, currR, currC, targetR, targetC):\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        m, n = len(forest), len(forest[0])\\n        q  = collections.deque([(currR, currC)])\\n        visited = set([(currR, currC)])\\n        steps = 0\\n        \\n        while q:\\n            sameLevelCounts = len(q)\\n            for _ in range(sameLevelCounts):\\n                r, c = q.popleft()\\n                if r == targetR and c == targetC:\\n                    return steps\\n                for dr, dc in directions:\\n                    nextR, nextC = r + dr, c + dc\\n                    if 0 <= nextR < m and 0 <= nextC < n and (nextR, nextC) not in visited and forest[nextR][nextC] != 0:\\n                        visited.add((nextR, nextC))\\n                        q.append((nextR, nextC))\\n            steps += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272841,
                "title": "c-solution-using-a-search",
                "content": "```\\nclass Solution {\\n\\tint find(vector<vector<int>> &forest, int cur, int tar) {\\n\\t\\tint n = forest[0].size(), m = forest.size();\\n\\t\\tint tr = tar/n, tc = tar%n, curr = cur/n, curc = cur%n;\\n\\t\\tauto cmp = [](const pair<int,int> &a, const pair<int,int> &b) {\\n\\t\\t\\treturn a.second > b.second;\\n\\t\\t};\\n\\t\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> q{cmp};\\n\\t    unordered_set<int> vis;\\n\\t    q.push(make_pair(cur, abs(tr-curr)+abs(tc-curc)));\\n\\t    while (!q.empty()) {\\n\\t    \\tauto f = q.top();\\n\\t    \\tq.pop();\\n\\t\\t\\tif (vis.count(f.first)) continue;\\n\\t\\t\\tvis.insert(f.first);\\n\\t    \\tif (f.first == tar) return f.second;\\n\\t    \\tint dirs[][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\t    \\tint r = f.first/n, c = f.first%n;\\n\\t    \\tfor (auto &dir : dirs) {\\n\\t    \\t\\tint newr = r + dir[0], newc = c + dir[1];\\n\\t    \\t\\tif (newr < 0 || newr >= m || newc < 0 || newc >= n || \\n\\t    \\t\\t\\tforest[newr][newc] == 0 || vis.count(newr*n+newc)) continue;\\n\\t    \\t\\tq.push(make_pair(newr*n+newc, f.second-abs(r-tr)-abs(c-tc)+1+abs(newr-tr)+abs(newc-tc)));\\n\\t    \\t}\\n\\t    }\\n\\t    return -1;\\n\\t}\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if (forest.size() == 0 || forest[0].size() == 0) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        vector<int> targets;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (forest[i][j] > 1) targets.push_back(i*n+j);\\n            }\\n        }\\n        sort(targets.begin(), targets.end(), [&forest,n](int a, int b) {\\n            return forest[a/n][a%n] < forest[b/n][b%n];\\n        });\\n        int ans = 0, cur = 0;\\n        for (auto tar : targets) {\\n            auto dis = find(forest, cur, tar);\\n            if (dis == -1) return -1;\\n            ans += dis;\\n            cur = tar;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nbfs is too slow to passing the test cases",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tint find(vector<vector<int>> &forest, int cur, int tar) {\\n\\t\\tint n = forest[0].size(), m = forest.size();\\n\\t\\tint tr = tar/n, tc = tar%n, curr = cur/n, curc = cur%n;\\n\\t\\tauto cmp = [](const pair<int,int> &a, const pair<int,int> &b) {\\n\\t\\t\\treturn a.second > b.second;\\n\\t\\t};\\n\\t\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> q{cmp};\\n\\t    unordered_set<int> vis;\\n\\t    q.push(make_pair(cur, abs(tr-curr)+abs(tc-curc)));\\n\\t    while (!q.empty()) {\\n\\t    \\tauto f = q.top();\\n\\t    \\tq.pop();\\n\\t\\t\\tif (vis.count(f.first)) continue;\\n\\t\\t\\tvis.insert(f.first);\\n\\t    \\tif (f.first == tar) return f.second;\\n\\t    \\tint dirs[][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\t    \\tint r = f.first/n, c = f.first%n;\\n\\t    \\tfor (auto &dir : dirs) {\\n\\t    \\t\\tint newr = r + dir[0], newc = c + dir[1];\\n\\t    \\t\\tif (newr < 0 || newr >= m || newc < 0 || newc >= n || \\n\\t    \\t\\t\\tforest[newr][newc] == 0 || vis.count(newr*n+newc)) continue;\\n\\t    \\t\\tq.push(make_pair(newr*n+newc, f.second-abs(r-tr)-abs(c-tc)+1+abs(newr-tr)+abs(newc-tc)));\\n\\t    \\t}\\n\\t    }\\n\\t    return -1;\\n\\t}\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if (forest.size() == 0 || forest[0].size() == 0) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        vector<int> targets;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (forest[i][j] > 1) targets.push_back(i*n+j);\\n            }\\n        }\\n        sort(targets.begin(), targets.end(), [&forest,n](int a, int b) {\\n            return forest[a/n][a%n] < forest[b/n][b%n];\\n        });\\n        int ans = 0, cur = 0;\\n        for (auto tar : targets) {\\n            auto dis = find(forest, cur, tar);\\n            if (dis == -1) return -1;\\n            ans += dis;\\n            cur = tar;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213369,
                "title": "java-bfs-priorityqueue-solution-with-comments",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        // Sort trees by height\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( new Comparator<int[]>(){\\n            public int compare(int[] p1, int[] p2){\\n                return p1[2] - p2[2];\\n            }\\n        });\\n\\n        // Add trees in the pq\\n        for (int r = 0; r < forest.size(); ++r) \\n            for (int c = 0; c < forest.get(0).size(); ++c) {\\n                int height = forest.get(r).get(c);\\n                if (height >0) pq.add(new int[]{r, c, height});\\n            }\\n        \\n        int last_i = 0, last_j = 0;\\n        int result = 0;\\n        \\n        // Visit shorter trees first\\n        while (!pq.isEmpty()){\\n            int[] new_step = pq.poll();\\n            int step = bfs(forest, last_i, last_j, new_step[0], new_step[1]);\\n            if (step == -1) return -1;\\n            result += step;\\n            last_i = new_step[0];\\n            last_j = new_step[1];\\n        }\\n        return result;\\n            \\n    }\\n    \\n    // Using BFS to record shortest dist between two trees\\n    private int bfs(List<List<Integer>> forest, int start_i, int start_j, int end_i, int end_j){\\n        \\n        Queue<int[]> queue = new LinkedList();\\n        int m = forest.size(), n = forest.get(0).size();\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        queue.add(new int[]{start_i, start_j});\\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for (int i=0; i<size; i++){\\n                int[] curr = queue.poll();\\n\\t\\t\\t\\t// Target is found. Return the level of BFS traversal as steps\\n                if (curr[0] == end_i && curr[1] == end_j)\\n                    return level;\\n                for (int j=0; j<4; j++){\\n                    int next_i = curr[0]+dirs[j][0];\\n                    int next_j = curr[1]+dirs[j][1];\\n                    if (inBounds(forest, next_i , next_j) && ! visited[next_i][next_j]){\\n                        visited[next_i][next_j] = true;\\n                        queue.offer(new int[]{ next_i, next_j});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    \\n    // Return false if out of forest or meet obstacles\\n    private boolean inBounds(List<List<Integer>> forest, int i, int j){\\n        return (i >=0 && i<=forest.size()-1 && j >=0 && j<=forest.get(0).size()-1 && forest.get(i).get(j) != 0);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        // Sort trees by height\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( new Comparator<int[]>(){\\n            public int compare(int[] p1, int[] p2){\\n                return p1[2] - p2[2];\\n            }\\n        });\\n\\n        // Add trees in the pq\\n        for (int r = 0; r < forest.size(); ++r) \\n            for (int c = 0; c < forest.get(0).size(); ++c) {\\n                int height = forest.get(r).get(c);\\n                if (height >0) pq.add(new int[]{r, c, height});\\n            }\\n        \\n        int last_i = 0, last_j = 0;\\n        int result = 0;\\n        \\n        // Visit shorter trees first\\n        while (!pq.isEmpty()){\\n            int[] new_step = pq.poll();\\n            int step = bfs(forest, last_i, last_j, new_step[0], new_step[1]);\\n            if (step == -1) return -1;\\n            result += step;\\n            last_i = new_step[0];\\n            last_j = new_step[1];\\n        }\\n        return result;\\n            \\n    }\\n    \\n    // Using BFS to record shortest dist between two trees\\n    private int bfs(List<List<Integer>> forest, int start_i, int start_j, int end_i, int end_j){\\n        \\n        Queue<int[]> queue = new LinkedList();\\n        int m = forest.size(), n = forest.get(0).size();\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        queue.add(new int[]{start_i, start_j});\\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for (int i=0; i<size; i++){\\n                int[] curr = queue.poll();\\n\\t\\t\\t\\t// Target is found. Return the level of BFS traversal as steps\\n                if (curr[0] == end_i && curr[1] == end_j)\\n                    return level;\\n                for (int j=0; j<4; j++){\\n                    int next_i = curr[0]+dirs[j][0];\\n                    int next_j = curr[1]+dirs[j][1];\\n                    if (inBounds(forest, next_i , next_j) && ! visited[next_i][next_j]){\\n                        visited[next_i][next_j] = true;\\n                        queue.offer(new int[]{ next_i, next_j});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n    \\n    // Return false if out of forest or meet obstacles\\n    private boolean inBounds(List<List<Integer>> forest, int i, int j){\\n        return (i >=0 && i<=forest.size()-1 && j >=0 && j<=forest.get(0).size()-1 && forest.get(i).get(j) != 0);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054777,
                "title": "c-solution-approach-commented-bfs-code-beats-95-at-time-of-submission",
                "content": "**Solution Approach:**\\nSince it is given that we need to visit node in increasing order. A simple direct BFS cannot solve our problem, because we might need to visit single cell multiple times. \\nExample: in below input, we will first move to 2 (1->3->2)[2 steps] , then from 2 we will move to 3(2->3)[1 step], then to 4,5,6,7,8 with one step each. so ans will be 2 + 1 + 1 + 1 + 1 + 1 + 1 = 8\\n```\\n\\t\\t1       3        2 \\n\\t\\t0       4        5\\n\\t\\t8       7        6\\n```\\n\\nActual idea to solve this problem is move from first point to second, determine the steps required using BFS, then move from second point to third, again use BFS to find number of steps and so on. In end add all the steps required, which will be our final answer.\\n\\n**Algo:**\\n1. Figure out all the point present in grid that are greater than 1 and needs to be visited.(save in vector)\\n2. sort the vector obtained above. We will move as per this vector values.\\n3. Apply standard BFS to determine steps required to move from [0,0] (point A) to cell with value = vector[0] (point B).\\n4. Now make point A = point B and point B = vector[1] and apply BFS again, to determine steps required.\\n5. Follow step 4 till all the vector is parsed or if one of the point is not reachable.\\n6. Add all the steps obtained in step 4 and return as answer, if all points are reachable, else return -1.\\n\\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& f) {\\n      \\n        /* Way to move in 4 direction */\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        \\n        /* keeping a copy of original forest */\\n        vector<vector<int>> orig(f.begin(),f.end());\\n        \\n        vector<int> p;\\n        \\n        /* store all the values that are greater than 1 */\\n        for(int i = 0 ; i < f.size(); i++ )\\n        {\\n            for(int j = 0; j < f[0].size(); j++)\\n            {\\n                if(f[i][j] > 1 )\\n                {\\n                    p.push_back(f[i][j]);\\n                }\\n            }\\n        }\\n        \\n        /*sort the element, we will visit each node one by one in this order */\\n        sort(p.begin(),p.end());\\n        \\n        int ans = 0;\\n        \\n        int x = 0;  /* x coordinate */\\n        int y = 0;  /* y coordinate */\\n        int ans1 = 0; /* steps required to move from point A to point B */\\n        int vis = 0;  /* Indicate whether it is possible to reach some point or not */\\n        int flag = 0; /* variable to break out of two loop,as goto is not a right option */\\n        \\n        \\n        /* outer loop will run for all values that needs to be visited. */\\n        for(int i = 0 ; i < p.size(); i++)\\n        {\\n            vis = 0;\\n            int val = p[i];\\n           \\n            queue<pair<int,int>> q;\\n            q.push({x,y});\\n            \\n            /* our standard BFS implementation with just one tweak \\n               -> break out of loop when our val is found and move on to next value. \\n             */\\n            while(!q.empty())\\n            {\\n                \\n                if(val == orig[q.front().first][q.front().second])\\n                {         \\n                    x = q.front().first;   /* setting up coordinate for next iteration */\\n                    y = q.front().second;\\n                    vis = 1;   /* if val is found, vis is made one otherwise we can directly                                      return -1 */\\n                    break;\\n                }\\n               \\n                ans1++; /* increasing step count for bfs */\\n                flag = 0;\\n                int size = q.size();\\n             \\n                while(size--)\\n                {\\n                    \\n                    pair<int,int> temp = q.front();\\n                    q.pop();\\n                    x = temp.first;\\n                    y = temp.second;\\n                   \\n                    for(int j = 0 ;j < 4; j++)\\n                    {\\n                        int newX = x + dx[j];\\n                        int newY = y + dy[j];\\n                        \\n                        if(newX >= 0 && newX < f.size() && newY >= 0 && newY < f[0].size() &&\\n                          f[newX][newY] >= 1)\\n                        {\\n                            if(val == orig[newX][newY])\\n                            {         \\n                                vis = 1;    /* if val is found, vis is made one otherwise we                                                   can directly return -1 */\\n                                x = newX;   /* setting up coordinate for next iteration */\\n                                y = newY;\\n                                flag = 1;\\n                                break;\\n                            }\\n                            q.push({newX,newY});\\n                            f[newX][newY] = 0;/*making it 0 so our bfs will converge quicky */\\n                        }\\n                    }\\n                    if(flag)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(flag)\\n                    break;\\n            }\\n            \\n            ans = ans + ans1; /* adding to the final result */\\n            \\n            /* copying original value to variable for next iterations*/\\n            flag = 0;\\n            f = orig;\\n            ans1 = 0;\\n            \\n            if(vis == 0)  /* there is no path to reach a given point , return -1*/\\n                return -1;\\n                 \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\n\\t\\t1       3        2 \\n\\t\\t0       4        5\\n\\t\\t8       7        6\\n```\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& f) {\\n      \\n        /* Way to move in 4 direction */\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        \\n        /* keeping a copy of original forest */\\n        vector<vector<int>> orig(f.begin(),f.end());\\n        \\n        vector<int> p;\\n        \\n        /* store all the values that are greater than 1 */\\n        for(int i = 0 ; i < f.size(); i++ )\\n        {\\n            for(int j = 0; j < f[0].size(); j++)\\n            {\\n                if(f[i][j] > 1 )\\n                {\\n                    p.push_back(f[i][j]);\\n                }\\n            }\\n        }\\n        \\n        /*sort the element, we will visit each node one by one in this order */\\n        sort(p.begin(),p.end());\\n        \\n        int ans = 0;\\n        \\n        int x = 0;  /* x coordinate */\\n        int y = 0;  /* y coordinate */\\n        int ans1 = 0; /* steps required to move from point A to point B */\\n        int vis = 0;  /* Indicate whether it is possible to reach some point or not */\\n        int flag = 0; /* variable to break out of two loop,as goto is not a right option */\\n        \\n        \\n        /* outer loop will run for all values that needs to be visited. */\\n        for(int i = 0 ; i < p.size(); i++)\\n        {\\n            vis = 0;\\n            int val = p[i];\\n           \\n            queue<pair<int,int>> q;\\n            q.push({x,y});\\n            \\n            /* our standard BFS implementation with just one tweak \\n               -> break out of loop when our val is found and move on to next value. \\n             */\\n            while(!q.empty())\\n            {\\n                \\n                if(val == orig[q.front().first][q.front().second])\\n                {         \\n                    x = q.front().first;   /* setting up coordinate for next iteration */\\n                    y = q.front().second;\\n                    vis = 1;   /* if val is found, vis is made one otherwise we can directly                                      return -1 */\\n                    break;\\n                }\\n               \\n                ans1++; /* increasing step count for bfs */\\n                flag = 0;\\n                int size = q.size();\\n             \\n                while(size--)\\n                {\\n                    \\n                    pair<int,int> temp = q.front();\\n                    q.pop();\\n                    x = temp.first;\\n                    y = temp.second;\\n                   \\n                    for(int j = 0 ;j < 4; j++)\\n                    {\\n                        int newX = x + dx[j];\\n                        int newY = y + dy[j];\\n                        \\n                        if(newX >= 0 && newX < f.size() && newY >= 0 && newY < f[0].size() &&\\n                          f[newX][newY] >= 1)\\n                        {\\n                            if(val == orig[newX][newY])\\n                            {         \\n                                vis = 1;    /* if val is found, vis is made one otherwise we                                                   can directly return -1 */\\n                                x = newX;   /* setting up coordinate for next iteration */\\n                                y = newY;\\n                                flag = 1;\\n                                break;\\n                            }\\n                            q.push({newX,newY});\\n                            f[newX][newY] = 0;/*making it 0 so our bfs will converge quicky */\\n                        }\\n                    }\\n                    if(flag)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(flag)\\n                    break;\\n            }\\n            \\n            ans = ans + ans1; /* adding to the final result */\\n            \\n            /* copying original value to variable for next iterations*/\\n            flag = 0;\\n            f = orig;\\n            ans1 = 0;\\n            \\n            if(vis == 0)  /* there is no path to reach a given point , return -1*/\\n                return -1;\\n                 \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204000,
                "title": "python-normal-and-priority-bfs-faster-than-99-and-faster-than-77",
                "content": "## normal bfs\\n![image](https://assets.leetcode.com/users/images/f70bca63-7c1d-4a5d-9b9b-d2a5ac4733e7_1620800536.5729027.png)\\n\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        forest.append([0] * len(forest[0]))\\n        for row in forest: row.append(0)\\n        def bfs(end, start):\\n            if end == start: return 0\\n            visited, queue = set(), {start}\\n            visited.add(start)\\n            step = 0\\n            while queue:\\n                s = set()\\n                step += 1\\n                for p in queue:                    \\n                    for dr, dc in ((-1, 0), (1, 0), (0, 1), (0, -1)):\\n                        r, c = p[0] + dr, p[1] + dc\\n                        if not forest[r][c] or (r, c) in visited: continue\\n                        if (r, c) == end: return step\\n                        visited.add((r, c))\\n                        s.add((r, c))\\n                queue = s\\n\\n        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]\\n        # check\\n        queue = [(0, 0)]\\n        reached = set()\\n        reached.add((0, 0))\\n        while queue:\\n            r, c = queue.pop()\\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                row, col = r + dr, c + dc\\n                if forest[row][col] and (row, col) not in reached:\\n                    queue.append((row, col))\\n                    reached.add((row,col))\\n        if not all([(i, j) in reached for (height, i, j) in trees]): return -1\\n        trees.sort()\\n        return sum([bfs((I,J),(i,j)) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])\\n```\\n## priority bfs\\n![image](https://assets.leetcode.com/users/images/87009e0b-3b8f-4ad1-96db-f3582810ef95_1620800616.6076303.png)\\n\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        forest.append([0] * len(forest[0]))\\n        for row in forest: row.append(0)\\n        # distance\\n        def distance(i, j, I, J):\\n            manhattan = abs(i - I) + abs(j - J)\\n            detour = 0\\n            good, bad = [(i, j)], []\\n            visited = set()\\n            while True:\\n                if not good:\\n                    good, bad = bad, []\\n                    detour += 1\\n                i, j = good.pop()\\n                if i == I and j == J: return manhattan + detour * 2\\n                if (i, j) in visited: continue\\n                visited.add((i, j))\\n                for i, j, closer in ((i-1, j, i > I), (i+1, j, i < I), (i, j+1, j < J), (i, j-1, j > J)):\\n                    if forest[i][j]:\\n                        (good if closer else bad).append((i, j))\\n                    \\n        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]\\n        # check\\n        queue = [(0, 0)]\\n        reached = set()\\n        reached.add((0, 0))\\n        while queue:\\n            r, c = queue.pop()\\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                row, col = r + dr, c + dc\\n                if forest[row][col] and (row, col) not in reached:\\n                    queue.append((row, col))\\n                    reached.add((row,col))\\n        if not all([(i, j) in reached for (height, i, j) in trees]): return -1\\n        trees.sort()\\n        return sum([distance(i, j, I, J) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        forest.append([0] * len(forest[0]))\\n        for row in forest: row.append(0)\\n        def bfs(end, start):\\n            if end == start: return 0\\n            visited, queue = set(), {start}\\n            visited.add(start)\\n            step = 0\\n            while queue:\\n                s = set()\\n                step += 1\\n                for p in queue:                    \\n                    for dr, dc in ((-1, 0), (1, 0), (0, 1), (0, -1)):\\n                        r, c = p[0] + dr, p[1] + dc\\n                        if not forest[r][c] or (r, c) in visited: continue\\n                        if (r, c) == end: return step\\n                        visited.add((r, c))\\n                        s.add((r, c))\\n                queue = s\\n\\n        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]\\n        # check\\n        queue = [(0, 0)]\\n        reached = set()\\n        reached.add((0, 0))\\n        while queue:\\n            r, c = queue.pop()\\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                row, col = r + dr, c + dc\\n                if forest[row][col] and (row, col) not in reached:\\n                    queue.append((row, col))\\n                    reached.add((row,col))\\n        if not all([(i, j) in reached for (height, i, j) in trees]): return -1\\n        trees.sort()\\n        return sum([bfs((I,J),(i,j)) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])\\n```\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        forest.append([0] * len(forest[0]))\\n        for row in forest: row.append(0)\\n        # distance\\n        def distance(i, j, I, J):\\n            manhattan = abs(i - I) + abs(j - J)\\n            detour = 0\\n            good, bad = [(i, j)], []\\n            visited = set()\\n            while True:\\n                if not good:\\n                    good, bad = bad, []\\n                    detour += 1\\n                i, j = good.pop()\\n                if i == I and j == J: return manhattan + detour * 2\\n                if (i, j) in visited: continue\\n                visited.add((i, j))\\n                for i, j, closer in ((i-1, j, i > I), (i+1, j, i < I), (i, j+1, j < J), (i, j-1, j > J)):\\n                    if forest[i][j]:\\n                        (good if closer else bad).append((i, j))\\n                    \\n        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]\\n        # check\\n        queue = [(0, 0)]\\n        reached = set()\\n        reached.add((0, 0))\\n        while queue:\\n            r, c = queue.pop()\\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                row, col = r + dr, c + dc\\n                if forest[row][col] and (row, col) not in reached:\\n                    queue.append((row, col))\\n                    reached.add((row,col))\\n        if not all([(i, j) in reached for (height, i, j) in trees]): return -1\\n        trees.sort()\\n        return sum([distance(i, j, I, J) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847011,
                "title": "java-simple-bfs-solution",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int rows;\\n    int cols;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        rows = forest.size();\\n        cols = forest.get(0).size();\\n        int[][] matrix = new int[rows][cols];\\n        TreeMap<Integer, int[]> map = new TreeMap<>();\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < cols; ++c) {\\n                matrix[r][c] = forest.get(r).get(c);\\n                if (matrix[r][c] > 1) {\\n                    map.put(matrix[r][c], new int[]{r, c});\\n                }\\n            }\\n        }\\n        int x = 0, y = 0, res = 0;\\n        for (int t : map.keySet()) {\\n            int[] pos = map.get(t);\\n            boolean[][] visited = new boolean[rows][cols];\\n            int step = bfs(x, y, pos[0], pos[1], matrix, visited);\\n            if (step == -1) {\\n                return -1;\\n            }\\n            res += step;\\n            matrix[x][y] = 1;\\n            x = pos[0];\\n            y = pos[1];\\n        }\\n        return res;\\n    }\\n    \\n    private int bfs(int r, int c, int x, int y, int[][] matrix, boolean[][] visited) {\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{r, c});\\n        visited[r][c] = true;\\n        int step = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == x && cur[1] == y) {\\n                    return step;\\n                }\\n                for (int[] dir : dirs) {\\n                    int nr = dir[0] + cur[0];\\n                    int nc = dir[1] + cur[1];\\n                    if (0 <= nr && nr < rows && 0 <= nc && nc < cols && matrix[nr][nc] > 0 && !visited[nr][nc]) {\\n                        visited[nr][nc] = true;\\n                        queue.offer(new int[]{nr, nc});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int rows;\\n    int cols;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        rows = forest.size();\\n        cols = forest.get(0).size();\\n        int[][] matrix = new int[rows][cols];\\n        TreeMap<Integer, int[]> map = new TreeMap<>();\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < cols; ++c) {\\n                matrix[r][c] = forest.get(r).get(c);\\n                if (matrix[r][c] > 1) {\\n                    map.put(matrix[r][c], new int[]{r, c});\\n                }\\n            }\\n        }\\n        int x = 0, y = 0, res = 0;\\n        for (int t : map.keySet()) {\\n            int[] pos = map.get(t);\\n            boolean[][] visited = new boolean[rows][cols];\\n            int step = bfs(x, y, pos[0], pos[1], matrix, visited);\\n            if (step == -1) {\\n                return -1;\\n            }\\n            res += step;\\n            matrix[x][y] = 1;\\n            x = pos[0];\\n            y = pos[1];\\n        }\\n        return res;\\n    }\\n    \\n    private int bfs(int r, int c, int x, int y, int[][] matrix, boolean[][] visited) {\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{r, c});\\n        visited[r][c] = true;\\n        int step = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == x && cur[1] == y) {\\n                    return step;\\n                }\\n                for (int[] dir : dirs) {\\n                    int nr = dir[0] + cur[0];\\n                    int nc = dir[1] + cur[1];\\n                    if (0 <= nr && nr < rows && 0 <= nc && nc < cols && matrix[nr][nc] > 0 && !visited[nr][nc]) {\\n                        visited[nr][nc] = true;\\n                        queue.offer(new int[]{nr, nc});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380398,
                "title": "c-solution-avoid-tle-in-2019",
                "content": "The idea is that find the heights of trees in order as your multiple goals. Then, you go traverse the tree one by one from your goals.\\nOriginally, you can easily pass by the solution like above method. However, new testcases impose extra computing time so that you might encouter TLE issue.\\n\\nHere is what I modify.\\n1) adopt ```pair<int,int>``` instead of ```vector<int>```;\\n2) avoid copying by value operations; this is also common sense.\\n3) try allocate your memory by essential operations, such as int x[][] instead;\\n\\nthe time complexity is O((m*n)\\xB2); then, space complexity is O(m*n).\\n\\nThe following is my implementation. At first section, I fill out my goals, and sort the goals. For that, you can implement it by priority_queue as well. But it might incur extra computing resources like push, pop. Afterwards, at second section, I bfs my shortest path from source to  target spots. After the initated source goal you reach, you pick up the subsequent goal from your candidate goals as your new target, and alter original target into you new source spot. If you cannot get your target for the round, directly return -1; otherwise, you can keep going and accumulating your step.\\n\\n```\\nclass Solution {\\n    const int xs[4] = {0, 0,-1,1};\\n    const int ys[4] = {-1,1, 0,0};\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        std::ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        if (forest.empty() || forest[0].empty())  return -1;\\n        int m = forest.size(),\\n                n = forest[0].size();\\n\\n        vector<vector<int>> goal;\\n\\n        for(int r=0; r < m; r++) {\\n            for(int c=0; c < n; c++) {\\n                if(forest[r][c] > 1) {\\n                    goal.push_back({r,c});\\n                }\\n            }\\n        }\\n\\n        sort(begin(goal), end(goal), [&forest](const vector<int>& a, const vector<int> &b) {\\n            return forest[a[0]][a[1]] < forest[b[0]][b[1]];\\n        });\\n\\n\\n\\n        vector<int> start = {0,0};\\n        int rst = 0;\\n        for(auto &g : goal) {\\n            auto cur = bfs(m,n, start, g, forest);\\n            if( cur == -1) return -1;\\n            rst += cur;\\n            start = g;\\n        }\\n        return rst;\\n    }\\n\\n    int bfs(const int &m, const int& n, vector<int>& src, vector<int>& target, vector<vector<int>>& forest)\\n    {\\n        bool visited[m][n];\\n        memset(visited, 0, sizeof(visited));\\n\\n        queue<pair<int,int>> q;\\n        q.push({src[0],src[1]});\\n        visited[src[0]][src[1]] = true;\\n        register int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for(int i=0; i < sz; ++i) {\\n                auto from = q.front(); q.pop();\\n                if(from.first == target[0] && from.second==target[1]) return step; // to handle the first spot like example 3\\n                for(int d = 0; d < 4; ++d) {\\n                    auto R = from.first+xs[d],\\n                            C = from.second+ys[d];\\n                    if(0<= R && R < m && 0 <= C && C < n && !visited[R][C] && forest[R][C] >= 1) {\\n                        visited[R][C] = true;\\n                        q.push({R,C});\\n                        if(R == target[0] && C == target[1]) return step+1;\\n                    }\\n                }\\n            }\\n            ++step;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```pair<int,int>```\n```vector<int>```\n```\\nclass Solution {\\n    const int xs[4] = {0, 0,-1,1};\\n    const int ys[4] = {-1,1, 0,0};\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        std::ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        if (forest.empty() || forest[0].empty())  return -1;\\n        int m = forest.size(),\\n                n = forest[0].size();\\n\\n        vector<vector<int>> goal;\\n\\n        for(int r=0; r < m; r++) {\\n            for(int c=0; c < n; c++) {\\n                if(forest[r][c] > 1) {\\n                    goal.push_back({r,c});\\n                }\\n            }\\n        }\\n\\n        sort(begin(goal), end(goal), [&forest](const vector<int>& a, const vector<int> &b) {\\n            return forest[a[0]][a[1]] < forest[b[0]][b[1]];\\n        });\\n\\n\\n\\n        vector<int> start = {0,0};\\n        int rst = 0;\\n        for(auto &g : goal) {\\n            auto cur = bfs(m,n, start, g, forest);\\n            if( cur == -1) return -1;\\n            rst += cur;\\n            start = g;\\n        }\\n        return rst;\\n    }\\n\\n    int bfs(const int &m, const int& n, vector<int>& src, vector<int>& target, vector<vector<int>>& forest)\\n    {\\n        bool visited[m][n];\\n        memset(visited, 0, sizeof(visited));\\n\\n        queue<pair<int,int>> q;\\n        q.push({src[0],src[1]});\\n        visited[src[0]][src[1]] = true;\\n        register int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for(int i=0; i < sz; ++i) {\\n                auto from = q.front(); q.pop();\\n                if(from.first == target[0] && from.second==target[1]) return step; // to handle the first spot like example 3\\n                for(int d = 0; d < 4; ++d) {\\n                    auto R = from.first+xs[d],\\n                            C = from.second+ys[d];\\n                    if(0<= R && R < m && 0 <= C && C < n && !visited[R][C] && forest[R][C] >= 1) {\\n                        visited[R][C] = true;\\n                        q.push({R,C});\\n                        if(R == target[0] && C == target[1]) return step+1;\\n                    }\\n                }\\n            }\\n            ++step;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 220020,
                "title": "readable-python-solution-using-heap-and-bfs",
                "content": "```\\ndef cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(forest), len(forest[0])\\n        heap = [(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\\n        heapq.heapify(heap)\\n\\n        def get_distance(x1, y1, x2, y2):\\n            if x1 == x2 and y1 == y2:\\n                return 0\\n            queue, dist, visited = [(x1, y1)], 0, {(x1, y1)}\\n            while queue:\\n                new_queue = []\\n                dist += 1\\n                for r, c in queue:\\n                    for dir in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                        nr, nc = r + dir[0], c + dir[1]\\n                        if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and forest[nr][nc] != 0:\\n                            visited.add((nr, nc))\\n                            if nr == x2 and nc == y2:\\n                                return dist\\n                            new_queue.append((nr, nc))\\n                queue = new_queue\\n            return -1\\n\\n        res = 0\\n        x, y = 0, 0\\n        while heap:\\n            _, nx, ny = heapq.heappop(heap)\\n            dist = get_distance(x, y, nx, ny)\\n            if dist == -1:\\n                return -1\\n            res += dist\\n            x, y = nx, ny\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(forest), len(forest[0])\\n        heap = [(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\\n        heapq.heapify(heap)\\n\\n        def get_distance(x1, y1, x2, y2):\\n            if x1 == x2 and y1 == y2:\\n                return 0\\n            queue, dist, visited = [(x1, y1)], 0, {(x1, y1)}\\n            while queue:\\n                new_queue = []\\n                dist += 1\\n                for r, c in queue:\\n                    for dir in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                        nr, nc = r + dir[0], c + dir[1]\\n                        if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and forest[nr][nc] != 0:\\n                            visited.add((nr, nc))\\n                            if nr == x2 and nc == y2:\\n                                return dist\\n                            new_queue.append((nr, nc))\\n                queue = new_queue\\n            return -1\\n\\n        res = 0\\n        x, y = 0, 0\\n        while heap:\\n            _, nx, ny = heapq.heappop(heap)\\n            dist = get_distance(x, y, nx, ny)\\n            if dist == -1:\\n                return -1\\n            res += dist\\n            x, y = nx, ny\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 217864,
                "title": "c-priority-queue-bfs-solution-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int rows = forest.size();\\n        int cols = rows ? forest[0].size() : 0;\\n        \\n        if (!rows || !cols) {\\n            return 0;\\n        }\\n        \\n        // Start location is blocked\\n        if (forest[0][0] == 0) {\\n            return -1;\\n        }\\n        \\n        // Min queue of trees based on height\\n         priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> trees;\\n        \\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < cols; ++c) {\\n                if (forest[r][c] > 1) {\\n                   trees.push({forest[r][c], {r, c}}); \\n                }\\n            }\\n        }\\n        \\n        // Legal moves\\n        vector<pair<int, int>> moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        // Track visited\\n        vector<vector<int>> visited(rows, vector<int>(cols, -1));\\n        \\n        // Total distance\\n        int totalDist = 0;\\n        \\n        // Start location\\n        pair<int, int> start = {0, 0};\\n        \\n        // Tree ID\\n        int i = 0;\\n        \\n        // Iterate through trees in increasing height order\\n        while (!trees.empty()) {\\n            pair<int, int> to = trees.top().second;\\n            trees.pop();\\n            \\n            // Level order traversal\\n            bool found = false;\\n            int dist = -1;  \\n            queue<pair<int, int>> qu;\\n            \\n            qu.push({start.first, start.second});\\n            visited[start.first][start.second] = i;\\n            \\n            while (!qu.empty() && !found) {\\n                ++dist;\\n                \\n                for (int j = 0, r, c, size = qu.size(); j < size && !found; ++j) {\\n                    tie(r, c) = qu.front();\\n                    qu.pop();\\n                \\n                    // Break if target location found\\n                    if (r == to.first && c == to.second) {\\n                        found = true;\\n                        break;\\n                    }\\n                \\n                    for (int m = 0, nr, nc; m < 4; ++m) {\\n                        // New location\\n                        nr = r + moves[m].first;\\n                        nc = c + moves[m].second;\\n\\n                        // Skip out of bound, blockages and already scheduled\\n                        if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc] == i || forest[nr][nc] == 0) {\\n                            continue;\\n                        }\\n                            \\n                        // Mark visited asap otherwise it will be scheduled mutiple times\\n                        visited[nr][nc] = i;\\n                        qu.push({nr, nc});\\n                    }\\n                }\\n            }\\n            \\n            // Return if not found\\n            if (!found) {\\n                return -1;\\n            }\\n            \\n            // Update total distance\\n            totalDist += dist;\\n            \\n            // Update start\\n            start = to;\\n            \\n            // Update id\\n            ++i;\\n        }\\n        \\n        return totalDist;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int rows = forest.size();\\n        int cols = rows ? forest[0].size() : 0;\\n        \\n        if (!rows || !cols) {\\n            return 0;\\n        }\\n        \\n        // Start location is blocked\\n        if (forest[0][0] == 0) {\\n            return -1;\\n        }\\n        \\n        // Min queue of trees based on height\\n         priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> trees;\\n        \\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < cols; ++c) {\\n                if (forest[r][c] > 1) {\\n                   trees.push({forest[r][c], {r, c}}); \\n                }\\n            }\\n        }\\n        \\n        // Legal moves\\n        vector<pair<int, int>> moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        // Track visited\\n        vector<vector<int>> visited(rows, vector<int>(cols, -1));\\n        \\n        // Total distance\\n        int totalDist = 0;\\n        \\n        // Start location\\n        pair<int, int> start = {0, 0};\\n        \\n        // Tree ID\\n        int i = 0;\\n        \\n        // Iterate through trees in increasing height order\\n        while (!trees.empty()) {\\n            pair<int, int> to = trees.top().second;\\n            trees.pop();\\n            \\n            // Level order traversal\\n            bool found = false;\\n            int dist = -1;  \\n            queue<pair<int, int>> qu;\\n            \\n            qu.push({start.first, start.second});\\n            visited[start.first][start.second] = i;\\n            \\n            while (!qu.empty() && !found) {\\n                ++dist;\\n                \\n                for (int j = 0, r, c, size = qu.size(); j < size && !found; ++j) {\\n                    tie(r, c) = qu.front();\\n                    qu.pop();\\n                \\n                    // Break if target location found\\n                    if (r == to.first && c == to.second) {\\n                        found = true;\\n                        break;\\n                    }\\n                \\n                    for (int m = 0, nr, nc; m < 4; ++m) {\\n                        // New location\\n                        nr = r + moves[m].first;\\n                        nc = c + moves[m].second;\\n\\n                        // Skip out of bound, blockages and already scheduled\\n                        if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc] == i || forest[nr][nc] == 0) {\\n                            continue;\\n                        }\\n                            \\n                        // Mark visited asap otherwise it will be scheduled mutiple times\\n                        visited[nr][nc] = i;\\n                        qu.push({nr, nc});\\n                    }\\n                }\\n            }\\n            \\n            // Return if not found\\n            if (!found) {\\n                return -1;\\n            }\\n            \\n            // Update total distance\\n            totalDist += dist;\\n            \\n            // Update start\\n            start = to;\\n            \\n            // Update id\\n            ++i;\\n        }\\n        \\n        return totalDist;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115685,
                "title": "python-currently-fastest-implementation-610ms-same-method-as-wufangjie-s-perf-improved",
                "content": "Disclaimer:\n* This solution is inspired by @wufangjie's solution (as I summarized below)\n* My contribution is to improve the performance to 610ms (currently fastest among all python submissions, with the second fastest be around 700ms)\n\nSummary of the solution:\n\n1. first floodfill to make sure all trees are reachable for each pair of trees (pairs defined in step 3)\n2. sort distances between all trees, call routine 3 to calculate minimum distance between pairs of trees (with closest height) and return the sum.\n3. calculate the minimum distance between a pair of trees as following:\n3.1. bfs through only the paths which can achieve theoretical minimum distance (i.e. `cost`) between the two points\n3.2. while doing the above bfs, keep a note of the seed nodes which can achieve `cost + 2` distance\n3.3. if 3.1 failed, switch to the next level, which is to bfs from the seed nodes found in 2.2 with `cost += 2`\n3.4. keep the above loop 3.1 ~ 3.3, until there are no more seed nodes for the next level\n\nThis implementation appears to be faster than @wufangjie's and is currently the fastest (i.e. beats 100% of the python solutions as of 2/18/2018). I submitted it three times to confirm that it's the fastest, got: 644 ms, 608 ms, 612 ms, with the second fastest running time from other submissions to be 700ms.\n\nThe first part of the implemention is similar to @wufangjie's, while the last part (i.e. shortest distance between tree pairs) differs in some details. Two major differences:\n\n* The judgement of whether a movement will cost additional 2 steps is unified without many `if` statements.\n* New neighbors are directly added into existing queues without creating temporary lists.\n\nSide note:\n* The usage of `list`s with `append()` and `pop()` for `queue` and `next_queue` are important (as also did in @wufangjie's implementation). Changing them to `deque`s with `append()` and `popleft()` will slow down the perf about three times.\n\n```\nclass Solution:\n    d = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def cutOffTree(self, forest):\n        #print(forest)\n        rows = len(forest)\n        if rows == 0:\n            return 0\n\n        cols = len(forest[0])\n        if cols == 0:\n            return 0\n\n        forest.append([0] * cols)\n        for row in forest:\n            row.append(0)\n\n        trees = {(r, c) for c in range(cols) for r in range(rows) if forest[r][c] > 1}\n\n        visited = {(0, 0)}\n        queue = [(0, 0)]\n        while len(queue) != 0:\n            r, c = queue.pop()\n            for nr, nc in ((r + dr, c + dc) for dr, dc in self.d):\n                if (nr, nc) not in visited and forest[nr][nc] > 0:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n\n        if trees.difference(visited):\n            return -1\n\n        trees = sorted(trees, key=lambda t: forest[t[0]][t[1]])\n        if trees[0] != (0, 0):\n            trees.insert(0, (0, 0))\n        num_trees = len(trees)\n        #print('TREES:', trees)\n\n        total_steps = 0\n        for i in range(1, num_trees):\n            pr, pc = p = trees[i - 1]\n            qr, qc = q = trees[i]\n            cost = abs(pr - qr) + abs(pc - qc)\n\n            queue, next_queue = [], [] # Using list: 0.53s, 0.52s, 0.54s\n            #queue, next_queue = deque(), deque() # Using deque: 1.45s, 1.50s, 1.46s\n            queue.append(p)\n            visited, pending_visited = {p}, set()\n            while len(queue) + len(next_queue) != 0:\n                if len(queue) == 0:\n                    queue = next_queue\n                    next_queue = deque()\n\n                    visited.update(pending_visited)\n                    pending_visited = set()\n                    cost += 2\n\n                (r, c) = queue.pop() # Using list\n                #(r, c) = queue.popleft() # Using deque\n                #print('POP', r, c, cost)\n\n                safe_dr = qr - r\n                safe_dr = safe_dr and safe_dr // abs(safe_dr)\n                safe_dc = qc - c\n                safe_dc = safe_dc and safe_dc // abs(safe_dc)\n                for dr, dc in self.d:\n                    nbr = (r + dr, c + dc)\n                    if nbr not in visited and forest[nbr[0]][nbr[1]] > 0:\n                        #print('SAFE', (safe_dr, safe_dc), 'D', (dr, dc))\n                        if (dr == safe_dr and dc != -safe_dc) or (dc == safe_dc and dr != -safe_dr):\n                            queue.append(nbr)\n                            visited.add(nbr)\n                            ncost = cost\n                            #print('PUSH', nbr)\n                        else:\n                            next_queue.append(nbr)\n                            pending_visited.add(nbr)\n                            ncost = cost + 2\n                            #print('PUSH NEXT', nbr)\n                        if nbr == q:\n                            #print('COST:', p, q, ncost)\n                            total_steps += ncost\n                            queue = next_queue = list()\n                            break\n\n                # print('MAP', cost)\n                # for rr in range(rows):\n                #     for cc in range(cols):\n                #         if (rr, cc) == (r, c):\n                #             print('*', end='')\n                #         elif (rr, cc) in queue:\n                #             print('Q', end='')\n                #         elif (rr, cc) in visited:\n                #             print('+', end='')\n                #         elif (rr, cc) in next_queue:\n                #             print('N', end='')\n                #         else:\n                #             print(forest[rr][cc], end='')\n                #     print()\n\n        return total_steps\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    d = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def cutOffTree(self, forest):\n        #print(forest)\n        rows = len(forest)\n        if rows == 0:\n            return 0\n\n        cols = len(forest[0])\n        if cols == 0:\n            return 0\n\n        forest.append([0] * cols)\n        for row in forest:\n            row.append(0)\n\n        trees = {(r, c) for c in range(cols) for r in range(rows) if forest[r][c] > 1}\n\n        visited = {(0, 0)}\n        queue = [(0, 0)]\n        while len(queue) != 0:\n            r, c = queue.pop()\n            for nr, nc in ((r + dr, c + dc) for dr, dc in self.d):\n                if (nr, nc) not in visited and forest[nr][nc] > 0:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n\n        if trees.difference(visited):\n            return -1\n\n        trees = sorted(trees, key=lambda t: forest[t[0]][t[1]])\n        if trees[0] != (0, 0):\n            trees.insert(0, (0, 0))\n        num_trees = len(trees)\n        #print('TREES:', trees)\n\n        total_steps = 0\n        for i in range(1, num_trees):\n            pr, pc = p = trees[i - 1]\n            qr, qc = q = trees[i]\n            cost = abs(pr - qr) + abs(pc - qc)\n\n            queue, next_queue = [], [] # Using list: 0.53s, 0.52s, 0.54s\n            #queue, next_queue = deque(), deque() # Using deque: 1.45s, 1.50s, 1.46s\n            queue.append(p)\n            visited, pending_visited = {p}, set()\n            while len(queue) + len(next_queue) != 0:\n                if len(queue) == 0:\n                    queue = next_queue\n                    next_queue = deque()\n\n                    visited.update(pending_visited)\n                    pending_visited = set()\n                    cost += 2\n\n                (r, c) = queue.pop() # Using list\n                #(r, c) = queue.popleft() # Using deque\n                #print('POP', r, c, cost)\n\n                safe_dr = qr - r\n                safe_dr = safe_dr and safe_dr // abs(safe_dr)\n                safe_dc = qc - c\n                safe_dc = safe_dc and safe_dc // abs(safe_dc)\n                for dr, dc in self.d:\n                    nbr = (r + dr, c + dc)\n                    if nbr not in visited and forest[nbr[0]][nbr[1]] > 0:\n                        #print('SAFE', (safe_dr, safe_dc), 'D', (dr, dc))\n                        if (dr == safe_dr and dc != -safe_dc) or (dc == safe_dc and dr != -safe_dr):\n                            queue.append(nbr)\n                            visited.add(nbr)\n                            ncost = cost\n                            #print('PUSH', nbr)\n                        else:\n                            next_queue.append(nbr)\n                            pending_visited.add(nbr)\n                            ncost = cost + 2\n                            #print('PUSH NEXT', nbr)\n                        if nbr == q:\n                            #print('COST:', p, q, ncost)\n                            total_steps += ncost\n                            queue = next_queue = list()\n                            break\n\n                # print('MAP', cost)\n                # for rr in range(rows):\n                #     for cc in range(cols):\n                #         if (rr, cc) == (r, c):\n                #             print('*', end='')\n                #         elif (rr, cc) in queue:\n                #             print('Q', end='')\n                #         elif (rr, cc) in visited:\n                #             print('+', end='')\n                #         elif (rr, cc) in next_queue:\n                #             print('N', end='')\n                #         else:\n                #             print(forest[rr][cc], end='')\n                #     print()\n\n        return total_steps\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928744,
                "title": "python-3-19-lines-bfs-t-m-91-21",
                "content": "This code is similar to those in other posts, with one exception. We use `unseen` to prune out the zero cells initially, and then keep track of the cells *not* visited.\\n```\\nclass Solution:\\n\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n\\n        def bfs(beg, end):\\n            queue, uns = deque([(beg,0)]), unseen.copy()\\n            uns.discard(beg)\\n\\n            while queue:\\n                (r,c), steps = queue.popleft()\\n\\n                if (r,c) == end: return steps\\n\\n                for R,C in ((r-1,c), (r,c-1), (r+1,c), (r,c+1)):\\n\\n                    if (R,C) not in uns: continue\\n\\n                    queue.append(((R,C),steps+1))\\n                    uns.discard((R,C))\\n\\n            return -1\\n        \\n        m, n, ans = len(forest), len(forest[0]), 0\\n        start, trees = (0,0), []\\n\\n        grid = tuple(product(range(m), range(n)))\\n        unseen = set(filter(lambda x: forest[x[0]][x[1]] != 0, grid))\\n\\n        for r,c  in grid:\\n            if forest[r][c] > 1: heappush(trees,(forest[r][c], (r,c)))\\n\\n        while trees:\\n            if (res:= bfs(start,(pos:= heappop(trees)[1]))) < 0: return -1\\n\\n            ans += res\\n            start = pos\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/cut-off-trees-for-golf-event/submissions/1025189951/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*log*N*), in which *N* ~ number of cells in the 2D array`forest` (which is `len(forest)*len(forest[0])`).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n\\n        def bfs(beg, end):\\n            queue, uns = deque([(beg,0)]), unseen.copy()\\n            uns.discard(beg)\\n\\n            while queue:\\n                (r,c), steps = queue.popleft()\\n\\n                if (r,c) == end: return steps\\n\\n                for R,C in ((r-1,c), (r,c-1), (r+1,c), (r,c+1)):\\n\\n                    if (R,C) not in uns: continue\\n\\n                    queue.append(((R,C),steps+1))\\n                    uns.discard((R,C))\\n\\n            return -1\\n        \\n        m, n, ans = len(forest), len(forest[0]), 0\\n        start, trees = (0,0), []\\n\\n        grid = tuple(product(range(m), range(n)))\\n        unseen = set(filter(lambda x: forest[x[0]][x[1]] != 0, grid))\\n\\n        for r,c  in grid:\\n            if forest[r][c] > 1: heappush(trees,(forest[r][c], (r,c)))\\n\\n        while trees:\\n            if (res:= bfs(start,(pos:= heappop(trees)[1]))) < 0: return -1\\n\\n            ans += res\\n            start = pos\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722257,
                "title": "c-getting-accepted-and-tle-with-same-code",
                "content": "*  ***This same sol is submitting TLE and was approved following a few submissions without any changes.***\\n*  ***I\\'ve experienced this rather frequently.***\\n*  ***Has anyone encountered this issue??***\\n```\\nclass Solution {\\n    vector<int> dx{0,0,1,-1},dy{-1,1,0,0};\\n    int n,m;\\n    int BFS(vector<vector<int>>& forest ,int sx,int sy,int ex, int ey){\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));int c = 0;\\n        queue<pair<int,int>> q;\\n        q.push({sx,sy});\\n        vis[sx][sy] = true;\\n        \\n        while(!q.empty()){\\n            int qs = q.size();\\n            while(qs--){\\n                \\n                pair<int,int> p = q.front();q.pop();\\n                \\n                if(p.first == ex and p.second == ey) return c;\\n                for(int i = 0;i<4;i++){\\n                    int newX=p.first + dx[i];\\n                    int newY=p.second + dy[i];\\n                    if(newX<0 || newY<0 || newX==n || newY==m || forest[newX][newY]==0 || vis[newX][newY]==true)continue;\\n                    vis[newX][newY]=true;\\n                    q.push({newX,newY});\\n                }\\n            }c++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int ans = 0;n=forest.size(),m=forest[0].size();\\n        vector<vector<int>> v;\\n        for(int i = 0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(forest[i][j]>1) v.push_back({forest[i][j],i,j});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        int sx = 0,sy=0;\\n        for(auto it:v){\\n            int minStepsForNextTree = BFS(forest,sx,sy,it[1],it[2]);\\n            if(minStepsForNextTree==-1) return -1;\\n            ans+=minStepsForNextTree;\\n            sx = it[1],sy=it[2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dx{0,0,1,-1},dy{-1,1,0,0};\\n    int n,m;\\n    int BFS(vector<vector<int>>& forest ,int sx,int sy,int ex, int ey){\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));int c = 0;\\n        queue<pair<int,int>> q;\\n        q.push({sx,sy});\\n        vis[sx][sy] = true;\\n        \\n        while(!q.empty()){\\n            int qs = q.size();\\n            while(qs--){\\n                \\n                pair<int,int> p = q.front();q.pop();\\n                \\n                if(p.first == ex and p.second == ey) return c;\\n                for(int i = 0;i<4;i++){\\n                    int newX=p.first + dx[i];\\n                    int newY=p.second + dy[i];\\n                    if(newX<0 || newY<0 || newX==n || newY==m || forest[newX][newY]==0 || vis[newX][newY]==true)continue;\\n                    vis[newX][newY]=true;\\n                    q.push({newX,newY});\\n                }\\n            }c++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int ans = 0;n=forest.size(),m=forest[0].size();\\n        vector<vector<int>> v;\\n        for(int i = 0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(forest[i][j]>1) v.push_back({forest[i][j],i,j});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        int sx = 0,sy=0;\\n        for(auto it:v){\\n            int minStepsForNextTree = BFS(forest,sx,sy,it[1],it[2]);\\n            if(minStepsForNextTree==-1) return -1;\\n            ans+=minStepsForNextTree;\\n            sx = it[1],sy=it[2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153337,
                "title": "nightmare-for-python-coders",
                "content": "I bothered to try different Python algorithms on the forum. Only the one which used A* passes reliably. I also tried to optimize my BFS code, comparing heap vs sort, and using set vs array to store visited (array seems to be a little faster). None of them yield a big difference.\\n\\nI found that a monstrous testcase (54) causes similar amount of time between A* and BFS, but A* is consistently faster than BFS in earlier testcases.",
                "solutionTags": [],
                "code": "I bothered to try different Python algorithms on the forum. Only the one which used A* passes reliably. I also tried to optimize my BFS code, comparing heap vs sort, and using set vs array to store visited (array seems to be a little faster). None of them yield a big difference.\\n\\nI found that a monstrous testcase (54) causes similar amount of time between A* and BFS, but A* is consistently faster than BFS in earlier testcases.",
                "codeTag": "Unknown"
            },
            {
                "id": 1835440,
                "title": "java-arraylist-bfs-no-tle-with-clear-explanation-and-comments",
                "content": "**Complexities**\\n- Time Complexity: O(N^2 * M^2)\\n- Space Complexity: O (N * M)\\n\\n**Thinking Process**\\n1. All trees shall be cut in the order of height -> we shall create a list to store all of their heights and sort the list after all trees have been found\\n2. Find the total steps need to cut all trees \\n\\t- Traverse through all tree -> traverse the list from index 0 (the tree with the smallest height)\\n\\t- Move to the next tree to cut -> use BFS to find the shortest path from current location to it\\n\\t(If a tree is unreacheable, then return -1)\\n\\n\\n**PS**: \\n1. *Why use ArrayList instead of PriorityQueue*? \\n\\tWe only need the **final** list to be sorted. If we were using PQ, then every insertion/deletion would need O(logK) time (K == size of PQ), making the process of adding all trees with a time complexity O(K log K) and polling all trees from the PQ with O(K log K). In comparison, ArrayList would only need to be sorted after all trees have been added, which having a time complexity of O(K log K) [< O(2K logK) if using PQ].\\n\\n\\nPlease let me know if there\\'s any mistakes. Thanks in advance.\\n\\n```\\nclass Solution {\\n    static int[] dy = {-1, 0, 1, 0};\\n    static int[] dx = {0, 1, 0, -1};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int n = forest.size(), m = forest.get(0).size();\\n        int count = 0;\\n        \\n\\t\\t// Store the height of all trees in a list\\n        List<Integer> minList = new ArrayList<>();\\n        for (List<Integer> al: forest)\\n            for (int val: al) \\n                if (val > 1) \\n                    minList.add(val);\\n        \\n\\t\\t// Sort the list to have the smallest in the front\\n        Collections.sort(minList);\\n\\t\\t\\n        int totalSteps = 0;\\n        int si = 0, sj = 0; // Starting points <i, j>\\n        \\n        for (int i = 0; i < minList.size(); i++) {\\n            int target = minList.get(i);\\n            boolean hasFound = false;\\n            boolean[][] visited = new boolean[n][m];\\n\\t\\t\\t\\n            Queue<int[]> q = new LinkedList<>();\\n            q.offer(new int[]{si, sj});\\n        \\n            int steps = -1;\\n            while (!q.isEmpty() && !hasFound) {\\n                steps++; // Increment the steps for current move\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Level-Order Traversal\\n\\t\\t\\t\\tint size = q.size();\\n                while (size -- > 0) {\\n                    int[] curr = q.poll();\\n\\t\\t\\t\\t\\t\\n                    if (visited[curr[0]][curr[1]]) continue;\\n                    visited[curr[0]][curr[1]] = true;\\n                    \\n\\t\\t\\t\\t\\t// Skip if 0 is encountered\\n                    if (forest.get(curr[0]).get(curr[1]) == 0) continue;\\n                    \\n\\t\\t\\t\\t\\tif (forest.get(curr[0]).get(curr[1]) == target) {\\n                        si = curr[0];\\n                        sj = curr[1];\\n                        hasFound = true;\\n                        break;\\n                    }\\n\\n\\t\\t\\t\\t\\t// Typical BFS process\\n                    for (int j = 0; j < dy.length; j++) {\\n                        int y = curr[0] + dy[j];\\n                        int x = curr[1] + dx[j];\\n\\t\\t\\t\\t\\t\\t\\n                        if (y >= n || x >= m || y < 0 || x < 0 || visited[y][x] || forest.get(y).get(x) == 0)   \\n                            continue;\\n                        q.offer(new int[]{y, x});\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If the target is unreacheable, end the entire process\\n            if (steps == -1 || !hasFound) return -1;\\n\\n\\t\\t\\ttotalSteps += steps;\\n        }\\n        return totalSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    static int[] dy = {-1, 0, 1, 0};\\n    static int[] dx = {0, 1, 0, -1};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int n = forest.size(), m = forest.get(0).size();\\n        int count = 0;\\n        \\n\\t\\t// Store the height of all trees in a list\\n        List<Integer> minList = new ArrayList<>();\\n        for (List<Integer> al: forest)\\n            for (int val: al) \\n                if (val > 1) \\n                    minList.add(val);\\n        \\n\\t\\t// Sort the list to have the smallest in the front\\n        Collections.sort(minList);\\n\\t\\t\\n        int totalSteps = 0;\\n        int si = 0, sj = 0; // Starting points <i, j>\\n        \\n        for (int i = 0; i < minList.size(); i++) {\\n            int target = minList.get(i);\\n            boolean hasFound = false;\\n            boolean[][] visited = new boolean[n][m];\\n\\t\\t\\t\\n            Queue<int[]> q = new LinkedList<>();\\n            q.offer(new int[]{si, sj});\\n        \\n            int steps = -1;\\n            while (!q.isEmpty() && !hasFound) {\\n                steps++; // Increment the steps for current move\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Level-Order Traversal\\n\\t\\t\\t\\tint size = q.size();\\n                while (size -- > 0) {\\n                    int[] curr = q.poll();\\n\\t\\t\\t\\t\\t\\n                    if (visited[curr[0]][curr[1]]) continue;\\n                    visited[curr[0]][curr[1]] = true;\\n                    \\n\\t\\t\\t\\t\\t// Skip if 0 is encountered\\n                    if (forest.get(curr[0]).get(curr[1]) == 0) continue;\\n                    \\n\\t\\t\\t\\t\\tif (forest.get(curr[0]).get(curr[1]) == target) {\\n                        si = curr[0];\\n                        sj = curr[1];\\n                        hasFound = true;\\n                        break;\\n                    }\\n\\n\\t\\t\\t\\t\\t// Typical BFS process\\n                    for (int j = 0; j < dy.length; j++) {\\n                        int y = curr[0] + dy[j];\\n                        int x = curr[1] + dx[j];\\n\\t\\t\\t\\t\\t\\t\\n                        if (y >= n || x >= m || y < 0 || x < 0 || visited[y][x] || forest.get(y).get(x) == 0)   \\n                            continue;\\n                        q.offer(new int[]{y, x});\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If the target is unreacheable, end the entire process\\n            if (steps == -1 || !hasFound) return -1;\\n\\n\\t\\t\\ttotalSteps += steps;\\n        }\\n        return totalSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306264,
                "title": "python-bidirectional-bfs-accepted",
                "content": "Python seems to be too slow unless BFS is bothways. \\n\\n```\\nclass Solution:\\n  def processQueue(self, queue, selfVisited, targetVisited):\\n    for _ in range(len(queue)):\\n        cr, cc = queue.popleft()\\n        if (cr, cc) in targetVisited:\\n          return True\\n\\n        for d in self.dir:\\n          nr, nc = cr + d[0], cc + d[1]\\n          if nr >= self.R or nc >= self.C or nr < 0 or nc < 0:\\n            continue\\n          if self.fr[nr][nc] == 0:\\n            continue\\n          if (nr, nc) in selfVisited:\\n            continue\\n          queue.append((nr, nc))\\n          selfVisited.add((nr,nc))\\n        \\n    return False\\n  \\n  def findNext(self, pos, target):\\n    beginque= deque()\\n    endque= deque()\\n    beginque.append(pos)\\n    endque.append(target)\\n    step = 0\\n    visitedFromBegin = set()\\n    visitedFromBegin.add(pos)\\n    visitedFromEnd = set()\\n    visitedFromEnd.add(target)\\n\\n    while beginque or endque:\\n      if self.processQueue(beginque, visitedFromBegin, visitedFromEnd):\\n        return step\\n      step += 1\\n    \\n      if self.processQueue(endque, visitedFromEnd, visitedFromBegin):\\n        return step\\n      step += 1\\n          \\n    return -1\\n\\n\\n  def cutOffTree(self, forest: List[List[int]]) -> int:\\n    self.dir = [(0,1), (1,0), (0,-1), (-1,0)]\\n    self.fr = forest\\n    self.R = len(forest)\\n    self.C = len(forest[0])\\n\\n    trees = []\\n    treePos = dict()\\n    for r in range(self.R):\\n      for c in range(self.C):\\n        if self.fr[r][c] > 0:\\n          trees.append(self.fr[r][c])\\n          treePos[self.fr[r][c]] = (r,c)\\n\\n    trees.sort(reverse=True)\\n\\n    ret = 0\\n    pos = (0,0)\\n    while trees:\\n      nextTree = trees.pop()\\n      if nextTree == 1:\\n        continue\\n      steps = self.findNext(pos, treePos[nextTree])\\n      if steps == -1:\\n        return -1\\n      ret += steps\\n      pos = treePos[nextTree]\\n\\n    return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def processQueue(self, queue, selfVisited, targetVisited):\\n    for _ in range(len(queue)):\\n        cr, cc = queue.popleft()\\n        if (cr, cc) in targetVisited:\\n          return True\\n\\n        for d in self.dir:\\n          nr, nc = cr + d[0], cc + d[1]\\n          if nr >= self.R or nc >= self.C or nr < 0 or nc < 0:\\n            continue\\n          if self.fr[nr][nc] == 0:\\n            continue\\n          if (nr, nc) in selfVisited:\\n            continue\\n          queue.append((nr, nc))\\n          selfVisited.add((nr,nc))\\n        \\n    return False\\n  \\n  def findNext(self, pos, target):\\n    beginque= deque()\\n    endque= deque()\\n    beginque.append(pos)\\n    endque.append(target)\\n    step = 0\\n    visitedFromBegin = set()\\n    visitedFromBegin.add(pos)\\n    visitedFromEnd = set()\\n    visitedFromEnd.add(target)\\n\\n    while beginque or endque:\\n      if self.processQueue(beginque, visitedFromBegin, visitedFromEnd):\\n        return step\\n      step += 1\\n    \\n      if self.processQueue(endque, visitedFromEnd, visitedFromBegin):\\n        return step\\n      step += 1\\n          \\n    return -1\\n\\n\\n  def cutOffTree(self, forest: List[List[int]]) -> int:\\n    self.dir = [(0,1), (1,0), (0,-1), (-1,0)]\\n    self.fr = forest\\n    self.R = len(forest)\\n    self.C = len(forest[0])\\n\\n    trees = []\\n    treePos = dict()\\n    for r in range(self.R):\\n      for c in range(self.C):\\n        if self.fr[r][c] > 0:\\n          trees.append(self.fr[r][c])\\n          treePos[self.fr[r][c]] = (r,c)\\n\\n    trees.sort(reverse=True)\\n\\n    ret = 0\\n    pos = (0,0)\\n    while trees:\\n      nextTree = trees.pop()\\n      if nextTree == 1:\\n        continue\\n      steps = self.findNext(pos, treePos[nextTree])\\n      if steps == -1:\\n        return -1\\n      ret += steps\\n      pos = treePos[nextTree]\\n\\n    return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281999,
                "title": "java-solution-explained",
                "content": "Before moving into the solution there are a couple of questions to be asked during the interview.\\n* What if the first cell is 0?\\n* Can there be a tree in the start location (0, 0)?\\n* Can we walk though the trees?\\n* What is the behaviour if there are trees with same height? Is there any preference order to be considered?\\n\\nKeeping the above points in mind, we can arrive at the below algorithm.\\n* Define a class which stores the cell information containing x, y location and the tree height.\\n* We need trees sorted in non-decreasing order while travelling through the forest. A min heap (priority queue) is a good choice for the same.\\n* While adding cell information to the min heap, make sure only the trees are added and not the cells containing 0 or 1.\\n* We need to find out the minimum distance to be travelled from the given source and the destination. We can pick BFS to find it.\\n\\nWhen do I know if there is no possible path to cut all the trees in the forest?\\n* If the start location contains a 0 value.\\n* If there is no path for the given source and destination, i.e no path between tree1 and tree2 with increasing heights.\\n\\n```\\nclass Solution {\\n    class Cell implements Comparable<Cell> {\\n        int x;\\n        int y;\\n        int tree;\\n        public Cell(int x, int y, int tree) {\\n            this.x = x;\\n            this.y = y;\\n            this.tree = tree;\\n        }\\n        public int compareTo(Cell cell) {\\n            return this.tree <= cell.tree ? -1 : 1;\\n        }\\n        public boolean equals(Cell cell) {\\n            return this.x == cell.x && this.y == cell.y;\\n        }\\n    }\\n    \\n    int N, M;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<Cell> pq = new PriorityQueue<>();\\n        N = forest.size();\\n        M = forest.get(0).size();\\n        for(int i=0; i<N; i++) {\\n            for(int j=0; j<M; j++) {\\n                if(forest.get(i).get(j) > 1)\\n                    pq.add(new Cell(i, j, forest.get(i).get(j)));\\n            }\\n        }\\n        \\n        int minPath = 0;\\n        if(forest.get(0).get(0) == 0) {\\n            return -1;\\n        }\\n        \\n        Cell source = new Cell(0,0,forest.get(0).get(0));\\n        while(!pq.isEmpty()) {\\n            Cell dest = pq.remove();\\n            int path = getMinPath(forest, source, dest);\\n            if(path == -1)\\n                return -1;\\n\\n            minPath += path;\\n            source = dest;\\n        }\\n        \\n        return minPath;\\n    }\\n    \\n    int[][] dir = new int[][]{{1,0}, {0,1}, {-1,0}, {0,-1}};\\n    private int getMinPath(List<List<Integer>> forest, Cell source, Cell dest) {\\n        Deque<Cell> queue = new ArrayDeque<>();\\n        boolean[][] isVisited = new boolean[N][M];\\n        queue.add(source);\\n        int path = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Cell cell = queue.remove();\\n                if(cell.equals(dest)) {\\n                    return path;\\n                }\\n                \\n                for(int k=0; k<4; k++) {\\n                    int x = cell.x + dir[k][0];\\n                    int y = cell.y + dir[k][1];\\n                    if(checkBoundary(x, y, N, M) && !isVisited[x][y] && forest.get(x).get(y) != 0) {\\n                        queue.add(new Cell(x, y, forest.get(x).get(y)));\\n                        isVisited[x][y] = true;\\n                    }\\n                }\\n            }\\n            path++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean checkBoundary(int x, int y, int N, int M) {\\n        return x>=0 && y>=0 && x<N && y<M;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Cell implements Comparable<Cell> {\\n        int x;\\n        int y;\\n        int tree;\\n        public Cell(int x, int y, int tree) {\\n            this.x = x;\\n            this.y = y;\\n            this.tree = tree;\\n        }\\n        public int compareTo(Cell cell) {\\n            return this.tree <= cell.tree ? -1 : 1;\\n        }\\n        public boolean equals(Cell cell) {\\n            return this.x == cell.x && this.y == cell.y;\\n        }\\n    }\\n    \\n    int N, M;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<Cell> pq = new PriorityQueue<>();\\n        N = forest.size();\\n        M = forest.get(0).size();\\n        for(int i=0; i<N; i++) {\\n            for(int j=0; j<M; j++) {\\n                if(forest.get(i).get(j) > 1)\\n                    pq.add(new Cell(i, j, forest.get(i).get(j)));\\n            }\\n        }\\n        \\n        int minPath = 0;\\n        if(forest.get(0).get(0) == 0) {\\n            return -1;\\n        }\\n        \\n        Cell source = new Cell(0,0,forest.get(0).get(0));\\n        while(!pq.isEmpty()) {\\n            Cell dest = pq.remove();\\n            int path = getMinPath(forest, source, dest);\\n            if(path == -1)\\n                return -1;\\n\\n            minPath += path;\\n            source = dest;\\n        }\\n        \\n        return minPath;\\n    }\\n    \\n    int[][] dir = new int[][]{{1,0}, {0,1}, {-1,0}, {0,-1}};\\n    private int getMinPath(List<List<Integer>> forest, Cell source, Cell dest) {\\n        Deque<Cell> queue = new ArrayDeque<>();\\n        boolean[][] isVisited = new boolean[N][M];\\n        queue.add(source);\\n        int path = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Cell cell = queue.remove();\\n                if(cell.equals(dest)) {\\n                    return path;\\n                }\\n                \\n                for(int k=0; k<4; k++) {\\n                    int x = cell.x + dir[k][0];\\n                    int y = cell.y + dir[k][1];\\n                    if(checkBoundary(x, y, N, M) && !isVisited[x][y] && forest.get(x).get(y) != 0) {\\n                        queue.add(new Cell(x, y, forest.get(x).get(y)));\\n                        isVisited[x][y] = true;\\n                    }\\n                }\\n            }\\n            path++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean checkBoundary(int x, int y, int N, int M) {\\n        return x>=0 && y>=0 && x<N && y<M;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841018,
                "title": "simple-bfs-priority-queue-solution-beats-90",
                "content": "Approach -> Apply BFS from src node (initially (0,0))  to the smallest node with value >1. If there is no path then return -1. Else continue the iteration until you have cut all the trees in ascending order or you can\\'t find a path anymore.\\n\\nclass Solution {\\npublic:\\n    bool is_valid(int x,int y,int n,int m,vector<vector<int>> &mat)\\n    {\\n        if(x<0 || x>=n || y<0 || y>=m || mat[x][y]==0)\\n            return false;\\n        \\n        return true;\\n    }\\n    int cutOffTree(vector<vector<int>>& mat) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        if(n==0)\\n            return 0;\\n        \\n        if(mat[0][0]==0)\\n            return -1;\\n        int curr_x=0,curr_y=0;\\n        int ans=0;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]>1)\\n                pq.push({-mat[i][j],{i,j}});\\n            }\\n        }\\n        bool vis[n][m];\\n        while(!pq.empty())\\n        {\\n            pair<int,pair<int,int>> t=pq.top();\\n            pq.pop();\\n            int final_x=t.second.first;\\n            int final_y=t.second.second;\\n            queue<pair<int,int>> q;\\n            q.push({curr_x,curr_y});\\n            memset(vis,false,sizeof vis);\\n            vis[curr_x][curr_y]=true;\\n            int lvl=0;\\n            int arr[]={1,0,-1,0};\\n            int brr[]={0,1,0,-1};\\n            bool ok=false;\\n            while(!q.empty())\\n            {\\n                int si=q.size();\\n                for(int i=0;i<si;i++)\\n                {\\n                    pair<int,int> s=q.front();\\n                    q.pop();\\n                    if(s.first==final_x && s.second==final_y)\\n                    {\\n                        ans+=lvl;\\n                        ok=true;\\n                        break;\\n                    }\\n                    for(int i=0;i<4;i++)\\n                    {\\n                       int x=s.first+arr[i];\\n                       int y=s.second+brr[i];\\n                       if(is_valid(x,y,n,m,mat))\\n                       {\\n                          if(vis[x][y]==false)\\n                          {\\n                            vis[x][y]=true;\\n                            q.push({x,y});\\n                          }\\n                       }\\n                    }\\n                }\\n                if(ok)\\n                    break;\\n                \\n                lvl++;\\n            }\\n            if(ok==false)\\n                return -1;\\n            \\n            curr_x=final_x;\\n            curr_y=final_y;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool is_valid(int x,int y,int n,int m,vector<vector<int>> &mat)\\n    {\\n        if(x<0 || x>=n || y<0 || y>=m || mat[x][y]==0)\\n            return false;\\n        \\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 559865,
                "title": "simple-python-bfs-no-tle",
                "content": "I modified the solution to pass in length or rows and columns and did visited True before adding to queue, that got rid of TLE.\\nRuntime:  6252 ms\\tMemory: 14.2 MB Rank: 58%\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        \\n        m, n = len(forest), len(forest[0])\\n        trees = []\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                v = forest[r][c]\\n                if v > 1:\\n                    trees.append((v, r, c)) \\n                \\n        trees.sort()\\n        \\n        sr, sc = 0, 0\\n        total_cost = 0\\n        for tree in trees:\\n            height, tr, tc = tree\\n            d = self.bfs(forest, sr, sc, tr, tc, m, n)\\n            if d < 0: return -1\\n            total_cost += d\\n            sr, sc = tr, tc\\n            \\n        return total_cost\\n    \\n    def bfs(self, forest, sx, sy, tx, ty, m, n):\\n        \\n        queue = collections.deque([(sx, sy, 0)])\\n        visited = [[False]*n for _ in range(m)]\\n        visited[sx][sy] = True\\n        \\n        while queue:\\n            sr, sc, d = queue.popleft()\\n            if sr == tx and sc == ty: return d\\n            for x, y in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n                nr, nc = sr+x, sc+y\\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and forest[nr][nc]:\\n                    visited[nr][nc] = True\\n                    queue.append((nr, nc, d+1))\\n        \\n        return -1\\n\\t\\t",
                "solutionTags": [],
                "code": "I modified the solution to pass in length or rows and columns and did visited True before adding to queue, that got rid of TLE.\\nRuntime:  6252 ms\\tMemory: 14.2 MB Rank: 58%\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        \\n        m, n = len(forest), len(forest[0])\\n        trees = []\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                v = forest[r][c]\\n                if v > 1:\\n                    trees.append((v, r, c)) \\n                \\n        trees.sort()\\n        \\n        sr, sc = 0, 0\\n        total_cost = 0\\n        for tree in trees:\\n            height, tr, tc = tree\\n            d = self.bfs(forest, sr, sc, tr, tc, m, n)\\n            if d < 0: return -1\\n            total_cost += d\\n            sr, sc = tr, tc\\n            \\n        return total_cost\\n    \\n    def bfs(self, forest, sx, sy, tx, ty, m, n):\\n        \\n        queue = collections.deque([(sx, sy, 0)])\\n        visited = [[False]*n for _ in range(m)]\\n        visited[sx][sy] = True\\n        \\n        while queue:\\n            sr, sc, d = queue.popleft()\\n            if sr == tx and sc == ty: return d\\n            for x, y in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n                nr, nc = sr+x, sc+y\\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and forest[nr][nc]:\\n                    visited[nr][nc] = True\\n                    queue.append((nr, nc, d+1))\\n        \\n        return -1\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 470408,
                "title": "python-bfs",
                "content": "whats the cost of path p \\n```\\npath p == [u,v,w,x,y,z]\\n```\\n\\nits the cumulative total cost\\n+ cost to get from u to v \\n+ cost to get from v to w \\n+ cost to get from w to x .\\n+ etc...\\n\\nthe order we want is from smallest tree to highest\\nthe nodes are actually coordinates, and their value in grid is used to rank them\\n```\\ns = [(i,j) for i in range(len(f)) for j in range(len(f[0])) if f[i][j]]                \\ns.sort(key = lambda x: f[x[0]][x[1]])\\n```\\nand we always start by (0,0)\\n```\\ns = [(0,0)] + s\\n```\\ncumul is the answer\\n```\\ncumul = 0\\nfor u,v in zip(s,s[1:]): \\n\\tcumul += self.bfs(u,v,f)\\n\\tif cumul == float(\\'inf\\'): return -1\\nreturn cumul\\n```\\n\\nyou can walk passed uncut tree if, I was checking that the height would be strictly increasing from (0,0), but you can actually walk through a tree\\nthe only forbidden cell is the zero\\n\\n\\n\\n\\ncode\\n```\\nclass Solution(object):\\n    def cutOffTree(self, f):\\n        s = [(i,j) for i in range(len(f)) for j in range(len(f[0])) if f[i][j]]                \\n        s.sort(key = lambda x: f[x[0]][x[1]])\\n        s = [(0,0)] + s\\n        cumul = 0\\n        for u,v in zip(s,s[1:]): \\n            cumul += self.bfs(u,v,f)\\n            if cumul == float(\\'inf\\'): return -1\\n        return cumul\\n    \\n    def bfs(self,source,target,grid):\\n        q,vis = collections.deque([(source,0)]),set([source])\\n        while(q):\\n            u,steps  = q.popleft()\\n            if u == target: return steps\\n            for v in [(u[0]-1,u[1]), (u[0]+1,u[1]), (u[0],u[1]-1), (u[0],u[1]+1)]:\\n                if 0 <= v[0] < len(grid) and 0 <= v[1] < len(grid[0]) and grid[v[0]][v[1]] != 0 and v not in vis:\\n                    vis.add(v)\\n                    q.append((v,steps + 1))\\n        return +float(\\'inf\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\npath p == [u,v,w,x,y,z]\\n```\n```\\ns = [(i,j) for i in range(len(f)) for j in range(len(f[0])) if f[i][j]]                \\ns.sort(key = lambda x: f[x[0]][x[1]])\\n```\n```\\ns = [(0,0)] + s\\n```\n```\\ncumul = 0\\nfor u,v in zip(s,s[1:]): \\n\\tcumul += self.bfs(u,v,f)\\n\\tif cumul == float(\\'inf\\'): return -1\\nreturn cumul\\n```\n```\\nclass Solution(object):\\n    def cutOffTree(self, f):\\n        s = [(i,j) for i in range(len(f)) for j in range(len(f[0])) if f[i][j]]                \\n        s.sort(key = lambda x: f[x[0]][x[1]])\\n        s = [(0,0)] + s\\n        cumul = 0\\n        for u,v in zip(s,s[1:]): \\n            cumul += self.bfs(u,v,f)\\n            if cumul == float(\\'inf\\'): return -1\\n        return cumul\\n    \\n    def bfs(self,source,target,grid):\\n        q,vis = collections.deque([(source,0)]),set([source])\\n        while(q):\\n            u,steps  = q.popleft()\\n            if u == target: return steps\\n            for v in [(u[0]-1,u[1]), (u[0]+1,u[1]), (u[0],u[1]-1), (u[0],u[1]+1)]:\\n                if 0 <= v[0] < len(grid) and 0 <= v[1] < len(grid[0]) and grid[v[0]][v[1]] != 0 and v not in vis:\\n                    vis.add(v)\\n                    q.append((v,steps + 1))\\n        return +float(\\'inf\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549845,
                "title": "sort-as-per-the-given-numbers-and-keep-the-indexes-later-on-do-the-multi-source-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int vis[54][54];\\n    void fill_v()\\n    {\\n        for(int i =0;i<54;i++)\\n        {\\n            for(int j=0;j<54;j++)\\n            {\\n                vis[i][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    \\n    int bfs(int si, int sj, int ei, int ej,vector<vector<int>> &f)\\n    {\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{si,sj}});\\n        int ans = -1;\\n        \\n        int n = f.size();\\n        int m = f[0].size();\\n        \\n        while(!q.empty())\\n        {\\n            int level = q.front().first;\\n            int i = q.front().second.first;\\n            int j = q.front().second.second;\\n            \\n            q.pop();\\n            if(vis[i][j])\\n                continue;\\n            \\n            vis[i][j] = 1;\\n            \\n            \\n            \\n            if(i == ei && j == ej)\\n            {\\n                return level;\\n            }\\n            \\n            if(i+1 < n && j<m && vis[i+1][j] == 0 && f[i+1][j])\\n            {\\n                q.push({level+1, {i+1, j}});\\n            }\\n            \\n            if(i < n && j+1<m && vis[i][j+1] == 0 && f[i][j+1])\\n            {\\n                q.push({level+1, {i, j+1}});\\n            }\\n            \\n            if(i-1>=0 && i-1 < n && j<m && vis[i-1][j] == 0 && f[i-1][j])\\n            {\\n                q.push({level+1, {i-1, j}});\\n            }\\n            \\n            if(j-1>=0 && i< n && j-1<m && vis[i][j-1] == 0 && f[i][j-1])\\n            {\\n                q.push({level+1, {i, j-1}});\\n            }\\n        }\\n        \\n        return ans;\\n            \\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& f) {\\n        \\n        \\n        int n = f.size();\\n        int m = f[0].size();\\n        vector<pair<int,pair<int,int>>> v; \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(f[i][j]>1)\\n                    v.push_back({f[i][j],{i,j}});\\n            }\\n            \\n        }\\n        \\n        v.push_back({0,{0,0}});\\n        int l = v.size();\\n        \\n        sort(v.begin(),v.end());\\n        int ans = 0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            fill_v();\\n            int si,sj,ei,ej;\\n            si = v[i].second.first;\\n            sj = v[i].second.second;\\n            \\n            ei = v[i+1].second.first;\\n            ej = v[i+1].second.second;\\n            \\n            int res = bfs( si, sj,  ei, ej,f);\\n            if(res == -1)\\n                return res;\\n            ans+=res;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int vis[54][54];\\n    void fill_v()\\n    {\\n        for(int i =0;i<54;i++)\\n        {\\n            for(int j=0;j<54;j++)\\n            {\\n                vis[i][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    \\n    int bfs(int si, int sj, int ei, int ej,vector<vector<int>> &f)\\n    {\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{si,sj}});\\n        int ans = -1;\\n        \\n        int n = f.size();\\n        int m = f[0].size();\\n        \\n        while(!q.empty())\\n        {\\n            int level = q.front().first;\\n            int i = q.front().second.first;\\n            int j = q.front().second.second;\\n            \\n            q.pop();\\n            if(vis[i][j])\\n                continue;\\n            \\n            vis[i][j] = 1;\\n            \\n            \\n            \\n            if(i == ei && j == ej)\\n            {\\n                return level;\\n            }\\n            \\n            if(i+1 < n && j<m && vis[i+1][j] == 0 && f[i+1][j])\\n            {\\n                q.push({level+1, {i+1, j}});\\n            }\\n            \\n            if(i < n && j+1<m && vis[i][j+1] == 0 && f[i][j+1])\\n            {\\n                q.push({level+1, {i, j+1}});\\n            }\\n            \\n            if(i-1>=0 && i-1 < n && j<m && vis[i-1][j] == 0 && f[i-1][j])\\n            {\\n                q.push({level+1, {i-1, j}});\\n            }\\n            \\n            if(j-1>=0 && i< n && j-1<m && vis[i][j-1] == 0 && f[i][j-1])\\n            {\\n                q.push({level+1, {i, j-1}});\\n            }\\n        }\\n        \\n        return ans;\\n            \\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& f) {\\n        \\n        \\n        int n = f.size();\\n        int m = f[0].size();\\n        vector<pair<int,pair<int,int>>> v; \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(f[i][j]>1)\\n                    v.push_back({f[i][j],{i,j}});\\n            }\\n            \\n        }\\n        \\n        v.push_back({0,{0,0}});\\n        int l = v.size();\\n        \\n        sort(v.begin(),v.end());\\n        int ans = 0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            fill_v();\\n            int si,sj,ei,ej;\\n            si = v[i].second.first;\\n            sj = v[i].second.second;\\n            \\n            ei = v[i+1].second.first;\\n            ej = v[i+1].second.second;\\n            \\n            int res = bfs( si, sj,  ei, ej,f);\\n            if(res == -1)\\n                return res;\\n            ans+=res;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426989,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n    static constexpr int DIR[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n    struct Cell {\\n        short r : 8;\\n        short c : 8;\\n    };\\n    int doit(const vector<vector<int>>& forest, Cell start, vector<int> &curr, vector<int> &prev, vector<Cell> &bfs) {\\n        const int M = forest.size(), N = forest[0].size();\\n        int steps = 0;\\n        swap(curr, prev);\\n        fill(begin(curr), end(curr), -1);\\n        curr[start.r * N + start.c] = steps;\\n        if (prev[start.r * N + start.c] != -1) {\\n            return prev[start.r * N + start.c];\\n        }\\n        bfs.clear();\\n        bfs.push_back(start);\\n        while (!bfs.empty()) {\\n            int size = bfs.size();\\n            steps++;\\n            while (size--) {\\n                auto [r0, c0] = bfs[size];\\n                swap(bfs[size], bfs.back());\\n                bfs.pop_back();\\n                for (auto [dr, dc] : DIR) {\\n                    short r1 = r0 + dr, c1 = c0 + dc;\\n                    int pos = r1 * N + c1;\\n                    if (r1 >= 0 && r1 < M && c1 >= 0 && c1 < N && forest[r1][c1] > 0 && curr[pos] == -1) {\\n                        if (prev[pos] != -1) {\\n                            return steps + prev[pos];\\n                        }\\n                        curr[pos] = steps;\\n                        bfs.push_back({r1, c1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int manhattan_distance(vector<Cell> &cells) {\\n        int result = 0;\\n        Cell prev{0, 0};\\n        for (auto &cell : cells) {\\n            result += abs(prev.r - cell.r) + abs(prev.c - cell.c);\\n            prev = cell;\\n        }\\n        return result;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        const int M = forest.size(), N = forest[0].size();\\n        if (forest[0][0] == 0) {\\n            return -1;\\n        }\\n        int obstacles = 0;\\n        vector<Cell> cells;\\n        cells.reserve(8);\\n\\n        for (short r = 0; r < M; r++) {\\n            for (short c = 0; c < N; c++) {\\n                if (forest[r][c] > 1) {\\n                    cells.push_back({r, c});\\n                } else if (forest[r][c] == 0) {\\n                    obstacles++;\\n                }\\n            }\\n        }\\n        sort(begin(cells), end(cells), [&forest](const Cell &a, const Cell &b){\\n            return forest[a.r][a.c] < forest[b.r][b.c];\\n        });\\n        if (obstacles == 0) {\\n            return manhattan_distance(cells);\\n        }\\n        vector<int> curr(M * N, -1), prev = curr;\\n        curr[0] = 0;\\n\\n        vector<Cell> bfs;\\n        bfs.reserve(8);\\n\\n        int steps = 0;\\n\\n        for (auto &cell : cells) {\\n            int result = doit(forest, cell, curr, prev, bfs);\\n\\n            if (result != -1) {\\n                steps += result;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0 :\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        def distance(node1, node2):\\n            now = [node1]\\n            soon = []\\n            expanded = set()\\n            manhattan = abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])\\n            detours = 0\\n            while True:\\n                if len(now) == 0:\\n                    now = soon\\n                    soon = []\\n                    detours += 1\\n                node = now.pop()\\n                if node == node2:\\n                    return manhattan + 2 * detours\\n                if node not in expanded:\\n                    expanded.add(node)\\n                    x, y = node\\n                    if x - 1 >= 0 and forest[x - 1][y] >= 1:\\n                        if x > node2[0]:\\n                            now.append((x - 1, y))\\n                        else:\\n                            soon.append((x - 1, y))\\n                    if y + 1 < n and forest[x][y + 1] >= 1:\\n                        if y < node2[1]:\\n                            now.append((x, y + 1))\\n                        else:\\n                            soon.append((x, y + 1))\\n                    if x + 1 < m and forest[x + 1][y] >= 1:\\n                        if x < node2[0]:\\n                            now.append((x + 1, y))\\n                        else:\\n                            soon.append((x + 1, y))\\n                    if y - 1 >= 0 and forest[x][y - 1] >= 1:\\n                        if y > node2[1]:\\n                            now.append((x, y - 1))\\n                        else:\\n                            soon.append((x, y - 1))\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append(((i, j), forest[i][j]))\\n        trees.sort(key=lambda x: x[1])\\n        can_reach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while len(stack) > 0:\\n            x, y = stack.pop()\\n            if x - 1 >= 0 and forest[x - 1][y] >= 1 and (x - 1, y) not in can_reach:\\n                can_reach.add((x - 1, y))\\n                stack.append((x - 1, y))\\n            if y + 1 < n and forest[x][y + 1] >= 1 and (x, y + 1) not in can_reach:\\n                can_reach.add((x, y + 1))\\n                stack.append((x, y + 1))\\n            if x + 1 < m and forest[x + 1][y] >= 1 and (x + 1, y) not in can_reach:\\n                can_reach.add((x + 1, y))\\n                stack.append((x + 1, y))\\n            if y - 1 >= 0  and forest[x][y - 1] >= 1 and (x, y - 1) not in can_reach:\\n                can_reach.add((x, y - 1))\\n                stack.append((x, y - 1))\\n        for t in trees:\\n            if t[0] not in can_reach:\\n                return -1\\n        start = (0, 0)\\n        num_step = 0\\n        for t in trees: \\n            num_step += distance(start, t[0])\\n            forest[t[0][0]][t[0][1]] = 1\\n            start = t[0]\\n        return num_step\\n```\\n\\n```Java []\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(forest.get(a[0]).get(a[1])-forest.get(b[0]).get(b[1])));\\n        for(int i=0;i<forest.size();i++){\\n            for(int j=0;j<forest.get(0).size();j++){\\n                if(forest.get(i).get(j)>1)\\n                    pq.add(new int[]{i,j});\\n            }\\n        }\\n        int ans=0;\\n        int curr[]={0,0};\\n        while(pq.size()>0){\\n            int[] temp=pq.poll();\\n            int dis=calcDis(forest,curr,temp);\\n            if(dis==-1)\\n                return -1;\\n            ans+=dis;\\n            curr=temp;\\n        }\\n        return ans;\\n    }\\n    int calcDis(List<List<Integer>> forest,int start[],int end[]){\\n        int n=forest.size(),m=forest.get(0).size();\\n        boolean vis[][]=new boolean[n][m];\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.add(start);\\n        vis[start[0]][start[1]]=true;\\n        int dis=0;\\n        while(queue.size()>0){\\n            int len =queue.size();\\n            while(len-->0){\\n                int temp[]=queue.remove();\\n                int r=temp[0],c=temp[1];\\n                if(r==end[0] && c==end[1])\\n                    return dis;\\n                if(r+1<n && !vis[r+1][c] && forest.get(r+1).get(c)!=0){\\n                    queue.add(new int[]{r+1,c});\\n                    vis[r+1][c]=true;\\n                }if(r-1>=0 && !vis[r-1][c] && forest.get(r-1).get(c)!=0){\\n                    queue.add(new int[]{r-1,c});\\n                    vis[r-1][c]=true;\\n                }if(c-1>=0 && !vis[r][c-1] && forest.get(r).get(c-1)!=0){\\n                    queue.add(new int[]{r,c-1});\\n                    vis[r][c-1]=true;\\n                }if(c+1<m && !vis[r][c+1] && forest.get(r).get(c+1)!=0){\\n                    queue.add(new int[]{r,c+1});\\n                    vis[r][c+1]=true;\\n                }\\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n    static constexpr int DIR[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n    struct Cell {\\n        short r : 8;\\n        short c : 8;\\n    };\\n    int doit(const vector<vector<int>>& forest, Cell start, vector<int> &curr, vector<int> &prev, vector<Cell> &bfs) {\\n        const int M = forest.size(), N = forest[0].size();\\n        int steps = 0;\\n        swap(curr, prev);\\n        fill(begin(curr), end(curr), -1);\\n        curr[start.r * N + start.c] = steps;\\n        if (prev[start.r * N + start.c] != -1) {\\n            return prev[start.r * N + start.c];\\n        }\\n        bfs.clear();\\n        bfs.push_back(start);\\n        while (!bfs.empty()) {\\n            int size = bfs.size();\\n            steps++;\\n            while (size--) {\\n                auto [r0, c0] = bfs[size];\\n                swap(bfs[size], bfs.back());\\n                bfs.pop_back();\\n                for (auto [dr, dc] : DIR) {\\n                    short r1 = r0 + dr, c1 = c0 + dc;\\n                    int pos = r1 * N + c1;\\n                    if (r1 >= 0 && r1 < M && c1 >= 0 && c1 < N && forest[r1][c1] > 0 && curr[pos] == -1) {\\n                        if (prev[pos] != -1) {\\n                            return steps + prev[pos];\\n                        }\\n                        curr[pos] = steps;\\n                        bfs.push_back({r1, c1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int manhattan_distance(vector<Cell> &cells) {\\n        int result = 0;\\n        Cell prev{0, 0};\\n        for (auto &cell : cells) {\\n            result += abs(prev.r - cell.r) + abs(prev.c - cell.c);\\n            prev = cell;\\n        }\\n        return result;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        const int M = forest.size(), N = forest[0].size();\\n        if (forest[0][0] == 0) {\\n            return -1;\\n        }\\n        int obstacles = 0;\\n        vector<Cell> cells;\\n        cells.reserve(8);\\n\\n        for (short r = 0; r < M; r++) {\\n            for (short c = 0; c < N; c++) {\\n                if (forest[r][c] > 1) {\\n                    cells.push_back({r, c});\\n                } else if (forest[r][c] == 0) {\\n                    obstacles++;\\n                }\\n            }\\n        }\\n        sort(begin(cells), end(cells), [&forest](const Cell &a, const Cell &b){\\n            return forest[a.r][a.c] < forest[b.r][b.c];\\n        });\\n        if (obstacles == 0) {\\n            return manhattan_distance(cells);\\n        }\\n        vector<int> curr(M * N, -1), prev = curr;\\n        curr[0] = 0;\\n\\n        vector<Cell> bfs;\\n        bfs.reserve(8);\\n\\n        int steps = 0;\\n\\n        for (auto &cell : cells) {\\n            int result = doit(forest, cell, curr, prev, bfs);\\n\\n            if (result != -1) {\\n                steps += result;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0 :\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        def distance(node1, node2):\\n            now = [node1]\\n            soon = []\\n            expanded = set()\\n            manhattan = abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])\\n            detours = 0\\n            while True:\\n                if len(now) == 0:\\n                    now = soon\\n                    soon = []\\n                    detours += 1\\n                node = now.pop()\\n                if node == node2:\\n                    return manhattan + 2 * detours\\n                if node not in expanded:\\n                    expanded.add(node)\\n                    x, y = node\\n                    if x - 1 >= 0 and forest[x - 1][y] >= 1:\\n                        if x > node2[0]:\\n                            now.append((x - 1, y))\\n                        else:\\n                            soon.append((x - 1, y))\\n                    if y + 1 < n and forest[x][y + 1] >= 1:\\n                        if y < node2[1]:\\n                            now.append((x, y + 1))\\n                        else:\\n                            soon.append((x, y + 1))\\n                    if x + 1 < m and forest[x + 1][y] >= 1:\\n                        if x < node2[0]:\\n                            now.append((x + 1, y))\\n                        else:\\n                            soon.append((x + 1, y))\\n                    if y - 1 >= 0 and forest[x][y - 1] >= 1:\\n                        if y > node2[1]:\\n                            now.append((x, y - 1))\\n                        else:\\n                            soon.append((x, y - 1))\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append(((i, j), forest[i][j]))\\n        trees.sort(key=lambda x: x[1])\\n        can_reach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while len(stack) > 0:\\n            x, y = stack.pop()\\n            if x - 1 >= 0 and forest[x - 1][y] >= 1 and (x - 1, y) not in can_reach:\\n                can_reach.add((x - 1, y))\\n                stack.append((x - 1, y))\\n            if y + 1 < n and forest[x][y + 1] >= 1 and (x, y + 1) not in can_reach:\\n                can_reach.add((x, y + 1))\\n                stack.append((x, y + 1))\\n            if x + 1 < m and forest[x + 1][y] >= 1 and (x + 1, y) not in can_reach:\\n                can_reach.add((x + 1, y))\\n                stack.append((x + 1, y))\\n            if y - 1 >= 0  and forest[x][y - 1] >= 1 and (x, y - 1) not in can_reach:\\n                can_reach.add((x, y - 1))\\n                stack.append((x, y - 1))\\n        for t in trees:\\n            if t[0] not in can_reach:\\n                return -1\\n        start = (0, 0)\\n        num_step = 0\\n        for t in trees: \\n            num_step += distance(start, t[0])\\n            forest[t[0][0]][t[0][1]] = 1\\n            start = t[0]\\n        return num_step\\n```\n```Java []\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(forest.get(a[0]).get(a[1])-forest.get(b[0]).get(b[1])));\\n        for(int i=0;i<forest.size();i++){\\n            for(int j=0;j<forest.get(0).size();j++){\\n                if(forest.get(i).get(j)>1)\\n                    pq.add(new int[]{i,j});\\n            }\\n        }\\n        int ans=0;\\n        int curr[]={0,0};\\n        while(pq.size()>0){\\n            int[] temp=pq.poll();\\n            int dis=calcDis(forest,curr,temp);\\n            if(dis==-1)\\n                return -1;\\n            ans+=dis;\\n            curr=temp;\\n        }\\n        return ans;\\n    }\\n    int calcDis(List<List<Integer>> forest,int start[],int end[]){\\n        int n=forest.size(),m=forest.get(0).size();\\n        boolean vis[][]=new boolean[n][m];\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.add(start);\\n        vis[start[0]][start[1]]=true;\\n        int dis=0;\\n        while(queue.size()>0){\\n            int len =queue.size();\\n            while(len-->0){\\n                int temp[]=queue.remove();\\n                int r=temp[0],c=temp[1];\\n                if(r==end[0] && c==end[1])\\n                    return dis;\\n                if(r+1<n && !vis[r+1][c] && forest.get(r+1).get(c)!=0){\\n                    queue.add(new int[]{r+1,c});\\n                    vis[r+1][c]=true;\\n                }if(r-1>=0 && !vis[r-1][c] && forest.get(r-1).get(c)!=0){\\n                    queue.add(new int[]{r-1,c});\\n                    vis[r-1][c]=true;\\n                }if(c-1>=0 && !vis[r][c-1] && forest.get(r).get(c-1)!=0){\\n                    queue.add(new int[]{r,c-1});\\n                    vis[r][c-1]=true;\\n                }if(c+1<m && !vis[r][c+1] && forest.get(r).get(c+1)!=0){\\n                    queue.add(new int[]{r,c+1});\\n                    vis[r][c+1]=true;\\n                }\\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317191,
                "title": "675-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first initialize the size of the forest m and n. We also create an empty list called trees which will contain tuples of (height, x, y) where x and y are the coordinates of the tree in the forest.\\n\\n2. We iterate through every cell in the forest and if the value is greater than 1, we append a tuple of (height, x, y) to the trees list. We sort the list by the height of the trees in ascending order.\\n\\n3. We define a bfs function which takes in the starting coordinates sx and sy, and the target coordinates tx and ty. We use a heap to implement Dijkstra\\'s algorithm for finding the shortest path. We keep track of the minimum distance d, current coordinates x and y, and push the tuple (d, x, y) into the heap.\\n\\n4. We create a visited set to keep track of cells that have been visited. We add the starting coordinates to the set.\\n\\n5. While the heap is not empty, we pop the cell with the minimum distance d from the heap. If the current coordinates are the target coordinates, we return the minimum distance d.\\n\\n6. Otherwise, we iterate through all possible directions (north, east, south, west) and check if the next cell is within the boundaries of the forest, not in the visited set, and not blocked by a tree. If the conditions are met, we add the next cell to the visited set and push the tuple (d+1, nx, ny) into the heap.\\n\\n7. If the target coordinates cannot be reached, we return -1.\\n\\n8. We initialize ans to 0, and the starting coordinates sx and sy to (0, 0).\\n\\n9. We iterate through every tree in the trees list in ascending order of height. For each tree,\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m, n = len(forest), len(forest[0])\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append((forest[i][j], i, j))\\n        trees.sort()\\n\\n        def bfs(sx, sy, tx, ty):\\n            queue = [(0, sx, sy)]\\n            visited = set()\\n            visited.add((sx, sy))\\n            while queue:\\n                d, x, y = heapq.heappop(queue)\\n                if x == tx and y == ty:\\n                    return d\\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and forest[nx][ny]:\\n                        visited.add((nx, ny))\\n                        heapq.heappush(queue, (d+1, nx, ny))\\n            return -1\\n\\n        ans = 0\\n        sx, sy = 0, 0\\n        for _, tx, ty in trees:\\n            d = bfs(sx, sy, tx, ty)\\n            if d == -1:\\n                return -1\\n            ans += d\\n            sx, sy = tx, ty\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m, n = len(forest), len(forest[0])\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append((forest[i][j], i, j))\\n        trees.sort()\\n\\n        def bfs(sx, sy, tx, ty):\\n            queue = [(0, sx, sy)]\\n            visited = set()\\n            visited.add((sx, sy))\\n            while queue:\\n                d, x, y = heapq.heappop(queue)\\n                if x == tx and y == ty:\\n                    return d\\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and forest[nx][ny]:\\n                        visited.add((nx, ny))\\n                        heapq.heappush(queue, (d+1, nx, ny))\\n            return -1\\n\\n        ans = 0\\n        sx, sy = 0, 0\\n        for _, tx, ty in trees:\\n            d = bfs(sx, sy, tx, ty)\\n            if d == -1:\\n                return -1\\n            ans += d\\n            sx, sy = tx, ty\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665832,
                "title": "c-commented-explanation-easy-to-understand-bfs-greedy",
                "content": "```\\n/*\\n\\n 0 --> obstacle\\n 1 --> empty cell\\n>1 --> tree\\'s height\\n\\n North , East , South , West --> Moves Possible\\n \\n We can cut off all the trees , if and only if there exists a\\n path from the current tree to the next greater tree value.\\n\\n We will sort the tree\\'s according to their values and then do a\\n bfs traversal b/w adjacent trees and calculate the shortest \\n distance b/w them , if there is no path possible , then return \\n -1, otherwise at the end of the program return the summation of \\n those distances.\\n \\n T.C : O(M*N*M*N)\\n S.C : O(M*N)\\n\\n*/\\n\\n// Build a Tree Cell Structure for simplicity sake //\\n\\nstruct Tree{\\n  \\n    public:\\n    \\n    int value;\\n    int x;\\n    int y;\\n    \\n};\\n\\n// Helps to sort the trees on the basis of their values //\\n\\nbool static comp(const Tree&x,const Tree&y){\\n    \\n    return x.value < y.value;\\n    \\n}\\n\\n// 4-directional coordinates //\\n\\nint dx[4] = {0,0,1,-1};\\nint dy[4] = {1,-1,0,0};\\n\\nint visited[52][52];\\n\\nint bfs_traversal(int src1,int src2,int dest1,int dest2,vector<vector<int>>&forest){\\n    \\n    int m = forest.size();\\n    int n = forest[0].size();\\n    \\n    // Reset the visited array //\\n    \\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n            visited[i][j] = 0;\\n        }\\n    }\\n    \\n    // Data structure widely used for BFS Traversal //\\n    \\n    queue<pair<int,int>>q;\\n    \\n    // Single Source BFS //\\n    \\n    q.push({src1,src2});\\n    \\n    int lvl = 0;\\n    \\n    while(!q.empty()){\\n        \\n        int sz = q.size();\\n        \\n        while(sz--){\\n            \\n            auto curr = q.front();\\n            q.pop();\\n            \\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            if(x==dest1 && y==dest2){\\n                return lvl;\\n            }\\n            \\n            if(visited[x][y]) continue;\\n            \\n            visited[x][y] = 1;\\n            \\n            for(int dir=0;dir<4;dir++){\\n                \\n                int nx = x + dx[dir];\\n                int ny = y + dy[dir];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny<n && !visited[nx][ny] && forest[nx][ny]){\\n                    \\n                    q.push({nx,ny});\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        lvl++;\\n        \\n    }\\n    \\n    return -1;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        \\n        int m=forest.size();\\n        int n=forest[0].size();\\n        \\n        vector<Tree>vec;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(forest[i][j]>1){\\n                    vec.push_back({forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        \\n        // Starting Point - By default //\\n        \\n        vec.push_back({0,0,0});\\n        \\n        // Sort on the basis of the tree values //\\n        \\n        sort(vec.begin(),vec.end(),comp);\\n        \\n        int ans = 0;\\n        \\n        // BFS Traversal b/w adjacent trees //\\n        \\n        for(int i=0;i<vec.size()-1;i++){\\n            \\n            int curr = bfs_traversal(vec[i].x,vec[i].y,vec[i+1].x,vec[i+1].y,forest);\\n            \\n            // If there doesn\\'t exist a single path b/w adjacent trees , then simple return -1 (invalid sequence) //\\n            \\n            if(curr<0){\\n                return -1;\\n            }\\n            \\n            ans += curr;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n\\n 0 --> obstacle\\n 1 --> empty cell\\n>1 --> tree\\'s height\\n\\n North , East , South , West --> Moves Possible\\n \\n We can cut off all the trees , if and only if there exists a\\n path from the current tree to the next greater tree value.\\n\\n We will sort the tree\\'s according to their values and then do a\\n bfs traversal b/w adjacent trees and calculate the shortest \\n distance b/w them , if there is no path possible , then return \\n -1, otherwise at the end of the program return the summation of \\n those distances.\\n \\n T.C : O(M*N*M*N)\\n S.C : O(M*N)\\n\\n*/\\n\\n// Build a Tree Cell Structure for simplicity sake //\\n\\nstruct Tree{\\n  \\n    public:\\n    \\n    int value;\\n    int x;\\n    int y;\\n    \\n};\\n\\n// Helps to sort the trees on the basis of their values //\\n\\nbool static comp(const Tree&x,const Tree&y){\\n    \\n    return x.value < y.value;\\n    \\n}\\n\\n// 4-directional coordinates //\\n\\nint dx[4] = {0,0,1,-1};\\nint dy[4] = {1,-1,0,0};\\n\\nint visited[52][52];\\n\\nint bfs_traversal(int src1,int src2,int dest1,int dest2,vector<vector<int>>&forest){\\n    \\n    int m = forest.size();\\n    int n = forest[0].size();\\n    \\n    // Reset the visited array //\\n    \\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n            visited[i][j] = 0;\\n        }\\n    }\\n    \\n    // Data structure widely used for BFS Traversal //\\n    \\n    queue<pair<int,int>>q;\\n    \\n    // Single Source BFS //\\n    \\n    q.push({src1,src2});\\n    \\n    int lvl = 0;\\n    \\n    while(!q.empty()){\\n        \\n        int sz = q.size();\\n        \\n        while(sz--){\\n            \\n            auto curr = q.front();\\n            q.pop();\\n            \\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            if(x==dest1 && y==dest2){\\n                return lvl;\\n            }\\n            \\n            if(visited[x][y]) continue;\\n            \\n            visited[x][y] = 1;\\n            \\n            for(int dir=0;dir<4;dir++){\\n                \\n                int nx = x + dx[dir];\\n                int ny = y + dy[dir];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny<n && !visited[nx][ny] && forest[nx][ny]){\\n                    \\n                    q.push({nx,ny});\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        lvl++;\\n        \\n    }\\n    \\n    return -1;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        \\n        int m=forest.size();\\n        int n=forest[0].size();\\n        \\n        vector<Tree>vec;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(forest[i][j]>1){\\n                    vec.push_back({forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        \\n        // Starting Point - By default //\\n        \\n        vec.push_back({0,0,0});\\n        \\n        // Sort on the basis of the tree values //\\n        \\n        sort(vec.begin(),vec.end(),comp);\\n        \\n        int ans = 0;\\n        \\n        // BFS Traversal b/w adjacent trees //\\n        \\n        for(int i=0;i<vec.size()-1;i++){\\n            \\n            int curr = bfs_traversal(vec[i].x,vec[i].y,vec[i+1].x,vec[i+1].y,forest);\\n            \\n            // If there doesn\\'t exist a single path b/w adjacent trees , then simple return -1 (invalid sequence) //\\n            \\n            if(curr<0){\\n                return -1;\\n            }\\n            \\n            ans += curr;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584206,
                "title": "use-bfs-and-sorting",
                "content": "\\n       int dir[4][2]={{-1,0},{1,0},{0,1},{0,-1}};\\n        int solve(int s,int e,int x,int y,vector<vector<int>>& forest){\\n        if(s==x && e==y) return 0;\\n        \\n        int n=forest.size();\\n        int m=forest[0].size();\\n        queue<pair<int,int>> q;\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        \\n        vis[s][e]=1;\\n        q.push({s,e});\\n        int count=0;\\n        while(!q.empty()){\\n            count++;\\n            int nn=q.size();\\n            while(nn--){\\n                auto it=q.front();\\n                q.pop();\\n                \\n                for(int i=0;i<4;i++){\\n                    int n_x=it.first+dir[i][0];\\n                    int n_y=it.second+dir[i][1];\\n                    if(n_x<0 || n_y<0 || n_x>=n || n_y>=m || vis[n_x][n_y]==1 || forest[n_x][n_y]==0){\\n                        continue;\\n                    }\\n                    q.push({n_x,n_y});\\n                    vis[n_x][n_y]=1;\\n                    if(n_x==x && n_y==y) return count;\\n                   \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        \\n        for(int i=0;i<forest.size();i++){\\n            for(int j=0;j<forest[i].size();j++){\\n                if(forest[i][j]>1){\\n                    ans.push_back({forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        int s=0,e=0;\\n        int res=0;\\n        for(auto &it:ans){\\n            int d=solve(s,e,it[1],it[2],forest);\\n            if(d==-1){\\n                return -1;\\n            }\\n            res+=d;\\n            s=it[1];\\n            e=it[2];\\n        }\\n        return res;\\n        \\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\n       int dir[4][2]={{-1,0},{1,0},{0,1},{0,-1}};\\n        int solve(int s,int e,int x,int y,vector<vector<int>>& forest){\\n        if(s==x && e==y) return 0;\\n        \\n        int n=forest.size();\\n        int m=forest[0].size();\\n        queue<pair<int,int>> q;\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        \\n        vis[s][e]=1;\\n        q.push({s,e});\\n        int count=0;\\n        while(!q.empty()){\\n            count++;\\n            int nn=q.size();\\n            while(nn--){\\n                auto it=q.front();\\n                q.pop();\\n                \\n                for(int i=0;i<4;i++){\\n                    int n_x=it.first+dir[i][0];\\n                    int n_y=it.second+dir[i][1];\\n                    if(n_x<0 || n_y<0 || n_x>=n || n_y>=m || vis[n_x][n_y]==1 || forest[n_x][n_y]==0){\\n                        continue;\\n                    }\\n                    q.push({n_x,n_y});\\n                    vis[n_x][n_y]=1;\\n                    if(n_x==x && n_y==y) return count;\\n                   \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        \\n        for(int i=0;i<forest.size();i++){\\n            for(int j=0;j<forest[i].size();j++){\\n                if(forest[i][j]>1){\\n                    ans.push_back({forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        int s=0,e=0;\\n        int res=0;\\n        for(auto &it:ans){\\n            int d=solve(s,e,it[1],it[2],forest);\\n            if(d==-1){\\n                return -1;\\n            }\\n            res+=d;\\n            s=it[1];\\n            e=it[2];\\n        }\\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2380352,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n    //approach: 1st store all the positions in the min heap acc. to their height\\n    //now start removing the elements from the heap and calculate their dis using bfs\\n    // if at any point we cann\\'t reach at the next position return -1;\\n    // else keep on adding the distances and return;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n       PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(forest.get(a[0]).get(a[1])-forest.get(b[0]).get(b[1])));\\n       for(int i=0;i<forest.size();i++){\\n           for(int j=0;j<forest.get(0).size();j++){\\n               if(forest.get(i).get(j)>1)\\n                   pq.add(new int[]{i,j});\\n           }\\n       }\\n        int ans=0;\\n       int curr[]={0,0};\\n       while(pq.size()>0){\\n           int[] temp=pq.poll();\\n           int dis=calcDis(forest,curr,temp);\\n           //System.out.println(dis+\" \"+temp.height);\\n           if(dis==-1)\\n               return -1;\\n           ans+=dis;\\n           curr=temp;\\n       }\\n        return ans;\\n    }\\n    int calcDis(List<List<Integer>> forest,int start[],int end[]){\\n        int n=forest.size(),m=forest.get(0).size();\\n        boolean vis[][]=new boolean[n][m];\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.add(start);\\n        vis[start[0]][start[1]]=true;\\n        int dis=0;\\n        while(queue.size()>0){\\n            int len =queue.size();\\n            while(len-->0){\\n                int temp[]=queue.remove();\\n                int r=temp[0],c=temp[1];\\n                if(r==end[0] && c==end[1])\\n                    return dis;\\n                if(r+1<n && !vis[r+1][c] && forest.get(r+1).get(c)!=0){\\n                    queue.add(new int[]{r+1,c});\\n                    vis[r+1][c]=true;\\n                }if(r-1>=0 && !vis[r-1][c] && forest.get(r-1).get(c)!=0){\\n                    queue.add(new int[]{r-1,c});\\n                    vis[r-1][c]=true;\\n                }if(c-1>=0 && !vis[r][c-1] && forest.get(r).get(c-1)!=0){\\n                    queue.add(new int[]{r,c-1});\\n                    vis[r][c-1]=true;\\n                }if(c+1<m && !vis[r][c+1] && forest.get(r).get(c+1)!=0){\\n                    queue.add(new int[]{r,c+1});\\n                    vis[r][c+1]=true;\\n                }\\n            }\\n            dis++;\\n        }\\n        return -1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    //approach: 1st store all the positions in the min heap acc. to their height\\n    //now start removing the elements from the heap and calculate their dis using bfs\\n    // if at any point we cann\\'t reach at the next position return -1;\\n    // else keep on adding the distances and return;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n       PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(forest.get(a[0]).get(a[1])-forest.get(b[0]).get(b[1])));\\n       for(int i=0;i<forest.size();i++){\\n           for(int j=0;j<forest.get(0).size();j++){\\n               if(forest.get(i).get(j)>1)\\n                   pq.add(new int[]{i,j}",
                "codeTag": "Java"
            },
            {
                "id": 2190533,
                "title": "c-sorting-bfs-solution",
                "content": "```cpp\\ntypedef vector<vector<int>> vvi; \\ntypedef vector<vector<bool>> vvb; \\nclass Solution {\\npublic:\\n    bool isValid(int x, int y, int n, int m){\\n        return x>=0 && y>=0 && x<n && y<m; \\n    }\\n    // The function gives the length of shortest path\\n    // from (x1,y1)->(x2,y2)\\n    int bfs(int x1, int y1, int x2,int y2, vvi &forest){\\n        int n = forest.size(), m = forest[0].size(); \\n        int dx[4] = {1,-1,0,0};\\n        int dy[4] = {0,0,1,-1}; \\n        vector<vector<bool>> vis(n, vector<bool>(m, false)); \\n        queue<pair<int, int>> q;\\n        q.push({x1, y1}); \\n        vis[x1][y1] = true;\\n        int cnt = 0; \\n        // Level Order Traversal\\n        while(!q.empty()){\\n            int sz = q.size(); \\n            while(sz--){\\n                auto node = q.front(); q.pop(); \\n                int x = node.first, y = node.second; \\n                if(x == x2 && y==y2)\\n                    return cnt; \\n                for(int i = 0; i<4; ++i){\\n                    int xr = x + dx[i], yr = y + dy[i]; \\n                    if(isValid(xr,yr,n,m) && !vis[xr][yr]){\\n                        if(forest[xr][yr] > 0){\\n                            q.push({xr,yr});\\n                            vis[xr][yr] = true; \\n                        }\\n                    }\\n                }\\n            }\\n            cnt++; \\n        }\\n        return -1; \\n    }\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if(forest[0][0] == 0)\\n            return -1; \\n        int n = forest.size(), m = forest[0].size(); \\n        // Collect the trees with coordinates in heightwise order\\n        vector<pair<int, pair<int, int>>> trees; \\n        for(int i = 0; i<n; ++i){\\n            for(int j = 0; j<m; ++j){\\n                if(forest[i][j] > 1){\\n                    trees.push_back({forest[i][j], {i,j}}); \\n                }\\n            }\\n        }\\n        sort(trees.begin(), trees.end()); \\n        if(trees[0].second.first != 0 || trees[0].second.second != 0)\\n            trees.insert(trees.begin(), {0,{0,0}});\\n        // Traverse the order and find the shortest path between two adj trees\\n        int steps = 0; \\n        for(int i = 1; i<trees.size(); ++i){\\n            auto src = trees[i-1].second; \\n            auto dest = trees[i].second; \\n            int x1 = src.first, y1 = src.second; \\n            int x2 = dest.first, y2 = dest.second; \\n            int cnt = bfs(x1, y1, x2, y2, forest); \\n            if(cnt == -1)\\n                return -1; \\n            steps += cnt; \\n        }\\n        return steps; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Sorting"
                ],
                "code": "```cpp\\ntypedef vector<vector<int>> vvi; \\ntypedef vector<vector<bool>> vvb; \\nclass Solution {\\npublic:\\n    bool isValid(int x, int y, int n, int m){\\n        return x>=0 && y>=0 && x<n && y<m; \\n    }\\n    // The function gives the length of shortest path\\n    // from (x1,y1)->(x2,y2)\\n    int bfs(int x1, int y1, int x2,int y2, vvi &forest){\\n        int n = forest.size(), m = forest[0].size(); \\n        int dx[4] = {1,-1,0,0};\\n        int dy[4] = {0,0,1,-1}; \\n        vector<vector<bool>> vis(n, vector<bool>(m, false)); \\n        queue<pair<int, int>> q;\\n        q.push({x1, y1}); \\n        vis[x1][y1] = true;\\n        int cnt = 0; \\n        // Level Order Traversal\\n        while(!q.empty()){\\n            int sz = q.size(); \\n            while(sz--){\\n                auto node = q.front(); q.pop(); \\n                int x = node.first, y = node.second; \\n                if(x == x2 && y==y2)\\n                    return cnt; \\n                for(int i = 0; i<4; ++i){\\n                    int xr = x + dx[i], yr = y + dy[i]; \\n                    if(isValid(xr,yr,n,m) && !vis[xr][yr]){\\n                        if(forest[xr][yr] > 0){\\n                            q.push({xr,yr});\\n                            vis[xr][yr] = true; \\n                        }\\n                    }\\n                }\\n            }\\n            cnt++; \\n        }\\n        return -1; \\n    }\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if(forest[0][0] == 0)\\n            return -1; \\n        int n = forest.size(), m = forest[0].size(); \\n        // Collect the trees with coordinates in heightwise order\\n        vector<pair<int, pair<int, int>>> trees; \\n        for(int i = 0; i<n; ++i){\\n            for(int j = 0; j<m; ++j){\\n                if(forest[i][j] > 1){\\n                    trees.push_back({forest[i][j], {i,j}}); \\n                }\\n            }\\n        }\\n        sort(trees.begin(), trees.end()); \\n        if(trees[0].second.first != 0 || trees[0].second.second != 0)\\n            trees.insert(trees.begin(), {0,{0,0}});\\n        // Traverse the order and find the shortest path between two adj trees\\n        int steps = 0; \\n        for(int i = 1; i<trees.size(); ++i){\\n            auto src = trees[i-1].second; \\n            auto dest = trees[i].second; \\n            int x1 = src.first, y1 = src.second; \\n            int x2 = dest.first, y2 = dest.second; \\n            int cnt = bfs(x1, y1, x2, y2, forest); \\n            if(cnt == -1)\\n                return -1; \\n            steps += cnt; \\n        }\\n        return steps; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090934,
                "title": "sort-heap-bfs-good-job-leetcode-admin",
                "content": "Hi LeetCode Admin, congratulation, you made every python code using sort(heap) + BFS TLE **again**. Good job on wasting people\\'s time. I thought I did something wrong, but checked some code from discuss, same TLE. \\n\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m, n = len(forest), len(forest[0])\\n        if forest[0][0] == 0:\\n            return -1\\n        # Have priority queue that stores (height,x,y) for each tree in order of min to max.\\n        # Use BFS to find the next available smallest height in priority queue.\\n        heap = []\\n    \\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heappush(heap, (forest[i][j], i, j))\\n                    \\n        \\n        def bfs(sx, sy, tx, ty):\\n            \\n            visited = set()\\n            visited.add((sx, sy))\\n            \\n            queue = deque()\\n            queue.append((sx, sy))\\n            d = 0\\n            while queue:\\n                for _ in range(len(queue)):\\n                    cx, cy = queue.popleft()\\n                    if cx == tx and cy == ty:\\n                        forest[cx][cy] = 1\\n                        return d\\n\\n                    for nx, ny in ((cx+1, cy), (cx-1, cy), (cx, cy-1), (cx, cy+1)):\\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] != 0 and(nx, ny) not in visited:\\n                            queue.append((nx, ny))\\n                            visited.add((nx, ny))\\n\\n                d += 1\\n            return -1\\n        \\n        ans = 0\\n        prev_x, prev_y = 0, 0\\n        while heap:\\n            _, x, y = heappop(heap)\\n            \\n            step = bfs(prev_x, prev_y, x, y)\\n            if step == -1:\\n                return -1\\n            ans += step\\n            prev_x, prev_y = x, y\\n        return ans\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m, n = len(forest), len(forest[0])\\n        if forest[0][0] == 0:\\n            return -1\\n        # Have priority queue that stores (height,x,y) for each tree in order of min to max.\\n        # Use BFS to find the next available smallest height in priority queue.\\n        heap = []\\n    \\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heappush(heap, (forest[i][j], i, j))\\n                    \\n        \\n        def bfs(sx, sy, tx, ty):\\n            \\n            visited = set()\\n            visited.add((sx, sy))\\n            \\n            queue = deque()\\n            queue.append((sx, sy))\\n            d = 0\\n            while queue:\\n                for _ in range(len(queue)):\\n                    cx, cy = queue.popleft()\\n                    if cx == tx and cy == ty:\\n                        forest[cx][cy] = 1\\n                        return d\\n\\n                    for nx, ny in ((cx+1, cy), (cx-1, cy), (cx, cy-1), (cx, cy+1)):\\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] != 0 and(nx, ny) not in visited:\\n                            queue.append((nx, ny))\\n                            visited.add((nx, ny))\\n\\n                d += 1\\n            return -1\\n        \\n        ans = 0\\n        prev_x, prev_y = 0, 0\\n        while heap:\\n            _, x, y = heappop(heap)\\n            \\n            step = bfs(prev_x, prev_y, x, y)\\n            if step == -1:\\n                return -1\\n            ans += step\\n            prev_x, prev_y = x, y\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802123,
                "title": "readable-code-with-functions-comments-python-solution-bfs-with-priority-queue",
                "content": "This code is written in a way that should be understandable by most Leetcoders :)\\nI\\'d recommend reading it in the following order:\\nminStepsToCell, getPossibleMoves (standard bfs)\\ncreateTreeLocationsPriorityQueue,getNextTreeLocation (priority queue / function to feed us the next tree location)\\ncutOffTree -> logic that combines the two concepts (bfs + priority queue)\\n\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        self.createTreeLocationsPriorityQueue(forest)\\n        steps = 0\\n        treeLoc = self.getNextTreeLocation()\\n        currLoc = (0,0)\\n        while treeLoc != -1: \\n\\t\\t#if there are no more trees in the pq this means that we\\'ve cut down all the trees and should return the sum of the steps taken\\n\\t\\t#so in every loop we \"cut\" the next tree (move to the location of the next tree), if we can\\'t we return -1 as per the problem statement.\\n\\t\\t\\n            costToTree = self.minStepsToCell(forest,currLoc,treeLoc)\\n            if costToTree == -1:\\n                return -1\\n            steps += costToTree\\n            currLoc = treeLoc\\n            treeLoc = self.getNextTreeLocation()\\n        return steps\\n            \\n    def getNextTreeLocation(self):\\n\\t#simply pops the next tree from the tree priority queue and returns its location\\n        if self.treePQ:\\n            height,i,j = heapq.heappop(self.treePQ)\\n            return (i,j)\\n        return -1\\n    \\n    def createTreeLocationsPriorityQueue(self,forest):\\n\\t#puts trees in a priority queue with the following format (treeheight,i,j)\\n\\t#when removing trees from the pq they will be removed shortest first,\\n\\t#this helps us easily get the location of the next tree to cut down.\\n        self.treePQ = []\\n        \\n        for i in range(len(forest)):\\n            for j in range(len(forest[0])):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(self.treePQ,(forest[i][j],i,j))\\n    \\n    def minStepsToCell(self,forest,currLoc,targetLoc):\\n\\t#just a regular BFS to find the minimum distance from one location to another.\\n\\t#if we can\\'t reach our destination we return -1\\n        explored = set()\\n        q = [currLoc]\\n        steps = 0\\n        while q:\\n            nlq = []\\n            \\n            for loc in q:\\n                if loc == targetLoc:\\n                    return steps\\n                if loc not in explored:\\n                    explored.add(loc)\\n                    nlq.extend(self.getPossibleMoves(forest,loc))\\n                    \\n            steps += 1\\n            q = nlq\\n        return -1\\n            \\n    def getPossibleMoves(self,forest,loc):\\n\\t#Simply get possible moves (can move to cells that are not \\'0\\'\\n        i,j = loc\\n        moves = []\\n        if i > 0 and forest[i-1][j]:\\n            moves.append((i-1,j))\\n        if i < len(forest)-1 and forest[i+1][j]:\\n            moves.append((i+1,j))\\n        if j > 0 and forest[i][j-1]:\\n            moves.append((i,j-1))\\n        if j < len(forest[0])-1 and forest[i][j+1]:\\n            moves.append((i,j+1))\\n        return moves\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        self.createTreeLocationsPriorityQueue(forest)\\n        steps = 0\\n        treeLoc = self.getNextTreeLocation()\\n        currLoc = (0,0)\\n        while treeLoc != -1: \\n\\t\\t#if there are no more trees in the pq this means that we\\'ve cut down all the trees and should return the sum of the steps taken\\n\\t\\t#so in every loop we \"cut\" the next tree (move to the location of the next tree), if we can\\'t we return -1 as per the problem statement.\\n\\t\\t\\n            costToTree = self.minStepsToCell(forest,currLoc,treeLoc)\\n            if costToTree == -1:\\n                return -1\\n            steps += costToTree\\n            currLoc = treeLoc\\n            treeLoc = self.getNextTreeLocation()\\n        return steps\\n            \\n    def getNextTreeLocation(self):\\n\\t#simply pops the next tree from the tree priority queue and returns its location\\n        if self.treePQ:\\n            height,i,j = heapq.heappop(self.treePQ)\\n            return (i,j)\\n        return -1\\n    \\n    def createTreeLocationsPriorityQueue(self,forest):\\n\\t#puts trees in a priority queue with the following format (treeheight,i,j)\\n\\t#when removing trees from the pq they will be removed shortest first,\\n\\t#this helps us easily get the location of the next tree to cut down.\\n        self.treePQ = []\\n        \\n        for i in range(len(forest)):\\n            for j in range(len(forest[0])):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(self.treePQ,(forest[i][j],i,j))\\n    \\n    def minStepsToCell(self,forest,currLoc,targetLoc):\\n\\t#just a regular BFS to find the minimum distance from one location to another.\\n\\t#if we can\\'t reach our destination we return -1\\n        explored = set()\\n        q = [currLoc]\\n        steps = 0\\n        while q:\\n            nlq = []\\n            \\n            for loc in q:\\n                if loc == targetLoc:\\n                    return steps\\n                if loc not in explored:\\n                    explored.add(loc)\\n                    nlq.extend(self.getPossibleMoves(forest,loc))\\n                    \\n            steps += 1\\n            q = nlq\\n        return -1\\n            \\n    def getPossibleMoves(self,forest,loc):\\n\\t#Simply get possible moves (can move to cells that are not \\'0\\'\\n        i,j = loc\\n        moves = []\\n        if i > 0 and forest[i-1][j]:\\n            moves.append((i-1,j))\\n        if i < len(forest)-1 and forest[i+1][j]:\\n            moves.append((i+1,j))\\n        if j > 0 and forest[i][j-1]:\\n            moves.append((i,j-1))\\n        if j < len(forest[0])-1 and forest[i][j+1]:\\n            moves.append((i,j+1))\\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743118,
                "title": "python-bfs-no-tle-easy-to-understand",
                "content": "This solution would get TLE if we used `visited` set instead of `discovered` because the queue will contain many duplicates if keep enqueing nodes until they\\'ve been explored.\\n\\n```\\nBLOCKED = 0\\n\\n\\nclass DisjointNodesError(Exception):\\n    pass\\n\\n\\nclass Solution:\\n    \"\"\"\\n    we want to minimize the number of steps: ie path length\\n    we need to cut down trees in order from shortest to tallest\\n\\n    find shortest path from start (0, 0) to shortest tree\\n    then find shortest path to each tree in sorted order\\n    summing paths the entire time\\n\\t\\n\\tall moves: north east west south  => cost 1\\n    unweighted graph, bfs will give us the shortest path between any two points\\n\\t\\n    if we cannot get to a tree because the trees are disjoint return -1\\n    we shouldn\\'t need to check beforehand whether or not trees are disjoint because we will find out during breadth first search\\n\\n    first, sort trees by height so we know order to target them in => N logN\\n    then do bfs between each tree in sorted order => bfs O(n) * # trees n\\n    O(n^2)\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.grid = [[]]\\n        self.left_bound = -1\\n        self.top_bound = -1\\n        self.bottom_bound = 0\\n        self.right_bound = 0\\n\\n    def get_neighbors(self, node):\\n        r, c = node\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        neighbors = []\\n        for dr, dc in directions:\\n            if self.top_bound < r + dr < self.bottom_bound and self.left_bound < c + dc < self.right_bound:\\n                if self.grid[r + dr][c + dc] != BLOCKED:\\n                    neighbors.append((r + dr, c + dc))\\n        return neighbors\\n\\n    def bfs(self, start, end):\\n        discovered = set()\\n        queue = deque([(start, 0)])\\n        while queue:\\n            current, distance = queue.popleft()\\n            if current == end:\\n                return distance\\n            for neighbor in self.get_neighbors(current):\\n                if neighbor not in discovered:\\n                    queue.append((neighbor, distance + 1))\\n                    # use discovered instead of visited so we don\\'t add duplicate vertices to queue\\n                    discovered.add(neighbor)\\n        raise DisjointNodesError()\\n\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        self.grid = forest\\n        self.bottom_bound = len(forest)\\n        self.right_bound = len(forest[0])\\n        trees = []\\n        # gather trees\\n        for r, row in enumerate(forest):\\n            for c, height in enumerate(row):\\n                if height > 1:\\n                    trees.append((height, r, c))\\n        # sort trees\\n        trees.sort(key=lambda x: x[0])\\n        num_steps = 0\\n        # find shortest path between trees, sum path length\\n        start = (0, 0)\\n        for idx in range(0, len(trees)):\\n            height, r, c = trees[idx]\\n            next_tree = (r, c)\\n            try:\\n                distance = self.bfs(start, next_tree)\\n            except DisjointNodesError:\\n                return -1\\n            num_steps += distance\\n            start = next_tree\\n        return num_steps\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nBLOCKED = 0\\n\\n\\nclass DisjointNodesError(Exception):\\n    pass\\n\\n\\nclass Solution:\\n    \"\"\"\\n    we want to minimize the number of steps: ie path length\\n    we need to cut down trees in order from shortest to tallest\\n\\n    find shortest path from start (0, 0) to shortest tree\\n    then find shortest path to each tree in sorted order\\n    summing paths the entire time\\n\\t\\n\\tall moves: north east west south  => cost 1\\n    unweighted graph, bfs will give us the shortest path between any two points\\n\\t\\n    if we cannot get to a tree because the trees are disjoint return -1\\n    we shouldn\\'t need to check beforehand whether or not trees are disjoint because we will find out during breadth first search\\n\\n    first, sort trees by height so we know order to target them in => N logN\\n    then do bfs between each tree in sorted order => bfs O(n) * # trees n\\n    O(n^2)\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.grid = [[]]\\n        self.left_bound = -1\\n        self.top_bound = -1\\n        self.bottom_bound = 0\\n        self.right_bound = 0\\n\\n    def get_neighbors(self, node):\\n        r, c = node\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        neighbors = []\\n        for dr, dc in directions:\\n            if self.top_bound < r + dr < self.bottom_bound and self.left_bound < c + dc < self.right_bound:\\n                if self.grid[r + dr][c + dc] != BLOCKED:\\n                    neighbors.append((r + dr, c + dc))\\n        return neighbors\\n\\n    def bfs(self, start, end):\\n        discovered = set()\\n        queue = deque([(start, 0)])\\n        while queue:\\n            current, distance = queue.popleft()\\n            if current == end:\\n                return distance\\n            for neighbor in self.get_neighbors(current):\\n                if neighbor not in discovered:\\n                    queue.append((neighbor, distance + 1))\\n                    # use discovered instead of visited so we don\\'t add duplicate vertices to queue\\n                    discovered.add(neighbor)\\n        raise DisjointNodesError()\\n\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        self.grid = forest\\n        self.bottom_bound = len(forest)\\n        self.right_bound = len(forest[0])\\n        trees = []\\n        # gather trees\\n        for r, row in enumerate(forest):\\n            for c, height in enumerate(row):\\n                if height > 1:\\n                    trees.append((height, r, c))\\n        # sort trees\\n        trees.sort(key=lambda x: x[0])\\n        num_steps = 0\\n        # find shortest path between trees, sum path length\\n        start = (0, 0)\\n        for idx in range(0, len(trees)):\\n            height, r, c = trees[idx]\\n            next_tree = (r, c)\\n            try:\\n                distance = self.bfs(start, next_tree)\\n            except DisjointNodesError:\\n                return -1\\n            num_steps += distance\\n            start = next_tree\\n        return num_steps\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1605604,
                "title": "java-a-91-speed-mem-with-explanations",
                "content": "If you are not familiar with A* search, read this https://www.redblobgames.com/pathfinding/a-star/introduction.html first. It comes in handy with quesitons like this. This question basically boils down to how to effectively search for the next tree to cut down when they are all over the map. A* is great for this while standard BFS may give TLE. A* uses a priorityQueue to achieve its effectiveness.\\n\\nLet\\'s take down the problem into several parts:\\n\\nPart 1: Count how many trees there are and record their positon and heights with a List.\\nPart 2: Check if we can reach all the trees, if not, return -1 here.\\nPart 3: Sort the ArrayList in accordance with their height.\\nPart 4: Start our A* search and loop it until there is no more tree to cut\\nPart 5: Return the result. \\n\\nThe below is my code for reference\\n```\\nclass Solution {\\n    private static int N;\\n    private static int M;\\n    private static final int[][] dirs = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        N = forest.size();\\n        M = forest.get(0).size();\\n        \\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < M; j++)\\n                if (forest.get(i).get(j) > 1)\\n                    trees.add(new int[]{i, j, forest.get(i).get(j)});\\n\\n        if (trees.size() != reachableTrees(forest, 0, 0, new boolean[N][M])) return -1;\\n        Collections.sort(trees, Comparator.comparingInt(o -> o[2]));\\n\\n        int ans = 0;\\n        int idx = 0;\\n        int pr = 0;\\n        int pc = 0;\\n        while(idx < trees.size()){\\n            int tr = trees.get(idx)[0];\\n            int tc = trees.get(idx++)[1];\\n            PriorityQueue<int[]> minheap = new PriorityQueue<>(Comparator.comparingInt(o -> o[0]));\\n            minheap.offer(new int[]{dist(pr, pc, tr, tc), 0, pr, pc}); // priority, steps, r, c\\n            boolean[][] seen = new boolean[N][M];\\n            while(!minheap.isEmpty()){\\n                int[] cur = minheap.poll();\\n                int pri = cur[0];\\n                int steps = cur[1];\\n                int r = cur[2];\\n                int c = cur[3];\\n                if (r == tr && c == tc) {ans += steps; break;}\\n                seen[r][c] = true;\\n\\n                for (int[] d : dirs){\\n                    int nr = r + d[0];\\n                    int nc = c + d[1];\\n                    if (nr < 0 || nc < 0 || nr >= N || nc >= M || seen[nr][nc]\\n                            || forest.get(nr).get(nc) == 0)\\n                        continue;\\n                    minheap.offer(new int[]{dist(nr, nc, tr, tc) + steps + 1, steps + 1, nr, nc});\\n                }\\n            }\\n            pr = tr;\\n            pc = tc;\\n        }\\n        return ans;\\n    }\\n\\n    private int reachableTrees(List<List<Integer>> forest, int r, int c, boolean[][] seen){\\n        if (r < 0 || r >= N || c < 0 || c >= M || seen[r][c]\\n                || forest.get(r).get(c) == 0) return 0;\\n\\n        seen[r][c] = true;\\n\\n        return (forest.get(r).get(c) > 1? 1 : 0) \\n            + reachableTrees(forest, r + 1, c, seen)\\n            + reachableTrees(forest, r - 1, c, seen)\\n            + reachableTrees(forest, r, c + 1, seen)\\n            + reachableTrees(forest, r, c - 1, seen);\\n    }\\n\\n    private int dist(int x, int y, int dx, int dy){\\n        return Math.abs(x - dx) + Math.abs(y - dy);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    private static int N;\\n    private static int M;\\n    private static final int[][] dirs = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        N = forest.size();\\n        M = forest.get(0).size();\\n        \\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < M; j++)\\n                if (forest.get(i).get(j) > 1)\\n                    trees.add(new int[]{i, j, forest.get(i).get(j)});\\n\\n        if (trees.size() != reachableTrees(forest, 0, 0, new boolean[N][M])) return -1;\\n        Collections.sort(trees, Comparator.comparingInt(o -> o[2]));\\n\\n        int ans = 0;\\n        int idx = 0;\\n        int pr = 0;\\n        int pc = 0;\\n        while(idx < trees.size()){\\n            int tr = trees.get(idx)[0];\\n            int tc = trees.get(idx++)[1];\\n            PriorityQueue<int[]> minheap = new PriorityQueue<>(Comparator.comparingInt(o -> o[0]));\\n            minheap.offer(new int[]{dist(pr, pc, tr, tc), 0, pr, pc}); // priority, steps, r, c\\n            boolean[][] seen = new boolean[N][M];\\n            while(!minheap.isEmpty()){\\n                int[] cur = minheap.poll();\\n                int pri = cur[0];\\n                int steps = cur[1];\\n                int r = cur[2];\\n                int c = cur[3];\\n                if (r == tr && c == tc) {ans += steps; break;}\\n                seen[r][c] = true;\\n\\n                for (int[] d : dirs){\\n                    int nr = r + d[0];\\n                    int nc = c + d[1];\\n                    if (nr < 0 || nc < 0 || nr >= N || nc >= M || seen[nr][nc]\\n                            || forest.get(nr).get(nc) == 0)\\n                        continue;\\n                    minheap.offer(new int[]{dist(nr, nc, tr, tc) + steps + 1, steps + 1, nr, nc});\\n                }\\n            }\\n            pr = tr;\\n            pc = tc;\\n        }\\n        return ans;\\n    }\\n\\n    private int reachableTrees(List<List<Integer>> forest, int r, int c, boolean[][] seen){\\n        if (r < 0 || r >= N || c < 0 || c >= M || seen[r][c]\\n                || forest.get(r).get(c) == 0) return 0;\\n\\n        seen[r][c] = true;\\n\\n        return (forest.get(r).get(c) > 1? 1 : 0) \\n            + reachableTrees(forest, r + 1, c, seen)\\n            + reachableTrees(forest, r - 1, c, seen)\\n            + reachableTrees(forest, r, c + 1, seen)\\n            + reachableTrees(forest, r, c - 1, seen);\\n    }\\n\\n    private int dist(int x, int y, int dx, int dy){\\n        return Math.abs(x - dx) + Math.abs(y - dy);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539771,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0 || forest.get(0).size() == 0) {\\n            return -1;\\n        }\\n    \\n        int[][] matrix = new int[forest.size()][forest.get(0).size()];\\n        List<Integer> trees = new ArrayList<>();\\n        \\n        for (int i = 0; i < forest.size(); i++) {\\n            List<Integer> list = forest.get(i);\\n            for (int j = 0; j < list.size(); j++) {\\n                matrix[i][j] = list.get(j);\\n                if (matrix[i][j] > 1) {\\n                    trees.add(matrix[i][j]);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(trees);\\n        int row = 0, col = 0;\\n        int steps = 0;\\n        \\n        for (Integer tree: trees) {\\n            boolean[][] visited = new boolean[matrix.length][matrix[0].length];\\n            int[] result = cut(matrix, visited, row, col, tree);\\n            \\n            if (result[0] == 1) {\\n                steps += result[1];\\n                row = result[2];\\n                col = result[3];\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return steps;\\n    }\\n    \\n    private int[] cut(int[][] matrix, boolean[][] visited, int row, int col, int tree) {\\n        if (matrix[row][col] == tree) {\\n            matrix[row][col] = 1;\\n            return new int[] {1, 0, row, col};\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        q.add(row + \"_\" + col);\\n        visited[row][col] = true;\\n        q.add(null);\\n        \\n        int steps = 0;\\n        \\n        while (!q.isEmpty()) {\\n            String current = q.remove();\\n            if (current == null) {\\n                if (!q.isEmpty()) {\\n                    q.add(null);\\n                }\\n                steps++;\\n                continue;\\n            }\\n            \\n            String[] parts = current.split(\"_\");\\n            row = Integer.parseInt(parts[0]);\\n            col = Integer.parseInt(parts[1]);\\n            if (matrix[row][col] == tree) {\\n                return new int[] {1, steps, row, col};\\n            }\\n            \\n            if (isValidCell(matrix, visited, row - 1, col)) {\\n                q.add((row - 1) + \"_\" + (col));\\n                visited[row - 1][col] = true;\\n            }\\n            if (isValidCell(matrix, visited, row + 1, col)) {\\n                q.add((row + 1) + \"_\" + (col));\\n                visited[row + 1][col] = true;\\n            }\\n            if (isValidCell(matrix, visited, row, col - 1)) {\\n                q.add((row) + \"_\" + (col - 1));\\n                visited[row][col - 1] = true;\\n            }\\n            if (isValidCell(matrix, visited, row, col + 1)) {\\n                q.add((row) + \"_\" + (col + 1));\\n                visited[row][col + 1] = true;\\n            }\\n        }\\n        return new int[] {0, 0, row, col};\\n        \\n    }\\n    \\n    private boolean isValidCell(int[][] matrix, boolean[][] visited, int row, int col) {\\n        return row >= 0 && col >= 0 && row < matrix.length && col < matrix[0].length && matrix[row][col] != 0 && !visited[row][col];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0 || forest.get(0).size() == 0) {\\n            return -1;\\n        }\\n    \\n        int[][] matrix = new int[forest.size()][forest.get(0).size()];\\n        List<Integer> trees = new ArrayList<>();\\n        \\n        for (int i = 0; i < forest.size(); i++) {\\n            List<Integer> list = forest.get(i);\\n            for (int j = 0; j < list.size(); j++) {\\n                matrix[i][j] = list.get(j);\\n                if (matrix[i][j] > 1) {\\n                    trees.add(matrix[i][j]);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(trees);\\n        int row = 0, col = 0;\\n        int steps = 0;\\n        \\n        for (Integer tree: trees) {\\n            boolean[][] visited = new boolean[matrix.length][matrix[0].length];\\n            int[] result = cut(matrix, visited, row, col, tree);\\n            \\n            if (result[0] == 1) {\\n                steps += result[1];\\n                row = result[2];\\n                col = result[3];\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return steps;\\n    }\\n    \\n    private int[] cut(int[][] matrix, boolean[][] visited, int row, int col, int tree) {\\n        if (matrix[row][col] == tree) {\\n            matrix[row][col] = 1;\\n            return new int[] {1, 0, row, col};\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        q.add(row + \"_\" + col);\\n        visited[row][col] = true;\\n        q.add(null);\\n        \\n        int steps = 0;\\n        \\n        while (!q.isEmpty()) {\\n            String current = q.remove();\\n            if (current == null) {\\n                if (!q.isEmpty()) {\\n                    q.add(null);\\n                }\\n                steps++;\\n                continue;\\n            }\\n            \\n            String[] parts = current.split(\"_\");\\n            row = Integer.parseInt(parts[0]);\\n            col = Integer.parseInt(parts[1]);\\n            if (matrix[row][col] == tree) {\\n                return new int[] {1, steps, row, col};\\n            }\\n            \\n            if (isValidCell(matrix, visited, row - 1, col)) {\\n                q.add((row - 1) + \"_\" + (col));\\n                visited[row - 1][col] = true;\\n            }\\n            if (isValidCell(matrix, visited, row + 1, col)) {\\n                q.add((row + 1) + \"_\" + (col));\\n                visited[row + 1][col] = true;\\n            }\\n            if (isValidCell(matrix, visited, row, col - 1)) {\\n                q.add((row) + \"_\" + (col - 1));\\n                visited[row][col - 1] = true;\\n            }\\n            if (isValidCell(matrix, visited, row, col + 1)) {\\n                q.add((row) + \"_\" + (col + 1));\\n                visited[row][col + 1] = true;\\n            }\\n        }\\n        return new int[] {0, 0, row, col};\\n        \\n    }\\n    \\n    private boolean isValidCell(int[][] matrix, boolean[][] visited, int row, int col) {\\n        return row >= 0 && col >= 0 && row < matrix.length && col < matrix[0].length && matrix[row][col] != 0 && !visited[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426296,
                "title": "java-sorting-bfs",
                "content": "Idea: Find the order of trees you need to find, BFS between each of the two points to find shortest path between each consective pair of trees (ie shortest path between x1 and x2, then x2 and x3 where xi comes before xj if i < j).\\n\\n```\\nclass Solution {\\n    class Triple{\\n        int val;\\n        int row;\\n        int col;\\n        public Triple (int val, int row, int col){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    class TripleComparator implements Comparator<Triple>{\\n        public int compare(Triple a, Triple b){\\n            return a.val - b.val;\\n        }\\n    }\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        List<Triple> trees = new ArrayList<>();\\n        for(int i = 0; i < forest.size(); i++){\\n            for(int j = 0; j < forest.get(i).size(); j++){\\n                if(forest.get(i).get(j) > 1) trees.add(new Triple(forest.get(i).get(j), i, j));\\n            }\\n        }\\n        Collections.sort(trees, new TripleComparator());\\n        int[][] directions = new int[][] {{1,0}, {-1,0}, {0,-1}, {0,1}};\\n        int totalDistance = 0;\\n        Triple pastTree = new Triple(0,0,0);\\n        for(int i = 0; i < trees.size(); i++){\\n            Triple currTree = trees.get(i);\\n            int distance = findNextTree(forest, pastTree.row, pastTree.col, currTree.row, currTree.col, directions);\\n            if(distance == -1) return -1;\\n            totalDistance += distance;\\n            pastTree = currTree; \\n        }\\n        return totalDistance; \\n    }\\n    //number of edges between nodes, else -1 if unreachable \\n    //bfs gives shortest path from one node to another we do this for every pair of nodes\\n    private int findNextTree(List<List<Integer>> forest, int sr, int sc, int dr, int dc, int[][] directions){\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        Queue<Triple> bfsQ = new LinkedList<>();\\n        bfsQ.offer(new Triple(forest.get(sr).get(sc), sr, sc));\\n        int level = -1;\\n        while(!bfsQ.isEmpty()){\\n            int qSize = bfsQ.size();\\n            while(qSize > 0){\\n                qSize--;\\n                Triple currNode = bfsQ.poll();\\n                if(currNode.row == dr && currNode.col == dc) {\\n                    level++; \\n                    return level;\\n                }\\n                for(int[] dir : directions){\\n                    int nr = dir[0] + currNode.row;\\n                    int nc = dir[1] + currNode.col;\\n                    if(nr < 0 || nr > forest.size() - 1 || nc < 0 || nc > forest.get(nr).size()-1) continue;\\n                    if(visited[nr][nc] || forest.get(nr).get(nc) < 1) continue;\\n                    bfsQ.offer(new Triple(forest.get(nr).get(nc), nr, nc));\\n                    visited[nr][nc] = true; \\n                }\\n            }\\n            level ++; \\n        }\\n        return -1; \\n    }\\n    \\n     \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Triple{\\n        int val;\\n        int row;\\n        int col;\\n        public Triple (int val, int row, int col){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    class TripleComparator implements Comparator<Triple>{\\n        public int compare(Triple a, Triple b){\\n            return a.val - b.val;\\n        }\\n    }\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        List<Triple> trees = new ArrayList<>();\\n        for(int i = 0; i < forest.size(); i++){\\n            for(int j = 0; j < forest.get(i).size(); j++){\\n                if(forest.get(i).get(j) > 1) trees.add(new Triple(forest.get(i).get(j), i, j));\\n            }\\n        }\\n        Collections.sort(trees, new TripleComparator());\\n        int[][] directions = new int[][] {{1,0}, {-1,0}, {0,-1}, {0,1}};\\n        int totalDistance = 0;\\n        Triple pastTree = new Triple(0,0,0);\\n        for(int i = 0; i < trees.size(); i++){\\n            Triple currTree = trees.get(i);\\n            int distance = findNextTree(forest, pastTree.row, pastTree.col, currTree.row, currTree.col, directions);\\n            if(distance == -1) return -1;\\n            totalDistance += distance;\\n            pastTree = currTree; \\n        }\\n        return totalDistance; \\n    }\\n    //number of edges between nodes, else -1 if unreachable \\n    //bfs gives shortest path from one node to another we do this for every pair of nodes\\n    private int findNextTree(List<List<Integer>> forest, int sr, int sc, int dr, int dc, int[][] directions){\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        Queue<Triple> bfsQ = new LinkedList<>();\\n        bfsQ.offer(new Triple(forest.get(sr).get(sc), sr, sc));\\n        int level = -1;\\n        while(!bfsQ.isEmpty()){\\n            int qSize = bfsQ.size();\\n            while(qSize > 0){\\n                qSize--;\\n                Triple currNode = bfsQ.poll();\\n                if(currNode.row == dr && currNode.col == dc) {\\n                    level++; \\n                    return level;\\n                }\\n                for(int[] dir : directions){\\n                    int nr = dir[0] + currNode.row;\\n                    int nc = dir[1] + currNode.col;\\n                    if(nr < 0 || nr > forest.size() - 1 || nc < 0 || nc > forest.get(nr).size()-1) continue;\\n                    if(visited[nr][nc] || forest.get(nr).get(nc) < 1) continue;\\n                    bfsQ.offer(new Triple(forest.get(nr).get(nc), nr, nc));\\n                    visited[nr][nc] = true; \\n                }\\n            }\\n            level ++; \\n        }\\n        return -1; \\n    }\\n    \\n     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373788,
                "title": "c-clean-and-simple-bfs-with-proper-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int sx=0,sy=0;\\n    vector<vector<int>> offsets={{1,0},{0,1},{-1,0},{0,-1}};\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        \\n        if(forest[0][0]==0)\\n            return -1;\\n        \\n        //first get heights of all the trees.\\n        vector<int> tree_heights;\\n        for(int i=0;i<forest.size();i++){\\n            for(int j=0;j<forest.at(0).size();j++){\\n                if(forest[i][j]!=1&&forest[i][j]!=0)\\n                    tree_heights.push_back(forest[i][j]);\\n            }\\n        }\\n        \\n        //sort them (smaller to larger)\\n        sort(tree_heights.begin(),tree_heights.end());\\n        vector<vector<int>> temp;\\n        \\n        int total_steps=0,target;\\n        //loop that will find the next tree which we have to cut. and after finding that tree\\n        // we add the distance to total_distance and change the next tree(target) and update the forest vector\\n        for(int i=0;i<tree_heights.size();i++){\\n\\t\\t\\n            target=tree_heights[i];\\n            temp=forest;\\n            int h=find_tree(sx,sy,target,temp);\\n            if(h==-1){\\n                return -1;\\n            }\\n        \\n\\t\\t    total_steps+=h;\\n            forest[sx][sy]=1;\\n        }\\n        return total_steps;\\n    }\\n    \\n    \\n    //this function finds tree with a given height from a starting point.\\n\\t//function itself is pretty standard BFS implementation.\\n    int find_tree(int xi,int yi,int target,vector<vector<int>>&temp){\\n        \\n\\t\\t//corner case\\n        if(temp[xi][yi]==target){\\n            sx=xi;\\n            sy=yi;\\n            return 0;\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        q.push({xi,yi});\\n        \\n        int current_steps=1;\\n        \\n        while(!q.empty()){\\n            int l=q.size();\\n            for(int z=0;z<l;z++){\\n                auto[i,j]=q.front();\\n                q.pop();\\n                \\n                for(int m=0;m<4;m++){\\n                    \\n                    int x=i-offsets[m][0];\\n                    int y=j-offsets[m][1];\\n                    \\n                    if(x<0||y<0||x>=temp.size()||y>=temp.at(0).size()||temp[x][y]==0||temp[x][y]==-1)\\n                        continue;\\n                    \\n                    if(temp[x][y]==target){\\n                        sx=x;\\n                        sy=y;\\n                        return current_steps;\\n                    }\\n                    \\n                    temp[x][y]=-1;\\n                    q.push({x,y});\\n                }\\n            }\\n            current_steps++;\\n        }\\n        return -1;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sx=0,sy=0;\\n    vector<vector<int>> offsets={{1,0},{0,1},{-1,0},{0,-1}};\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        \\n        if(forest[0][0]==0)\\n            return -1;\\n        \\n        //first get heights of all the trees.\\n        vector<int> tree_heights;\\n        for(int i=0;i<forest.size();i++){\\n            for(int j=0;j<forest.at(0).size();j++){\\n                if(forest[i][j]!=1&&forest[i][j]!=0)\\n                    tree_heights.push_back(forest[i][j]);\\n            }\\n        }\\n        \\n        //sort them (smaller to larger)\\n        sort(tree_heights.begin(),tree_heights.end());\\n        vector<vector<int>> temp;\\n        \\n        int total_steps=0,target;\\n        //loop that will find the next tree which we have to cut. and after finding that tree\\n        // we add the distance to total_distance and change the next tree(target) and update the forest vector\\n        for(int i=0;i<tree_heights.size();i++){\\n\\t\\t\\n            target=tree_heights[i];\\n            temp=forest;\\n            int h=find_tree(sx,sy,target,temp);\\n            if(h==-1){\\n                return -1;\\n            }\\n        \\n\\t\\t    total_steps+=h;\\n            forest[sx][sy]=1;\\n        }\\n        return total_steps;\\n    }\\n    \\n    \\n    //this function finds tree with a given height from a starting point.\\n\\t//function itself is pretty standard BFS implementation.\\n    int find_tree(int xi,int yi,int target,vector<vector<int>>&temp){\\n        \\n\\t\\t//corner case\\n        if(temp[xi][yi]==target){\\n            sx=xi;\\n            sy=yi;\\n            return 0;\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        q.push({xi,yi});\\n        \\n        int current_steps=1;\\n        \\n        while(!q.empty()){\\n            int l=q.size();\\n            for(int z=0;z<l;z++){\\n                auto[i,j]=q.front();\\n                q.pop();\\n                \\n                for(int m=0;m<4;m++){\\n                    \\n                    int x=i-offsets[m][0];\\n                    int y=j-offsets[m][1];\\n                    \\n                    if(x<0||y<0||x>=temp.size()||y>=temp.at(0).size()||temp[x][y]==0||temp[x][y]==-1)\\n                        continue;\\n                    \\n                    if(temp[x][y]==target){\\n                        sx=x;\\n                        sy=y;\\n                        return current_steps;\\n                    }\\n                    \\n                    temp[x][y]=-1;\\n                    q.push({x,y});\\n                }\\n            }\\n            current_steps++;\\n        }\\n        return -1;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275005,
                "title": "java-bfs-with-sorted-trees-clean-with-comments",
                "content": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n        //1) put all tree\\'s into a list\\n        //2) sort the tree list by smallest\\n        //3) from idx (0,0) cut down all the trees by getting the next smallest tree from the list\\n        //4) call bfs to count the steps from current starting index until the next smallest tree\\n        \\n        //so if you can make it from the beginning to the smallest tree. count the steps at that tree as the new starting point to get to the next smallest\\n        \\n        List<int[]> trees = new ArrayList<>();\\n        \\n        int R = forest.size(), C = forest.get(0).size();\\n        \\n        //1)\\n        for(int r = 0; r < R; r++){\\n            \\n            for(int c = 0; c < C; c++){\\n                \\n                int treeHeight = forest.get(r).get(c);\\n                \\n                if(treeHeight < 2) continue;\\n                \\n                trees.add(new int[]{ r, c, treeHeight});\\n            }\\n        }\\n        \\n        //2)\\n        Collections.sort(trees, (tree1, tree2) -> { return tree1[2] - tree2[2]; });\\n        \\n        int steps = 0;\\n        \\n        //3)\\n        int[] startTree = new int[] { 0, 0 };\\n        \\n        for(int[] nextTree : trees){\\n            \\n            int stepsToNextTree = getStepsToNextTree(forest, startTree, nextTree, R, C);\\n            \\n            //we could not make it to the next tree, therefore not all trees can be cut down\\n            if(stepsToNextTree < 0) return -1;\\n            \\n            steps += stepsToNextTree;\\n            \\n            //the current next tree becomes the new start tree\\n            \\n            startTree = nextTree;\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    private int[][] directions = new int[][]{ {0, 1}, {0, -1}, {-1, 0}, {1, 0} };\\n    \\n    private int getStepsToNextTree(List<List<Integer>> forest, int[] startTree, int[] nextTree, int R, int C){\\n        \\n        //implelent bfs to move around the board taking steps to reach the next tree\\n        //do not move back to a visited tree within this function\\n        boolean[][] seen = new boolean[R][C];\\n        \\n        seen[startTree[0]][startTree[1]] = true;\\n        \\n        Queue<int[]> toVisit = new LinkedList<>();\\n\\n        toVisit.offer(startTree);\\n        \\n        int steps = 0;\\n        \\n        while(!toVisit.isEmpty()){\\n            \\n            //pop elements off the q and process level by level\\n            int size = toVisit.size();\\n                \\n            for(int i = 0; i < size; i++){\\n                \\n                int[] visitedTree = toVisit.poll();\\n                \\n                //if we have reached the next tree we can stop\\n                if(visitedTree[0] == nextTree[0] && visitedTree[1] == nextTree[1]) return steps;\\n\\n                //search surrounding cells for a connection to the next tree\\n                \\n                for(int[] dir : directions){\\n                    \\n                    int r = visitedTree[0] + dir[0];\\n                    int c = visitedTree[1] + dir[1];\\n                    \\n                    if(r < R && c < C && r >= 0 && c >= 0 && !seen[r][c] && forest.get(r).get(c) > 0){\\n                        \\n                        toVisit.offer(new int[]{r, c});\\n                        seen[r][c] = true;\\n                    }\\n                }\\n            }\\n            \\n            //each time we visit a tree, we find all surrounding connected trees - however we only move one step when we visit that tree\\n            steps++;\\n        }\\n        \\n        //if we have proccessed all surrounding cells as possible but not found the nextTree that means we will cannot connect to it\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n        //1) put all tree\\'s into a list\\n        //2) sort the tree list by smallest\\n        //3) from idx (0,0) cut down all the trees by getting the next smallest tree from the list\\n        //4) call bfs to count the steps from current starting index until the next smallest tree\\n        \\n        //so if you can make it from the beginning to the smallest tree. count the steps at that tree as the new starting point to get to the next smallest\\n        \\n        List<int[]> trees = new ArrayList<>();\\n        \\n        int R = forest.size(), C = forest.get(0).size();\\n        \\n        //1)\\n        for(int r = 0; r < R; r++){\\n            \\n            for(int c = 0; c < C; c++){\\n                \\n                int treeHeight = forest.get(r).get(c);\\n                \\n                if(treeHeight < 2) continue;\\n                \\n                trees.add(new int[]{ r, c, treeHeight});\\n            }\\n        }\\n        \\n        //2)\\n        Collections.sort(trees, (tree1, tree2) -> { return tree1[2] - tree2[2]; });\\n        \\n        int steps = 0;\\n        \\n        //3)\\n        int[] startTree = new int[] { 0, 0 };\\n        \\n        for(int[] nextTree : trees){\\n            \\n            int stepsToNextTree = getStepsToNextTree(forest, startTree, nextTree, R, C);\\n            \\n            //we could not make it to the next tree, therefore not all trees can be cut down\\n            if(stepsToNextTree < 0) return -1;\\n            \\n            steps += stepsToNextTree;\\n            \\n            //the current next tree becomes the new start tree\\n            \\n            startTree = nextTree;\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    private int[][] directions = new int[][]{ {0, 1}, {0, -1}, {-1, 0}, {1, 0} };\\n    \\n    private int getStepsToNextTree(List<List<Integer>> forest, int[] startTree, int[] nextTree, int R, int C){\\n        \\n        //implelent bfs to move around the board taking steps to reach the next tree\\n        //do not move back to a visited tree within this function\\n        boolean[][] seen = new boolean[R][C];\\n        \\n        seen[startTree[0]][startTree[1]] = true;\\n        \\n        Queue<int[]> toVisit = new LinkedList<>();\\n\\n        toVisit.offer(startTree);\\n        \\n        int steps = 0;\\n        \\n        while(!toVisit.isEmpty()){\\n            \\n            //pop elements off the q and process level by level\\n            int size = toVisit.size();\\n                \\n            for(int i = 0; i < size; i++){\\n                \\n                int[] visitedTree = toVisit.poll();\\n                \\n                //if we have reached the next tree we can stop\\n                if(visitedTree[0] == nextTree[0] && visitedTree[1] == nextTree[1]) return steps;\\n\\n                //search surrounding cells for a connection to the next tree\\n                \\n                for(int[] dir : directions){\\n                    \\n                    int r = visitedTree[0] + dir[0];\\n                    int c = visitedTree[1] + dir[1];\\n                    \\n                    if(r < R && c < C && r >= 0 && c >= 0 && !seen[r][c] && forest.get(r).get(c) > 0){\\n                        \\n                        toVisit.offer(new int[]{r, c});\\n                        seen[r][c] = true;\\n                    }\\n                }\\n            }\\n            \\n            //each time we visit a tree, we find all surrounding connected trees - however we only move one step when we visit that tree\\n            steps++;\\n        }\\n        \\n        //if we have proccessed all surrounding cells as possible but not found the nextTree that means we will cannot connect to it\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875059,
                "title": "ruby-accepted-solution",
                "content": "I had few runs of here-and-there small optimizations which finally brought me to the AC Solution.\\n\\nThe main idea is: check all the skip cases for the cell before adding it to the queue.\\n\\n```\\ndef cut_off_tree(forest)\\n    h = []\\n\\n    for i in 0..forest.size - 1\\n      for j in 0..forest[0].size - 1\\n        if forest[i][j] > 1\\n          h.push(forest[i][j])\\n        end\\n      end\\n    end\\n\\n    h.sort!\\n\\n    helper(forest, 0, 0, h, 0)\\nend\\n\\ndef helper(forest, istart, jstart, h, n)\\n  return if n == h.size\\n  target = h[n]\\n  q = [[istart, jstart]]\\n\\n  step = 0\\n  visited = Array.new(forest.size) { Array.new(forest[0].size, 0) }\\n  while !q.empty?\\n    q.size.times do\\n      i, j = q.shift\\n\\n      if forest[i][j] == target\\n        forest[i][j] = 1\\n        next_search = helper(forest, i, j, h, n + 1)\\n        return -1 if next_search == -1\\n        return step + next_search.to_i\\n      else\\n        if i - 1 >= 0 && forest[i - 1][j] > 0 && visited[i - 1][j] == 0\\n          q.push([i - 1, j])\\n          visited[i - 1][j] = 1\\n        end\\n        if i + 1 < forest.size && forest[i + 1][j] > 0 && visited[i + 1][j] == 0\\n          q.push([i + 1, j])\\n          visited[i + 1][j] = 1\\n        end\\n        if j - 1 >= 0 && forest[i][j - 1] > 0 && visited[i][j - 1] == 0\\n          q.push([i, j - 1])\\n          visited[i][j - 1] = 1\\n        end\\n        if j + 1 < forest[0].size && forest[i][j + 1] > 0 && visited[i][j + 1] == 0\\n          q.push([i, j + 1])\\n          visited[i][j + 1] = 1\\n        end\\n      end\\n    end\\n\\n    step += 1\\n  end\\n\\n  -1\\nend",
                "solutionTags": [],
                "code": "I had few runs of here-and-there small optimizations which finally brought me to the AC Solution.\\n\\nThe main idea is: check all the skip cases for the cell before adding it to the queue.\\n\\n```\\ndef cut_off_tree(forest)\\n    h = []\\n\\n    for i in 0..forest.size - 1\\n      for j in 0..forest[0].size - 1\\n        if forest[i][j] > 1\\n          h.push(forest[i][j])\\n        end\\n      end\\n    end\\n\\n    h.sort!\\n\\n    helper(forest, 0, 0, h, 0)\\nend\\n\\ndef helper(forest, istart, jstart, h, n)\\n  return if n == h.size\\n  target = h[n]\\n  q = [[istart, jstart]]\\n\\n  step = 0\\n  visited = Array.new(forest.size) { Array.new(forest[0].size, 0) }\\n  while !q.empty?\\n    q.size.times do\\n      i, j = q.shift\\n\\n      if forest[i][j] == target\\n        forest[i][j] = 1\\n        next_search = helper(forest, i, j, h, n + 1)\\n        return -1 if next_search == -1\\n        return step + next_search.to_i\\n      else\\n        if i - 1 >= 0 && forest[i - 1][j] > 0 && visited[i - 1][j] == 0\\n          q.push([i - 1, j])\\n          visited[i - 1][j] = 1\\n        end\\n        if i + 1 < forest.size && forest[i + 1][j] > 0 && visited[i + 1][j] == 0\\n          q.push([i + 1, j])\\n          visited[i + 1][j] = 1\\n        end\\n        if j - 1 >= 0 && forest[i][j - 1] > 0 && visited[i][j - 1] == 0\\n          q.push([i, j - 1])\\n          visited[i][j - 1] = 1\\n        end\\n        if j + 1 < forest[0].size && forest[i][j + 1] > 0 && visited[i][j + 1] == 0\\n          q.push([i, j + 1])\\n          visited[i][j + 1] = 1\\n        end\\n      end\\n    end\\n\\n    step += 1\\n  end\\n\\n  -1\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 735246,
                "title": "c-with-priority-queue-and-bfs",
                "content": "1. put the tree positions into a set(remeber no two trees can have the **same** height?). this set will act as a priority queue.\\n2. iterate the set and at every position run a BFS, placing the tree position as the destination.\\n\\t1. if the BFS  returns -1, there is no way we can cut off all the trees. return -1.\\n\\t2. else add the distnace to the answer.\\n\\nhere is the code:\\n```\\nclass Solution {\\nprivate:\\n    const int INF = 1061109567;\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n = forest.size() ;\\n        int m = forest[0].size() ;\\n        \\n        int ans = 0 ;\\n        \\n        set<pair<int,pair<int,int>>> points ;\\n        \\n        for(int i = 0; i<n ; i++){\\n            for(int j = 0; j<m; j++){\\n                if(forest[i][j]>1){\\n                    points.insert({forest[i][j], {i,j}}) ;\\n                }\\n            }\\n        }\\n\\t\\t\\n        int sx = 0, sy = 0 ;\\n        for(auto elem :points){\\n            int dx = elem.second.first ;\\n            int dy = elem.second.second ;\\n            int bfs_dist = bfs(forest, n, m, sx, sy, dx, dy) ;\\n            if(bfs_dist == -1) return -1 ;\\n            ans+=bfs_dist ;\\n            forest[dx][dy] = 1;\\n            sx = dx ;\\n            sy = dy ;   \\n        }\\n\\t\\t\\n        return ans ;    \\n    }\\n    \\n    int bfs(vector<vector<int>> &forest, int n, int m , int sx, int sy, int dx, int dy){\\n        int distance[n+2][m+2] ;\\n        memset(distance, 0x3f, sizeof(distance));\\n        int dirx[] = {1, 0, -1, 0} ;\\n        int diry[] = {0, 1,0, -1} ;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({sx,sy}) ;\\n        distance[sx][sy] = 0 ;\\n        \\n        while(!q.empty()){\\n            pair<int,int> p = q.front() ;\\n            q.pop() ;\\n            if(p.first == dx && p.second == dy) return distance[dx][dy] ;\\n            \\n            for(int i = 0 ;i<4 ;i++){\\n                int x = p.first + dirx[i] ;\\n                int y = p.second + diry[i] ;\\n                \\n                if(x<0 || x>=n || y <0 || y>=m)continue ;\\n                if(forest[x][y] == 0)continue ;\\n                if(distance[x][y] != INF)continue ;\\n                distance[x][y] = distance[p.first][p.second] + 1 ;\\n                q.push({x,y}) ;\\n            }   \\n            \\n        }\\n        \\n        return -1 ;     \\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int INF = 1061109567;\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n = forest.size() ;\\n        int m = forest[0].size() ;\\n        \\n        int ans = 0 ;\\n        \\n        set<pair<int,pair<int,int>>> points ;\\n        \\n        for(int i = 0; i<n ; i++){\\n            for(int j = 0; j<m; j++){\\n                if(forest[i][j]>1){\\n                    points.insert({forest[i][j], {i,j}}) ;\\n                }\\n            }\\n        }\\n\\t\\t\\n        int sx = 0, sy = 0 ;\\n        for(auto elem :points){\\n            int dx = elem.second.first ;\\n            int dy = elem.second.second ;\\n            int bfs_dist = bfs(forest, n, m, sx, sy, dx, dy) ;\\n            if(bfs_dist == -1) return -1 ;\\n            ans+=bfs_dist ;\\n            forest[dx][dy] = 1;\\n            sx = dx ;\\n            sy = dy ;   \\n        }\\n\\t\\t\\n        return ans ;    \\n    }\\n    \\n    int bfs(vector<vector<int>> &forest, int n, int m , int sx, int sy, int dx, int dy){\\n        int distance[n+2][m+2] ;\\n        memset(distance, 0x3f, sizeof(distance));\\n        int dirx[] = {1, 0, -1, 0} ;\\n        int diry[] = {0, 1,0, -1} ;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({sx,sy}) ;\\n        distance[sx][sy] = 0 ;\\n        \\n        while(!q.empty()){\\n            pair<int,int> p = q.front() ;\\n            q.pop() ;\\n            if(p.first == dx && p.second == dy) return distance[dx][dy] ;\\n            \\n            for(int i = 0 ;i<4 ;i++){\\n                int x = p.first + dirx[i] ;\\n                int y = p.second + diry[i] ;\\n                \\n                if(x<0 || x>=n || y <0 || y>=m)continue ;\\n                if(forest[x][y] == 0)continue ;\\n                if(distance[x][y] != INF)continue ;\\n                distance[x][y] = distance[p.first][p.second] + 1 ;\\n                q.push({x,y}) ;\\n            }   \\n            \\n        }\\n        \\n        return -1 ;     \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545290,
                "title": "simple-c-solution-bfs-sort",
                "content": "```\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        private void Helper((int i, int j) cellFrom, (int i, int j) cellTo, IList<IList<int>> forest, out int dist)\\n        {\\n            int n = forest.Count;\\n            int m = forest[0].Count;\\n            ISet<(int i, int j)> visited = new HashSet<(int i, int j)>();\\n            Queue<(int i, int j)> bfs = new Queue<(int i, int j)>();\\n            bfs.Enqueue(cellFrom);\\n            visited.Add(cellFrom);\\n\\n            dist = 0;\\n\\n            while (bfs.Count > 0)\\n            {\\n                int count = bfs.Count;\\n                for (int i = 0; i < count; i++)\\n                {\\n                    var node = bfs.Dequeue();\\n\\n                    if (node.i == cellTo.i && node.j == cellTo.j)\\n                    {\\n                        return;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = node.i + dir.di;\\n                        int newJ = node.j + dir.dj;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && forest[newI][newJ] != 0)\\n                        {\\n                            if(visited.Add((newI, newJ)))\\n                            {\\n                                bfs.Enqueue((newI, newJ));\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                dist++;\\n            }\\n\\n            dist = -1;\\n        }\\n\\n        public int CutOffTree(IList<IList<int>> forest)\\n        {\\n            int n = forest.Count;\\n            if (n == 0)\\n            {\\n                return 0;\\n            }\\n\\n            int m = forest[0].Count;\\n\\n\\n            List<(int i, int j, int h)> trees = new List<(int i, int j, int h)>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if(forest[i][j] != 0)\\n                    {\\n                        trees.Add((i,j,forest[i][j]));\\n                    }\\n                }\\n            }\\n\\n            trees.Sort((d1, d2) => d1.h.CompareTo(d2.h));\\n            int res = 0;\\n            (int i, int j) currCell = (0, 0);\\n\\n            for (int i = 0; i < trees.Count; i++)\\n            {\\n                Helper(currCell, (trees[i].i, trees[i].j), forest, out int dst);\\n                if (dst == -1)\\n                {\\n                    return -1;\\n                }\\n\\n                res += dst;\\n                currCell = (trees[i].i, trees[i].j);\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        private void Helper((int i, int j) cellFrom, (int i, int j) cellTo, IList<IList<int>> forest, out int dist)\\n        {\\n            int n = forest.Count;\\n            int m = forest[0].Count;\\n            ISet<(int i, int j)> visited = new HashSet<(int i, int j)>();\\n            Queue<(int i, int j)> bfs = new Queue<(int i, int j)>();\\n            bfs.Enqueue(cellFrom);\\n            visited.Add(cellFrom);\\n\\n            dist = 0;\\n\\n            while (bfs.Count > 0)\\n            {\\n                int count = bfs.Count;\\n                for (int i = 0; i < count; i++)\\n                {\\n                    var node = bfs.Dequeue();\\n\\n                    if (node.i == cellTo.i && node.j == cellTo.j)\\n                    {\\n                        return;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = node.i + dir.di;\\n                        int newJ = node.j + dir.dj;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && forest[newI][newJ] != 0)\\n                        {\\n                            if(visited.Add((newI, newJ)))\\n                            {\\n                                bfs.Enqueue((newI, newJ));\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                dist++;\\n            }\\n\\n            dist = -1;\\n        }\\n\\n        public int CutOffTree(IList<IList<int>> forest)\\n        {\\n            int n = forest.Count;\\n            if (n == 0)\\n            {\\n                return 0;\\n            }\\n\\n            int m = forest[0].Count;\\n\\n\\n            List<(int i, int j, int h)> trees = new List<(int i, int j, int h)>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if(forest[i][j] != 0)\\n                    {\\n                        trees.Add((i,j,forest[i][j]));\\n                    }\\n                }\\n            }\\n\\n            trees.Sort((d1, d2) => d1.h.CompareTo(d2.h));\\n            int res = 0;\\n            (int i, int j) currCell = (0, 0);\\n\\n            for (int i = 0; i < trees.Count; i++)\\n            {\\n                Helper(currCell, (trees[i].i, trees[i].j), forest, out int dst);\\n                if (dst == -1)\\n                {\\n                    return -1;\\n                }\\n\\n                res += dst;\\n                currCell = (trees[i].i, trees[i].j);\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341230,
                "title": "python-bfs-simple-working-solution",
                "content": "```\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        trees = []\\n\\n        for i in range(len(forest)):\\n            for j in range(len(forest[0])):\\n                if forest[i][j] > 1:\\n                    trees.append(forest[i][j])\\n\\n        trees = sorted(trees)[::-1]\\n        start = [0,0]\\n        steps = [0]\\n\\n        while trees:\\n            tree_loc = self.find_tree(trees.pop(), start[0], start[1], forest, steps)\\n            if not tree_loc:\\n                return -1\\n            else:\\n                start = tree_loc\\n\\n        return steps[0]\\n\\n    def find_tree(self, target, r, c, forest, steps):\\n        queue = [(r,c,0)]\\n        seen = set()\\n        while queue:\\n            r,c,step = queue.pop(0)\\n            if 0 <= r <= len(forest)-1 and 0 <= c <= len(forest[0]) - 1 and (r,c) not in seen and forest[r][c] >= 1:\\n                if forest[r][c] == target:\\n                    steps[0] += step\\n                    return [r,c]\\n                seen.add((r,c))\\n                queue.append((r+1,c,step+1))\\n                queue.append((r-1,c,step+1))\\n                queue.append((r,c+1,step+1))\\n                queue.append((r,c-1,step+1))\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        trees = []\\n\\n        for i in range(len(forest)):\\n            for j in range(len(forest[0])):\\n                if forest[i][j] > 1:\\n                    trees.append(forest[i][j])\\n\\n        trees = sorted(trees)[::-1]\\n        start = [0,0]\\n        steps = [0]\\n\\n        while trees:\\n            tree_loc = self.find_tree(trees.pop(), start[0], start[1], forest, steps)\\n            if not tree_loc:\\n                return -1\\n            else:\\n                start = tree_loc\\n\\n        return steps[0]\\n\\n    def find_tree(self, target, r, c, forest, steps):\\n        queue = [(r,c,0)]\\n        seen = set()\\n        while queue:\\n            r,c,step = queue.pop(0)\\n            if 0 <= r <= len(forest)-1 and 0 <= c <= len(forest[0]) - 1 and (r,c) not in seen and forest[r][c] >= 1:\\n                if forest[r][c] == target:\\n                    steps[0] += step\\n                    return [r,c]\\n                seen.add((r,c))\\n                queue.append((r+1,c,step+1))\\n                queue.append((r-1,c,step+1))\\n                queue.append((r,c+1,step+1))\\n                queue.append((r,c-1,step+1))\\n\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222302,
                "title": "python-solution-sort-bfs-o-n-2",
                "content": "```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        row, col = len(forest), len(forest[0]) \\n        def bfs(i,j, target):\\n            queue = [(i,j, 0)] \\n            move = 0 \\n            s = {(i,j)}\\n            while queue:\\n                i,j, move = queue.pop(0) \\n                if forest[i][j] == target:\\n                    return move \\n                for x,y in (i+1,j),(i,j+1),(i,j-1),(i-1,j):\\n                    if 0 <= x < row and 0 <= y < col and (x,y) not in s:\\n                        if forest[x][y]:\\n                           queue.append((x,y,move+1)) \\n                           s.add((x,y))\\n            return -1 \\n        g = sorted((forest[i][j],i,j) for i in range(row) for j in range(col) if forest[i][j] > 1)\\n        ans = 0\\n        x = y = 0\\n        while g:\\n            h,i,j = g.pop(0)\\n            move = bfs(x,y, h) \\n            if move == -1:\\n                return -1 \\n            ans += move \\n            x,y = i,j \\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def cutOffTree(self, forest):\\n        row, col = len(forest), len(forest[0]) \\n        def bfs(i,j, target):\\n            queue = [(i,j, 0)] \\n            move = 0 \\n            s = {(i,j)}",
                "codeTag": "Java"
            },
            {
                "id": 204052,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        //create a list of int[] {value, x, y}\\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(0).size(); j++) {\\n                int value = forest.get(i).get(j);\\n                if (value > 1) trees.add(new int[]{i, j, value});\\n            }\\n        }\\n        \\n        Collections.sort(trees, (a, b)->(a[2]-b[2]));\\n        int res = 0, x = 0, y = 0;\\n        for (int[] tree: trees) {\\n            int dist = bfs(forest, x, y, tree[0], tree[1]);\\n            if (dist < 0) return -1;\\n            else {\\n                res += dist;\\n                x = tree[0];\\n                y = tree[1];\\n            }\\n        }\\n        return res;\\n    }\\n    private int bfs(List<List<Integer>> forest, int x, int y, int tx, int ty) {\\n        int m = forest.size(), n = forest.get(0).size();\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{x, y});\\n        boolean[][] visited = new boolean[m][n];\\n        visited[x][y] = true;\\n        int dist = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int j = 0; j < size; j++) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == tx && cur[1] == ty) return dist;\\n                for (int i = 0; i < 4; i++) {\\n                    int nx = cur[0]+dirs[i][0];\\n                    int ny = cur[1]+dirs[i][1];\\n                    if (nx < 0 || nx >= m || ny < 0 || ny >= n || \\n                        visited[nx][ny] || forest.get(nx).get(ny) <= 0) continue;\\n                    visited[nx][ny] = true;\\n                    queue.add(new int[]{nx, ny});\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        //create a list of int[] {value, x, y}\\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(0).size(); j++) {\\n                int value = forest.get(i).get(j);\\n                if (value > 1) trees.add(new int[]{i, j, value});\\n            }\\n        }\\n        \\n        Collections.sort(trees, (a, b)->(a[2]-b[2]));\\n        int res = 0, x = 0, y = 0;\\n        for (int[] tree: trees) {\\n            int dist = bfs(forest, x, y, tree[0], tree[1]);\\n            if (dist < 0) return -1;\\n            else {\\n                res += dist;\\n                x = tree[0];\\n                y = tree[1];\\n            }\\n        }\\n        return res;\\n    }\\n    private int bfs(List<List<Integer>> forest, int x, int y, int tx, int ty) {\\n        int m = forest.size(), n = forest.get(0).size();\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{x, y});\\n        boolean[][] visited = new boolean[m][n];\\n        visited[x][y] = true;\\n        int dist = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int j = 0; j < size; j++) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == tx && cur[1] == ty) return dist;\\n                for (int i = 0; i < 4; i++) {\\n                    int nx = cur[0]+dirs[i][0];\\n                    int ny = cur[1]+dirs[i][1];\\n                    if (nx < 0 || nx >= m || ny < 0 || ny >= n || \\n                        visited[nx][ny] || forest.get(nx).get(ny) <= 0) continue;\\n                    visited[nx][ny] = true;\\n                    queue.add(new int[]{nx, ny});\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107418,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Cut Off Trees for Golf Event** https://leetcode.com/problems/cut-off-trees-for-golf-event/description/\\n\\n**BFS based solution (in Python gives TLE)**\\n* Use a priority queue to arrange all trees in ascending height order.\\n* Then simply use BFS to find the minimum steps between consecutive trees.\\n* Time complexity: O(m^2 * n^2)\\n```\\nfrom heapq import heappop, heappush\\nfrom collections import deque\\n\\nclass Solution:\\n    def build_pq(self, forest):\\n        pq = []\\n        for i in range(len(forest)):\\n            for j in range(len(forest[0])):\\n                if forest[i][j] > 1:\\n                    heappush(pq, (forest[i][j], i, j))\\n        return pq\\n    \\n    def process_level(self, forest, dq, seen, xdest, ydest):\\n        M,N = len(forest), len(forest[0])\\n        for _ in range(len(dq)):\\n            x2, y2 = dq.popleft()\\n            if x2 == xdest and y2 == ydest:\\n                return True\\n            for xn,yn in ((x2-1,y2),(x2+1,y2),(x2,y2-1),(x2,y2+1)):\\n                if 0<=xn<M and 0<=yn<N and forest[xn][yn] != 0 and (xn,yn) not in seen:\\n                    dq.append((xn,yn))\\n                    seen.add((xn,yn))\\n        return False\\n    \\n    def find_steps_bfs(self, forest, start, dest):\\n        dq = deque()\\n        dq.append((start[0], start[1]))\\n        seen = set()\\n        steps = 0\\n        while dq:\\n            found = self.process_level(forest, dq, seen, dest[0], dest[1])\\n            if found:\\n                break\\n            else:\\n                steps += 1\\n        return steps if found else -1\\n    \\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        pq = self.build_pq(forest)\\n        xstart, ystart, steps = 0, 0, 0\\n        while pq:\\n            ht, xdest, ydest = heappop(pq)\\n            curr_step = self.find_steps_bfs(forest, (xstart, ystart), (xdest, ydest))\\n            if curr_step == -1:\\n                return -1\\n            else:\\n                steps += curr_step\\n            xstart, ystart = xdest, ydest\\n        return steps    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappop, heappush\\nfrom collections import deque\\n\\nclass Solution:\\n    def build_pq(self, forest):\\n        pq = []\\n        for i in range(len(forest)):\\n            for j in range(len(forest[0])):\\n                if forest[i][j] > 1:\\n                    heappush(pq, (forest[i][j], i, j))\\n        return pq\\n    \\n    def process_level(self, forest, dq, seen, xdest, ydest):\\n        M,N = len(forest), len(forest[0])\\n        for _ in range(len(dq)):\\n            x2, y2 = dq.popleft()\\n            if x2 == xdest and y2 == ydest:\\n                return True\\n            for xn,yn in ((x2-1,y2),(x2+1,y2),(x2,y2-1),(x2,y2+1)):\\n                if 0<=xn<M and 0<=yn<N and forest[xn][yn] != 0 and (xn,yn) not in seen:\\n                    dq.append((xn,yn))\\n                    seen.add((xn,yn))\\n        return False\\n    \\n    def find_steps_bfs(self, forest, start, dest):\\n        dq = deque()\\n        dq.append((start[0], start[1]))\\n        seen = set()\\n        steps = 0\\n        while dq:\\n            found = self.process_level(forest, dq, seen, dest[0], dest[1])\\n            if found:\\n                break\\n            else:\\n                steps += 1\\n        return steps if found else -1\\n    \\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        pq = self.build_pq(forest)\\n        xstart, ystart, steps = 0, 0, 0\\n        while pq:\\n            ht, xdest, ydest = heappop(pq)\\n            curr_step = self.find_steps_bfs(forest, (xstart, ystart), (xdest, ydest))\\n            if curr_step == -1:\\n                return -1\\n            else:\\n                steps += curr_step\\n            xstart, ystart = xdest, ydest\\n        return steps    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 107427,
                "title": "c-bfs-with-optimization-86ms-beats-100",
                "content": "If you are going from (x1,y1) to (x2,y2), instead of doing 4-direction (up,down,left,right) BFS, we can first do 2-direction BFS to see if there exists a shortest path from source to destination.\\n\\ne.g. going from S(x1,y1) to T(x2,y2) we know we have to take lower-right direction, that is, either go right or down. ```'X'``` is obstacle, ```'*'``` is current layer, shortest length = 5, going step by step as follow:\\n```\\n[S, , , ]     [ ,*, , ]    [ , ,*, ]    [ , , ,*]    [ , , , ]    [ , , , ]\\n[ , ,X, ] ->  [*, ,X, ] -> [ ,*,X, ] -> [ , ,X, ] -> [ , ,X,*] -> [ , ,X, ]\\n[X, , ,T]     [X, , ,T]    [X, , , ]    [X,*, , ]    [X, ,*, ]    [X, , ,*]     \\n```\\nIf there is no shortest path available and have to make a detour, then we have to do conventional BFS.\\ne.g.\\n```\\n[ ,X, , , ]\\n[ ,S, ,X, ]\\n[ , , ,X, ] \\n[ , ,X, ,T]     \\n[X, , , , ] \\n```\\nThis is very efficient if obstacle is sparse in the forest.\\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        vector<vector<int>> trees; //vector<[height,i,j]>\\n        for(int i=0; i<forest.size(); ++i)\\n            for(int j=0; j<forest[0].size(); ++j)\\n                if(forest[i][j]>1)\\n                    trees.push_back(vector<int>({forest[i][j],i,j}));\\n        sort(trees.begin(),trees.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0]<b[0]; //sort by tree's height\\n        });\\n        \\n        //doing DFS to see if every tree is available from (0,0)\\n        int tree_available = 0;\\n        vector<vector<bool>> visited(forest.size(),vector<bool>(forest[0].size(),false));\\n        DFS(0,0,visited,forest,tree_available);\\n        if(tree_available != trees.size())   return -1; //some trees are not available from (0,0)\\n        \\n        int step = 0;\\n        int si=0, sj=0;\\n        for(int i=0; i<trees.size(); ++i){\\n            // optimization here, if there are no obstacles blocking the shortest path, return the shortest length \\n            // no need to do the 4-direction BFS\\n            if(ShortestPathAvailable(si,sj,trees[i][1],trees[i][2],forest))\\n                step += abs(si-trees[i][1])+abs(sj-trees[i][2]);\\n            else\\n                step += BFS(si,sj,trees[i][1],trees[i][2],forest);\\n            si = trees[i][1];\\n            sj = trees[i][2];\\n        }\\n        \\n        return step;\\n    }\\n    \\n    void DFS(int i, int j, vector<vector<bool>>& visited, const vector<vector<int>>& forest, int& count){\\n        if(i<0 || i>=forest.size() || j<0 || j>=forest[0].size() || visited[i][j] || forest[i][j]==0)  return;\\n        visited[i][j] = true;\\n        if(forest[i][j]>1)  count++;\\n        DFS(i+1,j,visited,forest,count);\\n        DFS(i-1,j,visited,forest,count);\\n        DFS(i,j+1,visited,forest,count);\\n        DFS(i,j-1,visited,forest,count);\\n    }\\n    \\n    //return the minimum step from (si,sj) to (ti,tj)\\n    int BFS(int si, int sj, int ti, int tj, const vector<vector<int>>& forest){\\n        vector<vector<bool>> visited(forest.size(),vector<bool>(forest[0].size(),false));\\n        visited[si][sj] = true;\\n        queue<pair<int,int>> q({make_pair(si,sj)});\\n        int len = 0;\\n        int di[4] = {1,0,-1,0};\\n        int dj[4] = {0,1,0,-1};\\n        while(true){\\n            int qsize = q.size();\\n            while(qsize--){\\n                if(q.front().first==ti && q.front().second==tj) //the function stops here\\n                    return len; \\n                for(int k=0; k<4; ++k){\\n                    int i=q.front().first+di[k];\\n                    int j=q.front().second+dj[k];\\n                    if(i>=0 && i<forest.size() && j>=0 && j<forest[0].size() && !visited[i][j] && forest[i][j]>0){\\n                        visited[i][j] = true;\\n                        q.push(make_pair(i,j));\\n                    }\\n                }\\n                q.pop();\\n            }\\n            ++len;\\n        }\\n        return -999999; //redundancy, never goes this line\\n    }\\n    \\n    // check if there exists a shortest path avail from (x1,y1) to (x2,y2) going one out of 4 directions :\\n    // upper-left , upper-right , lower-left , lower-right\\n    /*  e.g. going from S(x1,y1) to T(x2,y2), 'X' is obstacle, '*' is current layer\\n        lower-right direction, minumum step = 5, going step by step as follow\\n        [S, , , ]     [ ,*, , ]    [ , ,*, ]    [ , , ,*]    [ , , , ]    [ , , , ]\\n        [ , ,X, ] ->  [*, ,X, ] -> [ ,*,X, ] -> [ , ,X, ] -> [ , ,X,*] -> [ , ,X, ]\\n        [X, , ,T]     [X, , , ]    [X, , , ]    [X,*, , ]    [X, ,*, ]    [X, , ,*]     \\n                        step 1       step 2       step 3       step 4       step 5\\n    */\\n    bool ShortestPathAvailable(int x1, int y1, int x2, int y2, const vector<vector<int>>& forest){\\n        int dx = (x2>x1)? 1 : -1;\\n        int dy = (y2>y1)? 1 : -1;\\n        int minstep = abs(x1-x2)+abs(y1-y2);\\n        queue<pair<int,int>> q({make_pair(x1,y1)});\\n        while(minstep--){\\n            int qsize = q.size();\\n            if(qsize==0) \\n                return false; //haven't gone minstep yet, but no path available\\n            while(qsize--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x!=x2 && forest[x+dx][y]>0 && ((x+dx)!=q.back().first || y!=q.back().second))\\n                    q.push(make_pair(x+dx,y));\\n                if(y!=y2 && forest[x][y+dy]>0 && (x!=q.back().first || (y+dy)!=q.back().second))\\n                    q.push(make_pair(x,y+dy));\\n            }\\n        }\\n        return q.size()==1; //if true return, only destination [x2,y2] is in the queue\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```'X'```\n```'*'```\n```\\n[S, , , ]     [ ,*, , ]    [ , ,*, ]    [ , , ,*]    [ , , , ]    [ , , , ]\\n[ , ,X, ] ->  [*, ,X, ] -> [ ,*,X, ] -> [ , ,X, ] -> [ , ,X,*] -> [ , ,X, ]\\n[X, , ,T]     [X, , ,T]    [X, , , ]    [X,*, , ]    [X, ,*, ]    [X, , ,*]     \\n```\n```\\n[ ,X, , , ]\\n[ ,S, ,X, ]\\n[ , , ,X, ] \\n[ , ,X, ,T]     \\n[X, , , , ] \\n```\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        vector<vector<int>> trees; //vector<[height,i,j]>\\n        for(int i=0; i<forest.size(); ++i)\\n            for(int j=0; j<forest[0].size(); ++j)\\n                if(forest[i][j]>1)\\n                    trees.push_back(vector<int>({forest[i][j],i,j}));\\n        sort(trees.begin(),trees.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0]<b[0]; //sort by tree's height\\n        });\\n        \\n        //doing DFS to see if every tree is available from (0,0)\\n        int tree_available = 0;\\n        vector<vector<bool>> visited(forest.size(),vector<bool>(forest[0].size(),false));\\n        DFS(0,0,visited,forest,tree_available);\\n        if(tree_available != trees.size())   return -1; //some trees are not available from (0,0)\\n        \\n        int step = 0;\\n        int si=0, sj=0;\\n        for(int i=0; i<trees.size(); ++i){\\n            // optimization here, if there are no obstacles blocking the shortest path, return the shortest length \\n            // no need to do the 4-direction BFS\\n            if(ShortestPathAvailable(si,sj,trees[i][1],trees[i][2],forest))\\n                step += abs(si-trees[i][1])+abs(sj-trees[i][2]);\\n            else\\n                step += BFS(si,sj,trees[i][1],trees[i][2],forest);\\n            si = trees[i][1];\\n            sj = trees[i][2];\\n        }\\n        \\n        return step;\\n    }\\n    \\n    void DFS(int i, int j, vector<vector<bool>>& visited, const vector<vector<int>>& forest, int& count){\\n        if(i<0 || i>=forest.size() || j<0 || j>=forest[0].size() || visited[i][j] || forest[i][j]==0)  return;\\n        visited[i][j] = true;\\n        if(forest[i][j]>1)  count++;\\n        DFS(i+1,j,visited,forest,count);\\n        DFS(i-1,j,visited,forest,count);\\n        DFS(i,j+1,visited,forest,count);\\n        DFS(i,j-1,visited,forest,count);\\n    }\\n    \\n    //return the minimum step from (si,sj) to (ti,tj)\\n    int BFS(int si, int sj, int ti, int tj, const vector<vector<int>>& forest){\\n        vector<vector<bool>> visited(forest.size(),vector<bool>(forest[0].size(),false));\\n        visited[si][sj] = true;\\n        queue<pair<int,int>> q({make_pair(si,sj)});\\n        int len = 0;\\n        int di[4] = {1,0,-1,0};\\n        int dj[4] = {0,1,0,-1};\\n        while(true){\\n            int qsize = q.size();\\n            while(qsize--){\\n                if(q.front().first==ti && q.front().second==tj) //the function stops here\\n                    return len; \\n                for(int k=0; k<4; ++k){\\n                    int i=q.front().first+di[k];\\n                    int j=q.front().second+dj[k];\\n                    if(i>=0 && i<forest.size() && j>=0 && j<forest[0].size() && !visited[i][j] && forest[i][j]>0){\\n                        visited[i][j] = true;\\n                        q.push(make_pair(i,j));\\n                    }\\n                }\\n                q.pop();\\n            }\\n            ++len;\\n        }\\n        return -999999; //redundancy, never goes this line\\n    }\\n    \\n    // check if there exists a shortest path avail from (x1,y1) to (x2,y2) going one out of 4 directions :\\n    // upper-left , upper-right , lower-left , lower-right\\n    /*  e.g. going from S(x1,y1) to T(x2,y2), 'X' is obstacle, '*' is current layer\\n        lower-right direction, minumum step = 5, going step by step as follow\\n        [S, , , ]     [ ,*, , ]    [ , ,*, ]    [ , , ,*]    [ , , , ]    [ , , , ]\\n        [ , ,X, ] ->  [*, ,X, ] -> [ ,*,X, ] -> [ , ,X, ] -> [ , ,X,*] -> [ , ,X, ]\\n        [X, , ,T]     [X, , , ]    [X, , , ]    [X,*, , ]    [X, ,*, ]    [X, , ,*]     \\n                        step 1       step 2       step 3       step 4       step 5\\n    */\\n    bool ShortestPathAvailable(int x1, int y1, int x2, int y2, const vector<vector<int>>& forest){\\n        int dx = (x2>x1)? 1 : -1;\\n        int dy = (y2>y1)? 1 : -1;\\n        int minstep = abs(x1-x2)+abs(y1-y2);\\n        queue<pair<int,int>> q({make_pair(x1,y1)});\\n        while(minstep--){\\n            int qsize = q.size();\\n            if(qsize==0) \\n                return false; //haven't gone minstep yet, but no path available\\n            while(qsize--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x!=x2 && forest[x+dx][y]>0 && ((x+dx)!=q.back().first || y!=q.back().second))\\n                    q.push(make_pair(x+dx,y));\\n                if(y!=y2 && forest[x][y+dy]>0 && (x!=q.back().first || (y+dy)!=q.back().second))\\n                    q.push(make_pair(x,y+dy));\\n            }\\n        }\\n        return q.size()==1; //if true return, only destination [x2,y2] is in the queue\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107428,
                "title": "swift-solution-bfs",
                "content": "```\\nclass Solution {\\n    \\n    let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n    \\n    func cutOffTree(_ forest: [[Int]]) -> Int {\\n        if forest.count == 0 || forest[0].count == 0 {\\n            return -1\\n        }\\n        \\n        let m = forest.count\\n        let n = forest[0].count\\n        var result = 0\\n        var startX = 0\\n        var startY = 0\\n        var heights = [(Int, (Int, Int))]()\\n        \\n        for i in 0..<m {\\n            for j in 0..<n {\\n                if forest[i][j] > 1 {\\n                    heights .append((forest[i][j], (i, j)))\\n                }\\n            }\\n        }\\n        heights.sort { (height1: (Int, (Int, Int)), height2: (Int, (Int, Int))) -> Bool in\\n            return height1.0 < height2.0\\n        }\\n        \\n        for i in 0..<heights.count {\\n            let endX = heights[i].1.0\\n            let endY = heights[i].1.1\\n            let steps = BFS(forest, m, n, startX, startY, endX, endY)\\n            if steps == -1 {\\n                return -1\\n            }\\n            result += steps\\n            startX = endX\\n            startY = endY\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func BFS(_ forest: [[Int]], _ m: Int, _ n: Int, _ startX: Int, _ startY: Int, _ endX: Int, _ endY: Int) -> Int {\\n        if startX == endX && startY == endY {\\n            return 0\\n        }\\n        \\n        var steps = 0\\n        var queue = [(Int, Int)]()\\n        var visited = [[Bool]](repeatElement([Bool](repeatElement(false, count: n)), count: m))\\n        \\n        queue.append((startX, startY))\\n        visited[startX][startY] = true\\n        \\n        while !queue.isEmpty {\\n            let count = queue.count\\n            steps += 1\\n            for _ in 0..<count {\\n                let (x, y) = queue.removeFirst()\\n                for i in 0..<directions.count {\\n                    let nextX = x + directions[i].0\\n                    let nextY = y + directions[i].1\\n                    if nextX >= 0 && nextX < m && nextY >= 0 && nextY < n && forest[nextX][nextY] > 0 && !visited[nextX][nextY] {\\n                        if nextX == endX && nextY == endY {\\n                            return steps\\n                        }\\n                        visited[nextX][nextY] = true\\n                        queue.append((nextX, nextY))\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n    \\n    func cutOffTree(_ forest: [[Int]]) -> Int {\\n        if forest.count == 0 || forest[0].count == 0 {\\n            return -1\\n        }\\n        \\n        let m = forest.count\\n        let n = forest[0].count\\n        var result = 0\\n        var startX = 0\\n        var startY = 0\\n        var heights = [(Int, (Int, Int))]()\\n        \\n        for i in 0..<m {\\n            for j in 0..<n {\\n                if forest[i][j] > 1 {\\n                    heights .append((forest[i][j], (i, j)))\\n                }\\n            }\\n        }\\n        heights.sort { (height1: (Int, (Int, Int)), height2: (Int, (Int, Int))) -> Bool in\\n            return height1.0 < height2.0\\n        }\\n        \\n        for i in 0..<heights.count {\\n            let endX = heights[i].1.0\\n            let endY = heights[i].1.1\\n            let steps = BFS(forest, m, n, startX, startY, endX, endY)\\n            if steps == -1 {\\n                return -1\\n            }\\n            result += steps\\n            startX = endX\\n            startY = endY\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func BFS(_ forest: [[Int]], _ m: Int, _ n: Int, _ startX: Int, _ startY: Int, _ endX: Int, _ endY: Int) -> Int {\\n        if startX == endX && startY == endY {\\n            return 0\\n        }\\n        \\n        var steps = 0\\n        var queue = [(Int, Int)]()\\n        var visited = [[Bool]](repeatElement([Bool](repeatElement(false, count: n)), count: m))\\n        \\n        queue.append((startX, startY))\\n        visited[startX][startY] = true\\n        \\n        while !queue.isEmpty {\\n            let count = queue.count\\n            steps += 1\\n            for _ in 0..<count {\\n                let (x, y) = queue.removeFirst()\\n                for i in 0..<directions.count {\\n                    let nextX = x + directions[i].0\\n                    let nextY = y + directions[i].1\\n                    if nextX >= 0 && nextX < m && nextY >= 0 && nextY < n && forest[nextX][nextY] > 0 && !visited[nextX][nextY] {\\n                        if nextX == endX && nextY == endY {\\n                            return steps\\n                        }\\n                        visited[nextX][nextY] = true\\n                        queue.append((nextX, nextY))\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393765,
                "title": "python-hadlock-s-algorithm-time-complexity-o-m-n-2",
                "content": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        def dist(forest, sr, sc, tr, tc):\\n            processed = set()\\n            deque = collections.deque([(0, sr, sc)])\\n            while deque:\\n                detours, r, c = deque.popleft()\\n                if (r, c) not in processed:\\n                    processed.add((r, c))\\n                    if r == tr and c == tc:\\n                        return abs(sr-tr) + abs(sc-tc) + 2*detours\\n                    for nr, nc, closer in ((r-1, c, r > tr), (r+1, c, r < tr),\\n                                   (r, c-1, c > tc), (r, c+1, c < tc)):\\n                        if 0 <= nr < m and 0 <= nc < n and forest[nr][nc]:\\n                            if closer:\\n                                deque.appendleft((detours, nr, nc))\\n                            else:\\n                                deque.append((detours+1, nr, nc))\\n            return -1\\n        trees = []\\n        m,n = len(forest),len(forest[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append([forest[i][j],i,j])\\n        trees = sorted(trees)\\n                \\n        sr = sc = ans = 0\\n        for _, tr, tc in trees:\\n            d = dist(forest, sr, sc, tr, tc)\\n            if d < 0: return -1\\n            ans += d\\n            sr, sc = tr, tc\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        def dist(forest, sr, sc, tr, tc):\\n            processed = set()\\n            deque = collections.deque([(0, sr, sc)])\\n            while deque:\\n                detours, r, c = deque.popleft()\\n                if (r, c) not in processed:\\n                    processed.add((r, c))\\n                    if r == tr and c == tc:\\n                        return abs(sr-tr) + abs(sc-tc) + 2*detours\\n                    for nr, nc, closer in ((r-1, c, r > tr), (r+1, c, r < tr),\\n                                   (r, c-1, c > tc), (r, c+1, c < tc)):\\n                        if 0 <= nr < m and 0 <= nc < n and forest[nr][nc]:\\n                            if closer:\\n                                deque.appendleft((detours, nr, nc))\\n                            else:\\n                                deque.append((detours+1, nr, nc))\\n            return -1\\n        trees = []\\n        m,n = len(forest),len(forest[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append([forest[i][j],i,j])\\n        trees = sorted(trees)\\n                \\n        sr = sc = ans = 0\\n        for _, tr, tc in trees:\\n            d = dist(forest, sr, sc, tr, tc)\\n            if d < 0: return -1\\n            ans += d\\n            sr, sc = tr, tc\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2358864,
                "title": "pq-bfs-easy-explanation",
                "content": "To cut the shortest trees first - \\n- add all the tree with their position in a priority queue (min heap).\\n\\nTo find the min no. of steps to cut all trees starting from (0,0)\\n- Set the src to (0,0)\\n- Get position of shortest height tree, let\\'s say (x,y)\\n- BFS to find min steps to reach from (0,0) to (x,y)\\n- update src to (x,y) and repeat steps for the next shortest tree\\n\\n```\\nclass Solution {\\n    private static final int[][] DIR = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int m = forest.size(), n = forest.get(0).size();\\n        // [tree height, row, col]\\n        PriorityQueue<int[]> trees = new PriorityQueue<int[]>(\\n            (a,b) -> Integer.compare(a[0], b[0]));\\n        \\n        for(int i=0; i<m; i++) \\n            for(int j=0; j<n; j++) {\\n                int ht = forest.get(i).get(j);\\n                if( ht > 1 )\\n                    trees.offer(new int[]{ht, i, j});\\n            }\\n        \\n        int ans = 0;\\n        int currX = 0, currY = 0;\\n        \\n        while( !trees.isEmpty() ) {\\n            int i = trees.peek()[1], j = trees.poll()[2];\\n            \\n            int steps = bfs(currX, currY, i, j, forest);\\n            if( steps == -1 )\\n                return -1;\\n            ans += steps;\\n            currX = i;\\n            currY = j;\\n        }\\n        return ans;\\n    }\\n    \\n    private int bfs(int srcRow, int srcCol, int destRow, int destCol, List<List<Integer>> forest) {\\n        int m = forest.size(), n = forest.get(0).size();\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> queue = new LinkedList();\\n        int steps = 0;\\n\\n        queue.offer(new int[]{ srcRow, srcCol });\\n        visited[srcRow][srcCol] = true;\\n        \\n        while( !queue.isEmpty() ) {\\n            int size = queue.size();\\n            \\n            while( size-- > 0 ) {\\n                int i = queue.peek()[0];\\n                int j = queue.peek()[1];\\n                queue.poll();\\n                \\n                if( i == destRow && j == destCol )\\n                    return steps;\\n                \\n                for(int[] dir : DIR) {\\n                    int di = i + dir[0];\\n                    int dj = j + dir[1];\\n\\n                    if( di < 0 || dj < 0 || di == m || dj == n )\\n                        continue;\\n                    \\n                    if( visited[di][dj] || forest.get(di).get(dj) == 0 ) \\n                        continue;\\n                    \\n                    queue.offer(new int[]{di, dj});\\n                    visited[di][dj] = true;\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] DIR = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int m = forest.size(), n = forest.get(0).size();\\n        // [tree height, row, col]\\n        PriorityQueue<int[]> trees = new PriorityQueue<int[]>(\\n            (a,b) -> Integer.compare(a[0], b[0]));\\n        \\n        for(int i=0; i<m; i++) \\n            for(int j=0; j<n; j++) {\\n                int ht = forest.get(i).get(j);\\n                if( ht > 1 )\\n                    trees.offer(new int[]{ht, i, j});\\n            }\\n        \\n        int ans = 0;\\n        int currX = 0, currY = 0;\\n        \\n        while( !trees.isEmpty() ) {\\n            int i = trees.peek()[1], j = trees.poll()[2];\\n            \\n            int steps = bfs(currX, currY, i, j, forest);\\n            if( steps == -1 )\\n                return -1;\\n            ans += steps;\\n            currX = i;\\n            currY = j;\\n        }\\n        return ans;\\n    }\\n    \\n    private int bfs(int srcRow, int srcCol, int destRow, int destCol, List<List<Integer>> forest) {\\n        int m = forest.size(), n = forest.get(0).size();\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> queue = new LinkedList();\\n        int steps = 0;\\n\\n        queue.offer(new int[]{ srcRow, srcCol });\\n        visited[srcRow][srcCol] = true;\\n        \\n        while( !queue.isEmpty() ) {\\n            int size = queue.size();\\n            \\n            while( size-- > 0 ) {\\n                int i = queue.peek()[0];\\n                int j = queue.peek()[1];\\n                queue.poll();\\n                \\n                if( i == destRow && j == destCol )\\n                    return steps;\\n                \\n                for(int[] dir : DIR) {\\n                    int di = i + dir[0];\\n                    int dj = j + dir[1];\\n\\n                    if( di < 0 || dj < 0 || di == m || dj == n )\\n                        continue;\\n                    \\n                    if( visited[di][dj] || forest.get(di).get(dj) == 0 ) \\n                        continue;\\n                    \\n                    queue.offer(new int[]{di, dj});\\n                    visited[di][dj] = true;\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287937,
                "title": "modern-c-code-solution-minheap-bfs",
                "content": "```\\npublic class Solution {\\n    public int CutOffTree(IList<IList<int>> forest) {\\n        \\n        // The main idea is that we will put all the trees in minHeap in order to\\n        // cut them from lower height to higher.\\n        // Then, to find out distance between two adjacent trees we\\'ll use BFS\\n        const int BLOCK = 0;\\n        \\n        var directions = new (int dR, int dC)[] { (-1, 0), (0, 1), (1, 0), (0, -1) };\\n        \\n        int rows = forest.Count;\\n        int columns = forest[0].Count;\\n        \\n        PriorityQueue<(int row, int column), int> minHeap = new();\\n        \\n        for (int row = 0; row < rows; row++)\\n            for (int column = 0; column < columns; column++)\\n            {\\n                int height = forest[row][column];\\n                \\n                if (height > 1) minHeap.Enqueue((row, column), height);\\n            }\\n              \\n        int totalSteps = 0;\\n        (int row, int column) source = (0, 0);\\n        \\n        while (minHeap.TryDequeue(out var target, out _))\\n        {\\n            int stepsTaken = minSteps(source.row, source.column, target.row, target.column);\\n            \\n            if (stepsTaken == -1) return -1;\\n            \\n            totalSteps += stepsTaken;\\n            \\n            source = target;\\n        }\\n        \\n        return totalSteps;\\n        \\n        int minSteps(int sourceRow, int sourceColumn, int targetRow, int targetColumn)\\n        {\\n            HashSet<(int, int)> visited = new();\\n            Queue<(int, int)> queue = new();\\n            \\n            queue.Enqueue((sourceRow, sourceColumn));\\n            \\n            int steps = 0;\\n            \\n            while (queue.Count > 0)\\n            {\\n                int layerLength = queue.Count;\\n                \\n                for (int i = 0; i < layerLength; i++)\\n                {\\n                    (int row, int column) = queue.Dequeue();\\n                \\n                    if (row == targetRow && column == targetColumn) return steps;\\n                    \\n                    foreach (var direction in directions)\\n                    {\\n                        int nextRow = row + direction.dR;\\n                        int nextColumn = column + direction.dC;\\n                        \\n                        if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || \\n                            nextColumn >= columns || forest[nextRow][nextColumn] == BLOCK) continue;\\n                        \\n                        if (visited.Contains((nextRow, nextColumn))) continue;\\n                        \\n                        visited.Add((nextRow, nextColumn));\\n                        queue.Enqueue((nextRow, nextColumn));\\n                    }\\n                }\\n                \\n                steps++;\\n            }\\n            \\n            return -1;            \\n        }        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CutOffTree(IList<IList<int>> forest) {\\n        \\n        // The main idea is that we will put all the trees in minHeap in order to\\n        // cut them from lower height to higher.\\n        // Then, to find out distance between two adjacent trees we\\'ll use BFS\\n        const int BLOCK = 0;\\n        \\n        var directions = new (int dR, int dC)[] { (-1, 0), (0, 1), (1, 0), (0, -1) };\\n        \\n        int rows = forest.Count;\\n        int columns = forest[0].Count;\\n        \\n        PriorityQueue<(int row, int column), int> minHeap = new();\\n        \\n        for (int row = 0; row < rows; row++)\\n            for (int column = 0; column < columns; column++)\\n            {\\n                int height = forest[row][column];\\n                \\n                if (height > 1) minHeap.Enqueue((row, column), height);\\n            }\\n              \\n        int totalSteps = 0;\\n        (int row, int column) source = (0, 0);\\n        \\n        while (minHeap.TryDequeue(out var target, out _))\\n        {\\n            int stepsTaken = minSteps(source.row, source.column, target.row, target.column);\\n            \\n            if (stepsTaken == -1) return -1;\\n            \\n            totalSteps += stepsTaken;\\n            \\n            source = target;\\n        }\\n        \\n        return totalSteps;\\n        \\n        int minSteps(int sourceRow, int sourceColumn, int targetRow, int targetColumn)\\n        {\\n            HashSet<(int, int)> visited = new();\\n            Queue<(int, int)> queue = new();\\n            \\n            queue.Enqueue((sourceRow, sourceColumn));\\n            \\n            int steps = 0;\\n            \\n            while (queue.Count > 0)\\n            {\\n                int layerLength = queue.Count;\\n                \\n                for (int i = 0; i < layerLength; i++)\\n                {\\n                    (int row, int column) = queue.Dequeue();\\n                \\n                    if (row == targetRow && column == targetColumn) return steps;\\n                    \\n                    foreach (var direction in directions)\\n                    {\\n                        int nextRow = row + direction.dR;\\n                        int nextColumn = column + direction.dC;\\n                        \\n                        if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || \\n                            nextColumn >= columns || forest[nextRow][nextColumn] == BLOCK) continue;\\n                        \\n                        if (visited.Contains((nextRow, nextColumn))) continue;\\n                        \\n                        visited.Add((nextRow, nextColumn));\\n                        queue.Enqueue((nextRow, nextColumn));\\n                    }\\n                }\\n                \\n                steps++;\\n            }\\n            \\n            return -1;            \\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283092,
                "title": "python-solution-simplest-not-tle-bfs-graph",
                "content": "```\\nimport collections\\nfrom functools import reduce\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        graph = collections.defaultdict(list)\\n        m = len(forest)\\n        n = len(forest[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] != 0:\\n                    north = forest[i-1][j] if i-1 >= 0 and forest[i-1][j] != 0 else None\\n                    east = forest[i][j+1] if j+1 < n and forest[i][j+1] != 0 else None\\n                    south = forest[i+1][j] if i+1 < m and forest[i+1][j] != 0 else None\\n                    west = forest[i][j-1] if j-1 >= 0 and forest[i][j-1] != 0 else None\\n                    graph[forest[i][j]] = list(filter(lambda x: x != None,[north,east,south,west]))\\n        trees = []\\n        for i in forest: trees.extend(filter(lambda x: x != 0 and x!= 1, i))\\n        trees.sort()\\n        moves = 0\\n        initial_point = forest[0][0]\\n        for i in trees:\\n            tmp_move = self.min_dist(initial_point,i,graph)\\n            if tmp_move == None:\\n                return -1\\n            moves += tmp_move\\n            initial_point = i\\n        return moves\\n    \\n    def min_dist(self,begin:int,target:int,graph:dict[int,list]) -> int:\\n        visited = set()\\n        stack = collections.deque([])\\n        visited.add(begin)\\n        distance = {}\\n        for d in graph.keys() : distance[d] = None\\n        distance[begin] = 0\\n        stack.append(begin)\\n        while len(stack) > 0:\\n            t = stack.popleft()\\n            if t == target:\\n                return distance[t]\\n            for i in graph[t]:\\n                if i not in visited:\\n                    visited.add(i)\\n                    stack.append(i)\\n                    distance[i] = distance[t] + 1\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nfrom functools import reduce\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        graph = collections.defaultdict(list)\\n        m = len(forest)\\n        n = len(forest[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] != 0:\\n                    north = forest[i-1][j] if i-1 >= 0 and forest[i-1][j] != 0 else None\\n                    east = forest[i][j+1] if j+1 < n and forest[i][j+1] != 0 else None\\n                    south = forest[i+1][j] if i+1 < m and forest[i+1][j] != 0 else None\\n                    west = forest[i][j-1] if j-1 >= 0 and forest[i][j-1] != 0 else None\\n                    graph[forest[i][j]] = list(filter(lambda x: x != None,[north,east,south,west]))\\n        trees = []\\n        for i in forest: trees.extend(filter(lambda x: x != 0 and x!= 1, i))\\n        trees.sort()\\n        moves = 0\\n        initial_point = forest[0][0]\\n        for i in trees:\\n            tmp_move = self.min_dist(initial_point,i,graph)\\n            if tmp_move == None:\\n                return -1\\n            moves += tmp_move\\n            initial_point = i\\n        return moves\\n    \\n    def min_dist(self,begin:int,target:int,graph:dict[int,list]) -> int:\\n        visited = set()\\n        stack = collections.deque([])\\n        visited.add(begin)\\n        distance = {}\\n        for d in graph.keys() : distance[d] = None\\n        distance[begin] = 0\\n        stack.append(begin)\\n        while len(stack) > 0:\\n            t = stack.popleft()\\n            if t == target:\\n                return distance[t]\\n            for i in graph[t]:\\n                if i not in visited:\\n                    visited.add(i)\\n                    stack.append(i)\\n                    distance[i] = distance[t] + 1\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228136,
                "title": "bfs-heights-of-trees-in-sorted-order",
                "content": "\\tclass Solution:\\n\\t\\tdef bfs(self,v,i,j,n,m,forest):\\n\\t\\t\\tvis=set([i,j])\\n\\t\\t\\tq=deque([[i,j,0]])\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tx,y,d=q.pop()\\n\\t\\t\\t\\tif forest[x][y]==v:\\n\\t\\t\\t\\t\\treturn x,y,d\\n\\t\\t\\t\\tfor i,j in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:\\n\\t\\t\\t\\t\\tif 0<=i<n and 0<=j<m and not (i,j) in vis and forest[i][j]:\\n\\t\\t\\t\\t\\t\\tvis.add((i,j))\\n\\t\\t\\t\\t\\t\\tq.appendleft([i,j,d+1])\\n\\t\\t\\treturn -1,-1,-1\\n\\n\\t\\tdef cutOffTree(self, forest: List[List[int]]) -> int:\\n\\t\\t\\torder=[]\\n\\t\\t\\tn,m=len(forest),len(forest[0])\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif forest[i][j]>1:\\n\\t\\t\\t\\t\\t\\torder.append(forest[i][j])\\n\\t\\t\\torder.sort()\\n\\t\\t\\tres,x,y=0,0,0\\n\\t\\t\\tfor num in order:\\n\\t\\t\\t\\tx,y,d=self.bfs(num,x,y,n,m,forest)\\n\\t\\t\\t\\tif d==-1:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres+=d\\n\\t\\t\\treturn res\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef bfs(self,v,i,j,n,m,forest):\\n\\t\\t\\tvis=set([i,j])\\n\\t\\t\\tq=deque([[i,j,0]])\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tx,y,d=q.pop()\\n\\t\\t\\t\\tif forest[x][y]==v:\\n\\t\\t\\t\\t\\treturn x,y,d\\n\\t\\t\\t\\tfor i,j in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:\\n\\t\\t\\t\\t\\tif 0<=i<n and 0<=j<m and not (i,j) in vis and forest[i][j]:\\n\\t\\t\\t\\t\\t\\tvis.add((i,j))\\n\\t\\t\\t\\t\\t\\tq.appendleft([i,j,d+1])\\n\\t\\t\\treturn -1,-1,-1\\n\\n\\t\\tdef cutOffTree(self, forest: List[List[int]]) -> int:\\n\\t\\t\\torder=[]\\n\\t\\t\\tn,m=len(forest),len(forest[0])\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif forest[i][j]>1:\\n\\t\\t\\t\\t\\t\\torder.append(forest[i][j])\\n\\t\\t\\torder.sort()\\n\\t\\t\\tres,x,y=0,0,0\\n\\t\\t\\tfor num in order:\\n\\t\\t\\t\\tx,y,d=self.bfs(num,x,y,n,m,forest)\\n\\t\\t\\t\\tif d==-1:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres+=d\\n\\t\\t\\treturn res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2219946,
                "title": "c-simple-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int, int> hash;\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    int n, m;\\n    int cutOffTree(vector<vector<int>>& f) {\\n        n = f.size(), m = f[0].size();\\n        int cur = 0, result = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(f[i][j] > 1)\\n                    hash[f[i][j]] = i * m + j;\\n        \\n        for(auto& a: hash){\\n            int steps = helper(f, cur, a.second);\\n            if(steps == -1e9) return -1;\\n            result += steps;\\n            cur = a.second;\\n        }\\n        return result;\\n    }\\n    \\n    int helper(vector<vector<int>>& f, int cur, int target){\\n        queue<int> q;\\n        int steps = 0;\\n        q.push({cur});\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int pos = q.front(), r = pos / m, c = pos % m;\\n                q.pop();\\n                if(pos == target)\\n                    return steps;\\n                for(int k = 0; k < 4; k++){\\n                    int nr = r + DIR[k], nc = c + DIR[k + 1];\\n                    if(nr < 0 || nr == n || nc < 0 || nc == m || vis[nr][nc] || !f[nr][nc])\\n                        continue;\\n                    q.push({nr * m + nc});\\n                    vis[nr][nc] = true;\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1e9;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> hash;\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    int n, m;\\n    int cutOffTree(vector<vector<int>>& f) {\\n        n = f.size(), m = f[0].size();\\n        int cur = 0, result = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(f[i][j] > 1)\\n                    hash[f[i][j]] = i * m + j;\\n        \\n        for(auto& a: hash){\\n            int steps = helper(f, cur, a.second);\\n            if(steps == -1e9) return -1;\\n            result += steps;\\n            cur = a.second;\\n        }\\n        return result;\\n    }\\n    \\n    int helper(vector<vector<int>>& f, int cur, int target){\\n        queue<int> q;\\n        int steps = 0;\\n        q.push({cur});\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int pos = q.front(), r = pos / m, c = pos % m;\\n                q.pop();\\n                if(pos == target)\\n                    return steps;\\n                for(int k = 0; k < 4; k++){\\n                    int nr = r + DIR[k], nc = c + DIR[k + 1];\\n                    if(nr < 0 || nr == n || nc < 0 || nc == m || vis[nr][nc] || !f[nr][nc])\\n                        continue;\\n                    q.push({nr * m + nc});\\n                    vis[nr][nc] = true;\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1e9;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180214,
                "title": "java-simple-and-fast-with-explanation-and-comments",
                "content": "# Overview\\n\\nMy solution uses a BFS algorithm to find the distance between 2 any trees and then creates a path from the origin to the final tree by going via all the trees in the correct order.\\n\\n---\\n\\n# Step by Step\\n1. Find all trees (all heights > 1 in the forest) and store in a list for sorting (with the height cached in the int[])\\n2. Starting from (0, 0) get the distance between our current postion and the next tree (T1)\\n3. Set current position to be the tree T1, and then repeat\\n4. If any distance is -1, that means we can\\'t find a valid path so we should return -1;\\n5. Sum all paths together and return the result\\n\\n---\\n# The Code\\n\\n```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        List<int[]> trees = new ArrayList();\\n        \\n\\t\\t// Find all trees\\n        for(int i = 0; i < forest.size(); i++)\\n            for(int j = 0; j < forest.get(0).size(); j++)\\n                if (forest.get(i).get(j) > 1)\\n                    trees.add(new int[]{i, j, forest.get(i).get(j)});\\n        \\n\\t\\t// Sort trees based on height\\n        trees.sort((a, b) -> Integer.compare(a[2], b[2]));\\n        \\n        int dist = 0;\\n        \\n\\t\\t// Set current postion to be the origin\\n        int[] currPos = new int[]{0, 0};\\n        \\n        for(int[] tree : trees) {\\n            int d = getDist(forest, currPos, tree);\\n\\t\\t\\t// If we cannot find a path, return -1\\n            if (d == -1) return -1;\\n            dist+= d;\\n\\t\\t\\t// Set current position to be this tree\\n            currPos= tree;\\n        }\\n        \\n        return dist;\\n    }\\n    \\n\\t// Standard Breadth First Search algorithm\\n    private int getDist(List<List<Integer>> forest, int[] aPos, int[] bPos) {\\n        int aR = aPos[0];\\n        int aC = aPos[1];\\n        int bR = bPos[0];\\n        int bC = bPos[1];\\n        \\n        boolean[][] seen = new boolean[forest.size()][forest.get(0).size()];\\n        \\n        Queue<int[]> q = new LinkedList();\\n        q.offer(new int[]{aR, aC});\\n        \\n        int steps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            \\n\\t\\t\\t// Search through all positions in queue in 1 step\\n            for(int i = 0; i < size; i++) {\\n                int[] pos = q.poll();\\n                int r = pos[0];\\n                int c = pos[1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If we have found target, return steps\\n                if (r == bR && c == bC) return steps;\\n                \\n\\t\\t\\t\\t// validate position\\n                if (r < 0 || r >= forest.size() || c < 0 || c >= forest.get(0).size()) continue;\\n                if (seen[r][c]) continue;\\n                if (forest.get(r).get(c) == 0) continue;\\n                \\n                seen[r][c] = true;\\n                \\n\\t\\t\\t\\t// Expand into 4 directions\\n                q.offer(new int[]{r+1, c});\\n                q.offer(new int[]{r-1, c});\\n                q.offer(new int[]{r, c+1});\\n                q.offer(new int[]{r, c-1});\\n            }\\n            \\n            steps++;\\n        }\\n        \\n\\t\\t// If we haven\\'t found target and no more positions to check, return -1\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        List<int[]> trees = new ArrayList();\\n        \\n\\t\\t// Find all trees\\n        for(int i = 0; i < forest.size(); i++)\\n            for(int j = 0; j < forest.get(0).size(); j++)\\n                if (forest.get(i).get(j) > 1)\\n                    trees.add(new int[]{i, j, forest.get(i).get(j)});\\n        \\n\\t\\t// Sort trees based on height\\n        trees.sort((a, b) -> Integer.compare(a[2], b[2]));\\n        \\n        int dist = 0;\\n        \\n\\t\\t// Set current postion to be the origin\\n        int[] currPos = new int[]{0, 0};\\n        \\n        for(int[] tree : trees) {\\n            int d = getDist(forest, currPos, tree);\\n\\t\\t\\t// If we cannot find a path, return -1\\n            if (d == -1) return -1;\\n            dist+= d;\\n\\t\\t\\t// Set current position to be this tree\\n            currPos= tree;\\n        }\\n        \\n        return dist;\\n    }\\n    \\n\\t// Standard Breadth First Search algorithm\\n    private int getDist(List<List<Integer>> forest, int[] aPos, int[] bPos) {\\n        int aR = aPos[0];\\n        int aC = aPos[1];\\n        int bR = bPos[0];\\n        int bC = bPos[1];\\n        \\n        boolean[][] seen = new boolean[forest.size()][forest.get(0).size()];\\n        \\n        Queue<int[]> q = new LinkedList();\\n        q.offer(new int[]{aR, aC});\\n        \\n        int steps = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            \\n\\t\\t\\t// Search through all positions in queue in 1 step\\n            for(int i = 0; i < size; i++) {\\n                int[] pos = q.poll();\\n                int r = pos[0];\\n                int c = pos[1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If we have found target, return steps\\n                if (r == bR && c == bC) return steps;\\n                \\n\\t\\t\\t\\t// validate position\\n                if (r < 0 || r >= forest.size() || c < 0 || c >= forest.get(0).size()) continue;\\n                if (seen[r][c]) continue;\\n                if (forest.get(r).get(c) == 0) continue;\\n                \\n                seen[r][c] = true;\\n                \\n\\t\\t\\t\\t// Expand into 4 directions\\n                q.offer(new int[]{r+1, c});\\n                q.offer(new int[]{r-1, c});\\n                q.offer(new int[]{r, c+1});\\n                q.offer(new int[]{r, c-1});\\n            }\\n            \\n            steps++;\\n        }\\n        \\n\\t\\t// If we haven\\'t found target and no more positions to check, return -1\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137208,
                "title": "bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& f) {\\n        vector<int> trees;\\n        for (auto& v : f) {\\n            for (int x : v) {\\n                if (x > 1)\\n                    trees.push_back(x);\\n            }\\n        }\\n        sort(trees.begin(), trees.end());\\n        int treecounter = 0;\\n        int visited[51][51] = { 0 };\\n        queue<tuple<int, int, int>> q;\\n        q.push({0, 0, trees[0]});\\n        vector<vector<int>> dirs = {{-1 , 0}, {0, -1}, {1, 0}, {0, 1}};\\n        int steps = 0;\\n        while (q.size()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto[x, y, t] = q.front();\\n                q.pop();\\n                // Discontinue this search as the corresponding\\n                // tree is no more\\n                if (trees[treecounter] != t)\\n                    continue;\\n                // Found tree; cut tree\\n                if (f[x][y] == t) {\\n                    f[x][y] = 1;\\n                    treecounter++;\\n                    if (treecounter == trees.size())\\n                        return steps;\\n                    // Next tree to target\\n                    t = trees[treecounter];\\n                }\\n                for (auto& d : dirs) {\\n                    int nx = x + d[0];\\n                    int ny = y + d[1];\\n                    if (nx < 0 || ny < 0 || nx == f.size() || ny == f[0].size())\\n                        continue;\\n                    if (f[nx][ny] == 0)\\n                        continue;\\n                    // If we\\'ve been here before looking for the same tree\\n                    if (visited[nx][ny] == t)\\n                        continue;\\n                    visited[nx][ny] = t;\\n                    q.push({nx, ny, t});\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& f) {\\n        vector<int> trees;\\n        for (auto& v : f) {\\n            for (int x : v) {\\n                if (x > 1)\\n                    trees.push_back(x);\\n            }\\n        }\\n        sort(trees.begin(), trees.end());\\n        int treecounter = 0;\\n        int visited[51][51] = { 0 };\\n        queue<tuple<int, int, int>> q;\\n        q.push({0, 0, trees[0]});\\n        vector<vector<int>> dirs = {{-1 , 0}, {0, -1}, {1, 0}, {0, 1}};\\n        int steps = 0;\\n        while (q.size()) {\\n            int size = q.size();\\n            while (size--) {\\n                auto[x, y, t] = q.front();\\n                q.pop();\\n                // Discontinue this search as the corresponding\\n                // tree is no more\\n                if (trees[treecounter] != t)\\n                    continue;\\n                // Found tree; cut tree\\n                if (f[x][y] == t) {\\n                    f[x][y] = 1;\\n                    treecounter++;\\n                    if (treecounter == trees.size())\\n                        return steps;\\n                    // Next tree to target\\n                    t = trees[treecounter];\\n                }\\n                for (auto& d : dirs) {\\n                    int nx = x + d[0];\\n                    int ny = y + d[1];\\n                    if (nx < 0 || ny < 0 || nx == f.size() || ny == f[0].size())\\n                        continue;\\n                    if (f[nx][ny] == 0)\\n                        continue;\\n                    // If we\\'ve been here before looking for the same tree\\n                    if (visited[nx][ny] == t)\\n                        continue;\\n                    visited[nx][ny] = t;\\n                    q.push({nx, ny, t});\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087563,
                "title": "java-priority-queue-bfs",
                "content": "```\\npublic int shortestPathBfs(int[] start, int[] end, List<List<Integer>> forest) {\\n        int n = forest.size();\\n        int m = forest.get(0).size();\\n        boolean[][] visited = new boolean[n][m];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                visited[i][j] = false;\\n            }\\n        }\\n\\n        int[][] matrixTraversal = {{0,-1}, {-1, 0}, {0, 1}, {1, 0}};\\n        Queue<int[]> bfs = new LinkedList<>();\\n        bfs.add(new int[]{start[0], start[1], 0});\\n        visited[start[0]][start[1]] = true;\\n\\n        while(!bfs.isEmpty()) {\\n            int[] tree = bfs.poll();\\n            if(tree[0] == end[0] && tree[1] == end[1]) {\\n                return tree[2];\\n            }\\n\\n            /*\\n                marking visited as true in loop only as we will be reaching the node in the shortest distance in first visit itself.\\n             */\\n            for(int i = 0; i<4; i++) {\\n                int x = tree[0] + matrixTraversal[i][0];\\n                int y = tree[1] + matrixTraversal[i][1];\\n                if(x >=0 && y >=0 && x<n && y<m && forest.get(x).get(y)!=0 && !visited[x][y]) {\\n                    bfs.add(new int[]{x, y, tree[2] + 1});\\n                    visited[x][y] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int n = forest.size();\\n        int m = forest.get(0).size();\\n        PriorityQueue<int[]> trees = new PriorityQueue<>((a,b) -> {\\n            if(a[2] > b[2]) {\\n                return 1;\\n            }\\n            return -1;\\n        });\\n\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                if(forest.get(i).get(j) > 1) {\\n                    trees.add(new int[]{i, j, forest.get(i).get(j)});\\n                }\\n            }\\n        }\\n\\n        int[] start = new int[]{0, 0, forest.get(0).get(0)};\\n        int totalSteps = 0;\\n        while(!trees.isEmpty()) {\\n            int[] end = trees.poll();\\n            int steps = shortestPathBfs(start, end, forest);\\n            if(steps == -1) {\\n                return -1;\\n            }\\n            totalSteps += steps;\\n\\n            start[0] = end[0];\\n            start[1] = end[1];\\n        }\\n\\n        return totalSteps;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int shortestPathBfs(int[] start, int[] end, List<List<Integer>> forest) {\\n        int n = forest.size();\\n        int m = forest.get(0).size();\\n        boolean[][] visited = new boolean[n][m];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                visited[i][j] = false;\\n            }\\n        }\\n\\n        int[][] matrixTraversal = {{0,-1}, {-1, 0}, {0, 1}, {1, 0}};\\n        Queue<int[]> bfs = new LinkedList<>();\\n        bfs.add(new int[]{start[0], start[1], 0});\\n        visited[start[0]][start[1]] = true;\\n\\n        while(!bfs.isEmpty()) {\\n            int[] tree = bfs.poll();\\n            if(tree[0] == end[0] && tree[1] == end[1]) {\\n                return tree[2];\\n            }\\n\\n            /*\\n                marking visited as true in loop only as we will be reaching the node in the shortest distance in first visit itself.\\n             */\\n            for(int i = 0; i<4; i++) {\\n                int x = tree[0] + matrixTraversal[i][0];\\n                int y = tree[1] + matrixTraversal[i][1];\\n                if(x >=0 && y >=0 && x<n && y<m && forest.get(x).get(y)!=0 && !visited[x][y]) {\\n                    bfs.add(new int[]{x, y, tree[2] + 1});\\n                    visited[x][y] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int n = forest.size();\\n        int m = forest.get(0).size();\\n        PriorityQueue<int[]> trees = new PriorityQueue<>((a,b) -> {\\n            if(a[2] > b[2]) {\\n                return 1;\\n            }\\n            return -1;\\n        });\\n\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                if(forest.get(i).get(j) > 1) {\\n                    trees.add(new int[]{i, j, forest.get(i).get(j)});\\n                }\\n            }\\n        }\\n\\n        int[] start = new int[]{0, 0, forest.get(0).get(0)};\\n        int totalSteps = 0;\\n        while(!trees.isEmpty()) {\\n            int[] end = trees.poll();\\n            int steps = shortestPathBfs(start, end, forest);\\n            if(steps == -1) {\\n                return -1;\\n            }\\n            totalSteps += steps;\\n\\n            start[0] = end[0];\\n            start[1] = end[1];\\n        }\\n\\n        return totalSteps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082155,
                "title": "confuse-about-the-this-test-case-can-anyone-help-me",
                "content": "let\\'s see this test case\\n```\\n[\\n[10,2,3],\\n[0,0,4],\\n[7,6,5]]\\n```\\n\\nI run the code and the expected output would be 12 from Leetcode, I thought it would be -1 since from 0,0 it cannot go to anywhere.\\n\\nHow do we explain this test case?",
                "solutionTags": [],
                "code": "```\\n[\\n[10,2,3],\\n[0,0,4],\\n[7,6,5]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861059,
                "title": "python-bfs-minheap",
                "content": "```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def bfs(i, j, destx, desty):\\n            q = deque()\\n            visited = set()\\n            q.append((i, j, 0))\\n            while q:\\n                x, y, step = q.popleft()\\n                if x == destx and y == desty:\\n                    return step\\n                for dirx, diry in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                    curx, cury = dirx + x, diry + y\\n                    \\n                    if 0 <= curx < m and 0 <= cury < n and forest[curx][cury] != 0 and (curx, cury) not in visited:\\n                        q.append((curx, cury, step + 1))\\n                        visited.add((curx, cury))\\n            return -1\\n                \\n        \\n        m, n = len(forest), len(forest[0])\\n        \\n        heap = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(heap, (forest[i][j], i, j))\\n        \\n        res = 0\\n        i, j = 0, 0\\n        while heap:\\n            _, destx, desty = heapq.heappop(heap)\\n            step = bfs(i, j, destx, desty)\\n            # print i, j, destx, desty, step\\n            if step < 0:\\n                return -1\\n            res += step\\n            i, j = destx, desty\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def bfs(i, j, destx, desty):\\n            q = deque()\\n            visited = set()\\n            q.append((i, j, 0))\\n            while q:\\n                x, y, step = q.popleft()\\n                if x == destx and y == desty:\\n                    return step\\n                for dirx, diry in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                    curx, cury = dirx + x, diry + y\\n                    \\n                    if 0 <= curx < m and 0 <= cury < n and forest[curx][cury] != 0 and (curx, cury) not in visited:\\n                        q.append((curx, cury, step + 1))\\n                        visited.add((curx, cury))\\n            return -1\\n                \\n        \\n        m, n = len(forest), len(forest[0])\\n        \\n        heap = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(heap, (forest[i][j], i, j))\\n        \\n        res = 0\\n        i, j = 0, 0\\n        while heap:\\n            _, destx, desty = heapq.heappop(heap)\\n            step = bfs(i, j, destx, desty)\\n            # print i, j, destx, desty, step\\n            if step < 0:\\n                return -1\\n            res += step\\n            i, j = destx, desty\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750189,
                "title": "python-use-collections-deque-instead-of-queue-queue-no-tle-bfs-priorityqueue",
                "content": "Runtime: 5734 ms, faster than 79.53% of Python3 online submissions for Cut Off Trees for Golf Event.\\nMemory Usage: 14.4 MB, less than 96.34% of Python3 online submissions for Cut Off Trees for Golf Event.\\n\\nI was using queue.Queue() and got TLE, replaced that with collections.deque and reduced time from TLE to 2000 ms\\n```\\nfrom queue import Queue\\nclass Solution:\\n    # returns sorted trees by height\\n    def get_priority(self, forest):\\n        m, n = len(forest), len(forest[0])\\n        priority = []\\n        for r in range(m):\\n            for c in range(n):\\n                v = forest[r][c]\\n                if v > 1:\\n                    priority.append((v)) \\n        priority.sort()\\n        return priority\\n        \\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        n = len(forest)\\n        m = len(forest[0])\\n        priority = self.get_priority(forest)\\n        steps = 0\\n        \\n        i,j = 0, 0\\n\\t\\t# next tree in line\\n        for node in priority:\\n            to_find =node \\n            visited = [[0]*m for _ in range(n)]\\n            q = collections.deque([(i, j, steps)])\\n            q.append((i,j, steps))\\n            found = False # if found is False that means blocked by 0s\\n            while q:\\n                i, j, steps = q.popleft()\\n                if forest[i][j] == to_find: # Tree found so move to next tree\\n                    found = True\\n                    break\\n                \\n                if forest[i][j] == 0: # Skip 0s\\n                    continue\\n                if i + 1 < n and forest[i+1][j] !=0 and not visited[i+1][j]:\\n                    q.append((i+1, j, steps+1))\\n                    visited[i+1][j]= 1\\n                if i - 1 >= 0 and forest[i-1][j] !=0 and  not visited[i-1][j]:\\n                    q.append((i-1, j, steps+1))\\n                    visited[i-1][j]= 1\\n                if j + 1 < m and forest[i][j+1] !=0 and not  visited[i][j+1]:\\n                    q.append((i, j + 1, steps+1))\\n                    visited[i][j+1]= 1\\n                if j - 1 >= 0 and forest[i][j-1] !=0 and not visited[i][j-1]:\\n                    q.append((i, j-1, steps+1))\\n                    visited[i][j-1]= 1\\n            \\n            if not found: return -1\\n        return steps \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    # returns sorted trees by height\\n    def get_priority(self, forest):\\n        m, n = len(forest), len(forest[0])\\n        priority = []\\n        for r in range(m):\\n            for c in range(n):\\n                v = forest[r][c]\\n                if v > 1:\\n                    priority.append((v)) \\n        priority.sort()\\n        return priority\\n        \\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        n = len(forest)\\n        m = len(forest[0])\\n        priority = self.get_priority(forest)\\n        steps = 0\\n        \\n        i,j = 0, 0\\n\\t\\t# next tree in line\\n        for node in priority:\\n            to_find =node \\n            visited = [[0]*m for _ in range(n)]\\n            q = collections.deque([(i, j, steps)])\\n            q.append((i,j, steps))\\n            found = False # if found is False that means blocked by 0s\\n            while q:\\n                i, j, steps = q.popleft()\\n                if forest[i][j] == to_find: # Tree found so move to next tree\\n                    found = True\\n                    break\\n                \\n                if forest[i][j] == 0: # Skip 0s\\n                    continue\\n                if i + 1 < n and forest[i+1][j] !=0 and not visited[i+1][j]:\\n                    q.append((i+1, j, steps+1))\\n                    visited[i+1][j]= 1\\n                if i - 1 >= 0 and forest[i-1][j] !=0 and  not visited[i-1][j]:\\n                    q.append((i-1, j, steps+1))\\n                    visited[i-1][j]= 1\\n                if j + 1 < m and forest[i][j+1] !=0 and not  visited[i][j+1]:\\n                    q.append((i, j + 1, steps+1))\\n                    visited[i][j+1]= 1\\n                if j - 1 >= 0 and forest[i][j-1] !=0 and not visited[i][j-1]:\\n                    q.append((i, j-1, steps+1))\\n                    visited[i][j-1]= 1\\n            \\n            if not found: return -1\\n        return steps \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707085,
                "title": "very-clean-java-bfs-solution",
                "content": "BFS is used to find shortest path between src and destination, and PriorityQueue is used to find destinations..\\n\\'\\'\\'\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n       int n = forest.size();\\n       int m = forest.get(0).size();\\n       int dir[][]= {{1,0},{0,1},{-1,0},{0,-1}}; \\n       \\n       PriorityQueue<Integer> minheap =new PriorityQueue<>(); \\n        \\n       for(List<Integer> al  : forest)  for(int val : al) if(val>1)  minheap.add(val);\\n       \\n       int result=0;\\n       int [] src={0,0}; \\n        \\n        while(minheap.size()>0)\\n        {\\n            boolean vis [][] =new boolean[n][m];\\n            \\n            Queue<int[]> q =new LinkedList<>();\\n              \\n            q.add(new int[]{src[0],src[1],0});\\n            int target = minheap.remove(),ans=-1;    \\n      \\n            while(!q.isEmpty())\\n            {\\n               int a [] = q.remove();    \\n                \\n               if(vis[a[0]][a[1]]) continue; \\n               vis[a[0]][a[1]] =true;\\n                \\n               //check for target\\n                if(forest.get(a[0]).get(a[1])==target) \\n                {\\n                  src[0]=a[0];   \\n                  src[1]=a[1];\\n                  ans = a[2];  \\n                  break;    \\n                }\\n                \\n               for(int b[] : dir)\\n               {\\n                   int r=a[0]+b[0];\\n                   int c =a[1]+b[1];\\n                   \\n                   if(r<0 || r>=n || c<0 || c>=m || vis[r][c] || forest.get(r).get(c)==0) continue;\\n                   \\n                     q.add(new int[]{r,c,a[2]+1});\\n               } \\n                \\n            }\\n            \\n            if(ans==-1) return -1;\\n            \\n            result+=ans; \\n        }\\n   \\n        return result;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "BFS is used to find shortest path between src and destination, and PriorityQueue is used to find destinations..\\n\\'\\'\\'\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n       int n = forest.size();\\n       int m = forest.get(0).size();\\n       int dir[][]= {{1,0},{0,1},{-1,0},{0,-1}}; \\n       \\n       PriorityQueue<Integer> minheap =new PriorityQueue<>(); \\n        \\n       for(List<Integer> al  : forest)  for(int val : al) if(val>1)  minheap.add(val);\\n       \\n       int result=0;\\n       int [] src={0,0}; \\n        \\n        while(minheap.size()>0)\\n        {\\n            boolean vis [][] =new boolean[n][m];\\n            \\n            Queue<int[]> q =new LinkedList<>();\\n              \\n            q.add(new int[]{src[0],src[1],0});\\n            int target = minheap.remove(),ans=-1;    \\n      \\n            while(!q.isEmpty())\\n            {\\n               int a [] = q.remove();    \\n                \\n               if(vis[a[0]][a[1]]) continue; \\n               vis[a[0]][a[1]] =true;\\n                \\n               //check for target\\n                if(forest.get(a[0]).get(a[1])==target) \\n                {\\n                  src[0]=a[0];   \\n                  src[1]=a[1];\\n                  ans = a[2];  \\n                  break;    \\n                }\\n                \\n               for(int b[] : dir)\\n               {\\n                   int r=a[0]+b[0];\\n                   int c =a[1]+b[1];\\n                   \\n                   if(r<0 || r>=n || c<0 || c>=m || vis[r][c] || forest.get(r).get(c)==0) continue;\\n                   \\n                     q.add(new int[]{r,c,a[2]+1});\\n               } \\n                \\n            }\\n            \\n            if(ans==-1) return -1;\\n            \\n            result+=ans; \\n        }\\n   \\n        return result;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1673037,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>&mat)\\n    {\\n        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<long long>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]>1)\\n                {\\n                    v.push_back({i,j,mat[i][j]});\\n                }\\n            }\\n        }\\n        auto bfs=[&](int st1,int st2,int ds1,int ds2)\\n        {\\n            queue<pair<int,int>>q;\\n            q.push({st1,st2});\\n            int level=0;\\n            vector<vector<bool>>vis(n+2,vector<bool>(m+2,false));\\n            vis[st1][st2]=true;\\n            while(q.size())\\n            {\\n                int size=q.size();\\n                for(int i=0;i<size;i++)\\n                {\\n                    auto temp=q.front();\\n                    q.pop();\\n                    long long x=temp.first;\\n                    long long y=temp.second;\\n                    if(x==ds1&&y==ds2)\\n                    {\\n                        return level;\\n                    }\\n                    for(auto &it:d)\\n                    {\\n                        long long nx=x+it.first;\\n                        long long ny=y+it.second;\\n                        if(nx>=0&&ny>=0&&nx<n&&ny<m&&mat[nx][ny]>=1&&vis[nx][ny]==false)\\n                        {\\n                            q.push({nx,ny});\\n                            vis[nx][ny]=true;\\n                        }\\n                    }\\n                }\\n                level++;\\n            }\\n            return -1;\\n        };\\n        sort(v.begin(),v.end(),[&](auto &v1,auto &v2){return v1[2]<v2[2];});\\n        long long st1=0;\\n        long long st2=0;\\n        long long count=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            long long ds1=v[i][0];\\n            long long ds2=v[i][1];\\n            long long step=bfs(st1,st2,ds1,ds2);\\n            if(step<0)\\n            {\\n                return -1;\\n            }\\n            count+=step;\\n            st1=ds1;\\n            st2=ds2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>&mat)\\n    {\\n        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<long long>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]>1)\\n                {\\n                    v.push_back({i,j,mat[i][j]});\\n                }\\n            }\\n        }\\n        auto bfs=[&](int st1,int st2,int ds1,int ds2)\\n        {\\n            queue<pair<int,int>>q;\\n            q.push({st1,st2});\\n            int level=0;\\n            vector<vector<bool>>vis(n+2,vector<bool>(m+2,false));\\n            vis[st1][st2]=true;\\n            while(q.size())\\n            {\\n                int size=q.size();\\n                for(int i=0;i<size;i++)\\n                {\\n                    auto temp=q.front();\\n                    q.pop();\\n                    long long x=temp.first;\\n                    long long y=temp.second;\\n                    if(x==ds1&&y==ds2)\\n                    {\\n                        return level;\\n                    }\\n                    for(auto &it:d)\\n                    {\\n                        long long nx=x+it.first;\\n                        long long ny=y+it.second;\\n                        if(nx>=0&&ny>=0&&nx<n&&ny<m&&mat[nx][ny]>=1&&vis[nx][ny]==false)\\n                        {\\n                            q.push({nx,ny});\\n                            vis[nx][ny]=true;\\n                        }\\n                    }\\n                }\\n                level++;\\n            }\\n            return -1;\\n        };\\n        sort(v.begin(),v.end(),[&](auto &v1,auto &v2){return v1[2]<v2[2];});\\n        long long st1=0;\\n        long long st2=0;\\n        long long count=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            long long ds1=v[i][0];\\n            long long ds2=v[i][1];\\n            long long step=bfs(st1,st2,ds1,ds2);\\n            if(step<0)\\n            {\\n                return -1;\\n            }\\n            count+=step;\\n            st1=ds1;\\n            st2=ds2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623870,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    \\n    private readonly IList<int[]> _directions = new List<int[]>()\\n    {\\n        new int[] { 1, 0 },\\n        new int[] { -1, 0 },\\n        new int[] { 0, 1 },            \\n        new int[] { 0, -1 }\\n    };\\n    \\n    public int CutOffTree(IList<IList<int>> forest) {\\n        \\n        if (forest == null)\\n        {\\n            throw new ArgumentNullException(\"Parameter cannot be null\", nameof(forest));\\n        }\\n        \\n        return CutOffTreeBfs(forest);\\n    }\\n    \\n    private int CutOffTreeBfs(IList<IList<int>> forest)\\n    {\\n        // Note that here we will store <height:coordinates>\\n        var treeMap = new Dictionary<int, int[]>();\\n        for (var row = 0; row < forest.Count; row++)\\n        {\\n            for (var col = 0; col < forest[0].Count; col++)\\n            {\\n                // Note that we need to store only trees of height greater than one, since anything else is not a tree and either just grass or a barrier\\n                if (forest[row][col] > 1)\\n                {\\n                    // Note that we are guaranteed unique heights\\n                    treeMap.Add(forest[row][col], new int[] { row, col });\\n                }\\n            }\\n        }\\n        \\n        var result = 0;\\n        var startRow = 0;\\n        var startCol = 0;\\n        var sortedTreeMap = treeMap.OrderBy(kvp => kvp.Key);\\n        \\n        foreach (var kvp in sortedTreeMap)\\n        {\\n            var endRow = kvp.Value[0];\\n            var endCol = kvp.Value[1];\\n            \\n            var steps = GetShortestPathBfs(forest, startRow, startCol, endRow, endCol);\\n            if (steps == -1)\\n            {\\n                return -1;\\n            }\\n            \\n            result += steps;\\n            startRow = endRow;\\n            startCol = endCol;\\n        }\\n                        \\n        return result;\\n    }\\n    \\n    private int GetShortestPathBfs(IList<IList<int>> forest, int startRow, int startCol, int endRow, int endCol)\\n    {\\n        if (startRow == endRow && startCol == endCol)\\n        {\\n            return 0;\\n        }\\n        \\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] { startRow, startCol });\\n        \\n        var visited = new int[forest.Count, forest[0].Count];\\n        visited[startRow, startCol] = 1;\\n        \\n        var level = 0;\\n        \\n        while (queue.Count > 0)\\n        {\\n            level++;\\n            var size = queue.Count;\\n            while (size > 0)\\n            {\\n                var oldNode = queue.Dequeue();\\n                var oldRow = oldNode[0];\\n                var oldCol = oldNode[1];\\n                                \\n                foreach (var d in _directions)\\n                {\\n                    var newRow = oldRow + d[0];\\n                    var newCol = oldCol + d[1];\\n                    \\n                    if (newRow >= 0 && newRow < forest.Count && newCol >= 0 && newCol < forest[0].Count && forest[newRow][newCol] != 0 && visited[newRow, newCol] == 0)\\n                    { \\n                        if (newRow == endRow && newCol == endCol)\\n                        {\\n                            return level;\\n                        }                        \\n                        \\n                        visited[newRow, newCol] = 1;                        \\n                        queue.Enqueue(new int[] { newRow, newCol });\\n                    }\\n                }\\n                \\n                size--;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    private readonly IList<int[]> _directions = new List<int[]>()\\n    {\\n        new int[] { 1, 0 },\\n        new int[] { -1, 0 },\\n        new int[] { 0, 1 },            \\n        new int[] { 0, -1 }\\n    };\\n    \\n    public int CutOffTree(IList<IList<int>> forest) {\\n        \\n        if (forest == null)\\n        {\\n            throw new ArgumentNullException(\"Parameter cannot be null\", nameof(forest));\\n        }\\n        \\n        return CutOffTreeBfs(forest);\\n    }\\n    \\n    private int CutOffTreeBfs(IList<IList<int>> forest)\\n    {\\n        // Note that here we will store <height:coordinates>\\n        var treeMap = new Dictionary<int, int[]>();\\n        for (var row = 0; row < forest.Count; row++)\\n        {\\n            for (var col = 0; col < forest[0].Count; col++)\\n            {\\n                // Note that we need to store only trees of height greater than one, since anything else is not a tree and either just grass or a barrier\\n                if (forest[row][col] > 1)\\n                {\\n                    // Note that we are guaranteed unique heights\\n                    treeMap.Add(forest[row][col], new int[] { row, col });\\n                }\\n            }\\n        }\\n        \\n        var result = 0;\\n        var startRow = 0;\\n        var startCol = 0;\\n        var sortedTreeMap = treeMap.OrderBy(kvp => kvp.Key);\\n        \\n        foreach (var kvp in sortedTreeMap)\\n        {\\n            var endRow = kvp.Value[0];\\n            var endCol = kvp.Value[1];\\n            \\n            var steps = GetShortestPathBfs(forest, startRow, startCol, endRow, endCol);\\n            if (steps == -1)\\n            {\\n                return -1;\\n            }\\n            \\n            result += steps;\\n            startRow = endRow;\\n            startCol = endCol;\\n        }\\n                        \\n        return result;\\n    }\\n    \\n    private int GetShortestPathBfs(IList<IList<int>> forest, int startRow, int startCol, int endRow, int endCol)\\n    {\\n        if (startRow == endRow && startCol == endCol)\\n        {\\n            return 0;\\n        }\\n        \\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] { startRow, startCol });\\n        \\n        var visited = new int[forest.Count, forest[0].Count];\\n        visited[startRow, startCol] = 1;\\n        \\n        var level = 0;\\n        \\n        while (queue.Count > 0)\\n        {\\n            level++;\\n            var size = queue.Count;\\n            while (size > 0)\\n            {\\n                var oldNode = queue.Dequeue();\\n                var oldRow = oldNode[0];\\n                var oldCol = oldNode[1];\\n                                \\n                foreach (var d in _directions)\\n                {\\n                    var newRow = oldRow + d[0];\\n                    var newCol = oldCol + d[1];\\n                    \\n                    if (newRow >= 0 && newRow < forest.Count && newCol >= 0 && newCol < forest[0].Count && forest[newRow][newCol] != 0 && visited[newRow, newCol] == 0)\\n                    { \\n                        if (newRow == endRow && newCol == endCol)\\n                        {\\n                            return level;\\n                        }                        \\n                        \\n                        visited[newRow, newCol] = 1;                        \\n                        queue.Enqueue(new int[] { newRow, newCol });\\n                    }\\n                }\\n                \\n                size--;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582145,
                "title": "c-675-cut-off-trees-for-golf-event",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m = forest.size(), n = forest[0].size(), dir[5] = {-1, 0, 1, 0, -1}; \\n        bool seen[m][n]; \\n        \\n        auto fn = [&](pair<int, int>& start, pair<int, int>& end) {\\n            int ans = 0; \\n            memset(seen, false, sizeof(seen)); \\n            seen[start.first][start.second] = true; \\n            queue<pair<int, int>> q; q.push(start); \\n            for (; q.size(); ++ans) \\n                for (int sz = q.size(); sz; --sz) {\\n                    auto [i, j] = q.front(); q.pop(); \\n                    if (i == end.first && j == end.second) return ans; \\n                    for (int k = 0; k < 4; ++k) {\\n                        int ii = i + dir[k], jj = j + dir[k+1]; \\n                        if (0 <= ii && ii < m && 0 <= jj && jj < n && forest[ii][jj] != 0 && !seen[ii][jj]) {\\n                            seen[ii][jj] = true; \\n                            q.emplace(ii, jj); \\n                        }\\n                    }\\n                }\\n            return -1; \\n        }; \\n        \\n        vector<tuple<int, int, int>> vals; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (forest[i][j] > 1) vals.emplace_back(forest[i][j], i, j); \\n        sort(vals.begin(), vals.end()); \\n        \\n        int ans = 0; \\n        pair<int, int> start = {0, 0}; \\n        for (auto& [v, i, j] : vals) {\\n            pair<int, int> end = {i, j}; \\n            int val = fn(start, end); \\n            if (val == -1) return -1; \\n            ans += val; \\n            start = end; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m = forest.size(), n = forest[0].size(), dir[5] = {-1, 0, 1, 0, -1}; \\n        bool seen[m][n]; \\n        \\n        auto fn = [&](pair<int, int>& start, pair<int, int>& end) {\\n            int ans = 0; \\n            memset(seen, false, sizeof(seen)); \\n            seen[start.first][start.second] = true; \\n            queue<pair<int, int>> q; q.push(start); \\n            for (; q.size(); ++ans) \\n                for (int sz = q.size(); sz; --sz) {\\n                    auto [i, j] = q.front(); q.pop(); \\n                    if (i == end.first && j == end.second) return ans; \\n                    for (int k = 0; k < 4; ++k) {\\n                        int ii = i + dir[k], jj = j + dir[k+1]; \\n                        if (0 <= ii && ii < m && 0 <= jj && jj < n && forest[ii][jj] != 0 && !seen[ii][jj]) {\\n                            seen[ii][jj] = true; \\n                            q.emplace(ii, jj); \\n                        }\\n                    }\\n                }\\n            return -1; \\n        }; \\n        \\n        vector<tuple<int, int, int>> vals; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (forest[i][j] > 1) vals.emplace_back(forest[i][j], i, j); \\n        sort(vals.begin(), vals.end()); \\n        \\n        int ans = 0; \\n        pair<int, int> start = {0, 0}; \\n        for (auto& [v, i, j] : vals) {\\n            pair<int, int> end = {i, j}; \\n            int val = fn(start, end); \\n            if (val == -1) return -1; \\n            ans += val; \\n            start = end; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549945,
                "title": "c-using-bfs-priority-queue",
                "content": "\\n### Do Upvote if Helpful :-)\\nclass Solution {\\n    int n,m;\\n    int d[4][2] = {{-1,0},{0,-1},{0,1},{1,0}};\\npublic:\\n    \\n    bool valid(int a,int b,int n,int m){\\n        \\n        return (a>=0&&a<n&&b>=0&&b<m);\\n    }\\n    \\n    int bfs(vector<vector<int>> &fo,pair<int,int> start,pair<int,int> target){\\n        \\n        if(start.first==target.first && start.second==target.second)\\n            return 0;\\n        \\n        vector<vector<bool>> used(n,vector<bool>(m,false));\\n        used[start.first][start.second] = true;\\n        \\n        int steps = 0;\\n        queue<pair<int,int>> q;\\n        \\n        q.push(start);\\n        while(!q.empty()){\\n            \\n            steps++;\\n            int size = q.size();\\n           \\n            while(size--){\\n                auto curr = q.front();\\n                q.pop();\\n                \\n                for(int i=0;i<4;i++){\\n                    int x = curr.first+d[i][0];\\n                    int y = curr.second+d[i][1];\\n                    \\n                    if(valid(x,y,n,m) && !used[x][y] && fo[x][y]>0){\\n                        \\n                        if(x==target.first && y==target.second)\\n                            return steps;\\n                        \\n                        used[x][y] = true;\\n                        q.push({x,y});   \\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        \\n        n = forest.size();\\n        m = forest[0].size();\\n        \\n        if(n==0)\\n            return -1;\\n        \\n        typedef tuple<int,int,int> hxy;\\n        priority_queue<hxy,vector<hxy>,greater<hxy>> pq;\\n       \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(forest[i][j]>1) \\n                    pq.push({forest[i][j],i,j});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        pair<int,int> start{0,0};\\n        pair<int,int> target;\\n        \\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            \\n            target = {get<1>(curr),get<2>(curr)};\\n            int steps = bfs(forest,start,target);\\n            \\n            if(steps==-1)\\n                return -1;\\n           \\n            ans+=steps;\\n            start = target;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    int n,m;\\n    int d[4][2] = {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 1466793,
                "title": "c-solution-using-bfs",
                "content": "Not quite sure of the complexity though it might be T: O(n*m*logn).\\n\\nInterestingly, I had a timeout error because I was using a List as Visited. That taught me to use a bool[] in order to keep the values instead of a list as when searching, it\\'s much faster.\\n\\n```\\npublic class Solution {\\n    \\n    private List<(int r, int c)> Directions = new List<(int r, int c)>{\\n        (0, 1),\\n        (0, -1),\\n        (1, 0),\\n        (-1, 0)\\n    };\\n    \\n    public int CutOffTree(IList<IList<int>> forest) {\\n        \\n        var treesToCut = new List<int>();\\n        for(int i = 0; i < forest.Count; i++)\\n            for(int j = 0; j < forest[0].Count; j++)\\n                if(forest[i][j] > 1)\\n                    treesToCut.Add(forest[i][j]);\\n        \\n        treesToCut = treesToCut.OrderBy(x => x).ToList();\\n        \\n        // BFS\\n        var totalSteps = 0;\\n        (int r, int c) location = (0, 0);\\n        foreach(var tree in treesToCut)\\n        {\\n            var queue = new Queue<(int r, int c)>();\\n            var visited = new bool[forest.Count, forest[0].Count];\\n            queue.Enqueue(location);\\n            visited[location.r, location.c] = true;;\\n            \\n            var currentSteps = 0;\\n            var found = false;\\n            \\n            if(forest[location.r][location.c] == tree)\\n                found = true;\\n            \\n            while(queue.Count != 0 && !found)\\n            {\\n                currentSteps++;\\n                \\n                var currentLevelNodes = queue.Count();\\n                while(currentLevelNodes > 0 && !found)\\n                {\\n                    var curr = queue.Dequeue();\\n                    \\n                    foreach(var dir in Directions)\\n                    {\\n                        var r = curr.r + dir.r;\\n                        var c = curr.c + dir.c;\\n                        \\n                        if(0 <= r && r < forest.Count \\n                           && 0 <= c && c < forest[0].Count \\n                           && !visited[r, c] && forest[r][c] > 0){\\n                            queue.Enqueue((r, c));\\n                            visited[r, c] = true;;\\n                            if(forest[r][c] == tree){\\n                                location = (r, c);\\n                                found = true;\\n                            }\\n                        }\\n                    }\\n                    currentLevelNodes--;\\n                }\\n            }\\n            \\n            if(!found)\\n                return -1;\\n            \\n            totalSteps += currentSteps;\\n        }\\n        return totalSteps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    private List<(int r, int c)> Directions = new List<(int r, int c)>{\\n        (0, 1),\\n        (0, -1),\\n        (1, 0),\\n        (-1, 0)\\n    };\\n    \\n    public int CutOffTree(IList<IList<int>> forest) {\\n        \\n        var treesToCut = new List<int>();\\n        for(int i = 0; i < forest.Count; i++)\\n            for(int j = 0; j < forest[0].Count; j++)\\n                if(forest[i][j] > 1)\\n                    treesToCut.Add(forest[i][j]);\\n        \\n        treesToCut = treesToCut.OrderBy(x => x).ToList();\\n        \\n        // BFS\\n        var totalSteps = 0;\\n        (int r, int c) location = (0, 0);\\n        foreach(var tree in treesToCut)\\n        {\\n            var queue = new Queue<(int r, int c)>();\\n            var visited = new bool[forest.Count, forest[0].Count];\\n            queue.Enqueue(location);\\n            visited[location.r, location.c] = true;;\\n            \\n            var currentSteps = 0;\\n            var found = false;\\n            \\n            if(forest[location.r][location.c] == tree)\\n                found = true;\\n            \\n            while(queue.Count != 0 && !found)\\n            {\\n                currentSteps++;\\n                \\n                var currentLevelNodes = queue.Count();\\n                while(currentLevelNodes > 0 && !found)\\n                {\\n                    var curr = queue.Dequeue();\\n                    \\n                    foreach(var dir in Directions)\\n                    {\\n                        var r = curr.r + dir.r;\\n                        var c = curr.c + dir.c;\\n                        \\n                        if(0 <= r && r < forest.Count \\n                           && 0 <= c && c < forest[0].Count \\n                           && !visited[r, c] && forest[r][c] > 0){\\n                            queue.Enqueue((r, c));\\n                            visited[r, c] = true;;\\n                            if(forest[r][c] == tree){\\n                                location = (r, c);\\n                                found = true;\\n                            }\\n                        }\\n                    }\\n                    currentLevelNodes--;\\n                }\\n            }\\n            \\n            if(!found)\\n                return -1;\\n            \\n            totalSteps += currentSteps;\\n        }\\n        return totalSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429882,
                "title": "python-3-bfs-timeout-issue-need-help",
                "content": "Can any one tell why this code is timing out. It works fine for smaller input however it seems to be taking lot of time for a bigger input. What am I missing here?\\nYour input is highly appreciated.\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.offsets = [(1,0),(-1,0),(0,1),(0,-1)]\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        # traverse the forest \\n        # get all trees to be cut\\n        n = len(forest)\\n        m = len(forest[0])\\n        treesToBeCut = []\\n        for i in range(n):\\n            for j in range(m):\\n                if forest[i][j] > 1:\\n                    treesToBeCut.append((i, j, forest[i][j]))\\n        \\n        # sort these trees to be cut in ascending order \\n        # shortest first and the longest one last \\n        treesToBeCut.sort(key=lambda x: x[2])\\n        #print(treesToBeCut)\\n        \\n        # use this BFS to find the shortest path to all the \\n        # trees, two at a time starting from 0, 0\\n        \\n        # start from the begining and go through\\n        # all the trees that needs to be cut in the ascending order\\n        src_x = src_y = totalDist = 0\\n        for cur_x, cur_y, h in treesToBeCut:\\n            d = self.bfs(forest, src_x, src_y, cur_x, cur_y, n, m)\\n            if d < 0:\\n                # if there is no path between source cell to target cell\\n                return -1\\n            \\n            # add the distance to total distance\\n            totalDist += d\\n            \\n            # change the source cell to to be current cell\\n            src_x = cur_x\\n            src_y = cur_y\\n            \\n        return totalDist\\n    \\n    # to find the shortest distance between any two nodes\\n    # we will use BFS\\n    def bfs(self, forest, src_x, src_y, target_x, target_y, n, m):\\n        print((src_x, src_y), (target_x, target_y))\\n        q = collections.deque([(src_x, src_y)])\\n        seen = set()\\n        level = 0\\n        while q:\\n            s = len(q)\\n            for i in range(s):\\n                cur_x, cur_y = q.popleft()\\n                # if current cell is the target cell\\n                if cur_x == target_x and cur_y == target_y:\\n                    return level\\n\\n                # mark current node as visited\\n                seen.add((cur_x, cur_y))\\n\\n                # find all the neighbours\\n                for rowOffSet, colOffSet in self.offsets:\\n                    nx = cur_x + rowOffSet\\n                    ny = cur_y + colOffSet\\n\\n                    # if not valid do nothing \\n                    if nx < 0 or nx >= n or ny < 0 or ny >= m or forest[nx][ny] == 0 or (nx, ny) in seen:\\n                        continue\\n\\n                    # add the valid unseen node to the queue and increase the level\\n                    q.append((nx, ny))\\n                    \\n            # increment level\\n            level += 1\\n        \\n        # when there is no path between source and target cells\\n        return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.offsets = [(1,0),(-1,0),(0,1),(0,-1)]\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        # traverse the forest \\n        # get all trees to be cut\\n        n = len(forest)\\n        m = len(forest[0])\\n        treesToBeCut = []\\n        for i in range(n):\\n            for j in range(m):\\n                if forest[i][j] > 1:\\n                    treesToBeCut.append((i, j, forest[i][j]))\\n        \\n        # sort these trees to be cut in ascending order \\n        # shortest first and the longest one last \\n        treesToBeCut.sort(key=lambda x: x[2])\\n        #print(treesToBeCut)\\n        \\n        # use this BFS to find the shortest path to all the \\n        # trees, two at a time starting from 0, 0\\n        \\n        # start from the begining and go through\\n        # all the trees that needs to be cut in the ascending order\\n        src_x = src_y = totalDist = 0\\n        for cur_x, cur_y, h in treesToBeCut:\\n            d = self.bfs(forest, src_x, src_y, cur_x, cur_y, n, m)\\n            if d < 0:\\n                # if there is no path between source cell to target cell\\n                return -1\\n            \\n            # add the distance to total distance\\n            totalDist += d\\n            \\n            # change the source cell to to be current cell\\n            src_x = cur_x\\n            src_y = cur_y\\n            \\n        return totalDist\\n    \\n    # to find the shortest distance between any two nodes\\n    # we will use BFS\\n    def bfs(self, forest, src_x, src_y, target_x, target_y, n, m):\\n        print((src_x, src_y), (target_x, target_y))\\n        q = collections.deque([(src_x, src_y)])\\n        seen = set()\\n        level = 0\\n        while q:\\n            s = len(q)\\n            for i in range(s):\\n                cur_x, cur_y = q.popleft()\\n                # if current cell is the target cell\\n                if cur_x == target_x and cur_y == target_y:\\n                    return level\\n\\n                # mark current node as visited\\n                seen.add((cur_x, cur_y))\\n\\n                # find all the neighbours\\n                for rowOffSet, colOffSet in self.offsets:\\n                    nx = cur_x + rowOffSet\\n                    ny = cur_y + colOffSet\\n\\n                    # if not valid do nothing \\n                    if nx < 0 or nx >= n or ny < 0 or ny >= m or forest[nx][ny] == 0 or (nx, ny) in seen:\\n                        continue\\n\\n                    # add the valid unseen node to the queue and increase the level\\n                    q.append((nx, ny))\\n                    \\n            # increment level\\n            level += 1\\n        \\n        # when there is no path between source and target cells\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407769,
                "title": "python-sorted-trees-bfs",
                "content": "The problem dictates the path of ascending tree path (unique heights of tree). Hence we just need to find steps between current_tree and next_tree in the sorted trees. Summing up all should give us the total steps. To find path between tree and next_tree we could use any search(dfs/bfs) but bfs would be optimal. If no path exists between any two consequitve nodes in the sorted trees, it implies no solution exist.  \\n\\n```\\nclass Solution:\\n        \\n    def pathExists(self, src, dst, forest):\\n        \\n        rows = len(forest)\\n        cols = len(forest[0])\\n        \\n        dst_x = dst[1]\\n        dst_y = dst[2]\\n        \\n        def bfs(q, visited):\\n            while (q):\\n                (x,y, count) = q.popleft()\\n                \\n                if (x,y) == (dst_x, dst_y):\\n                    return count\\n\\n                dx, dy = 0, 1   \\n                for i in range(4):\\n                    nx = x + dx\\n                    ny = y + dy\\n                    if (0 <= nx < rows) and (0 <= ny < cols) and (forest[nx][ny] >= 1) and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        q.append((nx, ny, count + 1))\\n                    dx, dy = -dy, dx\\n                \\n            return -1\\n            \\n        v, x, y = src\\n        visited = {(x,y)}\\n        q = collections.deque()\\n        q.append((x,y,0))\\n        return bfs(q, visited)\\n    \\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        \\n        rows = len(forest)\\n        cols = len(forest[0])\\n        trees = sorted([(forest[i][j], i,j)  for i in range(rows) for j in range(cols) if forest[i][j] > 1])\\n        \\n        start = (forest[0][0], 0 ,0)\\n        mn_steps = 0\\n        for next_tree in trees:\\n            steps = self.pathExists(start, next_tree, forest)\\n            start = next_tree\\n            forest[start[1]][start[2]] = 1\\n            if steps < 0:\\n                return -1\\n            else:\\n                mn_steps += steps\\n        \\n        return mn_steps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n        \\n    def pathExists(self, src, dst, forest):\\n        \\n        rows = len(forest)\\n        cols = len(forest[0])\\n        \\n        dst_x = dst[1]\\n        dst_y = dst[2]\\n        \\n        def bfs(q, visited):\\n            while (q):\\n                (x,y, count) = q.popleft()\\n                \\n                if (x,y) == (dst_x, dst_y):\\n                    return count\\n\\n                dx, dy = 0, 1   \\n                for i in range(4):\\n                    nx = x + dx\\n                    ny = y + dy\\n                    if (0 <= nx < rows) and (0 <= ny < cols) and (forest[nx][ny] >= 1) and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        q.append((nx, ny, count + 1))\\n                    dx, dy = -dy, dx\\n                \\n            return -1\\n            \\n        v, x, y = src\\n        visited = {(x,y)}\\n        q = collections.deque()\\n        q.append((x,y,0))\\n        return bfs(q, visited)\\n    \\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        \\n        rows = len(forest)\\n        cols = len(forest[0])\\n        trees = sorted([(forest[i][j], i,j)  for i in range(rows) for j in range(cols) if forest[i][j] > 1])\\n        \\n        start = (forest[0][0], 0 ,0)\\n        mn_steps = 0\\n        for next_tree in trees:\\n            steps = self.pathExists(start, next_tree, forest)\\n            start = next_tree\\n            forest[start[1]][start[2]] = 1\\n            if steps < 0:\\n                return -1\\n            else:\\n                mn_steps += steps\\n        \\n        return mn_steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385727,
                "title": "python-bfs-working-solution",
                "content": "```\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        rows = len(forest)\\n        cols = len(forest[0])\\n        def is_valid_move(row, col, matrix, visited):\\n            nonlocal rows, cols\\n            if new_row >= rows or new_row < 0 or new_col >= cols or new_col < 0: return False\\n            if (new_row, new_col) in visited: return False\\n            if matrix[row][col] == 0: return False\\n            return True\\n        trees = []\\n        for r in range(rows):\\n            for c in range(cols):\\n                if forest[r][c] > 1: trees.append(forest[r][c])\\n        trees.sort()\\n        index = 0\\n        steps = 0\\n        start_node = (0,0)\\n        found_flag = True\\n        while index < len(trees):\\n            start_row, start_col = start_node\\n            if not found_flag: break\\n            found_flag = False\\n            queue = deque([(start_row, start_col, 0)])\\n            visited = set([(start_row, start_col)])\\n            while queue:\\n                # look for current_tree\\n                r,c,s = queue.popleft()\\n                if forest[r][c] == trees[index]:\\n                    forest[r][c] = 1\\n                    index += 1\\n                    steps += s\\n                    found_flag = True\\n                    start_node = (r,c)\\n                    break\\n                for direction_row, direction_col in [(-1,0), (1,0), (0,1), (0,-1)]:\\n                    new_row, new_col = direction_row + r, direction_col + c\\n                    if is_valid_move(new_row, new_col, forest, visited):\\n                        queue.append((new_row, new_col, s+1))\\n                        visited.add((new_row, new_col))\\n        return steps if index >= len(trees) else -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        rows = len(forest)\\n        cols = len(forest[0])\\n        def is_valid_move(row, col, matrix, visited):\\n            nonlocal rows, cols\\n            if new_row >= rows or new_row < 0 or new_col >= cols or new_col < 0: return False\\n            if (new_row, new_col) in visited: return False\\n            if matrix[row][col] == 0: return False\\n            return True\\n        trees = []\\n        for r in range(rows):\\n            for c in range(cols):\\n                if forest[r][c] > 1: trees.append(forest[r][c])\\n        trees.sort()\\n        index = 0\\n        steps = 0\\n        start_node = (0,0)\\n        found_flag = True\\n        while index < len(trees):\\n            start_row, start_col = start_node\\n            if not found_flag: break\\n            found_flag = False\\n            queue = deque([(start_row, start_col, 0)])\\n            visited = set([(start_row, start_col)])\\n            while queue:\\n                # look for current_tree\\n                r,c,s = queue.popleft()\\n                if forest[r][c] == trees[index]:\\n                    forest[r][c] = 1\\n                    index += 1\\n                    steps += s\\n                    found_flag = True\\n                    start_node = (r,c)\\n                    break\\n                for direction_row, direction_col in [(-1,0), (1,0), (0,1), (0,-1)]:\\n                    new_row, new_col = direction_row + r, direction_col + c\\n                    if is_valid_move(new_row, new_col, forest, visited):\\n                        queue.append((new_row, new_col, s+1))\\n                        visited.add((new_row, new_col))\\n        return steps if index >= len(trees) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1372280,
                "title": "c-simple-bfs-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int xp[4]={-1,1,0,0};\\n    int yp[4]={0,0,-1,1};\\n    \\n  int bfs(vector<vector<int>>& arr,int i,int j,int l,int m,vector<vector<int>>&visited)\\n    {\\n      \\n      \\n      visited[i][j]=1;\\n      \\n      queue<pair<int,pair<int,int>>>q;\\n      q.push({0,{i,j}});\\n      \\n      int ans=-1;\\n      while(q.size())\\n      {\\n          int level=q.front().first;\\n          int x=q.front().second.first;\\n          int y=q.front().second.second;\\n          q.pop();\\n          \\n         \\n          \\n          visited[x][y]=1;\\n          \\n          if(x==l&&y==m)\\n          {\\n              ans=level;\\n              break;\\n          }\\n          \\n          for(int k=0;k<4;k++)\\n          {\\n              int u=x+xp[k],v=y+yp[k];\\n \\n              if(u>=0&&v>=0&&u<arr.size()&&v<arr[0].size()&&!visited[u][v]&&arr[u][v])\\n              {\\n                  \\n                  visited[u][v]=1;\\n                  q.push({level+1,{u,v}});\\n              }\\n          }\\n\\n      }\\n      return ans;        \\n    }\\n    \\n    \\n    \\n    \\n    int cutOffTree(vector<vector<int>>& arr) {\\n           int ans=0;\\n        \\n        vector<pair<int,pair<int,int>>>v;\\n        \\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[i].size();j++)\\n                if(arr[i][j]>1)\\n                    v.push_back({arr[i][j],{i,j}});\\n     \\n        \\n         v.push_back({0,{0,0}});\\n         sort(v.begin(),v.end());\\n\\n        \\n        vector<vector<int>>visited;\\n        \\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            visited.clear();\\n            visited.resize(arr.size(),vector<int>(arr[0].size(),0));\\n            int k=bfs(arr,v[i].second.first,v[i].second.second,v[i+1].second.first,v[i+1].second.second,visited);\\n            if(k==-1)\\n                 return -1;\\n            else\\n                ans+=k;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int xp[4]={-1,1,0,0};\\n    int yp[4]={0,0,-1,1};\\n    \\n  int bfs(vector<vector<int>>& arr,int i,int j,int l,int m,vector<vector<int>>&visited)\\n    {\\n      \\n      \\n      visited[i][j]=1;\\n      \\n      queue<pair<int,pair<int,int>>>q;\\n      q.push({0,{i,j}});\\n      \\n      int ans=-1;\\n      while(q.size())\\n      {\\n          int level=q.front().first;\\n          int x=q.front().second.first;\\n          int y=q.front().second.second;\\n          q.pop();\\n          \\n         \\n          \\n          visited[x][y]=1;\\n          \\n          if(x==l&&y==m)\\n          {\\n              ans=level;\\n              break;\\n          }\\n          \\n          for(int k=0;k<4;k++)\\n          {\\n              int u=x+xp[k],v=y+yp[k];\\n \\n              if(u>=0&&v>=0&&u<arr.size()&&v<arr[0].size()&&!visited[u][v]&&arr[u][v])\\n              {\\n                  \\n                  visited[u][v]=1;\\n                  q.push({level+1,{u,v}});\\n              }\\n          }\\n\\n      }\\n      return ans;        \\n    }\\n    \\n    \\n    \\n    \\n    int cutOffTree(vector<vector<int>>& arr) {\\n           int ans=0;\\n        \\n        vector<pair<int,pair<int,int>>>v;\\n        \\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[i].size();j++)\\n                if(arr[i][j]>1)\\n                    v.push_back({arr[i][j],{i,j}});\\n     \\n        \\n         v.push_back({0,{0,0}});\\n         sort(v.begin(),v.end());\\n\\n        \\n        vector<vector<int>>visited;\\n        \\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            visited.clear();\\n            visited.resize(arr.size(),vector<int>(arr[0].size(),0));\\n            int k=bfs(arr,v[i].second.first,v[i].second.second,v[i+1].second.first,v[i+1].second.second,visited);\\n            if(k==-1)\\n                 return -1;\\n            else\\n                ans+=k;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372171,
                "title": "c-bfs-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={1,0,0,-1};\\n    int dy[4]={0,1,-1,0};\\n    int m,n;\\n    bool isvalid(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n)\\n            return false;\\n        return true;\\n    }\\n    int BFS(int si,int sj,int di,int dj,vector<vector<int>>forest)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({si,sj});\\n        forest[si][sj]=0;\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int i=q.front().first,j=q.front().second;\\n                q.pop();\\n                if(i==di && j==dj)\\n                    return res;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=i+dx[k],y=j+dy[k];\\n                    if(isvalid(x,y) && forest[x][y]!=0)\\n                    {\\n                        forest[x][y]=0;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& forest) \\n    {\\n        vector<vector<int>>v;\\n        m=forest.size(),n=forest[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(forest[i][j]>1)\\n                    v.push_back({forest[i][j],i,j});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int i=0,j=0,res=0;\\n        for(auto p:v)\\n        {\\n            int dist=BFS(i,j,p[1],p[2],forest);\\n            if(dist==-1)\\n                return -1;\\n            res+=dist;\\n            i=p[1],j=p[2];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={1,0,0,-1};\\n    int dy[4]={0,1,-1,0};\\n    int m,n;\\n    bool isvalid(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n)\\n            return false;\\n        return true;\\n    }\\n    int BFS(int si,int sj,int di,int dj,vector<vector<int>>forest)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({si,sj});\\n        forest[si][sj]=0;\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int i=q.front().first,j=q.front().second;\\n                q.pop();\\n                if(i==di && j==dj)\\n                    return res;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=i+dx[k],y=j+dy[k];\\n                    if(isvalid(x,y) && forest[x][y]!=0)\\n                    {\\n                        forest[x][y]=0;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& forest) \\n    {\\n        vector<vector<int>>v;\\n        m=forest.size(),n=forest[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(forest[i][j]>1)\\n                    v.push_back({forest[i][j],i,j});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int i=0,j=0,res=0;\\n        for(auto p:v)\\n        {\\n            int dist=BFS(i,j,p[1],p[2],forest);\\n            if(dist==-1)\\n                return -1;\\n            res+=dist;\\n            i=p[1],j=p[2];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251463,
                "title": "python3-priority-queue-bidirectional-bfs",
                "content": "The problem is actually easy with this one intuition. Since, the trees have to be cut in increasing order of height and the heights are distinct, there is always only one cell we need to visit next. The problem then becomes how fast can we get from the current cell to the next cell which is BFS! The problem reduces to performing X BFS calls where X is the number of trees.\\n\\nConsider the example\\n```\\n[5, 4, 6]\\n[0, 0, 2]\\n[10, 11, 12]\\n```\\n\\nWe start at (0, 0) and the height is 5. But we cannot cut it yet as there is a tree with height 2 at (1, 2). So the first step is to get from (0, 0) to (1, 2). After getting to (1, 2) we cut the tree. The next shortest tree is at (0, 1) with  a height of 4. So now we need to move from (1, 2) to (0, 1).\\n\\nThe order of the trees to cut can be maintained using a min heap. If at any point, we are not able to reach the next tree, just return -1. A bidirectional BFS helps speed up the search.\\n\\nTime Complexity: O((MN)^2 * lgMN)\\nM is the number of rows and N is the number of columns\\nAll the cells could be in the heap and processing all of them takes MN lgMN\\nEach BFS search could take a maximum of MN time\\n\\nSpace complexity: O(MN)\\nThe heap takes O(MN) space. One run of BFS takes O(MN) space and it is discarded once complete.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        def bfs(start, end):\\n            if start == end:\\n                return 0\\n            \\n            fwd, rev = [start], [end]\\n            visited_fwd, visited_rev = set(fwd), set(rev)\\n            steps = 0\\n            while fwd:\\n                if len(fwd) > len(rev):\\n                    fwd, rev = rev, fwd\\n                    visited_fwd, visited_rev = visited_rev, visited_fwd\\n                \\n                nxt = []\\n                for i, k in fwd:\\n                    for x, y in directions:\\n                        nxt_i, nxt_k = i + x, k + y\\n                        if 0 <= nxt_i < m and 0 <= nxt_k < n and forest[nxt_i][nxt_k] != 0 and (nxt_i, nxt_k) not in visited_fwd:\\n                            if (nxt_i, nxt_k) in visited_rev:\\n                                return steps + 1\\n                            visited_fwd.add((nxt_i, nxt_k))\\n                            nxt.append((nxt_i, nxt_k))\\n                \\n                steps += 1\\n                fwd = nxt\\n            \\n            return -1\\n        \\n        m, n = len(forest), len(forest[0])\\n        min_steps = 0\\n        directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        curr = (0, 0)\\n        \\n        heap = []\\n        for i, k in product(range(m), range(n)):\\n            if forest[i][k] > 1:\\n                heapq.heappush(heap, (forest[i][k], (i, k)))\\n        \\n        while heap:\\n            _, nxt = heapq.heappop(heap)\\n            min_steps_to_nxt = bfs(curr, nxt)\\n            if min_steps_to_nxt == -1:\\n                return -1\\n            \\n            min_steps += min_steps_to_nxt\\n            curr = nxt\\n        \\n        return min_steps\\n```",
                "solutionTags": [],
                "code": "```\\n[5, 4, 6]\\n[0, 0, 2]\\n[10, 11, 12]\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        def bfs(start, end):\\n            if start == end:\\n                return 0\\n            \\n            fwd, rev = [start], [end]\\n            visited_fwd, visited_rev = set(fwd), set(rev)\\n            steps = 0\\n            while fwd:\\n                if len(fwd) > len(rev):\\n                    fwd, rev = rev, fwd\\n                    visited_fwd, visited_rev = visited_rev, visited_fwd\\n                \\n                nxt = []\\n                for i, k in fwd:\\n                    for x, y in directions:\\n                        nxt_i, nxt_k = i + x, k + y\\n                        if 0 <= nxt_i < m and 0 <= nxt_k < n and forest[nxt_i][nxt_k] != 0 and (nxt_i, nxt_k) not in visited_fwd:\\n                            if (nxt_i, nxt_k) in visited_rev:\\n                                return steps + 1\\n                            visited_fwd.add((nxt_i, nxt_k))\\n                            nxt.append((nxt_i, nxt_k))\\n                \\n                steps += 1\\n                fwd = nxt\\n            \\n            return -1\\n        \\n        m, n = len(forest), len(forest[0])\\n        min_steps = 0\\n        directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        curr = (0, 0)\\n        \\n        heap = []\\n        for i, k in product(range(m), range(n)):\\n            if forest[i][k] > 1:\\n                heapq.heappush(heap, (forest[i][k], (i, k)))\\n        \\n        while heap:\\n            _, nxt = heapq.heappop(heap)\\n            min_steps_to_nxt = bfs(curr, nxt)\\n            if min_steps_to_nxt == -1:\\n                return -1\\n            \\n            min_steps += min_steps_to_nxt\\n            curr = nxt\\n        \\n        return min_steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247967,
                "title": "java-solution-slow-but-clear-coursera-princeton-algorithms-course",
                "content": "I am using Coursera algorithms (Princeton, Robert Sedgewick) course ideas so code should be easy to understand if you watched it.\\nIdea is based on building a Graph from the matrix using adjucencyMap representation and then use BFS to fins path from shortest tree to next shortest tree in this graph:\\nStep 1a: build adjucency HashMap (graph) of cells we can visit\\nStep 1b: build TreeMap (treeHeight, index) in order to know which trees to visit first \\nStep 2: run BFS to find distance from start to shortestTree; start = shortestTreeIndex after\\nStep 3: visit and cut trees in order from shortest one, if tree cannot be reached -> return -1\\n\\n**Note: this solution is extremely slow (bottom 5% on speed and memory by leetcode mertics)**\\n\\nIt supposed to be:\\n```\\nM == forest.length\\nN == forest[i].length\\nO(MN) -> building adjucency Map\\nO(MN)*log(MN) -> building heightIndexMap (TreeMap)\\nO(MN * (MN + 4MN)) -> running BFS to find shortest pathts between shortest and nextShortest tree.\\nTime complexity of BFS is O(V + E) when Adjacency List is used.\\nFor each tree we can have maximum of 4*MN edges and we are running BFS MN times, so it totales to O(MN * (MN + 4MN))\\n```\\nTme complexity is sum of the above, which can be simplified to O(MN * (MN + 4MN)) = O((MN)^2)\\n\\n**Bonus: the solution should work if input is not a matrix, but a `List<List<Integer>> forest` with random number of cells in each row**\\n\\n\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> adjucencyMap;\\n    Map<Integer, Integer> heightIndexMap;\\n    int forestSize = 0;\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if(forest.get(0).get(0) == 0){\\n            //(0,0) point is blocked\\n            return -1;\\n        }\\n        \\n        adjucencyMap = new HashMap<>();        \\n        //we use TreeMap so that trees will be sorted by height\\n        heightIndexMap = new TreeMap<>();\\n        forestSize = 0;\\n        \\n        for(int i = 0; i<forest.size(); i++){\\n            for(int j = 0; j<forest.get(i).size(); j++){    \\n                int cell = forest.get(i).get(j);\\n                int index = i*forest.get(i).size() + j + 1;\\n                //only consider trees we need to cut, ignore \"1\\'s\"\\n                if(cell > 1){\\n                    heightIndexMap.put(forest.get(i).get(j), index);\\n                }\\n                \\n                //only consider walkable cells\\n                if(cell > 0) {\\n                    List<Integer> adjucent = new ArrayList<>();\\n                    if(j-1 >= 0 && forest.get(i).get(j-1) > 0){\\n                        //add left\\n                        adjucent.add(index - 1);  \\n                    }\\n                    if(j+1 < forest.get(i).size() && forest.get(i).get(j+1) > 0){\\n                        //add right\\n                        adjucent.add(index + 1);  \\n                    }\\n                    if(i-1 >= 0 && j < forest.get(i-1).size() && forest.get(i-1).get(j) > 0){\\n                       //add top\\n                        adjucent.add(index - forest.get(i-1).size()); \\n                        \\n                    }\\n                    if(i+1 < forest.size() && j < forest.get(i+1).size() && forest.get(i+1).get(j) > 0){\\n                        //add bot\\n                        adjucent.add(index + forest.get(i).size()); \\n                    }               \\n                    adjucencyMap.put(index, adjucent);                        \\n                }\\n                \\n                forestSize++;\\n            }\\n        }\\n        \\n        int result = 0;\\n        int startIndex = 1;\\n        List<Integer> sortedTrees = new ArrayList(heightIndexMap.keySet());\\n        \\n        for(int i = 0; i < sortedTrees.size(); i++){\\n            int height = sortedTrees.get(i);\\n            int targetIndex = heightIndexMap.get(height);\\n            int dist = bfsFindDist(startIndex, targetIndex);\\n            if(dist == -1){\\n                return dist;\\n            }\\n            result += dist;\\n            startIndex = targetIndex;\\n        }\\n        \\n       return result;\\n    }\\n    \\n    // return: distance from startTreeIndex to targetTreeIndex\\n    // -1 if no path found\\n    int bfsFindDist(int startTreeIndex, int targetTreeIndex){\\n        if(startTreeIndex == targetTreeIndex){\\n            return 0;\\n        }\\n        \\n        List<Integer> distances = new ArrayList<>();\\n        for(int i = 0; i<=forestSize; i++){\\n            distances.add(i, -1);\\n        }\\n        \\n        List<Boolean> visited = new ArrayList<>();\\n        for(int i = 0; i<=forestSize; i++){\\n            visited.add(i, false);\\n        }\\n        \\n        visited.set(startTreeIndex, true);\\n        distances.set(startTreeIndex, 0);      \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(startTreeIndex);\\n        while(!queue.isEmpty()){\\n            int tree = queue.remove();\\n            for(int adj : adjucencyMap.get(tree)){\\n                if(adj == targetTreeIndex){\\n                    return distances.get(tree)+1;\\n                }\\n                if(!visited.get(adj)){\\n                    queue.add(adj);\\n                    visited.set(adj, true);\\n                    distances.set(adj, distances.get(tree)+1);\\n                }\\n            }\\n        }\\n        \\n        return distances.get(targetTreeIndex);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nM == forest.length\\nN == forest[i].length\\nO(MN) -> building adjucency Map\\nO(MN)*log(MN) -> building heightIndexMap (TreeMap)\\nO(MN * (MN + 4MN)) -> running BFS to find shortest pathts between shortest and nextShortest tree.\\nTime complexity of BFS is O(V + E) when Adjacency List is used.\\nFor each tree we can have maximum of 4*MN edges and we are running BFS MN times, so it totales to O(MN * (MN + 4MN))\\n```\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> adjucencyMap;\\n    Map<Integer, Integer> heightIndexMap;\\n    int forestSize = 0;\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if(forest.get(0).get(0) == 0){\\n            //(0,0) point is blocked\\n            return -1;\\n        }\\n        \\n        adjucencyMap = new HashMap<>();        \\n        //we use TreeMap so that trees will be sorted by height\\n        heightIndexMap = new TreeMap<>();\\n        forestSize = 0;\\n        \\n        for(int i = 0; i<forest.size(); i++){\\n            for(int j = 0; j<forest.get(i).size(); j++){    \\n                int cell = forest.get(i).get(j);\\n                int index = i*forest.get(i).size() + j + 1;\\n                //only consider trees we need to cut, ignore \"1\\'s\"\\n                if(cell > 1){\\n                    heightIndexMap.put(forest.get(i).get(j), index);\\n                }\\n                \\n                //only consider walkable cells\\n                if(cell > 0) {\\n                    List<Integer> adjucent = new ArrayList<>();\\n                    if(j-1 >= 0 && forest.get(i).get(j-1) > 0){\\n                        //add left\\n                        adjucent.add(index - 1);  \\n                    }\\n                    if(j+1 < forest.get(i).size() && forest.get(i).get(j+1) > 0){\\n                        //add right\\n                        adjucent.add(index + 1);  \\n                    }\\n                    if(i-1 >= 0 && j < forest.get(i-1).size() && forest.get(i-1).get(j) > 0){\\n                       //add top\\n                        adjucent.add(index - forest.get(i-1).size()); \\n                        \\n                    }\\n                    if(i+1 < forest.size() && j < forest.get(i+1).size() && forest.get(i+1).get(j) > 0){\\n                        //add bot\\n                        adjucent.add(index + forest.get(i).size()); \\n                    }               \\n                    adjucencyMap.put(index, adjucent);                        \\n                }\\n                \\n                forestSize++;\\n            }\\n        }\\n        \\n        int result = 0;\\n        int startIndex = 1;\\n        List<Integer> sortedTrees = new ArrayList(heightIndexMap.keySet());\\n        \\n        for(int i = 0; i < sortedTrees.size(); i++){\\n            int height = sortedTrees.get(i);\\n            int targetIndex = heightIndexMap.get(height);\\n            int dist = bfsFindDist(startIndex, targetIndex);\\n            if(dist == -1){\\n                return dist;\\n            }\\n            result += dist;\\n            startIndex = targetIndex;\\n        }\\n        \\n       return result;\\n    }\\n    \\n    // return: distance from startTreeIndex to targetTreeIndex\\n    // -1 if no path found\\n    int bfsFindDist(int startTreeIndex, int targetTreeIndex){\\n        if(startTreeIndex == targetTreeIndex){\\n            return 0;\\n        }\\n        \\n        List<Integer> distances = new ArrayList<>();\\n        for(int i = 0; i<=forestSize; i++){\\n            distances.add(i, -1);\\n        }\\n        \\n        List<Boolean> visited = new ArrayList<>();\\n        for(int i = 0; i<=forestSize; i++){\\n            visited.add(i, false);\\n        }\\n        \\n        visited.set(startTreeIndex, true);\\n        distances.set(startTreeIndex, 0);      \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(startTreeIndex);\\n        while(!queue.isEmpty()){\\n            int tree = queue.remove();\\n            for(int adj : adjucencyMap.get(tree)){\\n                if(adj == targetTreeIndex){\\n                    return distances.get(tree)+1;\\n                }\\n                if(!visited.get(adj)){\\n                    queue.add(adj);\\n                    visited.set(adj, true);\\n                    distances.set(adj, distances.get(tree)+1);\\n                }\\n            }\\n        }\\n        \\n        return distances.get(targetTreeIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233760,
                "title": "simple-bfs-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if(!forest.size() || !forest[0].size()) return 0;\\n        int n = forest.size();\\n        int m = forest[0].size();\\n        vector<int> trace;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                trace.push_back(forest[i][j]);\\n            }\\n        }\\n        sort(trace.begin(),trace.end());\\n        int curI=0,curJ=0;\\n        int steps = 0;\\n        for(auto i:trace){\\n            if(i==0||i==1)  continue;\\n            int ans = bfs(curI,curJ,forest,i,n,m);\\n            if(ans==-1) return -1;\\n            steps+=ans; \\n        }\\n        return steps;\\n    }\\nprivate:\\n    int bfs(int &curi, int &curj,vector<vector<int>> &forest, int dest,int n, int m){\\n        if(forest[curi][curj]==dest)  return 0;\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        visited[curi][curj]=1;\\n        list<pair<pair<int,int>,int>> q; //i,j, steps\\n        q.push_back({{curi,curj},0});\\n        while(!q.empty()){\\n            \\n            int i = q.front().first.first;\\n            int j = q.front().first.second;\\n            int steps = q.front().second;\\n            q.pop_front();\\n            if(forest[i][j]==dest){\\n                forest[i][j]=1;\\n                curi=i, curj=j;\\n                return steps;\\n            }\\n            if(i+1<n && visited[i+1][j]==0 && forest[i+1][j]!=0){\\n                visited[i+1][j]=1;\\n                q.push_back({{i+1,j},steps+1});\\n            }\\n            if(j+1<m && visited[i][j+1]==0 && forest[i][j+1]!=0){\\n                visited[i][j+1]=1;\\n                q.push_back({{i,j+1},steps+1});\\n            }\\n            if(i-1>=0 && visited[i-1][j]==0 && forest[i-1][j]!=0){\\n                visited[i-1][j]=1;\\n                q.push_back({{i-1,j},steps+1});\\n            }\\n            if(j-1>=0 && visited[i][j-1]==0 && forest[i][j-1]!=0){\\n                visited[i][j-1]=1;\\n                q.push_back({{i,j-1},steps+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if(!forest.size() || !forest[0].size()) return 0;\\n        int n = forest.size();\\n        int m = forest[0].size();\\n        vector<int> trace;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                trace.push_back(forest[i][j]);\\n            }\\n        }\\n        sort(trace.begin(),trace.end());\\n        int curI=0,curJ=0;\\n        int steps = 0;\\n        for(auto i:trace){\\n            if(i==0||i==1)  continue;\\n            int ans = bfs(curI,curJ,forest,i,n,m);\\n            if(ans==-1) return -1;\\n            steps+=ans; \\n        }\\n        return steps;\\n    }\\nprivate:\\n    int bfs(int &curi, int &curj,vector<vector<int>> &forest, int dest,int n, int m){\\n        if(forest[curi][curj]==dest)  return 0;\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        visited[curi][curj]=1;\\n        list<pair<pair<int,int>,int>> q; //i,j, steps\\n        q.push_back({{curi,curj},0});\\n        while(!q.empty()){\\n            \\n            int i = q.front().first.first;\\n            int j = q.front().first.second;\\n            int steps = q.front().second;\\n            q.pop_front();\\n            if(forest[i][j]==dest){\\n                forest[i][j]=1;\\n                curi=i, curj=j;\\n                return steps;\\n            }\\n            if(i+1<n && visited[i+1][j]==0 && forest[i+1][j]!=0){\\n                visited[i+1][j]=1;\\n                q.push_back({{i+1,j},steps+1});\\n            }\\n            if(j+1<m && visited[i][j+1]==0 && forest[i][j+1]!=0){\\n                visited[i][j+1]=1;\\n                q.push_back({{i,j+1},steps+1});\\n            }\\n            if(i-1>=0 && visited[i-1][j]==0 && forest[i-1][j]!=0){\\n                visited[i-1][j]=1;\\n                q.push_back({{i-1,j},steps+1});\\n            }\\n            if(j-1>=0 && visited[i][j-1]==0 && forest[i][j-1]!=0){\\n                visited[i][j-1]=1;\\n                q.push_back({{i,j-1},steps+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091838,
                "title": "c-sort-a-algorithm-with-brief-explanation",
                "content": "Saw a lot of bfs, think I might share my A* shortest path algoritm \\nBasic idea is as follow\\n1. Sort the trees accroding to height, this will be the cut off sequence.\\n2. Find all the shortest path (A* algorithm) starting from 0,0 to the shortest tree, then keeping going to the next taller till the tallest tree.\\n```\\nclass Node{\\n  public:\\n    int value;\\n    int row;\\n    int col;\\n    int fromStart;\\n    int toEnd;\\n    \\n    Node(int row, int col, int value){\\n        this->value = value;\\n        this->row = row;\\n        this->col = col;\\n        this->fromStart = -1;\\n        this->toEnd = -1;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        vector<vector<int>> heights;\\n        vector<vector<Node*>> g(forest.size(),vector<Node*>(forest[0].size(), NULL));\\n\\t\\t//building the A* matrix\\n        for(int i = 0; i < forest.size();i ++){\\n            for(int j = 0; j < forest[0].size();j++){\\n                g[i][j] = new Node(i,j,forest[i][j]);\\n                if(forest[i][j] > 1) heights.push_back({forest[i][j], i,j});\\n            }\\n        }\\n\\t\\t//sort the tree acording to height\\n        sort(heights.begin(),heights.end(),[](vector<int>& v1,vector<int>& v2){return v1[0] < v2[0];});\\n        vector<vector<bool>> seen(forest.size(),vector<bool>(forest[0].size(), false));\\n\\t\\t//from starting point to the shortest tree\\n        int steps = shortestPath(0,0,heights[0][1],heights[0][2], g,seen);\\n        if(steps == -1) return -1;\\n        for(int i = 1; i < heights.size();i++){\\n\\t\\t\\t//find all the shortest path between each tree in the cuting sequence \\n            int step = shortestPath(heights[i-1][1], heights[i-1][2],heights[i][1],heights[i][2], g,seen);\\n\\t\\t\\t//if no path availabe\\n            if(step == -1) return -1;\\n            steps += step;\\n        }\\n        return steps;\\n    }\\n    \\n    int getDist(int x1, int y1, int x2, int y2){\\n        return abs(x1-x2) + abs(y1-y2);\\n    }\\n    \\n\\t//This is pretty standard A* impelmentation , can refer to any materials online\\n    int shortestPath(int startRow, int startCol, int endRow, int endCol, vector<vector<Node*>>& g,vector<vector<bool>>& seen ){\\n         for(int i = 0; i < g.size();i ++){\\n            for(int j = 0; j < g[0].size();j++){\\n                g[i][j]->fromStart = -1;\\n                g[i][j]->toEnd = -1;\\n                seen[i][j] = false;\\n            }\\n        }\\n        vector<int> rowDiff = {-1,1,0,0};\\n        vector<int> colDiff = {0,0,-1,1};\\n        auto comp = [](Node* n1, Node* n2){\\n            if(n2->fromStart + n2->toEnd == n1->fromStart + n1->toEnd){\\n                return n1->fromStart > n2->fromStart;\\n            }else{\\n                return n1->fromStart + n1->toEnd > n2->fromStart + n2->toEnd;\\n            }\\n        };\\n        priority_queue<Node*, vector<Node*>, decltype(comp)> pq(comp);\\n        g[startRow][startCol]->fromStart = 0;\\n        g[startRow][startCol]->toEnd = getDist(startRow,startCol,endRow,endCol);\\n        pq.push(g[startRow][startCol]);\\n        while(!pq.empty()){\\n            Node* curr = pq.top();\\n            pq.pop();\\n            if(seen[curr->row][curr->col]) continue;\\n            seen[curr->row][curr->col] = true;\\n            if(curr->row == endRow && curr->col == endCol) return curr->fromStart;\\n            for(int i = 0; i < 4; i++){\\n                int nextRow = curr->row + rowDiff[i];\\n                int nextCol = curr->col + colDiff[i];\\n                \\n                if(nextRow < 0 || nextRow >= g.size() || nextCol < 0 || nextCol >= g[0].size() || g[nextRow][nextCol]->value == 0 || seen[nextRow][nextCol]) continue;\\n                if(g[nextRow][nextCol]->fromStart == -1){\\n                    g[nextRow][nextCol]->fromStart = curr->fromStart + 1;\\n                    g[nextRow][nextCol]->toEnd = getDist(nextRow,nextCol,endRow,endCol);\\n                    pq.push(g[nextRow][nextCol]);\\n                }else{\\n                    g[nextRow][nextCol]->fromStart = min(g[nextRow][nextCol]->fromStart, curr->fromStart + 1);\\n                    pq.push(g[nextRow][nextCol]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Node{\\n  public:\\n    int value;\\n    int row;\\n    int col;\\n    int fromStart;\\n    int toEnd;\\n    \\n    Node(int row, int col, int value){\\n        this->value = value;\\n        this->row = row;\\n        this->col = col;\\n        this->fromStart = -1;\\n        this->toEnd = -1;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        vector<vector<int>> heights;\\n        vector<vector<Node*>> g(forest.size(),vector<Node*>(forest[0].size(), NULL));\\n\\t\\t//building the A* matrix\\n        for(int i = 0; i < forest.size();i ++){\\n            for(int j = 0; j < forest[0].size();j++){\\n                g[i][j] = new Node(i,j,forest[i][j]);\\n                if(forest[i][j] > 1) heights.push_back({forest[i][j], i,j});\\n            }\\n        }\\n\\t\\t//sort the tree acording to height\\n        sort(heights.begin(),heights.end(),[](vector<int>& v1,vector<int>& v2){return v1[0] < v2[0];});\\n        vector<vector<bool>> seen(forest.size(),vector<bool>(forest[0].size(), false));\\n\\t\\t//from starting point to the shortest tree\\n        int steps = shortestPath(0,0,heights[0][1],heights[0][2], g,seen);\\n        if(steps == -1) return -1;\\n        for(int i = 1; i < heights.size();i++){\\n\\t\\t\\t//find all the shortest path between each tree in the cuting sequence \\n            int step = shortestPath(heights[i-1][1], heights[i-1][2],heights[i][1],heights[i][2], g,seen);\\n\\t\\t\\t//if no path availabe\\n            if(step == -1) return -1;\\n            steps += step;\\n        }\\n        return steps;\\n    }\\n    \\n    int getDist(int x1, int y1, int x2, int y2){\\n        return abs(x1-x2) + abs(y1-y2);\\n    }\\n    \\n\\t//This is pretty standard A* impelmentation , can refer to any materials online\\n    int shortestPath(int startRow, int startCol, int endRow, int endCol, vector<vector<Node*>>& g,vector<vector<bool>>& seen ){\\n         for(int i = 0; i < g.size();i ++){\\n            for(int j = 0; j < g[0].size();j++){\\n                g[i][j]->fromStart = -1;\\n                g[i][j]->toEnd = -1;\\n                seen[i][j] = false;\\n            }\\n        }\\n        vector<int> rowDiff = {-1,1,0,0};\\n        vector<int> colDiff = {0,0,-1,1};\\n        auto comp = [](Node* n1, Node* n2){\\n            if(n2->fromStart + n2->toEnd == n1->fromStart + n1->toEnd){\\n                return n1->fromStart > n2->fromStart;\\n            }else{\\n                return n1->fromStart + n1->toEnd > n2->fromStart + n2->toEnd;\\n            }\\n        };\\n        priority_queue<Node*, vector<Node*>, decltype(comp)> pq(comp);\\n        g[startRow][startCol]->fromStart = 0;\\n        g[startRow][startCol]->toEnd = getDist(startRow,startCol,endRow,endCol);\\n        pq.push(g[startRow][startCol]);\\n        while(!pq.empty()){\\n            Node* curr = pq.top();\\n            pq.pop();\\n            if(seen[curr->row][curr->col]) continue;\\n            seen[curr->row][curr->col] = true;\\n            if(curr->row == endRow && curr->col == endCol) return curr->fromStart;\\n            for(int i = 0; i < 4; i++){\\n                int nextRow = curr->row + rowDiff[i];\\n                int nextCol = curr->col + colDiff[i];\\n                \\n                if(nextRow < 0 || nextRow >= g.size() || nextCol < 0 || nextCol >= g[0].size() || g[nextRow][nextCol]->value == 0 || seen[nextRow][nextCol]) continue;\\n                if(g[nextRow][nextCol]->fromStart == -1){\\n                    g[nextRow][nextCol]->fromStart = curr->fromStart + 1;\\n                    g[nextRow][nextCol]->toEnd = getDist(nextRow,nextCol,endRow,endCol);\\n                    pq.push(g[nextRow][nextCol]);\\n                }else{\\n                    g[nextRow][nextCol]->fromStart = min(g[nextRow][nextCol]->fromStart, curr->fromStart + 1);\\n                    pq.push(g[nextRow][nextCol]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1035499,
                "title": "javascript-short-and-simple-bfs-solution-beats-100",
                "content": "```javascript\\nvar cutOffTree = function(forest) {\\n    const trees = forest.flat().filter(x => x && x !== 1).sort((a, b) => b - a);\\n    let currPos = [0, 0], totalDist = 0;\\n\\n    while(trees.length) {\\n        const grid = [...forest.map(row => [...row])];\\n        const res = getDist(currPos, trees.pop(), grid);\\n        if(res == null) return -1;\\n        const [pos, dist] = res;\\n        currPos = pos;\\n        totalDist += dist;\\n    }\\n    return totalDist;    \\n    \\n    function getDist(start, target, grid) {\\n        const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n        let queue = [start], dist = 0;\\n        \\n        while(queue.length) {\\n            const next = [];\\n            \\n            for(let [r, c] of queue) {\\n                if(grid[r][c] === target) return [[r, c], dist];\\n                if(!grid[r][c]) continue;\\n                \\n                for(let [x, y] of dir) {\\n                    x += r; y += c;\\n                    if(x >= 0 && x < grid.length && y >= 0 && \\n                       y < grid[0].length && grid[x][y]) next.push([x, y])\\n                }\\n                grid[r][c] = 0;   \\n            }\\n            dist++;\\n            queue = next;\\n        }\\n        return null;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar cutOffTree = function(forest) {\\n    const trees = forest.flat().filter(x => x && x !== 1).sort((a, b) => b - a);\\n    let currPos = [0, 0], totalDist = 0;\\n\\n    while(trees.length) {\\n        const grid = [...forest.map(row => [...row])];\\n        const res = getDist(currPos, trees.pop(), grid);\\n        if(res == null) return -1;\\n        const [pos, dist] = res;\\n        currPos = pos;\\n        totalDist += dist;\\n    }\\n    return totalDist;    \\n    \\n    function getDist(start, target, grid) {\\n        const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n        let queue = [start], dist = 0;\\n        \\n        while(queue.length) {\\n            const next = [];\\n            \\n            for(let [r, c] of queue) {\\n                if(grid[r][c] === target) return [[r, c], dist];\\n                if(!grid[r][c]) continue;\\n                \\n                for(let [x, y] of dir) {\\n                    x += r; y += c;\\n                    if(x >= 0 && x < grid.length && y >= 0 && \\n                       y < grid[0].length && grid[x][y]) next.push([x, y])\\n                }\\n                grid[r][c] = 0;   \\n            }\\n            dist++;\\n            queue = next;\\n        }\\n        return null;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931487,
                "title": "simple-c-solution-bfs-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> d = {0, 1, 0, -1, 0};\\n    int minSteps(vector<vector<int>> &f, array<int, 2> src, array<int, 2> dest) {\\n        vector<vector<int>> vis(f.size(), vector<int>(f[0].size(), 0));\\n        queue<array<int, 2>> q;\\n        q.push(src);\\n        vis[src[0]][src[1]] = 1;\\n        int moves = 0;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                auto top = q.front();\\n                q.pop();\\n                if(top == dest) return moves;\\n                for(int i = 0; i < 4; i++) {\\n                    int ni = top[0] + d[i], nj = top[1] + d[i + 1];\\n                    if(ni < 0 || nj < 0 || ni >= f.size() || nj >= f[0].size() || vis[ni][nj] || !f[ni][nj]) continue;\\n                    vis[ni][nj] = 1;\\n                    q.push({ni, nj});\\n                }\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& f) {\\n        int m = f.size(), n = f[0].size();\\n        auto cmp = [&](auto &a, auto &b) {\\n            return f[a[0]][a[1]] > f[b[0]][b[1]];\\n        };\\n        priority_queue<array<int, 2>, vector<array<int, 2>>, decltype(cmp)> pq(cmp);\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!f[i][j] || f[i][j] == 1) continue;\\n                pq.push({i, j});\\n            }\\n        }\\n        int steps = 0;\\n        array<int, 2> last = {0, 0};\\n        while(!pq.empty()) {\\n            int res = minSteps(f, last, pq.top());\\n            if(res == -1) return -1;\\n            steps += res;\\n            last = pq.top();\\n            pq.pop();\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> d = {0, 1, 0, -1, 0};\\n    int minSteps(vector<vector<int>> &f, array<int, 2> src, array<int, 2> dest) {\\n        vector<vector<int>> vis(f.size(), vector<int>(f[0].size(), 0));\\n        queue<array<int, 2>> q;\\n        q.push(src);\\n        vis[src[0]][src[1]] = 1;\\n        int moves = 0;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                auto top = q.front();\\n                q.pop();\\n                if(top == dest) return moves;\\n                for(int i = 0; i < 4; i++) {\\n                    int ni = top[0] + d[i], nj = top[1] + d[i + 1];\\n                    if(ni < 0 || nj < 0 || ni >= f.size() || nj >= f[0].size() || vis[ni][nj] || !f[ni][nj]) continue;\\n                    vis[ni][nj] = 1;\\n                    q.push({ni, nj});\\n                }\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& f) {\\n        int m = f.size(), n = f[0].size();\\n        auto cmp = [&](auto &a, auto &b) {\\n            return f[a[0]][a[1]] > f[b[0]][b[1]];\\n        };\\n        priority_queue<array<int, 2>, vector<array<int, 2>>, decltype(cmp)> pq(cmp);\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!f[i][j] || f[i][j] == 1) continue;\\n                pq.push({i, j});\\n            }\\n        }\\n        int steps = 0;\\n        array<int, 2> last = {0, 0};\\n        while(!pq.empty()) {\\n            int res = minSteps(f, last, pq.top());\\n            if(res == -1) return -1;\\n            steps += res;\\n            last = pq.top();\\n            pq.pop();\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901520,
                "title": "c-sort-bfs",
                "content": "```\\npublic class Solution {\\n    public int CutOffTree(IList<IList<int>> forest) {\\n        var rows = forest.Count;\\n        var ans = 0;\\n        if(rows==0 || forest[0].Count == 0){\\n            return ans;\\n        }\\n        var cols = forest[0].Count;\\n        \\n        var trees = new List<List<int>>();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(forest[i][j]>0){\\n                    trees.Add(new List<int>{forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        trees.Sort((a,b)=>a[0]-b[0]);\\n        var row = 0;\\n        var col = 0;\\n        foreach(var tree in trees){\\n            var res = ShortestPath(forest,row,col,tree[1],tree[2]);\\n           // Console.WriteLine(res+\" \"+tree[0]);\\n            if(res==-1){\\n                return -1;\\n            }\\n            ans+=res;\\n            row = tree[1];\\n            col = tree[2];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int ShortestPath(IList<IList<int>> forest, int i,int j, int fr,int fc){\\n        var m = forest.Count;\\n        var n = forest[0].Count;\\n        var visited = new bool[m,n];\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[]{i,j});\\n        var xDir = new int[]{0,0,1,-1};\\n        var yDir = new int[]{1,-1,0,0};\\n        var ans = 0;\\n        while(queue.Count!=0){\\n            var size = queue.Count;\\n            \\n            for(int k=0;k<size;k++){\\n                var top = queue.Dequeue();\\n                if(top[0]==fr && top[1]==fc){\\n                    return ans;\\n                }\\n                for(int l=0;l<4;l++){\\n                    var nx = top[0]+xDir[l];\\n                    var ny = top[1]+yDir[l];\\n                    if(nx>=m || ny>=n || nx<0 || ny<0 || forest[nx][ny]==0 || visited[nx,ny]){\\n                        continue;\\n                    }\\n                    queue.Enqueue(new int[]{nx,ny});\\n                    visited[nx,ny] = true;\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CutOffTree(IList<IList<int>> forest) {\\n        var rows = forest.Count;\\n        var ans = 0;\\n        if(rows==0 || forest[0].Count == 0){\\n            return ans;\\n        }\\n        var cols = forest[0].Count;\\n        \\n        var trees = new List<List<int>>();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(forest[i][j]>0){\\n                    trees.Add(new List<int>{forest[i][j],i,j});\\n                }\\n            }\\n        }\\n        trees.Sort((a,b)=>a[0]-b[0]);\\n        var row = 0;\\n        var col = 0;\\n        foreach(var tree in trees){\\n            var res = ShortestPath(forest,row,col,tree[1],tree[2]);\\n           // Console.WriteLine(res+\" \"+tree[0]);\\n            if(res==-1){\\n                return -1;\\n            }\\n            ans+=res;\\n            row = tree[1];\\n            col = tree[2];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int ShortestPath(IList<IList<int>> forest, int i,int j, int fr,int fc){\\n        var m = forest.Count;\\n        var n = forest[0].Count;\\n        var visited = new bool[m,n];\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[]{i,j});\\n        var xDir = new int[]{0,0,1,-1};\\n        var yDir = new int[]{1,-1,0,0};\\n        var ans = 0;\\n        while(queue.Count!=0){\\n            var size = queue.Count;\\n            \\n            for(int k=0;k<size;k++){\\n                var top = queue.Dequeue();\\n                if(top[0]==fr && top[1]==fc){\\n                    return ans;\\n                }\\n                for(int l=0;l<4;l++){\\n                    var nx = top[0]+xDir[l];\\n                    var ny = top[1]+yDir[l];\\n                    if(nx>=m || ny>=n || nx<0 || ny<0 || forest[nx][ny]==0 || visited[nx,ny]){\\n                        continue;\\n                    }\\n                    queue.Enqueue(new int[]{nx,ny});\\n                    visited[nx,ny] = true;\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882269,
                "title": "swift-bfs-faster-than-100-less-memory-than-100",
                "content": "```\\nclass Solution {\\n    \\n    func cutOffTree(_ forest: [[Int]]) -> Int {\\n        var trees: [Tree] = []\\n        var forest = forest\\n        \\n        for (row, arr) in forest.enumerated() {\\n            for (col, val) in arr.enumerated() {\\n                if val >= 1 {\\n                    trees.append(Tree(val, Coord(row, col)))\\n                }\\n            }\\n        }\\n        \\n        trees.sort { $0.height < $1.height }\\n        var minSteps = bfs(forest, Coord(0,0),trees[0].coord)\\n        \\n        if trees.count == 1 || minSteps == -1 {return minSteps}\\n        for index in 1..<trees.count {\\n            let lastCoord = trees[index - 1].coord\\n            let minStepsBetweenTrees = bfs(forest, lastCoord, trees[index].coord)\\n            if minStepsBetweenTrees == -1 {\\n                return -1\\n            }\\n            minSteps += minStepsBetweenTrees\\n        }\\n        return minSteps\\n    }\\n    \\n    func bfs(_ grid: [[Int]], _ pos: Coord, _ target: Coord) -> Int {\\n        var grid = grid\\n        var queue: [Coord] = [pos]\\n        var minSteps = 0\\n        let colOffsets = [0,0,-1,1]\\n        let rowOffsets = [-1,1,0,0]\\n        \\n        while !queue.isEmpty {\\n            let queueCount = queue.count\\n\\n            for _ in 0..<queueCount {\\n                let curr = queue.removeFirst()\\n                grid[curr.row][curr.col] = -1\\n                if curr.row == target.row && curr.col == target.col {\\n                    return minSteps\\n                }\\n                \\n                for num in 0..<4 {\\n                    let nextRow = curr.row + rowOffsets[num]\\n                    let nextCol = curr.col + colOffsets[num]\\n                    \\n                    if (0..<grid.count).contains(nextRow) &&\\n                    (0..<grid[0].count).contains(nextCol) &&\\n                    grid[nextRow][nextCol] > 0\\n                     {  \\n                        grid[nextRow][nextCol] = -1\\n                        queue.append(Coord(nextRow, nextCol))\\n                     }\\n                }\\n            }\\n            minSteps += 1\\n        }\\n        return -1\\n    }\\n}\\n\\nstruct Tree {\\n    var height: Int\\n    var coord: Coord\\n    \\n    init(_ height: Int, _ coord: Coord) {\\n        self.height = height\\n        self.coord = coord\\n    }\\n}\\n\\n\\nstruct Coord {\\n    var row: Int\\n    var col: Int\\n    \\n    init(_ row: Int, _ col: Int) {\\n        self.row = row\\n        self.col = col\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func cutOffTree(_ forest: [[Int]]) -> Int {\\n        var trees: [Tree] = []\\n        var forest = forest\\n        \\n        for (row, arr) in forest.enumerated() {\\n            for (col, val) in arr.enumerated() {\\n                if val >= 1 {\\n                    trees.append(Tree(val, Coord(row, col)))\\n                }\\n            }\\n        }\\n        \\n        trees.sort { $0.height < $1.height }\\n        var minSteps = bfs(forest, Coord(0,0),trees[0].coord)\\n        \\n        if trees.count == 1 || minSteps == -1 {return minSteps}\\n        for index in 1..<trees.count {\\n            let lastCoord = trees[index - 1].coord\\n            let minStepsBetweenTrees = bfs(forest, lastCoord, trees[index].coord)\\n            if minStepsBetweenTrees == -1 {\\n                return -1\\n            }\\n            minSteps += minStepsBetweenTrees\\n        }\\n        return minSteps\\n    }\\n    \\n    func bfs(_ grid: [[Int]], _ pos: Coord, _ target: Coord) -> Int {\\n        var grid = grid\\n        var queue: [Coord] = [pos]\\n        var minSteps = 0\\n        let colOffsets = [0,0,-1,1]\\n        let rowOffsets = [-1,1,0,0]\\n        \\n        while !queue.isEmpty {\\n            let queueCount = queue.count\\n\\n            for _ in 0..<queueCount {\\n                let curr = queue.removeFirst()\\n                grid[curr.row][curr.col] = -1\\n                if curr.row == target.row && curr.col == target.col {\\n                    return minSteps\\n                }\\n                \\n                for num in 0..<4 {\\n                    let nextRow = curr.row + rowOffsets[num]\\n                    let nextCol = curr.col + colOffsets[num]\\n                    \\n                    if (0..<grid.count).contains(nextRow) &&\\n                    (0..<grid[0].count).contains(nextCol) &&\\n                    grid[nextRow][nextCol] > 0\\n                     {  \\n                        grid[nextRow][nextCol] = -1\\n                        queue.append(Coord(nextRow, nextCol))\\n                     }\\n                }\\n            }\\n            minSteps += 1\\n        }\\n        return -1\\n    }\\n}\\n\\nstruct Tree {\\n    var height: Int\\n    var coord: Coord\\n    \\n    init(_ height: Int, _ coord: Coord) {\\n        self.height = height\\n        self.coord = coord\\n    }\\n}\\n\\n\\nstruct Coord {\\n    var row: Int\\n    var col: Int\\n    \\n    init(_ row: Int, _ col: Int) {\\n        self.row = row\\n        self.col = col\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873424,
                "title": "java-easy-understanding-bfs",
                "content": "class Solution {\\n   public int cutOffTree(List<List<Integer>> forest) {\\n\\n\\t\\tif (forest == null || forest.size() == 0) {\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tPriorityQueue<Place> placeQ = new PriorityQueue<>(\\n\\t\\t\\t\\tComparator.comparingInt(Place::getValue));\\n\\n\\t\\tfor (int row = 0; row < forest.size(); row++) {\\n\\t\\t\\tfor (int col = 0; col < forest.get(0).size(); col++) {\\n                Place place = new Place(row, col, forest.get(row).get(col));\\n                if(!place.isObs()){\\n                 \\n                    placeQ.add(place);\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint totalSteps = 0;\\n\\n\\t\\tPlace cur = new Place(0,0,forest.get(0).get(0));\\n\\n\\t\\twhile (!placeQ.isEmpty()) {\\n\\n\\t\\t\\tPlace next = placeQ.poll();\\n\\n\\t\\t\\tint steps = searchPlace(cur, next, forest);\\n\\n\\t\\t\\tif (steps == -1) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\ttotalSteps += steps;\\n\\n\\t\\t\\tcur = next;\\n\\t\\t}\\n\\n\\t\\treturn totalSteps == 0 ? -1 : totalSteps;\\n\\t}\\n\\n\\tprivate int searchPlace(Place start, Place end,\\n\\t\\t\\tList<List<Integer>> forest) {\\n\\n\\t\\tif (start.equals(end)) {\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tLinkedList<Place> places = new LinkedList<>();\\n\\t\\tplaces.add(start);\\n\\n\\t\\tint[][] counter = new int[forest.size()][forest.get(0).size()];\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n\\t\\tvisited[start.row][start.col] = true;\\n        counter[start.row][start.col] = 0;\\n\\n\\t\\twhile (!places.isEmpty()) {\\n\\n\\t\\t\\tPlace cur = places.poll();\\n\\n\\t\\t\\tList<Place> neighbours = getNeighbours(cur.row, cur.col, forest, visited);\\n\\n\\t\\t\\tfor (Place p : neighbours) {\\n\\n\\t\\t\\t\\tif (visited[p.row][p.col]) {\\n\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n                \\n                counter[p.row][p.col] = counter[cur.row][cur.col] +1;\\n\\n\\t\\t\\t\\tif (p.equals(end)) {\\n\\n\\t\\t\\t\\t\\treturn counter[p.row][p.col];\\n\\t\\t\\t\\t}\\n                \\n                visited[p.row][p.col] = true;\\n\\n\\t\\t\\t\\tplaces.add(p);   \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tprivate List<Place> getNeighbours(int row, int col,\\n\\t\\t\\tList<List<Integer>> forest, boolean[][] visited) {\\n\\n\\t\\tList<Place> places = new ArrayList<>();\\n\\n\\t\\tgetLeft(row, col, forest, places, visited);\\n\\n\\t\\tgetRight(row, col, forest, places, visited);\\n\\n\\t\\tgetTop(row, col, forest, places, visited);\\n\\n\\t\\tgetBottom(row, col, forest, places, visited);\\n\\n\\t\\treturn places;\\n\\t}\\n\\n\\tprivate void getLeft(int row, int col, List<List<Integer>> forest, List<Place> places, boolean[][] visited) {\\n        \\n        col = col -1;\\n\\n\\t\\tif (col < 0 || visited[row][col]) {\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tPlace place = new Place(row, col, forest.get(row).get(col));\\n\\n\\t\\tif (!place.isObs()) {\\n\\n\\t\\t\\tplaces.add(place);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void getRight(int row, int col, List<List<Integer>> forest, List<Place> places, boolean[][] visited) {\\n        \\n        col = col +1;\\n\\n\\t\\tif (col >= forest.get(0).size() || visited[row][col]) {\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n        \\n\\n\\t\\tPlace place = new Place(row, col, forest.get(row).get(col));\\n\\n\\t\\tif (!place.isObs()) {\\n\\n\\t\\t\\tplaces.add(place);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void getTop(int row, int col, List<List<Integer>> forest, List<Place> places, boolean[][] visited) {\\n        \\n        row = row - 1;\\n        \\n        if (row < 0 || visited[row][col]) {\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n        \\n\\t\\tPlace place = new Place(row, col, forest.get(row).get(col));\\n\\n\\t\\tif (!place.isObs()) {\\n\\n\\t\\t\\tplaces.add(place);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void getBottom(int row, int col, List<List<Integer>> forest, List<Place> places, boolean[][] visited) {\\n        \\n        row = row +1;\\n\\n\\t\\tif (row >= forest.size() || visited[row][col]) {\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tPlace place = new Place(row, col, forest.get(row).get(col));\\n\\n\\t\\tif (!place.isObs()) {\\n\\n\\t\\t\\tplaces.add(place);\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nclass Place {\\n\\tint row;\\n\\tint col;\\n\\tint value;\\n\\tboolean visited;\\n\\n\\tPlace(int row, int col, int value) {\\n\\t\\tthis.row = row;\\n\\t\\tthis.col = col;\\n\\t\\tthis.value = value;\\n\\t}\\n\\n\\tboolean isObs() {\\n\\n\\t\\treturn value == 0;\\n\\t}\\n    \\n    public int getValue(){\\n        \\n        return value;\\n    }\\n\\n\\tpublic boolean equals(Object o) {\\n\\n\\t\\tPlace that = (Place) o;\\n\\n\\t\\treturn this.row == that.row && this.col == that.col;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   public int cutOffTree(List<List<Integer>> forest) {\\n\\n\\t\\tif (forest == null || forest.size() == 0) {\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 848867,
                "title": "python-bfs-solution-not-tle",
                "content": "Python solution, not TLE\\n\\n```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def bfs(sx, sy, tx, ty, target, forest):\\n            \\n            q = collections.deque([(sx, sy)])\\n            step = 0\\n            saved = set()\\n            saved.add((sx, sy))\\n            \\n            while q:\\n                l = len(q)\\n                for _ in range(l):\\n                    cur = q.popleft()\\n                    if cur == (tx, ty):\\n                        return step\\n                    dir = [(0,1), (0,-1),(1,0),(-1,0)]\\n                    \\n                    for dx, dy in dir:\\n                        nx = cur[0] + dx\\n                        ny = cur[1] + dy\\n                        if nx < 0 or ny < 0 or nx >= len(forest) or ny >= len(forest[0]) or forest[nx][ny] == 0 or (nx, ny) in saved:\\n                            continue\\n                        saved.add((nx,ny))\\n                        q.append((nx,ny))\\n                step+=1\\n            \\n            return -1\\n                    \\n            \\n        \\n        m = len(forest[0])\\n        n = len(forest)\\n        tree = []\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if forest[i][j] > 1:\\n                    tree.append((forest[i][j], i, j))\\n        \\n        tree.sort()\\n        sx = 0\\n        sy = 0\\n        ans = 0\\n        \\n        for t in tree:\\n            tx = t[1]\\n            ty = t[2]\\n            target = t[0]\\n            \\n            re = bfs(sx, sy, tx, ty, target, forest)\\n            if re == -1:\\n                return -1\\n            ans += re\\n            \\n            sx, sy = tx, ty\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def bfs(sx, sy, tx, ty, target, forest):\\n            \\n            q = collections.deque([(sx, sy)])\\n            step = 0\\n            saved = set()\\n            saved.add((sx, sy))\\n            \\n            while q:\\n                l = len(q)\\n                for _ in range(l):\\n                    cur = q.popleft()\\n                    if cur == (tx, ty):\\n                        return step\\n                    dir = [(0,1), (0,-1),(1,0),(-1,0)]\\n                    \\n                    for dx, dy in dir:\\n                        nx = cur[0] + dx\\n                        ny = cur[1] + dy\\n                        if nx < 0 or ny < 0 or nx >= len(forest) or ny >= len(forest[0]) or forest[nx][ny] == 0 or (nx, ny) in saved:\\n                            continue\\n                        saved.add((nx,ny))\\n                        q.append((nx,ny))\\n                step+=1\\n            \\n            return -1\\n                    \\n            \\n        \\n        m = len(forest[0])\\n        n = len(forest)\\n        tree = []\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if forest[i][j] > 1:\\n                    tree.append((forest[i][j], i, j))\\n        \\n        tree.sort()\\n        sx = 0\\n        sy = 0\\n        ans = 0\\n        \\n        for t in tree:\\n            tx = t[1]\\n            ty = t[2]\\n            target = t[0]\\n            \\n            re = bfs(sx, sy, tx, ty, target, forest)\\n            if re == -1:\\n                return -1\\n            ans += re\\n            \\n            sx, sy = tx, ty\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839033,
                "title": "python-priorityqueue-bfs",
                "content": "Maintain a priority queue to get the pos of next tree to be cut.\\nThen use BFS to find the minimal steps\\n\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        M, N = len(forest), len(forest[0])\\n        pq = []\\n        for i in range(M):\\n            for j in range(N):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(pq, (forest[i][j], (i, j)))\\n        pos = (0, 0)\\n        steps = 0\\n        \\n        def minimal_path(start, end):\\n            #bfs\\n            q = deque([(start[0], start[1], 0)])\\n            visited = set(start)\\n            while q:\\n                si, sj, step = q.popleft()\\n                if (si, sj) == end:\\n                    return step\\n                diffs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n                for di, dj in diffs:\\n                    ni, nj = si + di, sj + dj\\n                    if ni < 0 or ni >= M or nj < 0 or nj >= N or forest[ni][nj] == 0:\\n                        continue\\n                    if (ni, nj) not in visited:\\n                        visited.add((ni, nj))\\n                        q.append((ni, nj, step + 1))\\n            return -1\\n        \\n        while pq:\\n            val, target = heapq.heappop(pq)\\n            step = minimal_path(pos, target)\\n            pos = target\\n            if step >= 0:\\n                steps += step\\n            else:\\n                return -1\\n        return steps\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        M, N = len(forest), len(forest[0])\\n        pq = []\\n        for i in range(M):\\n            for j in range(N):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(pq, (forest[i][j], (i, j)))\\n        pos = (0, 0)\\n        steps = 0\\n        \\n        def minimal_path(start, end):\\n            #bfs\\n            q = deque([(start[0], start[1], 0)])\\n            visited = set(start)\\n            while q:\\n                si, sj, step = q.popleft()\\n                if (si, sj) == end:\\n                    return step\\n                diffs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n                for di, dj in diffs:\\n                    ni, nj = si + di, sj + dj\\n                    if ni < 0 or ni >= M or nj < 0 or nj >= N or forest[ni][nj] == 0:\\n                        continue\\n                    if (ni, nj) not in visited:\\n                        visited.add((ni, nj))\\n                        q.append((ni, nj, step + 1))\\n            return -1\\n        \\n        while pq:\\n            val, target = heapq.heappop(pq)\\n            step = minimal_path(pos, target)\\n            pos = target\\n            if step >= 0:\\n                steps += step\\n            else:\\n                return -1\\n        return steps\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 816821,
                "title": "java-well-commented-code-bfs",
                "content": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n     \\n        int width = forest.size();\\n        int height = forest.get(0).size();\\n        \\n        // [positionX, positionY, Value]\\n        List<int[]> trees = new ArrayList();\\n        \\n\\t\\t// at first, we need a list trees with their coordinates to be able go to them one-by-one in ascending order\\n        for(int x = 0; x < width; x++) {\\n            for(int y = 0; y < height; y++) {\\n                int val = forest.get(x).get(y);\\n                if(val > 1) {\\n                    trees.add(new int[] {x, y, val});\\n                }\\n            }\\n        }\\n        \\n        // sort tree list ascending\\n        Collections.sort(trees, (a, b) -> a[2] - b[2] );\\n\\n        // all steps (answer)\\n        int steps = 0;\\n        \\n        // current position. We start form [0, 0]\\n        int[] currentPosition = new int[] {0, 0};\\n        \\n        for(int t = 0; t < trees.size(); t++) {\\n            int[] tree = trees.get(t);\\n            int treeX = tree[0];\\n            int treeY = tree[1];\\n            \\n            int[] treePosition = new int[] {treeX, treeY};\\n            int needSteps = howManyStepsDoWeNeed(currentPosition, treePosition, forest);\\n            \\n            // if there is no way to the next tree\\n            if(needSteps == -1) {\\n                return -1;\\n            }\\n            \\n            // cut the tree\\n            forest.get(treeX).remove(treeY);\\n            forest.get(treeX).add(treeY, 1); // \"1\" is grass\\n                \\n            // walk to the next tree\\n            currentPosition = treePosition;\\n                \\n            steps += needSteps;\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    /**\\n    * Looking for the shortes path from `currentPosition` to `treePosition`\\n    * BFS\\n    **/\\n    private int howManyStepsDoWeNeed(int[] currentPosition, int[] treePosition, List<List<Integer>> forest) {\\n        int width = forest.size();\\n        int height = forest.get(0).size();\\n        \\n        // [positionX, positionY]\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList();\\n        Set<Pair<Integer, Integer>> visited = new HashSet();\\n        \\n        // First step (start point)\\n        queue.add(new Pair(currentPosition[0], currentPosition[1]));\\n        visited.add(new Pair(currentPosition[0], currentPosition[1]));\\n        \\n        // calculate how many steps do we need to reach the tree\\n        int steps = 0;\\n        int stepsForThisTreeLevel = queue.size();\\n        \\n        while(!queue.isEmpty()) {\\n            stepsForThisTreeLevel--;\\n            \\n            // current point\\n            Pair<Integer, Integer> point = queue.poll();\\n            \\n            // current position\\n            int x = point.getKey();\\n            int y = point.getValue();\\n        \\n            // if we are on the same coordintates as tree that we need to\\n            if(x == treePosition[0] && y == treePosition[1]) {\\n                return steps;\\n            }\\n        \\n            // step right\\n            if(x + 1 < width) {\\n                Pair<Integer, Integer> newStep = new Pair(x + 1, y);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            // step left\\n            if(x - 1 >= 0) {\\n                Pair<Integer, Integer> newStep = new Pair(x - 1, y);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            // step bottom\\n            if(y + 1 < height) {\\n                Pair<Integer, Integer> newStep = new Pair(x, y + 1);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            // step top\\n            if(y - 1 >= 0) {\\n                Pair<Integer, Integer> newStep = new Pair(x, y - 1);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            \\n            // new level of tree (how many steps we\\'ve done)\\n            if(stepsForThisTreeLevel == 0) {\\n                stepsForThisTreeLevel = queue.size();\\n                steps++;\\n            }\\n        }\\n        \\n        // if we didn\\'t find a right path\\n        return -1;\\n    }\\n    \\n    private boolean canWalk(Pair<Integer, Integer> position, List<List<Integer>> forest) {\\n        return forest.get(position.getKey()).get(position.getValue()) >= 1;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n     \\n        int width = forest.size();\\n        int height = forest.get(0).size();\\n        \\n        // [positionX, positionY, Value]\\n        List<int[]> trees = new ArrayList();\\n        \\n\\t\\t// at first, we need a list trees with their coordinates to be able go to them one-by-one in ascending order\\n        for(int x = 0; x < width; x++) {\\n            for(int y = 0; y < height; y++) {\\n                int val = forest.get(x).get(y);\\n                if(val > 1) {\\n                    trees.add(new int[] {x, y, val});\\n                }\\n            }\\n        }\\n        \\n        // sort tree list ascending\\n        Collections.sort(trees, (a, b) -> a[2] - b[2] );\\n\\n        // all steps (answer)\\n        int steps = 0;\\n        \\n        // current position. We start form [0, 0]\\n        int[] currentPosition = new int[] {0, 0};\\n        \\n        for(int t = 0; t < trees.size(); t++) {\\n            int[] tree = trees.get(t);\\n            int treeX = tree[0];\\n            int treeY = tree[1];\\n            \\n            int[] treePosition = new int[] {treeX, treeY};\\n            int needSteps = howManyStepsDoWeNeed(currentPosition, treePosition, forest);\\n            \\n            // if there is no way to the next tree\\n            if(needSteps == -1) {\\n                return -1;\\n            }\\n            \\n            // cut the tree\\n            forest.get(treeX).remove(treeY);\\n            forest.get(treeX).add(treeY, 1); // \"1\" is grass\\n                \\n            // walk to the next tree\\n            currentPosition = treePosition;\\n                \\n            steps += needSteps;\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    /**\\n    * Looking for the shortes path from `currentPosition` to `treePosition`\\n    * BFS\\n    **/\\n    private int howManyStepsDoWeNeed(int[] currentPosition, int[] treePosition, List<List<Integer>> forest) {\\n        int width = forest.size();\\n        int height = forest.get(0).size();\\n        \\n        // [positionX, positionY]\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList();\\n        Set<Pair<Integer, Integer>> visited = new HashSet();\\n        \\n        // First step (start point)\\n        queue.add(new Pair(currentPosition[0], currentPosition[1]));\\n        visited.add(new Pair(currentPosition[0], currentPosition[1]));\\n        \\n        // calculate how many steps do we need to reach the tree\\n        int steps = 0;\\n        int stepsForThisTreeLevel = queue.size();\\n        \\n        while(!queue.isEmpty()) {\\n            stepsForThisTreeLevel--;\\n            \\n            // current point\\n            Pair<Integer, Integer> point = queue.poll();\\n            \\n            // current position\\n            int x = point.getKey();\\n            int y = point.getValue();\\n        \\n            // if we are on the same coordintates as tree that we need to\\n            if(x == treePosition[0] && y == treePosition[1]) {\\n                return steps;\\n            }\\n        \\n            // step right\\n            if(x + 1 < width) {\\n                Pair<Integer, Integer> newStep = new Pair(x + 1, y);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            // step left\\n            if(x - 1 >= 0) {\\n                Pair<Integer, Integer> newStep = new Pair(x - 1, y);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            // step bottom\\n            if(y + 1 < height) {\\n                Pair<Integer, Integer> newStep = new Pair(x, y + 1);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            // step top\\n            if(y - 1 >= 0) {\\n                Pair<Integer, Integer> newStep = new Pair(x, y - 1);\\n                if(!visited.contains(newStep) && canWalk(newStep, forest)) {\\n                    visited.add(newStep);\\n                    queue.add(newStep);\\n                }\\n            }\\n            \\n            // new level of tree (how many steps we\\'ve done)\\n            if(stepsForThisTreeLevel == 0) {\\n                stepsForThisTreeLevel = queue.size();\\n                steps++;\\n            }\\n        }\\n        \\n        // if we didn\\'t find a right path\\n        return -1;\\n    }\\n    \\n    private boolean canWalk(Pair<Integer, Integer> position, List<List<Integer>> forest) {\\n        return forest.get(position.getKey()).get(position.getValue()) >= 1;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801550,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public int CutOffTree(IList<IList<int>> forest) \\n    {\\n        if(forest[0][0]==0)\\n            return -1;\\n        \\n        List<int[]> trees = new List<int[]>();\\n        \\n        for(int i=0;i<forest.Count;i++)\\n        {\\n            for(int j=0;j<forest[0].Count;j++)\\n            {\\n                if(forest[i][j]>1)\\n                    trees.Add(new int[]{i,j,forest[i][j]});\\n            }\\n        }\\n        \\n        trees.Sort((x,y)=>x[2].CompareTo(y[2]));\\n        int minWalks = 0;\\n        int sr = 0;\\n        int sc = 0;\\n        \\n        foreach(var tree in trees)\\n        {\\n            int dis=Bfs(forest,sr,sc,tree[0],tree[1]);\\n            \\n            if(dis<0)\\n                return -1;\\n            \\n            minWalks+=dis;\\n            sr = tree[0];\\n            sc = tree[1];\\n        }\\n        \\n        \\n        return minWalks;\\n    }\\n    \\n    private int Bfs(IList<IList<int>> forest,int sr,int sc,int dr,int dc)\\n    {\\n        int[,] visited = new int[forest.Count,forest[0].Count];\\n        Queue<(int x,int y)> qu = new Queue<(int x,int y)>();\\n        qu.Enqueue((sr,sc));\\n        visited[sr,sc]=1;\\n        int minWalks = 0;\\n        int[] dx = {-1,1,0,0};\\n        int[] dy = {0,0,-1,1};\\n        \\n        while(qu.Count>0)\\n        {\\n            int cnt = qu.Count;\\n            \\n            for(int i=0;i<cnt;i++)\\n            {\\n                var cur = qu.Dequeue();\\n                \\n                if(cur.x==dr && cur.y==dc)\\n                {\\n                    return minWalks;\\n                }\\n                \\n                for(int d=0;d<4;d++)\\n                {\\n                    int x = cur.x+dx[d];\\n                    int y = cur.y+dy[d];\\n                    \\n                    if(IsValid(forest,x,y) && forest[x][y]>0 && visited[x,y]==0)\\n                    {\\n                        visited[x,y]=1;\\n                        qu.Enqueue((x,y));\\n                    }\\n                }\\n            }\\n            minWalks++;\\n        }\\n        return -1;\\n    }\\n    \\n    private bool IsValid(IList<IList<int>> forest, int x, int y)\\n    {\\n        if(x<0 || x>=forest.Count || y<0 || y>=forest[0].Count)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CutOffTree(IList<IList<int>> forest) \\n    {\\n        if(forest[0][0]==0)\\n            return -1;\\n        \\n        List<int[]> trees = new List<int[]>();\\n        \\n        for(int i=0;i<forest.Count;i++)\\n        {\\n            for(int j=0;j<forest[0].Count;j++)\\n            {\\n                if(forest[i][j]>1)\\n                    trees.Add(new int[]{i,j,forest[i][j]});\\n            }\\n        }\\n        \\n        trees.Sort((x,y)=>x[2].CompareTo(y[2]));\\n        int minWalks = 0;\\n        int sr = 0;\\n        int sc = 0;\\n        \\n        foreach(var tree in trees)\\n        {\\n            int dis=Bfs(forest,sr,sc,tree[0],tree[1]);\\n            \\n            if(dis<0)\\n                return -1;\\n            \\n            minWalks+=dis;\\n            sr = tree[0];\\n            sc = tree[1];\\n        }\\n        \\n        \\n        return minWalks;\\n    }\\n    \\n    private int Bfs(IList<IList<int>> forest,int sr,int sc,int dr,int dc)\\n    {\\n        int[,] visited = new int[forest.Count,forest[0].Count];\\n        Queue<(int x,int y)> qu = new Queue<(int x,int y)>();\\n        qu.Enqueue((sr,sc));\\n        visited[sr,sc]=1;\\n        int minWalks = 0;\\n        int[] dx = {-1,1,0,0};\\n        int[] dy = {0,0,-1,1};\\n        \\n        while(qu.Count>0)\\n        {\\n            int cnt = qu.Count;\\n            \\n            for(int i=0;i<cnt;i++)\\n            {\\n                var cur = qu.Dequeue();\\n                \\n                if(cur.x==dr && cur.y==dc)\\n                {\\n                    return minWalks;\\n                }\\n                \\n                for(int d=0;d<4;d++)\\n                {\\n                    int x = cur.x+dx[d];\\n                    int y = cur.y+dy[d];\\n                    \\n                    if(IsValid(forest,x,y) && forest[x][y]>0 && visited[x,y]==0)\\n                    {\\n                        visited[x,y]=1;\\n                        qu.Enqueue((x,y));\\n                    }\\n                }\\n            }\\n            minWalks++;\\n        }\\n        return -1;\\n    }\\n    \\n    private bool IsValid(IList<IList<int>> forest, int x, int y)\\n    {\\n        if(x<0 || x>=forest.Count || y<0 || y>=forest[0].Count)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798036,
                "title": "python3-bfs-heap-explanation",
                "content": "The tricky part of this problem is: the order of visiting each point is pre-defined! Meaning if I obtain the correct order of points to visit, then simply add up the shortest distance between every two point.\\nFirstly, use heap to store points and its coordinates, so that we could pop out in order of their height;\\nSecond, once we get the coordinates of the next point we want to visit, simply use BFS to find the shortest distance between these two points; If we find that the next point we want to visit is actually unreachable, then we could break and return -1 here.\\nLastly, add the distance to result.\\n\\n```\\nfrom heapq import *\\nDIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not forest or not forest[0]:\\n            return -1\\n        m, n = len(forest), len(forest[0])\\n        heap = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heappush(heap, [forest[i][j], i, j])\\n        \\n        start = [0, 0]\\n        res = 0\\n        while heap:\\n            _, x, y = heappop(heap)\\n            step = self.minStep(forest, start, x, y)\\n            if step < 0:\\n                return -1\\n            res += step\\n            start = [x, y]\\n        return res\\n    \\n    #find the shortest path from cur to target\\n    def minStep(self, forest, start, tx, ty):\\n        queue = collections.deque()\\n        queue.append([start[0], start[1]])\\n        visited = set()\\n        visited.add((start[0], start[1]))\\n        step = -1\\n        while queue:\\n            step += 1\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                if x == tx and y == ty:\\n                    return step\\n                \\n                for dx, dy in DIRECTIONS:\\n                    nx, ny = x + dx, y + dy\\n                    if not self.isValid(forest, nx, ny):\\n                        continue\\n                    if (nx, ny) in visited:\\n                        continue\\n                    visited.add((nx, ny))\\n                    queue.append([nx, ny])\\n        \\n        return -1\\n    \\n    def isValid(self, forest, x, y):\\n        m, n = len(forest), len(forest[0])\\n        if x < 0 or x >= m or y < 0 or y >= n:\\n            return False\\n        \\n        return forest[x][y] != 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\nDIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not forest or not forest[0]:\\n            return -1\\n        m, n = len(forest), len(forest[0])\\n        heap = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heappush(heap, [forest[i][j], i, j])\\n        \\n        start = [0, 0]\\n        res = 0\\n        while heap:\\n            _, x, y = heappop(heap)\\n            step = self.minStep(forest, start, x, y)\\n            if step < 0:\\n                return -1\\n            res += step\\n            start = [x, y]\\n        return res\\n    \\n    #find the shortest path from cur to target\\n    def minStep(self, forest, start, tx, ty):\\n        queue = collections.deque()\\n        queue.append([start[0], start[1]])\\n        visited = set()\\n        visited.add((start[0], start[1]))\\n        step = -1\\n        while queue:\\n            step += 1\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                if x == tx and y == ty:\\n                    return step\\n                \\n                for dx, dy in DIRECTIONS:\\n                    nx, ny = x + dx, y + dy\\n                    if not self.isValid(forest, nx, ny):\\n                        continue\\n                    if (nx, ny) in visited:\\n                        continue\\n                    visited.add((nx, ny))\\n                    queue.append([nx, ny])\\n        \\n        return -1\\n    \\n    def isValid(self, forest, x, y):\\n        m, n = len(forest), len(forest[0])\\n        if x < 0 or x >= m or y < 0 or y >= n:\\n            return False\\n        \\n        return forest[x][y] != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789571,
                "title": "java-using-bfs-simple-solution",
                "content": "```\\nclass Solution {\\n    int [] move_X = new int[]{1, -1, 0, 0};\\n    int [] move_Y = new int[]{0,  0, 1,-1};\\n    \\n    class Node implements Comparable<Node>{\\n        public int val;\\n        public int row;\\n        public int col;\\n        \\n        public Node(int v, int r, int c){\\n            this.val = v;\\n            this.row = r;\\n            this.col = c;\\n        }\\n        \\n        public int compareTo(Node n){\\n            if(this.val > n.val)\\n                return 1;\\n            else if(this.val < n.val)\\n                return -1;\\n            else\\n                return 0;\\n        }\\n    }\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        //solving using BFS\\n        //sort the trees according to their height\\n        List<Node> trees = new ArrayList();\\n        int n = forest.size();\\n        int m = forest.get(0).size();\\n        \\n        for(int i = 0; i< n;i++)\\n        {\\n            for(int j = 0;j<m;j++){\\n                if(forest.get(i).get(j) > 1)\\n                    trees.add(new Node(forest.get(i).get(j), i, j));\\n            }\\n        }\\n        //Sort trees according to their height\\n        Collections.sort(trees);\\n        \\n        //Start search from 0, 0  (d is the distance to find a node)\\n        int ans = 0, d = 0;\\n        Node source = new Node(0,0,0);\\n        for(Node tree : trees)\\n        {           \\n            d = BFS(forest, source, tree, n , m);\\n            if(d == -1)\\n                return -1;\\n            ans += d; \\n            //found the node looking for and the new source will be that node\\n            source.row = tree.row;\\n            source.col = tree.col;\\n        }\\n        return ans;\\n    }\\n    \\n    boolean isSafe(int i, int j, int n, int m){\\n        if(i<0 || j<0 || i>n-1 || j>m-1)\\n            return false;\\n        return true;\\n    }\\n    \\n    public int BFS(List<List<Integer>> forest, Node source, Node target, int n, int m)\\n    {\\n        boolean [][] visited = new boolean[n][m];\\n        visited[source.row][source.col] = true;\\n        //store <source, target, distance travelled>\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[]{source.row, source.col, 0});\\n        while(!q.isEmpty()){\\n            int [] curr = q.poll();\\n            if(curr[0] == target.row && curr[1] == target.col)\\n                return curr[2];\\n            //go through the 4 directions\\n            for(int i=0;i<4;i++){\\n                int row = curr[0] + move_X[i];\\n                int col = curr[1] + move_Y[i];\\n                \\n                if(isSafe(row, col, n , m)){\\n                    if(!visited[row][col] && forest.get(row).get(col) > 0)\\n                    {\\n                        visited[row][col] = true;\\n                        q.add(new int[]{row, col, curr[2] + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [] move_X = new int[]{1, -1, 0, 0};\\n    int [] move_Y = new int[]{0,  0, 1,-1};\\n    \\n    class Node implements Comparable<Node>{\\n        public int val;\\n        public int row;\\n        public int col;\\n        \\n        public Node(int v, int r, int c){\\n            this.val = v;\\n            this.row = r;\\n            this.col = c;\\n        }\\n        \\n        public int compareTo(Node n){\\n            if(this.val > n.val)\\n                return 1;\\n            else if(this.val < n.val)\\n                return -1;\\n            else\\n                return 0;\\n        }\\n    }\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        //solving using BFS\\n        //sort the trees according to their height\\n        List<Node> trees = new ArrayList();\\n        int n = forest.size();\\n        int m = forest.get(0).size();\\n        \\n        for(int i = 0; i< n;i++)\\n        {\\n            for(int j = 0;j<m;j++){\\n                if(forest.get(i).get(j) > 1)\\n                    trees.add(new Node(forest.get(i).get(j), i, j));\\n            }\\n        }\\n        //Sort trees according to their height\\n        Collections.sort(trees);\\n        \\n        //Start search from 0, 0  (d is the distance to find a node)\\n        int ans = 0, d = 0;\\n        Node source = new Node(0,0,0);\\n        for(Node tree : trees)\\n        {           \\n            d = BFS(forest, source, tree, n , m);\\n            if(d == -1)\\n                return -1;\\n            ans += d; \\n            //found the node looking for and the new source will be that node\\n            source.row = tree.row;\\n            source.col = tree.col;\\n        }\\n        return ans;\\n    }\\n    \\n    boolean isSafe(int i, int j, int n, int m){\\n        if(i<0 || j<0 || i>n-1 || j>m-1)\\n            return false;\\n        return true;\\n    }\\n    \\n    public int BFS(List<List<Integer>> forest, Node source, Node target, int n, int m)\\n    {\\n        boolean [][] visited = new boolean[n][m];\\n        visited[source.row][source.col] = true;\\n        //store <source, target, distance travelled>\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[]{source.row, source.col, 0});\\n        while(!q.isEmpty()){\\n            int [] curr = q.poll();\\n            if(curr[0] == target.row && curr[1] == target.col)\\n                return curr[2];\\n            //go through the 4 directions\\n            for(int i=0;i<4;i++){\\n                int row = curr[0] + move_X[i];\\n                int col = curr[1] + move_Y[i];\\n                \\n                if(isSafe(row, col, n , m)){\\n                    if(!visited[row][col] && forest.get(row).get(col) > 0)\\n                    {\\n                        visited[row][col] = true;\\n                        q.add(new int[]{row, col, curr[2] + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685983,
                "title": "c",
                "content": "this is a hard one; I don\\'t think I can do it during interview unless I practice it before.\\n```\\npublic int CutOffTree(IList<IList<int>> forest) {\\n        if(forest == null || forest.Count == 0 || forest[0].Count == 0)  return -1;\\n        var trees = new List<int[]>();\\n        for(int i = 0; i < forest.Count; i++)\\n            for(int j = 0; j < forest[i].Count; j++)\\n                if(forest[i][j] > 1)\\n                    trees.Add(new int[] {forest[i][j], i, j});\\n        \\n        trees.Sort((a,b) => a[0].CompareTo(b[0]));\\n        \\n        int result = 0, x = 0, y = 0;\\n        foreach(var tree in trees)\\n        {\\n            var pathLength = FindPathLength(forest, x, y, tree[1], tree[2]);\\n            if(pathLength < 0) return -1;\\n            forest[tree[1]][tree[2]] = 1;\\n            result += pathLength;\\n            x = tree[1]; y = tree[2];\\n        }\\n        \\n        return result;\\n    }\\n    public int FindPathLength(IList<IList<int>>forest, int sr, int sc, int tr, int tc)     { \\n        int[] dx = new int[]{-1,0,1,0};\\n        int[] dy = new int[]{0,-1,0,1};\\n    \\n        int n = forest.Count;\\n        int m = forest[0].Count;\\n        //bfs\\n        Queue<int[]>queue = new Queue<int[]>();\\n        queue.Enqueue(new int[]{sr,sc,0});\\n        bool[,]seen = new bool[n,m];\\n        seen[sr,sc] = true;\\n        int cut = 0;\\n        while(queue.Any())\\n        {\\n            int[] w = queue.Dequeue();\\n            if (w[0]==tr && w[1]==tc) return w[2];\\n            for(int i = 0; i<4; i++)\\n            {\\n                int x = w[0]+dx[i];\\n                int y = w[1]+dy[i];\\n                if (x>=0 && y>=0 && x<n && y<m && !seen[x,y] && forest[x][y]>0 )\\n                {\\n                   seen[x,y] = true;\\n                   queue.Enqueue(new int[]{x,y, w[2]+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "this is a hard one; I don\\'t think I can do it during interview unless I practice it before.\\n```\\npublic int CutOffTree(IList<IList<int>> forest) {\\n        if(forest == null || forest.Count == 0 || forest[0].Count == 0)  return -1;\\n        var trees = new List<int[]>();\\n        for(int i = 0; i < forest.Count; i++)\\n            for(int j = 0; j < forest[i].Count; j++)\\n                if(forest[i][j] > 1)\\n                    trees.Add(new int[] {forest[i][j], i, j});\\n        \\n        trees.Sort((a,b) => a[0].CompareTo(b[0]));\\n        \\n        int result = 0, x = 0, y = 0;\\n        foreach(var tree in trees)\\n        {\\n            var pathLength = FindPathLength(forest, x, y, tree[1], tree[2]);\\n            if(pathLength < 0) return -1;\\n            forest[tree[1]][tree[2]] = 1;\\n            result += pathLength;\\n            x = tree[1]; y = tree[2];\\n        }\\n        \\n        return result;\\n    }\\n    public int FindPathLength(IList<IList<int>>forest, int sr, int sc, int tr, int tc)     { \\n        int[] dx = new int[]{-1,0,1,0};\\n        int[] dy = new int[]{0,-1,0,1};\\n    \\n        int n = forest.Count;\\n        int m = forest[0].Count;\\n        //bfs\\n        Queue<int[]>queue = new Queue<int[]>();\\n        queue.Enqueue(new int[]{sr,sc,0});\\n        bool[,]seen = new bool[n,m];\\n        seen[sr,sc] = true;\\n        int cut = 0;\\n        while(queue.Any())\\n        {\\n            int[] w = queue.Dequeue();\\n            if (w[0]==tr && w[1]==tc) return w[2];\\n            for(int i = 0; i<4; i++)\\n            {\\n                int x = w[0]+dx[i];\\n                int y = w[1]+dy[i];\\n                if (x>=0 && y>=0 && x<n && y<m && !seen[x,y] && forest[x][y]>0 )\\n                {\\n                   seen[x,y] = true;\\n                   queue.Enqueue(new int[]{x,y, w[2]+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 630449,
                "title": "python-3-3-steps",
                "content": "```\\n\\'\\'\\'\\n1. map the tree heights in ascending order to their position, hi: (ri, ci)\\n2. find shortest distance to (ri, ci)... if shortest distance = -1, return -1 immediately\\n3. use bfs for calculating shortest distance\\n\\'\\'\\'\\nclass Solution:\\n    def __init__(self):\\n        self.dirs = ((0,1), (0, -1), (1, 0), (-1, 0))\\n        self.n, self.m = 0, 0\\n\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        self.n, self.m = len(forest), len(forest[0])\\n        l = []\\n        for i, row in enumerate(forest):\\n            for j, val in enumerate(row):\\n                if val > 1:\\n                    l.append((val, (i, j)))\\n        l.sort(key = lambda x: x[0])\\n        at, ret = (0, 0), 0\\n        for _, to in l:\\n            distance = self.shortest_distance(at, to, forest)\\n            if distance == -1:\\n                return -1\\n            ret += distance\\n            at = to\\n        return ret\\n\\n    def shortest_distance(self, at, to, forest):\\n        if at == to:\\n            return 0\\n        ret = 0\\n        q = deque()\\n        q.append(at)\\n        vis = set()\\n        vis.add(at)\\n        while q:\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                for dx, dy in self.dirs:\\n                    x, y = cur[0] + dx, cur[1] + dy\\n                    if x < 0 or x >= self.n or y < 0 or y >= self.m or (x, y) in vis or forest[x][y] == 0:\\n                        continue\\n                    if (x, y) == to:\\n                        return ret + 1\\n                    else:\\n                        q.append((x, y))\\n                        vis.add((x, y))\\n            ret += 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\n1. map the tree heights in ascending order to their position, hi: (ri, ci)\\n2. find shortest distance to (ri, ci)... if shortest distance = -1, return -1 immediately\\n3. use bfs for calculating shortest distance\\n\\'\\'\\'\\nclass Solution:\\n    def __init__(self):\\n        self.dirs = ((0,1), (0, -1), (1, 0), (-1, 0))\\n        self.n, self.m = 0, 0\\n\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        self.n, self.m = len(forest), len(forest[0])\\n        l = []\\n        for i, row in enumerate(forest):\\n            for j, val in enumerate(row):\\n                if val > 1:\\n                    l.append((val, (i, j)))\\n        l.sort(key = lambda x: x[0])\\n        at, ret = (0, 0), 0\\n        for _, to in l:\\n            distance = self.shortest_distance(at, to, forest)\\n            if distance == -1:\\n                return -1\\n            ret += distance\\n            at = to\\n        return ret\\n\\n    def shortest_distance(self, at, to, forest):\\n        if at == to:\\n            return 0\\n        ret = 0\\n        q = deque()\\n        q.append(at)\\n        vis = set()\\n        vis.add(at)\\n        while q:\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                for dx, dy in self.dirs:\\n                    x, y = cur[0] + dx, cur[1] + dy\\n                    if x < 0 or x >= self.n or y < 0 or y >= self.m or (x, y) in vis or forest[x][y] == 0:\\n                        continue\\n                    if (x, y) == to:\\n                        return ret + 1\\n                    else:\\n                        q.append((x, y))\\n                        vis.add((x, y))\\n            ret += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486653,
                "title": "javascript-solution-bfs-with-comments",
                "content": "```javascript\\n/**\\n * @param {number[][]} forest\\n * @return {number}\\n */\\nvar cutOffTree = function(forest) {\\n    const R = forest.length;\\n    const C = forest[0].length;\\n    \\n    const sortedTrees = sortTreesByHeight(forest);\\n    \\n    let sr = 0, sc = 0; // start node.\\n    let steps = 0; // steps taken to cut all trees.\\n    \\n    while (sortedTrees.length) {\\n        const [tr, tc] = sortedTrees.shift();\\n        \\n        // run BFS from start to target node.\\n        const partialSteps = cutOffTreeBfs(forest, sr, sc, tr, tc);\\n        \\n        if (partialSteps >= 0) {\\n            // increment steps by partialSteps, and set the start \\n            // node of the BFS to be the target we just reached.\\n            steps += partialSteps;\\n            sr = tr;\\n            sc = tc;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    return steps;\\n};\\n\\nfunction sortTreesByHeight(forest) {\\n    const trees = [];\\n    for (let i = 0; i < forest.length; i++) {\\n        for (let j = 0; j < forest[0].length; j++) {\\n            if (forest[i][j] > 1) {\\n                trees.push([i, j, forest[i][j]]);\\n            }\\n        }\\n    }\\n    // sort height from smallest to biggest.\\n    trees.sort((x, y) => x[2] - y[2]);\\n    return trees;\\n}\\n\\nfunction cutOffTreeBfs(forest, sr, sc, tr, tc) {\\n    const R = forest.length;\\n    const C = forest[0].length;\\n    \\n    // add start node to the queue with a dist of 0.\\n    const queue = [[sr, sc, 0]];\\n    \\n    // create visited matrix and initialize it to false.\\n    const visited = new Array(R);\\n    for (let i = 0; i < R; i++) {\\n        visited[i] = new Array(C).fill(false);\\n    }\\n    \\n    // mark the start node as visited.\\n    visited[sr][sc] = true;\\n    \\n    \\n    while (queue.length) {\\n        const [r, c, dist] = queue.shift();\\n        \\n        // if we reached the target, return the distance so far.\\n        if (r == tr && c === tc) {\\n            return dist;\\n        }\\n        \\n        // get the neighbors of the current node, \\n        // getNeighbors will return only valid neighbors.\\n        const neighbors = getNeighbors(R, C, forest, visited, r, c);\\n        \\n        for (const [nr, nc] of neighbors) {\\n            visited[nr][nc] = true;\\n            // add neighbor to the queue \\n            // and set its distance by current dist plus 1.\\n            queue.push([nr, nc, dist + 1]);\\n        }\\n    }\\n    \\n    return -1;\\n}\\n\\nfunction getNeighbors(R, C, forest, visited, r, c) {\\n    const neighbors = [];\\n    // direction vectors for moving in the matrix.\\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n    \\n    for (let i = 0; i < directions.length; i++) {\\n        const nr = r + directions[i][0];\\n        const nc = c + directions[i][1];\\n        // add only valid nodes.\\n        if (isValid(R, C, forest, visited, nr, nc)) {\\n            neighbors.push([nr, nc]);\\n        }\\n    }\\n    return neighbors;\\n}\\n\\nfunction isValid(R, C, forest, visited, r, c) {\\n    const inBounds = r >= 0 && r < R && c >= 0 && c < C;\\n    if (!inBounds || visited[r][c]) return false;\\n    // valid node = not visited and not an obstacle;\\n    return !visited[r][c] && forest[r][c] !== 0; \\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} forest\\n * @return {number}\\n */\\nvar cutOffTree = function(forest) {\\n    const R = forest.length;\\n    const C = forest[0].length;\\n    \\n    const sortedTrees = sortTreesByHeight(forest);\\n    \\n    let sr = 0, sc = 0; // start node.\\n    let steps = 0; // steps taken to cut all trees.\\n    \\n    while (sortedTrees.length) {\\n        const [tr, tc] = sortedTrees.shift();\\n        \\n        // run BFS from start to target node.\\n        const partialSteps = cutOffTreeBfs(forest, sr, sc, tr, tc);\\n        \\n        if (partialSteps >= 0) {\\n            // increment steps by partialSteps, and set the start \\n            // node of the BFS to be the target we just reached.\\n            steps += partialSteps;\\n            sr = tr;\\n            sc = tc;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    return steps;\\n};\\n\\nfunction sortTreesByHeight(forest) {\\n    const trees = [];\\n    for (let i = 0; i < forest.length; i++) {\\n        for (let j = 0; j < forest[0].length; j++) {\\n            if (forest[i][j] > 1) {\\n                trees.push([i, j, forest[i][j]]);\\n            }\\n        }\\n    }\\n    // sort height from smallest to biggest.\\n    trees.sort((x, y) => x[2] - y[2]);\\n    return trees;\\n}\\n\\nfunction cutOffTreeBfs(forest, sr, sc, tr, tc) {\\n    const R = forest.length;\\n    const C = forest[0].length;\\n    \\n    // add start node to the queue with a dist of 0.\\n    const queue = [[sr, sc, 0]];\\n    \\n    // create visited matrix and initialize it to false.\\n    const visited = new Array(R);\\n    for (let i = 0; i < R; i++) {\\n        visited[i] = new Array(C).fill(false);\\n    }\\n    \\n    // mark the start node as visited.\\n    visited[sr][sc] = true;\\n    \\n    \\n    while (queue.length) {\\n        const [r, c, dist] = queue.shift();\\n        \\n        // if we reached the target, return the distance so far.\\n        if (r == tr && c === tc) {\\n            return dist;\\n        }\\n        \\n        // get the neighbors of the current node, \\n        // getNeighbors will return only valid neighbors.\\n        const neighbors = getNeighbors(R, C, forest, visited, r, c);\\n        \\n        for (const [nr, nc] of neighbors) {\\n            visited[nr][nc] = true;\\n            // add neighbor to the queue \\n            // and set its distance by current dist plus 1.\\n            queue.push([nr, nc, dist + 1]);\\n        }\\n    }\\n    \\n    return -1;\\n}\\n\\nfunction getNeighbors(R, C, forest, visited, r, c) {\\n    const neighbors = [];\\n    // direction vectors for moving in the matrix.\\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n    \\n    for (let i = 0; i < directions.length; i++) {\\n        const nr = r + directions[i][0];\\n        const nc = c + directions[i][1];\\n        // add only valid nodes.\\n        if (isValid(R, C, forest, visited, nr, nc)) {\\n            neighbors.push([nr, nc]);\\n        }\\n    }\\n    return neighbors;\\n}\\n\\nfunction isValid(R, C, forest, visited, r, c) {\\n    const inBounds = r >= 0 && r < R && c >= 0 && c < C;\\n    if (!inBounds || visited[r][c]) return false;\\n    // valid node = not visited and not an obstacle;\\n    return !visited[r][c] && forest[r][c] !== 0; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 465996,
                "title": "python-a-90-79",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:                \\n        def astar(forest, passable, ibeg, jbeg, iend, jend):\\n            h, w = len(forest), len(forest[0])\\n            \\n            seen = {(ibeg, jbeg)}\\n            heap = [(0, 0, ibeg, jbeg)]\\n                        \\n            while heap:\\n                _, traveled, i, j = heapq.heappop(heap)\\n                if i == iend and j == jend:\\n                    return traveled\\n\\n                for cords in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                    if cords not in seen and cords in passable:\\n                        ni, nj = cords\\n                        seen.add(cords)\\n                        weight = traveled + 1 + abs(ni - iend) + abs(nj - jend)\\n                        heapq.heappush(heap, (weight, traveled + 1, ni, nj))\\n            return -1\\n\\n        passable = set()\\n        trees = []\\n        for i, row in enumerate(forest):\\n            for j, val in enumerate(row):\\n                if val > 0:\\n                    passable.add((i, j))\\n                    if val > 1:\\n                        trees.append((val, i, j))\\n\\n        path = 0\\n        ibeg, jbeg = 0, 0\\n        for _, iend, jend in sorted(trees):\\n            segmentPath = astar(forest, passable, ibeg, jbeg, iend, jend)\\n            if segmentPath < 0:\\n                return -1\\n            \\n            path += segmentPath\\n            ibeg, jbeg = iend, jend\\n            \\n        return path\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:                \\n        def astar(forest, passable, ibeg, jbeg, iend, jend):\\n            h, w = len(forest), len(forest[0])\\n            \\n            seen = {(ibeg, jbeg)}\\n            heap = [(0, 0, ibeg, jbeg)]\\n                        \\n            while heap:\\n                _, traveled, i, j = heapq.heappop(heap)\\n                if i == iend and j == jend:\\n                    return traveled\\n\\n                for cords in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                    if cords not in seen and cords in passable:\\n                        ni, nj = cords\\n                        seen.add(cords)\\n                        weight = traveled + 1 + abs(ni - iend) + abs(nj - jend)\\n                        heapq.heappush(heap, (weight, traveled + 1, ni, nj))\\n            return -1\\n\\n        passable = set()\\n        trees = []\\n        for i, row in enumerate(forest):\\n            for j, val in enumerate(row):\\n                if val > 0:\\n                    passable.add((i, j))\\n                    if val > 1:\\n                        trees.append((val, i, j))\\n\\n        path = 0\\n        ibeg, jbeg = 0, 0\\n        for _, iend, jend in sorted(trees):\\n            segmentPath = astar(forest, passable, ibeg, jbeg, iend, jend)\\n            if segmentPath < 0:\\n                return -1\\n            \\n            path += segmentPath\\n            ibeg, jbeg = iend, jend\\n            \\n        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449346,
                "title": "python3-bfs-and-a-star",
                "content": "# BFS\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        Valid_target=sorted([(val,r,c)for r,row in enumerate(forest) for c,val in enumerate(row) if val>1],key=lambda x:x[0])\\n        sc=sr=ans=0\\n        \\n        for x in Valid_target:\\n            _,tr,tc=x\\n            d=self.dist_bfs(forest,sr,sc,tr,tc)\\n            if d<0:return -1\\n            ans+=d\\n            sr,sc=tr,tc\\n        return ans\\n            \\n    def dist_bfs(self,forest,sr,sc,tr,tc):\\n        R,C=len(forest),len(forest[0])\\n        Queue=collections.deque([(sr,sc,0)])\\n        seen={(sr,sc)}\\n        \\n        while Queue:\\n            r,c,d=Queue.popleft()\\n            \\n            if tr==r and tc==c: return d\\n            \\n            for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\\n                if 0<=nr<R and 0<=nc<C and (nr,nc) not in seen and forest[nr][nc]:\\n                    seen.add((nr,nc))\\n                    Queue.append((nr,nc,d+1))\\n        return -1\\n```\\n\\n# A star\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        Valid_target=sorted([(val,r,c)for r,row in enumerate(forest) for c,val in enumerate(row) if val>1],key=lambda x:x[0])\\n        sc=sr=ans=0\\n        \\n        for x in Valid_target:\\n            _,tr,tc=x\\n            d=self.dist_Astar(forest,sr,sc,tr,tc)\\n            if d<0:return -1\\n            ans+=d\\n            sr,sc=tr,tc\\n        return ans\\n            \\n    def dist_Astar(self,forest,sr,sc,tr,tc):\\n        R,C=len(forest),len(forest[0])\\n        heap=[(0,0,sr,sc)]\\n        cost={(sr,sc):0}\\n        \\n        while heap:\\n            f,g,r,c=heapq.heappop(heap)\\n            \\n            if tr==r and tc==c: return g\\n            \\n            for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\\n                if 0<=nr<R and 0<=nc<C and forest[nr][nc]:\\n                    New_cost=g+1+abs(nr-tr)+abs(nc-tr)\\n                    if New_cost<cost.get((nr,nc),99999):\\n                        cost[(nr,nc)]=New_cost\\n                        heapq.heappush(heap,(New_cost,g+1,nr,nc))\\n        return -1\\n```\\n\\n*Advantage of A star over BFS:*\\nA star uses a Heuristic, which helps get A star a sense of direction towards goal/target while bfs traverse through its neighbor and their neighbor and so on without any smartness/ Heuristic. This can create a lot of speed difference.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        Valid_target=sorted([(val,r,c)for r,row in enumerate(forest) for c,val in enumerate(row) if val>1],key=lambda x:x[0])\\n        sc=sr=ans=0\\n        \\n        for x in Valid_target:\\n            _,tr,tc=x\\n            d=self.dist_bfs(forest,sr,sc,tr,tc)\\n            if d<0:return -1\\n            ans+=d\\n            sr,sc=tr,tc\\n        return ans\\n            \\n    def dist_bfs(self,forest,sr,sc,tr,tc):\\n        R,C=len(forest),len(forest[0])\\n        Queue=collections.deque([(sr,sc,0)])\\n        seen={(sr,sc)}\\n        \\n        while Queue:\\n            r,c,d=Queue.popleft()\\n            \\n            if tr==r and tc==c: return d\\n            \\n            for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\\n                if 0<=nr<R and 0<=nc<C and (nr,nc) not in seen and forest[nr][nc]:\\n                    seen.add((nr,nc))\\n                    Queue.append((nr,nc,d+1))\\n        return -1\\n```\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        Valid_target=sorted([(val,r,c)for r,row in enumerate(forest) for c,val in enumerate(row) if val>1],key=lambda x:x[0])\\n        sc=sr=ans=0\\n        \\n        for x in Valid_target:\\n            _,tr,tc=x\\n            d=self.dist_Astar(forest,sr,sc,tr,tc)\\n            if d<0:return -1\\n            ans+=d\\n            sr,sc=tr,tc\\n        return ans\\n            \\n    def dist_Astar(self,forest,sr,sc,tr,tc):\\n        R,C=len(forest),len(forest[0])\\n        heap=[(0,0,sr,sc)]\\n        cost={(sr,sc):0}\\n        \\n        while heap:\\n            f,g,r,c=heapq.heappop(heap)\\n            \\n            if tr==r and tc==c: return g\\n            \\n            for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\\n                if 0<=nr<R and 0<=nc<C and forest[nr][nc]:\\n                    New_cost=g+1+abs(nr-tr)+abs(nc-tr)\\n                    if New_cost<cost.get((nr,nc),99999):\\n                        cost[(nr,nc)]=New_cost\\n                        heapq.heappush(heap,(New_cost,g+1,nr,nc))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438922,
                "title": "bfs-solution-in-python-no-tle",
                "content": "```\\n\"\"\"\\nalg:\\n1. find all trees and their coordinates, sorted by height ascending\\n2. BFS from 0,0 to min\\'s coordinate; from min to sec min and so on; record steps taken\\n3. returns -1 if blocked\\n4. return total steps\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        def bfs(start, stop):\\n            if start == stop:\\n                return 0\\n            \\n            queue = deque([start])\\n            directions = [(0,1), (0,-1), (1,0), (-1,0)]\\n            steps = 0\\n            visited = set()\\n            visited.add(start)\\n            while queue:\\n                size = len(queue)\\n                steps += 1\\n                while size:\\n                    x, y = queue.popleft()\\n                    for dx, dy in directions:\\n                        if 0<=x+dx<rows and 0<=y+dy<cols and forest[x+dx][y+dy] and (x+dx, y+dy) not in visited:\\n                            if x+dx == stop[0] and y+dy == stop[1]:\\n                                return steps\\n                            queue.append((x+dx, y+dy))\\n                            visited.add((x+dx, y+dy))\\n                    size -= 1\\n            return -1\\n        \\n        \\n        rows = len(forest)\\n        cols = len(forest[0])\\n        trees = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                if forest[i][j] > 1:\\n                    trees.append((forest[i][j], (i, j)))\\n        trees.sort(key=lambda x: x[0])\\n        checkpoints = [(0, 0)] + [tree[1] for tree in trees]\\n\\n        steps = 0\\n        for i in range(len(checkpoints)-1):\\n            cur_step = bfs(checkpoints[i], checkpoints[i+1])\\n            if cur_step != -1:\\n                steps += cur_step\\n            else:\\n                return -1\\n            \\n        return steps\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nalg:\\n1. find all trees and their coordinates, sorted by height ascending\\n2. BFS from 0,0 to min\\'s coordinate; from min to sec min and so on; record steps taken\\n3. returns -1 if blocked\\n4. return total steps\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        def bfs(start, stop):\\n            if start == stop:\\n                return 0\\n            \\n            queue = deque([start])\\n            directions = [(0,1), (0,-1), (1,0), (-1,0)]\\n            steps = 0\\n            visited = set()\\n            visited.add(start)\\n            while queue:\\n                size = len(queue)\\n                steps += 1\\n                while size:\\n                    x, y = queue.popleft()\\n                    for dx, dy in directions:\\n                        if 0<=x+dx<rows and 0<=y+dy<cols and forest[x+dx][y+dy] and (x+dx, y+dy) not in visited:\\n                            if x+dx == stop[0] and y+dy == stop[1]:\\n                                return steps\\n                            queue.append((x+dx, y+dy))\\n                            visited.add((x+dx, y+dy))\\n                    size -= 1\\n            return -1\\n        \\n        \\n        rows = len(forest)\\n        cols = len(forest[0])\\n        trees = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                if forest[i][j] > 1:\\n                    trees.append((forest[i][j], (i, j)))\\n        trees.sort(key=lambda x: x[0])\\n        checkpoints = [(0, 0)] + [tree[1] for tree in trees]\\n\\n        steps = 0\\n        for i in range(len(checkpoints)-1):\\n            cur_step = bfs(checkpoints[i], checkpoints[i+1])\\n            if cur_step != -1:\\n                steps += cur_step\\n            else:\\n                return -1\\n            \\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416498,
                "title": "c-32ms-9-2mb-twice-fast-than-anyone-else",
                "content": "Surely you can make the code more OOP, put global things into class. cost 48ms without `static`\\n\\nIf you want good performance, don\\'t use `std::deque` when you know the exact size you need. It will cost both a lot more memory and time. And you can\\'t even use something like `reserve` to solve the problem.\\n\\nThe result when using std::deque is 64ms & 57MB\\n\\n```\\nstruct Node{\\n        int r, c, d;\\n        bool operator<(const Node& n) const{\\n            return (d < n.d);\\n        }\\n    };\\n\\nint direct[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\nNode* dq=new Node[3000];\\nNode* dqf,*dqb;\\nvector<Node> v;\\nchar mask[2500];\\n\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        R = forest.size(); C = forest[0].size();\\n        v.clear();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest[i].size(); j++) {\\n                if (forest[i][j] > 1) {\\n                    Node n={i, j, forest[i][j]}; \\n                    v.push_back(n);\\n                }                \\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        int ans = 0;\\n        Node cur={0, 0, 1};\\n        for (int i = 0; i < v.size(); i++) {\\n            int step = hadlock(forest, cur.r, cur.c, v[i].r, v[i].c);\\n            if (step < 0) {\\n                return -1;\\n            }\\n            \\n            ans += step;\\n            cur = v[i];\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int R, C;\\n    int hadlock(vector<vector<int>>& forest, int sr, int sc, int tr, int tc) {    \\n        dqf=dqb=dq+500;\\n        Node cur={sr, sc, 0};\\n        *dqb=cur;\\n        ++dqb;\\n        memset(mask,0,R*C);\\n        while (dqf!=dqb) {\\n            Node n = *dqf;\\n            ++dqf;\\n            if (mask[n.r*C+n.c]) {\\n                continue;\\n            }\\n            mask[n.r*C+n.c] = true;\\n            if (n.r == tr && n.c == tc) {\\n                return abs(sr - tr) + abs(sc - tc) + 2*n.d;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int nr = n.r + direct[i][0];\\n                int nc = n.c + direct[i][1];\\n                if (nr >= 0 && nr < R && nc >= 0 && nc < C && forest[nr][nc] > 0) {\\n                    bool closer = abs(n.r - tr) > abs(nr - tr) || abs(n.c - tc) > abs(nc - tc);\\n                    if (closer) {\\n                        *(--dqf)={nr, nc, n.d};\\n                    }\\n                    else {\\n                        *(dqb++)={nr, nc, n.d+1};\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n        int r, c, d;\\n        bool operator<(const Node& n) const{\\n            return (d < n.d);\\n        }\\n    };\\n\\nint direct[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\nNode* dq=new Node[3000];\\nNode* dqf,*dqb;\\nvector<Node> v;\\nchar mask[2500];\\n\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        R = forest.size(); C = forest[0].size();\\n        v.clear();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest[i].size(); j++) {\\n                if (forest[i][j] > 1) {\\n                    Node n={i, j, forest[i][j]}; \\n                    v.push_back(n);\\n                }                \\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        int ans = 0;\\n        Node cur={0, 0, 1};\\n        for (int i = 0; i < v.size(); i++) {\\n            int step = hadlock(forest, cur.r, cur.c, v[i].r, v[i].c);\\n            if (step < 0) {\\n                return -1;\\n            }\\n            \\n            ans += step;\\n            cur = v[i];\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int R, C;\\n    int hadlock(vector<vector<int>>& forest, int sr, int sc, int tr, int tc) {    \\n        dqf=dqb=dq+500;\\n        Node cur={sr, sc, 0};\\n        *dqb=cur;\\n        ++dqb;\\n        memset(mask,0,R*C);\\n        while (dqf!=dqb) {\\n            Node n = *dqf;\\n            ++dqf;\\n            if (mask[n.r*C+n.c]) {\\n                continue;\\n            }\\n            mask[n.r*C+n.c] = true;\\n            if (n.r == tr && n.c == tc) {\\n                return abs(sr - tr) + abs(sc - tc) + 2*n.d;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int nr = n.r + direct[i][0];\\n                int nc = n.c + direct[i][1];\\n                if (nr >= 0 && nr < R && nc >= 0 && nc < C && forest[nr][nc] > 0) {\\n                    bool closer = abs(n.r - tr) > abs(nr - tr) || abs(n.c - tc) > abs(nc - tc);\\n                    if (closer) {\\n                        *(--dqf)={nr, nc, n.d};\\n                    }\\n                    else {\\n                        *(dqb++)={nr, nc, n.d+1};\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361638,
                "title": "javascript-with-bfs",
                "content": "```\\n/**\\n * @param {number[][]} forest\\n * @return {number}\\n */\\nvar cutOffTree = function(forest) {\\n    \\n    // first we want to find the end node. which is the highest tree.\\n    \\n    // then we\\'re going to do \\n    const trees = findAllTrees(forest);\\n    let location = {x: 0, y: 0, pathLength: 0};\\n    let distance = 0;\\n    while (trees.length) {\\n        let tree = trees.pop();\\n        let travelled = bfs(forest, location.x, location.y, tree.x, tree.y);\\n        if (travelled >= 0) {\\n            distance += travelled;    \\n            location = {x: tree.x, y: tree.y};\\n        } else {\\n            return -1;\\n        }\\n    }\\n    return distance;\\n      \\n\\n\\n};\\n\\nfunction bfs(forest, sX, sY, eX, eY){\\n    const xLength = forest.length;\\n    const yLength = forest[0].length;\\n    const visited = createVisitedMatrix(xLength, yLength);\\n    const queue = [];\\n    queue.unshift({x: sX, y: sY, pathLength: 0});\\n    while(queue.length > 0){\\n        const field = queue.pop();\\n        if(field.x < 0 || field.x >= xLength || field.y < 0 || field.y >= yLength){\\n            continue; // isn\\'t a valid path to the matrix.\\n        }\\n        if(visited[field.x][field.y]){\\n            continue;\\n        }\\n        visited[field.x][field.y] = true;\\n        if(forest[field.x][field.y] == 0){\\n            continue;\\n        }\\n        \\n        if(field.x == eX && field.y == eY){\\n            return field.pathLength;\\n        }\\n        // add the next ones;\\n        queue.unshift({x: field.x -1, y: field.y, pathLength: field.pathLength +1});\\n        queue.unshift({x: field.x, y: field.y +1, pathLength: field.pathLength +1});\\n        queue.unshift({x: field.x +1, y: field.y, pathLength: field.pathLength +1});\\n        queue.unshift({x: field.x, y: field.y -1, pathLength: field.pathLength +1});\\n\\n    }\\n    \\n    return -1;\\n}\\n// creates a matrix \\nfunction createVisitedMatrix(x, y){\\n    const matrix = new Array(x);\\n    for(let i = 0; i< x;i++){\\n        matrix[i] = [];\\n        for(let j=0; j< y;j++){\\n            matrix[i].push(false);\\n        }\\n    }\\n    return matrix;\\n}\\n// Finds all trees in the matrix and sort\\'s them by descending height\\nfunction findAllTrees(forest){\\n    if(!forest) return;\\n    let trees = [];\\n    for(let i = 0; i < forest.length; i++){\\n        for(let j=0;j<forest[i].length;j++){\\n            if(forest[i][j] > 1){\\n                trees.push({x: i, y: j, height: forest[i][j]});\\n            }\\n        }\\n    }\\n    trees.sort((a,b)=>b.height - a.height);\\n    return trees;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} forest\\n * @return {number}\\n */\\nvar cutOffTree = function(forest) {\\n    \\n    // first we want to find the end node. which is the highest tree.\\n    \\n    // then we\\'re going to do \\n    const trees = findAllTrees(forest);\\n    let location = {x: 0, y: 0, pathLength: 0};\\n    let distance = 0;\\n    while (trees.length) {\\n        let tree = trees.pop();\\n        let travelled = bfs(forest, location.x, location.y, tree.x, tree.y);\\n        if (travelled >= 0) {\\n            distance += travelled;    \\n            location = {x: tree.x, y: tree.y};\\n        } else {\\n            return -1;\\n        }\\n    }\\n    return distance;\\n      \\n\\n\\n};\\n\\nfunction bfs(forest, sX, sY, eX, eY){\\n    const xLength = forest.length;\\n    const yLength = forest[0].length;\\n    const visited = createVisitedMatrix(xLength, yLength);\\n    const queue = [];\\n    queue.unshift({x: sX, y: sY, pathLength: 0});\\n    while(queue.length > 0){\\n        const field = queue.pop();\\n        if(field.x < 0 || field.x >= xLength || field.y < 0 || field.y >= yLength){\\n            continue; // isn\\'t a valid path to the matrix.\\n        }\\n        if(visited[field.x][field.y]){\\n            continue;\\n        }\\n        visited[field.x][field.y] = true;\\n        if(forest[field.x][field.y] == 0){\\n            continue;\\n        }\\n        \\n        if(field.x == eX && field.y == eY){\\n            return field.pathLength;\\n        }\\n        // add the next ones;\\n        queue.unshift({x: field.x -1, y: field.y, pathLength: field.pathLength +1});\\n        queue.unshift({x: field.x, y: field.y +1, pathLength: field.pathLength +1});\\n        queue.unshift({x: field.x +1, y: field.y, pathLength: field.pathLength +1});\\n        queue.unshift({x: field.x, y: field.y -1, pathLength: field.pathLength +1});\\n\\n    }\\n    \\n    return -1;\\n}\\n// creates a matrix \\nfunction createVisitedMatrix(x, y){\\n    const matrix = new Array(x);\\n    for(let i = 0; i< x;i++){\\n        matrix[i] = [];\\n        for(let j=0; j< y;j++){\\n            matrix[i].push(false);\\n        }\\n    }\\n    return matrix;\\n}\\n// Finds all trees in the matrix and sort\\'s them by descending height\\nfunction findAllTrees(forest){\\n    if(!forest) return;\\n    let trees = [];\\n    for(let i = 0; i < forest.length; i++){\\n        for(let j=0;j<forest[i].length;j++){\\n            if(forest[i][j] > 1){\\n                trees.push({x: i, y: j, height: forest[i][j]});\\n            }\\n        }\\n    }\\n    trees.sort((a,b)=>b.height - a.height);\\n    return trees;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336267,
                "title": "c-tle-on-test-case-33-anyone-knows-why",
                "content": "I am confused about the TLE of case 33,what\\'s this test case is about? What\\'s wrong with my code??\\n\\n\\n```\\nclass Solution {\\npublic:\\nbool clean_ground(vector<vector<int>>& forest){\\n\\tfor(int outer=0; outer<forest.size(); outer++){\\n\\t\\tfor(int inner=0; inner<forest[outer].size(); inner++){\\n\\t\\t\\tif (forest[outer][inner] > 1) return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\npair<int, int> lowest_tree_pos(vector<vector<int>>& forest){\\n\\tint lowest = INT_MAX;\\n\\tpair<int, int> dest = make_pair(-1, -1);\\n\\tfor(int outer=0; outer<forest.size(); outer++){\\n\\t\\tfor(int inner=0; inner<forest[outer].size(); inner++){\\n\\t\\t\\tif((forest[outer][inner]>1) && (forest[outer][inner] < lowest)) {lowest=forest[outer][inner]; dest = make_pair(outer, inner);}\\n\\t\\t}\\n\\t}\\n\\t// return -1, -1 if no trees need to cut\\n\\tif (dest.first==-1) return dest;\\n\\treturn dest;\\n}\\n\\nstruct Triplet \\n{ \\n\\tint first, second, third; \\n}; \\n\\nint setps_to_pos(pair<int, int>& current_pos, pair<int, int> dest, vector<vector<int>>& forest){\\n\\tint total_steps = 0;\\n\\t// build the data structure called triplet, the third one is the level (steps) of current BFS\\n\\tqueue<Triplet> q;\\n\\tq.push({current_pos.first, current_pos.second, 0});\\n\\tvector<vector<bool>> visited;\\n\\tfor(int a=0; a<forest.size(); a++){\\n      visited.push_back(vector<bool>(forest[0].size(), false));\\n\\t}\\n\\n\\twhile(!q.empty()){\\n\\t\\tTriplet curr = q.front();\\n\\t\\tq.pop();\\n\\t\\tint level = curr.third;\\n\\t\\tvisited[curr.first][curr.second] = true;\\n\\t\\tif(curr.first==dest.first && curr.second==dest.second) return curr.third;\\n\\t\\t//up one\\n\\t\\tif(curr.first-1>=0 && forest[curr.first-1][curr.second]>0 && !visited[curr.first-1][curr.second]) \\n\\t\\t\\tq.push({curr.first-1, curr.second, curr.third+1});\\n\\t\\t//left one\\n\\t\\tif(curr.second-1>=0 && forest[curr.first][curr.second-1]>0 && !visited[curr.first][curr.second-1]) \\n\\t\\t\\tq.push({curr.first, curr.second-1, curr.third+1});\\n\\t\\t//down one\\n\\t\\tif(curr.first+1<forest.size() && forest[curr.first+1][curr.second]>0 && !visited[curr.first+1][curr.second]) \\n\\t\\t\\tq.push({curr.first+1, curr.second, curr.third+1});\\n\\t\\t//right one\\n\\t\\tif(curr.second+1<forest[0].size() && forest[curr.first][curr.second+1]>0 && !visited[curr.first][curr.second+1]) \\n\\t\\t\\tq.push({curr.first, curr.second+1, curr.third+1});\\n\\t}\\n\\treturn -1;\\n}\\n\\n\\nint cutOffTree(vector<vector<int>>& forest) {\\npair<int, int> current_pos;\\ncurrent_pos = make_pair(0, 0);  \\npair<int, int> dest;\\nint steps = 0;\\n\\nwhile(!clean_ground(forest)){\\n\\t\\tdest = lowest_tree_pos(forest);\\n\\t\\tif (dest.first == -1) return -1;\\n\\n\\t\\tint temp = setps_to_pos(current_pos, dest, forest);\\n\\t\\tif(temp==-1) return -1;\\n\\t\\tsteps += temp;\\n\\t\\tcurrent_pos = dest;\\n\\t\\tforest[dest.first][dest.second] = 1;\\n\\t\\t}\\n\\t\\treturn steps;\\n}\\n\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool clean_ground(vector<vector<int>>& forest){\\n\\tfor(int outer=0; outer<forest.size(); outer++){\\n\\t\\tfor(int inner=0; inner<forest[outer].size(); inner++){\\n\\t\\t\\tif (forest[outer][inner] > 1) return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\npair<int, int> lowest_tree_pos(vector<vector<int>>& forest){\\n\\tint lowest = INT_MAX;\\n\\tpair<int, int> dest = make_pair(-1, -1);\\n\\tfor(int outer=0; outer<forest.size(); outer++){\\n\\t\\tfor(int inner=0; inner<forest[outer].size(); inner++){\\n\\t\\t\\tif((forest[outer][inner]>1) && (forest[outer][inner] < lowest)) {lowest=forest[outer][inner]; dest = make_pair(outer, inner);}\\n\\t\\t}\\n\\t}\\n\\t// return -1, -1 if no trees need to cut\\n\\tif (dest.first==-1) return dest;\\n\\treturn dest;\\n}\\n\\nstruct Triplet \\n{ \\n\\tint first, second, third; \\n}; \\n\\nint setps_to_pos(pair<int, int>& current_pos, pair<int, int> dest, vector<vector<int>>& forest){\\n\\tint total_steps = 0;\\n\\t// build the data structure called triplet, the third one is the level (steps) of current BFS\\n\\tqueue<Triplet> q;\\n\\tq.push({current_pos.first, current_pos.second, 0});\\n\\tvector<vector<bool>> visited;\\n\\tfor(int a=0; a<forest.size(); a++){\\n      visited.push_back(vector<bool>(forest[0].size(), false));\\n\\t}\\n\\n\\twhile(!q.empty()){\\n\\t\\tTriplet curr = q.front();\\n\\t\\tq.pop();\\n\\t\\tint level = curr.third;\\n\\t\\tvisited[curr.first][curr.second] = true;\\n\\t\\tif(curr.first==dest.first && curr.second==dest.second) return curr.third;\\n\\t\\t//up one\\n\\t\\tif(curr.first-1>=0 && forest[curr.first-1][curr.second]>0 && !visited[curr.first-1][curr.second]) \\n\\t\\t\\tq.push({curr.first-1, curr.second, curr.third+1});\\n\\t\\t//left one\\n\\t\\tif(curr.second-1>=0 && forest[curr.first][curr.second-1]>0 && !visited[curr.first][curr.second-1]) \\n\\t\\t\\tq.push({curr.first, curr.second-1, curr.third+1});\\n\\t\\t//down one\\n\\t\\tif(curr.first+1<forest.size() && forest[curr.first+1][curr.second]>0 && !visited[curr.first+1][curr.second]) \\n\\t\\t\\tq.push({curr.first+1, curr.second, curr.third+1});\\n\\t\\t//right one\\n\\t\\tif(curr.second+1<forest[0].size() && forest[curr.first][curr.second+1]>0 && !visited[curr.first][curr.second+1]) \\n\\t\\t\\tq.push({curr.first, curr.second+1, curr.third+1});\\n\\t}\\n\\treturn -1;\\n}\\n\\n\\nint cutOffTree(vector<vector<int>>& forest) {\\npair<int, int> current_pos;\\ncurrent_pos = make_pair(0, 0);  \\npair<int, int> dest;\\nint steps = 0;\\n\\nwhile(!clean_ground(forest)){\\n\\t\\tdest = lowest_tree_pos(forest);\\n\\t\\tif (dest.first == -1) return -1;\\n\\n\\t\\tint temp = setps_to_pos(current_pos, dest, forest);\\n\\t\\tif(temp==-1) return -1;\\n\\t\\tsteps += temp;\\n\\t\\tcurrent_pos = dest;\\n\\t\\tforest[dest.first][dest.second] = 1;\\n\\t\\t}\\n\\t\\treturn steps;\\n}\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283290,
                "title": "python-bfs-with-explanation-and-console-log-output-though-lte-on-large-data",
                "content": "**Thoughts**:\\n1. Shortest path problem = BFS\\n* First , We need to know where will be the next tree to cut, thus, we will have a `sorted array treeToCut` to know where to stop next BFS\\n* Start coord will be (0,0), our BFS should return `nextStartCoord` and `steps` from `currentCoord` to `nextStartCoord`\\n\\n**So whole sudo logic will be :**\\n```\\nstartCoord = [0,0]\\ntreeToCut = [2,3,4,5,6,7,8]\\ntotalStep = 0 \\nwhile treeToCut:\\n\\tstartCoord(nextCoord) , stepsToNextNode = getStepsToNextTree() # return [0,1], 1 in the given example\\n\\tif no path to nextCoord:\\n\\t\\ttotalStep = -1\\n\\t\\tbreak\\n\\telse:\\n\\t\\ttotalStep += stepsToNextNode\\n\\nreturn totalSteps\\n```\\n\\n**Real Code LTE though**\\n```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not forest or not forest[0]:\\n            return 0\\n        \\n        totalStep = 0\\n        treesToCut = self.getSortedTreeList(forest) #[2,3,4,5,6,7,8]\\n        # print (\"treesToCut : \", treesToCut )\\n        startCoordinate = (0,0)\\n        \\n        while treesToCut:\\n            nextTree = heapq.heappop(treesToCut)\\n            #print(\"Start Coord: \",startCoordinate, \"Tree To Cut\", nextTree)\\n            startCoordinate, stepToNextTree = self.getStepsToNextTree(startCoordinate, nextTree, forest) # ([0,0],2, forest)\\n            #print(\"Next Start Coord:\", startCoordinate,  \"Steps:\", stepToNextTree )\\n            if stepToNextTree == -1:\\n                # No Valid Path find for next Tree:\\n                totalStep = -1\\n                break\\n            else:\\n                totalStep += stepToNextTree\\n        \\n        return totalStep\\n            \\n        \\n    \\n    def getSortedTreeList(self, forest):\\n        row = len(forest)\\n        col = len(forest[0])\\n        trees = []\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                if forest[i][j]!=0 and forest[i][j]!=1:\\n                    trees.append(forest[i][j])\\n        heapq.heapify(trees)\\n        return trees\\n    \\n    def getStepsToNextTree(self, coordinate, treeHeightToCut, forest):\\n        # @Return startIndex: the index of next bfs start\\n        #         step : the steps it take for current startIndex to next tree\\n        \\n        row = len(forest)\\n        col = len(forest[0])\\n        \\n        queue = [coordinate]\\n        visited = set()\\n        index = coordinate[0]*col+coordinate[1]\\n        visited.add(index)\\n        \\n        steps = -1\\n        directions = [(0,1),(0,-1),(1,0),(-1,0)]\\n        while queue:\\n            size = len(queue)\\n            steps+=1\\n            for _ in range(size):\\n                x, y = queue.pop()\\n                if forest[x][y] == treeHeightToCut:\\n                    return [x,y], steps\\n                \\n                for dx, dy in directions:\\n                    newX = x+dx\\n                    newY = y+dy\\n                    newIndex = newX*col+newY\\n                    if 0<=newX<row and 0<=newY<col and forest[newX][newY] !=0 and newIndex not in visited:\\n                        queue.insert(0,[newX,newY])\\n                        visited.add(newIndex)\\n        \\n        return [-1,-1], -1\\n        \\n        \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nstartCoord = [0,0]\\ntreeToCut = [2,3,4,5,6,7,8]\\ntotalStep = 0 \\nwhile treeToCut:\\n\\tstartCoord(nextCoord) , stepsToNextNode = getStepsToNextTree() # return [0,1], 1 in the given example\\n\\tif no path to nextCoord:\\n\\t\\ttotalStep = -1\\n\\t\\tbreak\\n\\telse:\\n\\t\\ttotalStep += stepsToNextNode\\n\\nreturn totalSteps\\n```\n```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not forest or not forest[0]:\\n            return 0\\n        \\n        totalStep = 0\\n        treesToCut = self.getSortedTreeList(forest) #[2,3,4,5,6,7,8]\\n        # print (\"treesToCut : \", treesToCut )\\n        startCoordinate = (0,0)\\n        \\n        while treesToCut:\\n            nextTree = heapq.heappop(treesToCut)\\n            #print(\"Start Coord: \",startCoordinate, \"Tree To Cut\", nextTree)\\n            startCoordinate, stepToNextTree = self.getStepsToNextTree(startCoordinate, nextTree, forest) # ([0,0],2, forest)\\n            #print(\"Next Start Coord:\", startCoordinate,  \"Steps:\", stepToNextTree )\\n            if stepToNextTree == -1:\\n                # No Valid Path find for next Tree:\\n                totalStep = -1\\n                break\\n            else:\\n                totalStep += stepToNextTree\\n        \\n        return totalStep\\n            \\n        \\n    \\n    def getSortedTreeList(self, forest):\\n        row = len(forest)\\n        col = len(forest[0])\\n        trees = []\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                if forest[i][j]!=0 and forest[i][j]!=1:\\n                    trees.append(forest[i][j])\\n        heapq.heapify(trees)\\n        return trees\\n    \\n    def getStepsToNextTree(self, coordinate, treeHeightToCut, forest):\\n        # @Return startIndex: the index of next bfs start\\n        #         step : the steps it take for current startIndex to next tree\\n        \\n        row = len(forest)\\n        col = len(forest[0])\\n        \\n        queue = [coordinate]\\n        visited = set()\\n        index = coordinate[0]*col+coordinate[1]\\n        visited.add(index)\\n        \\n        steps = -1\\n        directions = [(0,1),(0,-1),(1,0),(-1,0)]\\n        while queue:\\n            size = len(queue)\\n            steps+=1\\n            for _ in range(size):\\n                x, y = queue.pop()\\n                if forest[x][y] == treeHeightToCut:\\n                    return [x,y], steps\\n                \\n                for dx, dy in directions:\\n                    newX = x+dx\\n                    newY = y+dy\\n                    newIndex = newX*col+newY\\n                    if 0<=newX<row and 0<=newY<col and forest[newX][newY] !=0 and newIndex not in visited:\\n                        queue.insert(0,[newX,newY])\\n                        visited.add(newIndex)\\n        \\n        return [-1,-1], -1\\n        \\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 226026,
                "title": "easy-python-bfs",
                "content": "Similar to #864\\n```python\\nclass Solution:\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def neighbors(i, j, forest, tree_idx, visited):\\n            m, n = len(forest), len(forest[0])\\n            for x, y in [[i-1, j], [i+1, j], [i, j-1], [i, j+1]]:\\n                if 0 <= x < m and 0 <= y < n and forest[x][y] and (x, y) not in visited:\\n                    yield x, y\\n                    \\n        if not forest or not forest[0] or not forest[0][0]:\\n            return -1\\n        trees = [col for row in forest for col in row if col > 1]\\n        trees.sort()\\n        queue = collections.deque([[0, 0, -1, 0]])\\n        visited = {(0, 0)}\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                i, j, tree_idx, steps = queue.popleft()\\n                if tree_idx == len(trees) - 1:\\n                        return steps\\n                if forest[i][j] == trees[tree_idx+1]:\\n                    tree_idx += 1\\n                    queue = collections.deque([[i, j, tree_idx, steps]])\\n                    visited = {(i, j)}\\n                    break\\n                for x, y in neighbors(i, j, forest, tree_idx, visited):\\n                    queue.append([x, y, tree_idx, steps+1])\\n                    visited.add((x, y))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def neighbors(i, j, forest, tree_idx, visited):\\n            m, n = len(forest), len(forest[0])\\n            for x, y in [[i-1, j], [i+1, j], [i, j-1], [i, j+1]]:\\n                if 0 <= x < m and 0 <= y < n and forest[x][y] and (x, y) not in visited:\\n                    yield x, y\\n                    \\n        if not forest or not forest[0] or not forest[0][0]:\\n            return -1\\n        trees = [col for row in forest for col in row if col > 1]\\n        trees.sort()\\n        queue = collections.deque([[0, 0, -1, 0]])\\n        visited = {(0, 0)}\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                i, j, tree_idx, steps = queue.popleft()\\n                if tree_idx == len(trees) - 1:\\n                        return steps\\n                if forest[i][j] == trees[tree_idx+1]:\\n                    tree_idx += 1\\n                    queue = collections.deque([[i, j, tree_idx, steps]])\\n                    visited = {(i, j)}\\n                    break\\n                for x, y in neighbors(i, j, forest, tree_idx, visited):\\n                    queue.append([x, y, tree_idx, steps+1])\\n                    visited.add((x, y))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219707,
                "title": "confused-about-this-test-case",
                "content": "[[3,2,1],\\n [0,0,4],\\n [7,6,5]]\\n \\nShould this case output 10? Although my BFS algorithm pass, mine output is 3-2-1-2-3-2-1-4-5-6-7, but leetcode gives an answer 8.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 198244,
                "title": "not-sure-why-python-gets-tle",
                "content": "```\\nclass Solution(object):\\n    def bfs(self,current_position, next_tree, forest):\\n        M = len(forest)\\n        N = len(forest[0])\\n        steps = 0\\n        level = [current_position]\\n        visited = dict()\\n        visited[(current_position[0],current_position[1])] = None\\n        \\n        while len(level) > 0:\\n            next_level = list()\\n            for p in level:\\n                [x,y] = p\\n                if p == next_tree:\\n                    forest[x][y] = 1\\n                    return steps \\n                \\n                \\n                if x > 0 and forest[x-1][y] != 0 and (x-1,y) not in visited:\\n                    next_level.append([x-1,y])\\n                    visited[(x-1,y)] = None\\n                    \\n                if x < M - 1 and forest[x+1][y] != 0 and (x+1,y) not in visited:\\n                    next_level.append([x+1,y])\\n                    visited[(x+1,y)] = None \\n                    \\n                if y > 0 and forest[x][y-1] != 0 and (x,y-1) not in visited:\\n                    next_level.append([x,y-1])\\n                    visited[(x,y-1)] = None \\n                    \\n                if y < N-1 and forest[x][y+1] != 0 and (x,y+1) not in visited:\\n                    next_level.append([x,y+1])\\n                    visited[(x,y+1)] = None \\n                    \\n            steps += 1\\n            level = next_level\\n            \\n        return -1 \\n            \\n       \\n            \\n            \\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        tree_list = list()\\n        M = len(forest)\\n        if M == 0:\\n            return -1\\n        N = len(forest[0])\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if forest[i][j] > 1:\\n                    tree_list.append([i,j,forest[i][j]])\\n                    \\n        num_steps = 0\\n        current_position = [0,0]\\n        tree_list.sort(key=lambda x: x[2])\\n       \\n        \\n        for next_tree in tree_list:\\n          \\n            target = [next_tree[0],next_tree[1]]\\n            steps=self.bfs(current_position, target,forest)\\n            if steps == -1:\\n                return -1\\n            else:\\n                num_steps += steps\\n                current_position = target\\n                \\n        return num_steps\\n    \\n            \\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def bfs(self,current_position, next_tree, forest):\\n        M = len(forest)\\n        N = len(forest[0])\\n        steps = 0\\n        level = [current_position]\\n        visited = dict()\\n        visited[(current_position[0],current_position[1])] = None\\n        \\n        while len(level) > 0:\\n            next_level = list()\\n            for p in level:\\n                [x,y] = p\\n                if p == next_tree:\\n                    forest[x][y] = 1\\n                    return steps \\n                \\n                \\n                if x > 0 and forest[x-1][y] != 0 and (x-1,y) not in visited:\\n                    next_level.append([x-1,y])\\n                    visited[(x-1,y)] = None\\n                    \\n                if x < M - 1 and forest[x+1][y] != 0 and (x+1,y) not in visited:\\n                    next_level.append([x+1,y])\\n                    visited[(x+1,y)] = None \\n                    \\n                if y > 0 and forest[x][y-1] != 0 and (x,y-1) not in visited:\\n                    next_level.append([x,y-1])\\n                    visited[(x,y-1)] = None \\n                    \\n                if y < N-1 and forest[x][y+1] != 0 and (x,y+1) not in visited:\\n                    next_level.append([x,y+1])\\n                    visited[(x,y+1)] = None \\n                    \\n            steps += 1\\n            level = next_level\\n            \\n        return -1 \\n            \\n       \\n            \\n            \\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        tree_list = list()\\n        M = len(forest)\\n        if M == 0:\\n            return -1\\n        N = len(forest[0])\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if forest[i][j] > 1:\\n                    tree_list.append([i,j,forest[i][j]])\\n                    \\n        num_steps = 0\\n        current_position = [0,0]\\n        tree_list.sort(key=lambda x: x[2])\\n       \\n        \\n        for next_tree in tree_list:\\n          \\n            target = [next_tree[0],next_tree[1]]\\n            steps=self.bfs(current_position, target,forest)\\n            if steps == -1:\\n                return -1\\n            else:\\n                num_steps += steps\\n                current_position = target\\n                \\n        return num_steps\\n    \\n            \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 175734,
                "title": "c-bfs-priorityqueue",
                "content": "\\'\\'\\'\\n    struct tree{\\n        int x,y;\\n        int h;\\n        tree(int vx,int vy, int vh):x(vx),y(vy),h(vh){};\\n    };\\n    static bool cmp(const tree&a, const tree&b){ return a.h>b.h;}\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m = forest.size();\\n        int n = (m)? forest[0].size():0;\\n        if(!m||!n) return 0;\\n        priority_queue<tree,vector<tree>, decltype(&cmp)> pq(cmp);\\n        for(int i =0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(forest[i][j] >1) \\n                    pq.emplace(tree{i,j,forest[i][j]});\\n            }\\n        }\\n      \\n        int res = 0;\\n        vector<pair<int,int>> dirs= {{-1,0},{1,0},{0,-1},{0,1}};\\n        queue<pair<int,int>> start;\\n        start.push(make_pair(0,0));\\n        while(!pq.empty()){\\n            auto endTree = pq.top();\\n            pq.pop();\\n            int x = endTree.x;\\n            int y = endTree.y;\\n            auto end = make_pair(x,y);\\n            forest[x][y]=1;\\n            int path = 0;\\n            bool find = false;\\n            vector<vector<int>> visited(m, vector<int>(n,0));\\n            \\n            while(!start.empty()){\\n                int sn = start.size();\\n                for(int i = 0; i < sn; i++){\\n                    auto cur = start.front();\\n                    start.pop();\\n                    if(cur == end) {\\n                        find = true;\\n                        break;\\n                    }else {\\n                        for(auto d:dirs){\\n                            int x1 = cur.first+d.first;\\n                            int y1 = cur.second+d.second;\\n                            if(x1>=m || y1 >=n ||x1 <0 || y1 <0|| !forest[x1][y1]||visited[x1][y1]) continue;\\n                            start.push(make_pair(x1,y1));\\n                            visited[x1][y1]=1;\\n                        }\\n                    }\\n                }\\n                if(find) break;\\n                path++;\\n            }\\n            if(find) res += path;\\n            else return -1;\\n            start= queue<pair<int,int>> {};\\n            start.push(end);\\n        }\\n        return res;\\n    }\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n    struct tree{\\n        int x,y;\\n        int h;\\n        tree(int vx,int vy, int vh):x(vx),y(vy),h(vh){};\\n    };\\n    static bool cmp(const tree&a, const tree&b){ return a.h>b.h;}\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m = forest.size();\\n        int n = (m)? forest[0].size():0;\\n        if(!m||!n) return 0;\\n        priority_queue<tree,vector<tree>, decltype(&cmp)> pq(cmp);\\n        for(int i =0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(forest[i][j] >1) \\n                    pq.emplace(tree{i,j,forest[i][j]});\\n            }\\n        }\\n      \\n        int res = 0;\\n        vector<pair<int,int>> dirs= {{-1,0},{1,0},{0,-1},{0,1}};\\n        queue<pair<int,int>> start;\\n        start.push(make_pair(0,0));\\n        while(!pq.empty()){\\n            auto endTree = pq.top();\\n            pq.pop();\\n            int x = endTree.x;\\n            int y = endTree.y;\\n            auto end = make_pair(x,y);\\n            forest[x][y]=1;\\n            int path = 0;\\n            bool find = false;\\n            vector<vector<int>> visited(m, vector<int>(n,0));\\n            \\n            while(!start.empty()){\\n                int sn = start.size();\\n                for(int i = 0; i < sn; i++){\\n                    auto cur = start.front();\\n                    start.pop();\\n                    if(cur == end) {\\n                        find = true;\\n                        break;\\n                    }else {\\n                        for(auto d:dirs){\\n                            int x1 = cur.first+d.first;\\n                            int y1 = cur.second+d.second;\\n                            if(x1>=m || y1 >=n ||x1 <0 || y1 <0|| !forest[x1][y1]||visited[x1][y1]) continue;\\n                            start.push(make_pair(x1,y1));\\n                            visited[x1][y1]=1;\\n                        }\\n                    }\\n                }\\n                if(find) break;\\n                path++;\\n            }\\n            if(find) res += path;\\n            else return -1;\\n            start= queue<pair<int,int>> {};\\n            start.push(end);\\n        }\\n        return res;\\n    }\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 171413,
                "title": "java-bfs-clean-solution",
                "content": "```\\n    private static final int[][] DIRS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(i).size(); j++) {\\n                if (forest.get(i).get(j) != 0) {\\n                    trees.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        trees.sort(Comparator.comparingInt(tree -> forest.get(tree[0]).get(tree[1])));\\n        int[] position = new int[]{0, 0};\\n        int steps = 0;\\n        for (int[] tree : trees) {\\n            int step = bfs(forest, position[0], position[1], tree[0], tree[1]);\\n            if (step < 0) {\\n                return -1;\\n            }\\n            steps += step;\\n            position = tree;\\n        }\\n        return steps;\\n    }\\n\\n    private int bfs(List<List<Integer>> forest, int x, int y, int targetX, int targetY) {\\n        if (x == targetX && y == targetY) {\\n            return 0;\\n        }\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        int steps = 0;\\n        List<int[]> positions = Arrays.asList(new int[]{x, y});\\n        visited[x][y] = true;\\n        while (!positions.isEmpty()) {\\n            steps++;\\n            List<int[]> nextPositions = new ArrayList<>();\\n            for (int[] each : positions) {\\n                for (int[] dir : DIRS) {\\n                    int newX = each[0] + dir[0];\\n                    int newY = each[1] + dir[1];\\n                    if (newX >= 0 && newX < forest.size() && newY >= 0 && newY < forest.get(0).size() && forest.get(newX).get(newY) > 0 && !visited[newX][newY]) {\\n                        if (newX == targetX && newY == targetY) {\\n                            return steps;\\n                        }\\n                        visited[newX][newY] = true;\\n                        nextPositions.add(new int[]{newX, newY});\\n                    }\\n                }\\n            }\\n            positions = nextPositions;\\n        }\\n        return -1;\\n    }\\n```\\n\\nMy two cents:\\n1. I always prefer to have a new collection to keep track of each level of BFS, and in the end I simply assign the new collection to the main collection to be iterated on.\\n2. There\\'s a nice syntax to sort the collection based on a custom comparator.",
                "solutionTags": [],
                "code": "```\\n    private static final int[][] DIRS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        List<int[]> trees = new ArrayList<>();\\n        for (int i = 0; i < forest.size(); i++) {\\n            for (int j = 0; j < forest.get(i).size(); j++) {\\n                if (forest.get(i).get(j) != 0) {\\n                    trees.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        trees.sort(Comparator.comparingInt(tree -> forest.get(tree[0]).get(tree[1])));\\n        int[] position = new int[]{0, 0};\\n        int steps = 0;\\n        for (int[] tree : trees) {\\n            int step = bfs(forest, position[0], position[1], tree[0], tree[1]);\\n            if (step < 0) {\\n                return -1;\\n            }\\n            steps += step;\\n            position = tree;\\n        }\\n        return steps;\\n    }\\n\\n    private int bfs(List<List<Integer>> forest, int x, int y, int targetX, int targetY) {\\n        if (x == targetX && y == targetY) {\\n            return 0;\\n        }\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        int steps = 0;\\n        List<int[]> positions = Arrays.asList(new int[]{x, y});\\n        visited[x][y] = true;\\n        while (!positions.isEmpty()) {\\n            steps++;\\n            List<int[]> nextPositions = new ArrayList<>();\\n            for (int[] each : positions) {\\n                for (int[] dir : DIRS) {\\n                    int newX = each[0] + dir[0];\\n                    int newY = each[1] + dir[1];\\n                    if (newX >= 0 && newX < forest.size() && newY >= 0 && newY < forest.get(0).size() && forest.get(newX).get(newY) > 0 && !visited[newX][newY]) {\\n                        if (newX == targetX && newY == targetY) {\\n                            return steps;\\n                        }\\n                        visited[newX][newY] = true;\\n                        nextPositions.add(new int[]{newX, newY});\\n                    }\\n                }\\n            }\\n            positions = nextPositions;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107426,
                "title": "java-bfs-with-treemap",
                "content": "1. Get a list of all trees to cut down in order of lowest height to greatest\\n2. Then go from one tree to the other starting at (0,0) to cut them all down. Use BFS to calculate optimal number of steps needed to go from one tree to another.\\n\\n```\\npublic int cutOffTree(List<List<Integer>> forest) {\\n    int n = forest.size(), m = forest.get(0).size(), numSteps = 0;\\n    Map<Integer, int[]> map = new TreeMap<>();\\n    for (int i=0;i<n;i++) \\n        for (int j=0;j<m;j++) \\n            if (forest.get(i).get(j) > 1) \\n      \\t       map.put(forest.get(i).get(j), new int[]{i,j});\\n    \\n    int[] curCoord = new int[]{0,0};\\n    for (Map.Entry<Integer, int[]> entry : map.entrySet()) {\\n        int stepsNeeded = getDistance(curCoord, entry.getValue(), forest, n, m);\\n        if (stepsNeeded == -1) return -1;\\n        numSteps += stepsNeeded;\\n        curCoord = entry.getValue();\\n    }\\n    return numSteps;\\n}\\n\\npublic int getDistance(int[] coord1, int[] coord2, List<List<Integer>> forest, int n, int m) {\\n    Queue<int[]> queue = new LinkedList<>();\\n    queue.add(coord1);\\n    int stepsTaken = 0;\\n    boolean[][] visited = new boolean[n][m];\\n    visited[coord1[0]][coord1[1]] = true;\\n    while (!queue.isEmpty()) {\\n        int queueSize = queue.size();\\n        for (int k=0;k<queueSize;k++) {\\n            int[] curCoord = queue.poll();\\n            int i = curCoord[0], j = curCoord[1];\\n            if (i == coord2[0] && j == coord2[1]) return stepsTaken;\\n            if (i-1 >= 0 && !visited[i-1][j] && forest.get(i-1).get(j) != 0) {\\n                queue.add(new int[]{i-1, j});\\n                visited[i-1][j] = true;\\n            }\\n            if (j-1 >= 0 && !visited[i][j-1] && forest.get(i).get(j-1) != 0) {\\n                queue.add(new int[]{i, j-1});\\n                visited[i][j-1] = true;\\n            }     \\n            if (i+1 < n && !visited[i+1][j] && forest.get(i+1).get(j) != 0) {\\n                queue.add(new int[]{i+1, j});\\n                visited[i+1][j] = true;\\n            } \\n            if (j+1 < m && !visited[i][j+1] && forest.get(i).get(j+1) != 0) {\\n                queue.add(new int[]{i, j+1});\\n                visited[i][j+1] = true;\\n            }  \\n        }\\n        stepsTaken++;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int cutOffTree(List<List<Integer>> forest) {\\n    int n = forest.size(), m = forest.get(0).size(), numSteps = 0;\\n    Map<Integer, int[]> map = new TreeMap<>();\\n    for (int i=0;i<n;i++) \\n        for (int j=0;j<m;j++) \\n            if (forest.get(i).get(j) > 1) \\n      \\t       map.put(forest.get(i).get(j), new int[]{i,j});\\n    \\n    int[] curCoord = new int[]{0,0};\\n    for (Map.Entry<Integer, int[]> entry : map.entrySet()) {\\n        int stepsNeeded = getDistance(curCoord, entry.getValue(), forest, n, m);\\n        if (stepsNeeded == -1) return -1;\\n        numSteps += stepsNeeded;\\n        curCoord = entry.getValue();\\n    }\\n    return numSteps;\\n}\\n\\npublic int getDistance(int[] coord1, int[] coord2, List<List<Integer>> forest, int n, int m) {\\n    Queue<int[]> queue = new LinkedList<>();\\n    queue.add(coord1);\\n    int stepsTaken = 0;\\n    boolean[][] visited = new boolean[n][m];\\n    visited[coord1[0]][coord1[1]] = true;\\n    while (!queue.isEmpty()) {\\n        int queueSize = queue.size();\\n        for (int k=0;k<queueSize;k++) {\\n            int[] curCoord = queue.poll();\\n            int i = curCoord[0], j = curCoord[1];\\n            if (i == coord2[0] && j == coord2[1]) return stepsTaken;\\n            if (i-1 >= 0 && !visited[i-1][j] && forest.get(i-1).get(j) != 0) {\\n                queue.add(new int[]{i-1, j});\\n                visited[i-1][j] = true;\\n            }\\n            if (j-1 >= 0 && !visited[i][j-1] && forest.get(i).get(j-1) != 0) {\\n                queue.add(new int[]{i, j-1});\\n                visited[i][j-1] = true;\\n            }     \\n            if (i+1 < n && !visited[i+1][j] && forest.get(i+1).get(j) != 0) {\\n                queue.add(new int[]{i+1, j});\\n                visited[i+1][j] = true;\\n            } \\n            if (j+1 < m && !visited[i][j+1] && forest.get(i).get(j+1) != 0) {\\n                queue.add(new int[]{i, j+1});\\n                visited[i][j+1] = true;\\n            }  \\n        }\\n        stepsTaken++;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041394,
                "title": "most-detailed-solution-explained-approach-sorting-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n\\n        // Given : Clear the trees in increasing order of height\\n        // constraints : n , m <= 50 = Larger Complexity Acceptable\\n\\n        // Solution : To handle the contriant we are given that we have to cut them\\n        // in increasing order which provides us with solution itself\\n\\n        // If gives tress are [ 10 , 12 , 11 ]\\n        // if i cut 10 next i have to cut will be 11 and i need to find a way to reach 11 \\n        // if possible find steps to it if not return -1\\n\\n        vector<vector<int>> trees;\\n        for(int i = 0; i < forest.size(); i++){\\n\\n            for(int j = 0; j < forest[0].size(); j++){\\n\\n                if(forest[i][j] > 1){\\n\\n                    trees.push_back({forest[i][j] , i , j});\\n                }\\n            }\\n            cout<<endl;\\n        }\\n\\n        // sorting the trees according to their height\\n        sort(trees.begin() , trees.end());\\n\\n        // how it gurantees minimum ? As bfs does a level order search so we will\\n        // surely get the closest step automatically\\n\\n        // defining all valid moves in advance\\n        vector<pair<int,int>> moves = {{0 , 1} , {1 , 0} , { 0 , -1} , {-1 , 0}};\\n\\n        // defining start points \\n        int sx = 0 , sy = 0;\\n        int ans = 0;\\n        // now we will cut trees in order\\n        for(int i = 0; i < trees.size(); i++){\\n            \\n            // using breadth first search to find if next tree is reachable or not\\n            int cost = bfs(forest , sx , sy , trees[i][1] , trees[i][2] , moves);\\n            // if not reachable return -1\\n            if(cost == -1){\\n                \\n                return -1;\\n            }\\n            // if reachable add the 1 to cost\\n            ans += cost;\\n            // update the start points to new tree\\n            sx = trees[i][1];\\n            sy = trees[i][2];\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    int bfs(vector<vector<int>> forest , int sx , int sy , int fx , int fy , vector<pair<int,int>> &moves){\\n\\n        // if we are search for start point\\n        if(fx == sx && fy == sy) return 0;\\n\\n        // now let\\'s do a bfs \\n\\n        queue<pair<int,int>> q;\\n        q.push({sx , sy});\\n        int n = forest.size() , m = forest[0].size();\\n        vector<vector<int>> seen(n , vector<int>(m , 0));\\n        seen[sx][sy] = 1;\\n        int cost = 0;\\n        while(!q.empty()){\\n\\n            int qsize = q.size();\\n            // iterating the current level\\n            for(int i = 0; i < qsize; i++){\\n\\n                pair<int,int> point = q.front();\\n                q.pop();\\n\\n                for(int j = 0 ; j < moves.size(); j++){\\n\\n                    long int newx = point.first + moves[j].first;\\n                    long int newy = point.second + moves[j].second;\\n\\n                    // skip if new point is not valid point\\n                    if(newx >= n || newy >= m || newx < 0 || newy < 0 ) continue;\\n\\n                    // if new point is not obstacle and also not seen before the add it\\n                    if(forest[newx][newy] != 0 && seen[newx][newy] == 0){\\n\\n                        q.push({newx , newy});\\n                        seen[newx][newy] = 1;\\n\\n                        if(newx == fx && newy == fy){\\n\\n                            return cost + 1;\\n                        }\\n\\n                    }\\n    \\n                }\\n                \\n            }\\n            \\n            cost++;\\n\\n\\n        }\\n\\n        // if not found return -1\\n        return -1;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n\\n        // Given : Clear the trees in increasing order of height\\n        // constraints : n , m <= 50 = Larger Complexity Acceptable\\n\\n        // Solution : To handle the contriant we are given that we have to cut them\\n        // in increasing order which provides us with solution itself\\n\\n        // If gives tress are [ 10 , 12 , 11 ]\\n        // if i cut 10 next i have to cut will be 11 and i need to find a way to reach 11 \\n        // if possible find steps to it if not return -1\\n\\n        vector<vector<int>> trees;\\n        for(int i = 0; i < forest.size(); i++){\\n\\n            for(int j = 0; j < forest[0].size(); j++){\\n\\n                if(forest[i][j] > 1){\\n\\n                    trees.push_back({forest[i][j] , i , j});\\n                }\\n            }\\n            cout<<endl;\\n        }\\n\\n        // sorting the trees according to their height\\n        sort(trees.begin() , trees.end());\\n\\n        // how it gurantees minimum ? As bfs does a level order search so we will\\n        // surely get the closest step automatically\\n\\n        // defining all valid moves in advance\\n        vector<pair<int,int>> moves = {{0 , 1} , {1 , 0} , { 0 , -1} , {-1 , 0}};\\n\\n        // defining start points \\n        int sx = 0 , sy = 0;\\n        int ans = 0;\\n        // now we will cut trees in order\\n        for(int i = 0; i < trees.size(); i++){\\n            \\n            // using breadth first search to find if next tree is reachable or not\\n            int cost = bfs(forest , sx , sy , trees[i][1] , trees[i][2] , moves);\\n            // if not reachable return -1\\n            if(cost == -1){\\n                \\n                return -1;\\n            }\\n            // if reachable add the 1 to cost\\n            ans += cost;\\n            // update the start points to new tree\\n            sx = trees[i][1];\\n            sy = trees[i][2];\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    int bfs(vector<vector<int>> forest , int sx , int sy , int fx , int fy , vector<pair<int,int>> &moves){\\n\\n        // if we are search for start point\\n        if(fx == sx && fy == sy) return 0;\\n\\n        // now let\\'s do a bfs \\n\\n        queue<pair<int,int>> q;\\n        q.push({sx , sy});\\n        int n = forest.size() , m = forest[0].size();\\n        vector<vector<int>> seen(n , vector<int>(m , 0));\\n        seen[sx][sy] = 1;\\n        int cost = 0;\\n        while(!q.empty()){\\n\\n            int qsize = q.size();\\n            // iterating the current level\\n            for(int i = 0; i < qsize; i++){\\n\\n                pair<int,int> point = q.front();\\n                q.pop();\\n\\n                for(int j = 0 ; j < moves.size(); j++){\\n\\n                    long int newx = point.first + moves[j].first;\\n                    long int newy = point.second + moves[j].second;\\n\\n                    // skip if new point is not valid point\\n                    if(newx >= n || newy >= m || newx < 0 || newy < 0 ) continue;\\n\\n                    // if new point is not obstacle and also not seen before the add it\\n                    if(forest[newx][newy] != 0 && seen[newx][newy] == 0){\\n\\n                        q.push({newx , newy});\\n                        seen[newx][newy] = 1;\\n\\n                        if(newx == fx && newy == fy){\\n\\n                            return cost + 1;\\n                        }\\n\\n                    }\\n    \\n                }\\n                \\n            }\\n            \\n            cost++;\\n\\n\\n        }\\n\\n        // if not found return -1\\n        return -1;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4023436,
                "title": "bfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> directions={{-1,0},{0,-1},{0,1},{1,0}};\\n    int bfs(int startRow, int startCol, int targetRow, int targetCol, vector<vector<int>> &forest)\\n    {\\n        if(startRow==targetRow && startCol==targetCol) return 0;\\n        int rows=forest.size(), cols=forest[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        queue<pair<int,int>> q;\\n        q.push({startRow,startCol});\\n        vis[startRow][startCol]=1;\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                int r=q.front().first, c=q.front().second;\\n                q.pop();\\n                for(auto it: directions)\\n                {\\n                    int dr=r+it.first, dc=c+it.second;\\n                    if(dr<0 || dc<0 || dr>=rows || dc>=cols || forest[dr][dc]==0 || vis[dr][dc]) continue;\\n                    if(dr==targetRow && dc==targetCol) return level;\\n                    vis[dr][dc]=1;\\n                    q.push({dr,dc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& forest) \\n    {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        int rows=forest.size(), cols=forest[0].size();\\n        for(int r=0; r<rows; r++)\\n        {\\n            for(int c=0; c<cols; c++)\\n            {\\n                if(forest[r][c]>1)\\n                {\\n                    q.push({forest[r][c],{r,c}});\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int startRow=0, startCol=0;\\n        while(!q.empty())\\n        {\\n            int targetRow=q.top().second.first, targetCol=q.top().second.second;\\n            q.pop();\\n            int steps=bfs(startRow, startCol, targetRow, targetCol, forest);\\n            if(steps==-1) return -1;\\n            ans+=steps;\\n            startRow=targetRow, startCol=targetCol;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> directions={{-1,0},{0,-1},{0,1},{1,0}};\\n    int bfs(int startRow, int startCol, int targetRow, int targetCol, vector<vector<int>> &forest)\\n    {\\n        if(startRow==targetRow && startCol==targetCol) return 0;\\n        int rows=forest.size(), cols=forest[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        queue<pair<int,int>> q;\\n        q.push({startRow,startCol});\\n        vis[startRow][startCol]=1;\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                int r=q.front().first, c=q.front().second;\\n                q.pop();\\n                for(auto it: directions)\\n                {\\n                    int dr=r+it.first, dc=c+it.second;\\n                    if(dr<0 || dc<0 || dr>=rows || dc>=cols || forest[dr][dc]==0 || vis[dr][dc]) continue;\\n                    if(dr==targetRow && dc==targetCol) return level;\\n                    vis[dr][dc]=1;\\n                    q.push({dr,dc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& forest) \\n    {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        int rows=forest.size(), cols=forest[0].size();\\n        for(int r=0; r<rows; r++)\\n        {\\n            for(int c=0; c<cols; c++)\\n            {\\n                if(forest[r][c]>1)\\n                {\\n                    q.push({forest[r][c],{r,c}});\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int startRow=0, startCol=0;\\n        while(!q.empty())\\n        {\\n            int targetRow=q.top().second.first, targetCol=q.top().second.second;\\n            q.pop();\\n            int steps=bfs(startRow, startCol, targetRow, targetCol, forest);\\n            if(steps==-1) return -1;\\n            ans+=steps;\\n            startRow=targetRow, startCol=targetCol;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023370,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n\\ntypedef pair<int,pair<int,int>> pii;\\n\\nclass Solution {\\npublic:\\n    bool valid(int  x,int y,int n,int m)\\n    {\\n        return x>=0 && y>=0 && x<n && y<m;\\n    }\\n    int bfs(int x,int y,vector<vector<int>>& forest,int target)\\n    {\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        vis[x][y]=1;\\n        int deli[]={0,0,1,-1};\\n        int delj[]={1,-1,0,0};\\n        int steps=0;\\n        while(!q.empty())\\n        {\\n           int sz=q.size();\\n           while(sz--)\\n           {\\n               auto temp=q.front();\\n               q.pop();\\n               int xx=temp.first;\\n               int yy=temp.second;\\n               if (forest[xx][yy]==target) return steps;\\n               for (int i=0;i<4;i++)\\n               {\\n                   int newx=xx+deli[i];\\n                   int newy=yy+delj[i];\\n                   if (valid(newx,newy,n,m) && forest[newx][newy]>0 && vis[newx][newy]==0)\\n                   {\\n                     vis[newx][newy]=1;\\n                     q.push({newx,newy});\\n                   }\\n               }\\n           }\\n           steps++;\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& forest)\\n    {\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (forest[i][j]>1) pq.push({forest[i][j],{i,j}});\\n            }\\n        }\\n        int startx=0;\\n        int starty=0;\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            int target=temp.first;\\n            int dis=bfs(startx,starty,forest,target);\\n            if (dis==-1) return -1;\\n            ans+=dis;\\n            startx=temp.second.first;\\n            starty=temp.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef pair<int,pair<int,int>> pii;\\n\\nclass Solution {\\npublic:\\n    bool valid(int  x,int y,int n,int m)\\n    {\\n        return x>=0 && y>=0 && x<n && y<m;\\n    }\\n    int bfs(int x,int y,vector<vector<int>>& forest,int target)\\n    {\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        vis[x][y]=1;\\n        int deli[]={0,0,1,-1};\\n        int delj[]={1,-1,0,0};\\n        int steps=0;\\n        while(!q.empty())\\n        {\\n           int sz=q.size();\\n           while(sz--)\\n           {\\n               auto temp=q.front();\\n               q.pop();\\n               int xx=temp.first;\\n               int yy=temp.second;\\n               if (forest[xx][yy]==target) return steps;\\n               for (int i=0;i<4;i++)\\n               {\\n                   int newx=xx+deli[i];\\n                   int newy=yy+delj[i];\\n                   if (valid(newx,newy,n,m) && forest[newx][newy]>0 && vis[newx][newy]==0)\\n                   {\\n                     vis[newx][newy]=1;\\n                     q.push({newx,newy});\\n                   }\\n               }\\n           }\\n           steps++;\\n        }\\n        return -1;\\n    }\\n    int cutOffTree(vector<vector<int>>& forest)\\n    {\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (forest[i][j]>1) pq.push({forest[i][j],{i,j}});\\n            }\\n        }\\n        int startx=0;\\n        int starty=0;\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            int target=temp.first;\\n            int dis=bfs(startx,starty,forest,target);\\n            if (dis==-1) return -1;\\n            ans+=dis;\\n            startx=temp.second.first;\\n            starty=temp.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011984,
                "title": "bfs-heap",
                "content": "# Code\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        trees = []\\n        heapq.heapify(trees)\\n        m = len(forest)\\n        n = len(forest[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j]>1:\\n                    heapq.heappush(trees,(forest[i][j],i,j))\\n        curr = (0,0,0)\\n        res = 0\\n        while trees:\\n            queue = [curr]\\n            visited = set([(curr[0],curr[1])])\\n            find = False\\n            for i,j,d in queue:\\n                if (i,j) == (trees[0][1],trees[0][2]):\\n                    forest[i][j] = 1\\n                    res += d\\n                    curr = (i,j,0)\\n                    heapq.heappop(trees)\\n                    find = True\\n                    break\\n                else:\\n                    for di,dj in [(0,1),(1,0),(0,-1),(-1,0)]:\\n                        if 0<=i+di<m and 0<=j+dj<n and forest[i+di][j+dj] > 0 and (i+di,j+dj) not in visited:\\n                            visited.add((i+di,j+dj))\\n                            queue.append((i+di,j+dj,d+1))\\n            if not find:\\n                return -1\\n        return res\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        trees = []\\n        heapq.heapify(trees)\\n        m = len(forest)\\n        n = len(forest[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j]>1:\\n                    heapq.heappush(trees,(forest[i][j],i,j))\\n        curr = (0,0,0)\\n        res = 0\\n        while trees:\\n            queue = [curr]\\n            visited = set([(curr[0],curr[1])])\\n            find = False\\n            for i,j,d in queue:\\n                if (i,j) == (trees[0][1],trees[0][2]):\\n                    forest[i][j] = 1\\n                    res += d\\n                    curr = (i,j,0)\\n                    heapq.heappop(trees)\\n                    find = True\\n                    break\\n                else:\\n                    for di,dj in [(0,1),(1,0),(0,-1),(-1,0)]:\\n                        if 0<=i+di<m and 0<=j+dj<n and forest[i+di][j+dj] > 0 and (i+di,j+dj) not in visited:\\n                            visited.add((i+di,j+dj))\\n                            queue.append((i+di,j+dj,d+1))\\n            if not find:\\n                return -1\\n        return res\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965485,
                "title": "c-code-using-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint minDistance(const vector<vector<int>>& grid, int lastx, int lasty, int x, int y) {\\n    int rows = grid.size();\\n    int cols = grid[0].size();\\n    \\n    vector<vector<int>> distance(rows, vector<int>(cols, INT_MAX));\\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Possible directions: up, down, left, right\\n    \\n    queue<pair<int, int>> q;\\n    q.push({lastx, lasty});\\n    distance[lastx][lasty] = 0;\\n    \\n    while (!q.empty()) {\\n        int curx = q.front().first;\\n        int cury = q.front().second;\\n        q.pop();\\n        \\n        for (const auto& dir : directions) {\\n            int newx = curx + dir.first;\\n            int newy = cury + dir.second;\\n            \\n            if (newx >= 0 && newx < rows && newy >= 0 && newy < cols && grid[newx][newy] == 1) {\\n                if (distance[newx][newy] > distance[curx][cury] + 1) {\\n                    distance[newx][newy] = distance[curx][cury] + 1;\\n                    q.push({newx, newy});\\n                }\\n            }\\n        }\\n    }\\n    \\n    return distance[x][y] == INT_MAX ? -1 : distance[x][y];\\n}\\n    void check(vector<vector<int>> &mat, int x, int y, vector<vector<int>> &vis) {\\n    int rows = mat.size();\\n    int cols = mat[0].size();\\n\\n    if (x < 0 || x >= rows || y < 0 || y >= cols || mat[x][y] == 0 || vis[x][y]==1) {\\n        return  ;// Invalid point or blocked path\\n    }\\n\\n    vis[x][y] = 1;  // Mark the current position as visited\\n    mat[x][y] = 1 ; \\n    int dx[] = {-1, 1, 0, 0};\\n    int dy[] = {0, 0, -1, 1};\\n\\n    for (int i = 0; i < 4; ++i) {\\n        int newX = x + dx[i];\\n        int newY = y + dy[i];\\n\\n        check(mat, newX, newY, vis) ;\\n    }\\n    return ;\\n}\\n    int cutOffTree(vector<vector<int>>& mat) {\\n        int n = mat.size() , m= mat[0].size() ;\\n        if(mat[0][0]==0)return -1 ;\\n        long long int ans =0 ;\\n        vector<vector<int>> vis(n , vector<int> (m , 0)) ;\\n        vector<vector<int>> grid = mat ; \\n        check(grid , 0,0, vis) ;\\n        for(int i =0;i<n ;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]>1)return -1;\\n            }\\n        }\\n\\n        priority_queue< pair<int , pair<int, int >> , vector<pair<int , pair<int, int >>> , greater<pair<int , pair<int, int >>> > pq ; \\n        pq.push({1 , {0,0}}) ; \\n        for(int i =0;i<n ;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]>1)pq.push({mat[i][j] , {i,j}} ) ;\\n            }\\n        }\\n        int lastx=0,lasty=0 ;\\n        while(!pq.empty()){\\n            auto i = pq.top() ; \\n            pq.pop() ;\\n            int x =i.second.first;\\n            int y =i.second.second;\\n                ans+=minDistance(grid, lastx, lasty, x,y) ;\\n                mat[x][y] = 1 ;\\n                lastx = x ; \\n                lasty = y ; \\n            \\n        }\\n        for(int i =0;i<n ;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]>1)return -1;\\n            }\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint minDistance(const vector<vector<int>>& grid, int lastx, int lasty, int x, int y) {\\n    int rows = grid.size();\\n    int cols = grid[0].size();\\n    \\n    vector<vector<int>> distance(rows, vector<int>(cols, INT_MAX));\\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Possible directions: up, down, left, right\\n    \\n    queue<pair<int, int>> q;\\n    q.push({lastx, lasty});\\n    distance[lastx][lasty] = 0;\\n    \\n    while (!q.empty()) {\\n        int curx = q.front().first;\\n        int cury = q.front().second;\\n        q.pop();\\n        \\n        for (const auto& dir : directions) {\\n            int newx = curx + dir.first;\\n            int newy = cury + dir.second;\\n            \\n            if (newx >= 0 && newx < rows && newy >= 0 && newy < cols && grid[newx][newy] == 1) {\\n                if (distance[newx][newy] > distance[curx][cury] + 1) {\\n                    distance[newx][newy] = distance[curx][cury] + 1;\\n                    q.push({newx, newy});\\n                }\\n            }\\n        }\\n    }\\n    \\n    return distance[x][y] == INT_MAX ? -1 : distance[x][y];\\n}\\n    void check(vector<vector<int>> &mat, int x, int y, vector<vector<int>> &vis) {\\n    int rows = mat.size();\\n    int cols = mat[0].size();\\n\\n    if (x < 0 || x >= rows || y < 0 || y >= cols || mat[x][y] == 0 || vis[x][y]==1) {\\n        return  ;// Invalid point or blocked path\\n    }\\n\\n    vis[x][y] = 1;  // Mark the current position as visited\\n    mat[x][y] = 1 ; \\n    int dx[] = {-1, 1, 0, 0};\\n    int dy[] = {0, 0, -1, 1};\\n\\n    for (int i = 0; i < 4; ++i) {\\n        int newX = x + dx[i];\\n        int newY = y + dy[i];\\n\\n        check(mat, newX, newY, vis) ;\\n    }\\n    return ;\\n}\\n    int cutOffTree(vector<vector<int>>& mat) {\\n        int n = mat.size() , m= mat[0].size() ;\\n        if(mat[0][0]==0)return -1 ;\\n        long long int ans =0 ;\\n        vector<vector<int>> vis(n , vector<int> (m , 0)) ;\\n        vector<vector<int>> grid = mat ; \\n        check(grid , 0,0, vis) ;\\n        for(int i =0;i<n ;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]>1)return -1;\\n            }\\n        }\\n\\n        priority_queue< pair<int , pair<int, int >> , vector<pair<int , pair<int, int >>> , greater<pair<int , pair<int, int >>> > pq ; \\n        pq.push({1 , {0,0}}) ; \\n        for(int i =0;i<n ;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]>1)pq.push({mat[i][j] , {i,j}} ) ;\\n            }\\n        }\\n        int lastx=0,lasty=0 ;\\n        while(!pq.empty()){\\n            auto i = pq.top() ; \\n            pq.pop() ;\\n            int x =i.second.first;\\n            int y =i.second.second;\\n                ans+=minDistance(grid, lastx, lasty, x,y) ;\\n                mat[x][y] = 1 ;\\n                lastx = x ; \\n                lasty = y ; \\n            \\n        }\\n        for(int i =0;i<n ;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]>1)return -1;\\n            }\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954337,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> ( forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]) ));\\n        int output = 0;\\n        int prev[] = {0,0};\\n        int changeI[] = {0,0,1,-1};\\n        int changeJ[] = {1,-1,0,0};\\n\\n        for(int i = 0; i < forest.size(); i++){\\n            for(int j = 0; j < forest.get(0).size(); j++){\\n                if(forest.get(i).get(j) > 1){\\n                    pq.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        int count = 0;\\n        while(!pq.isEmpty()){\\n            int out[]  = pq.poll();\\n            System.out.println(Arrays.toString(out));\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.add(prev);\\n            boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n            boolean pathPresent = false;\\n            visited[prev[0]][prev[1]] = true;\\n            \\n            while(!queue.isEmpty()){\\n                \\n                int size = queue.size();\\n                for(int i = 0; i < size; i++){\\n                    int cur[] = queue.poll();\\n                    if(cur[0]==out[0] && cur[1]==out[1]){\\n                        pathPresent = true;\\n                        break;\\n                    }\\n                    for(int l = 0; l < 4; l++){\\n                        int newI = cur[0] + changeI[l];\\n                        int newJ = cur[1] + changeJ[l]; \\n                        if(newI >= 0 && newJ >=0 && newI < forest.size() && newJ < forest.get(0).size() && forest.get(newI).get(newJ) != 0 && !visited[newI][newJ]){\\n                            visited[newI][newJ] = true;\\n                            queue.add(new int[]{newI, newJ});\\n                        }\\n                    }\\n\\n                }\\n                if(pathPresent){\\n                    break;\\n                }\\n                \\n\\n                count++;\\n            }\\n            if(!pathPresent){\\n                return -1;\\n            }\\n            prev = out;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> ( forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]) ));\\n        int output = 0;\\n        int prev[] = {0,0};\\n        int changeI[] = {0,0,1,-1};\\n        int changeJ[] = {1,-1,0,0};\\n\\n        for(int i = 0; i < forest.size(); i++){\\n            for(int j = 0; j < forest.get(0).size(); j++){\\n                if(forest.get(i).get(j) > 1){\\n                    pq.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        int count = 0;\\n        while(!pq.isEmpty()){\\n            int out[]  = pq.poll();\\n            System.out.println(Arrays.toString(out));\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.add(prev);\\n            boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n            boolean pathPresent = false;\\n            visited[prev[0]][prev[1]] = true;\\n            \\n            while(!queue.isEmpty()){\\n                \\n                int size = queue.size();\\n                for(int i = 0; i < size; i++){\\n                    int cur[] = queue.poll();\\n                    if(cur[0]==out[0] && cur[1]==out[1]){\\n                        pathPresent = true;\\n                        break;\\n                    }\\n                    for(int l = 0; l < 4; l++){\\n                        int newI = cur[0] + changeI[l];\\n                        int newJ = cur[1] + changeJ[l]; \\n                        if(newI >= 0 && newJ >=0 && newI < forest.size() && newJ < forest.get(0).size() && forest.get(newI).get(newJ) != 0 && !visited[newI][newJ]){\\n                            visited[newI][newJ] = true;\\n                            queue.add(new int[]{newI, newJ});\\n                        }\\n                    }\\n\\n                }\\n                if(pathPresent){\\n                    break;\\n                }\\n                \\n\\n                count++;\\n            }\\n            if(!pathPresent){\\n                return -1;\\n            }\\n            prev = out;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938495,
                "title": "c-solution-with-best-indentation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pb push_back\\n#define ff first\\n#define ss second\\ntypedef pair<int,pair<int,int>> piii;\\ntypedef pair<int,int> pii;\\nclass Solution {\\nprivate:\\n    bool isSafe(int row, int col, int n, int m){\\n        if(row >= 0 && row < n && col >= 0 && col < m) return true;\\n        return false;\\n    }\\n    vector<pii> edges = {{-1,0},{1,0},{0,1},{0,-1}};\\n    int bfs(vector<vector<int>>& f, int sx, int sy, int ex, int ey){\\n        int n = f.size(); int m = f[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        queue<piii> q;\\n        q.push({0,{sx,sy}});\\n        vis[sx][sy] = 1;\\n\\n        while(!q.empty()){\\n            int row = q.front().ss.ff; int col = q.front().ss.ss; int dist = q.front().ff; q.pop();\\n            if(row == ex && col == ey) return dist; \\n\\n            for(auto edge : edges){\\n                int nrow = row + edge.ff;\\n                int ncol = col + edge.ss;\\n\\n                if(isSafe(nrow, ncol, n, m) && f[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n                    q.push({dist+1, {nrow, ncol}});\\n                    vis[nrow][ncol] = 1;\\n                } \\n            }\\n        }\\n\\n        return -1;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& f) {\\n        vector<piii> v;\\n        v.pb({0,{0,0}});\\n\\n        int n = f.size();\\n        int m = f[0].size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(i == 0 && j == 0){\\n                    if(f[i][j] > 1) v.pb({f[i][j], {i,j}});\\n                }\\n                else if(f[i][j] > 1) v.pb({f[i][j], {i,j}});\\n            }\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        int res = 0;\\n        for(int i = 0; i < v.size()-1; i++){\\n            int sx = v[i].ss.ff; int sy = v[i].ss.ss; int ex = v[i+1].ss.ff; int ey = v[i+1].ss.ss;\\n            int temp = bfs(f, sx, sy, ex, ey);\\n            if(temp == -1) return -1;\\n            res += temp;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pb push_back\\n#define ff first\\n#define ss second\\ntypedef pair<int,pair<int,int>> piii;\\ntypedef pair<int,int> pii;\\nclass Solution {\\nprivate:\\n    bool isSafe(int row, int col, int n, int m){\\n        if(row >= 0 && row < n && col >= 0 && col < m) return true;\\n        return false;\\n    }\\n    vector<pii> edges = {{-1,0},{1,0},{0,1},{0,-1}};\\n    int bfs(vector<vector<int>>& f, int sx, int sy, int ex, int ey){\\n        int n = f.size(); int m = f[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        queue<piii> q;\\n        q.push({0,{sx,sy}});\\n        vis[sx][sy] = 1;\\n\\n        while(!q.empty()){\\n            int row = q.front().ss.ff; int col = q.front().ss.ss; int dist = q.front().ff; q.pop();\\n            if(row == ex && col == ey) return dist; \\n\\n            for(auto edge : edges){\\n                int nrow = row + edge.ff;\\n                int ncol = col + edge.ss;\\n\\n                if(isSafe(nrow, ncol, n, m) && f[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n                    q.push({dist+1, {nrow, ncol}});\\n                    vis[nrow][ncol] = 1;\\n                } \\n            }\\n        }\\n\\n        return -1;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& f) {\\n        vector<piii> v;\\n        v.pb({0,{0,0}});\\n\\n        int n = f.size();\\n        int m = f[0].size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(i == 0 && j == 0){\\n                    if(f[i][j] > 1) v.pb({f[i][j], {i,j}});\\n                }\\n                else if(f[i][j] > 1) v.pb({f[i][j], {i,j}});\\n            }\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        int res = 0;\\n        for(int i = 0; i < v.size()-1; i++){\\n            int sx = v[i].ss.ff; int sy = v[i].ss.ss; int ex = v[i+1].ss.ff; int ey = v[i+1].ss.ss;\\n            int temp = bfs(f, sx, sy, ex, ey);\\n            if(temp == -1) return -1;\\n            res += temp;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938494,
                "title": "best-solution-c",
                "content": "```\\n#define pii pair<int, pair<int, int>>\\nclass Solution {\\npublic:\\n    int dir[5] = {-1, 0, 1, 0, -1};\\n    bool isValid(int nx, int ny, int n, int m){\\n        if(nx < 0 || nx >= n || ny < 0 || ny >= m) return false;\\n        return true;\\n    }\\n    int bfs(pair<int, int> s, pair<int,int> e, vector<vector<int>>& forest){\\n        int n = forest.size(), m = forest[0].size();\\n        priority_queue<pii, vector<pii>, greater<pii>> pq; // {dist, {x, y}}\\n        vector<vector<int>> dis(n, vector<int>(m, INT_MAX));\\n        \\n        pq.push({0,{s.first, s.second}});\\n        dis[s.first][s.second] = 0;\\n        \\n        while(!pq.empty()){\\n            auto curr = pq.top(); pq.pop();\\n            int dist = curr.first, x = curr.second.first, y = curr.second.second;    \\n            if(make_pair(x, y) == e) return dis[x][y];\\n            \\n            for(int i = 0; i < 4; i++){\\n                int nx =  x+ dir[i], ny = y + dir[i+1];\\n\\n                if(isValid(nx, ny, n, m) && dist+1 < dis[nx][ny] && forest[nx][ny] > 0){            \\n                    pq.push({dist+1, {nx, ny}});\\n                    dis[nx][ny] = 1 + dist;   \\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n = forest.size(), m = forest[0].size();\\n        \\n        vector<pii> trees;\\n        trees.push_back({0,{0,0}});\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int h = forest[i][j];\\n                \\n                if(i==0 and j==0){\\n                    if(h>1) trees.push_back({h, {i, j}});\\n                }else if(h>1){\\n                    trees.push_back({h, {i, j}});\\n                }\\n            }\\n        }\\n\\n        int res=0;\\n        sort(trees.begin(), trees.end());\\n\\n        for(int i = 0; i < trees.size()-1; i++){\\n            auto s = trees[i].second;\\n            auto e = trees[i+1].second;\\n\\n            int dist = bfs(s, e, forest);\\n            if(dist == -1){\\n                return -1;\\n            }else{\\n                res += dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int, pair<int, int>>\\nclass Solution {\\npublic:\\n    int dir[5] = {-1, 0, 1, 0, -1};\\n    bool isValid(int nx, int ny, int n, int m){\\n        if(nx < 0 || nx >= n || ny < 0 || ny >= m) return false;\\n        return true;\\n    }\\n    int bfs(pair<int, int> s, pair<int,int> e, vector<vector<int>>& forest){\\n        int n = forest.size(), m = forest[0].size();\\n        priority_queue<pii, vector<pii>, greater<pii>> pq; // {dist, {x, y}}\\n        vector<vector<int>> dis(n, vector<int>(m, INT_MAX));\\n        \\n        pq.push({0,{s.first, s.second}});\\n        dis[s.first][s.second] = 0;\\n        \\n        while(!pq.empty()){\\n            auto curr = pq.top(); pq.pop();\\n            int dist = curr.first, x = curr.second.first, y = curr.second.second;    \\n            if(make_pair(x, y) == e) return dis[x][y];\\n            \\n            for(int i = 0; i < 4; i++){\\n                int nx =  x+ dir[i], ny = y + dir[i+1];\\n\\n                if(isValid(nx, ny, n, m) && dist+1 < dis[nx][ny] && forest[nx][ny] > 0){            \\n                    pq.push({dist+1, {nx, ny}});\\n                    dis[nx][ny] = 1 + dist;   \\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n = forest.size(), m = forest[0].size();\\n        \\n        vector<pii> trees;\\n        trees.push_back({0,{0,0}});\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int h = forest[i][j];\\n                \\n                if(i==0 and j==0){\\n                    if(h>1) trees.push_back({h, {i, j}});\\n                }else if(h>1){\\n                    trees.push_back({h, {i, j}});\\n                }\\n            }\\n        }\\n\\n        int res=0;\\n        sort(trees.begin(), trees.end());\\n\\n        for(int i = 0; i < trees.size()-1; i++){\\n            auto s = trees[i].second;\\n            auto e = trees[i+1].second;\\n\\n            int dist = bfs(s, e, forest);\\n            if(dist == -1){\\n                return -1;\\n            }else{\\n                res += dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927422,
                "title": "easy-c-solution-with-intuition-and-approach-pq-bfs",
                "content": "# Intuition\\nAs there are trees of different distinct heights and we have to cut them in ascending order of their heights , \\n> Its for sure that if we have 4 trees with heights 1,2,3,4 at different positions in the forest , then we\\'ll cut the trees in the order 1->2->3->4 ; \\n\\nThus, we first sort the heights of the trees using a min-heap pq , and then just sum the distances of moving from the min to the second min and so on until only one element is left in the pq.\\n\\n> (i..e.. dist 1->2 + dist 2->3 + dist 3->4) , then only one element in pq which is 4 , which is the max height tree of the forest....\\n\\n# Approach\\n- First we store all the trees in a min-heap to attain their ascending sorted order.\\n- Then, we just sum the consequent distances of moving from the min height tree to the second min height tree and so on until only one tree is left in the minheap(which is the max height tree, marking that we have cut all the trees now and don\\'t need to continue any further).\\n- We find these distances of moving from one point to the other using simple bfs\\n- Dijikstra\\'s algorithm can also be used in order to optimize time but as the constraints are not that strict a simple bfs works for us here.\\n\\n---\\n> Do upvote if helpful , Happy Coding\\uD83C\\uDF86\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x[4]={0,0,1,-1};\\n    int y[4]={1,-1,0,0};\\n\\n    int bfs(vector<vector<int>> &forest,int curri,int currj,int dsti,int dstj,int m,int n){\\n        int out=0;\\n        queue<pair<int,int>> q;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        q.push({curri,currj});\\n        vis[curri][currj]=true;\\n        int steps=0;\\n\\n        while(!q.empty()){\\n            steps++;\\n            int size=q.size();\\n            while(size--){\\n                int i=q.front().first;\\n                int j=q.front().second;\\n                q.pop();\\n                if(i==dsti && j==dstj)return steps-1;\\n                for(int k=0;k<4;k++){\\n                    int nr=i+x[k];\\n                    int nc=j+y[k];\\n                    if(nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && forest[nr][nc]!=0){\\n                        if(nr==dsti && nc==dstj)return steps;\\n                        q.push({nr,nc});\\n                        vis[nr][nc]=true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m=forest.size();\\n        int n=forest[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(forest[i][j]>1)pq.push({forest[i][j],{i,j}});\\n            }\\n        }\\n        pq.push({1,{0,0}});\\n        int out=0;\\n        while(pq.size()>1){\\n            int curri=pq.top().second.first , currj=pq.top().second.second;\\n            pq.pop();\\n            int dsti=pq.top().second.first , dstj=pq.top().second.second;\\n            int temp=bfs(forest,curri,currj,dsti,dstj,m,n);\\n            if(temp==-1)return -1;\\n            out+=temp;\\n        }\\n        return out;\\n    }\\n};\\n```\\n![upvote xd.jpeg](https://assets.leetcode.com/users/images/e5e8e93f-0df9-4835-b71a-2a9468920807_1692369668.9972389.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,0,1,-1};\\n    int y[4]={1,-1,0,0};\\n\\n    int bfs(vector<vector<int>> &forest,int curri,int currj,int dsti,int dstj,int m,int n){\\n        int out=0;\\n        queue<pair<int,int>> q;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        q.push({curri,currj});\\n        vis[curri][currj]=true;\\n        int steps=0;\\n\\n        while(!q.empty()){\\n            steps++;\\n            int size=q.size();\\n            while(size--){\\n                int i=q.front().first;\\n                int j=q.front().second;\\n                q.pop();\\n                if(i==dsti && j==dstj)return steps-1;\\n                for(int k=0;k<4;k++){\\n                    int nr=i+x[k];\\n                    int nc=j+y[k];\\n                    if(nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && forest[nr][nc]!=0){\\n                        if(nr==dsti && nc==dstj)return steps;\\n                        q.push({nr,nc});\\n                        vis[nr][nc]=true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m=forest.size();\\n        int n=forest[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(forest[i][j]>1)pq.push({forest[i][j],{i,j}});\\n            }\\n        }\\n        pq.push({1,{0,0}});\\n        int out=0;\\n        while(pq.size()>1){\\n            int curri=pq.top().second.first , currj=pq.top().second.second;\\n            pq.pop();\\n            int dsti=pq.top().second.first , dstj=pq.top().second.second;\\n            int temp=bfs(forest,curri,currj,dsti,dstj,m,n);\\n            if(temp==-1)return -1;\\n            out+=temp;\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915895,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    static int[] dy = {-1, 0, 1, 0};\\n    static int[] dx = {0, 1, 0, -1};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int n = forest.size(), m = forest.get(0).size();\\n        int count = 0;\\n        \\n\\t\\t// Store the height of all trees in a list\\n        List<Integer> minList = new ArrayList<>();\\n        for (List<Integer> al: forest)\\n            for (int val: al) \\n                if (val > 1) \\n                    minList.add(val);\\n        \\n\\t\\t// Sort the list to have the smallest in the front\\n        Collections.sort(minList);\\n\\t\\t\\n        int totalSteps = 0;\\n        int si = 0, sj = 0; // Starting points <i, j>\\n        \\n        for (int i = 0; i < minList.size(); i++) {\\n            int target = minList.get(i);\\n            boolean hasFound = false;\\n            boolean[][] visited = new boolean[n][m];\\n\\t\\t\\t\\n            Queue<int[]> q = new LinkedList<>();\\n            q.offer(new int[]{si, sj});\\n        \\n            int steps = -1;\\n            while (!q.isEmpty() && !hasFound) {\\n                steps++; // Increment the steps for current move\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Level-Order Traversal\\n\\t\\t\\t\\tint size = q.size();\\n                while (size -- > 0) {\\n                    int[] curr = q.poll();\\n\\t\\t\\t\\t\\t\\n                    if (visited[curr[0]][curr[1]]) continue;\\n                    visited[curr[0]][curr[1]] = true;\\n                    \\n\\t\\t\\t\\t\\t// Skip if 0 is encountered\\n                    if (forest.get(curr[0]).get(curr[1]) == 0) continue;\\n                    \\n\\t\\t\\t\\t\\tif (forest.get(curr[0]).get(curr[1]) == target) {\\n                        si = curr[0];\\n                        sj = curr[1];\\n                        hasFound = true;\\n                        break;\\n                    }\\n\\n\\t\\t\\t\\t\\t// Typical BFS process\\n                    for (int j = 0; j < dy.length; j++) {\\n                        int y = curr[0] + dy[j];\\n                        int x = curr[1] + dx[j];\\n\\t\\t\\t\\t\\t\\t\\n                        if (y >= n || x >= m || y < 0 || x < 0 || visited[y][x] || forest.get(y).get(x) == 0)   \\n                            continue;\\n                        q.offer(new int[]{y, x});\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If the target is unreacheable, end the entire process\\n            if (steps == -1 || !hasFound) return -1;\\n\\n\\t\\t\\ttotalSteps += steps;\\n        }\\n        return totalSteps;\\n    }\\n}\\n```\\n\\n```python3 []\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0 :\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        def distance(node1, node2):\\n            now = [node1]\\n            soon = []\\n            expanded = set()\\n            manhattan = abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])\\n            detours = 0\\n            while True:\\n                if len(now) == 0:\\n                    now = soon\\n                    soon = []\\n                    detours += 1\\n                node = now.pop()\\n                if node == node2:\\n                    return manhattan + 2 * detours\\n                if node not in expanded:\\n                    expanded.add(node)\\n                    x, y = node\\n                    if x - 1 >= 0 and forest[x - 1][y] >= 1:\\n                        if x > node2[0]:\\n                            now.append((x - 1, y))\\n                        else:\\n                            soon.append((x - 1, y))\\n                    if y + 1 < n and forest[x][y + 1] >= 1:\\n                        if y < node2[1]:\\n                            now.append((x, y + 1))\\n                        else:\\n                            soon.append((x, y + 1))\\n                    if x + 1 < m and forest[x + 1][y] >= 1:\\n                        if x < node2[0]:\\n                            now.append((x + 1, y))\\n                        else:\\n                            soon.append((x + 1, y))\\n                    if y - 1 >= 0 and forest[x][y - 1] >= 1:\\n                        if y > node2[1]:\\n                            now.append((x, y - 1))\\n                        else:\\n                            soon.append((x, y - 1))\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append(((i, j), forest[i][j]))\\n        trees.sort(key=lambda x: x[1])\\n        can_reach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while len(stack) > 0:\\n            x, y = stack.pop()\\n            if x - 1 >= 0 and forest[x - 1][y] >= 1 and (x - 1, y) not in can_reach:\\n                can_reach.add((x - 1, y))\\n                stack.append((x - 1, y))\\n            if y + 1 < n and forest[x][y + 1] >= 1 and (x, y + 1) not in can_reach:\\n                can_reach.add((x, y + 1))\\n                stack.append((x, y + 1))\\n            if x + 1 < m and forest[x + 1][y] >= 1 and (x + 1, y) not in can_reach:\\n                can_reach.add((x + 1, y))\\n                stack.append((x + 1, y))\\n            if y - 1 >= 0  and forest[x][y - 1] >= 1 and (x, y - 1) not in can_reach:\\n                can_reach.add((x, y - 1))\\n                stack.append((x, y - 1))\\n        for t in trees:\\n            if t[0] not in can_reach:\\n                return -1\\n        start = (0, 0)\\n        num_step = 0\\n        for t in trees: \\n            num_step += distance(start, t[0])\\n            forest[t[0][0]][t[0][1]] = 1\\n            start = t[0]\\n        return num_step\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    static int[] dy = {-1, 0, 1, 0};\\n    static int[] dx = {0, 1, 0, -1};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int n = forest.size(), m = forest.get(0).size();\\n        int count = 0;\\n        \\n\\t\\t// Store the height of all trees in a list\\n        List<Integer> minList = new ArrayList<>();\\n        for (List<Integer> al: forest)\\n            for (int val: al) \\n                if (val > 1) \\n                    minList.add(val);\\n        \\n\\t\\t// Sort the list to have the smallest in the front\\n        Collections.sort(minList);\\n\\t\\t\\n        int totalSteps = 0;\\n        int si = 0, sj = 0; // Starting points <i, j>\\n        \\n        for (int i = 0; i < minList.size(); i++) {\\n            int target = minList.get(i);\\n            boolean hasFound = false;\\n            boolean[][] visited = new boolean[n][m];\\n\\t\\t\\t\\n            Queue<int[]> q = new LinkedList<>();\\n            q.offer(new int[]{si, sj});\\n        \\n            int steps = -1;\\n            while (!q.isEmpty() && !hasFound) {\\n                steps++; // Increment the steps for current move\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Level-Order Traversal\\n\\t\\t\\t\\tint size = q.size();\\n                while (size -- > 0) {\\n                    int[] curr = q.poll();\\n\\t\\t\\t\\t\\t\\n                    if (visited[curr[0]][curr[1]]) continue;\\n                    visited[curr[0]][curr[1]] = true;\\n                    \\n\\t\\t\\t\\t\\t// Skip if 0 is encountered\\n                    if (forest.get(curr[0]).get(curr[1]) == 0) continue;\\n                    \\n\\t\\t\\t\\t\\tif (forest.get(curr[0]).get(curr[1]) == target) {\\n                        si = curr[0];\\n                        sj = curr[1];\\n                        hasFound = true;\\n                        break;\\n                    }\\n\\n\\t\\t\\t\\t\\t// Typical BFS process\\n                    for (int j = 0; j < dy.length; j++) {\\n                        int y = curr[0] + dy[j];\\n                        int x = curr[1] + dx[j];\\n\\t\\t\\t\\t\\t\\t\\n                        if (y >= n || x >= m || y < 0 || x < 0 || visited[y][x] || forest.get(y).get(x) == 0)   \\n                            continue;\\n                        q.offer(new int[]{y, x});\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If the target is unreacheable, end the entire process\\n            if (steps == -1 || !hasFound) return -1;\\n\\n\\t\\t\\ttotalSteps += steps;\\n        }\\n        return totalSteps;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0 :\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        def distance(node1, node2):\\n            now = [node1]\\n            soon = []\\n            expanded = set()\\n            manhattan = abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])\\n            detours = 0\\n            while True:\\n                if len(now) == 0:\\n                    now = soon\\n                    soon = []\\n                    detours += 1\\n                node = now.pop()\\n                if node == node2:\\n                    return manhattan + 2 * detours\\n                if node not in expanded:\\n                    expanded.add(node)\\n                    x, y = node\\n                    if x - 1 >= 0 and forest[x - 1][y] >= 1:\\n                        if x > node2[0]:\\n                            now.append((x - 1, y))\\n                        else:\\n                            soon.append((x - 1, y))\\n                    if y + 1 < n and forest[x][y + 1] >= 1:\\n                        if y < node2[1]:\\n                            now.append((x, y + 1))\\n                        else:\\n                            soon.append((x, y + 1))\\n                    if x + 1 < m and forest[x + 1][y] >= 1:\\n                        if x < node2[0]:\\n                            now.append((x + 1, y))\\n                        else:\\n                            soon.append((x + 1, y))\\n                    if y - 1 >= 0 and forest[x][y - 1] >= 1:\\n                        if y > node2[1]:\\n                            now.append((x, y - 1))\\n                        else:\\n                            soon.append((x, y - 1))\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append(((i, j), forest[i][j]))\\n        trees.sort(key=lambda x: x[1])\\n        can_reach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while len(stack) > 0:\\n            x, y = stack.pop()\\n            if x - 1 >= 0 and forest[x - 1][y] >= 1 and (x - 1, y) not in can_reach:\\n                can_reach.add((x - 1, y))\\n                stack.append((x - 1, y))\\n            if y + 1 < n and forest[x][y + 1] >= 1 and (x, y + 1) not in can_reach:\\n                can_reach.add((x, y + 1))\\n                stack.append((x, y + 1))\\n            if x + 1 < m and forest[x + 1][y] >= 1 and (x + 1, y) not in can_reach:\\n                can_reach.add((x + 1, y))\\n                stack.append((x + 1, y))\\n            if y - 1 >= 0  and forest[x][y - 1] >= 1 and (x, y - 1) not in can_reach:\\n                can_reach.add((x, y - 1))\\n                stack.append((x, y - 1))\\n        for t in trees:\\n            if t[0] not in can_reach:\\n                return -1\\n        start = (0, 0)\\n        num_step = 0\\n        for t in trees: \\n            num_step += distance(start, t[0])\\n            forest[t[0][0]][t[0][1]] = 1\\n            start = t[0]\\n        return num_step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828616,
                "title": "solution-in-cpp",
                "content": "# Approach\\n1. Listing down the order of visiting cells.\\n2. Move from one cell to another based on order derieved in step 1.\\n    a. Use BFS to find minimum distance between two consecutive cells.\\n\\n# Complexity\\n- Time complexity:\\n$$O( rows^2 * columns^2)$$\\n\\n- Space complexity:\\n$$O(rows * columns)$$\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> gforest;\\n    pair<int,int> move[4] = {\\n        make_pair(0,1),\\n        make_pair(1,0),\\n        make_pair(0,-1),\\n        make_pair(-1,0)\\n    };\\n\\npublic:\\n    int bfs(pair<int,int> s, pair<int,int>des) {\\n        int mark[51][51];\\n        for (int i = 0 ; i < gforest.size(); i ++) {\\n            for (int j = 0 ; j < gforest[i].size() ; j ++) {\\n                mark[i][j] = 0;\\n            }\\n        }\\n        queue<pair<int,int> > q;\\n        q.push(s);\\n\\n        mark[s.first][s.second] = 1;\\n\\n        while(!q.empty()) {\\n            pair<int,int> nw = q.front();\\n            q.pop();\\n            if (nw == des) {\\n                return  mark[nw.first][nw.second] - 1;\\n            }\\n\\n            for(int i = 0 ; i < 4; i ++) {\\n                pair<int,int>nxt = make_pair(nw.first+move[i].first,nw.second+move[i].second);\\n               \\n                if (nxt.first < 0 || nxt.second < 0 || nxt.first >= gforest.size() || nxt.second >= gforest[0].size() || mark[nxt.first][nxt.second] || gforest[nxt.first][nxt.second] == 0) {\\n                    continue;\\n                }\\n\\n                mark[nxt.first][nxt.second] = 1 + mark[nw.first][nw.second];\\n                q.push(nxt);\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        gforest = forest;\\n\\n        vector<pair<int, pair<int,int> > > order;\\n        for(int i = 0 ; i < forest.size() ; i ++ ) {\\n            for (int j = 0 ; j < forest[i].size(); j ++) {\\n                if (forest[i][j] <= 1 ) continue;\\n                order.push_back(make_pair(forest[i][j], make_pair(i,j)));\\n            }\\n        }\\n\\n        int cost = 0;\\n        sort(order.begin(), order.end());\\n        if (order[0].second != make_pair(0,0)) {\\n            cost = bfs(make_pair(0,0), order[0].second);\\n            if (cost == - 1) {\\n                return -1;\\n            }\\n        }\\n\\n        for (int i = 1 ; i < order.size() ; i ++) {\\n            int dis = bfs(order[i-1].second, order[i].second);\\n            if (dis == -1) {\\n                return -1;\\n            }\\n            cost += dis;\\n        }\\n\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> gforest;\\n    pair<int,int> move[4] = {\\n        make_pair(0,1),\\n        make_pair(1,0),\\n        make_pair(0,-1),\\n        make_pair(-1,0)\\n    };\\n\\npublic:\\n    int bfs(pair<int,int> s, pair<int,int>des) {\\n        int mark[51][51];\\n        for (int i = 0 ; i < gforest.size(); i ++) {\\n            for (int j = 0 ; j < gforest[i].size() ; j ++) {\\n                mark[i][j] = 0;\\n            }\\n        }\\n        queue<pair<int,int> > q;\\n        q.push(s);\\n\\n        mark[s.first][s.second] = 1;\\n\\n        while(!q.empty()) {\\n            pair<int,int> nw = q.front();\\n            q.pop();\\n            if (nw == des) {\\n                return  mark[nw.first][nw.second] - 1;\\n            }\\n\\n            for(int i = 0 ; i < 4; i ++) {\\n                pair<int,int>nxt = make_pair(nw.first+move[i].first,nw.second+move[i].second);\\n               \\n                if (nxt.first < 0 || nxt.second < 0 || nxt.first >= gforest.size() || nxt.second >= gforest[0].size() || mark[nxt.first][nxt.second] || gforest[nxt.first][nxt.second] == 0) {\\n                    continue;\\n                }\\n\\n                mark[nxt.first][nxt.second] = 1 + mark[nw.first][nw.second];\\n                q.push(nxt);\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        gforest = forest;\\n\\n        vector<pair<int, pair<int,int> > > order;\\n        for(int i = 0 ; i < forest.size() ; i ++ ) {\\n            for (int j = 0 ; j < forest[i].size(); j ++) {\\n                if (forest[i][j] <= 1 ) continue;\\n                order.push_back(make_pair(forest[i][j], make_pair(i,j)));\\n            }\\n        }\\n\\n        int cost = 0;\\n        sort(order.begin(), order.end());\\n        if (order[0].second != make_pair(0,0)) {\\n            cost = bfs(make_pair(0,0), order[0].second);\\n            if (cost == - 1) {\\n                return -1;\\n            }\\n        }\\n\\n        for (int i = 1 ; i < order.size() ; i ++) {\\n            int dis = bfs(order[i-1].second, order[i].second);\\n            if (dis == -1) {\\n                return -1;\\n            }\\n            cost += dis;\\n        }\\n\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778112,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static constexpr int DIR[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n    struct Cell {\\n        short r : 8;\\n        short c : 8;\\n    };\\n    int doit(const vector<vector<int>>& forest, Cell start, vector<int> &curr, vector<int> &prev, vector<Cell> &bfs) {\\n        const int M = forest.size(), N = forest[0].size();\\n        int steps = 0;\\n        swap(curr, prev);\\n        fill(begin(curr), end(curr), -1);\\n        curr[start.r * N + start.c] = steps;\\n        if (prev[start.r * N + start.c] != -1) {\\n            return prev[start.r * N + start.c];\\n        }\\n        bfs.clear();\\n        bfs.push_back(start);\\n        while (!bfs.empty()) {\\n            int size = bfs.size();\\n            steps++;\\n            while (size--) {\\n                auto [r0, c0] = bfs[size];\\n                swap(bfs[size], bfs.back());\\n                bfs.pop_back();\\n                for (auto [dr, dc] : DIR) {\\n                    short r1 = r0 + dr, c1 = c0 + dc;\\n                    int pos = r1 * N + c1;\\n                    if (r1 >= 0 && r1 < M && c1 >= 0 && c1 < N && forest[r1][c1] > 0 && curr[pos] == -1) {\\n                        if (prev[pos] != -1) {\\n                            return steps + prev[pos];\\n                        }\\n                        curr[pos] = steps;\\n                        bfs.push_back({r1, c1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int manhattan_distance(vector<Cell> &cells) {\\n        int result = 0;\\n        Cell prev{0, 0};\\n        for (auto &cell : cells) {\\n            result += abs(prev.r - cell.r) + abs(prev.c - cell.c);\\n            prev = cell;\\n        }\\n        return result;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        const int M = forest.size(), N = forest[0].size();\\n        if (forest[0][0] == 0) {\\n            return -1;\\n        }\\n        int obstacles = 0;\\n        vector<Cell> cells;\\n        cells.reserve(8);\\n\\n        for (short r = 0; r < M; r++) {\\n            for (short c = 0; c < N; c++) {\\n                if (forest[r][c] > 1) {\\n                    cells.push_back({r, c});\\n                } else if (forest[r][c] == 0) {\\n                    obstacles++;\\n                }\\n            }\\n        }\\n        sort(begin(cells), end(cells), [&forest](const Cell &a, const Cell &b){\\n            return forest[a.r][a.c] < forest[b.r][b.c];\\n        });\\n        if (obstacles == 0) {\\n            return manhattan_distance(cells);\\n        }\\n        vector<int> curr(M * N, -1), prev = curr;\\n        curr[0] = 0;\\n\\n        vector<Cell> bfs;\\n        bfs.reserve(8);\\n\\n        int steps = 0;\\n\\n        for (auto &cell : cells) {\\n            int result = doit(forest, cell, curr, prev, bfs);\\n\\n            if (result != -1) {\\n                steps += result;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    static constexpr int DIR[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n    struct Cell {\\n        short r : 8;\\n        short c : 8;\\n    };\\n    int doit(const vector<vector<int>>& forest, Cell start, vector<int> &curr, vector<int> &prev, vector<Cell> &bfs) {\\n        const int M = forest.size(), N = forest[0].size();\\n        int steps = 0;\\n        swap(curr, prev);\\n        fill(begin(curr), end(curr), -1);\\n        curr[start.r * N + start.c] = steps;\\n        if (prev[start.r * N + start.c] != -1) {\\n            return prev[start.r * N + start.c];\\n        }\\n        bfs.clear();\\n        bfs.push_back(start);\\n        while (!bfs.empty()) {\\n            int size = bfs.size();\\n            steps++;\\n            while (size--) {\\n                auto [r0, c0] = bfs[size];\\n                swap(bfs[size], bfs.back());\\n                bfs.pop_back();\\n                for (auto [dr, dc] : DIR) {\\n                    short r1 = r0 + dr, c1 = c0 + dc;\\n                    int pos = r1 * N + c1;\\n                    if (r1 >= 0 && r1 < M && c1 >= 0 && c1 < N && forest[r1][c1] > 0 && curr[pos] == -1) {\\n                        if (prev[pos] != -1) {\\n                            return steps + prev[pos];\\n                        }\\n                        curr[pos] = steps;\\n                        bfs.push_back({r1, c1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int manhattan_distance(vector<Cell> &cells) {\\n        int result = 0;\\n        Cell prev{0, 0};\\n        for (auto &cell : cells) {\\n            result += abs(prev.r - cell.r) + abs(prev.c - cell.c);\\n            prev = cell;\\n        }\\n        return result;\\n    }\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        const int M = forest.size(), N = forest[0].size();\\n        if (forest[0][0] == 0) {\\n            return -1;\\n        }\\n        int obstacles = 0;\\n        vector<Cell> cells;\\n        cells.reserve(8);\\n\\n        for (short r = 0; r < M; r++) {\\n            for (short c = 0; c < N; c++) {\\n                if (forest[r][c] > 1) {\\n                    cells.push_back({r, c});\\n                } else if (forest[r][c] == 0) {\\n                    obstacles++;\\n                }\\n            }\\n        }\\n        sort(begin(cells), end(cells), [&forest](const Cell &a, const Cell &b){\\n            return forest[a.r][a.c] < forest[b.r][b.c];\\n        });\\n        if (obstacles == 0) {\\n            return manhattan_distance(cells);\\n        }\\n        vector<int> curr(M * N, -1), prev = curr;\\n        curr[0] = 0;\\n\\n        vector<Cell> bfs;\\n        bfs.reserve(8);\\n\\n        int steps = 0;\\n\\n        for (auto &cell : cells) {\\n            int result = doit(forest, cell, curr, prev, bfs);\\n\\n            if (result != -1) {\\n                steps += result;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753101,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int cur , n;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest.get(0).get(0) == 0) return -1;\\n        n = forest.get(0).size();\\n        cur = 0;\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (Integer.compare(forest.get(a/n).get(a%n), forest.get(b/n).get(b%n))));\\n        for (int i = 0; i < forest.size() ; i++)\\n            for (int j = 0; j < forest.get(0).size(); j++) \\n                if (forest.get(i).get(j) > 1) pq.offer(i*n + j);\\n        int ans = 0;\\n        final int [] dirs = new int [] {n,-n,1,-1};\\n        while(!pq.isEmpty() && cur > -1) ans += bfs (pq.poll(), forest, dirs);\\n        return cur == -1 ? -1 : ans;\\n    }\\n\\n    private int bfs(int to, List<List<Integer>> forest , int [] dirs){\\n        if (cur == to) return 0;\\n        int steps = 0;\\n        Set<Integer> visited = new HashSet();\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(cur);\\n        visited.add(cur);\\n        while(!q.isEmpty()){\\n            steps++;\\n            int size = q.size();\\n            for (int i= 0; i < size; i++){\\n                int from = q.poll(); \\n                for (int dir: dirs){\\n                    if (n!=1 && ((dir == 1 && from % n == n-1)  || (dir == -1 && from % n == 0))) continue; // cant jump to next row first cell from last cell\\n                    int next = from + dir;\\n                    if (next < 0 || next >= forest.size() * n || forest.get(next/n).get(next%n) == 0 || !visited.add(next)) continue;\\n                    if (next == to) {\\n                        forest.get(next/n).set(next%n, 1) ;\\n                        cur = to;\\n                        return steps;\\n                    }\\n                    q.offer(next);\\n                }\\n            }\\n        }     \\n        cur = -1;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int cur , n;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest.get(0).get(0) == 0) return -1;\\n        n = forest.get(0).size();\\n        cur = 0;\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (Integer.compare(forest.get(a/n).get(a%n), forest.get(b/n).get(b%n))));\\n        for (int i = 0; i < forest.size() ; i++)\\n            for (int j = 0; j < forest.get(0).size(); j++) \\n                if (forest.get(i).get(j) > 1) pq.offer(i*n + j);\\n        int ans = 0;\\n        final int [] dirs = new int [] {n,-n,1,-1};\\n        while(!pq.isEmpty() && cur > -1) ans += bfs (pq.poll(), forest, dirs);\\n        return cur == -1 ? -1 : ans;\\n    }\\n\\n    private int bfs(int to, List<List<Integer>> forest , int [] dirs){\\n        if (cur == to) return 0;\\n        int steps = 0;\\n        Set<Integer> visited = new HashSet();\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(cur);\\n        visited.add(cur);\\n        while(!q.isEmpty()){\\n            steps++;\\n            int size = q.size();\\n            for (int i= 0; i < size; i++){\\n                int from = q.poll(); \\n                for (int dir: dirs){\\n                    if (n!=1 && ((dir == 1 && from % n == n-1)  || (dir == -1 && from % n == 0))) continue; // cant jump to next row first cell from last cell\\n                    int next = from + dir;\\n                    if (next < 0 || next >= forest.size() * n || forest.get(next/n).get(next%n) == 0 || !visited.add(next)) continue;\\n                    if (next == to) {\\n                        forest.get(next/n).set(next%n, 1) ;\\n                        cur = to;\\n                        return steps;\\n                    }\\n                    q.offer(next);\\n                }\\n            }\\n        }     \\n        cur = -1;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713829,
                "title": "c-easy-to-understand-visited-boolean-matrix-bfs-sorting-hashing",
                "content": "**Approach**\\nFirst things first, I store all the trees to be cut in a vector and sort them so as to traverse linearly. Then, i check for the base-case where the starting point is a wall, if true return -1.\\n\\nThen, i iterate through the vector, with the initial starting point as {0,0} and target point as the location of the tree with smallest height of the vector sorted in ascending order which is at 0th index.\\n\\nThen, as i iterate i update the starting point as the previous target point and target point as the location of the current tree to be cut. Then, i perform an iterative bfs call and if the result is -1, meaning the tree couldn\\'t be reached anyhow, return -1 otherwise add up the result.\\n\\nIn bfs function, i check for the base case when starting point and target point are same, return 0 if true. I store the location in a queue, a typical data structure used for bfs traversal. I create a boolean visited vector of same dimensions as that of grid. Initially, i push the starting point and mark it as visted. Then, i perform a level by level bfs traversal where i increment moves for every level, check if the unvisited non-wall neighbour cell is the target cell, if true, return moves. Else mark the parent as well as neighbouring cell as visited and if out of bounds, check for the next neighbour.\\n\\nIf the queue gets empty without returning moves, means we weren\\'t able to reach the target, in that case, return -1.\\n\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    \\n    int cutOffTree(vector<vector<int>>& grid) {\\n        \\n       vector<pair<int,pair<int,int>>> v;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>1)\\n                    v.push_back({grid[i][j],{i,j}});\\n            }\\n        }\\n        \\n        if(grid[0][0]==0)return -1;\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        int m=grid.size(),n=grid[0].size(),tx,ty;\\n        \\n            for(int i=0,sx=0,sy=0;i<v.size();i++){\\n                \\n                \\n                tx=v[i].second.first,ty=v[i].second.second;\\n                \\n                \\n                int result=bfs(grid,sx,sy,tx,ty);\\n                \\n                if(result==-1)return -1;\\n                else ans+=result;\\n                \\n                sx=tx,sy=ty;\\n            }\\n            return ans;\\n      \\n    }\\n    \\n    \\nprivate:\\n    \\n    int bfs(vector<vector<int>>& grid,int& sx,int& sy,int& tx,int& ty){\\n        if(sx==tx and sy==ty)return 0;\\n        queue<pair<int,int>> q;\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        //stack<pair<int,pair<int,int>>> st;\\n        q.push({sx,sy});\\n        vis[sx][sy]=true;\\n        int moves=0;\\n        \\n        while(!q.empty()){\\n            moves++;\\n            \\n            int si=q.size();\\n            \\n            vector<int> dir={-1,0,1,0,-1};\\n            \\n            while(si--){\\n                int i=q.front().first,j=q.front().second;\\n                vis[i][j]=true;\\n                \\n                q.pop();\\n                if(i==tx and j==ty){\\n                    return moves-1;\\n                }\\n                \\n                for(int a=0;a<4;a++){\\n                    int r=i+dir[a],c=j+dir[a+1];\\n                    \\n                    if(r<0 or c<0 or r>=m or c>=n or grid[r][c]==0 or vis[r][c])\\n                        continue;\\n                    \\n                    vis[r][c]=true;\\n                    q.push({r,c});\\n                }\\n                   \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n\\n##### If u like the code and approach, pls UPVOTE..it motivates me to write further solutions.\\n\\nThanks in advance!**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int cutOffTree(vector<vector<int>>& grid) {\\n        \\n       vector<pair<int,pair<int,int>>> v;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>1)\\n                    v.push_back({grid[i][j],{i,j}});\\n            }\\n        }\\n        \\n        if(grid[0][0]==0)return -1;\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        int m=grid.size(),n=grid[0].size(),tx,ty;\\n        \\n            for(int i=0,sx=0,sy=0;i<v.size();i++){\\n                \\n                \\n                tx=v[i].second.first,ty=v[i].second.second;\\n                \\n                \\n                int result=bfs(grid,sx,sy,tx,ty);\\n                \\n                if(result==-1)return -1;\\n                else ans+=result;\\n                \\n                sx=tx,sy=ty;\\n            }\\n            return ans;\\n      \\n    }\\n    \\n    \\nprivate:\\n    \\n    int bfs(vector<vector<int>>& grid,int& sx,int& sy,int& tx,int& ty){\\n        if(sx==tx and sy==ty)return 0;\\n        queue<pair<int,int>> q;\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        //stack<pair<int,pair<int,int>>> st;\\n        q.push({sx,sy});\\n        vis[sx][sy]=true;\\n        int moves=0;\\n        \\n        while(!q.empty()){\\n            moves++;\\n            \\n            int si=q.size();\\n            \\n            vector<int> dir={-1,0,1,0,-1};\\n            \\n            while(si--){\\n                int i=q.front().first,j=q.front().second;\\n                vis[i][j]=true;\\n                \\n                q.pop();\\n                if(i==tx and j==ty){\\n                    return moves-1;\\n                }\\n                \\n                for(int a=0;a<4;a++){\\n                    int r=i+dir[a],c=j+dir[a+1];\\n                    \\n                    if(r<0 or c<0 or r>=m or c>=n or grid[r][c]==0 or vis[r][c])\\n                        continue;\\n                    \\n                    vis[r][c]=true;\\n                    q.push({r,c});\\n                }\\n                   \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657050,
                "title": "java-optimal-solution-best-solution-to-understand-priority-queue-bfs",
                "content": "# Intuition\\nBFS was definitely going to be used, along with PriorityQueue maintaing the next tree to be cut and global state to store row and col position.\\n\\n# Approach\\n- Converted **List<List<Integer>> to int[][]** to save time in operations.\\n- Maintained **global variables row and col** to store current position in the grid.\\n- Used **PriorityQueue to get the height of next Tree** to be cut, So the steps include the **minimum path from current row and col to the tree with the height which is least in PriorityQueue**.\\n- Used **BFS to get minimum path**.\\n- If **no path found return -1**;\\n- Add the value and repeat these steps to get ans.\\n\\n# PLEASE UPVOTE !!! if you liked my solution.....\\n\\n# Code\\n```\\nclass Solution {\\n        int row=0;    //to maintain current global positions row\\n        int col=0;    //to maintain current global positions col\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int m=forest.size();\\n        int n=forest.get(0).size();\\n        int[][] grid=new int[m][n];   //creating int[][] to reduce time.\\n        int steps=0;                  //steps as ans\\n\\n        //PriorityQueue to get the height of next Tree to be cut\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int num=forest.get(i).get(j);\\n                grid[i][j]=num;    //storing in grid\\n                if(num>1){\\n                    pq.add(num);   //adding to PriorityQueue\\n                }\\n            }\\n        }\\n        //get trees in ascending order to be visited\\n        while(pq.size()>0){\\n            int val=bfs(pq.poll(),grid,m,n);   //get steps to reach from current position to the tree with least height left\\n            if(val==-1) return -1;     //if no path return -1\\n            steps+=val;                //add to total steps\\n        }\\n        return steps;\\n    }\\n    public int bfs(int num,int[][] forest,int m,int n){\\n        int[][] grid=forest.clone();\\n        for(int i=0;i<m;i++){\\n            grid[i]=forest[i].clone();\\n        }\\n        //cloning grid so as to change variabled temporary and not in global grid.\\n        Queue<int[]> q=new LinkedList();      //Queue for bfs\\n        q.add(new int[]{row,col});           //adding current global position to the queue\\n        int steps=0;      //minimum steps to go from row,col to the height(num) of tree\\n        while(q.size()>0){\\n            int k=q.size();\\n            //in one step followng can be traversed\\n            for(int i=0;i<k;i++){\\n                int[] ar=q.poll();\\n                int r=ar[0];\\n                int c=ar[1];\\n                int val=grid[r][c];       \\n                if(val!=0){\\n                    //IF WE GET THE SPECEFIC TREE WITH HEIGHT NUM \\n                    if(val==num) {\\n                        //CHANGE CURRENT GLOBAL POSITION TO THE TREE FOUND\\n                        row=r;\\n                        col=c;         \\n                        //return minimum steps           \\n                        return steps;\\n                    }\\n                    grid[r][c]=0;    //change to 0 so as to not visit again in this iteration\\n                    //checking bounds and if there is tree add to queue\\n                    if(r+1<m &&grid[r+1][c]>0) q.add(new int[]{r+1,c});\\n                    if(r-1>=0 && grid[r-1][c]>0) q.add(new int[]{r-1,c});\\n                    if(c+1<n && grid[r][c+1]>0) q.add(new int[]{r,c+1});\\n                    if(c-1>=0 && grid[r][c-1]>0) q.add(new int[]{r,c-1});\\n                }\\n            }\\n            steps++;\\n        }\\n        //if tree not found return -1;\\n        return -1;\\n    }\\n}\\n```\\n# Code without comments below\\n```\\nclass Solution {\\n        int row=0;\\n        int col=0;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int m=forest.size();\\n        int n=forest.get(0).size();\\n        int[][] grid=new int[m][n];\\n        int steps=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int num=forest.get(i).get(j);\\n                grid[i][j]=num;\\n                if(num>1){\\n                    pq.add(num);\\n                }\\n            }\\n        }\\n        while(pq.size()>0){\\n            int val=bfs(pq.poll(),grid,m,n);\\n            if(val==-1) return -1;\\n            steps+=val;\\n        }\\n        return steps;\\n    }\\n    public int bfs(int num,int[][] forest,int m,int n){\\n        int[][] grid=forest.clone();\\n        for(int i=0;i<m;i++){\\n            grid[i]=forest[i].clone();\\n        }\\n        Queue<int[]> q=new LinkedList();\\n        q.add(new int[]{row,col});\\n        int steps=0;\\n        while(q.size()>0){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                int[] ar=q.poll();\\n                int r=ar[0];\\n                int c=ar[1];\\n                int val=grid[r][c];\\n                if(val!=0){\\n                    if(val==num) {\\n                        row=r;\\n                        col=c;                    \\n                        return steps;\\n                    }\\n                    grid[r][c]=0;\\n                    if(r+1<m &&grid[r+1][c]>0) q.add(new int[]{r+1,c});\\n                    if(r-1>=0 && grid[r-1][c]>0) q.add(new int[]{r-1,c});\\n                    if(c+1<n && grid[r][c+1]>0) q.add(new int[]{r,c+1});\\n                    if(c-1>=0 && grid[r][c-1]>0) q.add(new int[]{r,c-1});\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n        int row=0;    //to maintain current global positions row\\n        int col=0;    //to maintain current global positions col\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int m=forest.size();\\n        int n=forest.get(0).size();\\n        int[][] grid=new int[m][n];   //creating int[][] to reduce time.\\n        int steps=0;                  //steps as ans\\n\\n        //PriorityQueue to get the height of next Tree to be cut\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int num=forest.get(i).get(j);\\n                grid[i][j]=num;    //storing in grid\\n                if(num>1){\\n                    pq.add(num);   //adding to PriorityQueue\\n                }\\n            }\\n        }\\n        //get trees in ascending order to be visited\\n        while(pq.size()>0){\\n            int val=bfs(pq.poll(),grid,m,n);   //get steps to reach from current position to the tree with least height left\\n            if(val==-1) return -1;     //if no path return -1\\n            steps+=val;                //add to total steps\\n        }\\n        return steps;\\n    }\\n    public int bfs(int num,int[][] forest,int m,int n){\\n        int[][] grid=forest.clone();\\n        for(int i=0;i<m;i++){\\n            grid[i]=forest[i].clone();\\n        }\\n        //cloning grid so as to change variabled temporary and not in global grid.\\n        Queue<int[]> q=new LinkedList();      //Queue for bfs\\n        q.add(new int[]{row,col});           //adding current global position to the queue\\n        int steps=0;      //minimum steps to go from row,col to the height(num) of tree\\n        while(q.size()>0){\\n            int k=q.size();\\n            //in one step followng can be traversed\\n            for(int i=0;i<k;i++){\\n                int[] ar=q.poll();\\n                int r=ar[0];\\n                int c=ar[1];\\n                int val=grid[r][c];       \\n                if(val!=0){\\n                    //IF WE GET THE SPECEFIC TREE WITH HEIGHT NUM \\n                    if(val==num) {\\n                        //CHANGE CURRENT GLOBAL POSITION TO THE TREE FOUND\\n                        row=r;\\n                        col=c;         \\n                        //return minimum steps           \\n                        return steps;\\n                    }\\n                    grid[r][c]=0;    //change to 0 so as to not visit again in this iteration\\n                    //checking bounds and if there is tree add to queue\\n                    if(r+1<m &&grid[r+1][c]>0) q.add(new int[]{r+1,c});\\n                    if(r-1>=0 && grid[r-1][c]>0) q.add(new int[]{r-1,c});\\n                    if(c+1<n && grid[r][c+1]>0) q.add(new int[]{r,c+1});\\n                    if(c-1>=0 && grid[r][c-1]>0) q.add(new int[]{r,c-1});\\n                }\\n            }\\n            steps++;\\n        }\\n        //if tree not found return -1;\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n        int row=0;\\n        int col=0;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int m=forest.size();\\n        int n=forest.get(0).size();\\n        int[][] grid=new int[m][n];\\n        int steps=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int num=forest.get(i).get(j);\\n                grid[i][j]=num;\\n                if(num>1){\\n                    pq.add(num);\\n                }\\n            }\\n        }\\n        while(pq.size()>0){\\n            int val=bfs(pq.poll(),grid,m,n);\\n            if(val==-1) return -1;\\n            steps+=val;\\n        }\\n        return steps;\\n    }\\n    public int bfs(int num,int[][] forest,int m,int n){\\n        int[][] grid=forest.clone();\\n        for(int i=0;i<m;i++){\\n            grid[i]=forest[i].clone();\\n        }\\n        Queue<int[]> q=new LinkedList();\\n        q.add(new int[]{row,col});\\n        int steps=0;\\n        while(q.size()>0){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                int[] ar=q.poll();\\n                int r=ar[0];\\n                int c=ar[1];\\n                int val=grid[r][c];\\n                if(val!=0){\\n                    if(val==num) {\\n                        row=r;\\n                        col=c;                    \\n                        return steps;\\n                    }\\n                    grid[r][c]=0;\\n                    if(r+1<m &&grid[r+1][c]>0) q.add(new int[]{r+1,c});\\n                    if(r-1>=0 && grid[r-1][c]>0) q.add(new int[]{r-1,c});\\n                    if(c+1<n && grid[r][c+1]>0) q.add(new int[]{r,c+1});\\n                    if(c-1>=0 && grid[r][c-1]>0) q.add(new int[]{r,c-1});\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650159,
                "title": "bfs",
                "content": "# Code\\n```\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m, n = len(forest), len(forest[0])\\n\\n        # Step 1: Extract and sort tree positions\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append((forest[i][j], i, j))\\n        trees.sort()\\n\\n        # Step 2: Helper function for BFS\\n        def bfs(start, target):\\n            queue = deque([(start[0], start[1], 0)])\\n            visited = set([(start[0], start[1])])\\n\\n            while queue:\\n                x, y, steps = queue.popleft()\\n                if x == target[0] and y == target[1]:\\n                    return steps\\n\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] != 0 and (nx, ny) not in visited:\\n                        queue.append((nx, ny, steps + 1))\\n                        visited.add((nx, ny))\\n\\n            return -1\\n\\n        # Step 3 and 4: Iterate over trees and calculate steps\\n        steps = 0\\n        cur_pos = (0, 0)\\n        for _, target_x, target_y in trees:\\n            cur_steps = bfs(cur_pos, (target_x, target_y))\\n            if cur_steps == -1:\\n                return -1\\n            steps += cur_steps\\n            cur_pos = (target_x, target_y)\\n\\n        return steps\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        m, n = len(forest), len(forest[0])\\n\\n        # Step 1: Extract and sort tree positions\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append((forest[i][j], i, j))\\n        trees.sort()\\n\\n        # Step 2: Helper function for BFS\\n        def bfs(start, target):\\n            queue = deque([(start[0], start[1], 0)])\\n            visited = set([(start[0], start[1])])\\n\\n            while queue:\\n                x, y, steps = queue.popleft()\\n                if x == target[0] and y == target[1]:\\n                    return steps\\n\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] != 0 and (nx, ny) not in visited:\\n                        queue.append((nx, ny, steps + 1))\\n                        visited.add((nx, ny))\\n\\n            return -1\\n\\n        # Step 3 and 4: Iterate over trees and calculate steps\\n        steps = 0\\n        cur_pos = (0, 0)\\n        for _, target_x, target_y in trees:\\n            cur_steps = bfs(cur_pos, (target_x, target_y))\\n            if cur_steps == -1:\\n                return -1\\n            steps += cur_steps\\n            cur_pos = (target_x, target_y)\\n\\n        return steps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634010,
                "title": "bfs-in-increasing-order",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0:\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        vals = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] not in {0, 1}:\\n                    vals.add((forest[i][j], i, j))\\n        vals = [(0, 0, 0)] + sorted(vals)\\n        k = len(vals)\\n        res = 0\\n        for pos in range(k - 1):\\n            vv, ii, jj = vals[pos]\\n            q = deque([(ii, jj, 0)])\\n            v = {(ii, jj)}\\n            found = False\\n            while len(q) > 0:\\n                i, j, d = q.pop()\\n                if forest[i][j] == vals[pos + 1][0]:\\n                    res += d\\n                    found = True\\n                    break\\n                for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\\n                    if 0 <= x < m and 0 <= y < n and forest[x][y] != 0 and (x, y) not in v:\\n                        v.add((x, y))\\n                        q.appendleft((x, y, d + 1))\\n            if not found:\\n                return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0:\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        vals = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] not in {0, 1}:\\n                    vals.add((forest[i][j], i, j))\\n        vals = [(0, 0, 0)] + sorted(vals)\\n        k = len(vals)\\n        res = 0\\n        for pos in range(k - 1):\\n            vv, ii, jj = vals[pos]\\n            q = deque([(ii, jj, 0)])\\n            v = {(ii, jj)}\\n            found = False\\n            while len(q) > 0:\\n                i, j, d = q.pop()\\n                if forest[i][j] == vals[pos + 1][0]:\\n                    res += d\\n                    found = True\\n                    break\\n                for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\\n                    if 0 <= x < m and 0 <= y < n and forest[x][y] != 0 and (x, y) not in v:\\n                        v.add((x, y))\\n                        q.appendleft((x, y, d + 1))\\n            if not found:\\n                return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582830,
                "title": "99-45-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0 :\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        def distance(node1, node2):\\n            now = [node1]\\n            soon = []\\n            expanded = set()\\n            manhattan = abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])\\n            detours = 0\\n            while True:\\n                if len(now) == 0:\\n                    now = soon\\n                    soon = []\\n                    detours += 1\\n                node = now.pop()\\n                if node == node2:\\n                    return manhattan + 2 * detours\\n                if node not in expanded:\\n                    expanded.add(node)\\n                    x, y = node\\n                    if x - 1 >= 0 and forest[x - 1][y] >= 1:\\n                        if x > node2[0]:\\n                            now.append((x - 1, y))\\n                        else:\\n                            soon.append((x - 1, y))\\n                    if y + 1 < n and forest[x][y + 1] >= 1:\\n                        if y < node2[1]:\\n                            now.append((x, y + 1))\\n                        else:\\n                            soon.append((x, y + 1))\\n                    if x + 1 < m and forest[x + 1][y] >= 1:\\n                        if x < node2[0]:\\n                            now.append((x + 1, y))\\n                        else:\\n                            soon.append((x + 1, y))\\n                    if y - 1 >= 0 and forest[x][y - 1] >= 1:\\n                        if y > node2[1]:\\n                            now.append((x, y - 1))\\n                        else:\\n                            soon.append((x, y - 1))\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append(((i, j), forest[i][j]))\\n        trees.sort(key=lambda x: x[1])\\n        can_reach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while len(stack) > 0:\\n            x, y = stack.pop()\\n            if x - 1 >= 0 and forest[x - 1][y] >= 1 and (x - 1, y) not in can_reach:\\n                can_reach.add((x - 1, y))\\n                stack.append((x - 1, y))\\n            if y + 1 < n and forest[x][y + 1] >= 1 and (x, y + 1) not in can_reach:\\n                can_reach.add((x, y + 1))\\n                stack.append((x, y + 1))\\n            if x + 1 < m and forest[x + 1][y] >= 1 and (x + 1, y) not in can_reach:\\n                can_reach.add((x + 1, y))\\n                stack.append((x + 1, y))\\n            if y - 1 >= 0  and forest[x][y - 1] >= 1 and (x, y - 1) not in can_reach:\\n                can_reach.add((x, y - 1))\\n                stack.append((x, y - 1))\\n        for t in trees:\\n            if t[0] not in can_reach:\\n                return -1\\n        start = (0, 0)\\n        num_step = 0\\n        for t in trees: \\n            num_step += distance(start, t[0])\\n            forest[t[0][0]][t[0][1]] = 1\\n            start = t[0]\\n        return num_step\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0 :\\n            return -1\\n        m = len(forest)\\n        n = len(forest[0])\\n        def distance(node1, node2):\\n            now = [node1]\\n            soon = []\\n            expanded = set()\\n            manhattan = abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])\\n            detours = 0\\n            while True:\\n                if len(now) == 0:\\n                    now = soon\\n                    soon = []\\n                    detours += 1\\n                node = now.pop()\\n                if node == node2:\\n                    return manhattan + 2 * detours\\n                if node not in expanded:\\n                    expanded.add(node)\\n                    x, y = node\\n                    if x - 1 >= 0 and forest[x - 1][y] >= 1:\\n                        if x > node2[0]:\\n                            now.append((x - 1, y))\\n                        else:\\n                            soon.append((x - 1, y))\\n                    if y + 1 < n and forest[x][y + 1] >= 1:\\n                        if y < node2[1]:\\n                            now.append((x, y + 1))\\n                        else:\\n                            soon.append((x, y + 1))\\n                    if x + 1 < m and forest[x + 1][y] >= 1:\\n                        if x < node2[0]:\\n                            now.append((x + 1, y))\\n                        else:\\n                            soon.append((x + 1, y))\\n                    if y - 1 >= 0 and forest[x][y - 1] >= 1:\\n                        if y > node2[1]:\\n                            now.append((x, y - 1))\\n                        else:\\n                            soon.append((x, y - 1))\\n        trees = []\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    trees.append(((i, j), forest[i][j]))\\n        trees.sort(key=lambda x: x[1])\\n        can_reach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while len(stack) > 0:\\n            x, y = stack.pop()\\n            if x - 1 >= 0 and forest[x - 1][y] >= 1 and (x - 1, y) not in can_reach:\\n                can_reach.add((x - 1, y))\\n                stack.append((x - 1, y))\\n            if y + 1 < n and forest[x][y + 1] >= 1 and (x, y + 1) not in can_reach:\\n                can_reach.add((x, y + 1))\\n                stack.append((x, y + 1))\\n            if x + 1 < m and forest[x + 1][y] >= 1 and (x + 1, y) not in can_reach:\\n                can_reach.add((x + 1, y))\\n                stack.append((x + 1, y))\\n            if y - 1 >= 0  and forest[x][y - 1] >= 1 and (x, y - 1) not in can_reach:\\n                can_reach.add((x, y - 1))\\n                stack.append((x, y - 1))\\n        for t in trees:\\n            if t[0] not in can_reach:\\n                return -1\\n        start = (0, 0)\\n        num_step = 0\\n        for t in trees: \\n            num_step += distance(start, t[0])\\n            forest[t[0][0]][t[0][1]] = 1\\n            start = t[0]\\n        return num_step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539907,
                "title": "python-bfs-why-is-this-tle-it-seems-like-it-is-right",
                "content": "```\\nfrom queue import PriorityQueue\\nfrom queue import Queue\\nclass Solution:\\n    def bfs(self, forest, begin, target) -> int:\\n        if begin == target:\\n            return 0\\n        q = Queue()\\n        steps = 0\\n        q.put((begin, 0))\\n        visited = [[False for j in range(len(forest[0]))] for i in range(len(forest))]\\n        visited[begin[0]][begin[1]] = True\\n        while q.qsize() > 0:\\n            at = q.get()\\n            c = at[0]\\n            dist = at[1]\\n            row = c[0]\\n            col = c[1]\\n            visited[row][col] = True\\n            if row == target[0] and col == target[1]:\\n                return dist\\n            \\n            if row < len(forest) - 1 and forest[row+1][col] != 0 and not visited[row+1][col]:\\n                q.put(((row+1, col), dist+1))\\n            if row > 0 and forest[row-1][col] != 0 and not visited[row-1][col]:\\n                q.put(((row-1, col), dist+1))\\n            if col < len(forest[0]) - 1 and forest[row][col + 1] != 0 and not visited[row][col + 1]:\\n                q.put(((row, col+1), dist+1))\\n            if col > 0 and forest[row][col - 1] != 0 and not visited[row][col - 1]:\\n                q.put(((row, col-1), dist+1))\\n            \\n        return -1\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        mi = len(forest)\\n        mj = len(forest[0])\\n        \\n        d = {}\\n        pq = PriorityQueue()\\n        for i in range(mi):\\n            for j in range(mj):\\n                at = forest[i][j]\\n                if not at in d and not at == 1 and not at == 0:\\n                    d[at] = (i,j)\\n                    pq.put(at)\\n        \\n        steps = 0\\n        curloc = (0,0)\\n        while pq.qsize() != 0:\\n            curtarg_val = pq.get()\\n            curtarg = d[curtarg_val]\\n            val = self.bfs(forest, curloc, curtarg)\\n            if val == -1:\\n                return -1\\n            steps += val\\n            curloc = curtarg\\n        return steps\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\nfrom queue import Queue\\nclass Solution:\\n    def bfs(self, forest, begin, target) -> int:\\n        if begin == target:\\n            return 0\\n        q = Queue()\\n        steps = 0\\n        q.put((begin, 0))\\n        visited = [[False for j in range(len(forest[0]))] for i in range(len(forest))]\\n        visited[begin[0]][begin[1]] = True\\n        while q.qsize() > 0:\\n            at = q.get()\\n            c = at[0]\\n            dist = at[1]\\n            row = c[0]\\n            col = c[1]\\n            visited[row][col] = True\\n            if row == target[0] and col == target[1]:\\n                return dist\\n            \\n            if row < len(forest) - 1 and forest[row+1][col] != 0 and not visited[row+1][col]:\\n                q.put(((row+1, col), dist+1))\\n            if row > 0 and forest[row-1][col] != 0 and not visited[row-1][col]:\\n                q.put(((row-1, col), dist+1))\\n            if col < len(forest[0]) - 1 and forest[row][col + 1] != 0 and not visited[row][col + 1]:\\n                q.put(((row, col+1), dist+1))\\n            if col > 0 and forest[row][col - 1] != 0 and not visited[row][col - 1]:\\n                q.put(((row, col-1), dist+1))\\n            \\n        return -1\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        mi = len(forest)\\n        mj = len(forest[0])\\n        \\n        d = {}\\n        pq = PriorityQueue()\\n        for i in range(mi):\\n            for j in range(mj):\\n                at = forest[i][j]\\n                if not at in d and not at == 1 and not at == 0:\\n                    d[at] = (i,j)\\n                    pq.put(at)\\n        \\n        steps = 0\\n        curloc = (0,0)\\n        while pq.qsize() != 0:\\n            curtarg_val = pq.get()\\n            curtarg = d[curtarg_val]\\n            val = self.bfs(forest, curloc, curtarg)\\n            if val == -1:\\n                return -1\\n            steps += val\\n            curloc = curtarg\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537743,
                "title": "easy-bfs-runtime-509-ms-beats-64-12",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[][] ok;\\n    int n,m;\\n    public int cutOffTree(List<List<Integer>> arr) {\\n        \\n\\n        n = arr.size();\\n        m = arr.get(0).size();\\n        ok = new boolean[n][m];\\n\\n        PriorityQueue< Pair > pq = new PriorityQueue<>((a,b)-> a.num - b.num);\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(arr.get(i).get(j) > 1){\\n                    ok[i][j] = true;\\n                    pq.add(new Pair(i,j,arr.get(i).get(j)));\\n                }\\n                else if(arr.get(i).get(j) == 1){\\n                    ok[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        int i = 0, j = 0;\\n\\n        int cnt = 0;\\n        while(!pq.isEmpty()){\\n\\n            Pair p = pq.remove();\\n\\n            int cur = dfs(i,j,p.x,p.y);\\n\\n            if(cur == Integer.MAX_VALUE){\\n                return -1;\\n            }\\n\\n            cnt += cur;\\n            i = p.x;\\n            j = p.y;\\n\\n        }\\n\\n        return cnt;\\n\\n    }\\n    public int dfs(int from_i, int from_j, int to_i, int to_j){\\n\\n        int[][] dp = new int[n][m];\\n        \\n        for(int [] a : dp) Arrays.fill(a, Integer.MAX_VALUE);\\n\\n        dp[from_i][from_j] = 0;\\n\\n        Queue< int[] > pq = new LinkedList<>();\\n\\n        pq.add(new int[]{from_i, from_j});\\n\\n        while(!pq.isEmpty()){\\n\\n            int [] a = pq.remove();\\n\\n            int i = a[0] , j = a[1];\\n            if(i + 1 < n && ok[i + 1][j] && dp[i + 1][j] > dp[i][j] + 1){\\n                dp[i + 1][j] = dp[i][j] + 1;\\n                pq.add(new int[]{i + 1, j});\\n            }\\n            if(i - 1 >= 0 && ok[i - 1][j] && dp[i - 1][j] > dp[i][j] + 1){                \\n                dp[i - 1][j] = dp[i][j] + 1;\\n                pq.add(new int[]{i - 1, j});\\n            }\\n            if(j + 1 < m && ok[i][j + 1] && dp[i][j + 1] > dp[i][j] + 1){\\n                dp[i][j + 1] = dp[i][j] + 1;\\n                pq.add(new int[]{i,j + 1});\\n            }\\n            if(j - 1 >= 0 && ok[i][j - 1] && dp[i][j - 1] > dp[i][j] + 1){                \\n                dp[i][j - 1] = dp[i][j] + 1;\\n                pq.add(new int[]{i,j - 1});\\n            }\\n        }\\n\\n        return dp[to_i][to_j];\\n    }\\n}\\nclass Pair{\\n    int x,y;\\n    int num;\\n    public Pair(int x, int y, int num){\\n        this.x = x;\\n        this.y = y;\\n        this.num = num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] ok;\\n    int n,m;\\n    public int cutOffTree(List<List<Integer>> arr) {\\n        \\n\\n        n = arr.size();\\n        m = arr.get(0).size();\\n        ok = new boolean[n][m];\\n\\n        PriorityQueue< Pair > pq = new PriorityQueue<>((a,b)-> a.num - b.num);\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(arr.get(i).get(j) > 1){\\n                    ok[i][j] = true;\\n                    pq.add(new Pair(i,j,arr.get(i).get(j)));\\n                }\\n                else if(arr.get(i).get(j) == 1){\\n                    ok[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        int i = 0, j = 0;\\n\\n        int cnt = 0;\\n        while(!pq.isEmpty()){\\n\\n            Pair p = pq.remove();\\n\\n            int cur = dfs(i,j,p.x,p.y);\\n\\n            if(cur == Integer.MAX_VALUE){\\n                return -1;\\n            }\\n\\n            cnt += cur;\\n            i = p.x;\\n            j = p.y;\\n\\n        }\\n\\n        return cnt;\\n\\n    }\\n    public int dfs(int from_i, int from_j, int to_i, int to_j){\\n\\n        int[][] dp = new int[n][m];\\n        \\n        for(int [] a : dp) Arrays.fill(a, Integer.MAX_VALUE);\\n\\n        dp[from_i][from_j] = 0;\\n\\n        Queue< int[] > pq = new LinkedList<>();\\n\\n        pq.add(new int[]{from_i, from_j});\\n\\n        while(!pq.isEmpty()){\\n\\n            int [] a = pq.remove();\\n\\n            int i = a[0] , j = a[1];\\n            if(i + 1 < n && ok[i + 1][j] && dp[i + 1][j] > dp[i][j] + 1){\\n                dp[i + 1][j] = dp[i][j] + 1;\\n                pq.add(new int[]{i + 1, j});\\n            }\\n            if(i - 1 >= 0 && ok[i - 1][j] && dp[i - 1][j] > dp[i][j] + 1){                \\n                dp[i - 1][j] = dp[i][j] + 1;\\n                pq.add(new int[]{i - 1, j});\\n            }\\n            if(j + 1 < m && ok[i][j + 1] && dp[i][j + 1] > dp[i][j] + 1){\\n                dp[i][j + 1] = dp[i][j] + 1;\\n                pq.add(new int[]{i,j + 1});\\n            }\\n            if(j - 1 >= 0 && ok[i][j - 1] && dp[i][j - 1] > dp[i][j] + 1){                \\n                dp[i][j - 1] = dp[i][j] + 1;\\n                pq.add(new int[]{i,j - 1});\\n            }\\n        }\\n\\n        return dp[to_i][to_j];\\n    }\\n}\\nclass Pair{\\n    int x,y;\\n    int num;\\n    public Pair(int x, int y, int num){\\n        this.x = x;\\n        this.y = y;\\n        this.num = num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461218,
                "title": "python-bfs",
                "content": "# Intuition\\nFind out the order in which trees should be visited, then visit them one by one using the shortest path, which can be found using bfs\\n\\n# Approach\\nSimple bfs\\n\\n# Complexity\\n\\nN = n * m\\n\\n- Time complexity:\\n$$O(N^2)$$. BFS takes $$O(N)$$ because we visit each node at most once, and we do BFS on all trees, which is another $$O(N)$$.\\n\\n- Space complexity:\\n$$O(N)$$ for array of heights and for dictionary mapping height to coords of the tree\\n\\n# Code\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0:\\n            return -1\\n\\n        M = len(forest)\\n        N = len(forest[0])\\n        \\n        storage = {} # height to coords\\n        heights = [] # heights sorted  \\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if forest[i][j] > 1:\\n                    storage[forest[i][j]] = (i, j)\\n                    heights.append(forest[i][j])\\n        heights.sort()\\n        \\n        # bfs\\n        def steps(start, finish):\\n            visited = set()\\n            n_steps = 0\\n            start_i, start_j = start\\n            finish_i, finish_j = finish\\n            forest[start_i][start_j] = 1\\n            q = collections.deque([start])\\n            visited.add(start)\\n            while q:\\n                next_level = []\\n                for i in range(len(q)):\\n                    cur_i, cur_j = q.popleft()\\n                    poss_arr = [(cur_i, cur_j + 1), (cur_i, cur_j - 1), (cur_i - 1, cur_j), (cur_i + 1, cur_j)]\\n                    for poss_dest_i, poss_dest_j in poss_arr:\\n                        if poss_dest_i < 0 or poss_dest_i >= M or poss_dest_j < 0 or poss_dest_j >= N:\\n                            continue\\n                        if (poss_dest_i, poss_dest_j) in visited:\\n                            continue\\n                        if forest[poss_dest_i][poss_dest_j] == 0:\\n                            continue\\n                        if (poss_dest_i, poss_dest_j) == finish:\\n                            return n_steps + 1\\n                        visited.add((poss_dest_i, poss_dest_j))\\n                        next_level.append((poss_dest_i, poss_dest_j))\\n                q.extend(next_level)\\n                n_steps += 1\\n            return -1\\n        \\n        total_res = 0        \\n        cur_coords = (0, 0)\\n        for tree in heights:\\n            if storage[tree] == cur_coords: # if starting on lowest tree\\n                forest[cur_coords[0]][cur_coords[1]] = 1\\n                continue\\n            else:\\n                cur_steps = steps(cur_coords, storage[tree])\\n                if cur_steps == -1:\\n                    return -1\\n                else:\\n                    total_res += cur_steps\\n                    cur_coords = storage[tree]\\n        \\n        return total_res\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        if forest[0][0] == 0:\\n            return -1\\n\\n        M = len(forest)\\n        N = len(forest[0])\\n        \\n        storage = {} # height to coords\\n        heights = [] # heights sorted  \\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if forest[i][j] > 1:\\n                    storage[forest[i][j]] = (i, j)\\n                    heights.append(forest[i][j])\\n        heights.sort()\\n        \\n        # bfs\\n        def steps(start, finish):\\n            visited = set()\\n            n_steps = 0\\n            start_i, start_j = start\\n            finish_i, finish_j = finish\\n            forest[start_i][start_j] = 1\\n            q = collections.deque([start])\\n            visited.add(start)\\n            while q:\\n                next_level = []\\n                for i in range(len(q)):\\n                    cur_i, cur_j = q.popleft()\\n                    poss_arr = [(cur_i, cur_j + 1), (cur_i, cur_j - 1), (cur_i - 1, cur_j), (cur_i + 1, cur_j)]\\n                    for poss_dest_i, poss_dest_j in poss_arr:\\n                        if poss_dest_i < 0 or poss_dest_i >= M or poss_dest_j < 0 or poss_dest_j >= N:\\n                            continue\\n                        if (poss_dest_i, poss_dest_j) in visited:\\n                            continue\\n                        if forest[poss_dest_i][poss_dest_j] == 0:\\n                            continue\\n                        if (poss_dest_i, poss_dest_j) == finish:\\n                            return n_steps + 1\\n                        visited.add((poss_dest_i, poss_dest_j))\\n                        next_level.append((poss_dest_i, poss_dest_j))\\n                q.extend(next_level)\\n                n_steps += 1\\n            return -1\\n        \\n        total_res = 0        \\n        cur_coords = (0, 0)\\n        for tree in heights:\\n            if storage[tree] == cur_coords: # if starting on lowest tree\\n                forest[cur_coords[0]][cur_coords[1]] = 1\\n                continue\\n            else:\\n                cur_steps = steps(cur_coords, storage[tree])\\n                if cur_steps == -1:\\n                    return -1\\n                else:\\n                    total_res += cur_steps\\n                    cur_coords = storage[tree]\\n        \\n        return total_res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454985,
                "title": "java-bfs-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n-- insert into PQ - mn log mn\\n-- process the elements from PQ using BFS.\\n  -- each node can add max 4 . atmost we will visit mn cells.\\n  -- hence it will be mn * mn\\n\\nO(mn * mn) + O(mn log mn)\\n\\n- Space complexity:\\n\\nO(mn) for PQ and O(mn) for BFS queue.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int[][] dirs = new int[][] {{0,-1}, {-1,0}, {1,0}, {0, 1}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        //Note: The input is generated such that no two trees have the same height, \\n        //and there is at least one tree needs to be cut off.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[0] - b[0]));\\n\\n        addToQueue(forest, pq);\\n        int ans = 0;\\n        int[] src = new int[]{0,0};\\n        while(!pq.isEmpty()){\\n            int[] pos = pq.poll();\\n            int[] dest = new int[]{pos[1], pos[2]};\\n            int steps = bfs(src, dest, forest);\\n            if (steps == -1)\\n                return -1;\\n            ans += steps;\\n            src = dest;\\n        }\\n        return ans;\\n    }\\n\\n\\n    private int bfs(int[] src, int[] dest, List<List<Integer>> forest){\\n\\n        Deque<int[]> queue = new LinkedList<>();\\n        int m = forest.size();\\n        int n = forest.get(0).size();\\n        boolean[][] visited = new boolean[m][n];\\n        int sr = src[0], sc = src[1];\\n        int dr = dest[0], dc = dest[1];\\n\\n        int d = 0;\\n        queue.offer(new int[]{sr, sc, d});\\n\\n        while(!queue.isEmpty()){\\n\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++){\\n                int[] tree = queue.poll();\\n                int cr = tree[0], cc = tree[1];\\n                if (cr == dr && cc == dc){\\n                    System.out.println( \"sr:\" + sr + \" sc:\" + sc + \" dr:\" + dr + \" dc:\" + \" d:\" + tree[2]);\\n                    return tree[2];\\n                }\\n                visited[cr][cc] = true;\\n                for (int[] neigh : getNeighbors(tree, m, n)){\\n                    int nr = neigh[0],  nc = neigh[1];\\n                    if (!visited[nr][nc] && forest.get(nr).get(nc) != 0){\\n                        queue.offer (new int[] { nr, nc, d + 1});\\n                        visited[nr][nc] = true;\\n                    }\\n                }\\n            }\\n            d++;\\n        }\\n        return -1;\\n    }\\n\\n\\n\\n    private List<int[]> getNeighbors(int[] src, int m, int n){\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int r = src[0], c = src[1];\\n        for (int[] dir : dirs){\\n            int nr = r + dir[0], nc = c + dir[1];\\n            if (nr >= 0 && nr < m && nc >= 0 && nc < n){\\n                result.add(new int[] { nr, nc});\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void addToQueue(List<List<Integer>> forest, PriorityQueue<int[]> pq ){\\n        int m = forest.size();\\n        int n = forest.get(0).size();\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int height = forest.get(i).get(j);\\n                if (height > 1)\\n                    pq.offer(new int[]{height, i , j});\\n            }\\n        }\\n    }\\n}\\n/*\\n\\ninsert into queue all cells with value > 1.\\n\\n-- insert everything into min heap\\n-- pick the top one.\\n-- run bfs to get to smallest tree from 00.\\n\\n# if we can\\'t get to the next tree then fail.\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dirs = new int[][] {{0,-1}, {-1,0}, {1,0}, {0, 1}};\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        //Note: The input is generated such that no two trees have the same height, \\n        //and there is at least one tree needs to be cut off.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[0] - b[0]));\\n\\n        addToQueue(forest, pq);\\n        int ans = 0;\\n        int[] src = new int[]{0,0};\\n        while(!pq.isEmpty()){\\n            int[] pos = pq.poll();\\n            int[] dest = new int[]{pos[1], pos[2]};\\n            int steps = bfs(src, dest, forest);\\n            if (steps == -1)\\n                return -1;\\n            ans += steps;\\n            src = dest;\\n        }\\n        return ans;\\n    }\\n\\n\\n    private int bfs(int[] src, int[] dest, List<List<Integer>> forest){\\n\\n        Deque<int[]> queue = new LinkedList<>();\\n        int m = forest.size();\\n        int n = forest.get(0).size();\\n        boolean[][] visited = new boolean[m][n];\\n        int sr = src[0], sc = src[1];\\n        int dr = dest[0], dc = dest[1];\\n\\n        int d = 0;\\n        queue.offer(new int[]{sr, sc, d});\\n\\n        while(!queue.isEmpty()){\\n\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++){\\n                int[] tree = queue.poll();\\n                int cr = tree[0], cc = tree[1];\\n                if (cr == dr && cc == dc){\\n                    System.out.println( \"sr:\" + sr + \" sc:\" + sc + \" dr:\" + dr + \" dc:\" + \" d:\" + tree[2]);\\n                    return tree[2];\\n                }\\n                visited[cr][cc] = true;\\n                for (int[] neigh : getNeighbors(tree, m, n)){\\n                    int nr = neigh[0],  nc = neigh[1];\\n                    if (!visited[nr][nc] && forest.get(nr).get(nc) != 0){\\n                        queue.offer (new int[] { nr, nc, d + 1});\\n                        visited[nr][nc] = true;\\n                    }\\n                }\\n            }\\n            d++;\\n        }\\n        return -1;\\n    }\\n\\n\\n\\n    private List<int[]> getNeighbors(int[] src, int m, int n){\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int r = src[0], c = src[1];\\n        for (int[] dir : dirs){\\n            int nr = r + dir[0], nc = c + dir[1];\\n            if (nr >= 0 && nr < m && nc >= 0 && nc < n){\\n                result.add(new int[] { nr, nc});\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void addToQueue(List<List<Integer>> forest, PriorityQueue<int[]> pq ){\\n        int m = forest.size();\\n        int n = forest.get(0).size();\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int height = forest.get(i).get(j);\\n                if (height > 1)\\n                    pq.offer(new int[]{height, i , j});\\n            }\\n        }\\n    }\\n}\\n/*\\n\\ninsert into queue all cells with value > 1.\\n\\n-- insert everything into min heap\\n-- pick the top one.\\n-- run bfs to get to smallest tree from 00.\\n\\n# if we can\\'t get to the next tree then fail.\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418149,
                "title": "priority-queue-bfs",
                "content": "\\n# Code\\n```\\nclass Node {\\npublic:\\n    Node(int _h, int _x, int _y) : height(_h), x(_x), y(_y) { }\\n    int height;\\n    int x;\\n    int y;\\n};\\n\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int steps = 0;\\n        if (forest.empty() || forest[0].empty()) {\\n            return -1;\\n        }\\n        auto comparator = [] (const Node& a, const Node& b) {\\n            return a.height > b.height;\\n        };\\n        priority_queue<Node, vector<Node>, decltype(comparator)> store{comparator};\\n        for (int i = 0; i < forest.size(); ++i) {\\n            for (int j = 0; j < forest[0].size(); ++j) {\\n                int height = forest[i][j];\\n                if (height > 1) {\\n                    store.emplace(height, i, j);\\n                }\\n            }\\n        }\\n\\n        Node current = {forest[0][0], 0, 0};\\n        while (!store.empty()) {\\n            auto target = store.top();\\n            store.pop();\\n            int depth = distance(forest, {current.x, current.y}, {target.x, target.y});\\n            if (depth < 0) {\\n                return -1;\\n            }\\n            steps += depth;\\n            current = target;\\n        }\\n        return steps;\\n    }\\n\\nprivate:\\n    int distance(const vector<vector<int>>& forest,\\n                 const std::pair<int, int>& current,\\n                 const std::pair<int, int>& target) {\\n        int depth = 0;\\n        if (current == target) {\\n            return depth;\\n        }\\n        vector<vector<int>> dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n        queue<pair<int, int>> store;\\n        store.push(current);\\n        vector<vector<bool>> marked(forest.size(), vector<bool>(forest[0].size(), false));\\n        marked[current.first][current.second] = true;\\n\\n        while (!store.empty()) {\\n            ++ depth;\\n            int size = store.size();\\n            for (int i = 0; i < size; ++i) {\\n                auto pos = store.front();\\n                store.pop();\\n                for (int k = 0; k < dirs.size(); ++ k) {\\n                    int ni = pos.first + dirs[k][0];\\n                    int nj = pos.second + dirs[k][1];\\n                    if (ni >= forest.size() || nj >= forest[0].size() || ni < 0 || nj < 0) {\\n                        continue;\\n                    }\\n                    if (ni == target.first && nj == target.second) {\\n                        return depth;\\n                    }\\n                    if (!marked[ni][nj] && (forest[ni][nj] >= 1)) {\\n                        store.emplace(ni, nj);\\n                        marked[ni][nj] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node {\\npublic:\\n    Node(int _h, int _x, int _y) : height(_h), x(_x), y(_y) { }\\n    int height;\\n    int x;\\n    int y;\\n};\\n\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int steps = 0;\\n        if (forest.empty() || forest[0].empty()) {\\n            return -1;\\n        }\\n        auto comparator = [] (const Node& a, const Node& b) {\\n            return a.height > b.height;\\n        };\\n        priority_queue<Node, vector<Node>, decltype(comparator)> store{comparator};\\n        for (int i = 0; i < forest.size(); ++i) {\\n            for (int j = 0; j < forest[0].size(); ++j) {\\n                int height = forest[i][j];\\n                if (height > 1) {\\n                    store.emplace(height, i, j);\\n                }\\n            }\\n        }\\n\\n        Node current = {forest[0][0], 0, 0};\\n        while (!store.empty()) {\\n            auto target = store.top();\\n            store.pop();\\n            int depth = distance(forest, {current.x, current.y}, {target.x, target.y});\\n            if (depth < 0) {\\n                return -1;\\n            }\\n            steps += depth;\\n            current = target;\\n        }\\n        return steps;\\n    }\\n\\nprivate:\\n    int distance(const vector<vector<int>>& forest,\\n                 const std::pair<int, int>& current,\\n                 const std::pair<int, int>& target) {\\n        int depth = 0;\\n        if (current == target) {\\n            return depth;\\n        }\\n        vector<vector<int>> dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n        queue<pair<int, int>> store;\\n        store.push(current);\\n        vector<vector<bool>> marked(forest.size(), vector<bool>(forest[0].size(), false));\\n        marked[current.first][current.second] = true;\\n\\n        while (!store.empty()) {\\n            ++ depth;\\n            int size = store.size();\\n            for (int i = 0; i < size; ++i) {\\n                auto pos = store.front();\\n                store.pop();\\n                for (int k = 0; k < dirs.size(); ++ k) {\\n                    int ni = pos.first + dirs[k][0];\\n                    int nj = pos.second + dirs[k][1];\\n                    if (ni >= forest.size() || nj >= forest[0].size() || ni < 0 || nj < 0) {\\n                        continue;\\n                    }\\n                    if (ni == target.first && nj == target.second) {\\n                        return depth;\\n                    }\\n                    if (!marked[ni][nj] && (forest[ni][nj] >= 1)) {\\n                        store.emplace(ni, nj);\\n                        marked[ni][nj] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387751,
                "title": "time-o-m2n2-o-m2n2-space-o-mn-o-mn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct T {\\n  int i;\\n  int j;\\n  int height;\\n  T(int i, int j, int height) : i(i), j(j), height(height) {}\\n};\\n\\nclass Solution {\\n public:\\n  int cutOffTree(vector<vector<int>>& forest) {\\n    auto compare = [&](const T& a, const T& b) { return a.height > b.height; };\\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\\n\\n    for (int i = 0; i < forest.size(); ++i)\\n      for (int j = 0; j < forest[0].size(); ++j)\\n        if (forest[i][j] > 1)\\n          minHeap.emplace(i, j, forest[i][j]);\\n\\n    int ans = 0;\\n    int x = 0;\\n    int y = 0;\\n\\n    while (!minHeap.empty()) {\\n      const auto [i, j, _] = minHeap.top();\\n      minHeap.pop();\\n      // Walk from (x, y) to (i, j).\\n      const int steps = bfs(forest, x, y, i, j);\\n      if (steps < 0)\\n        return -1;\\n      ans += steps;\\n      x = i;\\n      y = j;\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  const vector<int> dirs{0, 1, 0, -1, 0};\\n\\n  int bfs(const vector<vector<int>>& forest, int si, int sj, int ei, int ej) {\\n    const int m = forest.size();\\n    const int n = forest[0].size();\\n    int steps = 0;\\n    queue<pair<int, int>> q{{{si, sj}}};\\n    vector<vector<bool>> seen(m, vector<bool>(n));\\n    seen[si][sj] = true;\\n\\n    while (!q.empty()) {\\n      for (int s = q.size(); s > 0; --s) {\\n        const auto [i, j] = q.front();\\n        q.pop();\\n        if (i == ei && j == ej)\\n          return steps;\\n        for (int k = 0; k < 4; ++k) {\\n          const int x = i + dirs[k];\\n          const int y = j + dirs[k + 1];\\n          if (x < 0 || x == m || y < 0 || y == n)\\n            continue;\\n          if (seen[x][y] || forest[x][y] == 0)\\n            continue;\\n          q.emplace(x, y);\\n          seen[x][y] = true;\\n        }\\n      }\\n      ++steps;\\n    }\\n\\n    return -1;\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct T {\\n  int i;\\n  int j;\\n  int height;\\n  T(int i, int j, int height) : i(i), j(j), height(height) {}\\n};\\n\\nclass Solution {\\n public:\\n  int cutOffTree(vector<vector<int>>& forest) {\\n    auto compare = [&](const T& a, const T& b) { return a.height > b.height; };\\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\\n\\n    for (int i = 0; i < forest.size(); ++i)\\n      for (int j = 0; j < forest[0].size(); ++j)\\n        if (forest[i][j] > 1)\\n          minHeap.emplace(i, j, forest[i][j]);\\n\\n    int ans = 0;\\n    int x = 0;\\n    int y = 0;\\n\\n    while (!minHeap.empty()) {\\n      const auto [i, j, _] = minHeap.top();\\n      minHeap.pop();\\n      // Walk from (x, y) to (i, j).\\n      const int steps = bfs(forest, x, y, i, j);\\n      if (steps < 0)\\n        return -1;\\n      ans += steps;\\n      x = i;\\n      y = j;\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  const vector<int> dirs{0, 1, 0, -1, 0};\\n\\n  int bfs(const vector<vector<int>>& forest, int si, int sj, int ei, int ej) {\\n    const int m = forest.size();\\n    const int n = forest[0].size();\\n    int steps = 0;\\n    queue<pair<int, int>> q{{{si, sj}}};\\n    vector<vector<bool>> seen(m, vector<bool>(n));\\n    seen[si][sj] = true;\\n\\n    while (!q.empty()) {\\n      for (int s = q.size(); s > 0; --s) {\\n        const auto [i, j] = q.front();\\n        q.pop();\\n        if (i == ei && j == ej)\\n          return steps;\\n        for (int k = 0; k < 4; ++k) {\\n          const int x = i + dirs[k];\\n          const int y = j + dirs[k + 1];\\n          if (x < 0 || x == m || y < 0 || y == n)\\n            continue;\\n          if (seen[x][y] || forest[x][y] == 0)\\n            continue;\\n          q.emplace(x, y);\\n          seen[x][y] = true;\\n        }\\n      }\\n      ++steps;\\n    }\\n\\n    return -1;\\n  };\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345231,
                "title": "python-bfs-works-but-slow-apperently-visit-array-is-better-than-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsame as everybody else. sort trees by height. then bfs between each of those points. \\n\\n# Complexity\\n- Time complexity: o(n^4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        n, m = len(forest), len(forest[0])\\n        order = []\\n        \\n        for i1, j1 in enumerate(forest):\\n            for i2, j2 in enumerate(j1):\\n                if j2 > 1: \\n                    order.append([i1, i2, j2])\\n\\n        order.sort(key = lambda x : x[2])\\n        \\n        res = 0\\n        q = [(0, 0, 0)]\\n        for i in order:\\n            visit = [[False] * m for _ in range(n)]\\n            found = False\\n            while q:\\n                x, y, level = q.pop()\\n                if not (0 <= x < n and 0 <= y < m) or visit[x][y] or forest[x][y] == 0:\\n                    continue\\n                if (x, y) == (i[0], i[1]):\\n                    res += level\\n                    found = True\\n                    break\\n                visit[x][y] = True\\n                q.insert(0, (x+1, y, level+1))\\n                q.insert(0, (x-1, y, level+1))\\n                q.insert(0, (x, y+1, level+1))\\n                q.insert(0, (x, y-1, level+1))\\n            if not found:\\n                return -1\\n            q = [(i[0], i[1], 0)]\\n        return res\\n\\n```\\nupvote! this question is pretty hard",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        n, m = len(forest), len(forest[0])\\n        order = []\\n        \\n        for i1, j1 in enumerate(forest):\\n            for i2, j2 in enumerate(j1):\\n                if j2 > 1: \\n                    order.append([i1, i2, j2])\\n\\n        order.sort(key = lambda x : x[2])\\n        \\n        res = 0\\n        q = [(0, 0, 0)]\\n        for i in order:\\n            visit = [[False] * m for _ in range(n)]\\n            found = False\\n            while q:\\n                x, y, level = q.pop()\\n                if not (0 <= x < n and 0 <= y < m) or visit[x][y] or forest[x][y] == 0:\\n                    continue\\n                if (x, y) == (i[0], i[1]):\\n                    res += level\\n                    found = True\\n                    break\\n                visit[x][y] = True\\n                q.insert(0, (x+1, y, level+1))\\n                q.insert(0, (x-1, y, level+1))\\n                q.insert(0, (x, y+1, level+1))\\n                q.insert(0, (x, y-1, level+1))\\n            if not found:\\n                return -1\\n            q = [(i[0], i[1], 0)]\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211683,
                "title": "slow-but-easy-sort-of-min-heap-dijkstra",
                "content": "# Intuition\\nBecause we have to go from smallest to largest - need to sort by tree height and then use this information to count min steps using Dijkstra between each point.\\n**let me know if this gets TLE, I will remove it not to confuse people**\\n# Approach\\nSort cells by height (excluding 0 and 1)\\nstart from point 0, 0 and count steps  to get to cells which trees need to be cut.\\nfor each pair perform Dijsktra to get min steps and add to the total steps until you get to the cell with the highest tree\\n\\n# Complexity\\n- Time complexity:\\nadding to sorted points = nmlog(mn)\\ncalculate distance for all mn and and for dijkstra mn+mnlogmn  = nm*(nmlogmn) = n^2m^2logmn \\n- Space complexity:\\nmin heap and min heap +visited array temp for dijkstra = mn\\n\\n# Code\\n```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {       \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(Integer.compare(a[2], b[2])));\\n        int m = forest.size();\\n        int n = forest.get(0).size();\\n        //define order of cells to cut min heap\\n        for(int i=0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(forest.get(i).get(j) >= 2){\\n                    pq.add(new int[]{i,j,forest.get(i).get(j)});\\n                }\\n            }\\n        }\\n        //start from 0,0 count min steps to reach what\\'s in heap\\n        pq.add(new int[]{0,0,0});\\n        int minSteps = 0;        \\n        while(!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n            if(pq.isEmpty())\\n                break;\\n            int[] next = pq.peek();\\n            //once reached remove from pq and aim for the next one\\n            int steps = reachSteps(curr, pq.peek(),forest);\\n            if(steps == Integer.MAX_VALUE)\\n                return -1;\\n            minSteps += steps;\\n        }        \\n        return minSteps;\\n    }\\n    \\n    private int reachSteps(int[] start, int[] goal, List<List<Integer>> forest){\\n        int minSteps = Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(Integer.compare(a[2], b[2])));\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        pq.add(new int[]{start[0], start[1], 0});\\n        int[] xd = {-1, 0, 1, 0}; \\n        int[] yd = { 0, 1, 0,-1};\\n        while(!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n            if(visited[curr[0]][curr[1]])\\n                continue;\\n            visited[curr[0]][curr[1]] = true;\\n            if(curr[0] == goal[0] && curr[1] == goal[1])\\n                return minSteps = curr[2];\\n            for(int i=0; i < 4; i++){\\n                int newX = curr[0]+xd[i];\\n                int newY = curr[1]+yd[i];\\n                if(newX >= 0 && newX < forest.size() && newY >=0 && newY < forest.get(0).size() && !visited[newX][newY] && forest.get(newX).get(newY) > 0){\\n                    pq.add(new int[]{newX, newY, curr[2]+1});\\n                }\\n            }\\n        }\\n        return minSteps;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {       \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(Integer.compare(a[2], b[2])));\\n        int m = forest.size();\\n        int n = forest.get(0).size();\\n        //define order of cells to cut min heap\\n        for(int i=0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(forest.get(i).get(j) >= 2){\\n                    pq.add(new int[]{i,j,forest.get(i).get(j)});\\n                }\\n            }\\n        }\\n        //start from 0,0 count min steps to reach what\\'s in heap\\n        pq.add(new int[]{0,0,0});\\n        int minSteps = 0;        \\n        while(!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n            if(pq.isEmpty())\\n                break;\\n            int[] next = pq.peek();\\n            //once reached remove from pq and aim for the next one\\n            int steps = reachSteps(curr, pq.peek(),forest);\\n            if(steps == Integer.MAX_VALUE)\\n                return -1;\\n            minSteps += steps;\\n        }        \\n        return minSteps;\\n    }\\n    \\n    private int reachSteps(int[] start, int[] goal, List<List<Integer>> forest){\\n        int minSteps = Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(Integer.compare(a[2], b[2])));\\n        boolean[][] visited = new boolean[forest.size()][forest.get(0).size()];\\n        pq.add(new int[]{start[0], start[1], 0});\\n        int[] xd = {-1, 0, 1, 0}; \\n        int[] yd = { 0, 1, 0,-1};\\n        while(!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n            if(visited[curr[0]][curr[1]])\\n                continue;\\n            visited[curr[0]][curr[1]] = true;\\n            if(curr[0] == goal[0] && curr[1] == goal[1])\\n                return minSteps = curr[2];\\n            for(int i=0; i < 4; i++){\\n                int newX = curr[0]+xd[i];\\n                int newY = curr[1]+yd[i];\\n                if(newX >= 0 && newX < forest.size() && newY >=0 && newY < forest.get(0).size() && !visited[newX][newY] && forest.get(newX).get(newY) > 0){\\n                    pq.add(new int[]{newX, newY, curr[2]+1});\\n                }\\n            }\\n        }\\n        return minSteps;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198032,
                "title": "bfs-sort-the-trees-clean-code-and-explanation",
                "content": "# Approach\\n* According to the problem statement, if a cell has a tree, then we can either choose to cut it or not cut it and if we cut the tree, the value of the cell becomes 1 and it can still be walked on. Hence it means that we can walk on any cell that initially has a value greater than or equal to 1 as many times as we want.\\n* The only restriction that we have is the order of cutting the trees, we have to cut the trees from shortest to longest but it doesn\\'t mean that we are not allowed to take a path that consists of that cell.\\n* Let the trees sorted by their height be t1, t2, t3, t4, ........\\n* Since we start from the cell (0, 0), we first have to find the shortest path from (0, 0) to t1. The shortest path between (0, 0) and t1 can consist of any cell that doesn\\'t have the value 0. (Remember, we are only not allowed to cut a longer tree before a shorter tree, but we can still freely walk on them). We can find the shortest path using BFS.\\n* After going to tree t1, we cut the tree and now we will go to the tree t2. We can again use BFS to find the shortest path from t1 to t2.\\n* Similarly, we find the shortest path between t2 to t3, t3 to t4 and so on cutting those trees along the way.\\n* Let the shortest distance between (0,0) and t1 be d1, t1 and t2 be d2, t2 and t3 be d3 and so on.....\\n* The answer will be the sum of all those shortest distances d1 + d2 + d3 + .....\\n\\n# Complexity\\n- Time complexity: $$O((m*n)^2)$$\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m=forest.size(), n=forest[0].size();\\n\\n        // find all the trees\\n        vector<vector<int>> trees;\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(forest[i][j] > 1) {\\n                    trees.push_back({forest[i][j], i, j});\\n                }\\n            }\\n        }\\n\\n        // sort the trees in increasing order of their heights\\n        sort(trees.begin(), trees.end());\\n\\n        auto bfs = [&](int sx, int sy, int tx, int ty) {\\n            // find the shortest distance between the source and target\\n            vector<pair<int,int>> moves{{1,0},{-1,0},{0,1},{0,-1}};\\n            bool visited[m][n];\\n            memset(visited, false, sizeof visited);\\n            queue<pair<int,int>> queue;\\n\\n            visited[sx][sy] = true;\\n            queue.push({sx, sy});\\n            int depth = 0;\\n\\n            while(not queue.empty()) {\\n                for(int t=queue.size(); t>0; t--) {\\n                    auto [x, y] = queue.front();\\n                    queue.pop();\\n\\n                    if(x==tx and y==ty) return depth;\\n\\n                    for(auto [dx, dy] : moves) {\\n                        int nx = x + dx;\\n                        int ny = y + dy;\\n\\n                        if(nx>=0 and nx<m and ny>=0 and ny<n\\n                           and forest[nx][ny]>=1 and not visited[nx][ny]) {\\n                               visited[nx][ny] = true;\\n                               queue.push({nx, ny});\\n                           }\\n                    }\\n                }\\n\\n                depth++;\\n            }\\n\\n            return -1;\\n        };\\n\\n        int dist = bfs(0, 0, trees[0][1], trees[0][2]);\\n        if(dist == -1) return -1;\\n\\n        int result = dist;\\n\\n        for(int i=0; i<trees.size()-1; i++) {\\n            int dist = bfs(trees[i][1], trees[i][2], trees[i+1][1], trees[i+1][2]);\\n            if(dist == -1) return -1;\\n            result += dist;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m=forest.size(), n=forest[0].size();\\n\\n        // find all the trees\\n        vector<vector<int>> trees;\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(forest[i][j] > 1) {\\n                    trees.push_back({forest[i][j], i, j});\\n                }\\n            }\\n        }\\n\\n        // sort the trees in increasing order of their heights\\n        sort(trees.begin(), trees.end());\\n\\n        auto bfs = [&](int sx, int sy, int tx, int ty) {\\n            // find the shortest distance between the source and target\\n            vector<pair<int,int>> moves{{1,0},{-1,0},{0,1},{0,-1}};\\n            bool visited[m][n];\\n            memset(visited, false, sizeof visited);\\n            queue<pair<int,int>> queue;\\n\\n            visited[sx][sy] = true;\\n            queue.push({sx, sy});\\n            int depth = 0;\\n\\n            while(not queue.empty()) {\\n                for(int t=queue.size(); t>0; t--) {\\n                    auto [x, y] = queue.front();\\n                    queue.pop();\\n\\n                    if(x==tx and y==ty) return depth;\\n\\n                    for(auto [dx, dy] : moves) {\\n                        int nx = x + dx;\\n                        int ny = y + dy;\\n\\n                        if(nx>=0 and nx<m and ny>=0 and ny<n\\n                           and forest[nx][ny]>=1 and not visited[nx][ny]) {\\n                               visited[nx][ny] = true;\\n                               queue.push({nx, ny});\\n                           }\\n                    }\\n                }\\n\\n                depth++;\\n            }\\n\\n            return -1;\\n        };\\n\\n        int dist = bfs(0, 0, trees[0][1], trees[0][2]);\\n        if(dist == -1) return -1;\\n\\n        int result = dist;\\n\\n        for(int i=0; i<trees.size()-1; i++) {\\n            int dist = bfs(trees[i][1], trees[i][2], trees[i+1][1], trees[i+1][2]);\\n            if(dist == -1) return -1;\\n            result += dist;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112024,
                "title": "bfs-min-heap",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        \"\"\"\\n        push all trees into a heap\\n        iterate over heap and compute the min distance b/w each tree\\n        add those steps to current steps\\n        \"\"\"\\n        m, n = len(forest), len(forest[0])\\n        trees = []\\n        total_steps = 0\\n        start_x, start_y = 0, 0\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(trees, (forest[i][j], i, j))\\n        \\n        def compute_distance_bw_tree(sx, sy, ex, ey):\\n            steps = 0\\n            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            que = deque([(sx, sy)])\\n            visited = {(sx,sy)}\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    if (i,j) == (ex, ey):\\n                        return steps\\n                    for dx, dy in directions:\\n                        x = i + dx\\n                        y = j + dy\\n                        if 0 <= x < m and 0 <= y < n and forest[x][y] != 0 and (x,y) not in visited:\\n                            que.append((x,y))\\n                            visited.add((x,y))\\n                steps+=1\\n            return -1\\n\\n        while len(trees):\\n            height, end_x, end_y = heapq.heappop(trees)\\n            steps = compute_distance_bw_tree(start_x, start_y, end_x, end_y)\\n            if steps == -1:\\n                return -1\\n            total_steps+=steps\\n            start_x, start_y = end_x, end_y\\n        return total_steps    \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        \"\"\"\\n        push all trees into a heap\\n        iterate over heap and compute the min distance b/w each tree\\n        add those steps to current steps\\n        \"\"\"\\n        m, n = len(forest), len(forest[0])\\n        trees = []\\n        total_steps = 0\\n        start_x, start_y = 0, 0\\n        for i in range(m):\\n            for j in range(n):\\n                if forest[i][j] > 1:\\n                    heapq.heappush(trees, (forest[i][j], i, j))\\n        \\n        def compute_distance_bw_tree(sx, sy, ex, ey):\\n            steps = 0\\n            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            que = deque([(sx, sy)])\\n            visited = {(sx,sy)}\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    if (i,j) == (ex, ey):\\n                        return steps\\n                    for dx, dy in directions:\\n                        x = i + dx\\n                        y = j + dy\\n                        if 0 <= x < m and 0 <= y < n and forest[x][y] != 0 and (x,y) not in visited:\\n                            que.append((x,y))\\n                            visited.add((x,y))\\n                steps+=1\\n            return -1\\n\\n        while len(trees):\\n            height, end_x, end_y = heapq.heappop(trees)\\n            steps = compute_distance_bw_tree(start_x, start_y, end_x, end_y)\\n            if steps == -1:\\n                return -1\\n            total_steps+=steps\\n            start_x, start_y = end_x, end_y\\n        return total_steps    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078114,
                "title": "what-do-you-think-is-the-output-for-the-input-1-2-3-0-0-9-7-6-5",
                "content": "For the input` [[1,2,3],[0,0,9],[7,6,5]]` the expected is shown to be 9. I think its 5. Can someone explain why it should be 9?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3031429,
                "title": "python-a",
                "content": "A* is usually faster than BFS in finding the shortest route between two nodes. The [Wikipedia A* page](https://en.wikipedia.org/wiki/A*_search_algorithm) is very informative and helpful. If you are interested, you can take a look. Also, I found [this tutorial](http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html) to be very good as well.\\n\\n> Two Statements from Wikipedia A* page\\n\\nThe [Wikipedia A* page](https://en.wikipedia.org/wiki/A*_search_algorithm) states that:\\n* \\'If the heuristic function is admissible \\u2013 meaning that it never overestimates the actual cost to get to the goal \\u2013, A* is guaranteed to return a least-cost path from start to goal.\\'\\n* \\'If the heuristic h satis\\uFB01es the additional condition h(x) \\u2264 d(x, y) + h(y) for every edge (x, y) of the graph (where d denotes the length of that edge), then h is called monotone, or consistent. With a consistent heuristic, A* is guaranteed to \\uFB01nd an optimal path without processing any node more than once...\\'\\n\\nIn the following, I will focus on the proof of these two statements.\\n\\n> The Proof\\n\\nThe first statement is easy to prove. If the heuristic function never overestimates the cost, then when the target is popping out of the open set, it means all the other routes which can lead us to the target has a higher cost than the current route leading to the target. The reason is the cost of all other routes must be higher than the current f(x) since the heuristic function never overestimates their costs. The current f(x) is essentially g(x) since now h(x) is zero. Therefore current f(x) is the actual cost of our current route, and our current route\\'s cost is better(lower) than any other route. That leads us to conclude that if the heuristic function is admissible, then A* is guaranteed to return the optimal path.\\n\\nThe second statement can be understood through a solid example. Let\\'s say we are using the A* search to find the shortest route between two node. Currently, the A* search still needs to be finished, and it has built a search tree in the following so far.\\n\\n![Screen Shot 2023-01-10 at 10.50.08 AM.png](https://assets.leetcode.com/users/images/c6903a66-8820-405c-ba41-e97c8b8ee4b0_1673365832.3250365.png)\\n\\n\\nThe red dot is the starting node, the green node is the target node, the blue nodes are discovered nodes, and the yellow nodes are the nodes in the open set now. Suppose that the algorithm now decides to pop the yellow dot with `I` inside from the open set since it has the lowest `f(x)` value. Then we can conclude that the path leading to this yellow node to be popped is the optimal path to this yellow node with `I`, and this node would never be added back into the open set again once it has been popped out.\\n\\nThe reason is that the heuristic function is consistent, meaning: `h(x) \\u2264 d(x, y) + h(y)` for every `edge (x, y)` of the graph (where `d` denotes the length of that edge). Let\\'s use `f(x\\')` to represent the `f(x)` of yellow nodes without `I`, and use `f(x)` to represent the `f(x)` of the yellow node with `I`. Currently, we have `f(x\\') > f(x)`. All the other routes leading to the yellow node with `I` will have to go through these yellow nodes without `I`. So if we try to reach the yellow node with `I` though these yellow nodes without `I`, the `f(x\\')` would become larger and larger since at first, we have `f(x\\') = g(x\\') + h(x\\')`, when we go to a neighbor node `y`, then `f(x\\') = g(x\\') + d(x\\', y) + h(y)`\\u2014combining `h(x) \\u2264 d(x, y) + h(y)`, we know that `f(x\\')` will become larger and larger. Therefore, we can conclude that any other route leading to the yellow node with `I` has a higher `g(x)` and `f(x)`. A higher `g(x)` means the current route is the optimal path leading to the yellow node with `I`.\\n\\nIf the heuristic is not consistent, then through other routes, we can have a lower `f(x)` and `g(x)` when we reach this yellow node with `I` again, then which means the algorithm found a shorter route to this node, and this node will be added back into the open set again.\\n\\nOne thing worth noting is that even when the heuristic function is consistent when a node is in the open set and has not been popped out yet, it is possible that this same node is reached by a cheaper path and then added into the open set again. That means if we don\\'t do open set duplicate checking, the open set can have a duplicate node(with different g(x) values). That wouldn\\'t break the algorithm. The algorithm is still guaranteed to find the optimal path if there exists one. But it will cost more space and potentially more time since the open set is a min heap. With more elements inside, the min heap needs more time to find the smallest element.\\n\\nAn interesting property of a 2D grid is that if we use Manhattan distance as our heuristic function, then it is guaranteed that the heuristic is not only admissible but also consistent. \\n\\nThe way how you handle tie-breaking is a factor that infects the effectiveness of the algorithm. It turns out that when there is a tie, if the algorithm prefers the more recently added nodes(paths) over previously added ones, then the algorithm usually runs faster. There are some great articles in terms of handling the tie-breaking in A* out there. You can take a look at them if you are interested.\\n\\n> Implementation\\n\\n```\\nfrom collections import defaultdict\\nimport heapq as hq\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        # Edge cases.\\n        if forest[0][0] == 0:\\n            return -1\\n        # Other cases.\\n        # Find all the trees.\\n        m, n = len(forest), len(forest[0])\\n        trees = [(row, col) for row in range(m) for col in range(n) if forest[row][col] > 1]\\n        trees.sort(key=lambda tree: forest[tree[0]][tree[1]])\\n\\n        # A* search.\\n        # Heuristic function.\\n        def h(row, col, t_row, t_col):\\n            return abs(t_row-row) + abs(t_col-col)\\n        # A* search function.\\n        def a_star(s_row, s_col, t_row, t_col):\\n            s_key = (s_row, s_col)\\n            t_key = (t_row, t_col)\\n            # Timestamp is used here to help break the tie.\\n            # At each iteration, timestamp -= 1, that will\\n            # make the algorithm prefer to choose the most \\n            # recent discovered path than previous ones when\\n            # there is a tie. This behaviour helps accelerate the searching.\\n            timestamp = 0\\n            # `g_score` is used to store the g(x) value for all nodes.\\n            g_score = defaultdict(lambda: float(\\'inf\\'))\\n            g_score[s_key] = 0\\n            s_f_score = h(s_row, s_col, t_row, t_col)\\n            s_node = [s_f_score, 0, s_key]\\n            open_set = [s_node]\\n            # `f(x)` of nodes are stored in the `open_set_map`.\\n            # `open_set_map` is used to accelerate the checking whether a node\\n            # is in the open_set.\\n            open_set_map = {s_key: s_node}\\n            while open_set:\\n                cur_f_score, _, cur_key = hq.heappop(open_set)\\n                open_set_map.pop(cur_key)\\n                if cur_key == t_key:\\n                    forest[t_row][t_col] = 1\\n                    return cur_f_score\\n                timestamp -= 1\\n                for i, j in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\\n                    nei_key = (cur_key[0]+i, cur_key[1]+j)\\n                    nei_g_score = g_score[cur_key] + 1\\n                    if 0 <= nei_key[0] < m and 0 <= nei_key[1] < n and \\\\\\n                       forest[nei_key[0]][nei_key[1]] != 0 and \\\\\\n                       nei_g_score < g_score[nei_key]:\\n                        g_score[nei_key] = nei_g_score\\n                        nei_f_score = nei_g_score + h(nei_key[0], nei_key[1], t_row, t_col)\\n                        if nei_key not in open_set_map:\\n                            nei_node = [nei_f_score, timestamp, nei_key]\\n                            hq.heappush(open_set, nei_node)\\n                            open_set_map[nei_key] = nei_node\\n                        else:\\n                            open_set_map[nei_key][0], open_set_map[nei_key][1] = nei_f_score, timestamp\\n                            hq.heapify(open_set)\\n            return -1\\n        \\n        res = a_star(0, 0, trees[0][0], trees[0][1])\\n        if res == -1:\\n            return -1\\n        for idx in range(len(trees)-1):\\n            dis = a_star(trees[idx][0], trees[idx][1], trees[idx+1][0], trees[idx+1][1])\\n            if dis == -1:\\n                return -1\\n            res += dis\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq as hq\\nclass Solution:\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        # Edge cases.\\n        if forest[0][0] == 0:\\n            return -1\\n        # Other cases.\\n        # Find all the trees.\\n        m, n = len(forest), len(forest[0])\\n        trees = [(row, col) for row in range(m) for col in range(n) if forest[row][col] > 1]\\n        trees.sort(key=lambda tree: forest[tree[0]][tree[1]])\\n\\n        # A* search.\\n        # Heuristic function.\\n        def h(row, col, t_row, t_col):\\n            return abs(t_row-row) + abs(t_col-col)\\n        # A* search function.\\n        def a_star(s_row, s_col, t_row, t_col):\\n            s_key = (s_row, s_col)\\n            t_key = (t_row, t_col)\\n            # Timestamp is used here to help break the tie.\\n            # At each iteration, timestamp -= 1, that will\\n            # make the algorithm prefer to choose the most \\n            # recent discovered path than previous ones when\\n            # there is a tie. This behaviour helps accelerate the searching.\\n            timestamp = 0\\n            # `g_score` is used to store the g(x) value for all nodes.\\n            g_score = defaultdict(lambda: float(\\'inf\\'))\\n            g_score[s_key] = 0\\n            s_f_score = h(s_row, s_col, t_row, t_col)\\n            s_node = [s_f_score, 0, s_key]\\n            open_set = [s_node]\\n            # `f(x)` of nodes are stored in the `open_set_map`.\\n            # `open_set_map` is used to accelerate the checking whether a node\\n            # is in the open_set.\\n            open_set_map = {s_key: s_node}\\n            while open_set:\\n                cur_f_score, _, cur_key = hq.heappop(open_set)\\n                open_set_map.pop(cur_key)\\n                if cur_key == t_key:\\n                    forest[t_row][t_col] = 1\\n                    return cur_f_score\\n                timestamp -= 1\\n                for i, j in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\\n                    nei_key = (cur_key[0]+i, cur_key[1]+j)\\n                    nei_g_score = g_score[cur_key] + 1\\n                    if 0 <= nei_key[0] < m and 0 <= nei_key[1] < n and \\\\\\n                       forest[nei_key[0]][nei_key[1]] != 0 and \\\\\\n                       nei_g_score < g_score[nei_key]:\\n                        g_score[nei_key] = nei_g_score\\n                        nei_f_score = nei_g_score + h(nei_key[0], nei_key[1], t_row, t_col)\\n                        if nei_key not in open_set_map:\\n                            nei_node = [nei_f_score, timestamp, nei_key]\\n                            hq.heappush(open_set, nei_node)\\n                            open_set_map[nei_key] = nei_node\\n                        else:\\n                            open_set_map[nei_key][0], open_set_map[nei_key][1] = nei_f_score, timestamp\\n                            hq.heapify(open_set)\\n            return -1\\n        \\n        res = a_star(0, 0, trees[0][0], trees[0][1])\\n        if res == -1:\\n            return -1\\n        for idx in range(len(trees)-1):\\n            dis = a_star(trees[idx][0], trees[idx][1], trees[idx+1][0], trees[idx+1][1])\\n            if dis == -1:\\n                return -1\\n            res += dis\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019956,
                "title": "bfs-traversal-heap-java-88-faster-detailed-solution",
                "content": "# Approach\\n- Standing on the curent grid we need minimum distance to move to next grid.For eg we are standing on grid value 2 so we need shortest distance to move to next greater grid say 3 if no path exist return -1.\\n- Insert all the grids having value>1 *(as they are trees which needed to be cutdown)* into heap in form __[value,row,col]__ form and sorted in increasing order of **value**.\\n- __shortestpath__ function gives mimum distance between 2 grids using *BFS* traversal.\\n -Start with [0,0] and **poll** from the heap next greater grid calculate the shortest path(if -1 return -1)\\n- Repeat while heap is not empty.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n        PriorityQueue<int[]> q=new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        int n=forest.size(),m=forest.get(0).size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val = forest.get(i).get(j);\\n                if(val>1)\\n                    q.add(new int[]{val,i,j});\\n            }\\n        }\\n\\n        int[] start={0,0};\\n        int total =0;\\n        while(q.size()>0){\\n            \\n            in\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->t[] pos = q.poll();\\n            int dis = shortpath(forest,start[0],start[1],pos[1],pos[2]);\\n            if(dis==-1)     return -1;\\n            // System.out.println(\"Dis b/w \"+start[0]+\",\"+start[1]+\" & \"+pos[1]+\",\"+pos[2]+\" is \"+dis);\\n            total +=dis;\\n            start[0]=pos[1];\\n            start[1]=pos[2];\\n        }\\n\\n        return total;\\n\\n    }\\n\\n    public int shortpath(List<List<Integer>> matrix,int x0,int y0,int x1,int y1){\\n\\n        int n=matrix.size(),m=matrix.get(0).size();\\n        boolean[][] vis = new boolean[n][m];\\n        int c =0;\\n        Queue<int[]> q = new LinkedList<>();\\n        int[] dx={1,-1,0,0},dy={0,0,1,-1};\\n        q.add(new int[]{x0,y0});\\n        vis[x0][y0] = true;\\n\\n        while(q.isEmpty()==false){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                int[] a=q.poll();\\n                if(a[0]==x1 && a[1]==y1)\\n                    return c;\\n                for(int j=0;j<4;j++){\\n                    int x=a[0]+dx[j],y=a[1]+dy[j];\\n                    if(x>=0 && y>=0 && x<n && y<m && !vis[x][y]&&matrix.get(x).get(y)!=0){\\n                        vis[x][y]=true;\\n                        q.add(new int[]{x,y});\\n                    }\\n                        \\n                }\\n            }\\n            c++;\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        \\n        PriorityQueue<int[]> q=new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        int n=forest.size(),m=forest.get(0).size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val = forest.get(i).get(j);\\n                if(val>1)\\n                    q.add(new int[]{val,i,j});\\n            }\\n        }\\n\\n        int[] start={0,0};\\n        int total =0;\\n        while(q.size()>0){\\n            \\n            in\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->t[] pos = q.poll();\\n            int dis = shortpath(forest,start[0],start[1],pos[1],pos[2]);\\n            if(dis==-1)     return -1;\\n            // System.out.println(\"Dis b/w \"+start[0]+\",\"+start[1]+\" & \"+pos[1]+\",\"+pos[2]+\" is \"+dis);\\n            total +=dis;\\n            start[0]=pos[1];\\n            start[1]=pos[2];\\n        }\\n\\n        return total;\\n\\n    }\\n\\n    public int shortpath(List<List<Integer>> matrix,int x0,int y0,int x1,int y1){\\n\\n        int n=matrix.size(),m=matrix.get(0).size();\\n        boolean[][] vis = new boolean[n][m];\\n        int c =0;\\n        Queue<int[]> q = new LinkedList<>();\\n        int[] dx={1,-1,0,0},dy={0,0,1,-1};\\n        q.add(new int[]{x0,y0});\\n        vis[x0][y0] = true;\\n\\n        while(q.isEmpty()==false){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                int[] a=q.poll();\\n                if(a[0]==x1 && a[1]==y1)\\n                    return c;\\n                for(int j=0;j<4;j++){\\n                    int x=a[0]+dx[j],y=a[1]+dy[j];\\n                    if(x>=0 && y>=0 && x<n && y<m && !vis[x][y]&&matrix.get(x).get(y)!=0){\\n                        vis[x][y]=true;\\n                        q.add(new int[]{x,y});\\n                    }\\n                        \\n                }\\n            }\\n            c++;\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993967,
                "title": "bfs-approach-based-on-heights-easier-read",
                "content": "# Intuition\\nBFS approach overall - uses heights instead of cells to do BFS for easier readability\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO((m*n)*2)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    List<List<Integer>> forest;\\n    List<Integer> treeHeights = new ArrayList<>();\\n    HashMap<Integer, List<Integer>> neighbours = new HashMap<>();\\n    int[] que;\\n    HashSet<Integer> visited = new HashSet<>();\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest.get(0).get(0) == 0)\\n            return -1;\\n\\n        this.forest = forest;\\n        this.que = new int[forest.size() * forest.get(0).size()];\\n\\n        int height;\\n\\n        for (int y = forest.size(); y-- > 0; ) {\\n            for (int x = forest.get(0).size(); x-- > 0; ) {\\n                height = forest.get(y).get(x);\\n                if (height == 0)\\n                    continue;\\n                if (height == 1)\\n                    height = getEmptyHeight(x, y);\\n                else\\n                    treeHeights.add(height);\\n\\n                addNeighbours(x, y, height);\\n            }\\n        }\\n\\n        Collections.sort(treeHeights);\\n\\n        int pathLength = 0;\\n        height = forest.get(0).get(0);\\n        if (height == 1)\\n            height = getEmptyHeight(0, 0);\\n        int idx = 0;\\n        if (treeHeights.get(0) == height) {\\n            idx = 1;\\n        }\\n        int nextHeight;\\n        int heightCount = treeHeights.size();\\n\\n        for (; idx < heightCount; idx++) {\\n            nextHeight = treeHeights.get(idx);\\n            try {\\n                pathLength += getDistance(height, nextHeight);\\n            } catch (Exception e) {\\n                return -1;\\n            }\\n            height = nextHeight;\\n        }\\n\\n        return pathLength;\\n    }\\n\\n    //for empty spaces, we assign a fake unique height to track it as a unique neighbor\\n    private int getEmptyHeight(int x, int y) {\\n        return - 100 - x * 100 - y;\\n    }\\n\\n    private int getDistance(int fromHeight, int toHeight) throws Exception {\\n        int quePos = 0;\\n        que[quePos] = fromHeight;\\n        int queSize = 1;\\n\\n        visited.clear();\\n        visited.add(fromHeight);\\n\\n        for (int len = 1; quePos < queSize; len++) {\\n            for (int queCurrentLen = queSize - quePos; queCurrentLen-- > 0; ) {\\n                for (Integer neighborHeight: neighbours.get(que[quePos++])) {\\n                    if (neighborHeight == toHeight)\\n                        return len;\\n                    if (visited.contains(neighborHeight))\\n                        continue;\\n                    que[queSize++] = neighborHeight;\\n                    visited.add(neighborHeight);\\n                }\\n            }\\n        }\\n\\n        throw new Exception();\\n    }\\n\\n    private void addNeighbor(int from, int to, int len) {\\n        List<Integer> neighbourList = neighbours.get(from);\\n        if (neighbourList == null) {\\n            neighbourList = new ArrayList<Integer>();\\n            neighbours.put(from, neighbourList);\\n        }\\n        neighbourList.add(to);\\n    }\\n\\n    private void addNeighbours(int x, int y, int from) {\\n        int h;\\n\\n        if (x > 0) {\\n            h = getCellHeight(x - 1, y);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n\\n        if (x < forest.get(0).size() - 1) {\\n            h = getCellHeight(x + 1, y);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n\\n        if (y > 0) {\\n            h = getCellHeight(x, y - 1);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n\\n        if (y < forest.size() - 1) {\\n            h = getCellHeight(x, y + 1);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n    }\\n\\n    private int getCellHeight(int x, int y) {\\n        int h = forest.get(y).get(x);\\n        if (h == 1)\\n            return getEmptyHeight(x, y);\\n        else\\n            return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    List<List<Integer>> forest;\\n    List<Integer> treeHeights = new ArrayList<>();\\n    HashMap<Integer, List<Integer>> neighbours = new HashMap<>();\\n    int[] que;\\n    HashSet<Integer> visited = new HashSet<>();\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest.get(0).get(0) == 0)\\n            return -1;\\n\\n        this.forest = forest;\\n        this.que = new int[forest.size() * forest.get(0).size()];\\n\\n        int height;\\n\\n        for (int y = forest.size(); y-- > 0; ) {\\n            for (int x = forest.get(0).size(); x-- > 0; ) {\\n                height = forest.get(y).get(x);\\n                if (height == 0)\\n                    continue;\\n                if (height == 1)\\n                    height = getEmptyHeight(x, y);\\n                else\\n                    treeHeights.add(height);\\n\\n                addNeighbours(x, y, height);\\n            }\\n        }\\n\\n        Collections.sort(treeHeights);\\n\\n        int pathLength = 0;\\n        height = forest.get(0).get(0);\\n        if (height == 1)\\n            height = getEmptyHeight(0, 0);\\n        int idx = 0;\\n        if (treeHeights.get(0) == height) {\\n            idx = 1;\\n        }\\n        int nextHeight;\\n        int heightCount = treeHeights.size();\\n\\n        for (; idx < heightCount; idx++) {\\n            nextHeight = treeHeights.get(idx);\\n            try {\\n                pathLength += getDistance(height, nextHeight);\\n            } catch (Exception e) {\\n                return -1;\\n            }\\n            height = nextHeight;\\n        }\\n\\n        return pathLength;\\n    }\\n\\n    //for empty spaces, we assign a fake unique height to track it as a unique neighbor\\n    private int getEmptyHeight(int x, int y) {\\n        return - 100 - x * 100 - y;\\n    }\\n\\n    private int getDistance(int fromHeight, int toHeight) throws Exception {\\n        int quePos = 0;\\n        que[quePos] = fromHeight;\\n        int queSize = 1;\\n\\n        visited.clear();\\n        visited.add(fromHeight);\\n\\n        for (int len = 1; quePos < queSize; len++) {\\n            for (int queCurrentLen = queSize - quePos; queCurrentLen-- > 0; ) {\\n                for (Integer neighborHeight: neighbours.get(que[quePos++])) {\\n                    if (neighborHeight == toHeight)\\n                        return len;\\n                    if (visited.contains(neighborHeight))\\n                        continue;\\n                    que[queSize++] = neighborHeight;\\n                    visited.add(neighborHeight);\\n                }\\n            }\\n        }\\n\\n        throw new Exception();\\n    }\\n\\n    private void addNeighbor(int from, int to, int len) {\\n        List<Integer> neighbourList = neighbours.get(from);\\n        if (neighbourList == null) {\\n            neighbourList = new ArrayList<Integer>();\\n            neighbours.put(from, neighbourList);\\n        }\\n        neighbourList.add(to);\\n    }\\n\\n    private void addNeighbours(int x, int y, int from) {\\n        int h;\\n\\n        if (x > 0) {\\n            h = getCellHeight(x - 1, y);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n\\n        if (x < forest.get(0).size() - 1) {\\n            h = getCellHeight(x + 1, y);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n\\n        if (y > 0) {\\n            h = getCellHeight(x, y - 1);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n\\n        if (y < forest.size() - 1) {\\n            h = getCellHeight(x, y + 1);\\n            if (h != 0)\\n                addNeighbor(from, h, 1);\\n        }\\n    }\\n\\n    private int getCellHeight(int x, int y) {\\n        int h = forest.get(y).get(x);\\n        if (h == 1)\\n            return getEmptyHeight(x, y);\\n        else\\n            return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989692,
                "title": "c-logical-thinking-sorting-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int bfs(int x,int y,int a,int b,int c, vector<vector<int>> &vis,vector<vector<int>>& f){\\n        int n=f.size();\\n        int m=f[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=c;\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int k=0;k<sz;k++){\\n            int i=q.front().first,j=q.front().second;\\n            q.pop();\\n            if(a==i && b==j) return ans;\\n            \\n      if(i-1>=0 && vis[i-1][j]<c && f[i-1][j]>=1){q.push({i-1,j});vis[i-1][j]=c;}\\n      if(i+1<n && vis[i+1][j]<c && f[i+1][j]>=1){q.push({i+1,j});vis[i+1][j]=c;}\\n      if(j-1>=0 && vis[i][j-1]<c && f[i][j-1]>=1){q.push({i,j-1});vis[i][j-1]=c;}\\n      if(j+1<m && vis[i][j+1]<c && f[i][j+1]>=1){q.push({i,j+1});vis[i][j+1]=c;}\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        \\n        vector<vector<int>> trees;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(forest[i][j]>1)\\n                    trees.push_back({forest[i][j],i,j});\\n            }\\n        }\\n        sort(trees.begin(),trees.end());\\n       vector<vector<int>> vis(n+1,vector<int>(m+1,0));\\n        \\n        int x=0,y=0;\\n        int ans=0;\\n        for(int i=0;i<trees.size();i++){\\n            int res = bfs(x,y,trees[i][1],trees[i][2],i+1,vis,forest);\\n            if(res==-1) return -1;\\n            ans+=res;\\n            // cout<<x<<\" \"<<y<<\" \"<<trees[i][1]<<\" \"<<trees[i][2]<<\" \"<<trees[i][0]<<\" \";\\n            //             cout<<res<<\" \\\\n\";\\n\\n            x=trees[i][1];\\n            y=trees[i][2];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int x,int y,int a,int b,int c, vector<vector<int>> &vis,vector<vector<int>>& f){\\n        int n=f.size();\\n        int m=f[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=c;\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int k=0;k<sz;k++){\\n            int i=q.front().first,j=q.front().second;\\n            q.pop();\\n            if(a==i && b==j) return ans;\\n            \\n      if(i-1>=0 && vis[i-1][j]<c && f[i-1][j]>=1){q.push({i-1,j});vis[i-1][j]=c;}\\n      if(i+1<n && vis[i+1][j]<c && f[i+1][j]>=1){q.push({i+1,j});vis[i+1][j]=c;}\\n      if(j-1>=0 && vis[i][j-1]<c && f[i][j-1]>=1){q.push({i,j-1});vis[i][j-1]=c;}\\n      if(j+1<m && vis[i][j+1]<c && f[i][j+1]>=1){q.push({i,j+1});vis[i][j+1]=c;}\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int n=forest.size();\\n        int m=forest[0].size();\\n        \\n        vector<vector<int>> trees;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(forest[i][j]>1)\\n                    trees.push_back({forest[i][j],i,j});\\n            }\\n        }\\n        sort(trees.begin(),trees.end());\\n       vector<vector<int>> vis(n+1,vector<int>(m+1,0));\\n        \\n        int x=0,y=0;\\n        int ans=0;\\n        for(int i=0;i<trees.size();i++){\\n            int res = bfs(x,y,trees[i][1],trees[i][2],i+1,vis,forest);\\n            if(res==-1) return -1;\\n            ans+=res;\\n            // cout<<x<<\" \"<<y<<\" \"<<trees[i][1]<<\" \"<<trees[i][2]<<\" \"<<trees[i][0]<<\" \";\\n            //             cout<<res<<\" \\\\n\";\\n\\n            x=trees[i][1];\\n            y=trees[i][2];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2987067,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cutOffTree(self, f):\\n        m, n, result = len(f), len(f[0]), []\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if f[i][j] > 1:\\n                    heapq.heappush(result,(f[i][j],i,j))\\n\\n        total, start_pos = 0, (0,0)\\n\\n        def bfs(start,end):\\n            stack, visited = [(start[0],start[1],0)], set()\\n\\n            visited.add((start[0],start[1]))\\n\\n            while stack:\\n                i, j, steps = stack.pop(0)\\n\\n                if (i,j) == end:\\n                    return steps\\n\\n                for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited and f[ni][nj] != 0:\\n                        stack.append((ni,nj,steps+1))\\n                        visited.add((ni,nj))\\n\\n            return -1\\n\\n        while result:\\n            val, x, y = heapq.heappop(result)\\n            res = bfs(start_pos,(x,y))\\n            if res >= 0:\\n                total += res\\n                start_pos = (x,y)\\n            else:\\n                return -1\\n\\n        return total\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cutOffTree(self, f):\\n        m, n, result = len(f), len(f[0]), []\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if f[i][j] > 1:\\n                    heapq.heappush(result,(f[i][j],i,j))\\n\\n        total, start_pos = 0, (0,0)\\n\\n        def bfs(start,end):\\n            stack, visited = [(start[0],start[1],0)], set()\\n\\n            visited.add((start[0],start[1]))\\n\\n            while stack:\\n                i, j, steps = stack.pop(0)\\n\\n                if (i,j) == end:\\n                    return steps\\n\\n                for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited and f[ni][nj] != 0:\\n                        stack.append((ni,nj,steps+1))\\n                        visited.add((ni,nj))\\n\\n            return -1\\n\\n        while result:\\n            val, x, y = heapq.heappop(result)\\n            res = bfs(start_pos,(x,y))\\n            if res >= 0:\\n                total += res\\n                start_pos = (x,y)\\n            else:\\n                return -1\\n\\n        return total\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981564,
                "title": "java-sorting-and-bfs-o-m-n-2",
                "content": "\\n**Approach** - \\n1. We need to start from tree from shortest to tallest starting from cell (0,0).\\n2. So, we will try to move from starting point to smallest tree. Then, from this position, we will go to 2nd smallest tree and from this point to 3rd smallest tree and then ultimately to tallest tree.\\n3. We will add the distance travelled from 1 tree to another tree and total distance travelled will be our answer.\\n4. For each starting point, first we have to find the next smallest tree using BFS and we will use BFS to find the distance from starting point to this new tree but, there is another better approach. In the beginning store all the trees positions in a new list and sort them in inceasing order of their heights.\\n5. Then, we will start from (0,0) to each tree in the list. If some tree is unreachable then we can return -1.\\nExample - Ans is 22\\n[[14, 13, 12, 11]\\n,[0, 0, 0, 10]\\n,[9, 8, 7, 2]\\n,[6, 5, 4, 3]]\\n\\nStarting position (0,0).\\nPath is (0,0)--5--(2,3)--1--(3,3)--1--(3,2)--1--(3,1)--1--(3,0)--1--(3,1)--1--(3,2)--1--(2,2)--1--(2,1)--\\n1--(2,0)--4--(1,3)--1--(0,3)--1--(0,2)--1--(0,1)--1--(0,0)\\nTotal distance travelled is 22\\n\\nT.C is O((M*N)*log(M*N) + (M*N)*(M*N)) and S.C is O((M*N)*(M*N))\\n```\\nclass Solution {\\n    private int[][] neighbors = {{0,1}, {1,0}, {0,-1}, {-1,0}}; \\n    private class Pair{\\n        private int x, y, h;\\n        public Pair(int _x, int _y, int _h){\\n            x = _x;\\n            y = _y;\\n            h = _h;\\n        }\\n    }\\n    private int rows, cols;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        rows = forest.size(); cols = forest.get(0).size();\\n        int h;\\n        List<Pair> heights = new ArrayList<>();\\n        for(int row = 0 ; row < rows ; ++row){\\n            for(int col = 0; col < cols; ++col){\\n                h = forest.get(row).get(col);\\n                if(h > 1){\\n                    heights.add(new Pair(row, col, h));\\n                }\\n            }\\n        }\\n        Collections.sort(heights, (p1,p2)->p1.h - p2.h);\\n        int totalDistance = 0, sx = 0, sy = 0, tx, ty, d;\\n        for(int i = 0; i<heights.size(); ++i){\\n            d = findDistanceBtwTrees(forest, sx, sy, heights.get(i).x, heights.get(i).y);\\n            if(d == -1) return -1;\\n            totalDistance += d;\\n            sx = heights.get(i).x; sy = heights.get(i).y;\\n        }\\n        return totalDistance;\\n    }\\n    \\n    private int findDistanceBtwTrees(List<List<Integer>> forest, int sx, int sy, int tx, int ty){\\n        LinkedList<Pair> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[rows][cols];\\n        queue.offer(new Pair(sx, sy, 0));\\n        visited[sx][sy] = true;\\n        int r, c;\\n        while(!queue.isEmpty()){\\n            Pair cell = queue.pollFirst();\\n            if(cell.x == tx && cell.y == ty) return cell.h;\\n            for(int[] d : neighbors){\\n                r = cell.x + d[0]; c = cell.y + d[1];\\n                if(r >= 0 && r < rows && c >= 0 && c < cols && !visited[r][c] && forest.get(r).get(c) >= 1){\\n                    visited[r][c] = true;\\n                    queue.offer(new Pair(r, c, cell.h + 1));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] neighbors = {{0,1}, {1,0}, {0,-1}, {-1,0}}; \\n    private class Pair{\\n        private int x, y, h;\\n        public Pair(int _x, int _y, int _h){\\n            x = _x;\\n            y = _y;\\n            h = _h;\\n        }\\n    }\\n    private int rows, cols;\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        rows = forest.size(); cols = forest.get(0).size();\\n        int h;\\n        List<Pair> heights = new ArrayList<>();\\n        for(int row = 0 ; row < rows ; ++row){\\n            for(int col = 0; col < cols; ++col){\\n                h = forest.get(row).get(col);\\n                if(h > 1){\\n                    heights.add(new Pair(row, col, h));\\n                }\\n            }\\n        }\\n        Collections.sort(heights, (p1,p2)->p1.h - p2.h);\\n        int totalDistance = 0, sx = 0, sy = 0, tx, ty, d;\\n        for(int i = 0; i<heights.size(); ++i){\\n            d = findDistanceBtwTrees(forest, sx, sy, heights.get(i).x, heights.get(i).y);\\n            if(d == -1) return -1;\\n            totalDistance += d;\\n            sx = heights.get(i).x; sy = heights.get(i).y;\\n        }\\n        return totalDistance;\\n    }\\n    \\n    private int findDistanceBtwTrees(List<List<Integer>> forest, int sx, int sy, int tx, int ty){\\n        LinkedList<Pair> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[rows][cols];\\n        queue.offer(new Pair(sx, sy, 0));\\n        visited[sx][sy] = true;\\n        int r, c;\\n        while(!queue.isEmpty()){\\n            Pair cell = queue.pollFirst();\\n            if(cell.x == tx && cell.y == ty) return cell.h;\\n            for(int[] d : neighbors){\\n                r = cell.x + d[0]; c = cell.y + d[1];\\n                if(r >= 0 && r < rows && c >= 0 && c < cols && !visited[r][c] && forest.get(r).get(c) >= 1){\\n                    visited[r][c] = true;\\n                    queue.offer(new Pair(r, c, cell.h + 1));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936175,
                "title": "java-using-priorityqueue-and-bfs",
                "content": "# Intuition\\nUse PriorityQueue to store the tree positions heightwise in the increasing order. Use BFS to calculate distance between successive trees.\\n\\n# Approach\\nNotice that last constraint - Heights of all trees are distinct. So all the trees must be visited sequentially in increasing order of their heights. We store the position of the trees in PriorityQueue and use BFS to get minimum distance between two positions.\\n\\n# Complexity\\n- Time complexity:\\nIn the worst case, we are cutting m*n trees and for each time, we are fetching location data from PriorityQueue. So time complexity of this operation is (nm)log(nm). We are performing BFS for each tree with time complexity of O(nm). So, overall time complexity is ((nm)^2)log(nm).\\n\\n- Space complexity:\\nO(nm) - for PriorotyQueue.\\n\\n# Code\\n```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(\\n            (a,b) ->forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1])\\n        );\\n        for(int i=0; i<forest.size(); i++){\\n            for(int j=0; j<forest.get(0).size(); j++){\\n                if(forest.get(i).get(j) > 1){\\n                    pq.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        \\n        int x = 0;\\n        int y = 0;\\n        int steps = 0;\\n        while(pq.isEmpty() == false){\\n            int[] nextPosition = pq.poll();\\n            int reqdStep = BFS(forest, x, y, nextPosition[0], nextPosition[1]);\\n            if(reqdStep >= 10000){\\n                return -1;\\n            }\\n            steps += reqdStep;\\n            x = nextPosition[0];\\n            y = nextPosition[1];\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    int BFS(List<List<Integer>> forest, int x, int y, int newX, int newY){\\n        LinkedList<int[]> queue = new LinkedList<int[]>();\\n        int[][] dp = new int[forest.size()][forest.get(0).size()];\\n        for(int[] arr : dp){\\n            Arrays.fill(arr, 10000);\\n        }\\n        queue.addFirst(new int[]{x,y,0});\\n        while(queue.isEmpty() == false){\\n            int[] currentPosition = queue.removeLast();\\n            x = currentPosition[0];\\n            y = currentPosition[1];\\n            int countOfSteps = currentPosition[2];\\n            if(x<0 || x>=forest.size() || y<0 || y>=forest.get(0).size() || forest.get(x).get(y) == 0){\\n            continue;\\n            }\\n            if(dp[x][y] <= countOfSteps){\\n                continue;\\n            }\\n            dp[x][y] = countOfSteps;\\n            if(x == newX && y == newY){\\n                return dp[x][y];\\n            }\\n            queue.addFirst(new int[]{x-1, y, dp[x][y]+1});\\n            queue.addFirst(new int[]{x+1, y, dp[x][y]+1});\\n            queue.addFirst(new int[]{x, y-1, dp[x][y]+1});\\n            queue.addFirst(new int[]{x, y+1, dp[x][y]+1});\\n        }\\n        return 10000;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(\\n            (a,b) ->forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1])\\n        );\\n        for(int i=0; i<forest.size(); i++){\\n            for(int j=0; j<forest.get(0).size(); j++){\\n                if(forest.get(i).get(j) > 1){\\n                    pq.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        \\n        int x = 0;\\n        int y = 0;\\n        int steps = 0;\\n        while(pq.isEmpty() == false){\\n            int[] nextPosition = pq.poll();\\n            int reqdStep = BFS(forest, x, y, nextPosition[0], nextPosition[1]);\\n            if(reqdStep >= 10000){\\n                return -1;\\n            }\\n            steps += reqdStep;\\n            x = nextPosition[0];\\n            y = nextPosition[1];\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    int BFS(List<List<Integer>> forest, int x, int y, int newX, int newY){\\n        LinkedList<int[]> queue = new LinkedList<int[]>();\\n        int[][] dp = new int[forest.size()][forest.get(0).size()];\\n        for(int[] arr : dp){\\n            Arrays.fill(arr, 10000);\\n        }\\n        queue.addFirst(new int[]{x,y,0});\\n        while(queue.isEmpty() == false){\\n            int[] currentPosition = queue.removeLast();\\n            x = currentPosition[0];\\n            y = currentPosition[1];\\n            int countOfSteps = currentPosition[2];\\n            if(x<0 || x>=forest.size() || y<0 || y>=forest.get(0).size() || forest.get(x).get(y) == 0){\\n            continue;\\n            }\\n            if(dp[x][y] <= countOfSteps){\\n                continue;\\n            }\\n            dp[x][y] = countOfSteps;\\n            if(x == newX && y == newY){\\n                return dp[x][y];\\n            }\\n            queue.addFirst(new int[]{x-1, y, dp[x][y]+1});\\n            queue.addFirst(new int[]{x+1, y, dp[x][y]+1});\\n            queue.addFirst(new int[]{x, y-1, dp[x][y]+1});\\n            queue.addFirst(new int[]{x, y+1, dp[x][y]+1});\\n        }\\n        return 10000;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885776,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn cut_off_tree(forest: Vec<Vec<i32>>) -> i32 {\\n        let mut trees = forest\\n            .iter()\\n            .enumerate()\\n            .flat_map(|(i, row)| {\\n                row.iter()\\n                    .enumerate()\\n                    .filter_map(move |(j, &height)| if height > 1 { Some((height, i, j)) } else { None })\\n            })\\n            .collect::<Vec<_>>();\\n        trees.sort_unstable();\\n\\n        let mut steps = 0;\\n        let mut start = (0, 0);\\n        for (_, i, j) in trees {\\n            let step = Self::bfs(&forest, start, (i, j));\\n            if step < 0 {\\n                return -1;\\n            }\\n            steps += step;\\n            start = (i, j);\\n        }\\n        steps\\n    }\\n\\n    fn bfs(forest: &[Vec<i32>], start: (usize, usize), end: (usize, usize)) -> i32 {\\n        let mut queue = std::collections::VecDeque::new();\\n        queue.push_back((start, 0));\\n        let mut visited = std::collections::HashSet::new();\\n        visited.insert(start);\\n\\n        while let Some(((i, j), step)) = queue.pop_front() {\\n            if (i, j) == end {\\n                return step;\\n            }\\n\\n            for (di, dj) in &[(0, 1), (0, -1), (1, 0), (-1, 0)] {\\n                let (ni, nj) = (i as i32 + di, j as i32 + dj);\\n                if ni >= 0\\n                    && ni < forest.len() as i32\\n                    && nj >= 0\\n                    && nj < forest[0].len() as i32\\n                    && forest[ni as usize][nj as usize] > 0\\n                    && visited.insert((ni as usize, nj as usize))\\n                {\\n                    queue.push_back(((ni as usize, nj as usize), step + 1));\\n                }\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cut_off_tree(forest: Vec<Vec<i32>>) -> i32 {\\n        let mut trees = forest\\n            .iter()\\n            .enumerate()\\n            .flat_map(|(i, row)| {\\n                row.iter()\\n                    .enumerate()\\n                    .filter_map(move |(j, &height)| if height > 1 { Some((height, i, j)) } else { None })\\n            })\\n            .collect::<Vec<_>>();\\n        trees.sort_unstable();\\n\\n        let mut steps = 0;\\n        let mut start = (0, 0);\\n        for (_, i, j) in trees {\\n            let step = Self::bfs(&forest, start, (i, j));\\n            if step < 0 {\\n                return -1;\\n            }\\n            steps += step;\\n            start = (i, j);\\n        }\\n        steps\\n    }\\n\\n    fn bfs(forest: &[Vec<i32>], start: (usize, usize), end: (usize, usize)) -> i32 {\\n        let mut queue = std::collections::VecDeque::new();\\n        queue.push_back((start, 0));\\n        let mut visited = std::collections::HashSet::new();\\n        visited.insert(start);\\n\\n        while let Some(((i, j), step)) = queue.pop_front() {\\n            if (i, j) == end {\\n                return step;\\n            }\\n\\n            for (di, dj) in &[(0, 1), (0, -1), (1, 0), (-1, 0)] {\\n                let (ni, nj) = (i as i32 + di, j as i32 + dj);\\n                if ni >= 0\\n                    && ni < forest.len() as i32\\n                    && nj >= 0\\n                    && nj < forest[0].len() as i32\\n                    && forest[ni as usize][nj as usize] > 0\\n                    && visited.insert((ni as usize, nj as usize))\\n                {\\n                    queue.push_back(((ni as usize, nj as usize), step + 1));\\n                }\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2851802,
                "title": "python-3-improving-bfs-to-avoid-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we sort the tree heights and get a sequence $(p_0,p_1,\\\\ldots, p_k)$ of tree position, where $p_0=(0,0)$ is the starting position. Then, similar to most of the approaches, BFS is empolyed to find the distance between $p_i$ and $p_{i+1}$ for each $i$. However, this approach will suffer from TLE for Python coder.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe suggest a very simpe improvement for BFS. We can find the distance from one source to two destinations in one BFS. That is, we find the $distance(p_i, p_{i-1}) + distance(p_i, p_{i+1})$ in one BFS procedure. The number of BFS will be cut in half. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(mnk)$, where $k$ is the number of trees. The complexity in Big-O is the same, but running time is one half.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(mn)$, the same.\\n# Code\\n```\\nclass Solution:\\n    # BFS search from i to i-1 and i+1\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        forest = [[0]*len(forest[0])] + forest \\n        # sentinel to save index check\\n        forest.append([0]*len(forest[0]))\\n        for i in range(len(forest)):\\n            forest[i] = [0]+forest[i]+[0]\\n        seq = [(0,1,1)] # starting point\\n        D0 = dict()\\n        for i,row in enumerate(forest):\\n            for j,x in enumerate(row):\\n                if x>1: seq.append((x,i,j))\\n                elif x==0: D0[(i,j)]=-1\\n        seq.sort() # sort the tree height\\n        def bfs(p0,p1,p2): # distance (p0,p1)+(p0,p2)\\n            #print(p0,p1,p2)\\n            que=[p0]; head=0 # FIFO queue\\n            D = D0.copy() # all 0 visited\\n            D[p0] = 0\\n            while head<len(que) and (p1 not in D or p2 not in D):\\n                r,c = que[head]; head += 1\\n                nd = D[(r,c)]+1\\n                for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                    if (nr,nc) not in D:\\n                        D[(nr,nc)] = nd\\n                        que.append((nr,nc))\\n                #end for\\n            #endwhile\\n            if p1 not in D or p2 not in D:\\n                return -1\\n            return D[p1]+D[p2]\\n        #end BFS\\n        total = 0\\n        while len(seq)>2:\\n            # find dustance for last 3 points\\n            step = bfs(seq[-2][1:],seq[-1][1:],seq[-3][1:])\\n            if step<0: return -1\\n            total += step\\n            seq.pop(); seq.pop()\\n        if len(seq)>1: # when only two points left\\n            step = bfs(seq[0][1:],seq[0][1:],seq[1][1:])\\n            if step<0: return -1\\n            total += step\\n        return total\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # BFS search from i to i-1 and i+1\\n    def cutOffTree(self, forest: List[List[int]]) -> int:\\n        forest = [[0]*len(forest[0])] + forest \\n        # sentinel to save index check\\n        forest.append([0]*len(forest[0]))\\n        for i in range(len(forest)):\\n            forest[i] = [0]+forest[i]+[0]\\n        seq = [(0,1,1)] # starting point\\n        D0 = dict()\\n        for i,row in enumerate(forest):\\n            for j,x in enumerate(row):\\n                if x>1: seq.append((x,i,j))\\n                elif x==0: D0[(i,j)]=-1\\n        seq.sort() # sort the tree height\\n        def bfs(p0,p1,p2): # distance (p0,p1)+(p0,p2)\\n            #print(p0,p1,p2)\\n            que=[p0]; head=0 # FIFO queue\\n            D = D0.copy() # all 0 visited\\n            D[p0] = 0\\n            while head<len(que) and (p1 not in D or p2 not in D):\\n                r,c = que[head]; head += 1\\n                nd = D[(r,c)]+1\\n                for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                    if (nr,nc) not in D:\\n                        D[(nr,nc)] = nd\\n                        que.append((nr,nc))\\n                #end for\\n            #endwhile\\n            if p1 not in D or p2 not in D:\\n                return -1\\n            return D[p1]+D[p2]\\n        #end BFS\\n        total = 0\\n        while len(seq)>2:\\n            # find dustance for last 3 points\\n            step = bfs(seq[-2][1:],seq[-1][1:],seq[-3][1:])\\n            if step<0: return -1\\n            total += step\\n            seq.pop(); seq.pop()\\n        if len(seq)>1: # when only two points left\\n            step = bfs(seq[0][1:],seq[0][1:],seq[1][1:])\\n            if step<0: return -1\\n            total += step\\n        return total\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565256,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1565494,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1565561,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1567652,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1567029,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1575758,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1569413,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1569149,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1568095,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1754911,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1565256,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1565494,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1565561,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1567652,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1567029,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1575758,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1569413,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1569149,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1568095,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1754911,
                "content": [
                    {
                        "username": "dimnowhere",
                        "content": "Can anyone explain why the answer of this case is 57?\n\n[[54581641,64080174,24346381,69107959],\n[86374198,61363882,68783324,79706116],\n[668150,92178815,89819108,94701471],\n[83920491,22724204,46281641,47531096],\n[89078499,18904913,25462145,60813308]]\n\nMy program returns -1 because you can only cut trees in ascending order, which is (0,0)->(0,1) or (0,0)->(1,0)."
                    },
                    {
                        "username": "bharatim1221",
                        "content": "Read question carefully, it\\'s written on it that we can choose to cut the tree, but we can walk over it if it is a tree or 1. Read that again"
                    },
                    {
                        "username": "shweRaj",
                        "content": "Can some one explain why we sould use bfs instead of dfs?\\nwhat are the advantages ?"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "BFS is better for getting the shortest path."
                    },
                    {
                        "username": "mstrotta",
                        "content": "We all know that our BFS needs a \"visited\" set to avoid backtracking and an infinite loop. \\n\\nSemantically, it may make sense to add your current node to the visited set, but this is a **mistake**! (And in my case, it cost me a TLE.)\\n\\nConsider a search starting at (0,0). The neighbors are (1,0) and (0,1). These two cells themselves share a new neighbor in common, (1,1). There is no reason to add (1,1) to the search queue twice; but if we make the mistake of updating our visited set with our current node, that is exactly what will happen.\\n\\nThe correct thing to do is updated our \"visited\" set each time we add a cell to the queue. To be more semantically clear, we should get into the habit of naming this variable \"enqueued\" instead of \"visited\"; that will help us avoid this common mistake."
                    },
                    {
                        "username": "shubham06vijay",
                        "content": "I faced an issue in understanding this test case.\\n\\n[[4,2,3],[0,0,1],[7,6,5]]\\nThe answer to this test case according to me was 14 and the answer given was 10?\\n\\nMy doubt was - Do we not consider the steps to go to [1,2] position (with value 1) from [0,0]!\\n\\nThe answer is that we don\\'t consider those steps as \"1\" means that there is no tree or basically we don\\'t need to cut it, so we don\\'t need to go till that position.\\n\\nThis was breaking one of my test case, so thought of letting everyone know. :)\\n\\nSo, The answer to this would basically be as follows:\\nYou can go from (0, 0) straight to 2.\\n(0,0)->2: 1\\n2->3: 1\\n3->4: 2\\n4->5: 4\\n5->6: 1\\n6->7: 1\\n\\nSo 10 steps in total"
                    },
                    {
                        "username": "plusgood",
                        "content": "My code failed at the same test case. \\nI was further misled by the last test case - Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\\n1) according to which you can cut off the first tree at (0, 0) before making any steps. \\n2) in the problem description it is said that -When you cut off a tree, the value at its cell becomes 1 (an empty cell).\\nSo I concluded from 1 & 2 that we don\\'t need to return to 0,0 (because we already cut the tree at 0,0) but turns out we do.\\nThanks for your explanation !"
                    },
                    {
                        "username": "tzef",
                        "content": "This should let everyone see it!!"
                    },
                    {
                        "username": "AlgoNinja",
                        "content": "[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\\n\\nAccording to logic, you can cut one tree at a time. And we don\\'t count the tree we start with. Then answer should be 19, right?\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s examine the matrix:\\n\\n    [[54581641, 64080174, 24346381, 69107959],\\n     [86374198, 61363882, 68783324, 79706116],\\n     [668150,   92178815, 89819108, 94701471],\\n     [83920491, 22724204, 46281641, 47531096],\\n     [89078499, 18904913, 25462145, 60813308]]\\n\\nFirstly, let\\'s sort the trees based on their heights:\\n\\n    668150, 24346381, 18904913, 22724204, 25462145, 46281641, 47531096, \\n    54581641, 60813308, 61363882, 64080174, 68783324, 69107959, 79706116, \\n    83920491, 86374198, 89078499, 89819108, 92178815, 94701471\\n\\nStarting at position (0,0), you would start with tree of height 54581641. But as per the problem, we only count the trees we cut down, not the one we start with.\\n\\nNext, we need to reach the smallest tree, which is 668150 at position (2,0). Since it\\'s not possible to go directly left from the starting position, we would have to go down first, then left. This would give us the path:\\n\\n    (0,0) -> (1,0) -> (2,0) - 2 steps\\n\\nWe continue this process for each tree in the sorted list, calculating the shortest path between each pair of trees. Remember that we can only move to cells that are empty or contain a tree we\\'re allowed to cut.\\n\\nIf it\\'s impossible to reach a tree (all paths are blocked by trees that are too tall), we should return -1 as per the problem statement.\\n\\nWithout the exact steps of traversing from each tree to the next, it\\'s hard to confirm the total steps. But if all trees are reachable in their height order, and it requires 19 steps to move from one to the next in this order, then yes, the answer would be 19.\\n"
                    },
                    {
                        "username": "AdityaGogoi",
                        "content": "[54581641,64080174,24346381,69107959],\\n[86374198,61363882,68783324,79706116],\\n[668150,92178815,89819108,94701471],\\n[83920491,22724204,46281641,47531096],\\n[89078499,18904913,25462145,60813308]]\\nFor this the trees cant be cut :\\n(0,0 ) - > (0,1) ->(0,2)X descending value\\n    (0,0 ) - > (0,1)-> (1,1) X descending value\\n(0,0) -> (1,0) -> (2,0) X descending value \\n                     (0,0) -> (1,0) -> (1,1) visited \\nfrom (0,0) all trees canot be cut so answer will be -1 instead of 57. \\nThe problem states to startsearch from (0,0) position and to return -1 in case all trees cannot be cut.\\nso answer should be -1 not 57 as stated by leetcode.\\n\\n\\n\\t\\t\\t\\t\\t"
                    },
                    {
                        "username": "bparanj",
                        "content": " You are correct. If a tree cannot be reached because it\\'s blocked by trees that are taller (which we cannot cut down because we have to cut the trees in increasing order of their heights), we should return -1. This is because it is not possible to cut down all the trees in this situation.\\n\\nThe grid you provided indeed has this situation. The tree with height 668150 is blocked by trees of higher heights, and we cannot get to it without cutting these higher trees down first, which contradicts our rules.\\n\\nSo for the forest you\\'ve provided, the answer should be -1, not 57. It\\'s possible that there\\'s a mistake in the problem or test case if Leetcode is suggesting that the answer is 57."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question doesn\\'t clarify the directions of motion. You can only move up, down, left, or right."
                    },
                    {
                        "username": "bparanj",
                        "content": " In many algorithmic problems related to grids or matrices, the allowed directions of movement are often up, down, left, and right, unless otherwise specified. Diagonal movements are usually explicitly mentioned if they are allowed.\\n\\nIn the problem statement you mentioned, it says \"In one step, you can walk in any of the four directions: north, east, south, and west.\" This generally means that you can move up (north), down (south), left (west), and right (east), not diagonally.\\n\\nIf the problem does not specify that diagonal movements are allowed, it is safe to assume that they are not."
                    },
                    {
                        "username": "edaengineer",
                        "content": "I wrote code for the function assuming that one could walk through only grass, and trees can be walked through only after cutting them based on the following sentence. This doesn't seem true as the following test would otherwise have returned -1.\\n\\nIsn't this question unclear? Could someone clarify this? \\n\\n> You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \\n\\n\\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement indeed has a somewhat misleading sentence, but the key point to remember is this: \"A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree\\'s height.\"\\n\\nSo, your initial assumption about being unable to walk through the trees without cutting them is incorrect. According to the problem statement, you can freely walk through the trees, but when you decide to cut one, it becomes a grass cell. \\n\\nThe order in which you cut the trees is determined by their height (you always cut the shortest tree first), not by their position or the path you take through the forest.\\n\\nSo, to clarify, you can move through any cell that is not a 0 (i.e., cells that are either grass or trees), and you can cut the trees in ascending order of their height. After a tree is cut, its cell turns into a grass cell (value 1)."
                    },
                    {
                        "username": "clark1012",
                        "content": "How the hell will be starting in obstacle, this just does not make any sense.\\ncase [[0],[0],[6014]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the provided problem statement, the starting point is explicitly given as (0, 0). The value of \\'0\\' at a cell in the forest matrix implies it\\'s an obstacle, and it cannot be walked through. If the starting cell (0, 0) is an obstacle, it implies that the person cannot even start walking in the forest, which indeed doesn\\'t make any sense.\\n\\nThis could either be a problem with the test cases, where such cases are not supposed to be valid, or if they are valid, it would mean that it is impossible to cut all the trees. In such cases, according to the problem statement, your function should return -1, indicating that it\\'s impossible to cut all the trees. \\n\\nSo for the given case [[0],[0],[6014]], the answer should be -1 as it\\'s impossible to start from the position (0, 0) to cut the tree."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "I think they mean you cannot walk via a 0 cell but can stand on it and go to another one. Absurd i know"
                    },
                    {
                        "username": "pankamit",
                        "content": "for the below Test Case I believe Answer is Wrong\\n[[4,2,3],[0,0,1],[7,6,5]] \\nExpected Given -> 10 It should be 14\\n\\nCan you please check this test case once"
                    }
                ]
            },
            {
                "id": 1576100,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 1575653,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 1574601,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 1573913,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 1573104,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 2060900,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 2024023,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 2017938,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 1868501,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            },
            {
                "id": 1800719,
                "content": [
                    {
                        "username": "nguyenlom",
                        "content": "Code passed about 1/2 the test easily but timed out when the input arrays are huge. On my local, it executed the same array in 6-7 secs. leetcode seem to take a very long time for it."
                    },
                    {
                        "username": "bparanj",
                        "content": "If your code passes for smaller test cases but times out for larger ones, it may be due to an inefficiency in your algorithm. The way you\\'ve structured your code might be performing well for smaller input sizes, but it might be having trouble with larger ones due to time complexity. \\n\\nHere are some tips to optimize your code:\\n\\n1. **Avoid unnecessary computations:** Try to reduce any redundant or unnecessary computations, especially within loops. Any calculation that is being repeated multiple times can often be stored in a variable and re-used.\\n\\n2. **Use appropriate data structures:** Certain operations are faster with specific data structures. For instance, lookup operations are faster in a set or a dictionary compared to a list. Choosing the right data structure for your problem can lead to significant speedups.\\n\\n3. **Take advantage of built-in functions:** Many programming languages offer built-in functions and libraries that are heavily optimized. Using these functions can often be faster than writing your own.\\n\\n4. **Improve your algorithm:** Often, time complexity issues come from an inefficient algorithm. If you\\'re using a brute-force approach, consider whether there are any properties of the problem that you can take advantage of to find a more efficient solution.\\n\\nRemember, though, that there\\'s often a trade-off between time and space complexity, and optimizing for one can sometimes worsen the other. It\\'s important to strike a balance between the two based on the requirements of the problem.\\n\\nIn your specific case, you might need to optimize your path-finding algorithm or the way you\\'re sorting and accessing the trees. For example, a breadth-first search (BFS) is generally faster than a depth-first search (DFS) for path-finding in a grid-like structure. A priority queue (a heap data structure) might help to efficiently find the next shortest tree. These are just examples; the exact optimizations would depend on your specific implementation."
                    },
                    {
                        "username": "tellmetiger",
                        "content": "[[1,6,7],\\n [4,3,2],\\n [0,0,5]]\\n if the input is like this, the problem description mentioned, you have to cut tree from shortest to tallest.\\n 1>4>3>2>5>come back to  2>come back to  3>6>7\\n \\n Isn\\'t the answer should be 8,  however the program result is 12.\\n Can anyone tell me why it is 12."
                    },
                    {
                        "username": "bparanj",
                        "content": "You are asked to cut the trees from the shortest to the tallest. Therefore, the order in which you should cut the trees in your example is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\\n\\nHowever, there\\'s a key detail in the problem: you can only move to a neighboring cell in four directions (up, down, left, and right), and you can\\'t move through cells that contain a 0. \\n\\nAfter cutting tree 1, you are at position (0, 0). You would then have to move to position (1, 2) to cut tree 2. This requires 2 steps.\\n\\nFrom there, you would move to position (1, 1) to cut tree 3, taking another 1 step.\\n\\nThen, you would move to position (1, 0) to cut tree 4, taking another 1 step.\\n\\nTo cut tree 5, you would have to move to position (2, 2). However, the cell at (2, 1) contains a 0, and you cannot move through it. So, you have to go around. You would move from (1, 0) to (0, 0), then to (0, 1), (0, 2), (1, 2), and finally to (2, 2). This takes a total of 5 steps.\\n\\nAfter that, you have to return to position (1, 1) to cut tree 6, taking 2 steps, and then move to position (0, 2) to cut tree 7, taking another 1 step.\\n\\nSo, the total number of steps is 2 + 1 + 1 + 5 + 2 + 1 = 12. That\\'s why the program is returning 12."
                    },
                    {
                        "username": "pkumar7",
                        "content": "So according to problem description we are asked to cut-off all the trees ascending order with trees height.\\nI was able to come up with solution which is almost similar to [top rated](https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)  within 5 mins but thought of below test case and stopped.\\nAccording to below test case:\\n[[7,2,3],\\n[0,0,4],\\n[1,6,5]]\\n\\nOutput should be 20 but expected output is 10. Is this test case correct ?? Or Am I missing something here ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Based on the problem statement, the correct order to cut trees would be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. However, the cells with a 0 are impassable until a tree is cut down.\\n\\nLet\\'s go step by step through the process:\\n\\n1. Start at (2, 0) to cut tree 1: 0 steps (starting point).\\n2. Move to (0, 1) to cut tree 2: 4 steps (go around the top through 3 -> 4 -> 5 -> 2).\\n3. Move to (0, 2) to cut tree 3: 1 step.\\n4. Move to (1, 2) to cut tree 4: 2 steps (go around through 3 -> 2 -> 4).\\n5. Move to (2, 2) to cut tree 5: 1 step.\\n6. Move to (2, 1) to cut tree 6: 1 step.\\n7. Finally, move to (0, 0) to cut tree 7: 1 step.\\n\\nTherefore, the total number of steps required would be 0 + 4 + 1 + 2 + 1 + 1 + 1 = 10 steps, which matches the expected output. \\n\\nThis problem is challenging because it requires understanding of breadth-first search or depth-first search and priority queue to find the shortest path in the grid."
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "answer shouldn\\'t be -1 as from (0,0) we can\\'t go anywhere?"
                    },
                    {
                        "username": "wilderfield",
                        "content": "Who has A* or Hadlock\\'s algorithm memorized?\\n\\nIsn\\'t this too hard?"
                    },
                    {
                        "username": "lallu1",
                        "content": "The question doesn\\'t mention in what direction one can walk, can he walk in all 4 directions or all 8 directions? Question seems hard as you first need to trace the lowest height tree everytime. Unable to understand how one \"walks\" in the golf ground."
                    },
                    {
                        "username": "peter920730",
                        "content": "does anyone know why `[[4,2,3],[0,0,1],[7,6,5]]` is 10?\\n\\nin my mind, u start 0,0, \\nto get to 1, is 3 steps\\n1-> 2 => 2 steps\\n2-> 3 => 1 step\\n3-> 4=> 2 step\\n4-> 5=> 4 step\\n5-> 6=> 1step\\n6-> 7=> 1 step\\ntotal is 14 steps.?"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Don\\'t cut forest."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "ok bro !"
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "Can\\'t we use Dijkstra\\'s Algorithm using BFS and Priority Queue?"
                    },
                    {
                        "username": "arpitUchiha",
                        "content": "hey leetcode people please let us know why for test case :\n\n[[54581641,64080174,24346381,69107959],[86374198,61363882,68783324,79706116],[668150,92178815,89819108,94701471],[83920491,22724204,46281641,47531096],[89078499,18904913,25462145,60813308]]\n\n we should get 57 and not -1 as expected output.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s mentioned that you can walk through the cells that contain trees without cutting them down. You only need to cut them when you want to. This means that even though some trees are surrounded by taller trees, you can still reach and cut them if they\\'re next in the order of cutting (from shortest to tallest). \\n\\nSo, for the provided test case, although it appears that you might not be able to cut all trees due to being surrounded by taller trees, you can indeed reach every tree, because walking through a tree does not necessitate cutting it. Therefore, the result is not -1 (impossible), but the actual number of steps to cut all trees in order.\\n\\nIt\\'s a matter of carefully interpreting the problem statement. The problem doesn\\'t state that you must cut a tree when you move to its cell, so you can pass through trees that are out of order."
                    },
                    {
                        "username": "FrankYJY",
                        "content": "Why there are always problems with strange definition (like here, start from 0,0, from shortest to tallest, but the shortest is not necessarily 0,0 in strange cases) with not-description-fitted cases?"
                    }
                ]
            }
        ]
    }
]