[
    {
        "title": "Continuous Subarray Sum",
        "question_content": "Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\n\n\tits length is at least two, and\n\tthe sum of the elements of the subarray is a multiple of k.\n\nNote that:\n\n\tA subarray is a contiguous part of the array.\n\tAn integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\n\n&nbsp;\nExample 1:\n\nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\nExample 2:\n\nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\nExample 3:\n\nInput: nums = [23,2,6,4,7], k = 13\nOutput: false\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] <= 109\n\t0 <= sum(nums[i]) <= 231 - 1\n\t1 <= k <= 231 - 1",
        "solutions": [
            {
                "id": 99499,
                "title": "java-o-n-time-o-k-space",
                "content": "We iterate through the input array exactly once, keeping track of the running sum mod k of the elements in the process. If we find that a running sum value at index j has been previously seen before in some earlier index i in the array, then we know that the sub-array (i,j] contains a desired sum.\\n\\n```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n    Map<Integer, Integer> map = new HashMap<>(){{put(0,-1);}};;\\n    int runningSum = 0;\\n    for (int i=0;i<nums.length;i++) {\\n        runningSum += nums[i];\\n        if (k != 0) runningSum %= k; \\n        Integer prev = map.get(runningSum);\\n        if (prev != null) {\\n            if (i - prev > 1) return true;\\n        }\\n        else map.put(runningSum, i);\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n    Map<Integer, Integer> map = new HashMap<>(){{put(0,-1);}};;\\n    int runningSum = 0;\\n    for (int i=0;i<nums.length;i++) {\\n        runningSum += nums[i];\\n        if (k != 0) runningSum %= k; \\n        Integer prev = map.get(runningSum);\\n        if (prev != null) {\\n            if (i - prev > 1) return true;\\n        }\\n        else map.put(runningSum, i);\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150330,
                "title": "math-behind-the-solutions",
                "content": "Haven\\'t seen anyone post the math or theory behind the solutions yet, so I\\'m sharing mine. Let me know if there is any better one.\\n    In short, start with mod =0, then we always do mod = (mod+nums[i])%k, if mod repeats, that means between these two mod = x occurences the sum is multiple of k.\\n    Math: c = a % k, c = b % k, so we have a % k = b % k. \\n\\t\\tWhere a is the mod at i and b is the mod at j and a <= b, i < j, because all nums are non-negative. And c is the mod that repeats.\\n\\t\\tSuppose b-a=d, then we have b % k = ((a+d) % k)%k = (a%k + d%k)%k\\n    In order to make the equation valid: a % k = (a%k + d%k)%k\\n    d%k has to be 0, so d, the different between b and a, is a multiple of k\\n    Example: \\n         [23, 2, 1, 6, 7] k=9\\n    mod = 5,  7, 8, 5 <-- at here we found it",
                "solutionTags": [],
                "code": "Haven\\'t seen anyone post the math or theory behind the solutions yet, so I\\'m sharing mine. Let me know if there is any better one.\\n    In short, start with mod =0, then we always do mod = (mod+nums[i])%k, if mod repeats, that means between these two mod = x occurences the sum is multiple of k.\\n    Math: c = a % k, c = b % k, so we have a % k = b % k. \\n\\t\\tWhere a is the mod at i and b is the mod at j and a <= b, i < j, because all nums are non-negative. And c is the mod that repeats.\\n\\t\\tSuppose b-a=d, then we have b % k = ((a+d) % k)%k = (a%k + d%k)%k\\n    In order to make the equation valid: a % k = (a%k + d%k)%k\\n    d%k has to be 0, so d, the different between b and a, is a multiple of k\\n    Example: \\n         [23, 2, 1, 6, 7] k=9\\n    mod = 5,  7, 8, 5 <-- at here we found it",
                "codeTag": "Unknown"
            },
            {
                "id": 679929,
                "title": "c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        //Questions to ask the interviewer - \\n        \\n        //1. So you said k is an integer? Can the k be equal to 0? Can it be n-ve?\\n        // ANS - k can be positive, zero or negative - consider all cases !\\n        \\n        // Positive case - [23, 2, 4, 6, 7],  k=6; ANS = true\\n        //Negative Case - [23,2,4,6,7], k= -6; ANS = true (Since n=-1 and -1*-6=6)\\n        //Zero Case - [0,0], k=0; ANS = true \\n        \\n        //2. \\'n\\' can be anything right? positive, negative and zero\\n        \\n        //Explanation of algorithm to interviewer - \\n        \\n        //A proof sketch:\\n        // Suppose sum_i represents the running sum starting from index 0 and ending at i\\n        // once we find a mod that has been seen, say modk, we have:\\n        \\n        // current one: sum_i = m*k + modk\\n        // previous one: sum_j = n*k + modk\\n        // Thus,\\n        // sum_i - sum_j = (m - n) *k\\n        \\n        //so if two runningSum mod k have the same values, then when they are subtracted, they are bound to be multiples of k\\n\\n        //base checking - first check if the size of the array is less than 2\\n        \\n        if(nums.size()<2)\\n            return false;\\n        \\n        //Create a hashmap of the running_sum remainder and it\\'s respective index\\n        \\n        unordered_map<int, int> mp;\\n        \\n        //Why to insert <0,-1> for the hashmap\\n        \\n        // <0,-1> can allow it to return true when the runningSum%k=0,\\n        \\n        //for example [1,2,3] is input and k=6\\n        //then the remainders are [ 1,3,0] i.e runningSum = runningSum%k\\n        //now 1+2+3=6 which is actually a multiple of 6 and hence 0 should be stored in the hashmap\\n        \\n        //ok - but why -1?\\n        //-1 is good for storing for 0 because - it will remove the case where we consider only the first element which alone may be a multiple as 0-(-1) is not greater than 1\\n        \\n        // In addition, it also avoids the first element of the array is the multiple of k, since 0-(-1)=1 is not greater than 1.\\n        \\n        mp[0]=-1;\\n        \\n        int runningSum=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            runningSum+=nums[i];\\n            \\n            if(k!=0) \\n                runningSum = runningSum%k;\\n            \\n            //check if the runningsum already exists in the hashmap\\n            if(mp.find(runningSum)!=mp.end())\\n            {\\n                //if it exists, then the current location minus the previous location must be greater than1\\n                \\n                if(i-mp[runningSum]>1)\\n                    return true;\\n            }\\n            else\\n            {\\n                //otherwise if the current runningSum doesn\\'t exist in the hashmap, then store it as it maybe used later on\\n                \\n                mp[runningSum]=i;\\n            }\\n                    \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        //Questions to ask the interviewer - \\n        \\n        //1. So you said k is an integer? Can the k be equal to 0? Can it be n-ve?\\n        // ANS - k can be positive, zero or negative - consider all cases !\\n        \\n        // Positive case - [23, 2, 4, 6, 7],  k=6; ANS = true\\n        //Negative Case - [23,2,4,6,7], k= -6; ANS = true (Since n=-1 and -1*-6=6)\\n        //Zero Case - [0,0], k=0; ANS = true \\n        \\n        //2. \\'n\\' can be anything right? positive, negative and zero\\n        \\n        //Explanation of algorithm to interviewer - \\n        \\n        //A proof sketch:\\n        // Suppose sum_i represents the running sum starting from index 0 and ending at i\\n        // once we find a mod that has been seen, say modk, we have:\\n        \\n        // current one: sum_i = m*k + modk\\n        // previous one: sum_j = n*k + modk\\n        // Thus,\\n        // sum_i - sum_j = (m - n) *k\\n        \\n        //so if two runningSum mod k have the same values, then when they are subtracted, they are bound to be multiples of k\\n\\n        //base checking - first check if the size of the array is less than 2\\n        \\n        if(nums.size()<2)\\n            return false;\\n        \\n        //Create a hashmap of the running_sum remainder and it\\'s respective index\\n        \\n        unordered_map<int, int> mp;\\n        \\n        //Why to insert <0,-1> for the hashmap\\n        \\n        // <0,-1> can allow it to return true when the runningSum%k=0,\\n        \\n        //for example [1,2,3] is input and k=6\\n        //then the remainders are [ 1,3,0] i.e runningSum = runningSum%k\\n        //now 1+2+3=6 which is actually a multiple of 6 and hence 0 should be stored in the hashmap\\n        \\n        //ok - but why -1?\\n        //-1 is good for storing for 0 because - it will remove the case where we consider only the first element which alone may be a multiple as 0-(-1) is not greater than 1\\n        \\n        // In addition, it also avoids the first element of the array is the multiple of k, since 0-(-1)=1 is not greater than 1.\\n        \\n        mp[0]=-1;\\n        \\n        int runningSum=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            runningSum+=nums[i];\\n            \\n            if(k!=0) \\n                runningSum = runningSum%k;\\n            \\n            //check if the runningsum already exists in the hashmap\\n            if(mp.find(runningSum)!=mp.end())\\n            {\\n                //if it exists, then the current location minus the previous location must be greater than1\\n                \\n                if(i-mp[runningSum]>1)\\n                    return true;\\n            }\\n            else\\n            {\\n                //otherwise if the current runningSum doesn\\'t exist in the hashmap, then store it as it maybe used later on\\n                \\n                mp[runningSum]=i;\\n            }\\n                    \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236976,
                "title": "python-solution",
                "content": "Idea: if `sum(nums[i:j]) % k == 0` for some `i < j`, then `sum(nums[:j]) % k == sum(nums[:i]) % k`. So we just need to use a dictionary to keep track of `sum(nums[:i]) % k` and the corresponding index `i`. Once some later `sum(nums[:i\\']) % k == sum(nums[:i]) % k` and `i\\' - i > 1`, we return `True`. \\n\\nTime complexity: `O(n)`, space complexity: `O(min(k, n))` if `k != 0`, else `O(n)`.\\n\\n```\\nclass Solution():\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        dic = {0:-1}\\n        summ = 0\\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                summ = (summ + n) % k\\n            else:\\n                summ += n\\n            if summ not in dic:\\n                dic[summ] = i\\n            else:\\n                if i - dic[summ] >= 2:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution():\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        dic = {0:-1}\\n        summ = 0\\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                summ = (summ + n) % k\\n            else:\\n                summ += n\\n            if summ not in dic:\\n                dic[summ] = i\\n            else:\\n                if i - dic[summ] >= 2:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99506,
                "title": "concise-c-solution-use-set-instead-of-map",
                "content": "There is really no need to use map, the required length is at least 2, so we just need to insert the mod one iteration later.\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size(), sum = 0, pre = 0;\\n        unordered_set<int> modk;\\n        for (int i = 0; i < n; ++i) {\\n            sum += nums[i];\\n            int mod = k == 0 ? sum : sum % k;\\n            if (modk.count(mod)) return true;\\n            modk.insert(pre);\\n            pre = mod;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size(), sum = 0, pre = 0;\\n        unordered_set<int> modk;\\n        for (int i = 0; i < n; ++i) {\\n            sum += nums[i];\\n            int mod = k == 0 ? sum : sum % k;\\n            if (modk.count(mod)) return true;\\n            modk.insert(pre);\\n            pre = mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1388564,
                "title": "c-crystal-clear-solution-prefix-sum-explanation-o-n-time-using-map",
                "content": "\\n**Intution :** \\n\\n * We need a subarray say from i to j such that sum of all elements is divisible by k.\\n\\t * sum_j means prefix sum from 0 to j\\n\\t * sum_i means prefix sum from 0 to i\\n\\n\\t\\t\\t=> (sum_j - sum_i) % k = 0\\n\\t\\t\\t=> sum_j % k - sum % k = 0\\n\\t\\t\\t=> sum_j % k = sum_i % k    <Relation derived !!!>\\n\\n* Thus for some prefix_sum(0,j) , we need to check if there exist some prefix_sum(0,i) such that both are equal. \\n\\t- If yes then return true.\\n\\t- Otherwise check for some other j\\n\\t\\n* Lets do a dry run on first example:\\n\\t*  Given, nums : 23 2 4 6 7  ,    k = 6\\n\\t* Prefix_Sum at every iteration from 0->i : \\n\\t\\t\\n\\t\\t\\ti = 0  , prefixSum = 23%6 = 5       | map[5] = 0 (new entry)\\n\\t\\t\\ti = 1 , prefixSum = (5+2)%6 = 1     | map[1] = 1 (new entry)\\n\\t\\t\\ti = 2 , prefixSum = (1+4)%6 = 5     | map[5] (already exist) !! -> Possible answer\\n\\n\\t* *Also, i - map[5] = 2 > 1 ... therefore atleast 2 elements condition is also satisfied*\\n\\n# Code :\\n\\n```\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n     \\n\\tint prefSum = 0;\\n\\tunordered_map<int, int> mp;\\n\\tfor(int i=0; i<nums.size(); i++)\\n\\t{\\n\\t\\tprefSum += nums[i];\\n\\t\\tprefSum %= k;\\n\\n\\t\\tif(prefSum == 0 && i) return true;\\n\\n\\t\\t// cout << prefSum << \" \";\\n\\t\\tif(mp.find(prefSum) != mp.end())  // Found the required prefix sum \\n\\t\\t{\\n\\t\\t\\tif(i - mp[prefSum] > 1) return true; // check if atleast 2 elements are there or not\\n\\t\\t}\\n\\t\\telse mp[prefSum] = i;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\nHope it was clear... \\nFeel free to ask in case of any query or correction !!! \\nAlso if you liked the solution please do upvote :)",
                "solutionTags": [
                    "C",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n     \\n\\tint prefSum = 0;\\n\\tunordered_map<int, int> mp;\\n\\tfor(int i=0; i<nums.size(); i++)\\n\\t{\\n\\t\\tprefSum += nums[i];\\n\\t\\tprefSum %= k;\\n\\n\\t\\tif(prefSum == 0 && i) return true;\\n\\n\\t\\t// cout << prefSum << \" \";\\n\\t\\tif(mp.find(prefSum) != mp.end())  // Found the required prefix sum \\n\\t\\t{\\n\\t\\t\\tif(i - mp[prefSum] > 1) return true; // check if atleast 2 elements are there or not\\n\\t\\t}\\n\\t\\telse mp[prefSum] = i;\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1405425,
                "title": "a-java-implementation-of-prefix-sum-that-may-be-easier-to-understand",
                "content": "To be honest, I was quite confused when I first saw the most voted answers and struggled a long time to understand why we should have the line `map.put(0, -1);` after initializing our hash map to store `sum % k` and the current index in the input array as key-value pairs.\\n\\nBut thanks to this great post (the solution for #437 Path Sum III: https://leetcode.com/problems/path-sum-iii/solution/), which explains thoroughly how prefix sum works, I came up with this version which corresponds with the \"two cases\" discussed in that very post. The only difference is that instead of storing the prefix sum at each index into hash map, we are storing the prefix sum **mod by k**, and we have one restriction that the subarray size should be greater than 1. \\n\\nSo similarly, our code now looks like this:\\n\\n* Things we need to do\\n\\n```\\ninitialize hash map\\ninitialize prefixSum variable \\na for-loop to iterate over input array {\\n    add up the current element to prefixSum, mod by k\\n\\tdiscuss case 1 { found : return true }\\n\\tdiscuss case 2 { found : return true }\\n\\tstore the current mod value into hash map if no answer is found, continue the for-loop\\n}\\nreturn false if we exhaust all possible cases\\n```\\n\\n* Case 1: We find that prefix sum mod by k equals 0, which is what we want. If the size > 1 restriction is also satisfied, return true directly.\\n\\n```\\n// somewhere in the for-loop\\nif (sum == 0 && i > 0) {\\n    return true;\\n}\\n```\\n\\n* Case 2: We check whether prefix sum mod by k is already in our hash set. If it is, and the size > 1 restriction is also satisfied, return true.\\n\\n```\\n// somewhere in the for-loop\\nif (map.containsKey(sum) && i - map.get(sum) > 1) { \\n    return true;\\n}\\n```\\n\\n* The whole code:\\n\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {      \\n        // maintain a hash map to store <sum % k, index>\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sum %= k; \\n            // case 1\\n            if (sum == 0 && i > 0) {\\n                return true;\\n            }\\n            // case 2\\n            if (map.containsKey(sum) && i - map.get(sum) > 1) { \\n                return true;\\n            }\\n            if (!map.containsKey(sum)) {\\n                map.put(sum, i); \\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n* Time complexity = O(n) for traversing n elements in input array\\n* Space complexity = O(n) for hash map storage",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\ninitialize hash map\\ninitialize prefixSum variable \\na for-loop to iterate over input array {\\n    add up the current element to prefixSum, mod by k\\n\\tdiscuss case 1 { found : return true }\\n\\tdiscuss case 2 { found : return true }\\n\\tstore the current mod value into hash map if no answer is found, continue the for-loop\\n}\\nreturn false if we exhaust all possible cases\\n```\n```\\n// somewhere in the for-loop\\nif (sum == 0 && i > 0) {\\n    return true;\\n}\\n```\n```\\n// somewhere in the for-loop\\nif (map.containsKey(sum) && i - map.get(sum) > 1) { \\n    return true;\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {      \\n        // maintain a hash map to store <sum % k, index>\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sum %= k; \\n            // case 1\\n            if (sum == 0 && i > 0) {\\n                return true;\\n            }\\n            // case 2\\n            if (map.containsKey(sum) && i - map.get(sum) > 1) { \\n                return true;\\n            }\\n            if (!map.containsKey(sum)) {\\n                map.put(sum, i); \\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485589,
                "title": "c-python-easy-and-concise",
                "content": "## **Explanation**:\\n`cur` calculate the prefix sum remainder of input array `A`\\n`seen` will record the first occurrence of the remainder.\\nIf we have seen the same remainder before,\\nit means the subarray sum if a multiple of `k`\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Python:**\\n```py\\n    def checkSubarraySum(self, A, k):\\n        seen, cur = {0: -1}, 0\\n        for i, a in enumerate(A):\\n            cur = (cur + a) % abs(k) if k else cur + a\\n            if i - seen.setdefault(cur, i) > 1: return True\\n        return False\\n```\\n**C++**\\n```cpp\\n    bool checkSubarraySum(vector<int>& A, int k) {\\n        unordered_map<int, int> seen = {{0, -1}};\\n        int cur = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            cur =  k ? (cur + A[i]) % abs(k) : cur + A[i];\\n            seen.insert({cur, i});\\n            if (i - seen[cur] > 1) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```py\\n    def checkSubarraySum(self, A, k):\\n        seen, cur = {0: -1}, 0\\n        for i, a in enumerate(A):\\n            cur = (cur + a) % abs(k) if k else cur + a\\n            if i - seen.setdefault(cur, i) > 1: return True\\n        return False\\n```\n```cpp\\n    bool checkSubarraySum(vector<int>& A, int k) {\\n        unordered_map<int, int> seen = {{0, -1}};\\n        int cur = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            cur =  k ? (cur + A[i]) % abs(k) : cur + A[i];\\n            seen.insert({cur, i});\\n            if (i - seen[cur] > 1) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 99566,
                "title": "simple-python-10-lines-with-explanation-58ms-o-n-time-o-k-space",
                "content": "1. If `k == 0`, then search for any consecutive pair of 0s.\\n2. Else, we will keep track of indices of the cumulative sum (or prefix sum) mod by k in a dictionary. We will return True if we've seen a `cumulative sum % k` at least 2 indices before.\\n* This means that there is a subarray that has a `sum(subarray) % k == 0` and that subarray contains at least 2 elements.\\n\\n```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        if k == 0:\\n            return any(nums[i] == 0 and nums[i + 1] == 0 for i in xrange(len(nums) - 1))\\n        mods, cum_sum_mod_k = {0: -1}, 0\\n        for i, n in enumerate(nums):\\n            cum_sum_mod_k = (cum_sum_mod_k + n) % k\\n            if cum_sum_mod_k in mods and i - mods[cum_sum_mod_k] > 1:\\n                return True\\n            if cum_sum_mod_k not in mods:\\n                mods[cum_sum_mod_k] = i\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        if k == 0:\\n            return any(nums[i] == 0 and nums[i + 1] == 0 for i in xrange(len(nums) - 1))\\n        mods, cum_sum_mod_k = {0: -1}, 0\\n        for i, n in enumerate(nums):\\n            cum_sum_mod_k = (cum_sum_mod_k + n) % k\\n            if cum_sum_mod_k in mods and i - mods[cum_sum_mod_k] > 1:\\n                return True\\n            if cum_sum_mod_k not in mods:\\n                mods[cum_sum_mod_k] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99518,
                "title": "not-smart-solution-but-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)   return false;\\n        \\n        int[] preSum = new int[nums.length+1];\\n        \\n        for (int i = 1; i <= nums.length; i++) {\\n            preSum[i] = preSum[i-1] + nums[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+2; j <= nums.length; j++) { // j = i + 2 is because question mentions subarray size at least 2\\n                if (k == 0) {\\n                    if (preSum[j] - preSum[i] == 0) {\\n                        return true;\\n                    }\\n                } else if ((preSum[j] - preSum[i]) % k == 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)   return false;\\n        \\n        int[] preSum = new int[nums.length+1];\\n        \\n        for (int i = 1; i <= nums.length; i++) {\\n            preSum[i] = preSum[i-1] + nums[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+2; j <= nums.length; j++) { // j = i + 2 is because question mentions subarray size at least 2\\n                if (k == 0) {\\n                    if (preSum[j] - preSum[i] == 0) {\\n                        return true;\\n                    }\\n                } else if ((preSum[j] - preSum[i]) % k == 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744281,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**APPROACH**\\n\\nIf ```sum(nums[i:j]) % k == 0``` for some ```i < j```,\\n* Then ```sum(nums[:j]) % k == sum(nums[:i]) % k```\\n* We just need to use a dictionary to keep track of ```sum(nums[:i]) % k``` and the corresponding index i.\\n* Whenever ```sum(nums[:i\\']) % k == sum(nums[:i]) % k and i\\' - i > 1```, we return True.\\n\\n**MATHS**\\n\\n```( s + (n * k)) % k <==> (s % k)```\\n\\nFor e.g. in case of the array ```[23,2,6,4,7]``` the running sum is ```[23,25,31,35,42]``` .\\nThe remainders are ```[5,1,1,5,0]```. \\nWe got remainder 5 at index 0 and at index 3. \\nThat means, in between these two indexes we must have added a number which is multiple of the k.\\n\\n**PYTHON CODE**\\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        d , s = {0:-1} , 0\\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                s = (s + n) % k\\n            else:\\n                s += n\\n            if s not in d:\\n                d[s] = i\\n            else:\\n                if i - d[s] >= 2:\\n                    return True\\n        return False\\n```\\n\\n**C++ CODE**\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> d;\\n        int s=0;\\n        d[0]=-1;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            s += nums[i];\\n            \\n            if(k!=0) s %= k;\\n            \\n            if(d.find(s) != d.end())\\n            {\\n                if(i-d[s] > 1) return true;\\n            }\\n            else d[s]=i;         \\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nTime   -> **O ( N )**\\nSpace -> **O ( min ( K, N ) )**\\n\\n**UPVOTE IF HELPFuuL**\\n\\n![image](https://assets.leetcode.com/users/images/ef989e7a-085b-41b3-b5e6-890c64296550_1666745167.4033725.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```sum(nums[i:j]) % k == 0```\n```i < j```\n```sum(nums[:j]) % k == sum(nums[:i]) % k```\n```sum(nums[:i]) % k```\n```sum(nums[:i\\']) % k == sum(nums[:i]) % k and i\\' - i > 1```\n```( s + (n * k)) % k <==> (s % k)```\n```[23,2,6,4,7]```\n```[23,25,31,35,42]```\n```[5,1,1,5,0]```\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        d , s = {0:-1} , 0\\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                s = (s + n) % k\\n            else:\\n                s += n\\n            if s not in d:\\n                d[s] = i\\n            else:\\n                if i - d[s] >= 2:\\n                    return True\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> d;\\n        int s=0;\\n        d[0]=-1;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            s += nums[i];\\n            \\n            if(k!=0) s %= k;\\n            \\n            if(d.find(s) != d.end())\\n            {\\n                if(i-d[s] > 1) return true;\\n            }\\n            else d[s]=i;         \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101690,
                "title": "c-code-with-20ms-runtime-and-picture-explanation",
                "content": "* There is a condition of subarray length of **atleast 2**, thats why we store sum in the **map mods** after 1 iteration, we store the sum in a variable `pretemp`.\\n* We dont need to store the whole sum, we just store `sum mod k` or `sum % k` , as `(a + b + .... + z)%k` is equivalent to `( a%k + b%k + .... + z%k)`.\\n* As we cant divide any number by 0, we store the whole in the array. And also for` k = 0` , the function will return true if there are **two continous 0** ( i.e [1, 4, 5, 0, 0, 8] ) in the given array.\\n\\n![image](https://assets.leetcode.com/users/images/db45ba0e-3e3e-47ff-93b9-b9d2e1482730_1615312334.6725743.png)\\n\\n\\n#### **C++ runtime 20ms**\\n```\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n        int n=nums.size(), pretemp=0, sum=0;\\n        map<int,int> mods;\\n        for (int i=0; i<n; i++){\\n            sum = (sum + nums[i]) % k;  // [edited]\\n            if (mods[sum]) return true;\\n            mods[pretemp] ++;\\n            pretemp = sum;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n        int n=nums.size(), pretemp=0, sum=0;\\n        map<int,int> mods;\\n        for (int i=0; i<n; i++){\\n            sum = (sum + nums[i]) % k;  // [edited]\\n            if (mods[sum]) return true;\\n            mods[pretemp] ++;\\n            pretemp = sum;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338417,
                "title": "python-solution-with-explanation",
                "content": "Approach:\\nSame as Subarray sum equals K with modification. Basic idea is that, **If you get the same remainder again, it means that you\\'ve encountered some sum which is a multiple of K**.\\n\\n```\\nd = dict()\\nd[0] = -1\\nsums = 0\\n\\nfor i in range(len(nums)):\\n\\tsums+=nums[i]\\n\\tif(k!=0):\\n\\t\\tsums = sums%k\\n\\tif(sums in d):\\n\\t\\tif(i-d[sums]>1):\\n\\t\\t\\treturn(True)\\n\\telse:\\n\\t\\td[sums] = i\\n\\nreturn(False)\\n```\\n\\n**Explanation with example**\\n\\n\\tExample:\\n\\tnums = [23,2,4], k = 6\\n\\tLets walk through the code with the example. \\n\\t(i=0) : sums = 23 => 23%6 => (sums = 5)\\n\\t(i=1) : sums = 5+2=7 => 7%6 => (sums = 1)\\n\\t(i=2) : sums = 1+4=5 => 5%6 => (sums = 5)\\n\\nWe have encountered the **same sums(remainder) again which means we have the subarray of sums%k = 0**.\\nBut, there\\'s another aspect to this problem. **The subarray must have a minimum size of 2**. \\nThat is why we check if (i - d[sums])>1. \\nIn the above example, this if loop is executed when (i=2) and (d[sums]=1). \\nIn other words, the same remainder(sums=5) has been encountered twice and then we check for the respective difference in indices.\\n\\n\\tCounter example to understand this. Lets take nums = [23,6], k = 6\\n\\t(i=0) : sums = 23 => 23%6 => (sums = 5)\\n\\t(i=1) : sums = 5+6=11 => 11%6 => (sums = 5)\\n\\nSo, the same sums(remainder) has appeared again which means we\\'ve found the subarray but it is not a subarray of size 2 or more.\\nBecause they\\'ve occurred next to each other, which means that, we have just one element in the subarray which contributes.\\nIf you remove 23 from the nums array and keep 6 alone, it will still be a subarray whose sum%k is 0. But, we want a subarray of size 2 or more.\\nThis is the reason why we calculate the index difference and then return True.\\n\\nAlso, if your k==0, you don\\'t need to find the remainder. So, you just keep adding the sums and repeat the rest of the process.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nd = dict()\\nd[0] = -1\\nsums = 0\\n\\nfor i in range(len(nums)):\\n\\tsums+=nums[i]\\n\\tif(k!=0):\\n\\t\\tsums = sums%k\\n\\tif(sums in d):\\n\\t\\tif(i-d[sums]>1):\\n\\t\\t\\treturn(True)\\n\\telse:\\n\\t\\td[sums] = i\\n\\nreturn(False)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99545,
                "title": "share-my-o-n-c-accumulation-modulo-solution-with-thinking-process-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nGiven a list of **non-negative** numbers and a target **integer** k, write a function to check if the array has a continuous subarray of size **at least 2** that sums up to the multiple of **k**, that is, sums up to n*k where n is also an **integer**\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Calculate the summation of a continuous subarray\\n\\n---\\nAs we know **the summation of series**\\n\\n>#### **S(n) = a(1) + a(2) + ... + a(n), n \\u2265 1**\\n\\nwhich has a **recursion formula**\\n\\n>#### **S(n) = a(1), n = 1**\\n>#### **S(n) = a(n) + S(n - 1), n > 1**\\n\\nSuppose **the summation** of a **subarray** from **a(i)** to **a(j)** is\\n\\n>#### **T(i, j) = a(i) + a(i + 1) + ... + a(j - 1) + a(j), 1\\u2264 i < j \\u2264 n.**\\n\\nIt can be inferred that \\n\\n>#### **T(i, j) = S(j), i = 1.**\\n>#### **T(i, j) = S(j) - S(i - 1), i > 1.**\\n\\n---\\n#### 2.2 Define the multiple of k (k \\u2260 0) by modulo\\n\\n---\\nThe problem is to find a continuous subarray of size **at least 2** that sums up to the multiple of **k**, which means\\n\\n>#### **T(i, j) = n \\xd7 k, 1\\u2264 i < j \\u2264 n.**\\n\\nThat is to say\\n\\n>#### **S(j) = n \\xd7 k , 1 = i < j.**\\n>#### **S(j) - S(i - 1) = n \\xd7 k, 1 < i < j.**\\n\\nBy doing the modulo, we get\\n\\n>#### **S(j) \\u2261 0 mod k , 1 = i < j.**\\n>#### **S(j) \\u2261 S(i - 1) mod k, 1 < i < j.**\\n\\n---\\n## 3. Algorithm\\n\\n---\\n#### 3.1. Special cases\\n\\n---\\n**A. The size of array < 2**\\n\\n- Since the size of subarray is **at least 2**, **return false**.\\n\\n---\\n**B. k = 0**\\n\\n>#### **T(i, j) = a(i) + a(i + 1) + ... + a(j - 1) + a(j) = 0.**\\n\\nAs the array only contains **non-negative** numbers, that is to say\\n\\n>#### **a(i) = a(i + 1) = ... = a(j - 1) = a(j) = 0.**\\n\\nSince the size of subarray is **at least 2**, \\n\\n- if there are **2 adjacent zeros** in the array, **return true.**\\n\\n- **If not, return false.**\\n\\n---\\n#### 3.2 Normal situation\\n---\\n**Step 1:  Summation**\\n\\n---\\n\\nDo iteration by using the recursion formula\\n\\n>#### **S(n) = a(1), n = 1**\\n>#### **S(n) = a(n) + S(n - 1), n > 1.**\\n\\n---\\n**Step 2: Modulo operation**\\n\\n---\\nThere are **2 situations**:\\n\\n>#### **S(j) \\u2261 0 mod k , 1 = i < j.**\\n\\n>#### **S(j) \\u2261 S(i - 1) mod k, 1 < i < j.**\\n\\nWhen **doing iteration from j = 1 to j = n**, we need to judge\\n\\n**A. When j > 1 and S(j) \\u2261 0 mod k, return true.**\\n\\n**B. Use a hash table (the key is S(i) mod k) to record THE FIRST i. If a same key appears twice (means S(j) \\u2261 S(i) mod k) and j - i > 1, return true.**\\n\\n(At first I didn't notice that the size is **at least 2**, thanks to @BavariaKing1822 )\\n\\n**C. After the iteration, return false.**\\n\\n---\\n## 4. Complexity analysis\\n\\n---\\n#### 4.1 Time complexity\\n\\n---\\nAs **Step 1 and Step 2** in **Section 3** can be merged to **a single iteration from j = 1 to j = n**.\\n\\n> #### **The time complexity is O(n)**.\\n\\n---\\n#### 4.2 Space complexity\\n\\n---\\nAs the **hash table's key** is **a remainder from division based on integer k**, the **probable maximum size** of the hash table is **|k|**.\\n\\n>#### **The space complexity is O(|k|)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() < 2) return false;\\n        if(k == 0)\\n        {\\n            for(int i = 1; i < nums.size(); i++)\\n            {\\n                if(nums[i] == 0 && nums[i - 1] == 0) return true;\\n            }\\n            return false;\\n        }else{\\n            int i = 0;\\n            map<int, int> res;\\n            while(true)\\n            {\\n                if(i != 0 && nums[i] % k == 0)\\n                {\\n                    return true;\\n                }else{\\n                    if(res.find(nums[i] % k) == res.end())\\n                    { \\n                         res[nums[i] % k] = i;\\n                    }else{\\n                         if(i - res[nums[i] % k] > 1) return true;\\n                    }\\n                }\\n                i++;\\n                if(i == nums.size()) return false;\\n                nums[i] += nums[i - 1];\\n            }\\n        }\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() < 2) return false;\\n        if(k == 0)\\n        {\\n            for(int i = 1; i < nums.size(); i++)\\n            {\\n                if(nums[i] == 0 && nums[i - 1] == 0) return true;\\n            }\\n            return false;\\n        }else{\\n            int i = 0;\\n            map<int, int> res;\\n            while(true)\\n            {\\n                if(i != 0 && nums[i] % k == 0)\\n                {\\n                    return true;\\n                }else{\\n                    if(res.find(nums[i] % k) == res.end())\\n                    { \\n                         res[nums[i] % k] = i;\\n                    }else{\\n                         if(i - res[nums[i] % k] > 1) return true;\\n                    }\\n                }\\n                i++;\\n                if(i == nums.size()) return false;\\n                nums[i] += nums[i - 1];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744844,
                "title": "c-explanation-beginner-continuos-subarray-sum",
                "content": "**Please upvote, your one upvote makes me happy**\\n\\n^____^\\n\\n**Explanation**\\n\\nWe need a subarray say from i to j such that sum of all elements is divisible by k.\\n\\nsum_j means prefix sum from 0 to j.\\n\\nSum_i means prefix sum from 0 to i.\\n\\n```\\n => (sum_j - sum_i) % k = 0\\n => sum_j % k - sum % k = 0\\n => sum_j % k = sum_i % k \\n ```\\n \\n Thus for some prefix_sum(0,j) , we need to check if there exist some prefix_sum(0,i) such that both are equal.\\n \\n If yes then return true.\\nOtherwise check for some other j\\nLets do a dry run on first example:\\n\\n```Given, nums : 23 2 4 6 7 , k = 6```\\n\\nPrefix_Sum at every iteration from 0->i :\\n\\n```\\n  i = 0  , prefixSum = 23%6 = 5       | map[5] = 0 (new entry)\\n  i = 1 , prefixSum = (5+2)%6 = 1     | map[1] = 1 (new entry)\\n  i = 2 , prefixSum = (1+4)%6 = 5     | map[5] (already exist) !! -> Possible answer\\nAlso, i - map[5] = 2 > 1 ... therefore atleast 2 elements condition is also satisfied\\n```\\n\\n**Here is the code**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n  int prefSum = 0;\\n  \\n  unordered_map<int, int> mp;\\n  for(int i=0; i<nums.size(); i++)\\n  {\\n    prefSum += nums[i];\\n    prefSum %= k;\\n\\n    if(prefSum == 0 && i) return true;\\n\\n    if(mp.find(prefSum) != mp.end())  // Found the required prefix sum \\n    {\\n      if(i - mp[prefSum] > 1) return true; // check if atleast 2 elements are there or not\\n    }\\n    else mp[prefSum] = i;\\n  }\\n\\n  return false; \\n        \\n    }\\n};\\n```\\n\\n**Keep coding Keep upvoting**\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n => (sum_j - sum_i) % k = 0\\n => sum_j % k - sum % k = 0\\n => sum_j % k = sum_i % k \\n ```\n```Given, nums : 23 2 4 6 7 , k = 6```\n```\\n  i = 0  , prefixSum = 23%6 = 5       | map[5] = 0 (new entry)\\n  i = 1 , prefixSum = (5+2)%6 = 1     | map[1] = 1 (new entry)\\n  i = 2 , prefixSum = (1+4)%6 = 5     | map[5] (already exist) !! -> Possible answer\\nAlso, i - map[5] = 2 > 1 ... therefore atleast 2 elements condition is also satisfied\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n  int prefSum = 0;\\n  \\n  unordered_map<int, int> mp;\\n  for(int i=0; i<nums.size(); i++)\\n  {\\n    prefSum += nums[i];\\n    prefSum %= k;\\n\\n    if(prefSum == 0 && i) return true;\\n\\n    if(mp.find(prefSum) != mp.end())  // Found the required prefix sum \\n    {\\n      if(i - mp[prefSum] > 1) return true; // check if atleast 2 elements are there or not\\n    }\\n    else mp[prefSum] = i;\\n  }\\n\\n  return false; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607327,
                "title": "clean-java-o-n-code-with-comment",
                "content": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        Map <Integer, Integer> map = new HashMap(); // key: rolling sum% k, val: array index\\n        map.put(0, -1); \\n        int sum =0;\\n        for(int i=0; i<nums.length; i++){\\n            sum+=nums[i]; \\n            int mod = k==0? sum:sum%k; //compute sum%k\\n\\t\\t\\t//when map contains mod, it means that there exist an subarray from 0~j (j=map.get(mod)) where its sum%k==mod.\\n\\t\\t\\t//which means that subarray sum( j~i) %k==0. \\n            if(map.containsKey(mod) && i-map.get(mod)>1) return true; \\n            map.putIfAbsent(mod,i);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        Map <Integer, Integer> map = new HashMap(); // key: rolling sum% k, val: array index\\n        map.put(0, -1); \\n        int sum =0;\\n        for(int i=0; i<nums.length; i++){\\n            sum+=nums[i]; \\n            int mod = k==0? sum:sum%k; //compute sum%k\\n\\t\\t\\t//when map contains mod, it means that there exist an subarray from 0~j (j=map.get(mod)) where its sum%k==mod.\\n\\t\\t\\t//which means that subarray sum( j~i) %k==0. \\n            if(map.containsKey(mod) && i-map.get(mod)>1) return true; \\n            map.putIfAbsent(mod,i);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744635,
                "title": "java-easy-solution-with-explanation-95-faster-code-hashset",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Set<Integer> modSet=new HashSet();\\n        int currSum = 0, prevSum=0; \\n\\t\\t//when we add prevSum=0 in set it will actually check if currSum is divided by k \\n        for(int n : nums) {\\n            currSum += n;\\n            if(modSet.contains(currSum%k)) {\\n                return true;\\n            }\\n            currSum %=k;\\n            modSet.add(prevSum);\\n            prevSum = currSum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Set<Integer> modSet=new HashSet();\\n        int currSum = 0, prevSum=0; \\n\\t\\t//when we add prevSum=0 in set it will actually check if currSum is divided by k \\n        for(int n : nums) {\\n            currSum += n;\\n            if(modSet.contains(currSum%k)) {\\n                return true;\\n            }\\n            currSum %=k;\\n            modSet.add(prevSum);\\n            prevSum = currSum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374913,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        unordered_map<int,int>m;\\n        // key is the remainder \\n        // value is the index\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem==0 && i>0)\\n            {\\n                return true;\\n            }\\n            if(m.find(rem)==m.end())\\n            {\\n                m[rem]=i;\\n            }\\n            else if(i-m[rem]>=2)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        unordered_map<int,int>m;\\n        // key is the remainder \\n        // value is the index\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem==0 && i>0)\\n            {\\n                return true;\\n            }\\n            if(m.find(rem)==m.end())\\n            {\\n                m[rem]=i;\\n            }\\n            else if(i-m[rem]>=2)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99512,
                "title": "python-with-explanation-62ms-time-o-min-n-k-mostly",
                "content": "- ```if k == 0```  \\n   If there are two continuous zeros in ```nums```, return ```True```\\n   ###### Time O(n).\\n- ```if n >= 2k and k > 0```\\n      There will be at least three numbers in ```sum``` with the same remainder divided by ```k```. So I can return True without any extra calculation.\\n     ###### Time O(1).\\n- ```if n < 2k and k > 0```\\n     If I can find two numbers in ```sum``` with the same remainder divided by ```k``` and the distance of them is greater than or equal to 2\\uff0c return ```True```.\\n   ###### Time O(n) <= O(k).\\n- ```k < 0```\\nsame as ```k > 0```.\\n\\n```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n\\n        \\n        if k == 0:\\n            # if two continuous zeros in nums, return True\\n            # time O(n)\\n            for i in range(0, len(nums) - 1):\\n                if nums[i] == 0 and nums[i+1] == 0:\\n                    return True\\n            return False\\n        \\n        k = abs(k)\\n        if len(nums) >= k * 2:\\n            return True\\n        \\n        #if n >= 2k: return True\\n        #if n < 2k:  time O(n) is O(k)  \\n\\n        sum = [0]\\n        for x in nums:\\n            sum.append((sum[-1] + x) % k)\\n        \\n        Dict = {}\\n        for i in range(0, len(sum)):\\n            if Dict.has_key(sum[i]):\\n                if i - Dict[sum[i]] > 1:\\n                    return True\\n            else:\\n                Dict[sum[i]] = i\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```if k == 0```\n```nums```\n```True```\n```if n >= 2k and k > 0```\n```sum```\n```k```\n```if n < 2k and k > 0```\n```sum```\n```k```\n```True```\n```k < 0```\n```k > 0```\n```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n\\n        \\n        if k == 0:\\n            # if two continuous zeros in nums, return True\\n            # time O(n)\\n            for i in range(0, len(nums) - 1):\\n                if nums[i] == 0 and nums[i+1] == 0:\\n                    return True\\n            return False\\n        \\n        k = abs(k)\\n        if len(nums) >= k * 2:\\n            return True\\n        \\n        #if n >= 2k: return True\\n        #if n < 2k:  time O(n) is O(k)  \\n\\n        sum = [0]\\n        for x in nums:\\n            sum.append((sum[-1] + x) % k)\\n        \\n        Dict = {}\\n        for i in range(0, len(sum)):\\n            if Dict.has_key(sum[i]):\\n                if i - Dict[sum[i]] > 1:\\n                    return True\\n            else:\\n                Dict[sum[i]] = i\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666972,
                "title": "java-o-n-with-explanation-and-iteration-run-down",
                "content": "For an array `arr` of length `n`\\n` arr = a0, a1, .....ai....aj....an-1`\\nAnd we are searching if a a sub array sum is a multiple of \\'k\\'\\n\\nSum till ith and sum till jth elements from 0 are as follows `sumi` and `sumj`\\n```\\n sumi = a0+a1+ ... + ai\\n sumj = a0+a1+ ... + aj\\n```\\n\\n From remainder theorem we know that for any two numbers `a`, `b`, there exists a constant such that\\n` a = b*q + r`, where `r` is the remainder or modulus.\\n\\n Similarly\\n```\\n sumi = K*ConstA + modi\\n sumj = K*ConstB + modj\\n```\\n\\nIf the modulus of the above two sums are equal, we can subtract the equation and know that we\\'ve found the sub range that adds to a sum divisible by `k` \\nThat means if  `modi = modj`, we\\'ve found the range\\n` Sumi-Sumj =  K (constA - constB)`\\n\\n**Example:**\\nConsider the array  `[ 3,  23, 2, 6, 4, 7 ]`\\n```\\n 3 + 23 + 2 + 6 = 34\\n 3 + 23 + 2 = 28\\n```\\n\\n```\\n 34 = 6*5 + 4\\n 28 = 6*4 + 4\\n```\\n\\nThis means that we\\'ve found a sub array with sum that is divisible by 6\\nWe pre load the hashmap with `(0, -1)` to handle the base case where if we run into a running modulus of 0, it means we\\'ve found the sub array starting from the first element. (and since we store hashMap values as index items and we didn\\'t account for this, we store the value as `-1` that helps in sub array size calculation)\\n\\n**Algorithm**\\nGiven: array = arr , sum = k \\n- We initialize hashmap with (0, -1)\\n- We initialize running mod to 0;\\n- We use the hashmap to store runningModulus and the index at which it\\'s found\\n- At each iteration we compute the mod\\n```\\n\\trunningMod = runningMod + arr[i]\\n\\trunningMod = runningMod % k; // to get the mod\\n```\\n- As we iterate if the hashMap already contains running mod, it means we\\'ve run into this situation\\n ```\\n\\t sumi = K*ConstA + modi\\n\\t sumj = K*ConstB + modj\\n ```\\n - Then at that iteration where we found the running mod in the hashmap we make sure that \\n\\t - the currentIndex - runningMod index in Hashmap > 1 (for 0 case) - If so we return yes\\n\\n**Detailed Algorithm**\\n```\\n initialize hashMap with (0, -1)\\n initialize runningMod = 0\\n for i <- 0 to arr.length\\n    runningMod = runningMod  + arr[i]\\n\\trunningMod = runningMod % k\\n\\tif (hashMap contains runningMod) {\\n\\t\\tif (i - runningMod index in hm > 1) {\\n\\t\\t  return true\\n\\t\\t }\\n\\t} else {\\n\\t\\t// add to hashmap only if it doesn\\'t exist\\n\\t\\thm.add(runningMod, i)\\n\\t}\\n\\t\\n```\\n\\n**Algorithm Run down:**\\n Initial:\\n\\n arr = [5, 23, 2, 6] k=6\\n | mod | index |\\n | :---| :---|\\n  0  | -1\\n\\n**Iteration 1:**\\n currMod = 0+5 % 6 = 5 . 5 not in HM, so we add it\\n | mod | index |\\n | :---| :---|\\n  0  | -1\\n  5  |  0\\n\\n**Iteration 2:**\\n currMod = 5 + 23 % 6 = 4. 4 not in HM, so we add it\\n | mod | index |\\n | :---| :---|\\n  0  | -1\\n  5  |  0\\n  4  |  1\\n\\n **Iteration 3:**\\n currMod = 4 + 2 % 6 = 0\\n - But the hashmap already has 0 mapped to -1\\n - if (currentIndex - hm.get(currMod))  > 1 => as we need our sub array to be of length > 1\\n 2 - (-1) = 3 > 1 => return true\\n\\n**Code**\\n```\\n\\t\\tif (k==0 || nums.length < 2) { return false; }\\n        int currSum = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        hm.put(0, -1); // explained above why we preload this\\n        for (int i=0; i<nums.length; i++) {\\n            currSum = currSum + nums[i];\\n            currSum = currSum % k;\\n            if (hm.containsKey(currSum)) {\\n                if (i - hm.get(currSum) > 1) {\\n                    return true;\\n                }\\n            } else {\\n                hm.put(currSum, i);\\n            }\\n        }\\n        return false;\\n```\\n",
                "solutionTags": [],
                "code": "```\\n sumi = a0+a1+ ... + ai\\n sumj = a0+a1+ ... + aj\\n```\n```\\n sumi = K*ConstA + modi\\n sumj = K*ConstB + modj\\n```\n```\\n 3 + 23 + 2 + 6 = 34\\n 3 + 23 + 2 = 28\\n```\n```\\n 34 = 6*5 + 4\\n 28 = 6*4 + 4\\n```\n```\\n\\trunningMod = runningMod + arr[i]\\n\\trunningMod = runningMod % k; // to get the mod\\n```\n```\\n\\t sumi = K*ConstA + modi\\n\\t sumj = K*ConstB + modj\\n ```\n```\\n initialize hashMap with (0, -1)\\n initialize runningMod = 0\\n for i <- 0 to arr.length\\n    runningMod = runningMod  + arr[i]\\n\\trunningMod = runningMod % k\\n\\tif (hashMap contains runningMod) {\\n\\t\\tif (i - runningMod index in hm > 1) {\\n\\t\\t  return true\\n\\t\\t }\\n\\t} else {\\n\\t\\t// add to hashmap only if it doesn\\'t exist\\n\\t\\thm.add(runningMod, i)\\n\\t}\\n\\t\\n```\n```\\n\\t\\tif (k==0 || nums.length < 2) { return false; }\\n        int currSum = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        hm.put(0, -1); // explained above why we preload this\\n        for (int i=0; i<nums.length; i++) {\\n            currSum = currSum + nums[i];\\n            currSum = currSum % k;\\n            if (hm.containsKey(currSum)) {\\n                if (i - hm.get(currSum) > 1) {\\n                    return true;\\n                }\\n            } else {\\n                hm.put(currSum, i);\\n            }\\n        }\\n        return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744653,
                "title": "c-prefix-sum-hashmap-faster-easy-to-understand",
                "content": "* ***Using Hashmap && Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        // curr_sum will keep track of sum from start till ith\\n\\n        int curr_sum = 0;\\n\\n        // declare a hashmap\\n\\n        unordered_map<int, int> mp;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // update curr_sum\\n\\n            curr_sum += nums[i];\\n\\n            // if multiple of k found \\n\\n            if(curr_sum % k == 0 && i > 0)\\n            {\\n                return true;\\n            }\\n\\n            if(mp.count(curr_sum % k) && (i - mp[curr_sum % k] >= 2))\\n            {\\n                return true;\\n            }\\n\\n            // if curr_sum % k is not present in map then insert it into map\\n\\n            if(mp.count(curr_sum % k) == 0)\\n            {\\n                mp[curr_sum % k] = i;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        // curr_sum will keep track of sum from start till ith\\n\\n        int curr_sum = 0;\\n\\n        // declare a hashmap\\n\\n        unordered_map<int, int> mp;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // update curr_sum\\n\\n            curr_sum += nums[i];\\n\\n            // if multiple of k found \\n\\n            if(curr_sum % k == 0 && i > 0)\\n            {\\n                return true;\\n            }\\n\\n            if(mp.count(curr_sum % k) && (i - mp[curr_sum % k] >= 2))\\n            {\\n                return true;\\n            }\\n\\n            // if curr_sum % k is not present in map then insert it into map\\n\\n            if(mp.count(curr_sum % k) == 0)\\n            {\\n                mp[curr_sum % k] = i;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99575,
                "title": "python-simple-prefix-sum",
                "content": "Since we are interested in quantities of the form A[L] + A[L+1] + ... + A[R], let's use a standard technique of keeping a prefix sum P[i] = sum(A[:i]), so that we can quickly query A[L] + A[L+1] + ... + A[R] = P[R+1] - P[L].\\n\\nNow, we would like to know if P[R+1] - P[L] = 0 (mod k) is solvable with 0 <= L < R < len(A).  This means: For any 0 <= L < len(A), we would like to know if there is some L + 2 <= X < len(A) with P[X] = P[L].  \\n\\nThis can be solved in linear time: at decreasing time i, we've now seen in total all elements in P[i+2:], and we want to know if P[i] is something we've seen before.  If we have, then indeed P[i] = P[j] for j >= i + 2 as desired.\\n\\nOf course, there is the pesky \"mod k\" part.  When k is zero, the modulus should be ignored, otherwise we should consider values of P modulo abs(k).\\n```\\ndef checkSubarraySum(self, A, k):\\n    P = [0] #P[i] = sum(A[:i]), mod abs(k) if k != 0\\n    for x in A:\\n        v = P[-1] + x\\n        if k: v %= abs(k)\\n        P.append(v)\\n    \\n    seen = set()\\n    for i in xrange(len(P) - 3, -1, -1):\\n        seen.add(P[i+2])\\n        if P[i] in seen:\\n            return True\\n    return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef checkSubarraySum(self, A, k):\\n    P = [0] #P[i] = sum(A[:i]), mod abs(k) if k != 0\\n    for x in A:\\n        v = P[-1] + x\\n        if k: v %= abs(k)\\n        P.append(v)\\n    \\n    seen = set()\\n    for i in xrange(len(P) - 3, -1, -1):\\n        seen.add(P[i+2])\\n        if P[i] in seen:\\n            return True\\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 863128,
                "title": "java-clean-code-o-n-best-solution-100-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic boolean checkSubarraySum (int[] nums, int k) {\\n\\t\\t\\n\\t\\tint sum = 0;\\n\\t\\tHashMap<Integer, Integer> map = new HashMap <>();\\n\\t\\tmap.put (0, -1);\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tsum = k == 0 ? sum : sum % k;\\n\\t\\t\\tif (map.containsKey (sum) && i - map.get (sum) != 1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put (sum, map.getOrDefault (sum, i));\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic boolean checkSubarraySum (int[] nums, int k) {\\n\\t\\t\\n\\t\\tint sum = 0;\\n\\t\\tHashMap<Integer, Integer> map = new HashMap <>();\\n\\t\\tmap.put (0, -1);\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tsum = k == 0 ? sum : sum % k;\\n\\t\\t\\tif (map.containsKey (sum) && i - map.get (sum) != 1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put (sum, map.getOrDefault (sum, i));\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744764,
                "title": "full-explanation-intuition-explained-easy-to-understand",
                "content": "**STEP - 1**\\n[23, 2, 6, 4, 7], k = 6\\nCalculate the prefix sum for each index\\npref[i] = sum of all elements till ith index\\n          (subarray from 0 to ith index)\\nPREF => [23, 25, 31, 35, 42]\\n//================================================================\\n**STEP-2**\\nWe want subarray sum to be a multiple of k\\nso lets see how  these pref[i] can get close to it\\n\\n23 => (23 % 6) = 5, 5 denotes that 23 has \"5\" more points than it actually requires \\n                    if we subtract 5 from 23 it will become a multiple of 6\\n                    so let\\'s do it (23 - 5) + 5 => 18 + 5\\n\\n25 => (25 % 6) = 1, 1 signifies that 25 is \"1\" more than a multiple of 6\\n                    if we subtract 1 from 25 it will become a multiple of 6\\n                    so let\\'s do it (25 - 1) + 1 => 24 + 1\\n\\nSimilarly you can do the same for rest of elements of pref array\\nThus now the pref[i] can be taken as this==>\\n**[23    ,   25  ,   31  ,   35  ,   42  ]\\n[18 + 5, 24 + 1, 30 + 1, 30 + 5, 42 + 0]**\\nThis is like\\n[6n + 5, 6n + 1, 6n + 1, 6n + 5, 6n + 0]\\neach element => (a multiple of 6) + remainder\\n\\n//=================================================================\\n**STEP-3**\\nNow for any index \\n\\n**=>i = 1**\\nWe have a subarray from i = 0 to i = 1 having sum = 25\\nNow we want a subarray ending before i = 1 whose sum when subtracted gives a multiple of 6\\n\\nfor j = 0, (24 + 1) - (18 + 5)  //**SUBTRACTING MULTIPLES OF \"6\" WILL ALWAYS GIVE A MULTIPLE OF 6**\\n           (24 - 18) + (1 - 5) XXXXXXXXXXXXX\\n\\n\\n**=>i = 2**\\nSubarray from i = 0 to i = 2, having sum = 31\\nNow we want a subarray ending before i = 2 whose sum when subtracted gives a multiple of 6\\n\\nfor j = 0, (30 + 1) - (18 + 5) \\n           (30 - 18) + (1 - 5)\\n           12 + (-4)\\n           (a multiple of 6) + (-4) XXXXXXXXXXXXXXXXXXX\\n\\nfor j = 1, (30 + 1) - (24 + 1) \\n           (30 - 24) + (1 - 1)\\n           6 + 0   \\n           (a multiple of 6) + (0)  FOUND :) **BUT LEN = 1** so we go to next index\\n\\n\\n\\n**=>i = 3**\\nSubarray from i = 0 to i = 3, having sum = 35\\nNow we want a subarray ending before i = 3 whose sum when subtracted gives a multiple of 6\\n\\nfor j = 0, (30 + 5) - (18 + 5)\\n           (30 - 18) + (5 - 5) \\n           12 + 0\\n           (a multiple of 6) + (0) **GOTCHA!!!!!!!!!!!!!!!!!!!!!!!!!!**\\n//====================================================================\\n**CONCLUSION**\\nNow from the above process\\nObservation\\n=>as subtracting multiples of k will ultimately get a multiple of k\\n  we only need to get rid of \"those extra remainders\" \\n=>we can get rid of remainders only when we subtract two same remainders\\n  and **KABOOOOM YOU GOT YOUR intuition  :))**\\n\\n**Optimization**\\n=>Using map to store remainders rather than going N^2\\n//============================================================\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int prefixSum = 0;\\n        map<int, int>mp; //map to keep a track of remainders\\n        mp[0] = -1;\\n        for (int i = 0; i < n; i++) //at each iteration subarray from (0 to i)\\n        {\\n            prefixSum += nums[i];\\n            int remainder = prefixSum % k;\\n            if (mp.count(remainder)) //if there exist a subarray sum with same remainder\\n            { \\n                int len =  i - mp[remainder];\\n                if (len == 1) continue; //don\\'t update map here as we want farthest remainder\\n                if  (len > 1) return true;\\n            }\\n            mp[remainder] = i; //storing the remainder of  current subarray sum  in map\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int prefixSum = 0;\\n        map<int, int>mp; //map to keep a track of remainders\\n        mp[0] = -1;\\n        for (int i = 0; i < n; i++) //at each iteration subarray from (0 to i)\\n        {\\n            prefixSum += nums[i];\\n            int remainder = prefixSum % k;\\n            if (mp.count(remainder)) //if there exist a subarray sum with same remainder\\n            { \\n                int len =  i - mp[remainder];\\n                if (len == 1) continue; //don\\'t update map here as we want farthest remainder\\n                if  (len > 1) return true;\\n            }\\n            mp[remainder] = i; //storing the remainder of  current subarray sum  in map\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745221,
                "title": "java-single-loop-and-o-k-space-solution",
                "content": "## Java Solution\\n\\n### Prerequisite\\n\\n#### 1. Prefix Sum\\n\\nPrefix sum is to use an **array** to store the sum of all the items in the originial array with number of elements:\\n```java\\n// example\\narr = [1, 2, 3, 4]\\n// then this arrays prefix sum would be \\nprefix_sum_arr = [0, 1, 3, 6, 10]\\n```\\n*or to basically store the sum of all elements as we move forward in array.*\\n\\nNotice the **zero** at the very first index: it denotes the sum of all element **up to** 0th index means all element present before the 0th index element. *This is important as we\\'ll see later.*\\n\\n#### 2. Multiple of k where subarray is greater than 1 in length\\n\\nThis section of the question means that in a given array we **can not** return true as an answer if at any index the number itself is divisible by k.\\n\\n```java\\n// example\\narr = [3, 3, 2, 3, 5, 7] ,  k = 7\\n```\\nHere although the element at 6th position ***is divisible by k***, we still **can not** return true as no sub array of length > 1 is divisible by k\\n```\\n// example :\\nsubarray = [3, 3, 2, 3, 5, 7] -> has sum 23 % 7 != 0, etc. etc.\\n```\\n\\n### Approach\\n\\n#### Naive\\n\\nA naive approach would be to check every possible sub array, get it\\'s sum and if it is divisible by k then return true otherwise false in the end. But it will take O(n<sup>2</sup>) Time which would be not feasible.\\n\\n#### Better\\n\\nA better approach would be to use prefix sum. **But How?**. To answer this we need to understand *How can we obtain the sum of all the elements between indexes **i** & **j** ?*\\n<br>One obvious way is to traverse between i and j and store the sum (*obvious, right?*).\\n```java\\n// an array of ints called arr is in the memory with last index > j.\\nint sum = 0;\\nfor (int idx = i; idx <= j; idx ++)\\n\\tsum += arr[idx];\\n```\\nWell not so fast \\uD83D\\uDE0F, literally. If we had, lets say, thousands of queries for the same range then each time we will have to traverse the same range, again and again although we are getting the same result.\\n<br>\\nSo, what can be done? Let\\'s say if we knew what is the sum of all elements upto **j**, and we also knew what is the sum of all elements upto **i**, then can\\'t we just subtract them to get the result.\\n```\\narr = [3, 3, 2, 3, 5, 7], i = 2, j = 4\\n```\\nthen\\n**sum_i** : \\'prefix sum of elements upto i\\' : 3 + 3 = 6\\n**sum_j** : \\'prefix sum of elements upto j\\' : 3 + 3 + 2 + 3 = 11\\n\\n*then sum of elements b/w i and j will be*\\n**sum_i_j** : sum_j - sum_i -> (3 + 3 + 2 + 3) - (3 + 3) -> 11 - 6 = ***5***\\n*and just like that we used prefix sum to obtain sum of all elements in a subarray without traversing them again and again.*\\n\\nNow as we have to check which subarray will be completly divisible by k, thus\\njust like we find the sum we can find the modulo but there\\'s more...\\n```\\n// we need a subarray between i and j such that\\n(sum_j - sum_i) % k = 0\\n// then\\nsum_j % k - sum_i % k = 0\\n// therefore\\nsum_j % k = sum_i % k   // required result\\n```\\n\\ntherefore, We need to find **two indices i & j** in the nums array (input) such that **mod** of their **prefix_sum by k** is *equal* and their *difference is greater than 1*.\\nSo, we need to store the occurances of all mods in the nums and then check them, well not the case. \\n\\nWe just need to store their **first occurance** because it will have ***greatest distance*** with any of it\\'s counterpart in the remaining array.\\n```\\n[i .....  j .... k]  // index\\n[0 ..... 0 ..... 0] // here (k - i) > (k - j) - > thus we only need the first occurance to check.\\n```\\n\\nIn our code we will use map to store the first occurance of our mod.\\n*some of you might have the idea of using an array indexes as mod value and store index of num as element, though this idea is conceptually correct but it **can not** work for larger values of k (say 10000000).*\\n\\n### Code\\n\\nWe are also using a set to accumulate unique values of mod, because that makes code more resilient *(just a say)*.\\nThe map will have : `key = mod` and `value = index + 1 (number of elements)` .\\n\\n```java\\nclass Solution {\\n\\tpublic boolean checkSubarraySum(int[] nums, int k) {\\n        int sum = 0; // prefix sum of 0 elements.\\n\\n        Set<Integer> set = new HashSet<>();\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n        set.add(sum);\\n        map.put(sum, 0); // it takes 0 elements to have sum % k == 0\\n\\n        for (int i = 0; i < nums.length; i ++) {\\n\\t\\t\\tsum += nums[i]; // increase the sum with next element\\n            int val = sum % k;\\n\\t\\t\\tif (!set.contains(val)) { // if this mod has never came before\\n\\t\\t\\t\\tset.add(val); // store the mod\\n\\t\\t\\t\\tmap.put(val, i + 1); // update the map to store mod and number of elements it took to reach this.\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif ((i + 1) - map.get(val) >= 2) // otherwise check if the distance between previous occurance and this one is greater than 1.\\n\\t\\t\\t\\t\\treturn true; // if so, then return true.\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false; // other wise false.\\n\\t}\\n}\\n```\\n\\n\\uD83D\\uDE0A\\n\\nPS:\\nTried to explain to the best of my abilities, still if there\\'s something I forgot to add or couldn\\'t explain properly then update in comments. If there\\'s a typo, feel free to skip that and read ahead or you can inform in the comments.\\n*Upvotes are appreciated.*",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```java\\n// example\\narr = [1, 2, 3, 4]\\n// then this arrays prefix sum would be \\nprefix_sum_arr = [0, 1, 3, 6, 10]\\n```\n```java\\n// example\\narr = [3, 3, 2, 3, 5, 7] ,  k = 7\\n```\n```\\n// example :\\nsubarray = [3, 3, 2, 3, 5, 7] -> has sum 23 % 7 != 0, etc. etc.\\n```\n```java\\n// an array of ints called arr is in the memory with last index > j.\\nint sum = 0;\\nfor (int idx = i; idx <= j; idx ++)\\n\\tsum += arr[idx];\\n```\n```\\narr = [3, 3, 2, 3, 5, 7], i = 2, j = 4\\n```\n```\\n// we need a subarray between i and j such that\\n(sum_j - sum_i) % k = 0\\n// then\\nsum_j % k - sum_i % k = 0\\n// therefore\\nsum_j % k = sum_i % k   // required result\\n```\n```\\n[i .....  j .... k]  // index\\n[0 ..... 0 ..... 0] // here (k - i) > (k - j) - > thus we only need the first occurance to check.\\n```\n```java\\nclass Solution {\\n\\tpublic boolean checkSubarraySum(int[] nums, int k) {\\n        int sum = 0; // prefix sum of 0 elements.\\n\\n        Set<Integer> set = new HashSet<>();\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n        set.add(sum);\\n        map.put(sum, 0); // it takes 0 elements to have sum % k == 0\\n\\n        for (int i = 0; i < nums.length; i ++) {\\n\\t\\t\\tsum += nums[i]; // increase the sum with next element\\n            int val = sum % k;\\n\\t\\t\\tif (!set.contains(val)) { // if this mod has never came before\\n\\t\\t\\t\\tset.add(val); // store the mod\\n\\t\\t\\t\\tmap.put(val, i + 1); // update the map to store mod and number of elements it took to reach this.\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif ((i + 1) - map.get(val) >= 2) // otherwise check if the distance between previous occurance and this one is greater than 1.\\n\\t\\t\\t\\t\\treturn true; // if so, then return true.\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false; // other wise false.\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329183,
                "title": "easy-javascript-solution-using-set-beats-99-46",
                "content": "```\\nvar checkSubarraySum = function (nums, k) {\\n\\n\\tlet sum = 0\\n\\t\\n\\tlet prefix = 0;\\n\\t\\n\\tconst hash = new Set();\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tsum += nums[i]\\n\\n\\t\\tif (k != 0) sum %= k\\n\\n\\t\\tif(hash.has(sum)) return true\\n\\n\\t\\thash.add(prefix);\\n\\t\\tprefix = sum;\\n\\t}\\n\\treturn false\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar checkSubarraySum = function (nums, k) {\\n\\n\\tlet sum = 0\\n\\t\\n\\tlet prefix = 0;\\n\\t\\n\\tconst hash = new Set();\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tsum += nums[i]\\n\\n\\t\\tif (k != 0) sum %= k\\n\\n\\t\\tif(hash.has(sum)) return true\\n\\n\\t\\thash.add(prefix);\\n\\t\\tprefix = sum;\\n\\t}\\n\\treturn false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586173,
                "title": "python-prefix-sum",
                "content": "# The best way to understand is explaining to yourself. So I did it ;D\\n## Prefix Sum Review\\n\\nWe can solve this question with a prefix sum, an array where each position is the accumulated sum until the current index, but not including it. For example:\\n\\n```python\\narr = [23, 2, 4, 6, 7]\\nprefix_sum = [0, 23, 25, 29, 35, 42]\\n```\\n\\nAnd, with prefix sum, we can also query the contiguous subarray sum between two index. Following the same example:\\n\\n```python\\nprefix_sum = [0, 23, 25, 29, 35, 42]\\n# Sum between element 1 and 3: (2, 4, 6)\\nprefix_sum[3 + 1] - prefix_sum[1] = 35 - 23 = 12\\n```\\n\\n* prefix_sum[3 + 1] because we want to include the element at index 3, so : (23 + 2 + 4 + 6 + 7). \\n* prefix_sum[1] because we want to remove all elements until the element at idx 1: (23)\\n* prefix_sum[4] - prefix_sum[1] = (23 + 2 + 4 + 6 + 7) - 23 = 2 + 4 + 6 + 7\\n\\n## Question\\'s Idea\\nNow we know more about the prefix_sum, lets think what is have a sum as multiple of k. Given the example ```nums = [23, 2, 4, 6, 7], k = 6```, all valid sum is: \\n* ```(2 + 4) = 6```\\n* ```(6) = 6```\\n* ```(23 + 2 + 4 + 6 + 7) = 42```\\nWe also can use a module property, where ```(A + B) % K = (A % K + B % K) % K```. So we can use a module in our accumulated array and, instead of looking for a sum equals to k\\\\*n, we want to find a sum equals to k.\\nSummarizing everything:\\n```python\\narr = [23, 2, 4, 6, 7]\\nprefix_sum = [0, 23, 25, 29, 35, 42]\\nmodule_prefix_sum = [0, 5, 1, 5, 5, 0]\\n```\\n\\nBut wait! Now we don\\'t have a valid prefix_sum, since it isn\\'t crescent. Yes, and that\\'s why we want to look forward **similar values**. For example, we have two ```5```. That means that, in my prefix_sum, I had two values where sum % k = 5. But what are we looking for now? Let\\'s think:\\n```python\\nA + B = n * k # simbolizes that A + B are multiple of k (k * n is equal to that sum)\\n(A + B) % k = (n * k) % k\\n(A % k + B % k) % k = n % k * k % k\\n(A % k + B % k) % k = 0 # (OMG!!)\\n```\\n\\nUsing the previous idea, we know now that we have to find a subarray where ```(nums[i] % k + nums[i+1] % k + ... nums[j] % k) % k == 0```.\\nBut, knowing our prefix_sum, we know that `prefix_sum[j + 1] - prefix_sum[i]` is exactly that sum!!!. So, using everything we already learned, `prefix_sum[j + 1] == prefix_sum[i]`!!!!!!!!!!\\n\\n## Conclusion\\nSo, thanks to the explanation before, we are looking for equal values in our custom prefix_sum (prefix_sum with modules) and i and j cannot be consecutives (if j = i + 1, prefix_sum[i + 1] - prefix_sum[i] means the sum between [i, i], a unique value)\\n\\n### Python 3\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\t\\t# We don\\'t want to do (num % 0,) right? hehe\\n        if not k:\\n\\t\\t# If k is 0 and there is no negative value, the only possible solution is a subarray like [0,0] (e.g. [1,7,3,0,0,1,2,5,0,1])\\n            return any([nums[i] + nums[i - 1] == 0 for i in range(1, len(nums))])\\n        \\n        prefix_sum = [0 for _ in range(len(nums) + 1)]\\n\\n        for idx in range(len(nums)):\\n            prefix_sum[idx + 1] = (prefix_sum[idx] + nums[idx] % k) % k\\n            \\n        memo = {}\\n\\n        for idx, curr_sum in enumerate(prefix_sum):\\n            if curr_sum in memo and idx - memo[curr_sum] > 1:\\n                return True\\n            \\n            if curr_sum not in memo:\\n                memo[curr_sum] = idx\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\narr = [23, 2, 4, 6, 7]\\nprefix_sum = [0, 23, 25, 29, 35, 42]\\n```\n```python\\nprefix_sum = [0, 23, 25, 29, 35, 42]\\n# Sum between element 1 and 3: (2, 4, 6)\\nprefix_sum[3 + 1] - prefix_sum[1] = 35 - 23 = 12\\n```\n```nums = [23, 2, 4, 6, 7], k = 6```\n```(2 + 4) = 6```\n```(6) = 6```\n```(23 + 2 + 4 + 6 + 7) = 42```\n```(A + B) % K = (A % K + B % K) % K```\n```python\\narr = [23, 2, 4, 6, 7]\\nprefix_sum = [0, 23, 25, 29, 35, 42]\\nmodule_prefix_sum = [0, 5, 1, 5, 5, 0]\\n```\n```5```\n```python\\nA + B = n * k # simbolizes that A + B are multiple of k (k * n is equal to that sum)\\n(A + B) % k = (n * k) % k\\n(A % k + B % k) % k = n % k * k % k\\n(A % k + B % k) % k = 0 # (OMG!!)\\n```\n```(nums[i] % k + nums[i+1] % k + ... nums[j] % k) % k == 0```\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\t\\t# We don\\'t want to do (num % 0,) right? hehe\\n        if not k:\\n\\t\\t# If k is 0 and there is no negative value, the only possible solution is a subarray like [0,0] (e.g. [1,7,3,0,0,1,2,5,0,1])\\n            return any([nums[i] + nums[i - 1] == 0 for i in range(1, len(nums))])\\n        \\n        prefix_sum = [0 for _ in range(len(nums) + 1)]\\n\\n        for idx in range(len(nums)):\\n            prefix_sum[idx + 1] = (prefix_sum[idx] + nums[idx] % k) % k\\n            \\n        memo = {}\\n\\n        for idx, curr_sum in enumerate(prefix_sum):\\n            if curr_sum in memo and idx - memo[curr_sum] > 1:\\n                return True\\n            \\n            if curr_sum not in memo:\\n                memo[curr_sum] = idx\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598886,
                "title": "java-2-approaches-detailed-comments-explanations-video",
                "content": "### ***If you find this helpful, Please Upvote !!!***\\n##### 1. Brute force approach (TLE):\\n We check each and every subarray, and see if one of them satisfies the condition.\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for (int i = 0; i < nums.length; ++i) {\\n            int sum = nums[i];\\n            for (int j = i + 1; j < nums.length; ++j) {\\n                sum += nums[j];\\n                if (sum % k == 0) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### 2. Optimal approach (Using hashmap):\\nIf we can find any two subarray of prefix sum having same mod value (or remainder), then their difference must be divisible by k.\\nSo we can use a map to store mod value (or remainder) of each prefix sum in map, with its index.\\nThen check if map contains the same mod value (remainder) with index difference >= 2 when we have new mod value with each iteration.\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if (nums.length < 2) return false;\\n\\t\\t\\n\\t\\t// Map<remainder, index>\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        map.put(0, -1);     // Why? Find the answer below\\n        \\n        int currSum = 0;    // This would be our running sum\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            currSum += nums[i];\\n            int rem = 0;\\n\\n            rem = currSum % k;      // k can\\'t be 0 when we do a number % k\\n\\n            if (map.containsKey(rem)) {         // if that remainder already exists\\n                if (i - map.get(rem) > 1) {     // Length/difference checking Step\\n                    return true;                // and if the diff between the indices of the same remainder > 1, we get our answer\\n                }\\n            }\\n\\n            map.putIfAbsent(rem, i);            // else we put that remainder along with its index in the map\\n\\n            // we don\\'t do map.put(rem, i) because it\\'ll overwrite the old index (value) for the same rem (key).\\n            // using a \\'putIfAbsent\\' will create a new unique map which we want.\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n\\n// Answer to why putting {0 : -1} in the map :\\n// we need to put a {0 : -1} in the map because what if at some point we get a remainder as 0?\\n// if we get a number divisible by k right at 0-th index, we won\\'t return true because \\'0 - (-1) is not > 1\\' (Length/difference checking Step)\\n// and if we get a remainder as 0 later in the array we will be able to return true because \\'x - (-1) > 0\\' when x >= 1. (where x is a latter index).\\n// As the logic suggests, keep going until you find the same remainder so we will need a 0 also for a 0 remainder which might come later.\\n\\n\\n// TC: O(n), SC: O(n)\\n```\\n[Here is a nice video you can watch to understand the solution](https://www.youtube.com/watch?v=OKcrLfR-8mE)\\n\\n**A dry run might prove to be beneficial if you wish to understand it properly.**",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for (int i = 0; i < nums.length; ++i) {\\n            int sum = nums[i];\\n            for (int j = i + 1; j < nums.length; ++j) {\\n                sum += nums[j];\\n                if (sum % k == 0) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if (nums.length < 2) return false;\\n\\t\\t\\n\\t\\t// Map<remainder, index>\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        map.put(0, -1);     // Why? Find the answer below\\n        \\n        int currSum = 0;    // This would be our running sum\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            currSum += nums[i];\\n            int rem = 0;\\n\\n            rem = currSum % k;      // k can\\'t be 0 when we do a number % k\\n\\n            if (map.containsKey(rem)) {         // if that remainder already exists\\n                if (i - map.get(rem) > 1) {     // Length/difference checking Step\\n                    return true;                // and if the diff between the indices of the same remainder > 1, we get our answer\\n                }\\n            }\\n\\n            map.putIfAbsent(rem, i);            // else we put that remainder along with its index in the map\\n\\n            // we don\\'t do map.put(rem, i) because it\\'ll overwrite the old index (value) for the same rem (key).\\n            // using a \\'putIfAbsent\\' will create a new unique map which we want.\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n\\n// Answer to why putting {0 : -1} in the map :\\n// we need to put a {0 : -1} in the map because what if at some point we get a remainder as 0?\\n// if we get a number divisible by k right at 0-th index, we won\\'t return true because \\'0 - (-1) is not > 1\\' (Length/difference checking Step)\\n// and if we get a remainder as 0 later in the array we will be able to return true because \\'x - (-1) > 0\\' when x >= 1. (where x is a latter index).\\n// As the logic suggests, keep going until you find the same remainder so we will need a 0 also for a 0 remainder which might come later.\\n\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929464,
                "title": "greatly-explained-hashmap-prefixsum-in-python-time-o-n-space-o-min-n-k-easy-to-understand",
                "content": "The optimal solutions for this kind of problems are always **Hashmap + Prefix Sum**!\\n\\nNote that if we first generate the whole prefix sum list of the input array, then we could get all subarray sum in O(n^2), which is good but not optimal.\\nThe idea comes: Also take Hashmap into use with Prefix Sum, reduce time to O(n).\\n\\nWe should **initiate a Hashmap**\\n**key** is ***prefix sum % k***, \\n**value** is ***index of the current prefix sum***.\\n\\nWhen we reach some position, for example i, whose prefix sum % k is already in the Hashmap, and Hashmap[prefix sum % k] = j, then it means that **nums[j+1:i+1] % k == 0**, which is what we want! (We need to check i - j >= 2, as given)\\n\\n**Time:** O(n)\\n**Space:** O(min(n, k))\\nThere could be at most k keys in the Hashmap.\\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        mapping = {0: -1}\\n        running_sum = 0\\n        \\n        for i, num in enumerate(nums):\\n            \\n            running_sum = (running_sum + num) % k\\n            \\n            if running_sum not in mapping:\\n                mapping[running_sum] = i\\n            else:\\n                if i - mapping[running_sum] >= 2:\\n                    return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        mapping = {0: -1}\\n        running_sum = 0\\n        \\n        for i, num in enumerate(nums):\\n            \\n            running_sum = (running_sum + num) % k\\n            \\n            if running_sum not in mapping:\\n                mapping[running_sum] = i\\n            else:\\n                if i - mapping[running_sum] >= 2:\\n                    return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377269,
                "title": "easy-peasy-python-comments-iterative-solution",
                "content": "\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        mp = {0: -1}\\n        prefix_sum = 0\\n        for i, num in enumerate(nums):\\n            prefix_sum += num\\n            if k != 0:\\n                prefix_sum = prefix_sum % k\\n            if prefix_sum in mp:\\n                # I know that sum between mp[prefix_sum] + 1 and i is multiple of K, so I don\\'t have to include mp[prefix_sum]\\n                if i - mp[prefix_sum] > 1:\\n                    return True\\n            else:\\n                # if prefix_sum doesn\\'t exists, then add its index, otherwise don\\'t update it, i would always prefer to keep the\\n                # oldest index, so that I can get length of atleast 2\\n                mp[prefix_sum] = i\\n            \\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        mp = {0: -1}\\n        prefix_sum = 0\\n        for i, num in enumerate(nums):\\n            prefix_sum += num\\n            if k != 0:\\n                prefix_sum = prefix_sum % k\\n            if prefix_sum in mp:\\n                # I know that sum between mp[prefix_sum] + 1 and i is multiple of K, so I don\\'t have to include mp[prefix_sum]\\n                if i - mp[prefix_sum] > 1:\\n                    return True\\n            else:\\n                # if prefix_sum doesn\\'t exists, then add its index, otherwise don\\'t update it, i would always prefer to keep the\\n                # oldest index, so that I can get length of atleast 2\\n                mp[prefix_sum] = i\\n            \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 295690,
                "title": "c-o-n-two-pass-beat-98-54-with-picture-explanation",
                "content": "thanks @hqztrue for correcting my for the time complexity. After that, I update a O(N) method and also keep original one.\\n# intuition\\nmaintain a array, array[i] = sum from 0-th to i-th elements. it\\'s like :\\n![image](https://assets.leetcode.com/users/ken771209/image_1558323482.png)\\n\\nbut if we maintain the array[i] = sum%k, like :\\n![image](https://assets.leetcode.com/users/ken771209/image_1558323628.png)\\n\\n```\\nfor [23, 2, 4, 6, 7] , k = 6\\nsum array = [23,25,29,35,42]\\nmod array = [5,1,5,5,0]\\ntrue  : if for any mod_array[i], we can find a mod_array[j] == mod_array[i] , which 0<= j <= i-2\\nfalse : if we cannot.\\n```\\n**O(N) method by hash table**.\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return false;\\n        else if(k == 0){\\n            for(int i = 0 ; i < nums.size()-1 ; i++)\\n                if(nums[i] == 0 && nums[i+1] == 0)\\n                    return true;\\n\\t\\t\\treturn false;\\n        }\\n        else if(k == 1) return true;\\n        vector<int> sum_map(nums.size()+1,0);\\n        unordered_map<int,int> history; // key:sum value:first position\\n        for(int i = 0 ; i < nums.size() ;i++)\\n            sum_map[i+1] = (sum_map[i]+nums[i])%k;\\n        history[sum_map[0]] = 1;\\n        history[sum_map[1]] = (sum_map[1]!=sum_map[0])+1;\\n\\t\\t/* using a hash table here to track if we have the target at least 2 consecutive elements */\\n        for(int i = 2 ; i < sum_map.size() ;i++){ \\n            if(history[sum_map[i]] == 0)\\n                history[sum_map[i]] = i+1;\\n            else if(i-history[sum_map[i]] > 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**O(N^2) method**, thanks @hqztrue for \"searching a vector take O(N)\"\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return false;\\n        else if(k == 0){\\n            for(int i = 0 ; i < nums.size()-1 ; i++)\\n                if(nums[i] == 0 && nums[i+1] == 0)\\n                    return true;\\n            return false;\\n        }\\n        else if(k == 1) return true;\\n        vector<int> sum_map(nums.size()+1,0);\\n        for(int i = 0 ; i < nums.size() ;i++)\\n            sum_map[i+1] = (sum_map[i]+nums[i])%k;\\n\\t\\t/* searching the index which is prior to current index, to see if any element can meet the requirement */\\n        for(int i = 2 ; i < sum_map.size() ;i++){\\n            if(find(sum_map.begin(),sum_map.begin()+i-1,sum_map[i]) != sum_map.begin()+i-1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfor [23, 2, 4, 6, 7] , k = 6\\nsum array = [23,25,29,35,42]\\nmod array = [5,1,5,5,0]\\ntrue  : if for any mod_array[i], we can find a mod_array[j] == mod_array[i] , which 0<= j <= i-2\\nfalse : if we cannot.\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return false;\\n        else if(k == 0){\\n            for(int i = 0 ; i < nums.size()-1 ; i++)\\n                if(nums[i] == 0 && nums[i+1] == 0)\\n                    return true;\\n\\t\\t\\treturn false;\\n        }\\n        else if(k == 1) return true;\\n        vector<int> sum_map(nums.size()+1,0);\\n        unordered_map<int,int> history; // key:sum value:first position\\n        for(int i = 0 ; i < nums.size() ;i++)\\n            sum_map[i+1] = (sum_map[i]+nums[i])%k;\\n        history[sum_map[0]] = 1;\\n        history[sum_map[1]] = (sum_map[1]!=sum_map[0])+1;\\n\\t\\t/* using a hash table here to track if we have the target at least 2 consecutive elements */\\n        for(int i = 2 ; i < sum_map.size() ;i++){ \\n            if(history[sum_map[i]] == 0)\\n                history[sum_map[i]] = i+1;\\n            else if(i-history[sum_map[i]] > 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return false;\\n        else if(k == 0){\\n            for(int i = 0 ; i < nums.size()-1 ; i++)\\n                if(nums[i] == 0 && nums[i+1] == 0)\\n                    return true;\\n            return false;\\n        }\\n        else if(k == 1) return true;\\n        vector<int> sum_map(nums.size()+1,0);\\n        for(int i = 0 ; i < nums.size() ;i++)\\n            sum_map[i+1] = (sum_map[i]+nums[i])%k;\\n\\t\\t/* searching the index which is prior to current index, to see if any element can meet the requirement */\\n        for(int i = 2 ; i < sum_map.size() ;i++){\\n            if(find(sum_map.begin(),sum_map.begin()+i-1,sum_map[i]) != sum_map.begin()+i-1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744428,
                "title": "python-beats-97-26-fully-explained",
                "content": "**Fast Python Solution Using Hashmap; Time: O(N), Space: O(K)**\\n```\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\tremainders = {0: -1} # we can get a remainder of 0 with a subarray containing no elements\\n\\tcurr_rem = 0 # current remainder\\n\\tfor i,num in enumerate(nums):\\n\\t\\tcurr_rem = (curr_rem+num)%k # update current remainder\\n\\t\\tif curr_rem in remainders: # if we have seen this remainder\\n\\t\\t\\tif remainders[curr_rem] < i-1: # if we have seen this remainder before but it was not at the previous prefix (since we need our subarray to have length 2)\\n\\t\\t\\t\\treturn True\\n\\t\\telse: # if we haven\\'t seen the remainder\\n\\t\\t\\tremainders[curr_rem] = i # add this remainder and the index it is at\\n\\treturn False\\n```\\n\\n**Explanation**\\nThe basic idea of this solution is to keep track of the current remainder of the sum of elements in ```nums``` up to some index ```i``` when divided by ```k``` --> ```curr_rem```. We store all previous such remainders as keys in a dictionary, ```remainders```, with their values corresponding the the index at which we had that remainder. If the current remainder has been seen before, and it was at an index lower than ```i-1``` then that means that the sum of the subarray containing all elements from ```remainders[curr_rem]+1``` to ```i``` (inclusive) will be a multiple of ```k``` because the difference of the remainder before and after going through that subarray is the same. Since going through that subarray did not modify our ```curr_rem```, we know that it must sum to a multiple of k. The reason we need to check that ```remainders[curr_rem] < i-1``` is that we will encounter a case where ```remainders[curr_rem] == i-1``` if ```nums[i] == 0```. However, the subarray of elements from ```remainders[curr_rem]+1``` to ```i``` will therefore be from ```i``` to ```i```, meaning that it just represents one element, the ```nums[i] == 0```. We need subarrays of length 2 or more, so we have to check this condition too. If we have not seen the ```curr_rem``` before, then we add it to ```remainders```. We only add it if we ahve not seen ```curr_rem``` before since we want ```remainders[curr_rem]``` to point to the earliest occurrence of the remainder. The reason we start with ```remainders = {0: -1}``` is that we may encounter a time when ```curr_rem = 0``` and if ```i > 0``` then this means we have found a subarray such that ```sum(nums[:i+1]) % k == 0``` --> the first ```i``` elements form a subarray which satisfies our condition, so we want to be able to check that ```0``` already exists in ```remainders``` to catch this case.\\n\\nThis is a lot of text, so it may be easier to see with examples:\\n\\n**Examples**\\n```\\nk = 6\\nnums = [23,2,4,6,7]\\nprefix sum array =  [23, 25, 29, 35, 42]\\nprefix mod array = [5, 1, 5, 5, 0]\\n```\\nWe can use the prefix mod array to figure out all subarrays which satisfy our condition. ```5``` is present at the 0th index of our prefix mod array, which would mean ```remainders[5] = 0``` in our solution. That means that, when we get to index 2 and find that we have already seen a remainder of ```5```, we then check that the two ```5```s are not directly next to each other (```remainders[5] < i-1```) and since they aren\\'t we know that the subarray is possible (the subarray is ```[2,4]``` since it goes from ```remainders[5]+1``` to ```i```, which is ```1``` to ```2```). \\nEven if the second ```5``` didn\\'t exist, we would also be able to make the subarray from ```[2,4,6]```, since the first ```5``` and the last ```5``` are not adjacent, but we could NOT make the subarray from ```[6]``` since the last two ```5```s are directly next to each other. We could also use the full subarray, ```[23,2,4,6,7]```, since the last value in the mod array is ```0```.\\n\\n```\\nk = 6\\nnums = [23,2,6,4,7]\\nprefix sum array =  [23, 25, 31, 35, 42]\\nprefix mod array = [5, 1, 1, 5, 0]\\n```\\nThe subarray is comprised of the elements between the two ```5```s, so it is ```[2,6,4]```. We could also use the full subarray since the last mod value is ```0```, so ```[23,2,6,4,7]``` is a valid subarray as well.\\n\\n```\\nk = 13\\nnums = [23,2,6,4,7]\\nprefix sum array = [23, 25, 31, 35, 42]\\nprefix mod array = [10, 12, 5, 9, 3]\\n```\\nOur prefix mod array has no duplicate values and no zeroes so there is no way for us to create a subarray satisfying our condition.\\n\\nIf the explanation above and examples have still left you with some questions about the solution, please ask and I will try to explain!\\n\\n**Complexity Analysis**\\nSince we need to look at every element in ```nums``` once in the worst case (when no subarray exists that meets our condition), the time complexity is ```O(N)``` where ```N == len(nums)```.\\nThe only possible remainders are from ```0``` to ```K-1```, so the maximum size of ```remainders``` scales with ```K```, giving our solution a space complexity of ```O(K)```.\\n\\n**Thanks for Reading!**\\nPlease consider upvoting the post if it helped you! If you have any questions, comments, or concerns, please leave them below and I will get to them as soon as possible.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\tremainders = {0: -1} # we can get a remainder of 0 with a subarray containing no elements\\n\\tcurr_rem = 0 # current remainder\\n\\tfor i,num in enumerate(nums):\\n\\t\\tcurr_rem = (curr_rem+num)%k # update current remainder\\n\\t\\tif curr_rem in remainders: # if we have seen this remainder\\n\\t\\t\\tif remainders[curr_rem] < i-1: # if we have seen this remainder before but it was not at the previous prefix (since we need our subarray to have length 2)\\n\\t\\t\\t\\treturn True\\n\\t\\telse: # if we haven\\'t seen the remainder\\n\\t\\t\\tremainders[curr_rem] = i # add this remainder and the index it is at\\n\\treturn False\\n```\n```nums```\n```i```\n```k```\n```curr_rem```\n```remainders```\n```i-1```\n```remainders[curr_rem]+1```\n```i```\n```k```\n```curr_rem```\n```remainders[curr_rem] < i-1```\n```remainders[curr_rem] == i-1```\n```nums[i] == 0```\n```remainders[curr_rem]+1```\n```i```\n```i```\n```i```\n```nums[i] == 0```\n```curr_rem```\n```remainders```\n```curr_rem```\n```remainders[curr_rem]```\n```remainders = {0: -1}```\n```curr_rem = 0```\n```i > 0```\n```sum(nums[:i+1]) % k == 0```\n```i```\n```0```\n```remainders```\n```\\nk = 6\\nnums = [23,2,4,6,7]\\nprefix sum array =  [23, 25, 29, 35, 42]\\nprefix mod array = [5, 1, 5, 5, 0]\\n```\n```5```\n```remainders[5] = 0```\n```5```\n```5```\n```remainders[5] < i-1```\n```[2,4]```\n```remainders[5]+1```\n```i```\n```1```\n```2```\n```5```\n```[2,4,6]```\n```5```\n```5```\n```[6]```\n```5```\n```[23,2,4,6,7]```\n```0```\n```\\nk = 6\\nnums = [23,2,6,4,7]\\nprefix sum array =  [23, 25, 31, 35, 42]\\nprefix mod array = [5, 1, 1, 5, 0]\\n```\n```5```\n```[2,6,4]```\n```0```\n```[23,2,6,4,7]```\n```\\nk = 13\\nnums = [23,2,6,4,7]\\nprefix sum array = [23, 25, 31, 35, 42]\\nprefix mod array = [10, 12, 5, 9, 3]\\n```\n```nums```\n```O(N)```\n```N == len(nums)```\n```0```\n```K-1```\n```remainders```\n```K```\n```O(K)```",
                "codeTag": "Python3"
            },
            {
                "id": 2099747,
                "title": "c-easy-solution-with-explanation",
                "content": "**C++ Code:**\\n\\n**Approach:**\\n\\nyaha apan hash map mein remainder store kr rahe hain index ke sath , jab bhi kabhi same remainder wapas aayega yani uss index aur abhi current index ke bich ka subarray ka sum definitely divisible hoga \"k\" se toh apan true return kr denge aur agar nhi mila toh last mein false return hoga .\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n       \\n       unordered_map<int,int>m;\\n        m[0]=-1;\\n         int sum = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum +=nums[i];\\n            if(m.find(sum%k)!=m.end())\\n            {\\n                if(i-m[sum%k]>=2)\\n                    return true;\\n            }\\n            else\\n            m[sum%k] = i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n       \\n       unordered_map<int,int>m;\\n        m[0]=-1;\\n         int sum = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum +=nums[i];\\n            if(m.find(sum%k)!=m.end())\\n            {\\n                if(i-m[sum%k]>=2)\\n                    return true;\\n            }\\n            else\\n            m[sum%k] = i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744299,
                "title": "python-c-java-rust-linear-time-prefix-sums-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs calculation of prefix sums. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**. \\n\\n**Comment**. For linear-time performance, we compute prefix sums (mod k) and wait for the same value to occur twice. On the second occurrence, if the difference between the corresponding indices satisfies the condition (i.e., >= 2) then the requested subarray lies between these indicies (and we return true). Please note the special case of, e.g., *nums=[2,1,2]* and *k=5*, i.e., when nums sum up to k.  Zero is the only remainder that is allowed to occur only once, thus, we insert it in the map with index  -1 (this will not break any logic, however, e.g., -2 will). \\n\\n<iframe src=\"https://leetcode.com/playground/JWfSBJH5/shared\" frameBorder=\"0\" width=\"800\" height=\"475\"></iframe>",
                "solutionTags": [],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs calculation of prefix sums. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**. \\n\\n**Comment**. For linear-time performance, we compute prefix sums (mod k) and wait for the same value to occur twice. On the second occurrence, if the difference between the corresponding indices satisfies the condition (i.e., >= 2) then the requested subarray lies between these indicies (and we return true). Please note the special case of, e.g., *nums=[2,1,2]* and *k=5*, i.e., when nums sum up to k.  Zero is the only remainder that is allowed to occur only once, thus, we insert it in the map with index  -1 (this will not break any logic, however, e.g., -2 will). \\n\\n<iframe src=\"https://leetcode.com/playground/JWfSBJH5/shared\" frameBorder=\"0\" width=\"800\" height=\"475\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1479244,
                "title": "simple-python-solution-o-n-time-with-comments",
                "content": "https://github.com/paulonteri/data-structures-and-algorithms\\n```\\n\"\"\"\\nsimilar to Maximum Sum Subarray of Size K https://www.notion.so/paulonteri/Sliding-Window-f6685a15f97a4ca2bb40111e2b264fb2#891e1ba6076b4454a9175a553393f295\\n\\n    [1, 2, 3, 4,]  <= array\\n    [1, 3, 6, 10] <= cummulative sums\\n    10 -1 =  19  = 2+3+4\\n    6 -1  =   5  = 2+3\\n\\nif we store the cumulative sum for every point (idx) in the array,\\n    if (sum2-sum1) % k = 0\\n    then the numbers between sum2-sum1 add up to a multiple of k\\n\\nif you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution.\\n(sum2-sum1) % k = 0\\nsum2%k - sum1%k = 0\\nsum2%k = sum1%k\\n\\n\"\"\"\\n\\n\\nclass Solution:\\n    def checkSubarraySum(self, nums, k):\\n        if len(nums) < 2:\\n            return False\\n\\n        # 0: -1 is for edge case that current sum mod k == 0\\n        # for when the current running sum is cleanly divisible by k\\n        # e.g: nums = [4, 2], k = 3\\n        sums = {0: -1}  # 0\\n        cumulative_sum = 0\\n        for idx, num in enumerate(nums):\\n            cumulative_sum += num\\n            remainder = cumulative_sum % k\\n\\n            # if current_sum mod k is in dict and index idx - sums[remainder] > 1, we got the Subarray!\\n            # we use 2 not 1 because the element at sums[remainder] is not in the subarray we are talking about\\n            if remainder in sums and idx - sums[remainder] >= 2:\\n                return True\\n\\n            # if current sum mod k not in dict, store it so as to ensure the further values stay\\n            if remainder not in sums:\\n                sums[remainder] = idx\\n\\n# space can be easily improved to O(k) be only storing k elements in sums\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nsimilar to Maximum Sum Subarray of Size K https://www.notion.so/paulonteri/Sliding-Window-f6685a15f97a4ca2bb40111e2b264fb2#891e1ba6076b4454a9175a553393f295\\n\\n    [1, 2, 3, 4,]  <= array\\n    [1, 3, 6, 10] <= cummulative sums\\n    10 -1 =  19  = 2+3+4\\n    6 -1  =   5  = 2+3\\n\\nif we store the cumulative sum for every point (idx) in the array,\\n    if (sum2-sum1) % k = 0\\n    then the numbers between sum2-sum1 add up to a multiple of k\\n\\nif you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution.\\n(sum2-sum1) % k = 0\\nsum2%k - sum1%k = 0\\nsum2%k = sum1%k\\n\\n\"\"\"\\n\\n\\nclass Solution:\\n    def checkSubarraySum(self, nums, k):\\n        if len(nums) < 2:\\n            return False\\n\\n        # 0: -1 is for edge case that current sum mod k == 0\\n        # for when the current running sum is cleanly divisible by k\\n        # e.g: nums = [4, 2], k = 3\\n        sums = {0: -1}  # 0\\n        cumulative_sum = 0\\n        for idx, num in enumerate(nums):\\n            cumulative_sum += num\\n            remainder = cumulative_sum % k\\n\\n            # if current_sum mod k is in dict and index idx - sums[remainder] > 1, we got the Subarray!\\n            # we use 2 not 1 because the element at sums[remainder] is not in the subarray we are talking about\\n            if remainder in sums and idx - sums[remainder] >= 2:\\n                return True\\n\\n            # if current sum mod k not in dict, store it so as to ensure the further values stay\\n            if remainder not in sums:\\n                sums[remainder] = idx\\n\\n# space can be easily improved to O(k) be only storing k elements in sums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945753,
                "title": "simple-and-efficient-solution-using-prefix-and-map-o-n-logn-c",
                "content": "If we use the modulus operator with any number, then it returns the remainder obtained by dividing the number. Suppose if the prefix sum is 23 and 23%6 = 5. Now, if we add 2 and 4, then the prefix sum would become 29 and 29%6 is again 5. So, the sub array added to the prefix sum has a sum 6 or a multiple of 6 (because 23+12 = 35 and 35%6 = 5).\\n\\nIn the hashmap, we are going to insert the remainder obtained by dividing perfix sum and k so that we can check if the same remainder appeared earlier or not. Finally, we need to take care of the size of the sub array which can be found by subtracting \\'i\\' from the map entry for that remainder.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int sum=0, t;\\n        mp[0] =-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if(mp.find(sum%k)!=mp.end())\\n            {\\n                if(i-mp[sum%k]>=2)\\n                    return true;\\n            }\\n            else\\n                mp[sum%k]=i;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int sum=0, t;\\n        mp[0] =-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if(mp.find(sum%k)!=mp.end())\\n            {\\n                if(i-mp[sum%k]>=2)\\n                    return true;\\n            }\\n            else\\n                mp[sum%k]=i;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621287,
                "title": "detailed-explanation-of-the-math",
                "content": "After spending hours, I finally understand the solution, so I hope this helps.\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # keep a cumulative mod of all nums\\n        # if same mod appears twice, \\n        # by definition a multiple of k must be between them\\n        # let\\'s say num = 2, k = 5, mod is 2 % 5 = 2\\n        # to get 2 again, we must have added 5 to 2,\\n\\t\\t#      \\u2193 sums to 5\\n        # 2, (2, 3), 2\\n        # mods: 2, 4, 2, 4\\n        #             ^ we got 2 again\\n\\t\\t\\n        # answer needs at least 2 elements\\' sum\\n        if len(nums) < 2:\\n            return False\\n\\n        # 0: -1 for the edge case of [0, 0], more explanation below\\n        seen_mods = {0:-1}\\n        mod = 0\\n        for i, num in enumerate(nums):\\n            mod = (num + mod) % k\\n            # if mod is 0, it means sum of previous nums were divisible by k\\n            # however, the number can\\'t be 0 itself since 0 mod any number will be 0\\n            # it also can\\'t be the first number (problem specifies at least 2 nums)\\n            if mod == 0 and num != 0 and i > 0:\\n                return True\\n            elif mod in seen_mods:\\n                # if we\\'ve seen this mod, then k have been added since, as explained above\\n                # distance needs to be at least 2 for the case of a 0\\n                # for example, [2, 0], k = 4\\n                # 2 % 4 is 2, (2 + 0) % 4 is 2 again, the program would be tricked, so we require a distance of 2\\n\\t\\t\\t\\tif i - seen_mods[mod] >= 2:\\n                    return True\\n                # in the case of [0, 0], first 0\\'s index will be stored, second time when we check the distance it would be 1\\n\\t\\t\\t\\t# that\\'s why we initialized seen_mods with {0:-1}\\n                # on second zero, distance will be 2 as opposed to 1, and program returns True\\n            else:\\n                seen_mods[mod] = i\\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # keep a cumulative mod of all nums\\n        # if same mod appears twice, \\n        # by definition a multiple of k must be between them\\n        # let\\'s say num = 2, k = 5, mod is 2 % 5 = 2\\n        # to get 2 again, we must have added 5 to 2,\\n\\t\\t#      \\u2193 sums to 5\\n        # 2, (2, 3), 2\\n        # mods: 2, 4, 2, 4\\n        #             ^ we got 2 again\\n\\t\\t\\n        # answer needs at least 2 elements\\' sum\\n        if len(nums) < 2:\\n            return False\\n\\n        # 0: -1 for the edge case of [0, 0], more explanation below\\n        seen_mods = {0:-1}\\n        mod = 0\\n        for i, num in enumerate(nums):\\n            mod = (num + mod) % k\\n            # if mod is 0, it means sum of previous nums were divisible by k\\n            # however, the number can\\'t be 0 itself since 0 mod any number will be 0\\n            # it also can\\'t be the first number (problem specifies at least 2 nums)\\n            if mod == 0 and num != 0 and i > 0:\\n                return True\\n            elif mod in seen_mods:\\n                # if we\\'ve seen this mod, then k have been added since, as explained above\\n                # distance needs to be at least 2 for the case of a 0\\n                # for example, [2, 0], k = 4\\n                # 2 % 4 is 2, (2 + 0) % 4 is 2 again, the program would be tricked, so we require a distance of 2\\n\\t\\t\\t\\tif i - seen_mods[mod] >= 2:\\n                    return True\\n                # in the case of [0, 0], first 0\\'s index will be stored, second time when we check the distance it would be 1\\n\\t\\t\\t\\t# that\\'s why we initialized seen_mods with {0:-1}\\n                # on second zero, distance will be 2 as opposed to 1, and program returns True\\n            else:\\n                seen_mods[mod] = i\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143224,
                "title": "c-three-solutions-easy-to-understand",
                "content": "**Brute Force**: Time complexity: **O(n3)** and Space complexity: **O(1)**\\n**Basic Idea**: Consider every possible subarray of size greater than or equal to 2, find out its sum by iterating over the elements of the subarray, and then we check if the sum obtained is an integer multiple of the given k.\\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        for (int start = 0; start < nums.Length-1; start++)\\n        {\\n            for (int end = start + 1; end < nums.Length; end++)\\n            {\\n                int sum = 0;\\n                for (int i = start; i <= end; i++)\\n                    sum += nums[i];\\n\\n                if (sum == k || (k != 0 && sum % k == 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**First Level Optimization**: Time complexity: **O(n2)** and Space complexity: **O(n)**\\n**Basic idea**: Make use of an array runningSum that stores the runningSum of the elements of the array, such that runningSum[i] stores the sum of the elements upto the ith element of the array. To determine the sum of elements from the ith index to the jth index, we use: runningSum[j]\\u2212runningSum[i]+nums[i]. \\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        int[] runningSum = new int[nums.Length];\\n        runningSum[0] = nums[0];\\n        for (int i = 1; i < nums.Length; i++)\\n            runningSum[i] = runningSum[i - 1] + nums[i];\\n\\n        for (int start = 0; start < nums.Length - 1; start++)\\n        {\\n            for (int end = start + 1; end < nums.Length; end++)\\n            {\\n                int subArraySum = runningSum[end] - runningSum[start] + nums[start];\\n                if (subArraySum == k || (k != 0 && subArraySum % k == 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Final Optimization**: Time complexity: **O(n)** and Space complexity: **O(n)**\\n**Basic idea**: Use Dictionary/HashMap\\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        dict[0] = -1;\\n        int runningSum = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            runningSum += nums[i];\\n            if (k != 0)\\n                runningSum = runningSum % k;\\n            if (dict.ContainsKey(runningSum))\\n            {\\n                if (i - dict[runningSum] > 1)\\n                    return true;\\n            }\\n            else\\n                dict[runningSum] = i;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        for (int start = 0; start < nums.Length-1; start++)\\n        {\\n            for (int end = start + 1; end < nums.Length; end++)\\n            {\\n                int sum = 0;\\n                for (int i = start; i <= end; i++)\\n                    sum += nums[i];\\n\\n                if (sum == k || (k != 0 && sum % k == 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        int[] runningSum = new int[nums.Length];\\n        runningSum[0] = nums[0];\\n        for (int i = 1; i < nums.Length; i++)\\n            runningSum[i] = runningSum[i - 1] + nums[i];\\n\\n        for (int start = 0; start < nums.Length - 1; start++)\\n        {\\n            for (int end = start + 1; end < nums.Length; end++)\\n            {\\n                int subArraySum = runningSum[end] - runningSum[start] + nums[start];\\n                if (subArraySum == k || (k != 0 && subArraySum % k == 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        dict[0] = -1;\\n        int runningSum = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            runningSum += nums[i];\\n            if (k != 0)\\n                runningSum = runningSum % k;\\n            if (dict.ContainsKey(runningSum))\\n            {\\n                if (i - dict[runningSum] > 1)\\n                    return true;\\n            }\\n            else\\n                dict[runningSum] = i;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333834,
                "title": "js-o-n-3-o-n-2-o-n-solutions",
                "content": "**Solution 1: Brute Force**\\nApproach: For every element, getting the sum of each subarray with length >= 2 and returning true if it is a multiple of k.\\n\\n```\\n// TC = O(n^3); SC = O(1)\\nvar checkSubarraySum = function(nums, k) {\\n    const n = nums.length;\\n    if(n < 2) {\\n        return false;\\n    }\\n    let sum = 0;\\n    for(let i = 0; i < n; ++i) {\\n        for(let j = i + 2; j <= n; ++j) {\\n            for(let l = i; l < j; ++l) {\\n                sum += nums[l];\\n            }\\n            if(sum % k === 0) {\\n                return true;\\n            }\\n            sum = 0;\\n        }\\n    }\\n    return false;\\n};\\n```\\nTime Complexity = O(n^3)\\nSpace Complexity = O(1)\\nThis will give TLE for the last test case.\\n\\n----\\n\\n**Solution 2: Dynamic Programming and Prefix Sum**\\nApproach:\\n- Creating a prefix sum array, if we get a sum which is multiple of k, return true. In each iteration, sum at dp[i] will be the sum obtained from [0, i]. If we don\\'t get a multiple sum, continue -\\n- Starting from index 2, subtract the sum at 2 places earlier (subrray length should be at least 2) and keep on checking the subarray sum, such that at dp[j], the sum will be obtained from [i - 1, j]. At each iteration, we subtract the sum and keep on checking for the next subarray starting from ith index. If the sum is a multiple of k, return true.\\n- Finally if no match is found, return false.\\n- Example:\\n  - In this we return true  at 21, which is a multiple of k = 7.\\n  - The subarray will be within index range [2,5] = 6 + 0 + 9 + 6 = 21\\n```\\nk = 7, [1,3,6,0,9,6,9]\\n1    3    6    0    9    6    9\\n1    4   10   10   19   25   34\\n     3    9    9   18   24   33\\n\\t\\t  6    6   15   21\\n```\\n\\n```\\n// TC = O(n^2); SC = O(n)\\nvar checkSubarraySum = function(nums, k) {\\n    const n = nums.length;\\n    if(n < 2) {\\n        return false;\\n    }\\n    const dp = Array(n).fill(0);\\n    dp[0] = nums[0];\\n    for(let i = 1; i < n; ++i) {\\n        dp[i] = dp[i - 1] + nums[i];\\n        if(dp[i] % k === 0) {\\n            return true;\\n        }\\n    }\\n    for(let i = 2; i < n; ++i) {\\n        let sum = nums[i - 2];\\n        for(let j = i; j < n; ++j) {\\n            dp[j] -= sum;\\n            if(dp[j] % k === 0) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\nTime Complexity = O(n^2)\\nSpace Complexity = O(n)\\nThis will give TLE for the last test case.\\n\\n----\\n\\n**Solution 3: Prefix Sum**\\nApproach: \\n```\\n- Sum at index i [0, i] = k * m + x\\n- Mod by k at index i = x\\n- Sum at index j [0, j] = k * n + y\\n- Mod by k at index j = y\\n- x and y value can range from [0, k - 1]\\n- if x === y\\n  - sum_i - sum_j = k * m + x - k * n - x\\n  -               = k * (m - n)\\n  -               = k * c (m - n is a constant value) \\n-> between index i and j (i, j] we will have a sum which is a multiple of k\\n\\n\\nk = 7, [1,3,6,0,9,6,9]\\n1    3    6    0    9    6    9\\n1    4    3    3    5    4\\n\\nThe sum 21 within range [2, 5] \\n```\\n\\nCode:\\n```\\nvar checkSubarraySum = function(nums, k) {\\n    const n = nums.length;\\n    if(n < 2) {\\n        return false;\\n    }\\n    const map = new Map();\\n\\t\\n\\t// edge case - to handle sum % k === 0 and\\n\\t// if the first element of array is a multiple of k, condition 0 - (-1) = 1 > 1 wil fail (min length of subarray must be 2)\\n    map.set(0, -1);\\n    let sum = 0;\\n    \\n    for(let i = 0; i < n; ++i) {\\n        sum += nums[i];\\n        sum = sum % k;\\n\\t\\t\\n\\t\\t// handles min length of subarray must be 2\\n        if(map.has(sum) && i - map.get(sum) > 1) {\\n            return true;\\n        } else if(!map.has(sum)) {\\n            map.set(sum, i);\\n        }\\n    }\\n    return false;\\n}\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(k) (mod value can range from [0, k - 1], so max length will be k)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// TC = O(n^3); SC = O(1)\\nvar checkSubarraySum = function(nums, k) {\\n    const n = nums.length;\\n    if(n < 2) {\\n        return false;\\n    }\\n    let sum = 0;\\n    for(let i = 0; i < n; ++i) {\\n        for(let j = i + 2; j <= n; ++j) {\\n            for(let l = i; l < j; ++l) {\\n                sum += nums[l];\\n            }\\n            if(sum % k === 0) {\\n                return true;\\n            }\\n            sum = 0;\\n        }\\n    }\\n    return false;\\n};\\n```\n```\\nk = 7, [1,3,6,0,9,6,9]\\n1    3    6    0    9    6    9\\n1    4   10   10   19   25   34\\n     3    9    9   18   24   33\\n\\t\\t  6    6   15   21\\n```\n```\\n// TC = O(n^2); SC = O(n)\\nvar checkSubarraySum = function(nums, k) {\\n    const n = nums.length;\\n    if(n < 2) {\\n        return false;\\n    }\\n    const dp = Array(n).fill(0);\\n    dp[0] = nums[0];\\n    for(let i = 1; i < n; ++i) {\\n        dp[i] = dp[i - 1] + nums[i];\\n        if(dp[i] % k === 0) {\\n            return true;\\n        }\\n    }\\n    for(let i = 2; i < n; ++i) {\\n        let sum = nums[i - 2];\\n        for(let j = i; j < n; ++j) {\\n            dp[j] -= sum;\\n            if(dp[j] % k === 0) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\n- Sum at index i [0, i] = k * m + x\\n- Mod by k at index i = x\\n- Sum at index j [0, j] = k * n + y\\n- Mod by k at index j = y\\n- x and y value can range from [0, k - 1]\\n- if x === y\\n  - sum_i - sum_j = k * m + x - k * n - x\\n  -               = k * (m - n)\\n  -               = k * c (m - n is a constant value) \\n-> between index i and j (i, j] we will have a sum which is a multiple of k\\n\\n\\nk = 7, [1,3,6,0,9,6,9]\\n1    3    6    0    9    6    9\\n1    4    3    3    5    4\\n\\nThe sum 21 within range [2, 5] \\n```\n```\\nvar checkSubarraySum = function(nums, k) {\\n    const n = nums.length;\\n    if(n < 2) {\\n        return false;\\n    }\\n    const map = new Map();\\n\\t\\n\\t// edge case - to handle sum % k === 0 and\\n\\t// if the first element of array is a multiple of k, condition 0 - (-1) = 1 > 1 wil fail (min length of subarray must be 2)\\n    map.set(0, -1);\\n    let sum = 0;\\n    \\n    for(let i = 0; i < n; ++i) {\\n        sum += nums[i];\\n        sum = sum % k;\\n\\t\\t\\n\\t\\t// handles min length of subarray must be 2\\n        if(map.has(sum) && i - map.get(sum) > 1) {\\n            return true;\\n        } else if(!map.has(sum)) {\\n            map.set(sum, i);\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283187,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // stores mod values of k mapped with first time found index\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        long sum=0;\\n        map.put(0,-1); // base case no sum at -1 position\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            int key = (int)sum%k;\\n            if(map.containsKey(key)){\\n                // System.out.println(i + \" \"+key);\\n                // subArray size greater than 1 \\n                if(i-map.get(key)>1)\\n                    return true;\\n            }\\n            else\\n                map.put(key,i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // stores mod values of k mapped with first time found index\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        long sum=0;\\n        map.put(0,-1); // base case no sum at -1 position\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            int key = (int)sum%k;\\n            if(map.containsKey(key)){\\n                // System.out.println(i + \" \"+key);\\n                // subArray size greater than 1 \\n                if(i-map.get(key)>1)\\n                    return true;\\n            }\\n            else\\n                map.put(key,i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126575,
                "title": "python-clear-o-n-solution",
                "content": "Similar to the problem of continuous subarray sum equals k, use a hashmap to speedup the lookup, but the difference is that now the key should be the remainder(cummulative sum mod k), so when we find the same key/remainder in hashmap, we find a subarray sum of n*k.\\nTime complexity is O(n).\\nSpace complexity is O(min(k, n)).\\n```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if 0 == k:\\n            return len(nums) >= 2 and any(i == 0 and j == 0 for i, j in zip(nums, nums[1:]))\\n\\n        sums = 0\\n        ht = {0:-1}\\n        for i in range(len(nums)):\\n            sums += nums[i]\\n            rem = sums % k\\n            if rem in ht:\\n                if i - ht[rem] >= 2:\\n                    return True\\n            else:\\n                ht[rem] = i\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if 0 == k:\\n            return len(nums) >= 2 and any(i == 0 and j == 0 for i, j in zip(nums, nums[1:]))\\n\\n        sums = 0\\n        ht = {0:-1}\\n        for i in range(len(nums)):\\n            sums += nums[i]\\n            rem = sums % k\\n            if rem in ht:\\n                if i - ht[rem] >= 2:\\n                    return True\\n            else:\\n                ht[rem] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745197,
                "title": "java-math-proof-explained-easy",
                "content": "# Intuition\\nWe need to sum up to some multiple of `k`. \\n\\nA multiple of k is `c*k`. If we `mod` this expression we get `c % k = 0`. Keep this in mind because we can use this to normalize the array.\\n\\nif the elements m + n sum up to a multiple of `k`, we get: `m + n = c * k`. We can reduce to:\\n`(a % m + x) + (b % n + y) = c % k => x + y = 0`.\\nThis means that if we perform mod operations on the numbers, it\\'s enough to sum them up to `0` instead of a multiple of `k`.\\n\\nThat\\'s great, now we are left with a variant of the finding a subarray equal to `0` problem.\\nIf at a current index `i` we have elements summing up to `x` (remember `0 <= x < k` because of mod) we can check our hashmap if we already seen the current sum `x`. If we did, it means we can remove that prefix and we are left with an infix (subarray) that is a multiple of `k`.\\n\\nExample\\nk=6\\narr =  [1,6,2,4]\\nmod =[1,1,3,1] \\n\\nwe can see that we have 1 repeating multiple times. That means there are multiple `infixes` that sum of to `k`.\\n\\nThe last constraint is to have the subarray length bigger than 1. We just check the last seen index of that same `x` value and if `i - j > 1` we are good to go.\\n\\n# Code\\n```\\npublic class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Integer, Integer> prefixToIndex = new HashMap<>();\\n        int normalizedRunningSum = nums[0] % k;\\n        prefixToIndex.put(normalizedRunningSum, 0);\\n\\n        for (int i = 1; i < n; i++) {\\n            normalizedRunningSum = (normalizedRunningSum + nums[i]) % k;\\n\\n            boolean validInfixCondition = prefixToIndex.containsKey(normalizedRunningSum) && i - prefixToIndex.get(normalizedRunningSum) > 1;\\n            if (normalizedRunningSum == 0 || validInfixCondition) {\\n                return true;\\n            }\\n\\n            if (!prefixToIndex.containsKey(normalizedRunningSum)) {\\n                prefixToIndex.put(normalizedRunningSum, i);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Integer, Integer> prefixToIndex = new HashMap<>();\\n        int normalizedRunningSum = nums[0] % k;\\n        prefixToIndex.put(normalizedRunningSum, 0);\\n\\n        for (int i = 1; i < n; i++) {\\n            normalizedRunningSum = (normalizedRunningSum + nums[i]) % k;\\n\\n            boolean validInfixCondition = prefixToIndex.containsKey(normalizedRunningSum) && i - prefixToIndex.get(normalizedRunningSum) > 1;\\n            if (normalizedRunningSum == 0 || validInfixCondition) {\\n                return true;\\n            }\\n\\n            if (!prefixToIndex.containsKey(normalizedRunningSum)) {\\n                prefixToIndex.put(normalizedRunningSum, i);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290490,
                "title": "simple-java-with-all-explanation-needed",
                "content": "class Solution {\\n    \\n\\t/* \\n    The main idea is we keep calculating sum of all numbers in the array and calculate sum%k which is \\n    the remainder and store it with the value of current index in a map.\\n    \\n    so at any point if you see a same remainder twice, you know the difference from the first index where remainder\\n    was the same as the current remainder is a multiple of k.\\n    \\n    Ex: [23,2,4,6,7] , k=6\\n    \\n    At index 0 we calculate sum = 23 and calculate remainder 23%6 = 5 and store it with value index 0 in the \\n    map. map -> [5->0]\\n    At index 1 we calculate sum  23+2 = 25 % 6 = 1. map = [5->0,1->1]\\n    At index 2 sum= 25+4 = 29 , rem = 29%6 = 5 there is a 5 already in the map.Check if there is atleast 1 \\n    index between first index and current index, because there have to be atleast 2 numbers in the criteria.\\n    \\n    So at this point we know 2,4 match the criteria and return true.\\n    \\n\\tEdge case:\\n    Eg: [0,0,2]\\n    you know the ans is true because [0,0] is enough.\\n    So to solve this edge case we store a 0 and -1 in the map initially.    \\n    */\\n    \\n    \\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap();\\n        \\n        \\n        // this is for example (-10,10,5,4,... )\\n        // -10,10 add up to zero is a multiple of k.\\n        map.put(0,-1);\\n        \\n        int sum=0;\\n        for(int i =0;i<nums.length;i++){\\n            sum+=nums[i];\\n            int rem = sum%k;\\n            if(map.containsKey(rem) ){\\n                if((i-map.get(rem))>1)\\n                    return true;\\n                else\\n                    continue;\\n            }\\n                    \\n            map.put(rem,i);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n\\t/* \\n    The main idea is we keep calculating sum of all numbers in the array and calculate sum%k which is \\n    the remainder and store it with the value of current index in a map.\\n    \\n    so at any point if you see a same remainder twice, you know the difference from the first index where remainder\\n    was the same as the current remainder is a multiple of k.\\n    \\n    Ex: [23,2,4,6,7] , k=6\\n    \\n    At index 0 we calculate sum = 23 and calculate remainder 23%6 = 5 and store it with value index 0 in the \\n    map. map -> [5->0]\\n    At index 1 we calculate sum  23+2 = 25 % 6 = 1. map = [5->0,1->1]\\n    At index 2 sum= 25+4 = 29 , rem = 29%6 = 5 there is a 5 already in the map.Check if there is atleast 1 \\n    index between first index and current index, because there have to be atleast 2 numbers in the criteria.\\n    \\n    So at this point we know 2,4 match the criteria and return true.\\n    \\n\\tEdge case:\\n    Eg: [0,0,2]\\n    you know the ans is true because [0,0] is enough.\\n    So to solve this edge case we store a 0 and -1 in the map initially.    \\n    */\\n    \\n    \\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap();\\n        \\n        \\n        // this is for example (-10,10,5,4,... )\\n        // -10,10 add up to zero is a multiple of k.\\n        map.put(0,-1);\\n        \\n        int sum=0;\\n        for(int i =0;i<nums.length;i++){\\n            sum+=nums[i];\\n            int rem = sum%k;\\n            if(map.containsKey(rem) ){\\n                if((i-map.get(rem))>1)\\n                    return true;\\n                else\\n                    continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1202674,
                "title": "2ms-100-faster-dp-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n       Set<Integer>dp=new HashSet<>();\\n        int sum=0,last=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            int remainder=sum%k;\\n            if(dp.contains(remainder)) return true;\\n            dp.add(last);\\n            last=remainder;\\n            sum=remainder;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n       Set<Integer>dp=new HashSet<>();\\n        int sum=0,last=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            int remainder=sum%k;\\n            if(dp.contains(remainder)) return true;\\n            dp.add(last);\\n            last=remainder;\\n            sum=remainder;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785081,
                "title": "python-better-than-100",
                "content": "`exception handling` is done to handle `k=0` , you can easily use `if-statements` if you don\\'t feel comfortable with exception handling.\\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        if not nums:\\n            return False\\n        \\n        cache = {0:-1}\\n        rem=0\\n        \\n        for i in range(len(nums)):\\n            try:\\n                rem = (rem+nums[i])%k\\n            except ZeroDivisionError:\\n                rem = rem+nums[i]\\n                \\n            if rem in cache:\\n                if i-cache[rem]>1:\\n                    return True\\n            else:\\n                cache[rem] = i\\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        if not nums:\\n            return False\\n        \\n        cache = {0:-1}\\n        rem=0\\n        \\n        for i in range(len(nums)):\\n            try:\\n                rem = (rem+nums[i])%k\\n            except ZeroDivisionError:\\n                rem = rem+nums[i]\\n                \\n            if rem in cache:\\n                if i-cache[rem]>1:\\n                    return True\\n            else:\\n                cache[rem] = i\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175571,
                "title": "python-easy-and-fast-solution",
                "content": "For the case when `k == 0` , we simply look for 2 consecutive occurences of `0` in `nums`.\\nWhen `k  != 0`, we try to find 2 indices `i` and `j`, such that `(sum(nums[0:j]) - sum(nums[0:i])) % k == 0`. This can in turn be implemented by maintaining a running sum `rs` and storing `rs % k` in a hashset to check for a future occurence of the same number.\\n```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        if k == 0:\\n            for i in range(0, len(nums) - 1):\\n                if nums[i] == 0 and nums[i + 1] == 0:\\n                    return True\\n            return False\\n        seen = {0, nums[0] % k}\\n        rs = nums[0]\\n        for i in range(1, len(nums)):\\n            rs = (rs + nums[i]) % k\\n            if rs in seen:\\n                return True\\n            seen.add(rs)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        if k == 0:\\n            for i in range(0, len(nums) - 1):\\n                if nums[i] == 0 and nums[i + 1] == 0:\\n                    return True\\n            return False\\n        seen = {0, nums[0] % k}\\n        rs = nums[0]\\n        for i in range(1, len(nums)):\\n            rs = (rs + nums[i]) % k\\n            if rs in seen:\\n                return True\\n            seen.add(rs)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173165,
                "title": "java-solution-beats-100",
                "content": "Thanks for @yz5548 who gave a test case which points out that when we consider the **Pigeonhole Principle**, we should not forget the length of the answer array should be at least 2. Under such circumstances, the length of input array should satisfy `nums.length + 1 > k * 2` to make sure the distance between two same prefix remainders is larger than one.\\n\\n``` java\\n/*\\n### Corner cases\\n1. Element maybe zero \\n2. Input could be empty\\n3. K maybe zero or negative\\n\\n### Solution\\n1. We store the prefix sum mod k rather than prefix sum. When two prefix sums with the same remainder appear, we got our answer. \\n   Furthermore, if `nums.length + 1 > k * 2` the answer is definitely true.\\n*/\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        k = k == 0 ? Integer.MAX_VALUE : (k < 0 ? -k : k); // make sure k is positive; if k is zero, we won\\'t do mod at all\\n        if ((nums.length + 2) / 2 > k) return true; // we have (length + 1 > k * 2) prefix sum but k remainder and k positions that the same remainders next to each other, then there is at least two prefix with the same remainder and the distance is larger than one\\n        \\n        Set<Integer> set = new HashSet<>();\\n        int last = 0; // the prefix sum one element earlier\\n        for (int num : nums) {\\n            int cur = (last + num) % k; // get newest prefix sum mod k\\n            if (set.contains(cur)) return true;\\n            set.add(last); // add old prefix sum into HashSet\\n            last = cur; // update old prefix sum\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\n/*\\n### Corner cases\\n1. Element maybe zero \\n2. Input could be empty\\n3. K maybe zero or negative\\n\\n### Solution\\n1. We store the prefix sum mod k rather than prefix sum. When two prefix sums with the same remainder appear, we got our answer. \\n   Furthermore, if `nums.length + 1 > k * 2` the answer is definitely true.\\n*/\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        k = k == 0 ? Integer.MAX_VALUE : (k < 0 ? -k : k); // make sure k is positive; if k is zero, we won\\'t do mod at all\\n        if ((nums.length + 2) / 2 > k) return true; // we have (length + 1 > k * 2) prefix sum but k remainder and k positions that the same remainders next to each other, then there is at least two prefix with the same remainder and the distance is larger than one\\n        \\n        Set<Integer> set = new HashSet<>();\\n        int last = 0; // the prefix sum one element earlier\\n        for (int num : nums) {\\n            int cur = (last + num) % k; // get newest prefix sum mod k\\n            if (set.contains(cur)) return true;\\n            set.add(last); // add old prefix sum into HashSet\\n            last = cur; // update old prefix sum\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744656,
                "title": "a-java-implementation-of-prefix-sum-that-may-be-easier-to-understand",
                "content": "```\\nclass Solution {\\n\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            sum[i] = sum[i - 1] + nums[i - 1];\\n        }\\n\\n        Set<Integer> set = new HashSet();\\n\\n        for (int i = 2; i <= n; i++) {\\n            set.add(sum[i - 2] % k);\\n            if (set.contains(sum[i] % k)) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            sum[i] = sum[i - 1] + nums[i - 1];\\n        }\\n\\n        Set<Integer> set = new HashSet();\\n\\n        for (int i = 2; i <= n; i++) {\\n            set.add(sum[i - 2] % k);\\n            if (set.contains(sum[i] % k)) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744585,
                "title": "super-easy-java-solution-99-56-faster-tested-and-verified",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n\\n```\\nclass Solution {\\n/**/\\n//SOLUTION BY YADUTTAM PAREEK\\n/**/\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] == 0 && nums[i-1] == 0) return true;\\n        }\\n        for(int i=1;i<nums.length;i++) {\\n            nums[i] += nums[i-1];\\n            if(nums[i] % k ==0) return true;\\n            int j = i;\\n            while(j> 1 && nums[i] > k) {\\n                if((nums[i] - nums[j-2]) % k ==0) {\\n                    return true;\\n                }\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# If you reached till here please upvote the solution.\\n![image](https://assets.leetcode.com/users/images/83ae693a-6d26-4dad-bf71-786dae4144cf_1666755653.0141456.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n/**/\\n//SOLUTION BY YADUTTAM PAREEK\\n/**/\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] == 0 && nums[i-1] == 0) return true;\\n        }\\n        for(int i=1;i<nums.length;i++) {\\n            nums[i] += nums[i-1];\\n            if(nums[i] % k ==0) return true;\\n            int j = i;\\n            while(j> 1 && nums[i] > k) {\\n                if((nums[i] - nums[j-2]) % k ==0) {\\n                    return true;\\n                }\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933875,
                "title": "java-hashmap-easy-to-understand-o-n-time-and-o-n-space",
                "content": "**Approach**: Compute the remainders of sum seen so far. If the remainder is seen again then the elements in the middle must have summed to *k* or *n\\\\*k* so their remainders must be 0. Now calculate length of subarray by getting index from hashmap.  If length is > 2 then return true.\\n\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // A hashmap to store remainder of sum so far with index\\n        HashMap<Integer, Integer> remIndex = new HashMap<Integer, Integer>();\\n        remIndex.put(0, -1); // Put remainder 0 with index -1 \\n        int sum = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            sum += nums[i];\\n            if (remIndex.containsKey(sum % k)) { // If sum % k is seen again which means middle values must be n*k so their remainder must be 0\\n                int j = remIndex.get(sum % k);\\n                if (i-j>=2) // The size of subarray must be greater than 2\\n                    return true;\\n            } else {\\n                remIndex.put(sum % k, i); // Put remainder of sum with index in hashmap\\n            }                \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // A hashmap to store remainder of sum so far with index\\n        HashMap<Integer, Integer> remIndex = new HashMap<Integer, Integer>();\\n        remIndex.put(0, -1); // Put remainder 0 with index -1 \\n        int sum = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            sum += nums[i];\\n            if (remIndex.containsKey(sum % k)) { // If sum % k is seen again which means middle values must be n*k so their remainder must be 0\\n                int j = remIndex.get(sum % k);\\n                if (i-j>=2) // The size of subarray must be greater than 2\\n                    return true;\\n            } else {\\n                remIndex.put(sum % k, i); // Put remainder of sum with index in hashmap\\n            }                \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797735,
                "title": "python-o-n-with-explanation",
                "content": "Two basic tips:\\n1. sum(i, j) = sum(0, j) - sum(0, i)\\n2. (a - b) % k = 0 equals to a % k = b % k\\n\\nFor each sum(0, j), we just need to find if there exists i < j - 1 s.t. sum(0, i) % k =sum(0, j) % k\\n\\nCheck the code\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        sum_ = 0\\n        modSet = {0:-1}\\n        for i in range(len(nums)):\\n            sum_ = (sum_ + nums[i]) % k\\n            if sum_ not in modSet:\\n                modSet[sum_] = i\\n            elif modSet[sum_] < i - 1:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        sum_ = 0\\n        modSet = {0:-1}\\n        for i in range(len(nums)):\\n            sum_ = (sum_ + nums[i]) % k\\n            if sum_ not in modSet:\\n                modSet[sum_] = i\\n            elif modSet[sum_] < i - 1:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782531,
                "title": "python-solution-the-most-straight-foward-i-have-seen",
                "content": "**This question is similar to** [Subarray Sum Equals K - LeetCode](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\nI will advice you check it out to get familiar\\n\\n**The Idea**\\n\\nWe are to find a subarray whose mod of k is 0 i.e is a multiple of k\\nThe idea is that if the mod of `nums[:i]` is equal to the mod of `nums[:j]` where `i < j` then the mod of `nums[i:j]` (subarray between **i** and **j**) is equal to 0 (posible answer)\\n\\n**Solution**\\n```\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(nums) < 2:\\n            return False\\n        \\n        d = {}\\n        currSum = 0\\n        \\n        for i in range(len(nums)):\\n            \\n            currSum = currSum + nums[i]\\n            mod = currSum%k\\n            \\n            if mod == 0 and i+1 >= 2:\\n                return True\\n                        \\n            if mod in d:\\n                if i - d[mod] >= 2:\\n                    return True\\n            else:\\n                d[mod] = i\\n                \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(nums) < 2:\\n            return False\\n        \\n        d = {}\\n        currSum = 0\\n        \\n        for i in range(len(nums)):\\n            \\n            currSum = currSum + nums[i]\\n            mod = currSum%k\\n            \\n            if mod == 0 and i+1 >= 2:\\n                return True\\n                        \\n            if mod in d:\\n                if i - d[mod] >= 2:\\n                    return True\\n            else:\\n                d[mod] = i\\n                \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1759854,
                "title": "c-easy-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_set<int> st;          \\n        int sum = 0, r = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            int ans = sum % k;\\n            if(st.count(ans)){return true;}\\n            st.insert(r);\\n            r = ans;\\n        }\\n        return false;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_set<int> st;          \\n        int sum = 0, r = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            int ans = sum % k;\\n            if(st.count(ans)){return true;}\\n            st.insert(r);\\n            r = ans;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694314,
                "title": "python-3-faster-than-94-using-dict",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        s=0\\n        d={0:-1}\\n        for i in range(len(nums)):\\n            s=s+nums[i]\\n            if k!=0:\\n                s=s%k\\n            if s in d:\\n                if i-d[s]>=2:\\n                    return True\\n            else:\\n                d[s]=i\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        s=0\\n        d={0:-1}",
                "codeTag": "Java"
            },
            {
                "id": 539591,
                "title": "python-with-very-detailed-explanation-of-corner-case",
                "content": "This is a common solution but I found people\\'s explanation on the corner case very vague. Thus, I decide to post mine\\n\\n```python\\nclass Solution:\\n    \"\"\"\\n    idea:\\n       we can use prefix sum\\n       for example:\\n           [23,2,4,6,7] -> cumsum -> [23,25,29,35,42] to find the subarray sum of 2,4,6, we use 35 - 23 = 12\\n           let\\'s say sum2 = 35, sum1 = 23, we can see that (sum2 - sum1)%k = 0 then we find a multiple of k\\n           equivalently, if we can find sum2%k = sum1%k, and these two prefix sum\\'s distance is at\\n           least 2 (the subarray should be at least length 2), we find the answer\\n\\n        thus, we convert the cumsum to cumsum%k\\n        from [23,25,29,35,42]%6 -> [5, 1, 3, 5, 0]. here we can see that there are two 5 here,\\n        hence, we can find a subarray sum that is multiple of k in this array\\n\\n        we can use a hashmap to store the pair of mod to their index, this way\\n        we can quickly check if any previous mod is the same\\n\\n        we need to be careful of 0, for example [0,0], k = 0, we can see that\\n        here cumsum = [0, 0] -> after mod = [0, 0], then if we use the hashmap to store it\\n        we will get {0: 0} and when we are in the second 0 and we found 0 already in\\n        the map, we will do 1-0 < 2, and we have conclude that no multiples found,\\n        but indeed, we found one.\\n        thus, we need to initialize the map with {0:-1} to take care of this situation\\n        this way, you will get 1-(-1) = 2, and have the right conclusion\\n    \"\"\"\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1] # get cumulative sum\\n\\n        hm = {0: -1} # corner case \\n        for i in range(len(nums)):\\n            tmp = nums[i]\\n            if k: # avoid zero division error\\n                tmp %= k\\n            if tmp in hm:\\n                if (i - hm[tmp]) >= 2:\\n                    return True\\n            else:\\n                hm[tmp] = i\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \"\"\"\\n    idea:\\n       we can use prefix sum\\n       for example:\\n           [23,2,4,6,7] -> cumsum -> [23,25,29,35,42] to find the subarray sum of 2,4,6, we use 35 - 23 = 12\\n           let\\'s say sum2 = 35, sum1 = 23, we can see that (sum2 - sum1)%k = 0 then we find a multiple of k\\n           equivalently, if we can find sum2%k = sum1%k, and these two prefix sum\\'s distance is at\\n           least 2 (the subarray should be at least length 2), we find the answer\\n\\n        thus, we convert the cumsum to cumsum%k\\n        from [23,25,29,35,42]%6 -> [5, 1, 3, 5, 0]. here we can see that there are two 5 here,\\n        hence, we can find a subarray sum that is multiple of k in this array\\n\\n        we can use a hashmap to store the pair of mod to their index, this way\\n        we can quickly check if any previous mod is the same\\n\\n        we need to be careful of 0, for example [0,0], k = 0, we can see that\\n        here cumsum = [0, 0] -> after mod = [0, 0], then if we use the hashmap to store it\\n        we will get {0: 0} and when we are in the second 0 and we found 0 already in\\n        the map, we will do 1-0 < 2, and we have conclude that no multiples found,\\n        but indeed, we found one.\\n        thus, we need to initialize the map with {0:-1} to take care of this situation\\n        this way, you will get 1-(-1) = 2, and have the right conclusion\\n    \"\"\"\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1] # get cumulative sum\\n\\n        hm = {0: -1} # corner case \\n        for i in range(len(nums)):\\n            tmp = nums[i]\\n            if k: # avoid zero division error\\n                tmp %= k\\n            if tmp in hm:\\n                if (i - hm[tmp]) >= 2:\\n                    return True\\n            else:\\n                hm[tmp] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744854,
                "title": "python-simple-and-easy-way-to-solve-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        lookup = {0:-1}\\n        curr_sum = 0\\n        \\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                curr_sum = (curr_sum + n) % k\\n            else:\\n                curr_sum += n\\n            if curr_sum not in lookup:\\n                lookup[curr_sum] = i\\n            else:\\n                if i - lookup[curr_sum] >= 2:\\n                    return True\\n        return False\\n```\\n**If you\\'re interested in learning Python, check out my blog. https://www.python-techs.com/**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        lookup = {0:-1}\\n        curr_sum = 0\\n        \\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                curr_sum = (curr_sum + n) % k\\n            else:\\n                curr_sum += n\\n            if curr_sum not in lookup:\\n                lookup[curr_sum] = i\\n            else:\\n                if i - lookup[curr_sum] >= 2:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744853,
                "title": "java-detailed-explanation-with-dry-run-clean-code",
                "content": "Upvote if the solution helped :) For all my optimised solutions, Click || -->[Here](https://github.com/abhideepghosh/Leetcode-Solutions)<-- ||\\n\\nContent In This Explanation:\\n1. Explanation Of The Code\\n2. Code\\n\\n![image](https://assets.leetcode.com/users/images/15726c82-aa91-40b0-9d8e-a3ce920433a2_1666761595.1767132.png)\\n![image](https://assets.leetcode.com/users/images/084cfbcc-513b-4e6a-9e6b-b8fadfe78702_1666761628.694907.png)\\n![image](https://assets.leetcode.com/users/images/6ddb8252-fa9d-4b24-add4-27216c89d76b_1666761759.5413418.png)\\n![image](https://assets.leetcode.com/users/images/8122f2ab-513a-4194-b35b-839f9c5ebdf3_1666761773.185961.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/c8904984-cf60-45da-b3c1-fb1faea49da6_1666761804.1299694.png)\\n![image](https://assets.leetcode.com/users/images/d7d99d6a-87d6-4cd9-8ae2-22867a7eebfd_1666761830.489237.png)\\n\\n\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        map.put(0,0);\\n        \\n        int sum = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            \\n            sum += nums[i];\\n            \\n            if(!map.containsKey(sum % k)){\\n                map.put(sum % k, i + 1);\\n            }else{\\n                if(map.get(sum % k) < i){\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        map.put(0,0);\\n        \\n        int sum = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            \\n            sum += nums[i];\\n            \\n            if(!map.containsKey(sum % k)){\\n                map.put(sum % k, i + 1);\\n            }else{\\n                if(map.get(sum % k) < i){\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964161,
                "title": "c-easy-with-concept",
                "content": "So first the brute force , you can check every possible subarray of size>=2 . \\nBut it will take O(n^2) ....\\nSo ....Now the concept of O(n) solution (using hash_map , can also use hash_set )\\nWe will use hash map.\\n\\nTraverse through the array and -\\n1. Calculate running sum and take the modulus of it from k ;\\n2. If not already present in hash map , then insert in hash map.\\n3. See if it is already present in the hash map but atleast , 2 position before so that we will get the size of subarray >=2.\\nCONCEPT : You will encounter the same \\'sum%k\\' , only if the previous \\'sum%k\\' plus some multiple of k is there within this range . So it will have a subarray satifying the criteria . \\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        unordered_map<int,int> mp={{0,-1}};\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=(sum+nums[i]%k)%k;\\n            if(mp.count(sum)==0)\\n                mp[sum]=i;\\n            if(i-mp[sum]>1)\\n                return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        unordered_map<int,int> mp={{0,-1}};\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=(sum+nums[i]%k)%k;\\n            if(mp.count(sum)==0)\\n                mp[sum]=i;\\n            if(i-mp[sum]>1)\\n                return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948647,
                "title": "how-could-i-come-up-with-this-solution-in-the-interview",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \"\"\"\\n        some cases:\\n            [3,3,3,3,3,3,3,3,3] k = 4 , k=1\\n            \\n            [1,1,1,1,1,1,1,1] k = 4\\n            \\n            [3,2,1,40,1,2,3,4,5,6,7] k = 50\\n            \\n            [0,0,0,0,0,0,3,0,0,1,1,1] k = 3\\n            \\n            prefix sum + iterate start and end =>  O(n^2)\\n            \\n            \\n            [23,2,4,6,7] -> mod by 6 -> [5,2,4,0,1]           0 <= x <= k-1\\n            \\n            presum[i] = [0,5,1,5,0,0]\\n            \\n        \"\"\"\\n\\n        memo = dict()\\n        memo[0] = -1\\n\\n        presum = 0\\n        for i in range(len(nums)):\\n            presum = (presum+nums[i]) % k\\n            if presum in memo: \\n                if i-memo[presum] >= 2:\\n                    return True\\n            else:\\n                memo[presum] = i\\n        return False\\n```\\n\\n How could I come up with this solution in the interview? \\n (prerequisite: residue knowledge and prefix sum knowledge. Without these two knowledges, it is not likely to have this solution.)\\n- This is all what have flowed in my brain:\\n\\t1. make some more cases so that I can better understand the problem, and let edge cases give me a true feeling of the solution.\\n\\t2. it is about continous subarray sum, so prefix sum might be useful\\n\\t3. prefix sum + iterate start and end, that is a O(n^2) solution; I got the brute force now.\\n\\t4. it can\\'t be O(nlogn) because there are no way to have sorting, binary search or whatever gives a `logn`\\n\\t5. so, I\\'m targeting O(n)\\n\\t6. I must iterate the array once, or twice and get the answer.\\n\\t7. what can I do in an iteration? no new thought => I can get prefix sum. Of course~\\n\\t8. read the problem again. I need to let them satisfy  `sum % k = 0` \\n\\t9. so it means when I sum some numbers, I only care about the residue w.r.t. `k` \\n\\t10. maybe prefix sum is still useful, but not in its original way => I can try to think about prefix residue sum => especially those `%k=0`\\n\\t11. I remember a knowledge that: if `A%k=R` and `B%k=R` , even though A or B doesn\\'t give me multiple of k, but their difference does.\\n\\t12. if `A%k=R,  B%k=R` ,  then `(A-B)%k = 0`\\n\\t13. In an iteration, I will know current sum, and the residue, like `A%k = x`. But I need to know where is the `B` ?\\n\\t14. Dictionary/Hashmap helps me store it.\\n\\t15. Clear my thought. Check the idea with the example cases I made => looks good. => And that\\'s it!\\n\\t16. Think about some implementation details and I start coding!\\n\\n\\nUPVOTE IF YOU LIKE. THANKS!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \"\"\"\\n        some cases:\\n            [3,3,3,3,3,3,3,3,3] k = 4 , k=1\\n            \\n            [1,1,1,1,1,1,1,1] k = 4\\n            \\n            [3,2,1,40,1,2,3,4,5,6,7] k = 50\\n            \\n            [0,0,0,0,0,0,3,0,0,1,1,1] k = 3\\n            \\n            prefix sum + iterate start and end =>  O(n^2)\\n            \\n            \\n            [23,2,4,6,7] -> mod by 6 -> [5,2,4,0,1]           0 <= x <= k-1\\n            \\n            presum[i] = [0,5,1,5,0,0]\\n            \\n        \"\"\"\\n\\n        memo = dict()\\n        memo[0] = -1\\n\\n        presum = 0\\n        for i in range(len(nums)):\\n            presum = (presum+nums[i]) % k\\n            if presum in memo: \\n                if i-memo[presum] >= 2:\\n                    return True\\n            else:\\n                memo[presum] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867394,
                "title": "time-o-n-and-space-o-k-use-simple-steps",
                "content": "\\n# Steps For Understand Algo\\n1. first->  find sum \\n2. then sum % k\\n3. and add it on hashmap with KEY(sum%k) and VALUE(Index);\\n4. if you find duplicate KEY means there are subArray with sum == k\\n5. check is this subArray contains At Least 2 Elemenet , yes the return true\\n6. else return false;\\n\\n# Code :)\\n```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n       if(nums.length == 0){\\n           return false;\\n       }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0 , -1); //for this case [0,0]\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            sum += nums[i];// for total sum\\n            \\n            if(k != 0){// avoid k = 0;\\n                sum %= k;\\n            }\\n            \\n            if(map.containsKey(sum)){\\n                int prevIndex = map.get(sum);\\n                \\n                if(i - prevIndex > 1){// if there are two element with sum = k\\n                    return true;\\n                }\\n            } else {\\n                map.put(sum , i);// if unique element \\n            }\\n        }\\n\\t\\t// if nothing find in the array\\n        return false;       \\n    \\n    }\\n```\\n// Welcome  in Advance yaar :)\\n![image](https://assets.leetcode.com/users/images/577cbba8-db3c-4329-b67c-0d892cf034df_1648118551.4685156.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n       if(nums.length == 0){\\n           return false;\\n       }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0 , -1); //for this case [0,0]\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            sum += nums[i];// for total sum\\n            \\n            if(k != 0){// avoid k = 0;\\n                sum %= k;\\n            }\\n            \\n            if(map.containsKey(sum)){\\n                int prevIndex = map.get(sum);\\n                \\n                if(i - prevIndex > 1){// if there are two element with sum = k\\n                    return true;\\n                }\\n            } else {\\n                map.put(sum , i);// if unique element \\n            }\\n        }\\n\\t\\t// if nothing find in the array\\n        return false;       \\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440809,
                "title": "java-o-n-time-and-o-k-space-with-reference-to-similar-problems",
                "content": "It is almost always the case that whenever we are asked about multiples to be found, we need to use **mod operation** since we cannot check for all multiples of a given number.\\n1) Since we are asked to find subarray which **sums** up to multiple of k, we want to calculate prefix sum, so that when we want to find sum of elements in subarray [i, j], we can subtract sum[j] - sum[i - 1];\\n2) Now,  lets say the current sum till **ith** index is **Sum[i]**. Now, lets say it is **X** more than multiple of k, in otherwords **X = Sum[i] % k**\\n3) If we can find another sum till index j where j < i, which is also **X** more than multiple of k, in other words **Sum[j] % k = X**, then that means the difference between them Sum[i] - Sum[j] is divisible by k\\n4) Sum[i] = n * k + x and Sum[j] = m * k + x (where j < i)\\n     Sum[i] - Sum[j] = (n * k + x) - (m * k + x)\\n     Sum[i] - Sum[j] = (n  - m)* k\\nClearly Sum[i] - Sum[j] is a multiple of k\\n5) At every index j, store Sum[j] % k in a hashmap so that we can quickly find it for indices i where i > j\\n\\n```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tmap.put(0, -1);\\n\\tint sum = 0;\\n\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\tsum += nums[i];\\n\\t\\tint mod = sum % k;\\n\\t\\tif(i - map.getOrDefault(mod, i) >= 2) return true;\\n\\t\\tmap.putIfAbsent(mod, i);\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Similar problem:**\\nThere is another similar problem which works on same grounds: https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/, whose solution looks like\\n\\n```\\npublic int numPairsDivisibleBy60(int[] time) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint count = 0;\\n\\tfor(int i = 0; i < time.length; i++){\\n\\t\\tint mod = time[i] % 60;\\n\\t\\tcount += map.getOrDefault((60 - mod) % 60, 0);\\n\\t\\tmap.put(mod, map.getOrDefault(mod, 0) + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tmap.put(0, -1);\\n\\tint sum = 0;\\n\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\tsum += nums[i];\\n\\t\\tint mod = sum % k;\\n\\t\\tif(i - map.getOrDefault(mod, i) >= 2) return true;\\n\\t\\tmap.putIfAbsent(mod, i);\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\npublic int numPairsDivisibleBy60(int[] time) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint count = 0;\\n\\tfor(int i = 0; i < time.length; i++){\\n\\t\\tint mod = time[i] % 60;\\n\\t\\tcount += map.getOrDefault((60 - mod) % 60, 0);\\n\\t\\tmap.put(mod, map.getOrDefault(mod, 0) + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422095,
                "title": "o-n-explanation-you-deserve-with-c-c-code",
                "content": "It is easier to understand if you review a few concepts, so lets do that first:\\n\\nA known property of mod: (a + b) % k = 0 is same as ((a % k) + (b % k)) % k = 0 \\n\\nsomething you can do in O(N), keep a running sum in some global. Lets call it currSum.\\n\\n```\\n        int currSum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum += nums[i];\\n\\t\\t}\\n```\\n\\nNow you have all the information you need to solve in O(N) time, but gotta do some math real quick. Your currSum above is relative to the start of the array at index 0.  If you had stored(just to understand better) the currSum result into an array at each index of the loop in some array called sum[], then sum[x] would be sum of all numbers from index 0 to x.\\n\\nExample:\\nsum[0] = nums[0]\\nsum[1] = nums[0] + nums[1]\\nsum[2] = nums[0] + nums[1] + nums[2]\\nsum[x] = nums[0] + nums[1] + nums[2] ... nums[x]\\n\\nSo far all of the above can be done in O(N) time in a single loop.\\nNow problem is asking if there exists any continous subarray where sum is multiple of k. Lets assume your continous subArray is from i to j, where i < j. Can you find any i, j where this is true?\\nLets derive the sum of i to j from sum[] which we already calcluated in O(N) time.\\n\\nsum(i,j) = sum[j] -  sum[i] + nums[i] <---- Think about that a little bit and understand why this is true, very important!\\n\\nNow what is the condition we are trying to solve for? Well we are trying to find any continous subarray sum such that sum(i,j) % k = 0. If you find any i, j where i<j then such a continous subarray exists. \\n\\nsum(i,j) % k = 0 and if you sub the equation above you get:\\n(sum[j] - sum[i] + nums[i]) % k  = 0\\n\\nNow how do we rewrite the equation above so that it works with our single O(N) for loop. Well at each step of the for loop, your currSum global after being updated is sum[j]. So lets solve for the (sum[j] %k) term here. Remember the first rule of mod I showed at the start, use that to solve it.\\n\\n(sum[j] % k) + ((nums[i] - sum[i]) % k) = 0\\nsum[j] % k = -1 * ((nums[i] - sum[i]) % k) <-----Final equation\\n\\nNow look at your final equation and you will realize you have all the information at each step of that O(N) loop. \\n\\n sum[j] % k: The sum[j] is just your currSum at each step in the loop, k is a known constant. \\n  -1 * ((nums[i] - sum[i]) % k): since i < j, you can always save this to a hash map at the END of current iteration, and just use the left side of the equation at the start of iteration to see if any such result existed in the past iteration of that loop(remember i < j). currSum after you have used to search in the hash map is now the past at the end of the loop, so in that context it then is the sum[i] part of the equation(remember i < j).\\n  If you find a match in your hash table, you have found a continuous subarrray that satisifies your condition. Final code below:\\n  \\n  ```\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        map<int, bool> modMap;\\n        \\n        int currSum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum += nums[i];\\n            auto iter = modMap.find(currSum % k);\\n            if (iter != modMap.end()) {\\n                return true;\\n            }\\n        \\n            int rightSideOfEquation = -1 * ((nums[i] - currSum) % k);\\n            modMap[rightSideOfEquation] = true;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\n        int currSum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum += nums[i];\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1334704,
                "title": "java-o-n-solution-inspired-by-most-votes-answer-with-detailed-comments",
                "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // to acheive O(N), the key here is to understand if(a % k == b % k), (a - b) % k == 0\\n        \\n        int runningSum = 0;\\n        Map<Integer, Integer> runningSumModToIndex = new HashMap<>();\\n        // if there is a prefixSum (running sum)\\'s mod is zero, we should be able to return true\\n        runningSumModToIndex.put(0, -1);\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            runningSum += nums[i];\\n            int mod = runningSum % k;\\n            if(runningSumModToIndex.containsKey(mod)) {\\n                // check if the subarray\\'s length at least 2\\n                if(i - runningSumModToIndex.get(mod) > 1) {\\n                    return true;\\n                }\\n            }\\n            else {\\n                // if not seen before, we add to map. Note: we should not update to the latest index so that \\n                // we can get the correct answer when the middle number is 0.\\n                runningSumModToIndex.put(mod, i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // to acheive O(N), the key here is to understand if(a % k == b % k), (a - b) % k == 0\\n        \\n        int runningSum = 0;\\n        Map<Integer, Integer> runningSumModToIndex = new HashMap<>();\\n        // if there is a prefixSum (running sum)\\'s mod is zero, we should be able to return true\\n        runningSumModToIndex.put(0, -1);\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            runningSum += nums[i];\\n            int mod = runningSum % k;\\n            if(runningSumModToIndex.containsKey(mod)) {\\n                // check if the subarray\\'s length at least 2\\n                if(i - runningSumModToIndex.get(mod) > 1) {\\n                    return true;\\n                }\\n            }\\n            else {\\n                // if not seen before, we add to map. Note: we should not update to the latest index so that \\n                // we can get the correct answer when the middle number is 0.\\n                runningSumModToIndex.put(mod, i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680238,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\nvar checkSubarraySum = function(nums, k) {\\n\\n    let sum = 0\\n    const hash = {}\\n    hash[0] = -1\\n    \\n    for (let i = 0; i<nums.length; i++) {\\n        sum += nums[i]\\n        \\n        if (k!=0) sum %= k\\n        \\n        if ( hash[sum] !== undefined   ) {\\n            if(i-hash[sum]>1) return true\\n        } else {\\n            hash[sum] = i\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar checkSubarraySum = function(nums, k) {\\n\\n    let sum = 0\\n    const hash = {}\\n    hash[0] = -1\\n    \\n    for (let i = 0; i<nums.length; i++) {\\n        sum += nums[i]\\n        \\n        if (k!=0) sum %= k\\n        \\n        if ( hash[sum] !== undefined   ) {\\n            if(i-hash[sum]>1) return true\\n        } else {\\n            hash[sum] = i\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 404815,
                "title": "c-hashmap-and-prefix-sum",
                "content": "```C++\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n\\tunordered_map<int, int> map;\\n\\tmap[0] = -1;\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tsum += nums[i];\\n\\t\\tif (k != 0) {\\n\\t\\t\\tsum %= k;\\n\\t\\t}\\n\\t\\tif (map.find(sum) != map.end()) {\\n\\t\\t\\tif (i - map[sum] > 1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tmap[sum] = i;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n\\tunordered_map<int, int> map;\\n\\tmap[0] = -1;\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tsum += nums[i];\\n\\t\\tif (k != 0) {\\n\\t\\t\\tsum %= k;\\n\\t\\t}\\n\\t\\tif (map.find(sum) != map.end()) {\\n\\t\\t\\tif (i - map[sum] > 1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tmap[sum] = i;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326044,
                "title": "this-problem-explains-why-our-life-is-hard",
                "content": "I finished it with only several lines less than 5 mins.\\nThen I met a lot of corner cases.\\nI tried agian and again which took me an hour.\\nAt last, I even didn\\'t know my code.\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        if len(nums) <= 1:\\n            return False\\n         \\n        if k == 0:\\n            for i in range(len(nums)-1):\\n                if nums[i] == 0 and nums[i+1] == 0:\\n                    return True\\n            return False\\n        d = {0:1}\\n\\n        while nums and nums[0] == 0:\\n            nums.pop(0)\\n        if len(nums) == 0:\\n            return True\\n\\t\\t#This is the original part :(\\n        s = nums[0]\\n        for i in nums[1:]:\\n            s = s + i\\n            if s % k in d:\\n                return True\\n            else:\\n                d[(s-i)%k] = 1\\n        return False",
                "solutionTags": [],
                "code": "class Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        if len(nums) <= 1:\\n            return False\\n         \\n        if k == 0:\\n            for i in range(len(nums)-1):\\n                if nums[i] == 0 and nums[i+1] == 0:\\n                    return True\\n            return False\\n        d = {0:1}",
                "codeTag": "Java"
            },
            {
                "id": 275219,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        cur_sum = 0\\n        cache = {0:-1}\\n        \\n        for i in range(len(nums)):\\n            cur_sum+=nums[i]\\n            if k!=0:\\n                cur_sum %= k\\n            if cur_sum in cache:\\n                if i - cache[cur_sum] > 1:\\n                    return True\\n            else:\\n                cache[cur_sum] = i\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        cur_sum = 0\\n        cache = {0:-1}\\n        \\n        for i in range(len(nums)):\\n            cur_sum+=nums[i]\\n            if k!=0:\\n                cur_sum %= k\\n            if cur_sum in cache:\\n                if i - cache[cur_sum] > 1:\\n                    return True\\n            else:\\n                cache[cur_sum] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99511,
                "title": "my-cpp-solution-using-unordered-map-o-n-time-and-o-k-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if (nums.size() < 2) return false;\\n        if (k == 0) k = INT_MAX;\\n        int sum = 0;\\n        unordered_map<int, int> map;\\n        map[0] = -1;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (map.find(sum % k) == map.end()) {\\n                map[sum % k] = i;\\n            } else {\\n                if (i - map[sum % k] > 1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if (nums.size() < 2) return false;\\n        if (k == 0) k = INT_MAX;\\n        int sum = 0;\\n        unordered_map<int, int> map;\\n        map[0] = -1;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (map.find(sum % k) == map.end()) {\\n                map[sum % k] = i;\\n            } else {\\n                if (i - map[sum % k] > 1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765108,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        map<int,int> m={{0,-1}};\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(!m.count(rem)) m[rem]=i;\\n            else if(i-m[rem]>1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        map<int,int> m={{0,-1}};\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(!m.count(rem)) m[rem]=i;\\n            else if(i-m[rem]>1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746158,
                "title": "fastest-solution-you-can-get-tc-o-n-sc-o-n",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        dc=defaultdict(lambda:[])\\n        st=0\\n        dc[0]=[-1]\\n        for i in range(len(nums)):\\n            st=(st+nums[i])%k\\n            if(dc[st]!=[] and dc[st][0]<i-1):\\n                return True\\n            dc[st].append(i)\\n        return False\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        dc=defaultdict(lambda:[])\\n        st=0\\n        dc[0]=[-1]\\n        for i in range(len(nums)):\\n            st=(st+nums[i])%k\\n            if(dc[st]!=[] and dc[st][0]<i-1):\\n                return True\\n            dc[st].append(i)\\n        return False\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744320,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefix_mod = set()\\n        previous_mod = None\\n        total = 0\\n        for idx, num in enumerate(nums):\\n            total += num\\n            mod = total % k\\n            if idx > 0 and (mod == 0 or mod in prefix_mod) : return True\\n            prefix_mod.add(previous_mod)\\n            previous_mod = mod\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefix_mod = set()\\n        previous_mod = None\\n        total = 0\\n        for idx, num in enumerate(nums):\\n            total += num\\n            mod = total % k\\n            if idx > 0 and (mod == 0 or mod in prefix_mod) : return True\\n            prefix_mod.add(previous_mod)\\n            previous_mod = mod\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278050,
                "title": "python-simple-prefix-sum-and-hashmap",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        dic = {0:-1}\\n        n = len(nums)\\n        prefix = 0\\n        for i in range(n):\\n            prefix = (prefix + nums[i])%k\\n            if prefix not in dic:\\n                dic[prefix] = i\\n            else:\\n                if (i - dic[prefix]) >= 2:\\n                    return True\\n        return False\\n```\\nTime : O(n)\\nSpace : O(n)\\nPlease **UPVOTE**.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        dic = {0:-1}\\n        n = len(nums)\\n        prefix = 0\\n        for i in range(n):\\n            prefix = (prefix + nums[i])%k\\n            if prefix not in dic:\\n                dic[prefix] = i\\n            else:\\n                if (i - dic[prefix]) >= 2:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691328,
                "title": "3-approaches-naive-to-efficient-map-and-set-both-approaches-simple-easy-c",
                "content": "Implementation\\n\\n**1st\\nNaive Approach\\nGiving TLE\\nTime Complexity = O(N^2), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int sum = nums[0];\\n        for(int itr = 1; itr < nums.size(); itr++){\\n            sum += nums[itr];\\n            if(sum % k == 0) return true;\\n            \\n            int temp = sum;\\n            for(int jtr = 0; jtr < itr-1; jtr++){\\n                temp -= nums[jtr];\\n                if(temp % k == 0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n**2nd\\nEfficient Approach\\nUsing unodered_map\\nTime Complexity = O(N), Space Complexity = O(K)**\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        // taking a map to store the key as a remainder and value as a current index+1\\n        unordered_map<int, int> mp;        \\n        mp[0] = 0;\\n        int sum = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // if remainder is present into map, then check the index of the present remainder into map, and the current index, if the length is more than or equal to 2, it means, we got the subarray of minimum length 2 \\n            if(mp.find(sumMod) != mp.end()){\\n                if(itr+1 - mp[sumMod] >= 2) return true;\\n            }\\n            else{   // if remainder is not present into map, then just put that remainder as a key and value as current index+1;\\n                mp[sumMod] = itr+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n**3rd\\nEfficient Approach\\nUsing unodered_set\\nTime Complexity = O(N), Space Complexity = O(K)**\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        // taking a set to store the previous remainder\\n        unordered_set<int> st;          \\n        int sum = 0, previousRem = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // if count of sumMod in set is more than 0, it means, we got the subarray of minimum length 2 \\n            if(st.count(sumMod)) return true;\\n            \\n            // insert the previousRem\\n            st.insert(previousRem);\\n            previousRem = sumMod;\\n        }\\n        return false;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int sum = nums[0];\\n        for(int itr = 1; itr < nums.size(); itr++){\\n            sum += nums[itr];\\n            if(sum % k == 0) return true;\\n            \\n            int temp = sum;\\n            for(int jtr = 0; jtr < itr-1; jtr++){\\n                temp -= nums[jtr];\\n                if(temp % k == 0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        // taking a map to store the key as a remainder and value as a current index+1\\n        unordered_map<int, int> mp;        \\n        mp[0] = 0;\\n        int sum = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // if remainder is present into map, then check the index of the present remainder into map, and the current index, if the length is more than or equal to 2, it means, we got the subarray of minimum length 2 \\n            if(mp.find(sumMod) != mp.end()){\\n                if(itr+1 - mp[sumMod] >= 2) return true;\\n            }\\n            else{   // if remainder is not present into map, then just put that remainder as a key and value as current index+1;\\n                mp[sumMod] = itr+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        // taking a set to store the previous remainder\\n        unordered_set<int> st;          \\n        int sum = 0, previousRem = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // if count of sumMod in set is more than 0, it means, we got the subarray of minimum length 2 \\n            if(st.count(sumMod)) return true;\\n            \\n            // insert the previousRem\\n            st.insert(previousRem);\\n            previousRem = sumMod;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605504,
                "title": "c-tc-o-n-sc-o-n-explained",
                "content": "**LOGIC:**\\nWe will store the modulus of sum in hash-set or hash-map. If the modulus already exist then return true.\\nExample:\\nnums = [23,2,7,1,8], k = 6\\n\\n![image](https://assets.leetcode.com/users/images/80e9fd8a-5f0d-432c-8215-ddbdd3ae5d59_1638337820.4330573.png)\\n\\n\\n**CATCH:**\\n1. We need to insert 0 in the hash-set/map initially, for example, for nums = [1,2,3] and k = 6\\n2. We need to avoid cases where nums[i] = 0\\n3. If two or more nums are 0 then we have to return true, as a subarray [0,0] is valid for all k\\n4. We need to maintain hash-map instead of hash-set, as requirement here is that the sub-array must have a size atleast of two, so we need to check if the hash found is not in the last index.\\n\\n**CODE:**\\n```\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> uMapModK;\\n        uMapModK[0] = -1;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] != 0){\\n                sum += nums[i];\\n                if(uMapModK.find(sum%k) != uMapModK.end()){\\n                    if(uMapModK[sum%k] != i-1)\\n                        return true;\\n                }\\n                else\\n                    uMapModK[sum%k] = i;\\n            }\\n            else{\\n                if(i > 0 && nums[i-1] == 0)\\n                    return true;\\n                if(i < nums.size()-1 && nums[i+1] == 0)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> uMapModK;\\n        uMapModK[0] = -1;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] != 0){\\n                sum += nums[i];\\n                if(uMapModK.find(sum%k) != uMapModK.end()){\\n                    if(uMapModK[sum%k] != i-1)\\n                        return true;\\n                }\\n                else\\n                    uMapModK[sum%k] = i;\\n            }\\n            else{\\n                if(i > 0 && nums[i-1] == 0)\\n                    return true;\\n                if(i < nums.size()-1 && nums[i+1] == 0)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587822,
                "title": "c-explained-with-examples-easy-93",
                "content": "**We have to use maths to solve this question**\\ncreate presum array of given array\\nwe know that presum works for continuous subarray, and If required continuous subarray exist then,\\n\\n(presum[i]- presum[random])%k = 0     {where, i - random >= 2}\\n=> presum[i]%k - presum[random]%k = 0\\n=> presum[i]%k = presum[random]%k      \\n\\nSo we can say if there exist some random index which is having same remainder and diffence of i - random >= 2 then continuous subarray exists. so we need to keep track of remainders instead of sums.\\n\\n**Example**. \\nk = 6 and arr 1 3 0 0 6 => presum = 1 4 4 4 6 => presumremainders = 1 4 4 4 0\\nwe can solve this using remainders \\n4 at i = 3  and 4 at i = 1 => (presum[3] - presum[1]) % k = 0\\nHence we return true.\\n# *But*\\nk = 6 and  arr  =  1 3 0 6 => presum = 1 4 4 6 => remainders = 1 4 4 0\\nNow we cannot solve this using remainders approach, because differnce of remainders index should be greater than or eqaul to 2 hence we have to saparatly verify subarray for consecutive numbers.\\n**Upvote \\uD83D\\uDE07\\uD83D\\uDE4C\\uD83C\\uDFFB**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1)return false;\\n        \\n        unordered_map<int, int> m;\\n        int sum = nums[0];\\n        m[sum%k] = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            sum += nums[i];\\n            if(sum%k == 0)return true;\\n            // this only handles non consecutive numbers\\n            if(m.find(sum%k) != m.end() && i - m[sum%k] >= 2)return true;\\n            // to handle two consecutive numbers in the actual array\\n            if( (nums[i-1] + nums[i]) %k == 0)return true; \\n            m[sum%k] = i;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1)return false;\\n        \\n        unordered_map<int, int> m;\\n        int sum = nums[0];\\n        m[sum%k] = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            sum += nums[i];\\n            if(sum%k == 0)return true;\\n            // this only handles non consecutive numbers\\n            if(m.find(sum%k) != m.end() && i - m[sum%k] >= 2)return true;\\n            // to handle two consecutive numbers in the actual array\\n            if( (nums[i-1] + nums[i]) %k == 0)return true; \\n            m[sum%k] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1582670,
                "title": "python-easy-solution-brute-force-and-optimal-approach",
                "content": "\\tclass Solution:\\n\\t\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\t\\t\\t# Brute Force: O(\\uD835\\uDC5B^2) - TLE\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tsum = 0\\n\\t\\t\\t\\tfor j in range(i, len(nums)):\\n\\t\\t\\t\\t\\tsum += nums[j]\\n\\t\\t\\t\\t\\tif sum % k == 0:\\n\\t\\t\\t\\t\\t   return True\\n\\t\\t\\treturn False\\n\\n\\tclass Solution:\\n\\t\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\t\\t\\t# Optimal Approach - Time and Space: O(n), O(n)\\n\\t\\t\\tres = {0: -1}\\n\\t\\t\\tprefSum = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tprefSum += nums[i]\\n\\t\\t\\t\\trem = prefSum % k\\n\\t\\t\\t\\tif rem in res:\\n\\t\\t\\t\\t\\tif i-res[rem] > 1:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[rem] = i\\n\\t\\t\\treturn False\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n\\t\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\t\\t\\t# Brute Force: O(\\uD835\\uDC5B^2) - TLE\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tsum = 0\\n\\t\\t\\t\\tfor j in range(i, len(nums)):\\n\\t\\t\\t\\t\\tsum += nums[j]\\n\\t\\t\\t\\t\\tif sum % k == 0:\\n\\t\\t\\t\\t\\t   return True\\n\\t\\t\\treturn False\\n\\n\\tclass Solution:\\n\\t\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\t\\t\\t# Optimal Approach - Time and Space: O(n), O(n)\\n\\t\\t\\tres = {0: -1}",
                "codeTag": "Java"
            },
            {
                "id": 1568794,
                "title": "python-simple-solution-with-detailed-comments-prefixsum-hashmap",
                "content": "\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefix_sums = defaultdict(lambda:float(inf))        \\n        #Key is prefix_sum%k, value is earliest occurence of the same prefix_sum   \\n        \\n        running_sum = 0\\n        for i, n in enumerate(nums):\\n            running_sum += n\\n            mod_sum = running_sum%k\\n            #If running_sum%k = 0 + other_sum%k for a value other_sum in prefix_sum \\n            #then we can subtract the other_sum and we\\'ll have a multiple of k\\n            \\n            #Subarray must have at least 2 elements so we will not return True in cases of having just one element\\n            #or subtracting the prefix_sum right before the current one\\n            if i >= 1 and (mod_sum == 0 or prefix_sums[mod_sum] < i - 1):\\n                return True\\n            \\n            #We wouldn\\'t need to keep track of minimum position if we could have subarray of size 1\\n            prefix_sums[mod_sum] = min(prefix_sums[mod_sum], i)\\n                \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefix_sums = defaultdict(lambda:float(inf))        \\n        #Key is prefix_sum%k, value is earliest occurence of the same prefix_sum   \\n        \\n        running_sum = 0\\n        for i, n in enumerate(nums):\\n            running_sum += n\\n            mod_sum = running_sum%k\\n            #If running_sum%k = 0 + other_sum%k for a value other_sum in prefix_sum \\n            #then we can subtract the other_sum and we\\'ll have a multiple of k\\n            \\n            #Subarray must have at least 2 elements so we will not return True in cases of having just one element\\n            #or subtracting the prefix_sum right before the current one\\n            if i >= 1 and (mod_sum == 0 or prefix_sums[mod_sum] < i - 1):\\n                return True\\n            \\n            #We wouldn\\'t need to keep track of minimum position if we could have subarray of size 1\\n            prefix_sums[mod_sum] = min(prefix_sums[mod_sum], i)\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448897,
                "title": "c-solution-using-hashmap-with-explanation",
                "content": "```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n       \\n        /*\\n            accumulative sums can calculated in a single loop, i.e. list below can be done in O(n)\\n            \\u03A3nums[0], \\u03A3nums[0..1], \\u03A3nums[0..2],..\\u03A3nums[0..i]..\\u03A3nums[0..j]..\\u03A3nums[0..n]\\n            \\n            also prefix sum (this is the basic premise)\\n            \\u03A3nums[i..j]  = \\u03A3nums[0..j]-\\u03A3nums[0..i-1] ; where j>i.\\n            \\n            Question can be rephrased as find \\u03A3nums[i..j] such that\\n            \\u03A3nums[i..j]%k==0 and j-i>=2\\n            \\n            from line #9 \\n            \\u03A3nums[i..j]%k = 0 can be written as\\n            \\n            \\u03A3nums[0..j]%k - \\u03A3nums[0..i-1]%k = 0\\n            \\n            reducing above \\n            \\u03A3nums[0..j]%k - \\u03A3nums[0..i-1]%k = 0\\n            we get\\n            \\n            \\u03A3nums[0..j]%k = \\u03A3nums[0..i-1]%k  (this is the other premise on which solution is based)\\n            \\n            Now this problem can be rephrased as\\n            \\n            while on jth element and having accumulated values till j\\n            find if we have \\u03A3nums[0..j]%k from accumulation before \\n            and ensure current index j - index (where we have found this remainder before) is >= 2.\\n        */\\n        \\n        \\n        var hash = new Dictionary<int,int>();\\n        hash.Add(0,-1); //this is \\u03A3nums[0..0] = \\u03A3nums[0..0] - \\u03A3nums[0..0-1]  \\n        int sumi = 0;\\n        for(int j=0; j<nums.Length; j++ ) {\\n        \\n            var sumj = sumi+nums[j];\\n            \\n            int remainderToFind = sumj % k;\\n            \\n            if(hash.TryGetValue(remainderToFind,out int foundIndex) && Math.Abs(foundIndex-j)>=2) {\\n                return true;\\n            }\\n            sumi = sumj;\\n            if(!hash.TryGetValue(remainderToFind,out int _))\\n                hash.Add(remainderToFind, j);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n       \\n        /*\\n            accumulative sums can calculated in a single loop, i.e. list below can be done in O(n)\\n            \\u03A3nums[0], \\u03A3nums[0..1], \\u03A3nums[0..2],..\\u03A3nums[0..i]..\\u03A3nums[0..j]..\\u03A3nums[0..n]\\n            \\n            also prefix sum (this is the basic premise)\\n            \\u03A3nums[i..j]  = \\u03A3nums[0..j]-\\u03A3nums[0..i-1] ; where j>i.\\n            \\n            Question can be rephrased as find \\u03A3nums[i..j] such that\\n            \\u03A3nums[i..j]%k==0 and j-i>=2\\n            \\n            from line #9 \\n            \\u03A3nums[i..j]%k = 0 can be written as\\n            \\n            \\u03A3nums[0..j]%k - \\u03A3nums[0..i-1]%k = 0\\n            \\n            reducing above \\n            \\u03A3nums[0..j]%k - \\u03A3nums[0..i-1]%k = 0\\n            we get\\n            \\n            \\u03A3nums[0..j]%k = \\u03A3nums[0..i-1]%k  (this is the other premise on which solution is based)\\n            \\n            Now this problem can be rephrased as\\n            \\n            while on jth element and having accumulated values till j\\n            find if we have \\u03A3nums[0..j]%k from accumulation before \\n            and ensure current index j - index (where we have found this remainder before) is >= 2.\\n        */\\n        \\n        \\n        var hash = new Dictionary<int,int>();\\n        hash.Add(0,-1); //this is \\u03A3nums[0..0] = \\u03A3nums[0..0] - \\u03A3nums[0..0-1]  \\n        int sumi = 0;\\n        for(int j=0; j<nums.Length; j++ ) {\\n        \\n            var sumj = sumi+nums[j];\\n            \\n            int remainderToFind = sumj % k;\\n            \\n            if(hash.TryGetValue(remainderToFind,out int foundIndex) && Math.Abs(foundIndex-j)>=2) {\\n                return true;\\n            }\\n            sumi = sumj;\\n            if(!hash.TryGetValue(remainderToFind,out int _))\\n                hash.Add(remainderToFind, j);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372238,
                "title": "number-theory-modulo-congruency-and-prefix-sums-o-n-c-code",
                "content": "Incremental Intuition and Improvements\\n\\nIf there exists a consecutive subarray that the sum of all its elements is a multiple of k, then the length must be at least 2.\\n\\nUsing Basic prefix sums. For each index in the prefix sum array we can check if a valid array ends here.\\n\\nFor instance array:\\n\\n23, 2, 4, 6,  7 will yield prefix sum array  0, 23, 25, 29, 35, 42\\n\\nif we fix any two indexes i  and j (i < j) in our prefix array, \\nWe know that prefix[j] - prefix[i] will give us the sum of original array[i] to orginal array[j-1].\\n\\nSo for every element we can find an array ending at this element, say at index j in O(N^2)  by iterating i over the prefix sum array from the beginning and seeing if any sum will be divisible by K.\\n\\nThe bottleneck with this approach is that it is O(N^2) and will not pass the time constraints.\\n\\nSince we know we are just looking for any element that appeared to the left of our current element  that (prefix[j] - prefix[i]) % k == 0, we can use a simple lemma in Number Theory.\\n\\nIt states that if the difference of 2 numbers modulo k == 0, then the both numbers mod k are equal.\\n\\nIn more formal terms:\\n\\nif ( |a-b| ) %  k == 0 then a % k == b % k;\\n\\nWith this knowledge we can create a modulo array and mod each element in our prefix Sum \\n\\nFrom the previous example our mod array will be \\n\\n0 5 1 5 5 0\\n\\nWhile traversing the array we can keep the first index we see any modulo value in say a hashmap. If we see the same modulo value and the distance is >= 3 we have found an answer.\\n\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> prefixSum(n+1, 0);\\n        for(int i = 1; i <= n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        }\\n        vector<int> mods(n+1, 0);\\n        for(int i = 0; i <= n; i++) {\\n            mods[i] = prefixSum[i] % k;\\n        }\\n        unordered_map<int, int> seenModulos;\\n        \\n        for(int i = 0; i <= n; i++) {\\n            if(seenModulos.find(mods[i]) == seenModulos.end()) {\\n                seenModulos[mods[i]] = i;\\n                continue;\\n            }\\n            int firstOccurrenceIdx = seenModulos[mods[i]];\\n            if(firstOccurrenceIdx < i - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> prefixSum(n+1, 0);\\n        for(int i = 1; i <= n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        }\\n        vector<int> mods(n+1, 0);\\n        for(int i = 0; i <= n; i++) {\\n            mods[i] = prefixSum[i] % k;\\n        }\\n        unordered_map<int, int> seenModulos;\\n        \\n        for(int i = 0; i <= n; i++) {\\n            if(seenModulos.find(mods[i]) == seenModulos.end()) {\\n                seenModulos[mods[i]] = i;\\n                continue;\\n            }\\n            int firstOccurrenceIdx = seenModulos[mods[i]];\\n            if(firstOccurrenceIdx < i - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355473,
                "title": "python-dict-solution",
                "content": "```\\n\"\"\"\\ns - prefix sum\\nsum(i, j) = s[j] - s[i - 1]\\n(s[i - 1] - s[j]) = kn\\ns[i - 1] = kn + s[j]\\ns[i - 1] =modk==s[j]\\n\"\"\"\\n\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        currentSum = 0\\n        d = dict()\\n        for i, s in enumerate([0] + nums):\\n            currentSum += s\\n            modk = currentSum % k\\n            if modk in d: \\n                if i - d[modk] >= 2:\\n                    return True\\n            else:\\n                d[modk] = i\\n            \\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\ns - prefix sum\\nsum(i, j) = s[j] - s[i - 1]\\n(s[i - 1] - s[j]) = kn\\ns[i - 1] = kn + s[j]\\ns[i - 1] =modk==s[j]\\n\"\"\"\\n\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        currentSum = 0\\n        d = dict()\\n        for i, s in enumerate([0] + nums):\\n            currentSum += s\\n            modk = currentSum % k\\n            if modk in d: \\n                if i - d[modk] >= 2:\\n                    return True\\n            else:\\n                d[modk] = i\\n            \\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289887,
                "title": "100-faster-solution-with-explanation-2ms-java",
                "content": "**Do upvote incase it helps you!**\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n=nums.length;\\n        //Initialize an array of length n and store sum of the nums so far in the arrya\\n        int dp[]= new int[n];dp[0]=nums[0]; //dp[0]  = nums[0]\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=nums[i]+dp[i-1]; // keep summing up the nums values\\n            // have to check the zero first \\n             if(nums[i]==0&&nums[i-1]==0)return true;//2 consecutive nums summing to 0 is true since 0 is considered as multiple\\n             if(dp[i]%k==0)return true;\\n        }\\n        \\n        if(dp[n-1]<k)return false;\\n        \\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=i+2;j<n;j++)\\n            {\\n                if((dp[j]-dp[i])%k==0)return true;\\n            }\\n        }\\n    return false;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n=nums.length;\\n        //Initialize an array of length n and store sum of the nums so far in the arrya\\n        int dp[]= new int[n];dp[0]=nums[0]; //dp[0]  = nums[0]\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=nums[i]+dp[i-1]; // keep summing up the nums values\\n            // have to check the zero first \\n             if(nums[i]==0&&nums[i-1]==0)return true;//2 consecutive nums summing to 0 is true since 0 is considered as multiple\\n             if(dp[i]%k==0)return true;\\n        }\\n        \\n        if(dp[n-1]<k)return false;\\n        \\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=i+2;j<n;j++)\\n            {\\n                if((dp[j]-dp[i])%k==0)return true;\\n            }\\n        }\\n    return false;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106579,
                "title": "c-linear-time-with-hash-set-of-size-k-with-explanations",
                "content": "**Key points:**\\n* The basic idea is very simple, if we keep adding numbers up and save off the remainder for each spot, for sample input we got this:\\n```\\n[23, 2, 4, 6, 7],  k=6 \\nSums: 23, 25, 29, 35, 42\\nRemainder: 5, 1, 5, 0\\n```\\n* Here as soon as 5 show up for the second time, the difference between the two sums must be n\\\\*k. Here 29-23 = 6 and it is because 2+4 = 6.\\n* I use a unordered_map to remember which remainder appeared before so we can return true as soon as it show up second time. Since remainders never go beyond k, the max size is k.\\n* When the sum remainder is 0 it means all numbers add up to current spot met the condition. I can either put 0 as remainder in lookup map or add one extra test before lookup.\\n* Note it doesn\\'t count if same number show up without any gap since the problem require a two number sequence. [1, 6] 6=6 gives remainder list of 1, 1 but it should be false.\\n* I did an even/odd buffer switch to delay the insertion into the remainder lookup map. If the question extend from minimum 2 number to n number sequence, I will need a real n size buffer.\\n* What? k can be 0! Cost me a wrong submit since we can\\'t %0. In that case we just look for two adjacent 0s in the list. As a matter of fact, it is the magic solution for all since 0\\\\*k = 0 + 0.\\n* Watch out for list shorter than 2. Another wrong submit.\\n* k can be negative, Another wrong submit. Sad day. Now I understand why many people hated this problem.\\n* Linear time to visit all numbers, k size memory to keep a remainder lookup. On average, 20ms 26 MB.\\n```\\n  bool checkSubarraySum(vector<int>& nums, int k) {\\n    if (nums.size() < 2)\\n      return false;\\n    for (int i=1; i<nums.size(); ++i)\\n      if (nums[i] == 0 && nums[i-1] == 0)\\n        return true;\\n    if (k != 0) {\\n      k = abs(k);\\n      unordered_set<int> remainders;\\n      int twoAhead[2] = {nums[0]%k, 0};\\n      for (int i=1; i<nums.size(); ++i) {\\n        twoAhead[i%2] = (nums[i] + twoAhead[(i+1)%2])%k;\\n        if (twoAhead[i%2] == 0 || remainders.find(twoAhead[i%2]) != remainders.end())\\n          return true;\\n        remainders.insert(twoAhead[(i+1)%2]);\\n      }\\n    }\\n    return false;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[23, 2, 4, 6, 7],  k=6 \\nSums: 23, 25, 29, 35, 42\\nRemainder: 5, 1, 5, 0\\n```\n```\\n  bool checkSubarraySum(vector<int>& nums, int k) {\\n    if (nums.size() < 2)\\n      return false;\\n    for (int i=1; i<nums.size(); ++i)\\n      if (nums[i] == 0 && nums[i-1] == 0)\\n        return true;\\n    if (k != 0) {\\n      k = abs(k);\\n      unordered_set<int> remainders;\\n      int twoAhead[2] = {nums[0]%k, 0};\\n      for (int i=1; i<nums.size(); ++i) {\\n        twoAhead[i%2] = (nums[i] + twoAhead[(i+1)%2])%k;\\n        if (twoAhead[i%2] == 0 || remainders.find(twoAhead[i%2]) != remainders.end())\\n          return true;\\n        remainders.insert(twoAhead[(i+1)%2]);\\n      }\\n    }\\n    return false;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074860,
                "title": "swift-easy-to-understand-o-n-solution-with-explaination",
                "content": "```\\n/*\\nif module of two numbers by k are same, then their difference will be divisible by k\\na%k = x\\nb%k = x\\nthis leads to\\n(a-b)%k = 0\\na and b are cumulative sum at index i and j\\n*/\\nclass Solution {\\n    func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool {\\n        \\n        var dict = [Int:Int]()\\n        dict[0] = -1\\n        var runningSum = 0\\n        for (index,value) in nums.enumerated() {\\n            runningSum = runningSum + value\\n            if(k != 0) {\\n                runningSum = runningSum % k\\n            }\\n            if let prev = dict[runningSum] {\\n                //this check because we require subarray of atleast size 2\\n                if(index - prev > 1) {\\n                    return true\\n                }\\n            }\\n            else {\\n                dict[runningSum] = index\\n            }\\n        }\\n        return false\\n    }\\n} \\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/*\\nif module of two numbers by k are same, then their difference will be divisible by k\\na%k = x\\nb%k = x\\nthis leads to\\n(a-b)%k = 0\\na and b are cumulative sum at index i and j\\n*/\\nclass Solution {\\n    func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool {\\n        \\n        var dict = [Int:Int]()\\n        dict[0] = -1\\n        var runningSum = 0\\n        for (index,value) in nums.enumerated() {\\n            runningSum = runningSum + value\\n            if(k != 0) {\\n                runningSum = runningSum % k\\n            }\\n            if let prev = dict[runningSum] {\\n                //this check because we require subarray of atleast size 2\\n                if(index - prev > 1) {\\n                    return true\\n                }\\n            }\\n            else {\\n                dict[runningSum] = index\\n            }\\n        }\\n        return false\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 372718,
                "title": "java-onepass-solution-with-explanations",
                "content": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n\\tif(nums == null || nums.length == 0)\\n\\t\\treturn false;\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tmap.put(0, -1);\\n\\tint sum=0;\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tsum += nums[i];\\n\\t\\tif(k!=0)\\n\\t\\t\\tsum %= k;\\n\\t\\tInteger target = map.get(sum);\\n\\t\\tif(target != null){\\n\\t\\t\\tif(i-target > 1)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tmap.put(sum, i);\\n\\t\\t\\t//only put new pairs into map when it is a sum value, this is because if we update the key \"sum\"\\'s value, a right subarray might be ignored\\n\\t}\\n\\treturn false;\\n}\\n```\\nFirstly, if we get  sums of numbers in array, then it is important to know that the sum of a subarray can be deprived from substracting those sums. Like in the array[23, 2, 4, 6, 7] and its **sum array**[23, 25, 29, 35, 42], a sum of the subarray[2, 4, 6] can be get from 35-23. \\n\\nThen since the problem requires the sum to be nk, x+n*k and x+m*k will be two numbers from the sum array that produce the right subarray. \\n\\nSo as we traversing from front to end, we calculate to get new sums and store them in a map, and at the same time, we know whether there is subarray that sums to be n*k.",
                "solutionTags": [],
                "code": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n\\tif(nums == null || nums.length == 0)\\n\\t\\treturn false;\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tmap.put(0, -1);\\n\\tint sum=0;\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tsum += nums[i];\\n\\t\\tif(k!=0)\\n\\t\\t\\tsum %= k;\\n\\t\\tInteger target = map.get(sum);\\n\\t\\tif(target != null){\\n\\t\\t\\tif(i-target > 1)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tmap.put(sum, i);\\n\\t\\t\\t//only put new pairs into map when it is a sum value, this is because if we update the key \"sum\"\\'s value, a right subarray might be ignored\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3003558,
                "title": "easy-c-and-java-solution-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprefix sum in map\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n\\n\\n# Code\\nJava Map solution \\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        m.put(0,-1);\\n        int sum = 0;\\n        for (int i=0;i<nums.length;i++) {\\n            sum += nums[i];\\n            if (k != 0) sum %= k;\\n\\n            if(m.containsKey(sum)){\\n                if(i - m.get(sum) > 1){\\n                    return true;\\n                }\\n            }\\n\\n            else m.put(sum, i);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# Code\\nC++ Map solution\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        m[0] = -1;\\n        int sum = 0;\\n\\n        for(int i = 0;i < nums.size();i++){\\n            sum += nums[i];\\n            if(k != 0){\\n                sum %= k;\\n            }\\n\\n            if(m.count(sum) > 0){\\n                if(i - m[sum] > 1) return true;\\n            }\\n            else{\\n                m[sum] = i;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        m.put(0,-1);\\n        int sum = 0;\\n        for (int i=0;i<nums.length;i++) {\\n            sum += nums[i];\\n            if (k != 0) sum %= k;\\n\\n            if(m.containsKey(sum)){\\n                if(i - m.get(sum) > 1){\\n                    return true;\\n                }\\n            }\\n\\n            else m.put(sum, i);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        m[0] = -1;\\n        int sum = 0;\\n\\n        for(int i = 0;i < nums.size();i++){\\n            sum += nums[i];\\n            if(k != 0){\\n                sum %= k;\\n            }\\n\\n            if(m.count(sum) > 0){\\n                if(i - m[sum] > 1) return true;\\n            }\\n            else{\\n                m[sum] = i;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748287,
                "title": "",
                "content": "\\uD835\\uDC0C\\uD835\\uDC1A\\uD835\\uDC2D\\uD835\\uDC21: 25%6 ==1 also (25+6)==1 or (25+12)==1 so on..\\nThis means if the remainder is same , then the subarray between 25 and agla sum jiska remainder 6 hoga is divisible by six. Thats it.\\nEg: -          [25,3,3,1] \\nremainder :[1,4,1,2]  .  Index [1,2] is divisible by 6.\\n\\n\\nyaha apan hash map mein remainder store kr rahe hain index ke sath , jab bhi kabhi same remainder wapas aayega yani uss index aur  current index ke bich ka subarray ka sum definitely divisible hoga \"k\" se toh apan true return kr denge aur agar nhi mila toh last mein false return hoga .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n       unordered_map<int,int> mp;\\n        int sum=0;\\n        mp[0]=-1;  // ye important hai agr future m kisika remainder 0 aya to return true ke liye\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(mp.find(sum%k)!=mp.end()){\\n                if(i-mp[sum%k]>=2) return true;\\n            }\\n            else mp[sum%k]=i;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\uD835\\uDC0F\\uD835\\uDC25\\uD835\\uDC1E\\uD835\\uDC1A\\uD835\\uDC2C\\uD835\\uDC1E \\uD835\\uDC14\\uD835\\uDC29\\uD835\\uDC2F\\uD835\\uDC28\\uD835\\uDC2D\\uD835\\uDC1E",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n       unordered_map<int,int> mp;\\n        int sum=0;\\n        mp[0]=-1;  // ye important hai agr future m kisika remainder 0 aya to return true ke liye\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(mp.find(sum%k)!=mp.end()){\\n                if(i-mp[sum%k]>=2) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2745757,
                "title": "java-map-solution-with-explanation-and-comments",
                "content": "**Intution and Little Maths to understand the solution** \\n\\n* If we create a prefix sum array (`prefix`) of the given nums array then, \\n* Let two indices low and high, low < high.\\n* Now if we have to find the sum from low to high we can easily do `prefix[high] - prefix[low - 1]`, which we give the sum of that subarray.\\n* But to find an answer we have to do step 3 for all the subarrays which will exceed the TC.\\n* **Now here comes the math part**\\n* Let diff be the difference between two indices a and b, a < b.\\n* So `diff = prefix[b] - prefix[a]`. Take `mod by k both sides`\\n* `diff % k = (prefix[b] - prefix[a]) % k`.\\n* `diff % k = prefix[b] % k - prefix[a] % k`.\\n* Now to be a valid answer `diff % k `should be equal to 0.\\n* Therefore,` 0 = prefix[b] % k - prefix[a] % k`.\\n* `prefix[b] % k = prefix[a] % k`.  **Final Derivation**\\n* Now our problem reduces to that, **we have to find two indices a and b such that prefix[b] % k = prefix[a] % k.**\\n\\n**Working**\\n\\n* Use a map to store the prefix sum and their index. So that we can access it all the previous prefix sum stored.\\n* Start iterating the nums array and put the `sum % k to map\\'s key and current index as value`.\\n* If the map already contains the sum and difference between indices is gretaer than 1 then we have our answer return true.\\n* We have one more situation which is if our `sum % k becomes zero` and index diffrenece is greater then 1 then this is also a valid answer return true.\\n\\n\\n\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n\\t\\t// Initialize the map\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int prefixSum = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n\\t\\t\\t// Prefix sum which will have sum of all previous elements.\\n            prefixSum += nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// Mod by k\\n            prefixSum %= k;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// If our prefixSum becomes 0 at any point for index gretaer than 0 the return true.\\n            if(prefixSum == 0 && i > 0){\\n                return true;\\n            }\\n            \\n\\t\\t\\t// If prefixSum is already there in map and the difference between current index and that index gretaer than 1.\\n            if(map.containsKey(prefixSum) && i - map.get(prefixSum) > 1){\\n                return true;\\n            }\\n            \\n\\t\\t\\t// At last put the prefixSum and the current in the map.\\n            if(!map.containsKey(prefixSum)){\\n                map.put(prefixSum, i);\\n            }            \\n            \\n        }\\n             \\n\\t\\t// Return false if no such subarray is found.\\n        return false;\\n        \\n    }\\n}\\n```\\n\\nPlease UpVote!!!",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n\\t\\t// Initialize the map\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int prefixSum = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n\\t\\t\\t// Prefix sum which will have sum of all previous elements.\\n            prefixSum += nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// Mod by k\\n            prefixSum %= k;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// If our prefixSum becomes 0 at any point for index gretaer than 0 the return true.\\n            if(prefixSum == 0 && i > 0){\\n                return true;\\n            }\\n            \\n\\t\\t\\t// If prefixSum is already there in map and the difference between current index and that index gretaer than 1.\\n            if(map.containsKey(prefixSum) && i - map.get(prefixSum) > 1){\\n                return true;\\n            }\\n            \\n\\t\\t\\t// At last put the prefixSum and the current in the map.\\n            if(!map.containsKey(prefixSum)){\\n                map.put(prefixSum, i);\\n            }            \\n            \\n        }\\n             \\n\\t\\t// Return false if no such subarray is found.\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745274,
                "title": "rust-hash-set-with-comments",
                "content": "Compute the prefix sums mod `k` of `nums`. Record the prefix sums that occur up to `i-2` (if any) when considering the prefix sum up to position `i`. If we have recorded a prefix sum with the same remainder mod `k`, the current remainder and the recorded remainder will cancel out when we compute the difference of the current prefix sum and the recorded prefix sum => we have found an interval where the numbers sum up to an even multiple of `k`.\\n\\nImplementation notes:\\n* Using `scan` is pretty neat here to keep the hash set contained in the scan state instead of having to declare it outside a for loop.\\n* Delay the insertion of the prefix sum until after we have checked the set to consider intervals of minimum length 2.\\n* `then(...)` and `or_else(...)` for a nice and concise `scan` body, where we skip insertion if we have found our target.\\n* `any` for an early return.\\n\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn check_subarray_sum(nums: Vec<i32>, k: i32) -> bool {\\n        nums.into_iter().scan((HashSet::<i32>::new(), 0), |(set, prefix_sum), num| {\\n            let new_prefix_sum = (*prefix_sum + num) % k;\\n            set.contains(&new_prefix_sum).then(|| true).or_else(|| {\\n                set.insert(*prefix_sum);\\n                *prefix_sum = new_prefix_sum;\\n                Some(false)\\n            })\\n        }).any(|found| found)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn check_subarray_sum(nums: Vec<i32>, k: i32) -> bool {\\n        nums.into_iter().scan((HashSet::<i32>::new(), 0), |(set, prefix_sum), num| {\\n            let new_prefix_sum = (*prefix_sum + num) % k;\\n            set.contains(&new_prefix_sum).then(|| true).or_else(|| {\\n                set.insert(*prefix_sum);\\n                *prefix_sum = new_prefix_sum;\\n                Some(false)\\n            })\\n        }).any(|found| found)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745211,
                "title": "c-unordered-map-easy-solution-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        //Create a hashmap of the running_sum remainder and it\\'s respective index\\n        unordered_map<int,int> mpp;\\n        \\n        \\n        //Why to insert <0,-1> for the hashmap\\n        \\n        // <0,-1> can allow it to return true when the runningSum%k=0,\\n        \\n        //for example [1,2,3] is input and k=6\\n        //then the remainders are [ 1,3,0] i.e runningSum = runningSum%k\\n        //now 1+2+3=6 which is actually a multiple of 6 and hence 0 should be stored in the hashmap\\n        \\n        //ok - but why -1?\\n        //-1 is good for storing for 0 because - it will remove the case where we consider only the first element which alone may be a multiple as 0-(-1) is not greater than 1\\n        \\n        // In addition, it also avoids the first element of the array is the multiple of k, since 0-(-1)=1 is not greater than 1.\\n        mpp[0] = -1;\\n        \\n        //Initialsize sum\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            int remainder = sum%k;\\n            \\n             //check if the runningsum already exists in the hashmap\\n            if(mpp.find(remainder) != mpp.end()){\\n                \\n                 //if it exists, then the current location minus the previous location must be greater than1\\n                if(i - mpp[remainder] >= 2){\\n                    return true;\\n                }\\n            }\\n                else\\n                {\\n                    //otherwise if the current runningSum doesn\\'t exist in the hashmap, then store it as it maybe used later on\\n                    mpp[remainder] = i;\\n                }\\n        }\\n        return false;\\n     }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        //Create a hashmap of the running_sum remainder and it\\'s respective index\\n        unordered_map<int,int> mpp;\\n        \\n        \\n        //Why to insert <0,-1> for the hashmap\\n        \\n        // <0,-1> can allow it to return true when the runningSum%k=0,\\n        \\n        //for example [1,2,3] is input and k=6\\n        //then the remainders are [ 1,3,0] i.e runningSum = runningSum%k\\n        //now 1+2+3=6 which is actually a multiple of 6 and hence 0 should be stored in the hashmap\\n        \\n        //ok - but why -1?\\n        //-1 is good for storing for 0 because - it will remove the case where we consider only the first element which alone may be a multiple as 0-(-1) is not greater than 1\\n        \\n        // In addition, it also avoids the first element of the array is the multiple of k, since 0-(-1)=1 is not greater than 1.\\n        mpp[0] = -1;\\n        \\n        //Initialsize sum\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            int remainder = sum%k;\\n            \\n             //check if the runningsum already exists in the hashmap\\n            if(mpp.find(remainder) != mpp.end()){\\n                \\n                 //if it exists, then the current location minus the previous location must be greater than1\\n                if(i - mpp[remainder] >= 2){\\n                    return true;\\n                }\\n            }\\n                else\\n                {\\n                    //otherwise if the current runningSum doesn\\'t exist in the hashmap, then store it as it maybe used later on\\n                    mpp[remainder] = i;\\n                }\\n        }\\n        return false;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744928,
                "title": "java-simple-solution-easy-understanding",
                "content": "if p % q == 0 then it means p is multiple of q. Same concept we used here\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        hm.put(0, 0);\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            \\n            if(!hm.containsKey(sum % k)){   // if map does not contains that remainder then it means including this index we haven\\'t found any subarray which can give remainder 0 so, we put that remainder on that index\\n                hm.put(sum % k, i + 1);\\n            }else if(hm.get(sum % k) < i){    // if we found same remainder before this index then it means we get 0 remainder and then we will check  (sum % k) index should not come out just before it because subarray size must be atleast 2.\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        hm.put(0, 0);\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            \\n            if(!hm.containsKey(sum % k)){   // if map does not contains that remainder then it means including this index we haven\\'t found any subarray which can give remainder 0 so, we put that remainder on that index\\n                hm.put(sum % k, i + 1);\\n            }else if(hm.get(sum % k) < i){    // if we found same remainder before this index then it means we get 0 remainder and then we will check  (sum % k) index should not come out just before it because subarray size must be atleast 2.\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744521,
                "title": "c-unordered-map-95-fast",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkSubarraySum(vector<int>& nums, int k) {\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif(k==1)\\n\\t\\t\\t\\treturn true;        \\n\\t\\t\\tint mod=nums[0]%k;\\n\\t\\t\\tmp[mod]=0;\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmod=(mod+nums[i])%k;\\n\\t\\t\\t\\tif(mod==0|| (mp.find(mod)!=mp.end() && mp[mod]!=i-1  ))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tif(mp.find(mod)==mp.end())\\n\\t\\t\\t\\t\\tmp[mod]=i;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkSubarraySum(vector<int>& nums, int k) {\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif(k==1)\\n\\t\\t\\t\\treturn true;        \\n\\t\\t\\tint mod=nums[0]%k;\\n\\t\\t\\tmp[mod]=0;\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmod=(mod+nums[i])%k;\\n\\t\\t\\t\\tif(mod==0|| (mp.find(mod)!=mp.end() && mp[mod]!=i-1  ))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tif(mp.find(mod)==mp.end())\\n\\t\\t\\t\\t\\tmp[mod]=i;\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2744430,
                "title": "ruby-map-1-k",
                "content": "```ruby\\ndef check_subarray_sum(nums, k)\\n    nums.map! { _1 % k }\\n    nums.each_cons(2) { return true if _1 == [0,0] }\\n    return false if nums.sum < k\\n    n = nums.length\\n    (0..n-2).each do |i|\\n        mod = nums[i]\\n        (i+1..n-1).each do |j|\\n            mod = (mod + nums[j]) % k\\n            return true if mod.zero?\\n        end\\n    end\\n    false\\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_check_subarray_sum < Test::Unit::TestCase\\n    def test_\\n        assert_equal true, check_subarray_sum([23,2,4,6,7], k = 6)\\n        assert_equal true, check_subarray_sum([23,2,6,4,7], k = 6)\\n        assert_equal false, check_subarray_sum([23,2,6,4,7], k = 13)\\n        assert_equal true, check_subarray_sum([23,2,4,6,6], k = 7)\\n        assert_equal false, check_subarray_sum([1617,4991,12564,3903,8881], k = 2000000000)\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef check_subarray_sum(nums, k)\\n    nums.map! { _1 % k }\\n    nums.each_cons(2) { return true if _1 == [0,0] }\\n    return false if nums.sum < k\\n    n = nums.length\\n    (0..n-2).each do |i|\\n        mod = nums[i]\\n        (i+1..n-1).each do |j|\\n            mod = (mod + nums[j]) % k\\n            return true if mod.zero?\\n        end\\n    end\\n    false\\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_check_subarray_sum < Test::Unit::TestCase\\n    def test_\\n        assert_equal true, check_subarray_sum([23,2,4,6,7], k = 6)\\n        assert_equal true, check_subarray_sum([23,2,6,4,7], k = 6)\\n        assert_equal false, check_subarray_sum([23,2,6,4,7], k = 13)\\n        assert_equal true, check_subarray_sum([23,2,4,6,6], k = 7)\\n        assert_equal false, check_subarray_sum([1617,4991,12564,3903,8881], k = 2000000000)\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744345,
                "title": "java-using-map",
                "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        boolean flag=false;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        int sum=0,rem=0;\\n        for(int j=0;j<nums.length;j++){\\n            sum+=nums[j];\\n            rem=sum%k;\\n            if(map.containsKey(rem)){\\n                int i=map.get(rem);\\n                if(j-i>=2){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            else{\\n                map.put(rem,j);\\n            }\\n        }\\n        return flag==true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        boolean flag=false;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        int sum=0,rem=0;\\n        for(int j=0;j<nums.length;j++){\\n            sum+=nums[j];\\n            rem=sum%k;\\n            if(map.containsKey(rem)){\\n                int i=map.get(rem);\\n                if(j-i>=2){\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            else{\\n                map.put(rem,j);\\n            }\\n        }\\n        return flag==true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744325,
                "title": "c-linear",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> m={{0,-1}};\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(!m.count(rem)) m[rem]=i;\\n            else if(i-m[rem]>1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> m={{0,-1}};\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(!m.count(rem)) m[rem]=i;\\n            else if(i-m[rem]>1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744253,
                "title": "daily-leetcoding-challenge-october-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/continuous-subarray-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/continuous-subarray-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2410304,
                "title": "java-easy-to-understand-o-n-solution",
                "content": "public boolean checkSubarraySum(int[] arr, int k) {\\n        int sum = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n            int rem = sum%k;\\n            if(map.containsKey(rem)){\\n                if(i-map.get(rem)>=2){\\n                    return true;\\n                }else{\\n                    map.put(rem,map.get(rem));\\n                    continue;\\n                }\\n            }\\n            map.put(rem,i);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "public boolean checkSubarraySum(int[] arr, int k) {\\n        int sum = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n            int rem = sum%k;\\n            if(map.containsKey(rem)){\\n                if(i-map.get(rem)>=2){\\n                    return true;\\n                }else{\\n                    map.put(rem,map.get(rem));\\n                    continue;\\n                }\\n            }\\n            map.put(rem,i);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2299294,
                "title": "java-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n//(a+(n*x))%x is same as (a%x). For e.g. in case of the array [23,2,6,4,7] the running sum is [23,25,31,35,42] and the remainders are [5,1,1,5,0]. We got remainder 5 at index 0 and at index 3. That means, in between these two indexes we must have added a number which is multiple of the k.\\n    \\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        if(k == 0 || n < 2) {       \\n            return false;\\n        }\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        int runningSum = 0;\\n        map.put(0, -1);\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            runningSum += nums[i];  \\n            runningSum %= k;\\n\\t\\t\\t\\n            if(map.containsKey(runningSum)) {   //we check for the remainder\\n                if(i - map.get(runningSum) > 1) {   //we check if the length is greater than 1\\n                    return true;\\n                }\\n            } else {\\n                map.put(runningSum, i);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n\\n// TimeComplexity : O(n)\\n// Space Complexity : O(k)\\n//Please upvote the solution if you like it.\\n```\\nAlso check out my GitHub repository (https://github.com/Ovaishk/DSA-Problems-for-Placement) for solution to other important DSA Problems !!!\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n//(a+(n*x))%x is same as (a%x). For e.g. in case of the array [23,2,6,4,7] the running sum is [23,25,31,35,42] and the remainders are [5,1,1,5,0]. We got remainder 5 at index 0 and at index 3. That means, in between these two indexes we must have added a number which is multiple of the k.\\n    \\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        if(k == 0 || n < 2) {       \\n            return false;\\n        }\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        int runningSum = 0;\\n        map.put(0, -1);\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            runningSum += nums[i];  \\n            runningSum %= k;\\n\\t\\t\\t\\n            if(map.containsKey(runningSum)) {   //we check for the remainder\\n                if(i - map.get(runningSum) > 1) {   //we check if the length is greater than 1\\n                    return true;\\n                }\\n            } else {\\n                map.put(runningSum, i);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n\\n// TimeComplexity : O(n)\\n// Space Complexity : O(k)\\n//Please upvote the solution if you like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239600,
                "title": "c-simple-straight-prefix-sum-implementation",
                "content": "**Please do upvote if you liked my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        int prefixSum = 0;\\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            prefixSum += nums[i];\\n            prefixSum = prefixSum%k;\\n            \\n            if(prefixSum == 0 and i) return true;\\n            \\n            if(m.find(prefixSum) != m.end())\\n            {\\n                if(i-m[prefixSum] > 1) return true;\\n            }\\n            else m[prefixSum] = i;\\n        }\\n        return false;\\n    }\\n};\\n    \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        int prefixSum = 0;\\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            prefixSum += nums[i];\\n            prefixSum = prefixSum%k;\\n            \\n            if(prefixSum == 0 and i) return true;\\n            \\n            if(m.find(prefixSum) != m.end())\\n            {\\n                if(i-m[prefixSum] > 1) return true;\\n            }\\n            else m[prefixSum] = i;\\n        }\\n        return false;\\n    }\\n};\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881416,
                "title": "java-simple-solution-using-set-with-comments",
                "content": "\\t/*\\n\\t\\tinput nums = [23,2,4,6,7], k = 6\\n\\t\\tcalculate the prefix sum   [23, 25, 29, 35, 42]\\n\\t\\tvalue = current - previous\\n\\t\\twe need to find value%k == 0 which means\\n\\t\\twe can find (current - previous)%k == 0 ==> current%k == previous%k\\n\\t\\tin every iteration compute current prefix sum and perform % k\\n\\t\\tif set contains the mod return true\\n\\t\\telse add to set\\n    */\\n    \\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // k = k == 0 ? Integer.MAX_VALUE : (k < 0 ? -k : k);\\n        Set<Integer> set = new HashSet<>();\\n        int last = 0; // the prefix sum one element earlier\\n        for (int num : nums) {\\n            int cur = (last + num) % k; // get newest prefix sum mod k\\n            if (set.contains(cur)) return true;\\n            set.add(last); // add old prefix sum into HashSet\\n            last = cur; // update old prefix sum\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "\\t/*\\n\\t\\tinput nums = [23,2,4,6,7], k = 6\\n\\t\\tcalculate the prefix sum   [23, 25, 29, 35, 42]\\n\\t\\tvalue = current - previous\\n\\t\\twe need to find value%k == 0 which means\\n\\t\\twe can find (current - previous)%k == 0 ==> current%k == previous%k\\n\\t\\tin every iteration compute current prefix sum and perform % k\\n\\t\\tif set contains the mod return true\\n\\t\\telse add to set\\n    */\\n    \\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        // k = k == 0 ? Integer.MAX_VALUE : (k < 0 ? -k : k);\\n        Set<Integer> set = new HashSet<>();\\n        int last = 0; // the prefix sum one element earlier\\n        for (int num : nums) {\\n            int cur = (last + num) % k; // get newest prefix sum mod k\\n            if (set.contains(cur)) return true;\\n            set.add(last); // add old prefix sum into HashSet\\n            last = cur; // update old prefix sum\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1761190,
                "title": "easiest-java-solution-using-hashmap",
                "content": "```\\n#**Please upvote if you like the Solution\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n       int psum=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,-1);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            psum+=nums[i];\\n            int rem=psum%k;\\n            if(hm.containsKey(rem))\\n            {\\n                if(i-hm.get(rem)>=2)\\n                return true;\\n            }else\\n            {\\n                hm.put(rem,i);\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n       int psum=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,-1);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            psum+=nums[i];\\n            int rem=psum%k;\\n            if(hm.containsKey(rem))\\n            {\\n                if(i-hm.get(rem)>=2)\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1759817,
                "title": "easy-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n       int psum=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,-1);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            psum+=nums[i];\\n            int rem=psum%k;\\n            if(hm.containsKey(rem))\\n            {\\n                if(i-hm.get(rem)>=2)\\n                return true;\\n            }else\\n            {\\n                hm.put(rem,i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n       int psum=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,-1);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            psum+=nums[i];\\n            int rem=psum%k;\\n            if(hm.containsKey(rem))\\n            {\\n                if(i-hm.get(rem)>=2)\\n                return true;\\n            }else\\n            {\\n                hm.put(rem,i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677458,
                "title": "c-o-n-time-o-n-space-one-pass",
                "content": "\\tbool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return false;\\n        unordered_map <int,int> mp;\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            int mod = sum % k;\\n            if(mod == 0 && i >= 1) return true;\\n            if(mp.find(mod) == mp.end()) mp[mod] = i;\\n            else if(mp.find(mod) != mp.end() && i - mp[mod] >= 2) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "\\tbool checkSubarraySum(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return false;\\n        unordered_map <int,int> mp;\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            int mod = sum % k;\\n            if(mod == 0 && i >= 1) return true;\\n            if(mp.find(mod) == mp.end()) mp[mod] = i;\\n            else if(mp.find(mod) != mp.end() && i - mp[mod] >= 2) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1562568,
                "title": "simple-python-solution-accumulative-mod",
                "content": "Simplified version based on @ZitaoWang idea\\n\\nTime O(N) Space worst case O(N) unless k is found earlier\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        myDict={0:-1} #For edge cases where the first index is included in the solution ex: [2,4] k=3\\n        total=0\\n        \\n        for idx,n in enumerate(nums):\\n            total+=n\\n            \\n            if total%k not in myDict:\\n                myDict[total%k]=idx \\n            \\n            elif idx - myDict[total%k]>=2:\\n                return True\\n        return False\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        myDict={0:-1} #For edge cases where the first index is included in the solution ex: [2,4] k=3\\n        total=0\\n        \\n        for idx,n in enumerate(nums):\\n            total+=n\\n            \\n            if total%k not in myDict:\\n                myDict[total%k]=idx \\n            \\n            elif idx - myDict[total%k]>=2:\\n                return True\\n        return False\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542636,
                "title": "visual-explanation",
                "content": "I had trouble understanding this problem, but thinking of it like a wheel helped me to figure it out.\\n\\nLet\\'s look at the example of:\\n```\\nnums = [23, 9, 1, 2, 6, 7]\\nk = 6\\n```\\n\\nImagine you have a wheel spinner like the one here with k segments:\\n![image](https://assets.leetcode.com/users/images/6a5f7655-3b40-4659-8c12-d73c628202e5_1635295616.2030134.png)\\n\\nYou will start with the arrow pointing to 0. For each number `num` in `nums`, you will spin the spinner `num` times. The result will be that the arrow will be offset somewhat from 0. You continue to spin the spinner `num` times at each step, and record the resulting offset. If you see the same offset twice at indices `i` and `j`, that would imply that there exist some numbers between `i` and `j` which sum to a multipe of `k`.\\n\\nLet\\'s walk through our example:\\nStart with `offset = 0`\\nIn round 1, we spin the arrow 23 places. This leaves the arrow pointing to 5.\\nIn round 2, we spin the arrow 9 more places. The arrow ends up pointing at 2. 2 != 5, so as we can see, 9 is not a multiple of 6.\\nIn round 3, we spin the arrow 1 place. The arrow now points to 3. We have not seen an offset of 3 before, so we know that we have not encountered a solution yet.\\nIn round 4, we spin the arrow 2 more places. The arrow now points to 5. We have seen 5 before! We now know that a solution exists in our array. Between rounds 2 and 4, the arrow went `5 => 2 => => 3 => 5`, so the nums in steps 2, 3, and 4 must sum to 6 (or a multiple of 6). In this case, `9 + 1 + 2 = 12`.\\n\\nHere is the code:\\n```\\nclass Solution():\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        seen_offsets = {0:-1} # Dict to track offsets we have seen before\\n        offset = 0 # Start with the arrow pointing to 0\\n        for index, num in enumerate(nums):\\n            # Spin the arrow num times, and calculate the new offset\\n            offset = (offset + num) % k \\n            # If this is an offset we have not seen before, record it\\n            if offset not in seen_offsets:\\n                seen_offsets[offset] = index\\n            # If we have seen the offset before, we have a valid subarray\\n            else:\\n                if index - seen_offsets[offset] > 1: # Subarray length must be > 1\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nnums = [23, 9, 1, 2, 6, 7]\\nk = 6\\n```\n```\\nclass Solution():\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        seen_offsets = {0:-1} # Dict to track offsets we have seen before\\n        offset = 0 # Start with the arrow pointing to 0\\n        for index, num in enumerate(nums):\\n            # Spin the arrow num times, and calculate the new offset\\n            offset = (offset + num) % k \\n            # If this is an offset we have not seen before, record it\\n            if offset not in seen_offsets:\\n                seen_offsets[offset] = index\\n            # If we have seen the offset before, we have a valid subarray\\n            else:\\n                if index - seen_offsets[offset] > 1: # Subarray length must be > 1\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527499,
                "title": "c-good-question-using-map",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        int remainder=0;\\n        m[0]=-1;\\n        for(int i=0;i<nums.size();++i){\\n            remainder+=nums[i];\\n           if(k!=0) remainder%=k;\\n            if(m.find(remainder)!=m.end()){\\n                if(i - m[remainder] > 1) return true;\\n            } else m[remainder]=i;\\n        }\\n        return false;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        int remainder=0;\\n        m[0]=-1;\\n        for(int i=0;i<nums.size();++i){\\n            remainder+=nums[i];\\n           if(k!=0) remainder%=k;\\n            if(m.find(remainder)!=m.end()){\\n                if(i - m[remainder] > 1) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1368985,
                "title": "java-o-n-solution-using-hashmap",
                "content": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        //if length of array is less than 2 then answer not possible\\n        if(nums.length<2)\\n            return false;\\n        HashMap<Integer,Integer>hmap=new HashMap<Integer,Integer>();\\n        \\n        //if we get 2 consecutive 0\\'s for any k,return true\\n        //since (0+0)%k=0\\n        for(int i=1;i<nums.length;i++)\\n            if(nums[i]==0 && nums[i-1]==0)\\n                return true;\\n        \\n        //for k=0,only two or more consecutive 0\\'s were possible\\n        if(k==0)\\n            return false;\\n        \\n        int curr_sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            curr_sum+=nums[i];\\n            \\n            //if subarray starting fron index 0 is a multiple of k\\n            if(curr_sum%k==0 && i>0)\\n                return true;\\n            if(hmap.containsKey(curr_sum%k))\\n                if(i-hmap.get(curr_sum%k)>1)//size of subarray should be more than 1\\n                    return true;\\n            hmap.put(curr_sum%k,i);\\n        }\\n        return false;\\n            \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        //if length of array is less than 2 then answer not possible\\n        if(nums.length<2)\\n            return false;\\n        HashMap<Integer,Integer>hmap=new HashMap<Integer,Integer>();\\n        \\n        //if we get 2 consecutive 0\\'s for any k,return true\\n        //since (0+0)%k=0\\n        for(int i=1;i<nums.length;i++)\\n            if(nums[i]==0 && nums[i-1]==0)\\n                return true;\\n        \\n        //for k=0,only two or more consecutive 0\\'s were possible\\n        if(k==0)\\n            return false;\\n        \\n        int curr_sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            curr_sum+=nums[i];\\n            \\n            //if subarray starting fron index 0 is a multiple of k\\n            if(curr_sum%k==0 && i>0)\\n                return true;\\n            if(hmap.containsKey(curr_sum%k))\\n                if(i-hmap.get(curr_sum%k)>1)//size of subarray should be more than 1\\n                    return true;\\n            hmap.put(curr_sum%k,i);\\n        }\\n        return false;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176727,
                "title": "easy-to-understand-with-explanation-c-0-n-0-n-space-maths-explanation",
                "content": "Sum will contains all the subarray sum  from (0,i) index.\\nTo find all the sum of subarray let (2,5) = Sum(0,5) - Sum(0,1)\\nsum1 = Sum(0,5)\\nsum 2= Sum(0,1)\\nNow , we have to find is (sum1-sum2) % k == 0  =>  (sum1) % k = (sum2)%k\\nStore the (sum1) % k , (sum2) % k in map check ,  that both are same with idx diff > 1 (for length 2 or more).\\n\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        size_t n = nums.size();\\n        int sum=0;\\n        if(n>0){\\n           sum = nums[0]; \\n        }\\n        int key = sum % k;\\n        unordered_map<int,int> ump;\\n        ump.insert({key,0});\\n\\n        for(int i=1;i<n;i++){\\n            sum+=nums[i];\\n            key = sum%k;\\n            if(key==0 || (ump.count(key)>0 && (i - ump[key]) > 1)){\\n                return true;\\n            }\\n            ump.insert({key,i});\\n        }\\n        return false;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        size_t n = nums.size();\\n        int sum=0;\\n        if(n>0){\\n           sum = nums[0]; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 797279,
                "title": "c-solution-o-n-unordered-map",
                "content": "```\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n    if(nums.size() < 2) return false;\\n    k = k == 0 ? INT_MAX : k;\\n    unordered_map<int,int> um;\\n    int sum = 0;\\n    um[0] = -1; //To handle cases like [0,0] which is a valid answer\\n    for(int i=0; i<nums.size(); i++){\\n        sum += nums[i];\\n        if(um.find(sum % k) != um.end()){\\n            if(i - um[sum % k] > 1)    // \"> 1\" in order to handle cases like [0,1,0]\\n                return true;\\n        }else{\\n            um[sum%k] = i;\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nbool checkSubarraySum(vector<int>& nums, int k) {\\n    if(nums.size() < 2) return false;\\n    k = k == 0 ? INT_MAX : k;\\n    unordered_map<int,int> um;\\n    int sum = 0;\\n    um[0] = -1; //To handle cases like [0,0] which is a valid answer\\n    for(int i=0; i<nums.size(); i++){\\n        sum += nums[i];\\n        if(um.find(sum % k) != um.end()){\\n            if(i - um[sum % k] > 1)    // \"> 1\" in order to handle cases like [0,1,0]\\n                return true;\\n        }else{\\n            um[sum%k] = i;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650209,
                "title": "c-solution-with-easy-math-explanation",
                "content": "![image](https://assets.leetcode.com/users/jasperjoe/image_1590355420.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkSubarraySum(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()<=1) return false;\\n\\t\\t\\tif(k==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[i]==0 && nums[i+1]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tunordered_set<int> Set;\\n\\t\\t\\tSet.insert(0);\\n\\t\\t\\tint presum2=0;\\n\\t\\t\\tint pre=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpresum2+=nums[i];\\n\\t\\t\\t\\tif(i>=2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpre+=nums[i-2];\\n\\t\\t\\t\\t\\tSet.insert(pre%k);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(i>=1 && Set.count(presum2%k)) return true;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkSubarraySum(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()<=1) return false;\\n\\t\\t\\tif(k==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[i]==0 && nums[i+1]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 633009,
                "title": "java-use-remainder",
                "content": "Orig: https://leetcode.com/problems/continuous-subarray-sum/discuss/99499/Java-O(n)-time-O(k)-space\\n```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        for (int i = 0, sum = 0; i < nums.length; ++i) {\\n            sum += nums[i];\\n            int rem = k == 0 ? sum : sum % k;\\n            if (map.containsKey(rem)) {\\n                if (map.get(rem) <= i - 2) return true;\\n            } else map.put(rem, i);\\n        }\\n        return false;\\n    }\\n```\\n\\nMore concise:\\n```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        for (int i = 0, sum = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (k != 0) sum = sum % k;\\n            if (map.containsKey(sum)) {\\n                if (i - map.get(sum) >= 2) return true;\\n            } else map.put(sum, i);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        for (int i = 0, sum = 0; i < nums.length; ++i) {\\n            sum += nums[i];\\n            int rem = k == 0 ? sum : sum % k;\\n            if (map.containsKey(rem)) {\\n                if (map.get(rem) <= i - 2) return true;\\n            } else map.put(rem, i);\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        for (int i = 0, sum = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (k != 0) sum = sum % k;\\n            if (map.containsKey(sum)) {\\n                if (i - map.get(sum) >= 2) return true;\\n            } else map.put(sum, i);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499006,
                "title": "o-n-javascript-readable-code-for-humans-with-comments",
                "content": "```js\\n// hashmap solution\\nvar checkSubarraySum = function(nums, k) {\\n    let map = {}\\n    let sum = 0\\n    map[0] = -1\\n    for(let i = 0; i< nums.length; i++) {\\n        sum += nums[i]\\n        if(k !== 0) { // we dont care about total sum, since we only care about modulo results. \\n            sum = sum % k\\n        }\\n        if(map[sum] !== undefined) { // means there is subarray sum derived from difference in sum modulo k exists\\n          if(i - map[sum] > 1) { // length >= 2\\n              return true\\n          }\\n        } else {\\n            map[sum] = i\\n        }\\n    }\\n    return false\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n// hashmap solution\\nvar checkSubarraySum = function(nums, k) {\\n    let map = {}\\n    let sum = 0\\n    map[0] = -1\\n    for(let i = 0; i< nums.length; i++) {\\n        sum += nums[i]\\n        if(k !== 0) { // we dont care about total sum, since we only care about modulo results. \\n            sum = sum % k\\n        }\\n        if(map[sum] !== undefined) { // means there is subarray sum derived from difference in sum modulo k exists\\n          if(i - map[sum] > 1) { // length >= 2\\n              return true\\n          }\\n        } else {\\n            map[sum] = i\\n        }\\n    }\\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3292739,
                "title": "523-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a dictionary to store the remainders and their corresponding indices. Initialize the dictionary with {0: -1} to handle the edge case when the cumulative sum of the numbers is a multiple of k.\\n\\n2. Traverse through the list, updating the remainder at each index with the current number.\\n\\n3. If k is not 0, take the remainder of the current sum when divided by k.\\n\\n4. If the current remainder is already in the dictionary, and the difference between the current index and the index of the previous occurrence of the same remainder is at least 2, we have found a subarray whose sum is a multiple of k. Return True.\\n\\n5. If the current remainder is not in the dictionary, add it with its corresponding index.\\n\\n6. If we have traversed through the whole list and haven\\'t found a subarray, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # Create a dictionary to store the remainders and their corresponding indices\\n        remainder_dict = {0: -1}\\n        remainder = 0\\n        \\n        # Traverse through the list\\n        for i in range(len(nums)):\\n            # Update the remainder with the current number\\n            remainder += nums[i]\\n            \\n            # If k is not 0, take the remainder when divided by k\\n            if k != 0:\\n                remainder %= k\\n            \\n            # If the current remainder is already in the dictionary,\\n            # and the difference between the current index and the index\\n            # of the previous occurrence of the same remainder is at least 2,\\n            # we have found a subarray whose sum is a multiple of k\\n            if remainder in remainder_dict:\\n                if i - remainder_dict[remainder] >= 2:\\n                    return True\\n            else:\\n                # If the current remainder is not in the dictionary,\\n                # add it with its corresponding index\\n                remainder_dict[remainder] = i\\n        \\n        # If we have traversed through the whole list and haven\\'t found a subarray,\\n        # return False\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # Create a dictionary to store the remainders and their corresponding indices\\n        remainder_dict = {0: -1}\\n        remainder = 0\\n        \\n        # Traverse through the list\\n        for i in range(len(nums)):\\n            # Update the remainder with the current number\\n            remainder += nums[i]\\n            \\n            # If k is not 0, take the remainder when divided by k\\n            if k != 0:\\n                remainder %= k\\n            \\n            # If the current remainder is already in the dictionary,\\n            # and the difference between the current index and the index\\n            # of the previous occurrence of the same remainder is at least 2,\\n            # we have found a subarray whose sum is a multiple of k\\n            if remainder in remainder_dict:\\n                if i - remainder_dict[remainder] >= 2:\\n                    return True\\n            else:\\n                # If the current remainder is not in the dictionary,\\n                # add it with its corresponding index\\n                remainder_dict[remainder] = i\\n        \\n        # If we have traversed through the whole list and haven\\'t found a subarray,\\n        # return False\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208351,
                "title": "python-92-faster-prefix-sum-dictionary",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        n=len(nums)\\n        s=0\\n        d={0:-1}\\n        for i in range(n):\\n            s=(s+nums[i])%k\\n            if s not in d:\\n                d[s]=i\\n            else:\\n                if i-d[s]>1:\\n                    return True\\n        return False               \\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        n=len(nums)\\n        s=0\\n        d={0:-1}\\n        for i in range(n):\\n            s=(s+nums[i])%k\\n            if s not in d:\\n                d[s]=i\\n            else:\\n                if i-d[s]>1:\\n                    return True\\n        return False               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746505,
                "title": "brief-c-solution",
                "content": "```\\nbool checkSubarraySum(int* nums, int numsSize, int k){\\n    if (numsSize == 1) return false;\\n    else if (k == 1) return true;\\n    \\n    bool *map = calloc(k, sizeof(bool)); \\n    // using bool-type would save u some memory\\n    int sum = 0;    \\n\\n    for(int i = 0; i < numsSize; i++){\\n        if (nums[i] % k == 0){  \\n            // return true if encounter at least two conterminous k\\'s multiple\\n            // else we do not do any hashing\\n            if (i < numsSize-1 && nums[i+1] % k == 0) return true;\\n            else continue;\\n        }\\n        sum += nums[i]; // accumulate the array\\n        if (sum % k == 0) return true;\\n        else if (map[sum % k] > 0) return true;\\n        map[sum % k] = 1;\\n    }\\n    free(map);\\n    return false;\\n}\\n```\\n> Plz upvote if u like my solution, Tks! :)",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nbool checkSubarraySum(int* nums, int numsSize, int k){\\n    if (numsSize == 1) return false;\\n    else if (k == 1) return true;\\n    \\n    bool *map = calloc(k, sizeof(bool)); \\n    // using bool-type would save u some memory\\n    int sum = 0;    \\n\\n    for(int i = 0; i < numsSize; i++){\\n        if (nums[i] % k == 0){  \\n            // return true if encounter at least two conterminous k\\'s multiple\\n            // else we do not do any hashing\\n            if (i < numsSize-1 && nums[i+1] % k == 0) return true;\\n            else continue;\\n        }\\n        sum += nums[i]; // accumulate the array\\n        if (sum % k == 0) return true;\\n        else if (map[sum % k] > 0) return true;\\n        map[sum % k] = 1;\\n    }\\n    free(map);\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744762,
                "title": "c-concise-sol-hashmap-o-n",
                "content": "```\\n bool checkSubarraySum(vector<int>& nums, int k) {\\n        //1.brute force- TC-O(n^2), SC-O(1)\\n        \\n        //2.using hashmap \\n\\t\\tlong long cums = 0;\\n        unordered_map<int,int>mp;\\n      \\n\\t   \\t// ( y2 - y1 ) % k = 0  =>  y2 % k = y1 % k  (store remainders in map)\\n\\t\\t\\n        mp[0]=-1;\\n        for(int i=0;i<nums.size();i++){\\n            cums+=nums[i];\\n            int rem = cums%k;\\n            \\n            if(mp.count(rem)){\\n                if(i-mp[rem]>=2) return true;\\n            }   \\n            \\n            else mp[rem]=i;\\n        }\\n        \\n        return false;\\n        \\n\\t\\t//TC- O(n) , SC- O(n)\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool checkSubarraySum(vector<int>& nums, int k) {\\n        //1.brute force- TC-O(n^2), SC-O(1)\\n        \\n        //2.using hashmap \\n\\t\\tlong long cums = 0;\\n        unordered_map<int,int>mp;\\n      \\n\\t   \\t// ( y2 - y1 ) % k = 0  =>  y2 % k = y1 % k  (store remainders in map)\\n\\t\\t\\n        mp[0]=-1;\\n        for(int i=0;i<nums.size();i++){\\n            cums+=nums[i];\\n            int rem = cums%k;\\n            \\n            if(mp.count(rem)){\\n                if(i-mp[rem]>=2) return true;\\n            }   \\n            \\n            else mp[rem]=i;\\n        }\\n        \\n        return false;\\n        \\n\\t\\t//TC- O(n) , SC- O(n)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2744583,
                "title": "easy-java-solution",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n\\n```\\nclass Solution {\\n/**/\\n//SOLUTION BY YADUTTAM PAREEK\\n/**/\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] == 0 && nums[i-1] == 0) return true;\\n        }\\n        for(int i=1;i<nums.length;i++) {\\n            nums[i] += nums[i-1];\\n            if(nums[i] % k ==0) return true;\\n            int j = i;\\n            while(j> 1 && nums[i] > k) {\\n                if((nums[i] - nums[j-2]) % k ==0) {\\n                    return true;\\n                }\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# If you reached till here please upvote the solution.\\n![image](https://assets.leetcode.com/users/images/83ae693a-6d26-4dad-bf71-786dae4144cf_1666755653.0141456.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n/**/\\n//SOLUTION BY YADUTTAM PAREEK\\n/**/\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] == 0 && nums[i-1] == 0) return true;\\n        }\\n        for(int i=1;i<nums.length;i++) {\\n            nums[i] += nums[i-1];\\n            if(nums[i] % k ==0) return true;\\n            int j = i;\\n            while(j> 1 && nums[i] > k) {\\n                if((nums[i] - nums[j-2]) % k ==0) {\\n                    return true;\\n                }\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744477,
                "title": "java-100-3ms-simple-solution-w-video-explanation",
                "content": "*Please **Upvote** if you find the Explanation Helpful*\\n\\n**Video Explanation**\\n[Continuous Subarray Sum | YouTube](https://www.youtube.com/watch?v=hqfPW9if3qk&feature=youtu.be)\\n\\n\\n**Java Solution**\\n\\n*First Approach : **TLE***\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)   return false;\\n        \\n        int[] preSum = new int[nums.length+1];\\n        \\n        for (int i = 1; i <= nums.length; i++) {\\n            preSum[i] = preSum[i-1] + nums[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+2; j <= nums.length; j++) { \\n                if (k == 0) {\\n                    if (preSum[j] - preSum[i] == 0) {\\n                        return true;\\n                    }\\n                } else if ((preSum[j] - preSum[i]) % k == 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n*Second Approach : **TLE***\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i = 0; i < nums.length-1; i++) {\\n            int sum = nums[i];\\n            for (int j = i+1; j < nums.length; j++) {\\n                sum += nums[j];\\n                if ((k == 0 && sum == 0) || (k != 0 && sum % k == 0)) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n*Map Based Approach : **Accepted***\\n```\\n//25ms\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sum %= k; \\n            \\n            if (sum == 0 && i > 0) {\\n                return true;\\n            }\\n            \\n            if (map.containsKey(sum) && i - map.get(sum) > 1) { \\n                return true;\\n            }\\n            if (!map.containsKey(sum)) {\\n                map.put(sum, i); \\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n*Final Approach : **Accepted** and Explained in Video*\\n```\\n//3ms\\nTC: O(n)\\nSC:O(1)\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] == 0 && nums[i-1] == 0) return true;\\n        }\\n        for(int i=1;i<nums.length;i++) {\\n            nums[i] += nums[i-1];\\n            if(nums[i] % k ==0) return true;\\n            int j = i;\\n            while(j> 1 && nums[i] > k) {\\n                if((nums[i] - nums[j-2]) % k ==0) {\\n                    return true;\\n                }\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)   return false;\\n        \\n        int[] preSum = new int[nums.length+1];\\n        \\n        for (int i = 1; i <= nums.length; i++) {\\n            preSum[i] = preSum[i-1] + nums[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+2; j <= nums.length; j++) { \\n                if (k == 0) {\\n                    if (preSum[j] - preSum[i] == 0) {\\n                        return true;\\n                    }\\n                } else if ((preSum[j] - preSum[i]) % k == 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i = 0; i < nums.length-1; i++) {\\n            int sum = nums[i];\\n            for (int j = i+1; j < nums.length; j++) {\\n                sum += nums[j];\\n                if ((k == 0 && sum == 0) || (k != 0 && sum % k == 0)) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n//25ms\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sum %= k; \\n            \\n            if (sum == 0 && i > 0) {\\n                return true;\\n            }\\n            \\n            if (map.containsKey(sum) && i - map.get(sum) > 1) { \\n                return true;\\n            }\\n            if (!map.containsKey(sum)) {\\n                map.put(sum, i); \\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n//3ms\\nTC: O(n)\\nSC:O(1)\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] == 0 && nums[i-1] == 0) return true;\\n        }\\n        for(int i=1;i<nums.length;i++) {\\n            nums[i] += nums[i-1];\\n            if(nums[i] % k ==0) return true;\\n            int j = i;\\n            while(j> 1 && nums[i] > k) {\\n                if((nums[i] - nums[j-2]) % k ==0) {\\n                    return true;\\n                }\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744465,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n   \\n        unordered_map<int, int> mp;\\n        mp[0] = 0;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n      \\n            if (mp.find(sum % k) == mp.end())\\n                mp[sum % k] = i + 1;\\n \\n            else if (mp[sum % k] < i)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n   \\n        unordered_map<int, int> mp;\\n        mp[0] = 0;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n      \\n            if (mp.find(sum % k) == mp.end())\\n                mp[sum % k] = i + 1;\\n \\n            else if (mp[sum % k] < i)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604261,
                "title": "with-explanation-comments-time-369-ms-52-18-space-98-2-mb-95-02",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        //initialize a sum variable with initial value of the first element\\n        long long sum=nums[0];\\n        \\n        //loop over the whole array elements with a pointer, i\\n        for(int i=1;i<nums.size();i++){\\n            \\n            //base case 1: two consecutive zeros-> true\\n            if(nums[i]==nums[i-1])\\n                if(nums[i]==0)\\n                    return true;\\n            \\n            sum+=nums[i];\\n            \\n            //base case 2: if the sum is divisible by the given k-> true\\n            if(sum%k==0)\\n                return true;\\n            \\n            //initialize a second pointer, j\\n            int j=0;\\n            //save the current sum value in a temp variable\\n            int temp=sum;\\n            \\n            //nested loop with the second pointer when there\\'re at least continuous subarray of size 2\\n            while((i-j)>1 && temp>=k){\\n                //subtract the current value from the temp & incremeant the pointer\\n                temp-=nums[j++];\\n                \\n                //base case 3: if the temp is divisible by the given k-> true\\n                if(temp%k==0)\\n                    return true;\\n            }\\n                    \\n        }\\n        \\n        //after all, if there\\'s no valid one-> false\\n        return false;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        \\n        //initialize a sum variable with initial value of the first element\\n        long long sum=nums[0];\\n        \\n        //loop over the whole array elements with a pointer, i\\n        for(int i=1;i<nums.size();i++){\\n            \\n            //base case 1: two consecutive zeros-> true\\n            if(nums[i]==nums[i-1])\\n                if(nums[i]==0)\\n                    return true;\\n            \\n            sum+=nums[i];\\n            \\n            //base case 2: if the sum is divisible by the given k-> true\\n            if(sum%k==0)\\n                return true;\\n            \\n            //initialize a second pointer, j\\n            int j=0;\\n            //save the current sum value in a temp variable\\n            int temp=sum;\\n            \\n            //nested loop with the second pointer when there\\'re at least continuous subarray of size 2\\n            while((i-j)>1 && temp>=k){\\n                //subtract the current value from the temp & incremeant the pointer\\n                temp-=nums[j++];\\n                \\n                //base case 3: if the temp is divisible by the given k-> true\\n                if(temp%k==0)\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2495872,
                "title": "523-continuous-subarray-sum",
                "content": "# Approach\\nThe most important concept is that if you mod a with b to get c : a%b=c, then (a+b)%b will also give c.\\nThe basic approach is that we take the prefix sum mod and store the remainder value with the index value in the hashmap.\\n\\nThe  maths is that if we again get the same remainder which is already present in the hasmap this means that the multiple of k has been added we will check the length  of this subarray sum that has been added or we can say we will check the diff b/w the indexes and if that is greater than or equal to 2. We will return true.\\n\\nEx [ 1 2 4 5 3 7  ] k=8\\n\\nsum=0+1;\\n\\nrem = sum%k;(1%8=1)\\n\\nhashmap has [   [ 1,0 ]   ]\\n\\nsum = 1+2;\\n\\nrem = sum%k;(3%8=3)\\n\\nhashmap has [   [ 1,0 ] [ 3,1 ]  ]\\n\\nsum = 1+2+4;\\n\\nrem = sum%k;(7%8=7)\\n\\nhashmap has [   [ 1,0 ] [ 3,1 ] [ 7,2 ] ]\\n\\nsum = 1+2+4+5;\\n\\nrem = sum%k;(12%8=4)\\n\\nhashmap has [   [ 1,0 ] [ 3,1 ] [ 7,2 ]  [  4,3  ] ]\\n\\nsum = 1+2+4+5+3;\\n\\nrem = sum%k;(15%8=7)\\n\\nNow,\\n\\n[  [ 1,0 ] [ 3,1 ] [ 7,2 ]  [  4,3  ] ]  \\n\\nhashmap has  key = 7 in it with idx as 2 since current idx = 4 therefore  4 -the idx (value) of the key =7 present in hashmap = 4-2 =2 ;\\n\\nsince this value is greater than or equal to 2 we will return true;\\n![image](https://assets.leetcode.com/users/images/f5a934b6-94e1-446e-8e24-3bae30b1ca75_1661693430.5059488.png)\\n\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n             //rem   //idx\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int sum=0;\\n        map.put(0,-1);\\n        for(int i=0;i<nums.length;i++){\\n            \\n            sum+=nums[i];\\n            int rem = sum%k;\\n            \\n            if(map.containsKey(rem)){\\n                if(i-map.get(rem)>=2) return true;\\n            }\\n            else{\\n            map.put(rem,i);    \\n            }\\n            \\n           \\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n             //rem   //idx\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int sum=0;\\n        map.put(0,-1);\\n        for(int i=0;i<nums.length;i++){\\n            \\n            sum+=nums[i];\\n            int rem = sum%k;\\n            \\n            if(map.containsKey(rem)){\\n                if(i-map.get(rem)>=2) return true;\\n            }\\n            else{\\n            map.put(rem,i);    \\n            }\\n            \\n           \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235062,
                "title": "python-hashmap-and-sliding-window",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        #the core idea is to create a hashmap where the key is the remainder of every value and the value their index\\n        #if we encounter the same remainder it means we added a sum that equals a multiple of k \\n        #between those two occurences of the same remainder\\n        \\n        #eg 23 2 4 6 7 k=6\\n        #23%6 = 5 25%6=1 29%6=5 thus between the first occurence (+1 it index) until now (i index) #we added k\\n        #length 2(position we found) - 1(position we found it first + 1) + 1 = 2\\n        if len(nums)<=1:\\n            return False\\n        \\n        cusum = 0\\n        remainders = {0:-1} #keeps track of the remainders we found and their index location\\n        #the reason we initialize remainder 0 with - 1\\n        #if the cusum is a multiple of k, we need to returns its length thus i (-1 + 1) + 1= i+1 which is the length of the subarray\\n        #this way if we find a remainder 0 we start counting from [0,i] inclusive both\\n        \\n        \\n        for ind,num in enumerate(nums):\\n            cusum = cusum + num\\n            remainder = cusum%k\\n            \\n            if remainder not in remainders:\\n                remainders[remainder] = ind\\n            \\n            elif (remainder in remainders) and ((ind - (remainders[remainder]+1) + 1 )>=2) : \\n                return True\\n            \\n        return False\\n    \\n    #O(n) time complexity due to for loop\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        #the core idea is to create a hashmap where the key is the remainder of every value and the value their index\\n        #if we encounter the same remainder it means we added a sum that equals a multiple of k \\n        #between those two occurences of the same remainder\\n        \\n        #eg 23 2 4 6 7 k=6\\n        #23%6 = 5 25%6=1 29%6=5 thus between the first occurence (+1 it index) until now (i index) #we added k\\n        #length 2(position we found) - 1(position we found it first + 1) + 1 = 2\\n        if len(nums)<=1:\\n            return False\\n        \\n        cusum = 0\\n        remainders = {0:-1} #keeps track of the remainders we found and their index location\\n        #the reason we initialize remainder 0 with - 1\\n        #if the cusum is a multiple of k, we need to returns its length thus i (-1 + 1) + 1= i+1 which is the length of the subarray\\n        #this way if we find a remainder 0 we start counting from [0,i] inclusive both\\n        \\n        \\n        for ind,num in enumerate(nums):\\n            cusum = cusum + num\\n            remainder = cusum%k\\n            \\n            if remainder not in remainders:\\n                remainders[remainder] = ind\\n            \\n            elif (remainder in remainders) and ((ind - (remainders[remainder]+1) + 1 )>=2) : \\n                return True\\n            \\n        return False\\n    \\n    #O(n) time complexity due to for loop\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228452,
                "title": "c-map-intuition-explained",
                "content": "The idea is simple we maintain a hash of res=sum%k and store index in it. If we encounter same res again this means we have had a subarray in between wherein sum is a multiple of k. Now we make sure i >m[res]+1 to make sure that the length of subarray is more than 1. If hash key is not found then we just enter the key value in hash.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> m; \\n        m[0] = -1; \\n        int sum = 0; \\n        for (int i = 0; i < nums.size(); i++){\\n            sum += nums[i]; \\n            int res = sum % k; \\n            if (m.find(res)!= m.end() && m[res]+ 1 < i) return true; \\n            \\n            if (m.find (res) == m.end()) m[res] = i; \\n        }\\n        return false; \\n        \\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> m; \\n        m[0] = -1; \\n        int sum = 0; \\n        for (int i = 0; i < nums.size(); i++){\\n            sum += nums[i]; \\n            int res = sum % k; \\n            if (m.find(res)!= m.end() && m[res]+ 1 < i) return true; \\n            \\n            if (m.find (res) == m.end()) m[res] = i; \\n        }\\n        return false; \\n        \\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874996,
                "title": "python-o-n-using-hash-map-dictionary",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        hash_map = {0:-1}\\n        total = 0\\n        for i,num in enumerate(nums):\\n            total += num\\n            remainder = total%k\\n            \\n            if remainder not in hash_map:\\n                hash_map[remainder] = i\\n            elif i - hash_map[remainder] > 1:\\n                return True\\n        \\n        return False\\n\\t\\t\\n        # T(n) --> O(N)         \\n\\t\\t# S(n) --> O(K)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        \\n        hash_map = {0:-1}\\n        total = 0\\n        for i,num in enumerate(nums):\\n            total += num\\n            remainder = total%k\\n            \\n            if remainder not in hash_map:\\n                hash_map[remainder] = i\\n            elif i - hash_map[remainder] > 1:\\n                return True\\n        \\n        return False\\n\\t\\t\\n        # T(n) --> O(N)         \\n\\t\\t# S(n) --> O(K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843565,
                "title": "too-much-noise-there-is-a-simplest-way-python",
                "content": "```\\n\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # Tackle edge case: n = k multiple && len(arr) < 2\\n        reminToIdx = {0: -1}\\n        \\n        total = 0\\n        for idx, num in enumerate(nums):\\n            total += num\\n            reminder = total % k\\n            \\n            if reminder not in reminToIdx:\\n                 reminToIdx[reminder] = idx\\n            elif (idx - reminToIdx[reminder]) > 1:\\n                return True\\n            \\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/7240bdd3-ae66-4175-ad59-1192b8cc7865_1647118273.8879385.png)\\n",
                "solutionTags": [],
                "code": "```\\n\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # Tackle edge case: n = k multiple && len(arr) < 2\\n        reminToIdx = {0: -1}\\n        \\n        total = 0\\n        for idx, num in enumerate(nums):\\n            total += num\\n            reminder = total % k\\n            \\n            if reminder not in reminToIdx:\\n                 reminToIdx[reminder] = idx\\n            elif (idx - reminToIdx[reminder]) > 1:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1793563,
                "title": "java-o-n-hashing-explained",
                "content": "\\nExplanation: \\nWe keep on storing current ```currSum % k``` value in the hashmap if it does not exist already\\nIf it exists already, and if the difference between the current index and the index of the same current mod value (```currSum % k```) found in the hashmap is greater than or equal to 2, the answer is true.\\n\\nProof:  \\nConsider, \\n``` currentSum = n * k + mod    ---- (1)```\\n\\n[Note - currSum is the sum of the prefix array from index 0 till current index i]\\n\\nNow if the same mod value is found in hashmap, this must be the case\\n``` sum = m * k + mod  ---- (2) ```\\n \\nFrom (1) and (2), the values n, m and sum are unknown and we do not actually need them. We know mod value in both equations is the same. So subtract equations (1) - (2)\\n\\n``` currSum - sum =  n * k - m * k + mod - mod ```\\n``` currSum - sum = (n - m) * k  --- (3) ```\\n \\nEquation (3) states that there exists a subarray sum value [```value = currSum - sum```] which is a multiple of k and ```(n - m)``` is the value of the multiple.\\nThus, equation (3) satisfies our requirement.\\n\\nTime: ```O(n)```  Space: ```O(n)```\\n\\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] arr, int k) {\\n        HashMap<Integer, Integer> hashmap = new HashMap<>();\\n        int currSum = 0;\\n        hashmap.put(0, -1);\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            \\n            if(hashmap.containsKey(currSum % k)) {\\n                if(i - hashmap.get(currSum % k) >= 2) return true;\\n            }\\n            else hashmap.put(currSum % k, i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```currSum % k```\n```currSum % k```\n``` currentSum = n * k + mod    ---- (1)```\n``` sum = m * k + mod  ---- (2) ```\n``` currSum - sum =  n * k - m * k + mod - mod ```\n``` currSum - sum = (n - m) * k  --- (3) ```\n```value = currSum - sum```\n```(n - m)```\n```O(n)```\n```O(n)```\n```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] arr, int k) {\\n        HashMap<Integer, Integer> hashmap = new HashMap<>();\\n        int currSum = 0;\\n        hashmap.put(0, -1);\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            \\n            if(hashmap.containsKey(currSum % k)) {\\n                if(i - hashmap.get(currSum % k) >= 2) return true;\\n            }\\n            else hashmap.put(currSum % k, i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789112,
                "title": "python-solution-using-mod",
                "content": "The core idea is that if the reminder M (suppose prefix_sum[i] % k == M) appears again at position j (i < j - 1), then we can say the sum between i and j can be divided by k with no remainder.\\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) < 2:\\n            return False\\n        \\n        #  calc prefix sum\\n        prefix_sum = [0]\\n        for num in nums:\\n            prefix_sum.append(prefix_sum[-1] + num)\\n        \\n        hash_set = {0: 0}\\n        for i in range(1, len(prefix_sum)):\\n            mod = prefix_sum[i] % k\\n            if mod in hash_set:\\n                if i - hash_set[mod] > 1:\\n                    return True\\n            else:\\n                hash_set[mod] = i\\n        return False\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) < 2:\\n            return False\\n        \\n        #  calc prefix sum\\n        prefix_sum = [0]\\n        for num in nums:\\n            prefix_sum.append(prefix_sum[-1] + num)\\n        \\n        hash_set = {0: 0}\\n        for i in range(1, len(prefix_sum)):\\n            mod = prefix_sum[i] % k\\n            if mod in hash_set:\\n                if i - hash_set[mod] > 1:\\n                    return True\\n            else:\\n                hash_set[mod] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748104,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n        // key = 0,  is for any other subarray sum % k == 0, so it can return true\\n        // val = -1, is to make sure if index of 1 is a multiple of k can pass the two element subarray check\\n        map.put(0, -1);\\n        \\n        for (int i = 0, sum = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            \\n            // to find if any remainder in which current sum - remainder = multiple of k\\n            int remainder = sum % k;\\n            \\n            // check if the subarray is at least two elements \\n            if (i - map.getOrDefault(remainder, i) > 1)\\n                return true;\\n            \\n            // save only the remainder because the running sum at a previous position has been \\n            // calculated and left its remainder for further running sum to check\\n            // thus, the subarray between the previous position and current position is a valid sum = multiple of k\\n            \\n            // storing the first occurrence only (so it could be > 1 element subarray)\\n            // [5, 0, 0, 0], k = 3, where two zeros is a valid subarray that\\'s a multiple of k\\n            map.putIfAbsent(remainder, i);\\n        }\\n        \\n        return false;            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n        // key = 0,  is for any other subarray sum % k == 0, so it can return true\\n        // val = -1, is to make sure if index of 1 is a multiple of k can pass the two element subarray check\\n        map.put(0, -1);\\n        \\n        for (int i = 0, sum = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            \\n            // to find if any remainder in which current sum - remainder = multiple of k\\n            int remainder = sum % k;\\n            \\n            // check if the subarray is at least two elements \\n            if (i - map.getOrDefault(remainder, i) > 1)\\n                return true;\\n            \\n            // save only the remainder because the running sum at a previous position has been \\n            // calculated and left its remainder for further running sum to check\\n            // thus, the subarray between the previous position and current position is a valid sum = multiple of k\\n            \\n            // storing the first occurrence only (so it could be > 1 element subarray)\\n            // [5, 0, 0, 0], k = 3, where two zeros is a valid subarray that\\'s a multiple of k\\n            map.putIfAbsent(remainder, i);\\n        }\\n        \\n        return false;            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709383,
                "title": "simple-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        h = {0: -1}\\n        s = 0\\n        for i in range(len(nums)):\\n            s += nums[i]\\n            if s%k in h and i - h[s%k] >1 :\\n                return True\\n            elif s%k not in h:\\n                h[s%k] = i\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        h = {0: -1}\\n        s = 0\\n        for i in range(len(nums)):\\n            s += nums[i]\\n            if s%k in h and i - h[s%k] >1 :\\n                return True\\n            elif s%k not in h:\\n                h[s%k] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664683,
                "title": "c-solution-with-explanation-o-n-time-complexity-o-n-space-complexity",
                "content": "The premise is this:\\nLet `i < j`.\\nThe sum from the `0th` element to the `ith` element is `sum[0:i]`.\\nThe sum from the `0th` element to the `jth` element is `sum[0:j]`.\\nThus, the sum from the `ith` element to the `jth` element is `sum[i:j] = sum[0:j] - sum[0:i]`.\\n\\nAs we iterate through the array, we add the current number to `sum`.\\nIf `sum%K == 0`, we have found a multiple of `K`.\\n\\nOtherwise, let remainder `r = sum%K`.\\nSince we have a remainder of `r`, if we were to subtract the sum of another sub array also with remainder `r`, then the remaining value must be a multiple of `K`.\\n\\nIn other words, if `sum[0:i] = nK + r`, and `sum[0:j] = mK + r`, then `sum[i:j] = sum[0:j] - sum[0:i] = mK + r - (nK + r) = (m-n)K`, where `m` and `n` are integer. Hence, sum[i:j] must be a multiple of `K`.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if (nums.size() < 2) {\\n            return false;\\n        }\\n        \\n        int sum = nums[0];\\n        unordered_map<int, int> culumulative;\\n        culumulative.insert({sum%k, 0});\\n        for (int i = 1; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            int remainder = sum%k;\\n            \\n            if (remainder == 0) { return true; }\\n            \\n\\t\\t\\t// Even if we found a subarray that is a multiple of k, make sure that it is of size 2 or greater.\\n            unordered_map<int, int>::iterator iter = culumulative.find(remainder);\\n            if (iter != culumulative.end() && i - iter->second > 1) {\\n                return true;\\n            } else {\\n                culumulative.insert({remainder, i});\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if (nums.size() < 2) {\\n            return false;\\n        }\\n        \\n        int sum = nums[0];\\n        unordered_map<int, int> culumulative;\\n        culumulative.insert({sum%k, 0});\\n        for (int i = 1; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            int remainder = sum%k;\\n            \\n            if (remainder == 0) { return true; }\\n            \\n\\t\\t\\t// Even if we found a subarray that is a multiple of k, make sure that it is of size 2 or greater.\\n            unordered_map<int, int>::iterator iter = culumulative.find(remainder);\\n            if (iter != culumulative.end() && i - iter->second > 1) {\\n                return true;\\n            } else {\\n                culumulative.insert({remainder, i});\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647246,
                "title": "c-explanation-with-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n            // TC: O(N)\\n            // SC: O(K)\\n        map<int,int>mp={{0,-1}};\\n           int mod_prefix_sum=0;\\n            for(int i=0;i<nums.size();i++){\\n                    mod_prefix_sum= (mod_prefix_sum + nums[i])%k;  \\n                    if(mp.count(mod_prefix_sum) ){\\n                            if(i-mp[mod_prefix_sum]>1)return true;  // since size of subarray must be atleast two\\n                    }\\n                    else mp[mod_prefix_sum]=i;\\n            }\\n            return false;\\n    }\\n};\\n```\\n\\n>    ------------------------------------------------\\n>    Logic behind the probem\\n>    find i , j such that sum(arr[i:j)) is multiple of k\\n   accum[i]= sum(arr[0:i))\\n   accum[j]= sum(arr[0:j))\\n\\n>    sum(arr[i:j)) = accum[j]-accum[i]\\n   let us assume \\n   accum[i]= a*k + b\\n   accum[j]= c*k + d\\n   \\n>    where 0 <= b,d < k\\n   case 1 : b==0 \\n          accum[i] = sum(arr[0:i))  is itself multiple of k\\n          \\n>    case 2 : b,d have value other than zero\\n   sum(arr[i:j))= (a-c)*k + (b-d)      \\n    as we know sum(arr[i:j)) is multiple of k\\n    hence b must be equal to d\\n    \\n>     -----------------------------------------\\n  \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n            // TC: O(N)\\n            // SC: O(K)\\n        map<int,int>mp={{0,-1}};\\n           int mod_prefix_sum=0;\\n            for(int i=0;i<nums.size();i++){\\n                    mod_prefix_sum= (mod_prefix_sum + nums[i])%k;  \\n                    if(mp.count(mod_prefix_sum) ){\\n                            if(i-mp[mod_prefix_sum]>1)return true;  // since size of subarray must be atleast two\\n                    }\\n                    else mp[mod_prefix_sum]=i;\\n            }\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611565,
                "title": "python-o-n-solution-with-dictionary",
                "content": "\\nThis concept is very similar to other contiguous array questions i.e. traverse the array once and calculate cumulative sum and store the information that can be used later.\\nAlso look at the similar problem if **Subarray Sum Equals K** the solutions of both of these problems follow very similar approach.\\n\\nI have commented the code for better understanding. \\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # key would be remainder and value will be index\\n        remainder_dict = {}\\n        \\n        # cumulative sum\\n        cum_sum = 0\\n        \\n        for i, v in enumerate(nums):\\n            # update cumulative sum\\n            cum_sum += v\\n            \\n            # check the remainder\\n            rem = cum_sum % k\\n\\n            # check if this remainder came up historically\\n            # and get the index when it came up\\n            # if not get i (the current index)\\n            prv_index = remainder_dict.get(rem, i)\\n            \\n            # if we saw the same remainder historically \\n            # it means from prv_index to current index i\\n            # exactly multiple of k is added (zero is multiple of k)\\n            if (i-prv_index >= 2) or (rem==0 and i>0):\\n                return True\\n            \\n            # update the remainder dict\\n            # but if remainder already exist as key, don\\'t update it\\n            if rem not in remainder_dict:\\n                remainder_dict[rem] = i\\n            \\n            \\n        return False\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # key would be remainder and value will be index\\n        remainder_dict = {}\\n        \\n        # cumulative sum\\n        cum_sum = 0\\n        \\n        for i, v in enumerate(nums):\\n            # update cumulative sum\\n            cum_sum += v\\n            \\n            # check the remainder\\n            rem = cum_sum % k\\n\\n            # check if this remainder came up historically\\n            # and get the index when it came up\\n            # if not get i (the current index)\\n            prv_index = remainder_dict.get(rem, i)\\n            \\n            # if we saw the same remainder historically \\n            # it means from prv_index to current index i\\n            # exactly multiple of k is added (zero is multiple of k)\\n            if (i-prv_index >= 2) or (rem==0 and i>0):\\n                return True\\n            \\n            # update the remainder dict\\n            # but if remainder already exist as key, don\\'t update it\\n            if rem not in remainder_dict:\\n                remainder_dict[rem] = i\\n            \\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556841,
                "title": "c-explained-with-examples-easy",
                "content": "**We have to use maths to solve this question**\\ncreate presum array of given array\\nwe know that presum works for continuous subarray, and If required continuous subarray exist then,\\n\\n(presum[i]- presum[random])%k = 0     {where, i - random >= 2}\\n=> presum[i]%k - presum[random]%k = 0\\n=> presum[i]%k = presum[random]%k      \\n\\nSo we can say if there exist some random index which is having same remainder and diffence of i - random >= 2 then continuous subarray exists. so we need to keep track of remainders instead of sums.\\n\\n**Example**. \\nk = 6 and arr 1 3 0 0 6 => presum = 1 4 4 4 6 => presumremainders = 1 4 4 4 0\\nwe can solve this using remainders \\n4 at i = 3  and 4 at i = 1 => (presum[3] - presum[1]) % k = 0\\nHence we return true.\\n# *But*\\nk = 6 and  arr  =  1 3 0 6 => presum = 1 4 4 6 => remainders = 1 4 4 0\\nNow we cannot solve this using remainders approach, because differnce of remainders index should be greater than or eqaul to 2 hence we have to saparatly verify subarray for consecutive numbers.\\n**Upvote \\uD83D\\uDE07\\uD83D\\uDE4C\\uD83C\\uDFFB**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1)return false;\\n        \\n        unordered_map<int, int> m;\\n        int sum = nums[0];\\n        m[sum%k] = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            sum += nums[i];\\n            if(sum%k == 0)return true;\\n            // this only handles non consecutive numbers\\n            if(m.find(sum%k) != m.end() && i - m[sum%k] >= 2)return true;\\n            // to handle two consecutive numbers in the actual array\\n            if( (nums[i-1] + nums[i]) %k == 0)return true; \\n            m[sum%k] = i;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1)return false;\\n        \\n        unordered_map<int, int> m;\\n        int sum = nums[0];\\n        m[sum%k] = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            sum += nums[i];\\n            if(sum%k == 0)return true;\\n            // this only handles non consecutive numbers\\n            if(m.find(sum%k) != m.end() && i - m[sum%k] >= 2)return true;\\n            // to handle two consecutive numbers in the actual array\\n            if( (nums[i-1] + nums[i]) %k == 0)return true; \\n            m[sum%k] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1475714,
                "title": "python-o-n-subarray-divisible-by-k-using-prefix-sum",
                "content": "Simple approach to find subarray that is divisble by k and ensuring that length of it is greater or equal to 2.\\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        cs = 0\\n        hmap = {}\\n        for i in range(len(nums)):\\n            cs += nums[i] # get current sum\\n            cs %= k # get the modulus to find if it is divisible.\\n            if cs in hmap and i - hmap[cs] > 1: return True # if the difference is found, which implies the subarray is divisible by k since we are taking modules of k and also need to  make sure the lenght of it is greater than or equal to 2.\\n            if cs == 0 and i >= 1: return True # subarray from start which has len equal or greater that 2\\n            if cs not in hmap: hmap[cs] = i # we prefer the longest subarray if the difference is already present.\\n        return False\\n```\\n\\nSimilar to https://leetcode.com/problems/subarray-sums-divisible-by-k/\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        cs = 0\\n        hmap = {}\\n        for i in range(len(nums)):\\n            cs += nums[i] # get current sum\\n            cs %= k # get the modulus to find if it is divisible.\\n            if cs in hmap and i - hmap[cs] > 1: return True # if the difference is found, which implies the subarray is divisible by k since we are taking modules of k and also need to  make sure the lenght of it is greater than or equal to 2.\\n            if cs == 0 and i >= 1: return True # subarray from start which has len equal or greater that 2\\n            if cs not in hmap: hmap[cs] = i # we prefer the longest subarray if the difference is already present.\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399187,
                "title": "easy-java-code",
                "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if(nums.length==1) return false;\\n        \\n        HashMap<Integer,Integer> map = new HashMap();\\n        int sum = 0;\\n        map.put(sum,-1);\\n        \\n        for(int i =0;i<nums.length;i++){\\n            int val = nums[i];\\n            sum+=val;\\n            int rem = sum%k;\\n            if(map.containsKey(rem)){\\n                int len = i-map.get(rem);\\n                if(len>1) return true;\\n            }\\n            if(map.containsKey(rem)==false) map.put(rem,i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if(nums.length==1) return false;\\n        \\n        HashMap<Integer,Integer> map = new HashMap();\\n        int sum = 0;\\n        map.put(sum,-1);\\n        \\n        for(int i =0;i<nums.length;i++){\\n            int val = nums[i];\\n            sum+=val;\\n            int rem = sum%k;\\n            if(map.containsKey(rem)){\\n                int len = i-map.get(rem);\\n                if(len>1) return true;\\n            }\\n            if(map.containsKey(rem)==false) map.put(rem,i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369562,
                "title": "standard-java-solution",
                "content": "### Theory\\nThe idea with the problem is rather counter-intuitive and takes a lot of analysis just to understand. As for a brute force solution, we just keep a prefix sum, and find all the subarrays. If we encounter a subarray where the summation mod k is equal to zero, then we return true, otherwise we return false after searching through all the subarrays.\\n\\nFor the linear solution, we first must come to the realization that we have to cache the remainder values to their appropriate indices. If we compute a modular sum and see that we have encountered that remainder before, we simply check if the previous index is at least 2 spaces away, and if thats the case, we return true. We return false at the end of our loop.\\n\\n\\n### Solution Brute Force\\n```\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int[] prefixSum = new int[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i; j < nums.length; j++) {\\n                int sum = prefixSum[j] - ((i == 0) ? 0 : prefixSum[i-1]);\\n                if (sum % k == 0 && j - i >= 1) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```\\n\\n### Solution Linear\\n```\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        \\n        int remainder = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            remainder = (nums[i] + remainder) % k;\\n            if (map.containsKey(remainder)) {\\n                Integer prev = map.get(remainder);\\n                if (i - prev > 1) return true;\\n            } else {\\n                map.put(remainder, i);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int[] prefixSum = new int[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i; j < nums.length; j++) {\\n                int sum = prefixSum[j] - ((i == 0) ? 0 : prefixSum[i-1]);\\n                if (sum % k == 0 && j - i >= 1) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```\n```\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        \\n        int remainder = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            remainder = (nums[i] + remainder) % k;\\n            if (map.containsKey(remainder)) {\\n                Integer prev = map.get(remainder);\\n                if (i - prev > 1) return true;\\n            } else {\\n                map.put(remainder, i);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359450,
                "title": "faster-than-96-python-code-using-remainder-for-checking-if-subarray-already-available",
                "content": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> int:\\n        mp = {0 : -1}\\n        curr = 0\\n        for i in range(len(nums)):\\n            curr = (curr + nums[i] )% k\\n            if curr in mp:\\n                if i - mp[curr] > 1:\\n                    return True\\n            else:\\n                mp[curr] = i\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> int:\\n        mp = {0 : -1}\\n        curr = 0\\n        for i in range(len(nums)):\\n            curr = (curr + nums[i] )% k\\n            if curr in mp:\\n                if i - mp[curr] > 1:\\n                    return True\\n            else:\\n                mp[curr] = i\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346371,
                "title": "easy-and-simple-o-n-and-one-pass",
                "content": "class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n        int len=nums.length;\\n        if(len==0){\\n            return false;\\n        }\\n        long sum=nums[0];\\n        Set<Long> st=new HashSet<>();\\n        st.add(sum%k);\\n        for(int i=1;i<len;i++){\\n            sum+=nums[i];\\n           \\n            if(nums[i]%k==0 && nums[i-1]%k==0){\\n                return true;\\n            }\\n            else if((st.contains(sum%k) || sum%k==0) && nums[i]%k!=0){\\n                return true;\\n            }\\n            st.add(sum%k);\\n        }\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        \\n        int len=nums.length;\\n        if(len==0){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1341095,
                "title": "python-solution-with-explaination",
                "content": "This one is similar to `560. Subarray Sum Equals K`\\nInstead of looking for `prefixSum - k` exists (liner solution for #560), we are looking for if `prefixSum % k` exists.\\n\\nWhy it works?\\nBecause `a % k = (a + nk) % k` \\nSo if two `prefixSum mod k` are the same, the subarray between them(nk) must be a multiple of k\\n```\\ne.g  14 % 8 = 22 % 8 = 30 % 8 = 6\\n     30 - 14 = 16; 16 % 8 = 0\\n\\t 14 is the sum of the subArray we are looking for\\n```\\n\\nFor example:\\n```\\narray =  [23, 2,  4,  6,  7], k = 6\\npreSum = [23, 25, 29, 35, 42]\\nsumModK= [5,  1,  5,  5,  0]\\nsumModK[0] == sumModK[2] = 5 which means the sum of subArray[1:3]([2, 4]) is a multiple of k\\n```\\nWe could also use this to solve the question like `how many(same as #560, we need to store times as value)`, `if sum of subArray equals to nk` etc.\\n\\nSolution:\\n**Time Complexity: O(n)\\nSpace Complexity: O(k): (as we only store sum%k)**\\n\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # 0: -1 is for edge case that current sum mod k == 0\\n        # e.g: nums = [4, 2], k = 3\\n        d = {0: -1}\\n        currSum = 0\\n        for idx, num in enumerate(nums):\\n            currSum += num\\n            # if current sum mod k is in dict and index j - i > 1, we got the Subarray!\\n            if currSum % k in d and idx - d[currSum % k] > 1:\\n                return True\\n            # if current sum mod k not in dict, store it\\n            elif currSum % k not in d:\\n                d[currSum % k] = idx\\n            # else (currSum % k in d and idx - d[currSum % k] <2)\\n            # do nothing\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ne.g  14 % 8 = 22 % 8 = 30 % 8 = 6\\n     30 - 14 = 16; 16 % 8 = 0\\n\\t 14 is the sum of the subArray we are looking for\\n```\n```\\narray =  [23, 2,  4,  6,  7], k = 6\\npreSum = [23, 25, 29, 35, 42]\\nsumModK= [5,  1,  5,  5,  0]\\nsumModK[0] == sumModK[2] = 5 which means the sum of subArray[1:3]([2, 4]) is a multiple of k\\n```\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        # 0: -1 is for edge case that current sum mod k == 0\\n        # e.g: nums = [4, 2], k = 3\\n        d = {0: -1}\\n        currSum = 0\\n        for idx, num in enumerate(nums):\\n            currSum += num\\n            # if current sum mod k is in dict and index j - i > 1, we got the Subarray!\\n            if currSum % k in d and idx - d[currSum % k] > 1:\\n                return True\\n            # if current sum mod k not in dict, store it\\n            elif currSum % k not in d:\\n                d[currSum % k] = idx\\n            # else (currSum % k in d and idx - d[currSum % k] <2)\\n            # do nothing\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304791,
                "title": "c-easy-short",
                "content": "Subtractting 2 number with same remainder gives a number divisible by k;\\nFor Example:\\n\\t5%3=2;\\n\\t6%3=0;\\n\\t7%3=1;\\n\\t8%3=2;\\n\\t9%3=0;\\n\\t10%3=1;\\n\\t11%3=2;\\n\\t12%3=0;\\nyou can see \\n8-5==3;\\n11-5=6;\\n```\\n\\nclass Solution\\n{\\n    private:\\n\\n    public:\\n    bool checkSubarraySum(vector<int>& a, int k)\\n    {\\n        map<int,int> index;\\n        int sum=0,n=a.size();\\n        index[0]=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            sum%=k;\\n            \\n            if(index.find(sum)!=index.end())\\n            {\\n                if(i-index[sum]>1)\\n                    return true;\\n            }\\n            else\\n            {\\n                index[sum]=i;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\n    private:\\n\\n    public:\\n    bool checkSubarraySum(vector<int>& a, int k)\\n    {\\n        map<int,int> index;\\n        int sum=0,n=a.size();\\n        index[0]=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            sum%=k;\\n            \\n            if(index.find(sum)!=index.end())\\n            {\\n                if(i-index[sum]>1)\\n                    return true;\\n            }\\n            else\\n            {\\n                index[sum]=i;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191111,
                "title": "easy-js-solution-using-hashmap",
                "content": "```\\nvar checkSubarraySum = function(nums, k) {\\n    let m = new Map();\\n    let cumSum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        cumSum += nums[i];\\n        if (cumSum % k === 0 || cumSum === 0) {\\n            if (i + 1 >= 2) {\\n                return true;\\n            }\\n        }\\n        if (m.has(cumSum % k)) {\\n            let subarrLen = i - (m.get(cumSum % k) + 1) + 1;\\n            if (subarrLen >= 2) {\\n                return true;\\n            }\\n        } else {\\n            m.set(cumSum % k, i);  \\n        }\\n    }\\n    return false;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/*\\nConditions to consider:\\n    Subarray should be at least two or longer\\n    Zero is a multiple of k\\n\\nTwo general possible cases for specific subarray sum:\\n\\nif cumulative sum at j == x\\n    sum of subarray[0...j] is x\\n\\nif cumulative sum at j - cumulative sum at i == x\\n    sum of subarray[i+1...j] is x\\n\\nFor this particular problem, we have\\n\\nif cumulative sum at j % k == 0\\n    sum of subarray[0...j] % k == 0\\n\\nif cumulative sum at j % k == cumulative sum at i % k\\n    sum of subarray[i+1...j] % k == 0\\n\\nSo, at each index, we check if cumulative sum is zero or cumulative sum % k is zero.\\nAlso, we check if cumulative sum % k exists in the map because that means there is a subarray whose sum is equal to zero or whose sum modulus k is zero.\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkSubarraySum = function(nums, k) {\\n    let m = new Map();\\n    let cumSum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        cumSum += nums[i];\\n        if (cumSum % k === 0 || cumSum === 0) {\\n            if (i + 1 >= 2) {\\n                return true;\\n            }\\n        }\\n        if (m.has(cumSum % k)) {\\n            let subarrLen = i - (m.get(cumSum % k) + 1) + 1;\\n            if (subarrLen >= 2) {\\n                return true;\\n            }\\n        } else {\\n            m.set(cumSum % k, i);  \\n        }\\n    }\\n    return false;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/*\\nConditions to consider:\\n    Subarray should be at least two or longer\\n    Zero is a multiple of k\\n\\nTwo general possible cases for specific subarray sum:\\n\\nif cumulative sum at j == x\\n    sum of subarray[0...j] is x\\n\\nif cumulative sum at j - cumulative sum at i == x\\n    sum of subarray[i+1...j] is x\\n\\nFor this particular problem, we have\\n\\nif cumulative sum at j % k == 0\\n    sum of subarray[0...j] % k == 0\\n\\nif cumulative sum at j % k == cumulative sum at i % k\\n    sum of subarray[i+1...j] % k == 0\\n\\nSo, at each index, we check if cumulative sum is zero or cumulative sum % k is zero.\\nAlso, we check if cumulative sum % k exists in the map because that means there is a subarray whose sum is equal to zero or whose sum modulus k is zero.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157433,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            int mod = sum % k;\\n            if(m.find(mod) != m.end()) {\\n                if(i - m[mod] >= 2) {\\n                    return true;\\n                }\\n            }\\n            else {\\n                m[mod] = i;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            int mod = sum % k;\\n            if(m.find(mod) != m.end()) {\\n                if(i - m[mod] >= 2) {\\n                    return true;\\n                }\\n            }\\n            else {\\n                m[mod] = i;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009756,
                "title": "java-code-with-explanation",
                "content": "Idea is following\\n        Lets say we have a sumi that denotes sum of all elements till and including ith element\\n        Similarly we have sumj denoting sum of all elements till and including jth element and j > i\\n        We want to find a condition such that\\n        (sumj - sumi) % k = 0. sumj - sumi would give sum of all elemeents between and including i+1 and j.\\n        sumj%k = sumi%k.\\n        \\n        Now considering this condition, we can try to find if when we are at j, is there an i where sumi%k is equal to sumj%k.\\n        Also since question says we need atleast two elements therefore\\n        j - (i+1) + 1 > 1 => j-i > 1\\n        \\n        To do this we will store modulo of running sum in a Map with index and check if we encounter it again\\n```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            sum += nums[i];\\n            sum = k!=0? sum%k: sum;\\n            if(map.containsKey(sum)) {\\n                int lastIx = map.get(sum);\\n                if(i - lastIx > 1) return true; // 2 elemeents\\n            } else\\n                map.put(sum, i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            sum += nums[i];\\n            sum = k!=0? sum%k: sum;\\n            if(map.containsKey(sum)) {\\n                int lastIx = map.get(sum);\\n                if(i - lastIx > 1) return true; // 2 elemeents\\n            } else\\n                map.put(sum, i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935674,
                "title": "c-o-n-solution-similar-to-974-subarray-sums-divisible-by-k",
                "content": "edge case:\\nk = 0, unless array contains [0, 0] this will never be true\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int i, sum = 0, len = 0;\\n        unordered_map<int, int> map;\\n        map[0] = -1;\\n        \\n        if(k==0){\\n            for(i=1; i<nums.size(); i++){\\n                if(nums[i]==0 && nums[i-1]==0){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        for(i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            \\n            if(map.find(sum % k) != map.end()){\\n                if(i-map[sum % k] >= 2){\\n                    return true;\\n                }\\n            } else {\\n                map[sum % k] = i;\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        int i, sum = 0, len = 0;\\n        unordered_map<int, int> map;\\n        map[0] = -1;\\n        \\n        if(k==0){\\n            for(i=1; i<nums.size(); i++){\\n                if(nums[i]==0 && nums[i-1]==0){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        for(i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            \\n            if(map.find(sum % k) != map.end()){\\n                if(i-map[sum % k] >= 2){\\n                    return true;\\n                }\\n            } else {\\n                map[sum % k] = i;\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791251,
                "title": "c-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(k==0)\\n        {\\n            for(int i=0; i<nums.size()-1; i++)\\n            {\\n                if(nums[i]==0 && nums[i+1]==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int dp[nums.size()];\\n        dp[0]=nums[0];\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            dp[i]=dp[i-1]+nums[i];\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=i+1; j<nums.size(); j++)\\n            {\\n                if((dp[j]-dp[i]+nums[i])%k ==0)\\n                {\\n                    return  true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        if(k==0)\\n        {\\n            for(int i=0; i<nums.size()-1; i++)\\n            {\\n                if(nums[i]==0 && nums[i+1]==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int dp[nums.size()];\\n        dp[0]=nums[0];\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            dp[i]=dp[i-1]+nums[i];\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=i+1; j<nums.size(); j++)\\n            {\\n                if((dp[j]-dp[i]+nums[i])%k ==0)\\n                {\\n                    return  true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729995,
                "title": "c-o-n-using-unordered-map-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        k=abs(k);  //for negative k\\n        unordered_map<int,int>m;  //store sum->index pair\\n        int sum=0;   \\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];  //add current to sum\\n            int mod = k==0?sum:sum%k;  // we need to find multiple so we use mod\\n            if(m.find(mod)!=m.end()){  //if mod exist\\n                int prev=m[mod];  //previous index where mod is found\\n                int size = ((k==0 && nums[prev]==0) || (k!=0 && nums[prev]%k==0))?(i-prev+1):(i-prev);\\n\\t\\t\\t\\t//if k==0 and previous index has 0, we can include the previous index in subarray  or  \\n\\t\\t\\t\\t// k!=0 and previous index has multiple of k, we can still include it\\n\\t\\t\\t\\t//otherwise we shouldn\\'t include the previous index\\n                if(size>=2)  //if subarray of atleast size=2 found\\n                    return true;\\n            }\\n            else m[mod]=i;  //if mod was not found, store it\\n            if(mod==0 && i>0)   //this is if we found a subarray from index 0 to i which is a multiple of k\\n                return true;\\n        }\\n        return false;  //no subarray found\\n    }\\n};\\n```\\n\\nThis should pass all test cases. \\nTime complexity = O(n)  One pass using unordered_map\\nSpace Complexity = O(k) since we store only mods",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSubarraySum(vector<int>& nums, int k) {\\n        k=abs(k);  //for negative k\\n        unordered_map<int,int>m;  //store sum->index pair\\n        int sum=0;   \\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];  //add current to sum\\n            int mod = k==0?sum:sum%k;  // we need to find multiple so we use mod\\n            if(m.find(mod)!=m.end()){  //if mod exist\\n                int prev=m[mod];  //previous index where mod is found\\n                int size = ((k==0 && nums[prev]==0) || (k!=0 && nums[prev]%k==0))?(i-prev+1):(i-prev);\\n\\t\\t\\t\\t//if k==0 and previous index has 0, we can include the previous index in subarray  or  \\n\\t\\t\\t\\t// k!=0 and previous index has multiple of k, we can still include it\\n\\t\\t\\t\\t//otherwise we shouldn\\'t include the previous index\\n                if(size>=2)  //if subarray of atleast size=2 found\\n                    return true;\\n            }\\n            else m[mod]=i;  //if mod was not found, store it\\n            if(mod==0 && i>0)   //this is if we found a subarray from index 0 to i which is a multiple of k\\n                return true;\\n        }\\n        return false;  //no subarray found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592128,
                "title": "c-two-accepted-solutions-o-n-2-and-o-n-time",
                "content": "__O(n^2) time, O(1) space__\\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        int len = nums.Length;\\n        for (int i = 0; i < len-1; i++) {\\n            int sum = nums[i];\\n            for (int j = i+1; j < len; j++) {\\n                sum += nums[j];\\n                if (k != 0 && sum % k == 0)\\n                    return true;\\n                else if (sum == 0)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n__O(n) time, O(n) space__\\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        int len = nums.Length;\\n        int sum = 0;\\n        int prefix = 0;\\n        HashSet<int> hset = new HashSet<int>();\\n        for (int i = 0; i < len; i++) {\\n            sum += nums[i];\\n            if (k != 0)\\n                sum %= k;\\n            if (hset.Contains(sum))\\n                return true;\\n            hset.Add(prefix);\\n            prefix = sum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        int len = nums.Length;\\n        for (int i = 0; i < len-1; i++) {\\n            int sum = nums[i];\\n            for (int j = i+1; j < len; j++) {\\n                sum += nums[j];\\n                if (k != 0 && sum % k == 0)\\n                    return true;\\n                else if (sum == 0)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckSubarraySum(int[] nums, int k) {\\n        int len = nums.Length;\\n        int sum = 0;\\n        int prefix = 0;\\n        HashSet<int> hset = new HashSet<int>();\\n        for (int i = 0; i < len; i++) {\\n            sum += nums[i];\\n            if (k != 0)\\n                sum %= k;\\n            if (hset.Contains(sum))\\n                return true;\\n            hset.Add(prefix);\\n            prefix = sum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413629,
                "title": "python-concise-solution",
                "content": "At first, we calculate prefix_sum ```cumsum```\\n d = b - a( b is on the right of a). \\n what we want is that d is multiple of k, so we just need d % k = 0. \\n Because d = b - a, so d % k = 0 -> (b - a) %k. = 0.\\n So (b-a)%k=0  --> b%k - a%k = 0, then b%k = a%k.\\n \\n Use hashmap to reduce time complexity \\n ```python\\n     def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        cumsum = [0]\\n        for n in nums:\\n            cumsum.append(cumsum[-1]+n)\\n        record = {}\\n        for a,b in zip(cumsum[:-1],cumsum[1:]):\\n            b = b%k if k else b\\n            a = a%k if k else a\\n            if b in record:\\n                return True\\n            record[a] = 1 \\n        return False\\n ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```cumsum```\n```python\\n     def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        cumsum = [0]\\n        for n in nums:\\n            cumsum.append(cumsum[-1]+n)\\n        record = {}\\n        for a,b in zip(cumsum[:-1],cumsum[1:]):\\n            b = b%k if k else b\\n            a = a%k if k else a\\n            if b in record:\\n                return True\\n            record[a] = 1 \\n        return False\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 173506,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        d = {0:0}\\n        sum_ = 0\\n        for i, e in enumerate(nums):\\n            sum_ += e\\n            d[i+1] = sum_\\n            \\n        nlen = len(nums)\\n        for i in xrange(0, nlen-1):\\n            for j in xrange(i + 2, nlen + 1):\\n                sub_sum = d[j] - d[i]\\n                if sub_sum == k or (k != 0 and sub_sum % k == 0):\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        d = {0:0}\\n        sum_ = 0\\n        for i, e in enumerate(nums):\\n            sum_ += e\\n            d[i+1] = sum_\\n            \\n        nlen = len(nums)\\n        for i in xrange(0, nlen-1):\\n            for j in xrange(i + 2, nlen + 1):\\n                sub_sum = d[j] - d[i]\\n                if sub_sum == k or (k != 0 and sub_sum % k == 0):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157558,
                "title": "python-simple-short-solutions-w-explanation-from-o-n-k-to-o-n",
                "content": "* O(N*K) (My original solution)\\n\\t* We keep track of possible modules of previous sums and if we see 0 in mods, congratulations!\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums, k):\\n        if not k: return any(nums[i] == nums[i - 1] == 0 for i in range(1, len(nums)))\\n        mods = set()\\n        for num in nums:\\n            mods = {(mod + num) % k for mod in mods}\\n            if 0 in mods: return True\\n            mods |= {num}\\n        return False\\n```\\n* O(N) (Inspired from other solutions)\\n* Same as above but we just check to see if same mod seen before. That means we have a range of sum equals to multiples of k.\\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums, k):\\n        if not k: return any(nums[i] == nums[i - 1] == 0 for i in range(1, len(nums)))\\n        mods, sm = set(), 0\\n        for i, num in enumerate(nums):\\n            sm = (sm + num) % k\\n            if (sm in mods and num or (i and not nums[i - 1])) or (not sm and i): return True\\n            mods |= {sm}\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkSubarraySum(self, nums, k):\\n        if not k: return any(nums[i] == nums[i - 1] == 0 for i in range(1, len(nums)))\\n        mods = set()\\n        for num in nums:\\n            mods = {(mod + num) % k for mod in mods}\\n            if 0 in mods: return True\\n            mods |= {num}\\n        return False\\n```\n```\\nclass Solution:\\n    def checkSubarraySum(self, nums, k):\\n        if not k: return any(nums[i] == nums[i - 1] == 0 for i in range(1, len(nums)))\\n        mods, sm = set(), 0\\n        for i, num in enumerate(nums):\\n            sm = (sm + num) % k\\n            if (sm in mods and num or (i and not nums[i - 1])) or (not sm and i): return True\\n            mods |= {sm}\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99531,
                "title": "o-n-2-without-any-extra-space",
                "content": "Comments?\\n\\n```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        n = len(nums)\\n        if n > 1:\\n            \\n            for i in range(n):\\n                isum = nums[i]\\n                for j in range(i+1,n):\\n                    isum += nums[j]\\n                    if (k != 0 and (isum % k) == 0) or (isum == 0 and k == 0):\\n                        return True\\n                    \\n        return False",
                "solutionTags": [],
                "code": "Comments?\\n\\n```\\nclass Solution(object):\\n    def checkSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        n = len(nums)\\n        if n > 1:\\n            \\n            for i in range(n):\\n                isum = nums[i]\\n                for j in range(i+1,n):\\n                    isum += nums[j]\\n                    if (k != 0 and (isum % k) == 0) or (isum == 0 and k == 0):\\n                        return True\\n                    \\n        return False",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564916,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1566606,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1570756,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1951247,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1567046,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1570411,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1659130,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1569656,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1662511,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1570436,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1564916,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1566606,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1570756,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1951247,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1567046,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1570411,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1659130,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1569656,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1662511,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1570436,
                "content": [
                    {
                        "username": "Codeameba",
                        "content": "Basically you want to create an array of the accumulated sum, but instead of the sum, you have the sum%k. If you just go through it normally and return on sum%k == 0, then that only accounts for (n) possibilities out of (n^2) possibilities. However, if you find duplicated sum%k values, then that the sub array between those two indexes will actually be the solution. \\n\\ni.e.\\n[4, 1, 2, 3] and 6\\n1) if we get the accumulated sum, it looks like this [4, 5, 7, 10]\\n2) if we make it accumulated sum % k, it looks like this [4, 5, 1, 4]\\n3) notice that there is duplicated 4\\'s. The diffference between these two sums in theory must be a multiple of 6 since we\\'ve only been storing the num%k. \\n\\nJust wanted to write this out cz I thought it was pretty awesome and really couldn\\'t figure it out for a while. \\n"
                    },
                    {
                        "username": "Kishore_S",
                        "content": "[@Davrokongra](/Davrokongra) \\nMod values are = [1, 3, 1, 4]\\nWe encountered 1 twice so, when we arrive at the same remainder as before means, the subarray after the old remainder is a multiple of 6.\\nFor this case\\n[2, 10] which is a multiple of 6"
                    },
                    {
                        "username": "Cornelious",
                        "content": "[@Davrokongra](/Davrokongra) The 0th index and the 2nd index both have a remainder of 1 "
                    },
                    {
                        "username": "BitUnWise",
                        "content": "If the same number shows up twice then the sum from that number to current one must be 0 % k\nin the example above sums[0] and sums[3] both are 4 so we know that the sub array nums[(0 + 1) -> 3] must sum to 0 % k\nwe can see this works because nums[1 -> 3] e.g. 1 + 2 + 3 does = 0 % k"
                    },
                    {
                        "username": "kos2kos",
                        "content": " Yeah that is not clear as to why it is a multiple of 6"
                    },
                    {
                        "username": "Davrokongra",
                        "content": "How would this work in the case of an array like this `[1, 2, 10, 3]` and 6?"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "Thanks. Can you explanation why the number between two duplicate number is a multiple of 6."
                    },
                    {
                        "username": "zloig",
                        "content": "Ok. Maybe there exists a non-math solution faster than O(N^2). But I managed to come up with the modular arithmetic O(N) solution only because of my math background. And now multiply that by the factor of pressure during an interview. I think even if an interviewer asks this question it shouldn\\'t be judged \"hit or miss\"."
                    },
                    {
                        "username": "sidcool1234",
                        "content": "[5,0,0,0]\\n3\\n\\n\\nFor this question, the above should be false, but Leetcode says it should be true.  Any reason?"
                    },
                    {
                        "username": "sandeepsah1998",
                        "content": "Because they mentioned in description , any subarray which is the multiple of k , so in this test case their should be answer true"
                    },
                    {
                        "username": "indraarora726",
                        "content": "EXACTLY  LEETCODE IS BROKE"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "They have mentioned any subarray having only 0\\'s with len>=2 ,sum=0 and 0%(anynumber) is 0 so it is a vaild tc."
                    },
                    {
                        "username": "jylee6020",
                        "content": "Subarray [0, 0] which sums to 0 and 0 is divisible by every number other than 0"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Test cases are just pure evil"
                    },
                    {
                        "username": "user9446u",
                        "content": "The answer for test case [5,0,0,0] and k=3 should be False but on test result it is showing True.\\n\\nSomeone please explain this."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "same doubt !"
                    },
                    {
                        "username": "Krishna3019",
                        "content": "because of the 3 zeros\\n"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "dude, you gotta read carefully, this problem is well explain not other than some fucked up desc i encountered before in LeetCode\n\n\"0 is always a multiple of k\" => which means if there's two consecurtive zeros in the array, it's legit!"
                    },
                    {
                        "username": "anu1rag",
                        "content": "k = 3; its mentioned any multiple of k .. so 0*k = 0.. so 0 is multiple for all k "
                    },
                    {
                        "username": "madannaik",
                        "content": "[23,2,4,6,6]\\n7\\nshould be false right???\\nthanks!"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "sum from 23 to 2nd last 6 is 35 which is multiple of 7 => 7*5=35 hence its true"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "23 + 2 + 4 + 6 = 35, which is divisible by 7"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "Testcase 92: A really long list. the sum over all elements (44660) is smaller than k (2147483640), yet the test requires it to be true. This should not be possible right??"
                    },
                    {
                        "username": "SergeDim",
                        "content": "I meet the same problem as paddyveith987 does.\\nBut as I checked out - this array contains 0,0,0 indeed.. damn.\\nTo do this trap with the consecutive zeros was very rough to us developers ))"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "must be having consecutive zeroes hiding in that test case."
                    },
                    {
                        "username": "Warbringer",
                        "content": "I\\'m wondering about this too..."
                    },
                    {
                        "username": "bdunubold",
                        "content": "Why [0, 1, 0] and 0 is false tho ?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "k>=1 and length is at least two"
                    },
                    {
                        "username": "shivaprasad16",
                        "content": "becoz the size of subarray should atleast 2 then only ans will be True, but in above case subarray size will be 1"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "this question is for sure not medium if you have never seen it before"
                    },
                    {
                        "username": "silenceage",
                        "content": "Why test case [5, 0, 0, 0] 3 is true but [0, 0] 1 is false? should I consider sum 0 as a correct answer?"
                    },
                    {
                        "username": "bluescorpians",
                        "content": "3*0 = 0 hence true"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Yes sum 0 will be considered as correct. as (0+0+0)%(any number)=0 only."
                    }
                ]
            },
            {
                "id": 1570426,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1576853,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1575899,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1572615,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1567299,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1764484,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1660286,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1572029,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1576322,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1575418,
                "content": [
                    {
                        "username": "niteshgarg",
                        "content": "It should be false right while it says should be true.\\n\\nfor test case [5, 0, 0, 0] and 3. I have 78 cases passing out of 93"
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "0 is multiple of 3. so, subarray [0,0]\\'s sumis divisible by 3"
                    },
                    {
                        "username": "mercer80",
                        "content": "Following is an example when no continuous subarray sum found hence return false  .\\n..*.to be continued *\\n\\n![image](https://assets.leetcode.com/users/images/3670c4cf-46f0-45ba-9483-4ceeea5f014a_1654384717.515372.jpeg)\\n"
                    },
                    {
                        "username": "amitkecian",
                        "content": "[5,0,0,0]\\n3\\n\\n5 doesn\\'t add to the multiple of 3 still the right answer is true. \\nCan somebody help me understanding this?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Because sub array [ 0 , 0 ] qualify the criteria "
                    },
                    {
                        "username": "sunkyu",
                        "content": "for input [0,0] sum = -1, expected = true. how so ?"
                    },
                    {
                        "username": "al-jadda",
                        "content": "I got this answer wrong because it said:\\n\\n[23,2,6,4,7] , 6 .. expected \"true\" \\n\\ndid I miss something in the problem definition, I only see a 6 in the array, 2 and 4 are non-continous"
                    },
                    {
                        "username": "HarshitJha_7",
                        "content": "but the whole sum is 42 which is divisible by k = 6 question is to check multiple of k\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if r is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "Chenaiier",
                        "content": "Tip:\\n\\nImaging build a prefix sum array and % every element by k, when there is same value at two different index, the sum in between them is multiple of k."
                    },
                    {
                        "username": "ryabkin",
                        "content": "[1,0,1,0,1] - the same value is 1 at two different indexes, you've returned True but expected - False"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/\\nif you have solved leetcode 560 problem,you can understand easily\\nif not, you can also understand it with my explanation\\nHope helpful!"
                    },
                    {
                        "username": "jaspion",
                        "content": "Does anyone can explain why [5,0,0,0] k=3 should return true?"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "[0,0] satisfies the criteria."
                    },
                    {
                        "username": "dineshcode",
                        "content": "![image](https://assets.leetcode.com/users/images/2eac05fe-25fb-4386-b7a8-15c3a7fdaa16_1623906353.9639943.png)\\nthis ans should be false and my ans is false then why it is expecting true plz someone explain"
                    },
                    {
                        "username": "lold",
                        "content": "23+2+4+6 = 35, where 7*5 = 35, 5 is integer, so true"
                    }
                ]
            },
            {
                "id": 1575373,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 2073013,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 2055358,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 2049316,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 2029727,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 1953948,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 1919294,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 1898363,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 1840490,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            },
            {
                "id": 1823651,
                "content": [
                    {
                        "username": "user8838Mx",
                        "content": "[23,2,4,6,6]\\n7\\n\\n"
                    },
                    {
                        "username": "_om_singh",
                        "content": "___"
                    },
                    {
                        "username": "jigonro",
                        "content": "Hint:\\nMod(x, k) = Mod(y, k)   iff   Mod(x - y, k) = 0\\nIn words:\\nIf two integers have the same Mod_k, then the difference of those two numbers will have a Mod_k of zero.\\nIf a number has Mod_k of zero, it is divisible by k.\\nTherefore:\\nIf two integers have the same Mod_k, then the difference of those numbers will be divisible by k."
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why sliding window won\\'t work here? "
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain this test case\\nnums = [5,0,0,0]\\nk = 3\\nhow tf the output is true\\nWHYYYYYYYYYYYYYYYYY???"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@ankitmishra1021](/ankitmishra1021) understood"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro sum of 0+0+0 = 0, and size of (0, 0,0) >=2,   \\nAnd 0/p,  p is any number is always 0,  so the testcase is True.. "
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Help, what would be the approach if we want to find the number of subarrays?? can we reduce the solution to O(N^2). Thank You "
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "You want to find how many subarray are there, so as it\\'s a subarray, go on  checking whether sum subarray is divisible by K or not, if divisible then increament count by 1, next time increament by 2 next time by 3 next time by 4 and so on, why I m adding 1,2,3,4,.... Because once we get a good subarray next time when we get it\\'s current subarray and the last one.. Take an example and see"
                    },
                    {
                        "username": "_drigger",
                        "content": "can someone explain why [1,0] k=2 expects false, since 0 is always multiple."
                    },
                    {
                        "username": "BitUnWise",
                        "content": "the sub array needs to be at least length 2, so the sum in this example has to be 1 which isn\\'t a multiple of 2"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**The last test cases are the 7 circles of hell**"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "How  can i make it faster, it is not as time efficient as memory.....please help me..  \\n\\n\\n\\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\n        dix = {0:1}\\n        current_sum = 0\\n        ans = 0\\n        for i in nums:\\n            if i%k == 0:\\n                ans -= 1\\n            current_sum += i\\n            rem = current_sum % k\\n\\n            if rem in dix:\\n                ans += dix[rem]\\n                dix[rem] += 1\\n            \\n            else:\\n                dix[rem] = 1 \\n                \\n        return ans"
                    },
                    {
                        "username": "lihanf",
                        "content": "Can someone help me optimize this? testcase 92 times out..\\n\\n\\n`    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        prefixSumsModk = 1\\n        prefixSum_2Modk = 0\\n        prefixSum = 0\\n        for num in nums:\\n            prefixSum = (prefixSum+num)%k\\n            if prefixSum_2Modk & (1 << prefixSum) :\\n                return True\\n            prefixSum_2Modk = prefixSumsModk\\n            prefixSumsModk = prefixSumsModk | (1 << prefixSum)\\n        return False`"
                    }
                ]
            }
        ]
    }
]