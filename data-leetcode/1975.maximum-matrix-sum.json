[
    {
        "title": "Linked List Components",
        "question_content": "You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values.\nReturn the number of connected components in nums where two values are connected if they appear consecutively in the linked list.\n&nbsp;\nExample 1:\n\nInput: head = [0,1,2,3], nums = [0,1,3]\nOutput: 2\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n\nExample 2:\n\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\nOutput: 2\nExplanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the linked list is n.\n\t1 <= n <= 104\n\t0 <= Node.val < n\n\tAll the values Node.val are unique.\n\t1 <= nums.length <= n\n\t0 <= nums[i] < n\n\tAll the values of nums are unique.",
        "solutions": [
            {
                "id": 123842,
                "title": "c-java-python-easy-and-concise-solution-with-explanation",
                "content": "Take second example in the description:\\nliked list: `0->1`->2->`3->4`\\nI highlighed the subset G in linked list with color red.\\nThe problem is just to count how many red part there are.\\nOne red part is one connected components.\\nTo do this, we just need to count tails of red parts.\\n\\n**C++:**\\n```\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```\\n**Java:**\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> setG = new HashSet<>();\\n        for (int i: G) setG.add(i);\\n        int res = 0;\\n        while (head != null) {\\n            if (setG.contains(head.val) && (head.next == null || !setG.contains(head.next.val))) res++;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def numComponents(self, head, G):\\n        setG = set(G)\\n        res = 0\\n        while head:\\n            if head.val in setG and (head.next == None or head.next.val not in setG):\\n                res += 1\\n            head = head.next\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> setG = new HashSet<>();\\n        for (int i: G) setG.add(i);\\n        int res = 0;\\n        while (head != null) {\\n            if (setG.contains(head.val) && (head.next == null || !setG.contains(head.next.val))) res++;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def numComponents(self, head, G):\\n        setG = set(G)\\n        res = 0\\n        while head:\\n            if head.val in setG and (head.next == None or head.next.val not in setG):\\n                res += 1\\n            head = head.next\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 541885,
                "title": "a-thinking-on-how-to-understand-this-problem",
                "content": "The description is not clear, which makes it difficult to understand this problem. \\nOnce you understand this problem it is easy to solve.\\n\\nIf you use the concepts from Union-Find, it becomes easy to understand.\\nG is the initail state of a Union-Find problem, each number in G is a node, every nodes is disjointed from other nodes.\\nWhenever we Union two nodes, components decrease by 1. \\nHow do we know which two nodes to Union?  Description says \"two values are connected if they appear consecutively in the linked list.\" So we traverse the linked list, for each edge, if both vals are in G, we decrease components by 1. \\n\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : G) set.add(n);\\n        \\n        ListNode cur = head;\\n        int res = set.size();\\n        while (cur.next != null) {\\n            if (set.contains(cur.val) && set.contains(cur.next.val)) res--;\\n            cur = cur.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : G) set.add(n);\\n        \\n        ListNode cur = head;\\n        int res = set.size();\\n        while (cur.next != null) {\\n            if (set.contains(cur.val) && set.contains(cur.next.val)) res--;\\n            cur = cur.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658560,
                "title": "c-easy-and-concise-solution-with-explanation",
                "content": "Our intuition behind this problem is to put the **nums** vector into a hashmap, and then interate over the linked-list and find if any node is in components (side by side) with another, which must be present in the **nums** vector!\\n\\n# Code:-\\n```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode *curr = head;\\n        unordered_map<int, bool> mpp;\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = true;\\n        int count = 0, streak = 0;\\n        while(curr) {\\n            if(mpp[curr->val]==true) {\\n                streak++;\\n            } else {\\n                if(streak>0) {\\n                    count++;\\n                }\\n                streak = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        if(streak>0) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```\\n\\nAt every position we\\'re taking a **streak** variable which updates and if the value of the Node was not in nums, then we check if the **streak** is greater than 0, if yes we increment the **count(final answer)**, and make the present **streak** back to 0.\\nFinally, we return the **count(ans)**.\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode *curr = head;\\n        unordered_map<int, bool> mpp;\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = true;\\n        int count = 0, streak = 0;\\n        while(curr) {\\n            if(mpp[curr->val]==true) {\\n                streak++;\\n            } else {\\n                if(streak>0) {\\n                    count++;\\n                }\\n                streak = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        if(streak>0) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123879,
                "title": "single-check-per-element",
                "content": "We increase our counter when we start a new connection:\\n- current item is in the list, and\\n- previous item is not (!connected).\\n\\nNote that this approach allows checking the set just once per an element.\\n\\n**C++**\\n```cpp\\nint numComponents(ListNode* h, vector<int>& nums) {\\n    unordered_set<int> s(begin(nums), end(nums));\\n    int res = 0, connected = 0;\\n    for (; h != nullptr; h = h->next) {\\n        if (s.count(h->val)) {\\n            res += !connected;\\n            connected = true;\\n        }\\n        else\\n            connected = false;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numComponents(ListNode* h, vector<int>& nums) {\\n    unordered_set<int> s(begin(nums), end(nums));\\n    int res = 0, connected = 0;\\n    for (; h != nullptr; h = h->next) {\\n        if (s.count(h->val)) {\\n            res += !connected;\\n            connected = true;\\n        }\\n        else\\n            connected = false;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123889,
                "title": "python-using-two-pointers",
                "content": "```\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p, prev, count, G = head, False, 0, set(G)\\n        while p:\\n            if p.val in G and not prev:\\n                count += 1\\n            prev, p = p.val in G, p.next;\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p, prev, count, G = head, False, 0, set(G)\\n        while p:\\n            if p.val in G and not prev:\\n                count += 1\\n            prev, p = p.val in G, p.next;\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123918,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : G) {\\n            set.add(i);\\n        }\\n        int count = 0;\\n        while (head != null) {\\n            ListNode cur = head;\\n            boolean found = false;\\n            while (cur != null && set.contains(cur.val)) {\\n                found = true;\\n                cur = cur.next;\\n            }\\n            if (found) {\\n                count++;\\n            }\\n            head = cur == null ? cur : cur.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : G) {\\n            set.add(i);\\n        }\\n        int count = 0;\\n        while (head != null) {\\n            ListNode cur = head;\\n            boolean found = false;\\n            while (cur != null && set.contains(cur.val)) {\\n                found = true;\\n                cur = cur.next;\\n            }\\n            if (found) {\\n                count++;\\n            }\\n            head = cur == null ? cur : cur.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123855,
                "title": "c-one-traversal-using-unordered-set",
                "content": "    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> subset;\\n        int connected_components = 0;\\n        \\n        for(auto n : G)\\n            subset.insert(n);\\n        \\n        while(head) {\\n            if (subset.count(head->val) && (head->next == NULL || !subset.count(head->next->val)))\\n                connected_components++;\\n            head = head->next;\\n        }   \\n        return connected_components;\\n    }",
                "solutionTags": [],
                "code": "    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> subset;\\n        int connected_components = 0;\\n        \\n        for(auto n : G)\\n            subset.insert(n);\\n        \\n        while(head) {\\n            if (subset.count(head->val) && (head->next == NULL || !subset.count(head->next->val)))\\n                connected_components++;\\n            head = head->next;\\n        }   \\n        return connected_components;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2673359,
                "title": "easy-cpp-solution-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        map<int,int> hs ;\\n        \\n        for (auto i :nums)\\n            hs[i]++;\\n        \\n        ListNode* tmp = head;\\n        \\n        int ans = 0;\\n        \\n        while(tmp)\\n        {\\n            if(hs[tmp->val] !=0 )\\n            {\\n                while(tmp->next && hs[tmp->next->val] != 0 )\\n                {\\n                    tmp = tmp->next;\\n                }\\n                ans++;\\n            }\\n            tmp = tmp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        map<int,int> hs ;\\n        \\n        for (auto i :nums)\\n            hs[i]++;\\n        \\n        ListNode* tmp = head;\\n        \\n        int ans = 0;\\n        \\n        while(tmp)\\n        {\\n            if(hs[tmp->val] !=0 )\\n            {\\n                while(tmp->next && hs[tmp->next->val] != 0 )\\n                {\\n                    tmp = tmp->next;\\n                }\\n                ans++;\\n            }\\n            tmp = tmp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659231,
                "title": "java-easy-to-understand",
                "content": "**We\\'re given with**  the `head` of the LinkedList containing unique integer values and an integer `array` nums that is a subset(means all the element of array must be taken from LinkedList) of the linked list values.\\n**We\\'ve to find** the number of connected components in `nums array` where two values are connected if they appear  in the `linked list`.\\n**Understanding** `find` function\\nIt\\'s there to check if  the `ith` value of `nums array` and `LinkedList` are same. If it\\'s same then it will return `true` else `false`.\\n**Understanding** `numComponents` function\\nIn this function we\\'re traversing the entire LinkedList with the `head` node provided to us. While traversing we\\'ll keep on checking if the  `ith` value of `nums array` and `LinkedList` are same using the helper function (named: find). \\nIf we get true from the `find` function  then we will increase the count of `found`  by 1 and then we\\'ve to check if the count of `found` is 1 then it\\'s obvious that we got one connected component because if there will be 1 element then also we\\'ve to return 1 as number of connected components. \\nIf the `ith` value didn\\'t matched with the element of array and LinkedList then we\\'ve to assign 0 to `found counter` because we can\\'t have that answer,  according to the question: we have to return continous connected components but our continuety broke.\\n\\n\\n```\\nclass Solution {\\n    \\n\\t// helper function to check if the element of our LinkedList matches the element in the array\\n    public static boolean find(int[] arr, int target){\\n        for(int i=0; i<arr.length; i++){\\n            if(target == arr[i]){\\n\\t\\t\\t//returning true if it matches\\n                return true;\\n            }\\n        }\\n\\t\\t// returning false if itdoesn\\'t  matches any\\n        return false;\\n    } \\n    // given function\\n    public int numComponents(ListNode head, int[] nums) {\\n        int connected = 0;\\n        int found = 0;\\n\\t\\t\\n\\t\\t//traversing the linkedlist\\n        while(head != null){\\n            if(find(nums, head.val)){\\n\\t\\t\\t// if the element of array matched with LinkedList\\n\\t\\t\\t//then we will increase our found variable by 1\\n                found++;\\n\\t\\t\\t\\t// whenever we increase our found variable for the first time, it means we got atleast one connected item\\n                if(found == 1){\\n                    connected++;\\n                }\\n            }\\n\\t\\t\\t// Assigning found with 0 is imp because if we didn\\'t found any match then our found variable will increase everytime \\n\\t\\t\\t// And this will never allow the connected variable to increase. \\n            else{\\n                found=0;\\n            }\\n            head = head.next;\\n        }\\n\\t\\t//returning the number of count of how many times our found variable increased \\n        return connected;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\t// helper function to check if the element of our LinkedList matches the element in the array\\n    public static boolean find(int[] arr, int target){\\n        for(int i=0; i<arr.length; i++){\\n            if(target == arr[i]){\\n\\t\\t\\t//returning true if it matches\\n                return true;\\n            }\\n        }\\n\\t\\t// returning false if itdoesn\\'t  matches any\\n        return false;\\n    } \\n    // given function\\n    public int numComponents(ListNode head, int[] nums) {\\n        int connected = 0;\\n        int found = 0;\\n\\t\\t\\n\\t\\t//traversing the linkedlist\\n        while(head != null){\\n            if(find(nums, head.val)){\\n\\t\\t\\t// if the element of array matched with LinkedList\\n\\t\\t\\t//then we will increase our found variable by 1\\n                found++;\\n\\t\\t\\t\\t// whenever we increase our found variable for the first time, it means we got atleast one connected item\\n                if(found == 1){\\n                    connected++;\\n                }\\n            }\\n\\t\\t\\t// Assigning found with 0 is imp because if we didn\\'t found any match then our found variable will increase everytime \\n\\t\\t\\t// And this will never allow the connected variable to increase. \\n            else{\\n                found=0;\\n            }\\n            head = head.next;\\n        }\\n\\t\\t//returning the number of count of how many times our found variable increased \\n        return connected;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628700,
                "title": "c-clean-code-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n    if(nums.size()==1) return 1;  \\n    map<int,bool> mp;\\n    \\n    for(int ele : nums)  mp[ele]= true;\\n        \\n       int ans = 0;\\n       bool flag = false;  \\n       ListNode* tmp = head;\\n        \\n      while(tmp){\\n          int x = tmp->val;\\n          if(mp[x]){\\n              if(!flag) {ans++; flag= true;}\\n            }\\n          else flag = false;\\n          tmp = tmp->next;\\n      }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n    if(nums.size()==1) return 1;  \\n    map<int,bool> mp;\\n    \\n    for(int ele : nums)  mp[ele]= true;\\n        \\n       int ans = 0;\\n       bool flag = false;  \\n       ListNode* tmp = head;\\n        \\n      while(tmp){\\n          int x = tmp->val;\\n          if(mp[x]){\\n              if(!flag) {ans++; flag= true;}",
                "codeTag": "Java"
            },
            {
                "id": 1302687,
                "title": "java-5ms-using-hashset-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++) set.add(nums[i]);\\n        \\n        ListNode n=head;\\n        while(n!=null){\\n            if(n.next!=null){\\n                int v=n.next.val;\\n                if(set.contains(v)){\\n                    set.remove(n.val);\\n                }\\n            }\\n            n=n.next;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++) set.add(nums[i]);\\n        \\n        ListNode n=head;\\n        while(n!=null){\\n            if(n.next!=null){\\n                int v=n.next.val;\\n                if(set.contains(v)){\\n                    set.remove(n.val);\\n                }\\n            }\\n            n=n.next;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621553,
                "title": "using-unoredred-map-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>map(nums.begin(),nums.end());\\n        int ans = 0;\\n        bool lastMatch = 0;\\n        while(head){\\n            if( map.find(head->val) == map.end() ){\\n                lastMatch=0;\\n            }else{\\n                if(!lastMatch) {\\n                    ans++;\\n                    lastMatch=1;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>map(nums.begin(),nums.end());\\n        int ans = 0;\\n        bool lastMatch = 0;\\n        while(head){\\n            if( map.find(head->val) == map.end() ){\\n                lastMatch=0;\\n            }else{\\n                if(!lastMatch) {\\n                    ans++;\\n                    lastMatch=1;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545830,
                "title": "java-9ms-solution-82-faster-hashset-o-n-time-and-space-solution",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums) set.add(n);\\n        int components = 0, connected = 0;\\n        ListNode temp = head;\\n        \\n        while(temp != null){\\n            if(set.contains(temp.val))\\n               connected++; \\n            else if(connected > 0){\\n                components++;\\n                connected = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        if(connected == 0) return components;\\n        return components+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums) set.add(n);\\n        int components = 0, connected = 0;\\n        ListNode temp = head;\\n        \\n        while(temp != null){\\n            if(set.contains(temp.val))\\n               connected++; \\n            else if(connected > 0){\\n                components++;\\n                connected = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        if(connected == 0) return components;\\n        return components+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311593,
                "title": "c-best-approach-shortest-solution-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(),nums.end());\\n        \\n        ListNode*ptr=head;\\n        int count=0;\\n        int res=0;\\n        while(ptr){\\n            count=0;\\n            while(ptr && s.find(ptr->val)!=s.end()){\\n                count++;\\n                ptr=ptr->next;\\n            }\\n            if(count>0){\\n                res+=1;\\n            }\\n            if(ptr)ptr=ptr->next;\\n        }\\n        return res;\\n    }\\n};\\n// UPVOTE IF YOU LIKE : )\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(),nums.end());\\n        \\n        ListNode*ptr=head;\\n        int count=0;\\n        int res=0;\\n        while(ptr){\\n            count=0;\\n            while(ptr && s.find(ptr->val)!=s.end()){\\n                count++;\\n                ptr=ptr->next;\\n            }\\n            if(count>0){\\n                res+=1;\\n            }\\n            if(ptr)ptr=ptr->next;\\n        }\\n        return res;\\n    }\\n};\\n// UPVOTE IF YOU LIKE : )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465771,
                "title": "ez-python-code-using-sets",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        itr=head\\n        c=0\\n        s=set(nums)\\n        while itr:\\n            if itr.val in s and (itr.next==None or itr.next.val not in s):\\n                c+=1\\n            itr=itr.next\\n        return c\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        itr=head\\n        c=0\\n        s=set(nums)\\n        while itr:\\n            if itr.val in s and (itr.next==None or itr.next.val not in s):\\n                c+=1\\n            itr=itr.next\\n        return c\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456660,
                "title": "java-o-n-very-ez-approach-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet();\\n        for (int i = 0; i < nums.length; i ++) {\\n            numSet.add(nums[i]);\\n        }\\n        int count = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            if (numSet.contains(curr.val)) {\\n                while (curr.next != null && numSet.contains(curr.next.val)) {\\n                    curr = curr.next;\\n                }\\n                count ++;\\n            }\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet();\\n        for (int i = 0; i < nums.length; i ++) {\\n            numSet.add(nums[i]);\\n        }\\n        int count = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            if (numSet.contains(curr.val)) {\\n                while (curr.next != null && numSet.contains(curr.next.val)) {\\n                    curr = curr.next;\\n                }\\n                count ++;\\n            }\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933679,
                "title": "python3-counting-end-of-component",
                "content": "Algo \\nSince the problem is to count number of continuous components, one could count the beginning or end of a continuous piece. Here, to count the beginning is more tedious for the singly-linked list. Instead, we count the end of component like below. \\n\\nImplementation \\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gs = set(G)\\n        ans = 0\\n        while head: \\n            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1\\n            head = head.next \\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(M+N)` where `M` is length of `G` and `N` is length of linked list\\nSpace complexity `O(M)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gs = set(G)\\n        ans = 0\\n        while head: \\n            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1\\n            head = head.next \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 672843,
                "title": "python3-simple-and-straightforward-o-n-soluiton",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        result = 0\\n        G = set(G)\\n        t = 0\\n        while head:\\n            if head.val in G:\\n                t+=1\\n            else:\\n                if t!=0:\\n                    result+=1\\n                    t = 0\\n            head = head.next\\n        if t!=0:\\n            result+=1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        result = 0\\n        G = set(G)\\n        t = 0\\n        while head:\\n            if head.val in G:\\n                t+=1\\n            else:\\n                if t!=0:\\n                    result+=1\\n                    t = 0\\n            head = head.next\\n        if t!=0:\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936452,
                "title": "easy-c-solution-beats-99-users-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& v) {\\n        ListNode* temp=head;\\n        bool component=false;\\n        int counter=0;\\n       while(temp)\\n       {\\n            if(count(v.begin(),v.end(),temp->val)>0&& component==false)\\n            {\\n                counter++;\\n                component =true;\\n            }\\n            else if( !count(v.begin(),v.end(),temp->val))\\n            component=false;\\n           temp=temp->next;\\n       }\\n       return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& v) {\\n        ListNode* temp=head;\\n        bool component=false;\\n        int counter=0;\\n       while(temp)\\n       {\\n            if(count(v.begin(),v.end(),temp->val)>0&& component==false)\\n            {\\n                counter++;\\n                component =true;\\n            }\\n            else if( !count(v.begin(),v.end(),temp->val))\\n            component=false;\\n           temp=temp->next;\\n       }\\n       return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925563,
                "title": "letcode-solution-beats-86-online-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,bool>m;\\n        for(auto it : nums){\\n            m[it] = true;\\n        }\\n        int ct = 0;\\n        ListNode* temp = head;\\n\\n        bool flag = false;\\n\\n        while(temp){\\n            if(m[temp -> val]){\\n                flag = true;\\n            }\\n            else{\\n                if(flag){\\n                    flag = false;\\n                    ct++;\\n                }\\n            }\\n            temp = temp -> next;\\n        }\\n        if(flag) ct++;\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,bool>m;\\n        for(auto it : nums){\\n            m[it] = true;\\n        }\\n        int ct = 0;\\n        ListNode* temp = head;\\n\\n        bool flag = false;\\n\\n        while(temp){\\n            if(m[temp -> val]){\\n                flag = true;\\n            }\\n            else{\\n                if(flag){\\n                    flag = false;\\n                    ct++;\\n                }\\n            }\\n            temp = temp -> next;\\n        }\\n        if(flag) ct++;\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652569,
                "title": "easiest-python-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\t\\n        pointer = head\\n\\t\\t#prev is the pointer that stores boolean value: if the previous node\\'s value exists in the nums list\\n        prev = None\\n        counter = 0\\n        while pointer != None:\\n\\t\\t\\t#check if pointer\\'s value exist in the nums list\\n            if pointer.val in nums:\\n                if not prev:\\n\\t\\t\\t\\t\\t#increase counter if only previous node\\'s value doesn\\'t exist in list,ie, prev=False\\n                    counter += 1\\n\\t\\t\\t\\t#set prev as True for next node\\t\\n                prev = True\\n            else:\\n\\t\\t\\t\\t#set prev as False for next node\\n                prev = False\\n            pointer = pointer.next\\n        return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\t\\n        pointer = head\\n\\t\\t#prev is the pointer that stores boolean value: if the previous node\\'s value exists in the nums list\\n        prev = None\\n        counter = 0\\n        while pointer != None:\\n\\t\\t\\t#check if pointer\\'s value exist in the nums list\\n            if pointer.val in nums:\\n                if not prev:\\n\\t\\t\\t\\t\\t#increase counter if only previous node\\'s value doesn\\'t exist in list,ie, prev=False\\n                    counter += 1\\n\\t\\t\\t\\t#set prev as True for next node\\t\\n                prev = True\\n            else:\\n\\t\\t\\t\\t#set prev as False for next node\\n                prev = False\\n            pointer = pointer.next\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289937,
                "title": "java-easy-set",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        int n = nums.length;\\n        int components = 0;\\n        Set<Integer> numsSet = new HashSet<>();\\n        for(int num : nums) {\\n            numsSet.add(num);\\n        }\\n        \\n        while(head != null) {\\n            boolean isPresentNode = false;\\n            while(head != null && numsSet.contains(head.val)) {\\n                isPresentNode = true;\\n                head = head.next;\\n            }\\n            \\n            if(isPresentNode) {\\n                components++;\\n            } if(head!=null) {\\n                head = head.next;\\n            }\\n        }\\n        \\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        int n = nums.length;\\n        int components = 0;\\n        Set<Integer> numsSet = new HashSet<>();\\n        for(int num : nums) {\\n            numsSet.add(num);\\n        }\\n        \\n        while(head != null) {\\n            boolean isPresentNode = false;\\n            while(head != null && numsSet.contains(head.val)) {\\n                isPresentNode = true;\\n                head = head.next;\\n            }\\n            \\n            if(isPresentNode) {\\n                components++;\\n            } if(head!=null) {\\n                head = head.next;\\n            }\\n        }\\n        \\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898261,
                "title": "easy-solution-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        vector<int>v(10001,0);\\n        if(!head)\\n            return 0;\\n        for(auto i:nums)\\n        {\\n            v[i]=1;\\n        }\\n        int cnt=0;\\n        while(head)\\n        {\\n            if(v[head->val]==1)\\n            {\\n                while(head and v[head->val]==1)\\n                {\\n                    head=head->next;\\n                } \\n                cnt++;\\n            }\\n            else                \\n                head=head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Upvote if it helped :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        vector<int>v(10001,0);\\n        if(!head)\\n            return 0;\\n        for(auto i:nums)\\n        {\\n            v[i]=1;\\n        }\\n        int cnt=0;\\n        while(head)\\n        {\\n            if(v[head->val]==1)\\n            {\\n                while(head and v[head->val]==1)\\n                {\\n                    head=head->next;\\n                } \\n                cnt++;\\n            }\\n            else                \\n                head=head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695600,
                "title": "c-solution-better-memory-usage-than-99-49",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(!head) return 0;\\n        if(!head->next) return 1;\\n        \\n        int count = 0;\\n        bool consecutive=false;\\n        while(head){\\n            if(find(nums.begin(), nums.end(), head->val) != nums.end()){\\n                if(!consecutive) count++;\\n                consecutive = true;\\n            }else{\\n                consecutive = false;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(!head) return 0;\\n        if(!head->next) return 1;\\n        \\n        int count = 0;\\n        bool consecutive=false;\\n        while(head){\\n            if(find(nums.begin(), nums.end(), head->val) != nums.end()){\\n                if(!consecutive) count++;\\n                consecutive = true;\\n            }else{\\n                consecutive = false;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673692,
                "title": "simple-beginner-s-solution-using-vector-with-comment",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        //Initializing vector\\n        vector<int> v(10001,0);\\n        for(int i=0;i<nums.size();i++){\\n            v[nums[i]]=1;\\n        }\\n        int ans=0;\\n        while(head){ //Iterate linked list\\n            if(v[head->val]){ \\n        //if the val in node is present in nums array checking if the consecutives nodes vals are present in nums.\\n            while(head && v[head->val]){\\n                head=head->next;\\n            }\\n            //For all the consecutive nodes and their val present in nums we increase ans by 1 (1-component).\\n                ans++;\\n            }\\n            if(head && head->next) head=head->next; //Iterating the linked list \\n            else break; //handling null node which we might get from previous while loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        //Initializing vector\\n        vector<int> v(10001,0);\\n        for(int i=0;i<nums.size();i++){\\n            v[nums[i]]=1;\\n        }\\n        int ans=0;\\n        while(head){ //Iterate linked list\\n            if(v[head->val]){ \\n        //if the val in node is present in nums array checking if the consecutives nodes vals are present in nums.\\n            while(head && v[head->val]){\\n                head=head->next;\\n            }\\n            //For all the consecutive nodes and their val present in nums we increase ans by 1 (1-component).\\n                ans++;\\n            }\\n            if(head && head->next) head=head->next; //Iterating the linked list \\n            else break; //handling null node which we might get from previous while loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236331,
                "title": "this-is-probably-the-most-unclear-question-i-ever-came-across",
                "content": "**First thoughts on the prompt** : We basically have to check if each consecutive nodes possess values that are present in the subset and return the count of such connected components.\\n\\nBut then I look at example 1, which says:\\n```Input: \\nhead: 0->1->2->3\\nnums = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\\n3 is connected to what? For a moment lets suppose that in such cases the last node would be treated as in individual candidate since it possess a value present in the subset and it connects to **Null**. Cool?\\n\\nExample 2 also complies with our assumption and original prompt.\\n```Input: \\nhead: 0->1->2->3->4\\nnums = [0, 3, 1, 4]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\\n```\\nWhich is clear.\\n\\nTherefore I wrote the code below and checked it against a custom output.\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count, nums, flag = 0, set(nums), 0\\n        while head.next:\\n            if head.val in nums and head.next.val in nums:\\n                count += 1\\n                flag = 1\\n            else:\\n                flag = 0\\n            head = head.next\\n        if flag == 1:\\n            return count\\n        return count+1 if head.val in nums else count\\n```\\nIt passes for all our assumptions but when checked against a custom output, which was:\\n```\\nWrong Answer Runtime: 26 ms\\nYour input\\n[0,1,2]\\n[0,2]\\nOutput\\n1\\nExpected\\n2\\n```\\nWhy does it expect **2** as a result coz it is clear that combining the prompt and assumption, only the last node is eligible to be counted (as an individual node).  \\n  \\nPlease walk me through if I\\'m going wrong.\\n",
                "solutionTags": [],
                "code": "```Input: \\nhead: 0->1->2->3\\nnums = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\n```Input: \\nhead: 0->1->2->3->4\\nnums = [0, 3, 1, 4]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\\n```\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count, nums, flag = 0, set(nums), 0\\n        while head.next:\\n            if head.val in nums and head.next.val in nums:\\n                count += 1\\n                flag = 1\\n            else:\\n                flag = 0\\n            head = head.next\\n        if flag == 1:\\n            return count\\n        return count+1 if head.val in nums else count\\n```\n```\\nWrong Answer Runtime: 26 ms\\nYour input\\n[0,1,2]\\n[0,2]\\nOutput\\n1\\nExpected\\n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160065,
                "title": "easy-c-approach",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& g) {\\n        if(head==NULL or g.size()<=1) {\\n            return 1;\\n        }\\n        \\n        unordered_set<int> out;\\n        \\n        for(int i=0; i<g.size(); i++) {\\n            out.insert(g[i]);\\n        }\\n        \\n        ListNode*curr = head;\\n        int ans = 0;\\n        \\n        while(curr) {\\n            if(out.count(curr->val)) {\\n                ans++;\\n\\n                while(curr->next and out.count(curr->next->val)) {\\n                    curr = curr->next;\\n                }                \\n            } \\n            curr = curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& g) {\\n        if(head==NULL or g.size()<=1) {\\n            return 1;\\n        }\\n        \\n        unordered_set<int> out;\\n        \\n        for(int i=0; i<g.size(); i++) {\\n            out.insert(g[i]);\\n        }\\n        \\n        ListNode*curr = head;\\n        int ans = 0;\\n        \\n        while(curr) {\\n            if(out.count(curr->val)) {\\n                ans++;\\n\\n                while(curr->next and out.count(curr->next->val)) {\\n                    curr = curr->next;\\n                }                \\n            } \\n            curr = curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606715,
                "title": "my-cpp-soln-using-hasmap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_map<int,int> mp;\\n        int count = 0;\\n        for(auto a:G)\\n        {\\n            mp[a]++;\\n        }\\n        while(head)\\n        {\\n            bool flag = false;\\n            while(mp[head->val]!=0)\\n            {\\n                mp[head->val]--;\\n                head = head->next;\\n                flag = true;\\n                if(!head)\\n                {\\n                    return ++count;\\n                }\\n            }\\n            if(flag) count++;\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_map<int,int> mp;\\n        int count = 0;\\n        for(auto a:G)\\n        {\\n            mp[a]++;\\n        }\\n        while(head)\\n        {\\n            bool flag = false;\\n            while(mp[head->val]!=0)\\n            {\\n                mp[head->val]--;\\n                head = head->next;\\n                flag = true;\\n                if(!head)\\n                {\\n                    return ++count;\\n                }\\n            }\\n            if(flag) count++;\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178928,
                "title": "javascript-solution",
                "content": "The description doesn\\'t explain the problem well, for an explanation of what they\\'re looking click  [here](http://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case/167790). What we\\'re looking for is nodes (or groups of nodes) that are in G but not connected to each other. \\n\\nIn my solution I have a notConnected variable and a counter variable. \\n\\nFor the first node in the linked list that is in G we will increment the counter by one and set notConnected to false. \\n\\nWhen we find a node that is not in G we have found a break in the chain. We set notConnected to true. Now if we find another node that is in G we can increment the counter again.\\n\\n```\\n    let notConnected = true;\\n    let counter = 0;\\n    \\n    while(head){\\n        if (G.includes(head.val) && notConnected){\\n            counter++;\\n            notConnected = false;\\n        } else if (!G.includes(head.val)){\\n            notConnected = true;\\n        }\\n        head = head.next\\n    }\\n    \\n    return counter;\\n```",
                "solutionTags": [],
                "code": "```\\n    let notConnected = true;\\n    let counter = 0;\\n    \\n    while(head){\\n        if (G.includes(head.val) && notConnected){\\n            counter++;\\n            notConnected = false;\\n        } else if (!G.includes(head.val)){\\n            notConnected = true;\\n        }\\n        head = head.next\\n    }\\n    \\n    return counter;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477753,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* cur = head;\\n        int n = 0;\\n        while (cur) {\\n            n++;\\n            cur = cur->next;\\n        }\\n        std::vector<int> found (n);\\n        for (auto& val : nums) {\\n            found[val] = 1;\\n        }\\n        int ans = 0;\\n        cur = head;\\n        bool connected = false;\\n        while (cur) {\\n            if (connected and found[cur->val] == 0) {\\n                ans++;\\n                connected = false;\\n            }\\n            else if (!connected and found[cur->val] == 1) {\\n                connected = true;\\n            }\\n            cur = cur->next;\\n        }\\n        if (connected) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        numsSet:set = {num for num in nums}\\n        \\n        isInLoop = False\\n        componentsCounter = 0\\n        \\n        while (head != None):\\n            if head.val in numsSet:\\n                isInLoop = True\\n            else:\\n                if isInLoop:\\n                    componentsCounter += 1\\n                    isInLoop = False\\n            head = head.next\\n        \\n        if isInLoop:\\n            return componentsCounter+1\\n        return componentsCounter \\n```\\n\\n```Java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        boolean[] map = new boolean[10001];\\n        for (int num : nums) {\\n            map[num] = true;\\n        }\\n        ListNode it = head;\\n        int counter = 0;\\n        int len = 0;\\n        while (it != null) {\\n            if (map[it.val]) {\\n                len++;\\n            }\\n            else {\\n                if (len != 0) {\\n                    counter++;\\n                }\\n                len = 0;\\n            }\\n            it = it.next;\\n        }\\n        if (len != 0) {\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* cur = head;\\n        int n = 0;\\n        while (cur) {\\n            n++;\\n            cur = cur->next;\\n        }\\n        std::vector<int> found (n);\\n        for (auto& val : nums) {\\n            found[val] = 1;\\n        }\\n        int ans = 0;\\n        cur = head;\\n        bool connected = false;\\n        while (cur) {\\n            if (connected and found[cur->val] == 0) {\\n                ans++;\\n                connected = false;\\n            }\\n            else if (!connected and found[cur->val] == 1) {\\n                connected = true;\\n            }\\n            cur = cur->next;\\n        }\\n        if (connected) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        numsSet:set = {num for num in nums}\\n        \\n        isInLoop = False\\n        componentsCounter = 0\\n        \\n        while (head != None):\\n            if head.val in numsSet:\\n                isInLoop = True\\n            else:\\n                if isInLoop:\\n                    componentsCounter += 1\\n                    isInLoop = False\\n            head = head.next\\n        \\n        if isInLoop:\\n            return componentsCounter+1\\n        return componentsCounter \\n```\n```Java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        boolean[] map = new boolean[10001];\\n        for (int num : nums) {\\n            map[num] = true;\\n        }\\n        ListNode it = head;\\n        int counter = 0;\\n        int len = 0;\\n        while (it != null) {\\n            if (map[it.val]) {\\n                len++;\\n            }\\n            else {\\n                if (len != 0) {\\n                    counter++;\\n                }\\n                len = 0;\\n            }\\n            it = it.next;\\n        }\\n        if (len != 0) {\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446312,
                "title": "0-n-simple-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ListNode parent = null;\\n        int count=0;\\n        Set<Integer> hashset = new HashSet<Integer>();\\n\\n        for(int i : nums){\\n            hashset.add(i);\\n        }\\n\\n        while(curr!=null){\\n\\n            if(parent==null && curr!=null){\\n                if(hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n            else{\\n                if(!hashset.contains(parent.val) && hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ListNode parent = null;\\n        int count=0;\\n        Set<Integer> hashset = new HashSet<Integer>();\\n\\n        for(int i : nums){\\n            hashset.add(i);\\n        }\\n\\n        while(curr!=null){\\n\\n            if(parent==null && curr!=null){\\n                if(hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n            else{\\n                if(!hashset.contains(parent.val) && hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323499,
                "title": "c-easy-intermidate-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto it: nums) s.insert(it);\\n        bool conn=false;\\n        int total=0;\\n        while(head){\\n            int val= head->val;\\n            if(s.count(val)&& conn==false){\\n                conn=true;\\n                total++;\\n            }\\n            else if(s.count(val)==0&& conn==true)conn=false;\\n            head=head->next;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto it: nums) s.insert(it);\\n        bool conn=false;\\n        int total=0;\\n        while(head){\\n            int val= head->val;\\n            if(s.count(val)&& conn==false){\\n                conn=true;\\n                total++;\\n            }\\n            else if(s.count(val)==0&& conn==true)conn=false;\\n            head=head->next;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302514,
                "title": "easy-solution-o-n-space-and-time-complexity",
                "content": "\\n> # Approach\\nWe need to find number of contigious subsequent element in the linked list which are exist in the array.To check the element exist in the array or not on O(1) time complexity ,hashing is the better way for that so i have created a hashset and add all array elements into it.Now by traversing the linked list ones we can find the number of continious sequence of elements easily.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        for(int itr : nums){\\n            hash.add(itr);\\n        }\\n        int common = 0;\\n        int size = 0;\\n        while(head!=null){\\n            if(hash.contains(head.val)){\\n                size++;\\n            }\\n            else{\\n                if(size>0){\\n                    common++;\\n                }\\n                size=0;\\n            }\\n            head=head.next;\\n        }\\n        if(size>0){\\n            common+=1;\\n        }\\n        return common;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        for(int itr : nums){\\n            hash.add(itr);\\n        }\\n        int common = 0;\\n        int size = 0;\\n        while(head!=null){\\n            if(hash.contains(head.val)){\\n                size++;\\n            }\\n            else{\\n                if(size>0){\\n                    common++;\\n                }\\n                size=0;\\n            }\\n            head=head.next;\\n        }\\n        if(size>0){\\n            common+=1;\\n        }\\n        return common;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094168,
                "title": "java-using-hashset-easy-and-explained-beats-95",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        // Using Set to store the nums values\\n        HashSet<Integer> set = new HashSet<>();\\n    \\n        int count =0;\\n        for(int num: nums)\\n        {\\n            set.add(num);\\n        }\\n        boolean flag = false;\\n        \\n        // we just check if the value occurs in the set and keep it flowing till we dont find the value in the set \\n        \\n        while(curr!=null)\\n        {\\n            while(curr!=null && set.contains(curr.val))\\n            {\\n                flag = true;\\n                curr = curr.next;\\n            }\\n            \\n            \\n            if(flag == true)\\n                count++;\\n           \\n            // reseting the flag \\n            flag = false;\\n            \\n        \\n            if(curr!=null)\\n            curr = curr.next;\\n            \\n        }\\n\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        // Using Set to store the nums values\\n        HashSet<Integer> set = new HashSet<>();\\n    \\n        int count =0;\\n        for(int num: nums)\\n        {\\n            set.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3035281,
                "title": "c-beginner-friendly-map",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for(auto x : nums) seen.insert(x);\\n\\n        int answer = 0, cnt = 0;\\n        while(head) {\\n            if(seen.count(head->val)) cnt++;\\n            else {\\n                if(cnt) answer++;\\n                cnt = 0;\\n            }\\n            head = head -> next;\\n        }\\n        if(cnt) answer++;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for(auto x : nums) seen.insert(x);\\n\\n        int answer = 0, cnt = 0;\\n        while(head) {\\n            if(seen.count(head->val)) cnt++;\\n            else {\\n                if(cnt) answer++;\\n                cnt = 0;\\n            }\\n            head = head -> next;\\n        }\\n        if(cnt) answer++;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975596,
                "title": "c-faster-than-90-hashing-easy-implementation-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n\\n       unordered_map<int,bool>mpp;\\n\\n       for(auto &it : nums) mpp[it] = true;\\n\\n       int res = nums.size();\\n       int cnt = 0;\\n\\n       while(head != NULL)\\n       {\\n           if(mpp[head->val] == true) cnt++;\\n\\n           else\\n           {\\n             if(cnt > 1) res -= cnt - 1;\\n             cnt = 0;   \\n           }\\n           head = head->next;\\n       } \\n\\n       if(cnt > 1) res -= cnt - 1;\\n\\n       return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n\\n       unordered_map<int,bool>mpp;\\n\\n       for(auto &it : nums) mpp[it] = true;\\n\\n       int res = nums.size();\\n       int cnt = 0;\\n\\n       while(head != NULL)\\n       {\\n           if(mpp[head->val] == true) cnt++;\\n\\n           else\\n           {\\n             if(cnt > 1) res -= cnt - 1;\\n             cnt = 0;   \\n           }\\n           head = head->next;\\n       } \\n\\n       if(cnt > 1) res -= cnt - 1;\\n\\n       return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741690,
                "title": "java-1ms-runtime-faster-than-100",
                "content": "``` java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        // finding max element\\n        int max=0;\\n        for(int x:nums){\\n            max= Math.max(max,x);\\n        }\\n        // Create an array to check whether the element is present in nums or not or we can use HashSet\\n        boolean[] isPresent = new boolean[max+1];\\n        \\n        for(int x:nums)\\n            isPresent[x]=true;\\n        \\n        int count=0, components=0;\\n    \\n        // Traverse the linked list\\n        while(head!=null)\\n        {\\n            // Increase counter if the current value is present in nums array\\n            if(head.val<=max && isPresent[head.val]){\\n                count++;\\n            }\\n            else{\\n                // If there are more than one adjacent element in a component, Increase component count and reset counter.\\n                if(count>0){\\n                    components++; \\n                    count=0;\\n                }\\n            }\\n            head=head.next;\\n        }\\n        // Check if there is any remaining component at the end of the linked list\\n        if(count>0)\\n            components++;\\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        // finding max element\\n        int max=0;\\n        for(int x:nums){\\n            max= Math.max(max,x);\\n        }\\n        // Create an array to check whether the element is present in nums or not or we can use HashSet\\n        boolean[] isPresent = new boolean[max+1];\\n        \\n        for(int x:nums)\\n            isPresent[x]=true;\\n        \\n        int count=0, components=0;\\n    \\n        // Traverse the linked list\\n        while(head!=null)\\n        {\\n            // Increase counter if the current value is present in nums array\\n            if(head.val<=max && isPresent[head.val]){\\n                count++;\\n            }\\n            else{\\n                // If there are more than one adjacent element in a component, Increase component count and reset counter.\\n                if(count>0){\\n                    components++; \\n                    count=0;\\n                }\\n            }\\n            head=head.next;\\n        }\\n        // Check if there is any remaining component at the end of the linked list\\n        if(count>0)\\n            components++;\\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542916,
                "title": "89-tc-and-77-sc-easy-python-solution",
                "content": "```\\ndef numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\tcurr = head\\n\\tans = 0\\n\\ts = set(nums)\\n\\twhile(curr):\\n\\t\\tif(curr.val in s and not(curr.next and curr.next.val in s)):\\n\\t\\t\\tans += 1\\n\\t\\tcurr = curr.next\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\ndef numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\tcurr = head\\n\\tans = 0\\n\\ts = set(nums)\\n\\twhile(curr):\\n\\t\\tif(curr.val in s and not(curr.next and curr.next.val in s)):\\n\\t\\t\\tans += 1\\n\\t\\tcurr = curr.next\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2334662,
                "title": "java-o-n-hashset-easy-understanding",
                "content": "\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n\\n        while (head != null) {\\n            if (set.contains(head.val)){\\n                ans++;\\n                while (head != null && set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            } else {\\n                while (head != null && !set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n\\n        while (head != null) {\\n            if (set.contains(head.val)){\\n                ans++;\\n                while (head != null && set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            } else {\\n                while (head != null && !set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1946978,
                "title": "intuitive-and-consice-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        nums = set(nums)\\n        cur = head\\n        res = 0\\n        connected = False\\n        \\n        while cur:\\n            if cur.val in nums:\\n                if not connected:\\n                    res += 1\\n                    connected = True\\n            else:\\n                connected = False\\n            cur = cur.next\\n            \\n        return(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        nums = set(nums)\\n        cur = head\\n        res = 0\\n        connected = False\\n        \\n        while cur:\\n            if cur.val in nums:\\n                if not connected:\\n                    res += 1\\n                    connected = True\\n            else:\\n                connected = False\\n            cur = cur.next\\n            \\n        return(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829845,
                "title": "linked-list-easy-code",
                "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        if(head == NULL) return false ;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        if(head == NULL) return false ;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1689039,
                "title": "c-solution",
                "content": "Map the componets to get if numbers present in array.\\nTraverse Linked List, and keep updating count accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        int count=0;\\n        ListNode* tmp = head;\\n        int prev=0;\\n        while(tmp!=NULL)\\n        {\\n            if(mp[tmp->val]!=0)\\n            {\\n                if(prev==0)\\n                    prev=1,count++;\\n            }\\n            else\\n                prev=0;\\n            tmp=tmp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        int count=0;\\n        ListNode* tmp = head;\\n        int prev=0;\\n        while(tmp!=NULL)\\n        {\\n            if(mp[tmp->val]!=0)\\n            {\\n                if(prev==0)\\n                    prev=1,count++;\\n            }\\n            else\\n                prev=0;\\n            tmp=tmp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628810,
                "title": "new-approach-and-easy-using-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans = 0;\\n\\t\\t\\n        unordered_set<int> st(nums.begin(),nums.end()); \\n\\t\\t\\n        for(ListNode * i = head;i != NULL;i = i->next){\\n\\t\\t\\n            //check last node for all possible components \\n            //so increse ans if node is last or next node of the current node is not present in nums vector\\n            if(st.count(i->val) and (!i->next or !st.count(i->next->val)))\\n                ans++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans = 0;\\n\\t\\t\\n        unordered_set<int> st(nums.begin(),nums.end()); \\n\\t\\t\\n        for(ListNode * i = head;i != NULL;i = i->next){\\n\\t\\t\\n            //check last node for all possible components \\n            //so increse ans if node is last or next node of the current node is not present in nums vector\\n            if(st.count(i->val) and (!i->next or !st.count(i->next->val)))\\n                ans++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584918,
                "title": "c-solution-using-hashmap",
                "content": "```\\n int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums){\\n            mp[i]++;\\n        }\\n        int count=0;\\n        while(head!=NULL){\\n            if(mp[head->val]!=0){\\n                while(head!=NULL && mp[head->val]!=0){\\n                    head=head->next;\\n                }\\n                count++;\\n            }\\n            else{\\n                head=head->next;\\n            }\\n        }\\n        return count;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums){\\n            mp[i]++;\\n        }\\n        int count=0;\\n        while(head!=NULL){\\n            if(mp[head->val]!=0){\\n                while(head!=NULL && mp[head->val]!=0){\\n                    head=head->next;\\n                }\\n                count++;\\n            }\\n            else{\\n                head=head->next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312496,
                "title": "c-simple-single-pass",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n         int ans=0;\\n        unordered_set<int>st;\\n        for(auto & i:nums)\\n            st.insert(i);\\n        while(head)\\n        {\\n            if(st.find(head->val)!=st.end())\\n            {\\n                ans++;\\n                while( head && st.find(head->val)!=st.end())\\n                    head=head->next;\\n            }\\n            else\\n                head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo UPVOTE if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n         int ans=0;\\n        unordered_set<int>st;\\n        for(auto & i:nums)\\n            st.insert(i);\\n        while(head)\\n        {\\n            if(st.find(head->val)!=st.end())\\n            {\\n                ans++;\\n                while( head && st.find(head->val)!=st.end())\\n                    head=head->next;\\n            }\\n            else\\n                head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214392,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        int ctr=0;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int n : G){\\n            set.add(n);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                ctr++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return ctr;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        int ctr=0;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int n : G){\\n            set.add(n);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                ctr++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return ctr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200557,
                "title": "c-simple-easy-to-understand-solution-o-n",
                "content": "* We use unordered_set so that the searching of element takes constant (O(1)) time.\\n* Then we traverse over the list, and if the current element is present in the set then we make our check variable (x), 1, otherwise, we can increase our result variable based on the condition that whether we found the previous element in the set or not.\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        \\n        int res = 0, x = 0;\\n        for(auto p = head; p; p = p->next) {\\n            bool check = s.find(p->val) != s.end();\\n            if(x == 1 || check)\\n                check ? x = 1 : (res++, x = 0);\\n        }\\n        return res + (x == 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        \\n        int res = 0, x = 0;\\n        for(auto p = head; p; p = p->next) {\\n            bool check = s.find(p->val) != s.end();\\n            if(x == 1 || check)\\n                check ? x = 1 : (res++, x = 0);\\n        }\\n        return res + (x == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820313,
                "title": "c-95-87-easy-to-understand",
                "content": "***Runtime: 52 ms, faster than 95.87% of C++ online submissions for Linked List Components.\\nMemory Usage: 21.4 MB, less than 80.14% of C++ online submissions for Linked List Components.***\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> elements(G.begin(), G.end());\\n        int result = 0;\\n        while(head){\\n            if(elements.count(head->val)){\\n                result++;\\n                while(head->next && elements.count(head->next->val)){\\n                   head = head->next; \\n                }\\n            }\\n            head = head->next; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> elements(G.begin(), G.end());\\n        int result = 0;\\n        while(head){\\n            if(elements.count(head->val)){\\n                result++;\\n                while(head->next && elements.count(head->next->val)){\\n                   head = head->next; \\n                }\\n            }\\n            head = head->next; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764360,
                "title": "c-clean-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> lookup(begin(G), end(G));\\n        int count = 0;\\n        auto curNode = head;\\n        \\n        while (curNode) {\\n            auto nextNode = curNode->next;\\n            \\n            if (lookup.count(curNode->val))\\n                if (!nextNode or !lookup.count(nextNode->val))\\n                    count++;\\n            \\n            curNode = nextNode;\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> lookup(begin(G), end(G));\\n        int count = 0;\\n        auto curNode = head;\\n        \\n        while (curNode) {\\n            auto nextNode = curNode->next;\\n            \\n            if (lookup.count(curNode->val))\\n                if (!nextNode or !lookup.count(nextNode->val))\\n                    count++;\\n            \\n            curNode = nextNode;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 645465,
                "title": "c-clean-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        \\n        ListNode* r = head;\\n        unordered_set<int>s(G.begin(), G.end());\\n        int count = 0;\\n        while (r) {\\n            if (s.find(r->val) != s.end() && (r->next == NULL || s.find(r->next->val) == s.end()))\\n                count++;\\n            r = r->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        \\n        ListNode* r = head;\\n        unordered_set<int>s(G.begin(), G.end());\\n        int count = 0;\\n        while (r) {\\n            if (s.find(r->val) != s.end() && (r->next == NULL || s.find(r->next->val) == s.end()))\\n                count++;\\n            r = r->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468700,
                "title": "python-3-three-lines-108-ms",
                "content": "```\\nclass Solution:\\n    def numComponents(self, H: ListNode, G: List[int]) -> int:\\n        S, c = set(G), 0\\n        while H != None: c, H = c + (H.val in S and (H.next == None or H.next.val not in S)), H.next\\n        return c\\n\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, H: ListNode, G: List[int]) -> int:\\n        S, c = set(G), 0\\n        while H != None: c, H = c + (H.val in S and (H.next == None or H.next.val not in S)), H.next\\n        return c\\n\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 452897,
                "title": "single-traversal-constant-space-easy-and-concise",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n  if(!head) return null;\\n  let GSet = new Set(G);  \\n  let ret = 0, series = 0;\\n  while(head) {\\n    series = GSet.has(head.val) ? series + 1 : 0;\\n    if(series == 1)\\n      ret += 1;\\n    head = head.next;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n  if(!head) return null;\\n  let GSet = new Set(G);  \\n  let ret = 0, series = 0;\\n  while(head) {\\n    series = GSet.has(head.val) ? series + 1 : 0;\\n    if(series == 1)\\n      ret += 1;\\n    head = head.next;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399773,
                "title": "go-golang",
                "content": "```\\n/**\\n * Approach: Count The End Node of Component\\n * Intuition\\n * Instead of thinking about connected components in G, think about them in the linked list.\\n * Connected components in G must occur consecutively in the linked list.\\n * \\n * Algorithm\\n * Scanning through the list, if node.val is in G and node.next.val isn\\'t in G (including if node.next is null),\\n * then this must be the end of a connected component.\\n * For example, if the list is 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7, and G = [0, 2, 3, 5, 7],\\n * then when scanning through the list, we fulfill the above condition at 0, 3, 5, 7, for a total answer of 4.\\n * \\n * Complexity Analysis\\n * Time Complexity : O(N+G.length), where N is the length of the linked list with root node head.\\n * Space Complexity: O(G.length), to store gMap.\\n */\\n \\nfunc numComponents(head *ListNode, G []int) int {\\n    var ans int\\n\\t\\n    var gMap = make(map[int]bool, len(G))\\n    for i := range G {\\n    \\tgMap[G[i]] = true\\n    }\\n\\n    for curr, i := head, 0; curr != nil; curr, i = curr.Next, i+1 {    \\t\\n        if _, ok := gMap[curr.Val]; !ok {\\n            continue\\n        }\\n        \\n        if curr.Next == nil {\\n            ans++\\n            continue\\n        }\\n\\n        if _, ok := gMap[curr.Next.Val]; !ok {\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Approach: Count The End Node of Component\\n * Intuition\\n * Instead of thinking about connected components in G, think about them in the linked list.\\n * Connected components in G must occur consecutively in the linked list.\\n * \\n * Algorithm\\n * Scanning through the list, if node.val is in G and node.next.val isn\\'t in G (including if node.next is null),\\n * then this must be the end of a connected component.\\n * For example, if the list is 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7, and G = [0, 2, 3, 5, 7],\\n * then when scanning through the list, we fulfill the above condition at 0, 3, 5, 7, for a total answer of 4.\\n * \\n * Complexity Analysis\\n * Time Complexity : O(N+G.length), where N is the length of the linked list with root node head.\\n * Space Complexity: O(G.length), to store gMap.\\n */\\n \\nfunc numComponents(head *ListNode, G []int) int {\\n    var ans int\\n\\t\\n    var gMap = make(map[int]bool, len(G))\\n    for i := range G {\\n    \\tgMap[G[i]] = true\\n    }\\n\\n    for curr, i := head, 0; curr != nil; curr, i = curr.Next, i+1 {    \\t\\n        if _, ok := gMap[curr.Val]; !ok {\\n            continue\\n        }\\n        \\n        if curr.Next == nil {\\n            ans++\\n            continue\\n        }\\n\\n        if _, ok := gMap[curr.Next.Val]; !ok {\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311872,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n    let map=new Map();\\n    G.map((item)=>{\\n        map.set(item,!0);\\n    });\\n    let c=0;\\n    while(head){\\n        if(map.has(head.val)){\\n\\t\\twhile(head&&map.has(head.val))\\n\\t\\thead=head.next;\\n\\t\\tc++;    \\n        }             \\n        if(head)\\n        head=head.next;\\n    }\\n    return c;  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n    let map=new Map();\\n    G.map((item)=>{\\n        map.set(item,!0);\\n    });\\n    let c=0;\\n    while(head){\\n        if(map.has(head.val)){\\n\\t\\twhile(head&&map.has(head.val))\\n\\t\\thead=head.next;\\n\\t\\tc++;    \\n        }             \\n        if(head)\\n        head=head.next;\\n    }\\n    return c;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123826,
                "title": "simple-java-solution-using-set",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head == null) return 0;\\n        int res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        for(int n:G)\\n            hs.add(n);        \\n        ListNode curr = head;\\n        while(curr != null){\\n            int val = curr.val;\\n            if(!hs.contains(val)){\\n                curr = curr.next;\\n            }else{\\n                res++;\\n                while(curr != null && hs.contains(val)){\\n                    curr = curr.next;\\n                    if(curr != null)\\n                        val = curr.val;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head == null) return 0;\\n        int res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        for(int n:G)\\n            hs.add(n);        \\n        ListNode curr = head;\\n        while(curr != null){\\n            int val = curr.val;\\n            if(!hs.contains(val)){\\n                curr = curr.next;\\n            }else{\\n                res++;\\n                while(curr != null && hs.contains(val)){\\n                    curr = curr.next;\\n                    if(curr != null)\\n                        val = curr.val;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010854,
                "title": "java-solution-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int count = 1;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            hs.add(nums[i]);\\n\\n        boolean bool = true;\\n        boolean bool1 = true;\\n\\n        while(head != null){\\n            if(!hs.contains(head.val) && bool){\\n                count++;\\n                bool = false;\\n            }\\n            else if(hs.contains(head.val))\\n                bool = true;\\n\\n            if(head.next == null && !hs.contains(head.val))\\n                count--;\\n\\n            if(bool1 && !hs.contains(head.val))\\n                count--;\\n\\n            bool1 = false;\\n\\n            head = head.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int count = 1;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            hs.add(nums[i]);\\n\\n        boolean bool = true;\\n        boolean bool1 = true;\\n\\n        while(head != null){\\n            if(!hs.contains(head.val) && bool){\\n                count++;\\n                bool = false;\\n            }\\n            else if(hs.contains(head.val))\\n                bool = true;\\n\\n            if(head.next == null && !hs.contains(head.val))\\n                count--;\\n\\n            if(bool1 && !hs.contains(head.val))\\n                count--;\\n\\n            bool1 = false;\\n\\n            head = head.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802854,
                "title": "easiest-solution-using-loops-without-using-hashset-for-begginers",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public boolean find(int[] nums, int target){\\n        for(int i = 0; i<nums.length; i++){\\n            if(target == nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public int numComponents(ListNode head, int[] nums) {\\n        int comp = 0;\\n        int found = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            if(find(nums, curr.val)){\\n                found++;\\n                if(found == 1){\\n                    comp++;\\n                }\\n            }else{\\n                found = 0;\\n            }\\n            curr = curr.next;\\n        }\\n        return comp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public boolean find(int[] nums, int target){\\n        for(int i = 0; i<nums.length; i++){\\n            if(target == nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public int numComponents(ListNode head, int[] nums) {\\n        int comp = 0;\\n        int found = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            if(find(nums, curr.val)){\\n                found++;\\n                if(found == 1){\\n                    comp++;\\n                }\\n            }else{\\n                found = 0;\\n            }\\n            curr = curr.next;\\n        }\\n        return comp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769418,
                "title": "simple-and-easy-solution-c-linked-list-undordered-map",
                "content": "\\n\\n    class Solution {\\n    public:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        int cnt=0;\\n        while(head!=NULL){\\n            if(mp.find(head->val)!=mp.end()){\\n                while(head!=NULL and mp.find(head->val)!=mp.end()){\\n                    head=head->next;\\n                }\\n                cnt++;\\n            }\\n            if(head!=NULL){\\n                head=head->next;\\n            }\\n        }\\n        return cnt;\\n       }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3698720,
                "title": "o-n-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(head==nullptr)\\n            return 0;\\n        unordered_set<int> s{nums.begin(),nums.end()};\\n        int count=0;\\n        while(head!=nullptr){\\n            if(s.find(head->val)!=s.end()){\\n                count++;\\n                while(head->next!=nullptr && s.find(head->next->val)  !=s.end())\\n            head=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(head==nullptr)\\n            return 0;\\n        unordered_set<int> s{nums.begin(),nums.end()};\\n        int count=0;\\n        while(head!=nullptr){\\n            if(s.find(head->val)!=s.end()){\\n                count++;\\n                while(head->next!=nullptr && s.find(head->next->val)  !=s.end())\\n            head=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545163,
                "title": "clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n       unordered_set<int> s (nums.begin(),nums.end());\\n       int  res = 0; \\n       ListNode* temp = head; \\n       int prev = head->val; \\n\\n       while(temp!=NULL)\\n       {\\n         if(s.find(temp->val)==s.end() && temp!=head && s.find(prev)!=s.end()) // if this node is not in array but prev node was there in array \\n// suppose this node and prev node both are not in set we don,t count them\\n         res++;\\n         prev = temp->val;\\n         temp = temp->next;\\n       }\\n       if(s.find(prev)!=s.end()) // for last node\\n       res++;\\n        \\n       return res;\\n       \\n\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n       unordered_set<int> s (nums.begin(),nums.end());\\n       int  res = 0; \\n       ListNode* temp = head; \\n       int prev = head->val; \\n\\n       while(temp!=NULL)\\n       {\\n         if(s.find(temp->val)==s.end() && temp!=head && s.find(prev)!=s.end()) // if this node is not in array but prev node was there in array \\n// suppose this node and prev node both are not in set we don,t count them\\n         res++;\\n         prev = temp->val;\\n         temp = temp->next;\\n       }\\n       if(s.find(prev)!=s.end()) // for last node\\n       res++;\\n        \\n       return res;\\n       \\n\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535221,
                "title": "c-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate over the consecutively connected nodes of the linked list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from the head and traverse the current consecutively connected nodes and increment `component` by `1`.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int components = 0;\\n        \\n        while(head)\\n        {\\n            if(s.count(head->val))\\n            {\\n                while(head && s.count(head->val))\\n                    head = head->next;\\n                components ++;\\n            }\\n            if(head)\\n                head = head->next;\\n        }\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int components = 0;\\n        \\n        while(head)\\n        {\\n            if(s.count(head->val))\\n            {\\n                while(head && s.count(head->val))\\n                    head = head->next;\\n                components ++;\\n            }\\n            if(head)\\n                head = head->next;\\n        }\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165971,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> set(nums.begin(),nums.end());\\n        unordered_set<int> parents;\\n        \\n        int par= head->val;\\n        while(head){\\n            if(set.count(head->val)){\\n                parents.insert(par);\\n                head= head->next;\\n            }\\n            else{\\n                while(head && set.count(head->val)==0) head= head->next;\\n                if(!head) break;\\n                par= head->val;\\n            }\\n        }\\n        \\n        return parents.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> set(nums.begin(),nums.end());\\n        unordered_set<int> parents;\\n        \\n        int par= head->val;\\n        while(head){\\n            if(set.count(head->val)){\\n                parents.insert(par);\\n                head= head->next;\\n            }\\n            else{\\n                while(head && set.count(head->val)==0) head= head->next;\\n                if(!head) break;\\n                par= head->val;\\n            }\\n        }\\n        \\n        return parents.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068232,
                "title": "fully-commented-easy-o-n-solution",
                "content": "\\n# Approach\\n\\nTo approach this question, first of all think , when we have to increment our component count and when not?\\n\\n- We will not increment our count when we conme to know that the element is a part of our previous chain and increment it when it is not.\\n- Then how we get to know that element is part of chain or not??\\n- Simple,maintain your flag variable...but how??\\n- See first we will initialize our flag as true and then traverse our whole ll until the head is null to check that whether head->val is in the nums array or not..(so to check this, should we have to traverse the whole nums??..No,No..do it in constant time using map :) \\n- Now,if the element in ll is found in map and flag is true(it means elemnt is not part of any chain),increment count and set flag as false(so that futher elements in ll who is part of chain do not contribute to the component count).\\n- if element is not found in map,set flag as true so that incase we will find some element which is in map, we can increment our count.\\n\\n# Complexity\\n- Time complexity:\\nAs we are traversing our linked list only once, so time complexity is **O(n)**\\n\\n- Space complexity:\\nHere we are using unordered map to store the elements of nums array ,thus S.C is also **O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        // traversing the nums array and mapping the elements \\n        for(auto e:nums){\\n            mp[e]++;\\n        }\\n        \\n        int count=0;\\n        bool flag=true;  //flag variable to keep a check if element belongs to the connected chain or not\\n        \\n        while(head){\\n           // if found the element in map and flag is true---\\n            // it means the element does not belong to any previous chain in ll thus increment the count variable and change flag to false\\n          if(mp.find(head->val)!=mp.end() && flag){\\n               count++;\\n               flag=false;\\n           } \\n         // if element is not in map then reset flag as true so that incase we will find some element which is in map, we can increment count\\n        else if(mp.find(head->val)==mp.end()) flag=true;\\n        head=head->next;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        // traversing the nums array and mapping the elements \\n        for(auto e:nums){\\n            mp[e]++;\\n        }\\n        \\n        int count=0;\\n        bool flag=true;  //flag variable to keep a check if element belongs to the connected chain or not\\n        \\n        while(head){\\n           // if found the element in map and flag is true---\\n            // it means the element does not belong to any previous chain in ll thus increment the count variable and change flag to false\\n          if(mp.find(head->val)!=mp.end() && flag){\\n               count++;\\n               flag=false;\\n           } \\n         // if element is not in map then reset flag as true so that incase we will find some element which is in map, we can increment count\\n        else if(mp.find(head->val)==mp.end()) flag=true;\\n        head=head->next;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960162,
                "title": "simple-linked-list-traversal-beats-99-python-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        my=set([])\\n        for i in nums:\\n            my.add(i)\\n        curr=head\\n        # flag=False\\n        count=0\\n        while curr!=None:\\n            flag=False\\n            while curr!=None and curr.val in my:\\n                flag=True\\n                curr=curr.next\\n            if flag==True:\\n                count+=1\\n            if curr!=None and curr.next!=None:\\n                curr=curr.next\\n            else:\\n                break\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        my=set([])\\n        for i in nums:\\n            my.add(i)\\n        curr=head\\n        # flag=False\\n        count=0\\n        while curr!=None:\\n            flag=False\\n            while curr!=None and curr.val in my:\\n                flag=True\\n                curr=curr.next\\n            if flag==True:\\n                count+=1\\n            if curr!=None and curr.next!=None:\\n                curr=curr.next\\n            else:\\n                break\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883410,
                "title": "c",
                "content": "```\\nint depth(struct ListNode* head){\\n    if(head == NULL)\\n        return 0;\\n    else\\n        return 1 + depth(head->next);\\n}\\nint numComponents(struct ListNode* head, int* nums, int numsSize){\\n    int n = depth(head);\\n    bool* exist = calloc(n , sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        exist[nums[i]] = true;\\n    }\\n    int ans = 0;\\n    struct ListNode* tmp = head;\\n    int cn = 0;\\n    while(tmp){\\n        if(exist[tmp->val]){\\n            cn++;\\n        }\\n        else{\\n            if(cn)\\n                ans++;\\n            cn = 0;\\n        }\\n        tmp = tmp->next;\\n    }\\n    if(cn)\\n        ans++;\\n    free(exist);\\n    return ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint depth(struct ListNode* head){\\n    if(head == NULL)\\n        return 0;\\n    else\\n        return 1 + depth(head->next);\\n}\\nint numComponents(struct ListNode* head, int* nums, int numsSize){\\n    int n = depth(head);\\n    bool* exist = calloc(n , sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        exist[nums[i]] = true;\\n    }\\n    int ans = 0;\\n    struct ListNode* tmp = head;\\n    int cn = 0;\\n    while(tmp){\\n        if(exist[tmp->val]){\\n            cn++;\\n        }\\n        else{\\n            if(cn)\\n                ans++;\\n            cn = 0;\\n        }\\n        tmp = tmp->next;\\n    }\\n    if(cn)\\n        ans++;\\n    free(exist);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2843145,
                "title": "c-easy-understandable-code",
                "content": "What we use is unordered_set just because we have to see whether the element is eligible to become a component and we cannot apply .find function on vector so what we done we define a set and assign vector values to it.\\nAfter that we traverse the whole linked list if we found a non component element we simply update our result with the flag value.\\nAnd the last condition is for remaining component if left over then for that consideration we done that if part\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>set;\\n        for(int i:nums){\\n            set.insert(i);\\n        }\\n        int res=0,flag=0;\\n        while(head){\\n            \\n            if(set.find(head->val)!=set.end()){\\n                flag=1;\\n            }\\n            else{\\n                res+=flag;\\n                flag=0;\\n            }\\n            head=head->next;\\n        }\\n        if(flag==1)res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>set;\\n        for(int i:nums){\\n            set.insert(i);\\n        }\\n        int res=0,flag=0;\\n        while(head){\\n            \\n            if(set.find(head->val)!=set.end()){\\n                flag=1;\\n            }\\n            else{\\n                res+=flag;\\n                flag=0;\\n            }\\n            head=head->next;\\n        }\\n        if(flag==1)res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261733,
                "title": "python-o-1-solution-without-hash-set",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        if not head:\\n            return 0\\n        \\n        connected_component = 0\\n        total = 0\\n        \\n        while head:\\n            if head.val in nums:\\n                connected_component+=1\\n            else:\\n                if connected_component > 0:\\n                    total+=1\\n                    connected_component = 0\\n            head = head.next\\n            \\n        if connected_component > 0:\\n            total+=1\\n            connected_component = 0\\n\\n        return total\\n                    \\n                \\n                \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        if not head:\\n            return 0\\n        \\n        connected_component = 0\\n        total = 0\\n        \\n        while head:\\n            if head.val in nums:\\n                connected_component+=1\\n            else:\\n                if connected_component > 0:\\n                    total+=1\\n                    connected_component = 0\\n            head = head.next\\n            \\n        if connected_component > 0:\\n            total+=1\\n            connected_component = 0\\n\\n        return total\\n                    \\n                \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230598,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        if(head == NULL) return 0;\\n        \\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        auto it = m.begin();\\n        int count = 0, flag = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]] = 1;\\n        }\\n        \\n        while(head != NULL)\\n        {\\n            it = m.find(head->val);\\n            if(it != m.end() && (*it).second == 1)\\n            {\\n                it = m.find(head->val);\\n                v.push_back(1);\\n            }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n            head = head->next;\\n        }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(flag != v[i])\\n            {\\n                if(v[i] == 1)\\n                {\\n                    count++;\\n                }\\n                flag = v[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        if(head == NULL) return 0;\\n        \\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        auto it = m.begin();\\n        int count = 0, flag = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]] = 1;\\n        }\\n        \\n        while(head != NULL)\\n        {\\n            it = m.find(head->val);\\n            if(it != m.end() && (*it).second == 1)\\n            {\\n                it = m.find(head->val);\\n                v.push_back(1);\\n            }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n            head = head->next;\\n        }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(flag != v[i])\\n            {\\n                if(v[i] == 1)\\n                {\\n                    count++;\\n                }\\n                flag = v[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186950,
                "title": "c-few-lines-of-code-set-hashing",
                "content": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> s;\\n        //storing every lement of nums in set\\n        for(auto i:nums) s.insert(i);\\n        ListNode* temp=head;\\n        while(temp->next!=NULL and temp!=NULL){\\n            //if the value next to temp pointer is  present in set than it forms a connected component\\n            if(s.find(temp->next->val)!=s.end()){\\n                //removing current node from set so that only one node from each connected component will\\n                //be present in set\\n                s.erase(temp->val);\\n            }\\n            temp=temp->next;\\n        }\\n        return s.size();\\n    }\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> s;\\n        //storing every lement of nums in set\\n        for(auto i:nums) s.insert(i);\\n        ListNode* temp=head;\\n        while(temp->next!=NULL and temp!=NULL){\\n            //if the value next to temp pointer is  present in set than it forms a connected component\\n            if(s.find(temp->next->val)!=s.end()){\\n                //removing current node from set so that only one node from each connected component will\\n                //be present in set\\n                s.erase(temp->val);\\n            }\\n            temp=temp->next;\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2160518,
                "title": "easy-explanation-using-hashset-o-n-with-comments",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> st;  // save all values of nums in hashset\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        if(head->next==NULL){             // check for edge case , if theirs only one node \\n            if(st.find(head->val)!=st.end()){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int count=0;\\n\\n        while(head){\\n            \\n            if(st.find(head->val)!=st.end()){ // if head->val is present in set\\n                \\n            while(st.find(head->val)!=st.end() && head && head->next){ \\n// since we need connected components we keep incrementing our pointer untill its val is present in set\\n                head=head->next;\\n            }\\n// as we get out of the while loop we increment our counter- meaning 1 component is added \\n            count++;\\n            }\\n// if head->val not in set , we simply increment our pointer to check for next node\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> st;  // save all values of nums in hashset\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        if(head->next==NULL){             // check for edge case , if theirs only one node \\n            if(st.find(head->val)!=st.end()){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int count=0;\\n\\n        while(head){\\n            \\n            if(st.find(head->val)!=st.end()){ // if head->val is present in set\\n                \\n            while(st.find(head->val)!=st.end() && head && head->next){ \\n// since we need connected components we keep incrementing our pointer untill its val is present in set\\n                head=head->next;\\n            }\\n// as we get out of the while loop we increment our counter- meaning 1 component is added \\n            count++;\\n            }\\n// if head->val not in set , we simply increment our pointer to check for next node\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093002,
                "title": "simple-logical-c-code-83-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int> components;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            components[nums[i]]++;\\n        }\\n        int cnt = 0;\\n        bool breakpoint = false;\\n        while(head)\\n        {\\n            if(!components.count(head->val))\\n            {\\n                breakpoint = false;\\n            }\\n            else if(components.count(head->val) && !breakpoint)\\n            {\\n                cnt++;\\n                breakpoint = true;\\n            }\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int> components;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            components[nums[i]]++;\\n        }\\n        int cnt = 0;\\n        bool breakpoint = false;\\n        while(head)\\n        {\\n            if(!components.count(head->val))\\n            {\\n                breakpoint = false;\\n            }\\n            else if(components.count(head->val) && !breakpoint)\\n            {\\n                cnt++;\\n                breakpoint = true;\\n            }\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941599,
                "title": "java-solution-fastser-than-90-percent-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int entry:nums){\\n            set.add(entry);\\n        }\\n        int count =0;\\n        boolean  isconnected =false;\\n        ListNode temp = head;\\n        \\n        while( temp !=null){\\n            \\n            if(set.contains(temp.val)){\\n                if(isconnected==false){\\n                    isconnected = true;\\n                    count++;\\n                }\\n            }\\n            else{\\n                isconnected = false;\\n            }\\n            temp = temp.next;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int entry:nums){\\n            set.add(entry);\\n        }\\n        int count =0;\\n        boolean  isconnected =false;\\n        ListNode temp = head;\\n        \\n        while( temp !=null){\\n            \\n            if(set.contains(temp.val)){\\n                if(isconnected==false){\\n                    isconnected = true;\\n                    count++;\\n                }\\n            }\\n            else{\\n                isconnected = false;\\n            }\\n            temp = temp.next;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908379,
                "title": "easy-java-soln",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            numSet.add(nums[i]);\\n        }\\n        \\n        int sequences = 0;\\n        \\n        \\n        boolean inASequence = false;\\n        \\n        while(head != null) {\\n            \\n            if(inASequence) {\\n                if(numSet.contains(head.val)){ // If we are in a sequence and we encounter something part of array just continue.\\n                    head = head.next;\\n                    continue;\\n                } \\n                inASequence = false;\\n                head = head.next;\\n            } else { // If we are not in a sequence and a Sequence starts then increase sequence count and set flag to true.\\n                if(numSet.contains(head.val)) {\\n                    inASequence = true;\\n                    sequences++;\\n                }\\n                head = head.next;   \\n            }\\n        }\\n        return sequences;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            numSet.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1899949,
                "title": "linked-list-components",
                "content": "\\t\\tcount=0\\n        seen=set(nums)\\n        prev=None\\n        while(head):\\n            if(head.val in seen and prev not in seen):\\n                count+=1\\n            prev,head=head.val,head.next\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tcount=0\\n        seen=set(nums)\\n        prev=None\\n        while(head):\\n            if(head.val in seen and prev not in seen):\\n                count+=1\\n            prev,head=head.val,head.next\\n        return count",
                "codeTag": "Unknown"
            },
            {
                "id": 1897485,
                "title": "easy-c-solution-better-runtime-than-99-86-and-better-memory-usage-than-81-48",
                "content": "The approach is simple. We first use a boolean vector to store if the elements are present or not. Then we start iterating the linked list and for each connected component, we increment the ans by 1. \\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        vector<bool> subsetNodesTrack(10000,0);\\n        for(int num:nums) subsetNodesTrack[num]=1;\\n        ListNode* curr=head;\\n        int ans=0;\\n        while(curr){\\n            if(subsetNodesTrack[curr->val]) {\\n                while(curr && subsetNodesTrack[curr->val]) curr=curr->next;\\n                ans++;\\n            }\\n            else curr=curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        vector<bool> subsetNodesTrack(10000,0);\\n        for(int num:nums) subsetNodesTrack[num]=1;\\n        ListNode* curr=head;\\n        int ans=0;\\n        while(curr){\\n            if(subsetNodesTrack[curr->val]) {\\n                while(curr && subsetNodesTrack[curr->val]) curr=curr->next;\\n                ans++;\\n            }\\n            else curr=curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883418,
                "title": "c-without-extra-memory-clean-concise-code",
                "content": "**Liked the code? Please do upvote it :)**\\n\\n```\\nclass Solution{\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        int cnt = 0, connect = 0, last = 0;\\n        \\n        while(head != NULL)\\n        {\\n            connect = (find(nums.begin(), nums.end(), head->val) != nums.end());\\n            \\n            if(last == 1 and connect == 0)\\n                ++cnt;\\n            \\n            last = connect;\\n            head = head->next;\\n        }\\n        \\n        cnt += (connect == 1);\\n        return cnt;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        int cnt = 0, connect = 0, last = 0;\\n        \\n        while(head != NULL)\\n        {\\n            connect = (find(nums.begin(), nums.end(), head->val) != nums.end());\\n            \\n            if(last == 1 and connect == 0)\\n                ++cnt;\\n            \\n            last = connect;\\n            head = head->next;\\n        }\\n        \\n        cnt += (connect == 1);\\n        return cnt;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879178,
                "title": "easy-c-sol",
                "content": "int numComponents(struct ListNode* head, int* nums, int numsSize){\\n\\n    int c[10000]={0};\\n    for(int i=0;i<numsSize;i++)\\n        c[nums[i]]++;\\n    \\n    struct ListNode* next= head;\\n    \\n    int z=0;\\n    \\n    while(next!=NULL){\\n        if(next!=NULL && c[next->val]==1){\\n            while(next!=NULL && c[next->val]==1){\\n                next=next->next;\\n            }\\n            z++;\\n        }\\n        else next=next->next;\\n    }\\n    \\n    return z;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int numComponents(struct ListNode* head, int* nums, int numsSize){\\n\\n    int c[10000]={0};\\n    for(int i=0;i<numsSize;i++)\\n        c[nums[i]]++;\\n    \\n    struct ListNode* next= head;\\n    \\n    int z=0;\\n    \\n    while(next!=NULL){\\n        if(next!=NULL && c[next->val]==1){\\n            while(next!=NULL && c[next->val]==1){\\n                next=next->next;\\n            }\\n            z++;\\n        }\\n        else next=next->next;\\n    }\\n    \\n    return z;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1837296,
                "title": "jave-hashset-o-n",
                "content": "```\\npublic int numComponents(ListNode head, int[] nums) {\\n        // Put all elements into a set.\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        \\n        // Initialize a pointer going through the list.\\n        ListNode curr = head;       \\n        // Initialize a flag, set to true when seeing set element in linkedlist.\\n        boolean flag = false;        \\n        // Initialize result variable.\\n        int res = 0;\\n        \\n        while (curr != null) {\\n            if (set.contains(curr.val)) {\\n                // No need to count res for connected element in linkedlist.\\n                if (!flag) {\\n                    res++;\\n                }\\n                flag = true;   \\n            } else {\\n                flag = false;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numComponents(ListNode head, int[] nums) {\\n        // Put all elements into a set.\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        \\n        // Initialize a pointer going through the list.\\n        ListNode curr = head;       \\n        // Initialize a flag, set to true when seeing set element in linkedlist.\\n        boolean flag = false;        \\n        // Initialize result variable.\\n        int res = 0;\\n        \\n        while (curr != null) {\\n            if (set.contains(curr.val)) {\\n                // No need to count res for connected element in linkedlist.\\n                if (!flag) {\\n                    res++;\\n                }\\n                flag = true;   \\n            } else {\\n                flag = false;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805625,
                "title": "c-leetcode-817-simple-hashing-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(int x : arr)m[x]++;\\n        int count = 0;\\n        ListNode* node = head;\\n        while(node!=NULL){\\n            int done = 0;\\n            while(node!=NULL && m[node->val]>0){\\n                node=node->next;\\n                done = 1;\\n            }\\n            if(done)count++;\\n            while(node!=NULL && m[node->val]==0){\\n                node=node->next;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(int x : arr)m[x]++;\\n        int count = 0;\\n        ListNode* node = head;\\n        while(node!=NULL){\\n            int done = 0;\\n            while(node!=NULL && m[node->val]>0){\\n                node=node->next;\\n                done = 1;\\n            }\\n            if(done)count++;\\n            while(node!=NULL && m[node->val]==0){\\n                node=node->next;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787773,
                "title": "java-o-n-using-hashset",
                "content": "```\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i : nums) set.add(i);\\n        \\n        int ans = 0;\\n        while(head != null){\\n            boolean count = true;\\n            while(set.contains(head.val)){\\n                if(count) ans++;\\n                count = false;\\n                if(head.next != null) head = head.next;\\n                else break;\\n            }\\n\\n            head = head.next;\\n            \\n        }\\n        return ans;\\n    }\\n\\t```\\n\\t\\n\\tvery ez understandble solution using a hashset to store the num array for fast lookup.\\n\\t\\n\\tTime : O(n)\\n\\tSpace : O( size of nums[] ) or O( nums.length )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i : nums) set.add(i);\\n        \\n        int ans = 0;\\n        while(head != null){\\n            boolean count = true;\\n            while(set.contains(head.val)){\\n                if(count) ans++;\\n                count = false;\\n                if(head.next != null) head = head.next;\\n                else break;\\n            }\\n\\n            head = head.next;\\n            \\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732435,
                "title": "didn-t-understand-the-test-case",
                "content": "Please explain me this test case, \\n```\\nInput: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nInput: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669475,
                "title": "python-faster-than-95",
                "content": "```\\nhashed = {}\\nfor n in nums:\\n\\thashed[n] = 0\\ncomponents = 0\\nprev_in_comp = in_comp = False\\nwhile head:\\n\\tprev_in_comp = in_comp\\n\\tif head.val in hashed:\\n\\t\\tin_comp = True\\n\\telse:\\n\\t\\tin_comp = False\\n\\tif not prev_in_comp and in_comp:\\n\\t\\tcomponents += 1\\n\\thead = head.next\\nreturn components\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nhashed = {}\\nfor n in nums:\\n\\thashed[n] = 0\\ncomponents = 0\\nprev_in_comp = in_comp = False\\nwhile head:\\n\\tprev_in_comp = in_comp\\n\\tif head.val in hashed:\\n\\t\\tin_comp = True\\n\\telse:\\n\\t\\tin_comp = False\\n\\tif not prev_in_comp and in_comp:\\n\\t\\tcomponents += 1\\n\\thead = head.next\\nreturn components\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1654638,
                "title": "java-easy-solution",
                "content": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums) set.add(i);\\n        int result=0;\\n        while(head!=null){\\n            if(set.contains(head.val)){\\n                while(head!=null&&set.contains(head.val))\\n                    head=head.next;\\n                result++;\\n            }\\n            else\\n                head=head.next;\\n        }\\n        \\n       \\n        return result;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums) set.add(i);\\n        int result=0;\\n        while(head!=null){\\n            if(set.contains(head.val)){\\n                while(head!=null&&set.contains(head.val))\\n                    head=head.next;\\n                result++;\\n            }\\n            else\\n                head=head.next;\\n        }\\n        \\n       \\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594482,
                "title": "python-solution-simple-one-pass-time-o-n-2-space-o-1",
                "content": "```\\n        res = 0\\n        hasConnection = False\\n        while head:\\n            if head.val in nums:\\n                hasConnection = True\\n            elif hasConnection:\\n                res += 1\\n                hasConnection = False\\n            head = head.next\\n        if hasConnection:\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n        res = 0\\n        hasConnection = False\\n        while head:\\n            if head.val in nums:\\n                hasConnection = True\\n            elif hasConnection:\\n                res += 1\\n                hasConnection = False\\n            head = head.next\\n        if hasConnection:\\n            res += 1\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578443,
                "title": "python3-solution-with-using-hashset",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        s = set(G)\\n        res = 0\\n        \\n        while head:\\n            if head.val in s and (head.next == None or head.next.val not in s):\\n                res += 1\\n        \\n            head = head.next\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        s = set(G)\\n        res = 0\\n        \\n        while head:\\n            if head.val in s and (head.next == None or head.next.val not in s):\\n                res += 1\\n        \\n            head = head.next\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536475,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        \\n        nums = set(nums)\\n        curr = False\\n        count = 0\\n        \\n        while head :\\n            top = head.val\\n            if top in nums :\\n                if not curr :\\n                    count += 1\\n                    curr = True       \\n            else :\\n                curr = False\\n            head = head.next\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        \\n        nums = set(nums)\\n        curr = False\\n        count = 0\\n        \\n        while head :\\n            top = head.val\\n            if top in nums :\\n                if not curr :\\n                    count += 1\\n                    curr = True       \\n            else :\\n                curr = False\\n            head = head.next\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496457,
                "title": "rust-4ms-iterator-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\npub fn num_components(head: Option<Box<ListNode>>, nums: Vec<i32>) -> i32 {\\n    let nums: HashSet<_> = nums.into_iter().collect();\\n    (0..).scan(&head, |node, _| node.as_deref().map(|ListNode { val, next }| {\\n            *node = next;\\n            nums.contains(&val)\\n        })).fuse()\\n        .fold((0, false), |(cnt, pre), b| (i32::from(b && !pre) + cnt, b)).0\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\npub fn num_components(head: Option<Box<ListNode>>, nums: Vec<i32>) -> i32 {\\n    let nums: HashSet<_> = nums.into_iter().collect();\\n    (0..).scan(&head, |node, _| node.as_deref().map(|ListNode { val, next }| {\\n            *node = next;\\n            nums.contains(&val)\\n        })).fuse()\\n        .fold((0, false), |(cnt, pre), b| (i32::from(b && !pre) + cnt, b)).0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1493468,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        int size = 0;\\n        while(head != null){\\n            if(set.contains(head.val)){\\n                size++;\\n                while(head.next != null && set.contains(head.next.val)){\\n                    head = head.next;\\n                }\\n            }\\n            head = head.next;\\n        }\\n        \\n        return size;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            set.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1428337,
                "title": "simple-solution-using-a-set",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int result = 0;\\n        \\n        for(int num : nums)\\n            set.add(num);\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null) {\\n            if(set.contains(curr.val) && (curr.next == null || !set.contains(curr.next.val)))\\n                result++;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int result = 0;\\n        \\n        for(int num : nums)\\n            set.add(num);\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null) {\\n            if(set.contains(curr.val) && (curr.next == null || !set.contains(curr.next.val)))\\n                result++;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423495,
                "title": "hashset-hashmap-c-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans=0;\\n        auto p = head;\\n        map<int,int> m;\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(p!=NULL && p->next!=NULL){\\n            int a = p->val;\\n            m[a]=p->next->val;\\n            p=p->next;\\n        }\\n        m[p->val]=-1;\\n        for(auto x:nums){\\n            if(s.find(m[x])!=s.end()) continue;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans=0;\\n        auto p = head;\\n        map<int,int> m;\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(p!=NULL && p->next!=NULL){\\n            int a = p->val;\\n            m[a]=p->next->val;\\n            p=p->next;\\n        }\\n        m[p->val]=-1;\\n        for(auto x:nums){\\n            if(s.find(m[x])!=s.end()) continue;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391515,
                "title": "python3-simple-hashmap-solution",
                "content": "```\\n#TIME COMPLEXITY - O(len(nums)+N)\\n#SPACE COMPLEXITY - O(len(nums))\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        hmap={}\\n        for i in range(len(nums)):\\n            if nums[i] not in hmap:\\n                hmap[nums[i]]=1\\n            else:\\n                hmap[nums[i]]+=1\\n        temp=head\\n        cnt=0\\n        while temp:\\n            if temp.val in hmap:\\n                curr=temp\\n                while curr and curr.val in hmap:\\n                    curr=curr.next\\n                temp=curr\\n                cnt+=1\\n            else:\\n                temp=temp.next\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#TIME COMPLEXITY - O(len(nums)+N)\\n#SPACE COMPLEXITY - O(len(nums))\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        hmap={}\\n        for i in range(len(nums)):\\n            if nums[i] not in hmap:\\n                hmap[nums[i]]=1\\n            else:\\n                hmap[nums[i]]+=1\\n        temp=head\\n        cnt=0\\n        while temp:\\n            if temp.val in hmap:\\n                curr=temp\\n                while curr and curr.val in hmap:\\n                    curr=curr.next\\n                temp=curr\\n                cnt+=1\\n            else:\\n                temp=temp.next\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391309,
                "title": "c-easy-solution-all-methods-faster-than-90",
                "content": "METHOD1: Using sorting and binary search (T(n) = O(nlgn) and S(n) = O(1))\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val)) {\\n                head = head->next;\\n                while (head and binary_search(nums.begin(), nums.end(), head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD2: Variant of Method1;\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val) and (!head->next or !binary_search(nums.begin(), nums.end(), head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD3 : using set (T(n) = S(n) = O(n))\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val)) {\\n                head = head->next;\\n                while (head and numbers.count(head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD4: Variant of Method3;\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val) and (!head->next or !numbers.count(head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val)) {\\n                head = head->next;\\n                while (head and binary_search(nums.begin(), nums.end(), head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val) and (!head->next or !binary_search(nums.begin(), nums.end(), head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val)) {\\n                head = head->next;\\n                while (head and numbers.count(head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val) and (!head->next or !numbers.count(head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337700,
                "title": "runtime-24ms-faster-than-98-c-solution",
                "content": "```\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++) s.insert(nums[i]);\\n        int c=0,f=0;\\n        while(head!=NULL){\\n            if(s.find(head->val)!=s.end()){\\n                if(!f)\\n                    f=1;\\n            }\\n            else{\\n                if(f){\\n                    c++;\\n                    f=0;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        if(f)\\n            c++;\\n        return c;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++) s.insert(nums[i]);\\n        int c=0,f=0;\\n        while(head!=NULL){\\n            if(s.find(head->val)!=s.end()){\\n                if(!f)\\n                    f=1;\\n            }\\n            else{\\n                if(f){\\n                    c++;\\n                    f=0;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        if(f)\\n            c++;\\n        return c;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1329190,
                "title": "c-solution-with-proper-explanation",
                "content": "Need to find the connected components ;\\nConditions :-\\n   1 . If there is a set of elements in nums (subset provided) is a connected sub-list in LinkedList then count it as 1.\\n   2. Count the remaining elements in nums (subset provided) which are in Linked-List as 1 for each.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> st(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        \\n        while(head!=NULL)\\n        {\\n            if(st.count(head->val))   //If an ele from num present in LinkedList\\n            {\\n                count++;     //Increase count by 1\\n                while(head!=NULL && st.count(head->val)) head = head->next;   // move all the connected elements to include in one set if available\\n            }\\n            else\\n                head = head->next;  //else simply move forward\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\nPlease Upvote if it helps you. Thanks !",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> st(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        \\n        while(head!=NULL)\\n        {\\n            if(st.count(head->val))   //If an ele from num present in LinkedList\\n            {\\n                count++;     //Increase count by 1\\n                while(head!=NULL && st.count(head->val)) head = head->next;   // move all the connected elements to include in one set if available\\n            }\\n            else\\n                head = head->next;  //else simply move forward\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294811,
                "title": "python-simple-solution",
                "content": "```\\ndef numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        d = set(nums)\\n        count = 0\\n        c = 0\\n        temp = head\\n        while temp:\\n            if temp.val in d:\\n                c=1\\n            else:\\n                count+=c\\n                c=0\\n            temp= temp.next\\n        return count+c",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\ndef numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        d = set(nums)\\n        count = 0\\n        c = 0\\n        temp = head\\n        while temp:\\n            if temp.val in d:\\n                c=1\\n            else:\\n                count+=c\\n                c=0\\n            temp= temp.next\\n        return count+c",
                "codeTag": "Python3"
            },
            {
                "id": 1266940,
                "title": "easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        int count=0,flag=0;\\n        while(head!=NULL)\\n             {\\n             auto it=find(G.begin(),G.end(),head->val);\\n             if(it!=G.end()&&flag==0)\\n             {\\n                 count++;\\n                 flag=1;\\n             }\\n             else if(it==G.end())\\n                 flag=0;\\n        head=head->next;\\n         }\\n        return count;\\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        int count=0,flag=0;\\n        while(head!=NULL)\\n             {\\n             auto it=find(G.begin(),G.end(),head->val);\\n             if(it!=G.end()&&flag==0)\\n             {\\n                 count++;\\n                 flag=1;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1266023,
                "title": "struggling-with-explanation",
                "content": "Explanation is really bad, you can see this post for explaination (in comments) : https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\nOne You get the point, Question is really simple...\\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n     \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            hs.add(nums[i]);\\n        }\\n        \\n        int flag = 0,ans = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            if(flag == 0 && hs.contains(temp.val)){\\n                ans++;\\n                flag = 1; \\n            }\\n            else if(!hs.contains(temp.val)){\\n                flag = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n     \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            hs.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1241184,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G)\\n    {\\n        int count=0;\\n        unordered_set<int>s(G.begin(),G.end());\\n        while(head!=NULL)\\n        {\\n            int f=0;\\n            while(head!=NULL&&s.find(head->val)!=s.end())\\n            {\\n                f=1;\\n                head=head->next;\\n            }\\n            if(f)\\n            count++;\\n            if(head!=NULL)\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G)\\n    {\\n        int count=0;\\n        unordered_set<int>s(G.begin(),G.end());\\n        while(head!=NULL)\\n        {\\n            int f=0;\\n            while(head!=NULL&&s.find(head->val)!=s.end())\\n            {\\n                f=1;\\n                head=head->next;\\n            }\\n            if(f)\\n            count++;\\n            if(head!=NULL)\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231068,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      if(!head) return 0;\\n      \\n      int n = nums.size();\\n      \\n      if(n == 0) return 0;\\n      \\n      map<int,bool> vals;\\n      \\n      for(int i = 0; i < n; ++i) {\\n        vals[nums[i]] = true;\\n      }\\n      \\n      int noOfComponents = 0;\\n      \\n      for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next) {\\n        if(vals.find(ptr->val) != vals.end()) {\\n          while(ptr && vals.find(ptr->val) != vals.end()) {\\n            ptr = ptr->next;\\n          }\\n          ++noOfComponents;\\n        }\\n        if(!ptr) break;\\n      }\\n      \\n      return noOfComponents;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      if(!head) return 0;\\n      \\n      int n = nums.size();\\n      \\n      if(n == 0) return 0;\\n      \\n      map<int,bool> vals;\\n      \\n      for(int i = 0; i < n; ++i) {\\n        vals[nums[i]] = true;\\n      }\\n      \\n      int noOfComponents = 0;\\n      \\n      for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next) {\\n        if(vals.find(ptr->val) != vals.end()) {\\n          while(ptr && vals.find(ptr->val) != vals.end()) {\\n            ptr = ptr->next;\\n          }\\n          ++noOfComponents;\\n        }\\n        if(!ptr) break;\\n      }\\n      \\n      return noOfComponents;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222007,
                "title": "simple-and-easy-python",
                "content": "As long as the head.next.val is in the nums we continue without increasing the count. \\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count = 0\\n        num = set(nums)\\n        while head:\\n            if head.val in num and (head.next==None or head.next.val not in num):\\n                count+=1\\n            head = head.next\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count = 0\\n        num = set(nums)\\n        while head:\\n            if head.val in num and (head.next==None or head.next.val not in num):\\n                count+=1\\n            head = head.next\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169662,
                "title": "java-solution",
                "content": "Scanning through head.value is present in G and head.next.val is not or including head.next==null. \\n\\n```\\npublic int numComponents(ListNode head, int[] G) {\\n        int result =0;\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<G.length;i++){\\n            set.add(G[i]);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                result++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numComponents(ListNode head, int[] G) {\\n        int result =0;\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<G.length;i++){\\n            set.add(G[i]);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                result++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132678,
                "title": "java-easy-solution-hashset",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] arr) {\\n      ListNode node=head;\\n      Set<Integer> set=new HashSet<>();\\n      for(int val:arr) set.add(val);\\n    \\n      int ans=0;\\n     \\n      while(node!=null){\\n        if(set.contains(node.val) && (node.next==null ||  !set.contains(node.next.val))){\\n           ans++;\\n        }\\n        node=node.next;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] arr) {\\n      ListNode node=head;\\n      Set<Integer> set=new HashSet<>();\\n      for(int val:arr) set.add(val);\\n    \\n      int ans=0;\\n     \\n      while(node!=null){\\n        if(set.contains(node.val) && (node.next==null ||  !set.contains(node.next.val))){\\n           ans++;\\n        }\\n        node=node.next;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095530,
                "title": "simple-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> hash=new HashSet<Integer>();\\n        \\n        for(int i=0;i<G.length;i++){\\n            hash.add(G[i]);\\n        }\\n        \\n        ListNode parent=null;\\n        ListNode current=head;\\n        int numOfComponents=0;\\n        \\n        while(current != null){\\n            if(parent == null){\\n                if(hash.contains(current.val))\\n                {\\n                    numOfComponents++;\\n                }\\n            }else{\\n                if(!hash.contains(parent.val) && hash.contains(current.val)){\\n                    numOfComponents++;\\n                }\\n            }\\n            parent=current;\\n            current=current.next;\\n        }\\n        return numOfComponents;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> hash=new HashSet<Integer>();\\n        \\n        for(int i=0;i<G.length;i++){\\n            hash.add(G[i]);\\n        }\\n        \\n        ListNode parent=null;\\n        ListNode current=head;\\n        int numOfComponents=0;\\n        \\n        while(current != null){\\n            if(parent == null){\\n                if(hash.contains(current.val))\\n                {\\n                    numOfComponents++;\\n                }\\n            }else{\\n                if(!hash.contains(parent.val) && hash.contains(current.val)){\\n                    numOfComponents++;\\n                }\\n            }\\n            parent=current;\\n            current=current.next;\\n        }\\n        return numOfComponents;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072342,
                "title": "java-simpple-solution-faster-than-95",
                "content": "JAVA CODE IS:\\n#    \\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int v : G)\\n            set.add(v);\\n       boolean t=false;\\n        int count=0;\\n        while(head!=null){\\n          if(set.contains(head.val))\\n             t=true;\\n          else{\\n              count+=t==true ? 1 : 0;\\n              t=false;\\n          }   \\n            head=head.next;\\n        }\\n        count+=t==true ? 1 : 0;\\n        return count;\\n    }\\n}\\n```\\nTime : O(N)\\nSpace : O(N)\\n***PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int v : G)\\n            set.add(v);\\n       boolean t=false;\\n        int count=0;\\n        while(head!=null){\\n          if(set.contains(head.val))\\n             t=true;\\n          else{\\n              count+=t==true ? 1 : 0;\\n              t=false;\\n          }   \\n            head=head.next;\\n        }\\n        count+=t==true ? 1 : 0;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018853,
                "title": "python",
                "content": "```\\n\\tdef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        flag = False\\n        cnt = 0\\n        nums = set(G)\\n        \\n        while head:\\n            if head.val in nums and not flag:\\n                flag = True\\n                cnt += 1\\n            elif head.val not in nums:\\n                flag = False\\n            head = head.next\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        flag = False\\n        cnt = 0\\n        nums = set(G)\\n        \\n        while head:\\n            if head.val in nums and not flag:\\n                flag = True\\n                cnt += 1\\n            elif head.val not in nums:\\n                flag = False\\n            head = head.next\\n            \\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1016745,
                "title": "c-100-time-and-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if (G.size() == 0) {\\n            return 0;\\n        }\\n        sort(G.begin(), G.end()); // O(G * log(G))\\n        int count = 0;\\n        bool connecting = false;\\n        \\n        // O(linked_list_length)\\n        while (head != nullptr) {\\n            \\n            // O(log(G))\\n            if (binary_search(G.begin(), G.end(), head->val)) {\\n                if (!connecting) {\\n                    connecting = true;\\n                    count++;\\n                }\\n            } else if (connecting) {\\n                connecting = false;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if (G.size() == 0) {\\n            return 0;\\n        }\\n        sort(G.begin(), G.end()); // O(G * log(G))\\n        int count = 0;\\n        bool connecting = false;\\n        \\n        // O(linked_list_length)\\n        while (head != nullptr) {\\n            \\n            // O(log(G))\\n            if (binary_search(G.begin(), G.end(), head->val)) {\\n                if (!connecting) {\\n                    connecting = true;\\n                    count++;\\n                }\\n            } else if (connecting) {\\n                connecting = false;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928075,
                "title": "simple-python-solution-beat-96",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]):\\n        current = head\\n        S = set(G)\\n        res = 0\\n        \\n        while current:\\n            if current.val in S and current.next is None:\\n                res += 1\\n                \\n            elif current.val in S and current.next.val not in S:\\n                res += 1\\n                \\n            current = current.next\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]):\\n        current = head\\n        S = set(G)\\n        res = 0\\n        \\n        while current:\\n            if current.val in S and current.next is None:\\n                res += 1\\n                \\n            elif current.val in S and current.next.val not in S:\\n                res += 1\\n                \\n            current = current.next\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 914427,
                "title": "swift-simple-100",
                "content": "```\\n    func numComponents(_ head: ListNode?, _ G: [Int]) -> Int {\\n        let set = Set(G)\\n        var total = 0\\n        var connected = false\\n        var cur = head\\n        \\n        while cur != nil {\\n            \\n            //If number in subset found and it is not connected to another \\n            //number in the subset, we increase the component count by one\\n            if set.contains(cur!.val) {\\n                if connected == false { \\n                    connected = true\\n                    total += 1\\n                }\\n            }else {\\n                //Number not in subset, break connected streak\\n                connected = false\\n            } \\n            \\n            cur = cur?.next\\n        }\\n        \\n        return total\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func numComponents(_ head: ListNode?, _ G: [Int]) -> Int {\\n        let set = Set(G)\\n        var total = 0\\n        var connected = false\\n        var cur = head\\n        \\n        while cur != nil {\\n            \\n            //If number in subset found and it is not connected to another \\n            //number in the subset, we increase the component count by one\\n            if set.contains(cur!.val) {\\n                if connected == false { \\n                    connected = true\\n                    total += 1\\n                }\\n            }else {\\n                //Number not in subset, break connected streak\\n                connected = false\\n            } \\n            \\n            cur = cur?.next\\n        }\\n        \\n        return total\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873910,
                "title": "java-1ms-100-with-comments",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        boolean[] map = new boolean[10001];\\n        for(int num : G) {\\n            map[num] = true;\\n        }\\n        \\n        if(head == null) {\\n            return 0;\\n        }\\n        \\n        ListNode runner = head;\\n        \\n        // slide runner to the next possible component\\n        while(runner != null && !map[runner.val]) {\\n            runner = runner.next;\\n        }\\n        \\n        // no connected components\\n        if(runner == null) {\\n            return 0;\\n        }\\n        \\n        int connected = 1;\\n        while(runner != null) {\\n            if(!map[runner.val]) {\\n                // slide runner to the next possible component\\n                while(runner != null && !map[runner.val]) {\\n                    runner = runner.next;\\n                }\\n                \\n                // increase component count if we did not reach to the end\\n                // of the linked list\\n                if(runner != null) {                    \\n                    connected++;\\n                }\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        \\n        return connected;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        boolean[] map = new boolean[10001];\\n        for(int num : G) {\\n            map[num] = true;\\n        }\\n        \\n        if(head == null) {\\n            return 0;\\n        }\\n        \\n        ListNode runner = head;\\n        \\n        // slide runner to the next possible component\\n        while(runner != null && !map[runner.val]) {\\n            runner = runner.next;\\n        }\\n        \\n        // no connected components\\n        if(runner == null) {\\n            return 0;\\n        }\\n        \\n        int connected = 1;\\n        while(runner != null) {\\n            if(!map[runner.val]) {\\n                // slide runner to the next possible component\\n                while(runner != null && !map[runner.val]) {\\n                    runner = runner.next;\\n                }\\n                \\n                // increase component count if we did not reach to the end\\n                // of the linked list\\n                if(runner != null) {                    \\n                    connected++;\\n                }\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        \\n        return connected;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849185,
                "title": "can-someone-explain-this-test-case",
                "content": "```\\n0->1->2\\nG= [0,2]\\n```\\n\\n`Output : 2`\\nShouldn\\'t the output be 1 when I consider the fact that only ```2 ```from the Linekd list will be counted?",
                "solutionTags": [],
                "code": "```\\n0->1->2\\nG= [0,2]\\n```\n```2 ```",
                "codeTag": "Unknown"
            },
            {
                "id": 839426,
                "title": "binary-search-solution-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool binarysearch(vector<int> &G,int k){\\n        int si = 0;\\n        int ei = G.size()-1;\\n        while(si<=ei){\\n            int mid = (si+ei)/2;\\n            if(G[mid]==k) return true;\\n            else if(G[mid]<k) si=mid+1;\\n            else ei = mid-1;\\n        }\\n        return false;\\n    }\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        sort(G.begin(),G.end());\\n        ListNode *temp = head;\\n        int components = 0;\\n        int currsize = 0;\\n        while(temp){\\n            int val = temp->val;\\n            bool b = binarysearch(G,val);\\n            if(b){\\n               currsize++; \\n            }else{\\n                if(currsize) components++;\\n                currsize = 0;\\n            }\\n            temp = temp->next;\\n        }\\n        if(currsize) components++;\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binarysearch(vector<int> &G,int k){\\n        int si = 0;\\n        int ei = G.size()-1;\\n        while(si<=ei){\\n            int mid = (si+ei)/2;\\n            if(G[mid]==k) return true;\\n            else if(G[mid]<k) si=mid+1;\\n            else ei = mid-1;\\n        }\\n        return false;\\n    }\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        sort(G.begin(),G.end());\\n        ListNode *temp = head;\\n        int components = 0;\\n        int currsize = 0;\\n        while(temp){\\n            int val = temp->val;\\n            bool b = binarysearch(G,val);\\n            if(b){\\n               currsize++; \\n            }else{\\n                if(currsize) components++;\\n                currsize = 0;\\n            }\\n            temp = temp->next;\\n        }\\n        if(currsize) components++;\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718172,
                "title": "simple-python-no-getattr",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        graph = set(G)\\n        components = 0\\n        while head:\\n            if head.val in graph and (not head.next or head.next.val not in graph):\\n                components += 1\\n            head = head.next\\n        return components\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        graph = set(G)\\n        components = 0\\n        while head:\\n            if head.val in graph and (not head.next or head.next.val not in graph):\\n                components += 1\\n            head = head.next\\n        return components\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668565,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "We use a set so we can search element in O(1)\\nNow we traverse linked list and keep track of connected elements we have seen so far.\\nIncrement when connectivity is lost.\\n```\\ndef numComponents(self, head, G):\\n        subsetVals = set(G)\\n        current = head\\n        comps = 0\\n        elementsInComp = 0\\n        while current != None:\\n            curVal = current.val\\n            if curVal in subsetVals:\\n                elementsInComp += 1\\n            else:\\n                if elementsInComp > 0:\\n                    elementsInComp = 0\\n                    comps += 1\\n            current = current.next\\n        if elementsInComp > 0:\\n            comps += 1\\n        return comps\\n```",
                "solutionTags": [],
                "code": "```\\ndef numComponents(self, head, G):\\n        subsetVals = set(G)\\n        current = head\\n        comps = 0\\n        elementsInComp = 0\\n        while current != None:\\n            curVal = current.val\\n            if curVal in subsetVals:\\n                elementsInComp += 1\\n            else:\\n                if elementsInComp > 0:\\n                    elementsInComp = 0\\n                    comps += 1\\n            current = current.next\\n        if elementsInComp > 0:\\n            comps += 1\\n        return comps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 661254,
                "title": "python-3-two-pointer",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count = 0\\n        p1, p2 = head, head\\n        while p2:\\n            if p1.val in G:\\n                p2 = p1.next\\n                p1 = p2\\n                if not p2 or p2.val not in G:\\n                    count+=1\\n            else:\\n                p1 = p2.next\\n                p2 = p1\\n        return count\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count = 0\\n        p1, p2 = head, head\\n        while p2:\\n            if p1.val in G:\\n                p2 = p1.next\\n                p1 = p2\\n                if not p2 or p2.val not in G:\\n                    count+=1\\n            else:\\n                p1 = p2.next\\n                p2 = p1\\n        return count\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 622539,
                "title": "java-simple-easy-solution-using-hashset",
                "content": "Java\\n\\n```\\n\\nThe problem has straight solution which are as follows:-\\n\\n1. First Move all  element of G  into a another datastruture which can be used to detect the presence of element of G. \\n2. This can be achieved by using creating a HashSet or by creating the array of size the max element. then putting the element in its proper position.\\n3. Then simply traverse the LinkedList and check the element present in HashSet.\\n4. If It is present in the HashSet, the simply **set = 1**. if it is not present then check set = 1 , and increment the count.\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> h = new HashSet<>();\\n        for(int num : G) {\\n            h.add(num);\\n        }\\n        int count = 0,set = 0;\\n        while(head != null) {\\n            if(h.contains(head.val)) {\\n                set = 1;\\n            }else if(set == 1) {\\n                count++;\\n                set = 0;\\n            }\\n            head = head.next;\\n        }\\n        return set==1?count+1:count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nThe problem has straight solution which are as follows:-\\n\\n1. First Move all  element of G  into a another datastruture which can be used to detect the presence of element of G. \\n2. This can be achieved by using creating a HashSet or by creating the array of size the max element. then putting the element in its proper position.\\n3. Then simply traverse the LinkedList and check the element present in HashSet.\\n4. If It is present in the HashSet, the simply **set = 1**. if it is not present then check set = 1 , and increment the count.\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> h = new HashSet<>();\\n        for(int num : G) {\\n            h.add(num);\\n        }\\n        int count = 0,set = 0;\\n        while(head != null) {\\n            if(h.contains(head.val)) {\\n                set = 1;\\n            }else if(set == 1) {\\n                count++;\\n                set = 0;\\n            }\\n            head = head.next;\\n        }\\n        return set==1?count+1:count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617824,
                "title": "javascript-100-mem-95-faster",
                "content": "```\\nvar numComponents = function(head, G) {\\n    const set = new Set(G);\\n    let count = 0, prevConn = false;\\n    while(head) {\\n       const hasCon = set.has(head.val);\\n       if (!prevConn && hasCon) {\\n           count++;\\n       }\\n        prevConn = hasCon;\\n        head = head.next;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numComponents = function(head, G) {\\n    const set = new Set(G);\\n    let count = 0, prevConn = false;\\n    while(head) {\\n       const hasCon = set.has(head.val);\\n       if (!prevConn && hasCon) {\\n           count++;\\n       }\\n        prevConn = hasCon;\\n        head = head.next;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594744,
                "title": "100-space-and-time-super-simple-explanation",
                "content": "```\\nstatic int x = [](){ios::sync_with_stdio(false), cin.tie(NULL); return 0;}();\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& a) {\\n        \\n        bool s[10001]={};\\n        for(auto i:a)   s[i]=true;     //make hash to denote what all elements has been exists in array\\n        \\n        int ct=0;\\n        while(head)\\n        {\\n            bool b = false;\\n             while(head and s[head->val] )   // while connected \\n                   head = head->next , b = true;\\n            ct+=b;\\n            if(head)\\n                head = head->next;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int x = [](){ios::sync_with_stdio(false), cin.tie(NULL); return 0;}();\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& a) {\\n        \\n        bool s[10001]={};\\n        for(auto i:a)   s[i]=true;     //make hash to denote what all elements has been exists in array\\n        \\n        int ct=0;\\n        while(head)\\n        {\\n            bool b = false;\\n             while(head and s[head->val] )   // while connected \\n                   head = head->next , b = true;\\n            ct+=b;\\n            if(head)\\n                head = head->next;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556357,
                "title": "c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 536427,
                "title": "easy-c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if(head == NULL || G.size() == 0) return 0;\\n        unordered_set<int> hash;\\n        for(int i : G)\\n            hash.insert(i);\\n        ListNode* curr = head;\\n        int count = 0, res = 0;\\n        while(curr != NULL){\\n            if(hash.count(curr->val))\\n                count = 1;\\n            else if(!hash.count(curr->val) && count > 0){\\n                res++;\\n                count = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        return count > 0 ? res + 1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if(head == NULL || G.size() == 0) return 0;\\n        unordered_set<int> hash;\\n        for(int i : G)\\n            hash.insert(i);\\n        ListNode* curr = head;\\n        int count = 0, res = 0;\\n        while(curr != NULL){\\n            if(hash.count(curr->val))\\n                count = 1;\\n            else if(!hash.count(curr->val) && count > 0){\\n                res++;\\n                count = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        return count > 0 ? res + 1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498357,
                "title": "python3-93-14",
                "content": "```\\ndef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        if not head:\\n            return 0\\n        A = set(G)\\n        total = 0\\n        while head:\\n            if head.val in A:\\n                while head.next and head.next.val in A:\\n                    head = head.next\\n                total += 1\\n            head = head.next\\n        return total\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\ndef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        if not head:\\n            return 0\\n        A = set(G)\\n        total = 0\\n        while head:\\n            if head.val in A:\\n                while head.next and head.next.val in A:\\n                    head = head.next\\n                total += 1\\n            head = head.next\\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444135,
                "title": "python-expand-this-idea-to-tree-s-connected-components",
                "content": "**Approach 1(TLE):**\\n\\nIntital thoughts: In a linked list, a node\\'s connected components are its previous node and next node. First, we need to loop through the list to save all the tuples of node and its neighbors in a dictionary. \\n\\nThen we check every pairs of nodes (a, b) in G, to see if b is a neighbor of a; if so, we decrement the number of connected components, which is initailly set as the number of nodes in the original list, by 1.\\n\\nComplexity: \\n* Time: O(N + M choose 2 ) where N is the length of list and M is the length of G.\\n* Space: O(N) for the dictionary\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        d = collections.defaultdict(set)\\n        prev = dummy = ListNode(-1)\\n        dummy.next = head\\n\\t\\t\\n        p, nxt = head, head.next\\n        while p:\\n            d[p.val].add(prev.val) if prev else -1\\n            d[p.val].add(nxt.val) if nxt else -1\\n            if not p.next: break\\n            prev = p\\n            p = p.next\\n            nxt = nxt.next\\n            \\n        connNum = len(G)\\n        for a, b in itertools.combinations(G, 2):\\n            if b in d[a]:\\n                connNum -= 1\\n        return connNum\\n```\\n\\n**Approach 2:**\\nInstead of looking at two directions in the original list, we can just iterate through the list and look at the next node of the current node (`nxt`). If `cur` in G and `nxt` is not in G, it indicates that the current node itself is an isolate connected component; otherwise, current node and `nxt` are in the same connected component.\\n\\nComplexity: \\n* Time: O(N + M)\\n* Space: O(M) for the `Gset`\\n\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset = set(G)\\n        cur = head\\n        ans = 0\\n        while cur:\\n            if cur.val in Gset and getattr(cur.next, \\'val\\', None) not in Gset:\\n                ans += 1\\n            cur = cur.next\\n        return ans\\n```\\n\\n```\\n\\n```\\n-----------\\n**Possible Follow-up: What if the given input is the a tree and G contains TreeNodes?  Find the number of connected components in this tree**\\n\\n\\nAlgorithm:\\n* We can recursively find the number of connected components in the left subtree and the right subtree, namely, `ccLeft` and `ccRight`.\\n* Then the number of connected component in the current tree is the sum of `ccLeft` and `ccRight` and `X`, where `X` can be calculated using the concept in **the originaly problem:** If current node is in G and its sucessor is not, we increment number of connected components by 1. \\n\\t* Thus, if current is in G and only one child is in G, we don\\'t increment `temp` \\n\\t   \\t```\\n\\t\\t\\t o\\t\\t   o\\t      o\\n\\t\\t\\t/ \\\\\\t\\t  / \\\\        / \\\\\\t\\n\\t\\t   o   x     o   x      x   o \\n\\t\\t```\\n\\t    If current is in G and two child in G, in this special case, we increment `temp` by 1 .\\n\\t\\t```\\n\\t\\t\\t\\t o\\t\\n\\t\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t\\t   o   o  \\n\\t    ``` \\n\\t\\t**if current is in G and none if its children is in G, we increment `temp` by 1.**\\n\\t   \\t```\\n\\t\\t\\t o\\t\\t \\n\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t   x   x     \\n\\t\\t```\\n\\n\\nExample:\\n\\n```\\n\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   2    3\\n\\t\\t\\t\\t  / \\\\  /\\n\\t\\t\\t\\t 4  5  6\\n\\t\\t\\t    /\\\\     /\\\\\\n\\t\\t\\t   7  8   9 10\\n\\t\\t\\t  / \\\\\\n\\t\\t\\t 11 12\\n\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t   13 14\\n\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t 15 16\\n\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t17    18\\n\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tans = 6\\n```\\n```\\nimport collections\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass findComponentsInTree:\\n\\tdef __init__(self, G):\\n\\t\\tself.G = set(G)\\n\\n\\tdef numComponents(self, node):\\n\\t\\tprint(node.val if node else node)\\n\\t\\tif not node: return 0\\n\\t\\tcount = self.numComponents(node.left) + self.numComponents(node.right) + self.AdjustByShape(node)\\n\\t\\t#print(\"ajusted: \", node.val, self.AdjustByShape(node), count)\\n\\t\\treturn count\\n\\t\\n\\tdef AdjustByShape(self, node):\\n\\t\\tif node.val in self.G:\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif not node.left:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.right)\\n\\t\\t\\telif not node.right:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.left)\\n\\t\\t\\telif node.left.val in self.G and node.right.val in self.G:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif node.left.val in self.G or node.right.val in self.G:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\nif __name__ == \"__main__\":\\n\\t# construct a tree example\\n\\troot = TreeNode(1)\\n\\troot.left, root.right = TreeNode(2), TreeNode(3)\\n\\tp, q = root.left, root.right\\n\\tp.left, p.right = TreeNode(4), TreeNode(5)\\n\\tq.left, q.right = TreeNode(6), None\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(7), TreeNode(8)\\n\\tq = q.left\\n\\tq.left, q.right = TreeNode(9), TreeNode(10)\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(11), TreeNode(12)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(13), TreeNode(14)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(15), TreeNode(16)\\n\\tp, q = p.left, p.right\\n\\tp.left, p.right = TreeNode(17), None\\n\\tq.left, q.right = None, TreeNode(18)\\n\\t\\'\\'\\'\\n\\tdef printTreeByLevel(root):\\n\\t\\tlevels = []\\n\\t\\tqueue = collections.deque([root])\\n\\t\\twhile queue:\\n\\t\\t\\tlevel = []\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tlevel.append(node.val) \\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tlevels.append(level)\\n\\t\\tprint(levels)\\n\\n\\tprintTreeByLevel(root)\\n\\t\\'\\'\\'\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tsol = findComponentsInTree(G)\\n\\tprint(\"ans: \", sol.numComponents(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        d = collections.defaultdict(set)\\n        prev = dummy = ListNode(-1)\\n        dummy.next = head\\n\\t\\t\\n        p, nxt = head, head.next\\n        while p:\\n            d[p.val].add(prev.val) if prev else -1\\n            d[p.val].add(nxt.val) if nxt else -1\\n            if not p.next: break\\n            prev = p\\n            p = p.next\\n            nxt = nxt.next\\n            \\n        connNum = len(G)\\n        for a, b in itertools.combinations(G, 2):\\n            if b in d[a]:\\n                connNum -= 1\\n        return connNum\\n```\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset = set(G)\\n        cur = head\\n        ans = 0\\n        while cur:\\n            if cur.val in Gset and getattr(cur.next, \\'val\\', None) not in Gset:\\n                ans += 1\\n            cur = cur.next\\n        return ans\\n```\n```\\n\\n```\n```\\n\\t\\t\\t o\\t\\t   o\\t      o\\n\\t\\t\\t/ \\\\\\t\\t  / \\\\        / \\\\\\t\\n\\t\\t   o   x     o   x      x   o \\n\\t\\t```\n```\\n\\t\\t\\t\\t o\\t\\n\\t\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t\\t   o   o  \\n\\t    ```\n```\\n\\t\\t\\t o\\t\\t \\n\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t   x   x     \\n\\t\\t```\n```\\n\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   2    3\\n\\t\\t\\t\\t  / \\\\  /\\n\\t\\t\\t\\t 4  5  6\\n\\t\\t\\t    /\\\\     /\\\\\\n\\t\\t\\t   7  8   9 10\\n\\t\\t\\t  / \\\\\\n\\t\\t\\t 11 12\\n\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t   13 14\\n\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t 15 16\\n\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t17    18\\n\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tans = 6\\n```\n```\\nimport collections\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass findComponentsInTree:\\n\\tdef __init__(self, G):\\n\\t\\tself.G = set(G)\\n\\n\\tdef numComponents(self, node):\\n\\t\\tprint(node.val if node else node)\\n\\t\\tif not node: return 0\\n\\t\\tcount = self.numComponents(node.left) + self.numComponents(node.right) + self.AdjustByShape(node)\\n\\t\\t#print(\"ajusted: \", node.val, self.AdjustByShape(node), count)\\n\\t\\treturn count\\n\\t\\n\\tdef AdjustByShape(self, node):\\n\\t\\tif node.val in self.G:\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif not node.left:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.right)\\n\\t\\t\\telif not node.right:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.left)\\n\\t\\t\\telif node.left.val in self.G and node.right.val in self.G:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif node.left.val in self.G or node.right.val in self.G:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\nif __name__ == \"__main__\":\\n\\t# construct a tree example\\n\\troot = TreeNode(1)\\n\\troot.left, root.right = TreeNode(2), TreeNode(3)\\n\\tp, q = root.left, root.right\\n\\tp.left, p.right = TreeNode(4), TreeNode(5)\\n\\tq.left, q.right = TreeNode(6), None\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(7), TreeNode(8)\\n\\tq = q.left\\n\\tq.left, q.right = TreeNode(9), TreeNode(10)\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(11), TreeNode(12)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(13), TreeNode(14)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(15), TreeNode(16)\\n\\tp, q = p.left, p.right\\n\\tp.left, p.right = TreeNode(17), None\\n\\tq.left, q.right = None, TreeNode(18)\\n\\t\\'\\'\\'\\n\\tdef printTreeByLevel(root):\\n\\t\\tlevels = []\\n\\t\\tqueue = collections.deque([root])\\n\\t\\twhile queue:\\n\\t\\t\\tlevel = []\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tlevel.append(node.val) \\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tlevels.append(level)\\n\\t\\tprint(levels)\\n\\n\\tprintTreeByLevel(root)\\n\\t\\'\\'\\'\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tsol = findComponentsInTree(G)\\n\\tprint(\"ans: \", sol.numComponents(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436589,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset= set()\\n        \\n        for g in G:\\n            Gset.add(g)\\n        \\n        result=0\\n        \\n        while(head and head.val not in Gset):\\n            head= head.next\\n        prev= None\\n        while(head):\\n            if head.val not in Gset:\\n                result+=1\\n                while(head and head.val not in Gset):\\n                    prev= head\\n                    head= head.next\\n            else:\\n                prev= head\\n                head= head.next\\n        if prev and prev.val in Gset:\\n            result+=1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset= set()\\n        \\n        for g in G:\\n            Gset.add(g)\\n        \\n        result=0\\n        \\n        while(head and head.val not in Gset):\\n            head= head.next\\n        prev= None\\n        while(head):\\n            if head.val not in Gset:\\n                result+=1\\n                while(head and head.val not in Gset):\\n                    prev= head\\n                    head= head.next\\n            else:\\n                prev= head\\n                head= head.next\\n        if prev and prev.val in Gset:\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412720,
                "title": "c-concise-solution",
                "content": "Delete the node if it is not the last one for each groups. \\nAt the end, HashSet contains only 1 node per each group.\\n\\n```\\npublic class Solution {\\n    public int NumComponents(ListNode head, int[] G) {\\n        HashSet<int> hash = new HashSet<int>();\\n        foreach(int x in G)\\n            hash.Add(x);\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && hash.Contains(head.next.val))\\n                hash.Remove(head.val);\\n            head = head.next;\\n        }\\n        \\n        return hash.Count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumComponents(ListNode head, int[] G) {\\n        HashSet<int> hash = new HashSet<int>();\\n        foreach(int x in G)\\n            hash.Add(x);\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && hash.Contains(head.next.val))\\n                hash.Remove(head.val);\\n            head = head.next;\\n        }\\n        \\n        return hash.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400359,
                "title": "javascript-64ms-faster-than-90",
                "content": "```js\\nconst numComponents = (head, G) => {\\n    const set = new Set(G);\\n    let pointer = head,\\n\\t\\tstack = [],\\n\\t\\tans = 0;\\n\\t\\n    while (pointer) {\\n\\t\\t// If there\\'s overlapped number, push to stack  \\n        if (set.has(pointer.val)) {\\n            stack.push(pointer.val);\\n        } else {\\n\\t\\t\\t// Once the continuous stopped and there\\'s something in the stack, ans++  \\n            if (stack.length) {\\n                ans++;\\n                stack = [];\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\t\\n\\t// Check if there\\'s numbers left in stack\\n    return (stack.length) ? ans + 1 : ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numComponents = (head, G) => {\\n    const set = new Set(G);\\n    let pointer = head,\\n\\t\\tstack = [],\\n\\t\\tans = 0;\\n\\t\\n    while (pointer) {\\n\\t\\t// If there\\'s overlapped number, push to stack  \\n        if (set.has(pointer.val)) {\\n            stack.push(pointer.val);\\n        } else {\\n\\t\\t\\t// Once the continuous stopped and there\\'s something in the stack, ans++  \\n            if (stack.length) {\\n                ans++;\\n                stack = [];\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\t\\n\\t// Check if there\\'s numbers left in stack\\n    return (stack.length) ? ans + 1 : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342745,
                "title": "why-so-many-dislikes-to-this-question",
                "content": "I mean the question is not tough but is there a reason behind so many dislikes to this question?\\nThe solution is pretty staight forward with no edge cases. What am I missing?\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> set;\\n        for(int & v : G)\\n            set.insert(v);\\n        int ans = 0;\\n        ListNode * ptr = head;\\n        while(ptr)\\n        {\\n            if(set.count(ptr -> val))\\n            {\\n                ++ans;\\n                while(ptr && set.count(ptr -> val))\\n                    ptr = ptr -> next;\\n            }\\n            else ptr = ptr -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> set;\\n        for(int & v : G)\\n            set.insert(v);\\n        int ans = 0;\\n        ListNode * ptr = head;\\n        while(ptr)\\n        {\\n            if(set.count(ptr -> val))\\n            {\\n                ++ans;\\n                while(ptr && set.count(ptr -> val))\\n                    ptr = ptr -> next;\\n            }\\n            else ptr = ptr -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342550,
                "title": "c-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tint numComponents(ListNode* head, vector<int>& G) {\\n\\t\\tbool arr[10000] = { false };\\n\\t\\tfor (int i = 0; i < G.size(); i++) arr[G[i]] = true;\\n\\t\\tListNode *p = head;\\n\\t\\tint count = 0;\\n\\t\\twhile (p!= NULL) {\\n\\t\\t\\tif (arr[p->val]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile (p!=NULL&&arr[p->val]) p = p->next;\\n\\t\\t\\t}\\n\\t\\t\\telse p = p->next;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tint numComponents(ListNode* head, vector<int>& G) {\\n\\t\\tbool arr[10000] = { false };\\n\\t\\tfor (int i = 0; i < G.size(); i++) arr[G[i]] = true;\\n\\t\\tListNode *p = head;\\n\\t\\tint count = 0;\\n\\t\\twhile (p!= NULL) {\\n\\t\\t\\tif (arr[p->val]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile (p!=NULL&&arr[p->val]) p = p->next;\\n\\t\\t\\t}\\n\\t\\t\\telse p = p->next;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340145,
                "title": "python3-solution-single-pass",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count=0\\n        i=head\\n        while i:\\n            if i.val in G:\\n                count+=1\\n                while i and i.val in G:\\n                    i=i.next\\n            else :i=i.next\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count=0\\n        i=head\\n        while i:\\n            if i.val in G:\\n                count+=1\\n                while i and i.val in G:\\n                    i=i.next\\n            else :i=i.next\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334107,
                "title": "c-9x-solution",
                "content": "It is hard to say this is a linked list problem.\\n```cpp\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        bool found = false;\\n        int n = 0;\\n        while (head != nullptr) {\\n            if (s.count(head->val)) {\\n                if (!found) {\\n                    found = true;  \\n                    n++;\\n                } \\n            } else {\\n                found = false;\\n            }\\n            head = head->next;\\n        }\\n        return n;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        bool found = false;\\n        int n = 0;\\n        while (head != nullptr) {\\n            if (s.count(head->val)) {\\n                if (!found) {\\n                    found = true;  \\n                    n++;\\n                } \\n            } else {\\n                found = false;\\n            }\\n            head = head->next;\\n        }\\n        return n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326995,
                "title": "python-union-find",
                "content": "My solution is convoluted compared to the concise solutions that others shared here, but wanted to share that it is possible to solve the problem using Disjoint Set (Union Find).\\n\\nThe idea is to perform `union` when both the current node and next node exist in `G`, and then count total number of unique items from the disjoint set.\\n\\n```py\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        self.parent[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        def length(head):\\n            cnt = 0\\n            if not head:\\n                return 0\\n            tmp = head\\n            while tmp:\\n                tmp = tmp.next\\n                cnt += 1\\n            return cnt\\n        \\n        n = length(head)\\n        uf = UnionFind(n)\\n        tmp = head\\n        subset = set(G)\\n        while tmp:\\n            if tmp.val in subset and tmp.next and tmp.next.val in subset:\\n                uf.union(tmp.val, tmp.next.val)\\n            tmp = tmp.next\\n        \\n        unique_count = len(set(uf.find(x) for x in G))\\n        return unique_count\\n```",
                "solutionTags": [],
                "code": "```py\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        self.parent[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        def length(head):\\n            cnt = 0\\n            if not head:\\n                return 0\\n            tmp = head\\n            while tmp:\\n                tmp = tmp.next\\n                cnt += 1\\n            return cnt\\n        \\n        n = length(head)\\n        uf = UnionFind(n)\\n        tmp = head\\n        subset = set(G)\\n        while tmp:\\n            if tmp.val in subset and tmp.next and tmp.next.val in subset:\\n                uf.union(tmp.val, tmp.next.val)\\n            tmp = tmp.next\\n        \\n        unique_count = len(set(uf.find(x) for x in G))\\n        return unique_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300450,
                "title": "python-with-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # How many different case will end up to be different component:\\n        # 1. the next of curr is not in G, then the prev one will be component \\n        # 2. Once again one node in G, it will start another component\\n        # 3. Exit, reach the end.\\n        setG = set(G)\\n        count = 0\\n\\n        while head:\\n            # process curr node:\\n            if head.val in setG:\\n                count += 1\\n                while head.next:\\n                    # if we find a component, we keep moving head until the first item not in setG\\n                    if head.val in setG:\\n                        head = head.next \\n                    else:\\n                        # e.g point stoped at 2\\n                        break\\n            \\n            head = head.next\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # How many different case will end up to be different component:\\n        # 1. the next of curr is not in G, then the prev one will be component \\n        # 2. Once again one node in G, it will start another component\\n        # 3. Exit, reach the end.\\n        setG = set(G)\\n        count = 0\\n\\n        while head:\\n            # process curr node:\\n            if head.val in setG:\\n                count += 1\\n                while head.next:\\n                    # if we find a component, we keep moving head until the first item not in setG\\n                    if head.val in setG:\\n                        head = head.next \\n                    else:\\n                        # e.g point stoped at 2\\n                        break\\n            \\n            head = head.next\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282708,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nBasically counting all the starting points of the chains. First while loop gets you to start of the chain, next while loop gets you to a node just past the end of the chain.\\n\\n```\\npublic int numComponents(ListNode head, int[] g) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : g)\\n            set.add(i);\\n        int count = 0;\\n        while(head != null){\\n            while(head != null && !set.contains(head.val)){\\n                head = head.next;\\n            }\\n            //new chain starting point\\n            if(head != null) ++count;\\n            while(head != null && set.contains(head.val)){\\n                set.remove(head.val);\\n                head = head.next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numComponents(ListNode head, int[] g) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : g)\\n            set.add(i);\\n        int count = 0;\\n        while(head != null){\\n            while(head != null && !set.contains(head.val)){\\n                head = head.next;\\n            }\\n            //new chain starting point\\n            if(head != null) ++count;\\n            while(head != null && set.contains(head.val)){\\n                set.remove(head.val);\\n                head = head.next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 228340,
                "title": "java-a-little-different-approach",
                "content": "After I submitted my solution, I looked at the official answer, and the Set approach is very clear and simple.  Well, I didn\\'t think of that on my own.  I used a method with some Maps.  This isn\\'t better, but it\\'s an alternate approach you might find interesting:\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        int components=0;\\n        Map<Integer,ListNode> unseenNodes = new HashMap<Integer,ListNode>();\\n        Map<Integer,ListNode> seenNodes = new HashMap<Integer,ListNode>();\\n        for( ListNode cur=head; cur!=null; cur=cur.next ) unseenNodes.put( cur.val, cur );\\n        \\n        for( int val : G ) {\\n            ListNode cur=unseenNodes.get(val);\\n            if( cur==null ) cur=seenNodes.get(val); else components++;\\n            unseenNodes.remove(val);\\n            \\n            if( cur.next!=null ) {\\n                if( unseenNodes.remove(cur.next.val)==null ) components--;\\n                seenNodes.put( cur.next.val, cur.next );\\n            }\\n        }\\n        \\n        return components;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numComponents(ListNode head, int[] G) {\\n        int components=0;\\n        Map<Integer,ListNode> unseenNodes = new HashMap<Integer,ListNode>();\\n        Map<Integer,ListNode> seenNodes = new HashMap<Integer,ListNode>();\\n        for( ListNode cur=head; cur!=null; cur=cur.next ) unseenNodes.put( cur.val, cur );\\n        \\n        for( int val : G ) {\\n            ListNode cur=unseenNodes.get(val);\\n            if( cur==null ) cur=seenNodes.get(val); else components++;\\n            unseenNodes.remove(val);\\n            \\n            if( cur.next!=null ) {\\n                if( unseenNodes.remove(cur.next.val)==null ) components--;\\n                seenNodes.put( cur.next.val, cur.next );\\n            }\\n        }\\n        \\n        return components;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213046,
                "title": "simple-solution-for-beginners-in-c",
                "content": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        set<int> s;\\n        for (auto t: G) s.insert(t);\\n        int ans = 0;\\n    \\tint ok = 0;\\n        int j=0;\\n        auto p=s.find(7);\\n        cout<<*p;\\n        while (head != NULL){\\n        \\tif (s.find(head->val) != s.end()){\\n        \\t\\tif (!ok){\\n        \\t\\t\\tok = 1;\\n        \\t\\t\\tans ++;\\n        \\t\\t}\\n                \\n        \\t}\\n        \\t else {ok = 0;\\n                   \\n                   j++;\\n                   //cout<<head->val;\\n                  }\\n        \\thead = head->next;\\n        }\\t\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        set<int> s;\\n        for (auto t: G) s.insert(t);\\n        int ans = 0;\\n    \\tint ok = 0;\\n        int j=0;\\n        auto p=s.find(7);\\n        cout<<*p;\\n        while (head != NULL){\\n        \\tif (s.find(head->val) != s.end()){\\n        \\t\\tif (!ok){\\n        \\t\\t\\tok = 1;\\n        \\t\\t\\tans ++;\\n        \\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 190637,
                "title": "javascript",
                "content": "```\nvar numComponents = function(head, G) {\n    let result = 0;\n    let mark = false;\n    let i = 0;\n    while(head != null && i != G.length) {\n        if(G.indexOf(head.val) == -1) {\n            head = head.next;\n            mark = false;\n            continue;\n        }\n        if(mark) {\n            head = head.next;\n        } else {\n            mark = true;\n            result++;\n            head = head.next;\n        }\n        i++;\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar numComponents = function(head, G) {\n    let result = 0;\n    let mark = false;\n    let i = 0;\n    while(head != null && i != G.length) {\n        if(G.indexOf(head.val) == -1) {\n            head = head.next;\n            mark = false;\n            continue;\n        }\n        if(mark) {\n            head = head.next;\n        } else {\n            mark = true;\n            result++;\n            head = head.next;\n        }\n        i++;\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182578,
                "title": "c-solution",
                "content": "```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& G) {\n        set<int> myset;\n        set<int>::iterator it;\n        for (int i = 0; i < G.size(); i++) {\n            myset.insert(G[i]);\n        }\n        int count = 0;\n        bool flag = false;\n        ListNode* tmp = head;\n        while(tmp != nullptr) {\n            int val = tmp->val;\n            it = myset.find(val);\n            if (it != myset.end()) {\n                flag = true;\n            } else {\n                if (flag == true) {\n                    count++;\n                }\n                flag = false;\n            }\n            tmp = tmp->next;\n        }\n        if (flag == true) {\n            count++;\n        }\n        return count;\n        \n    }\n};\n```",
                "solutionTags": [],
                "code": "```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& G) {\n        set<int> myset;\n        set<int>::iterator it;\n        for (int i = 0; i < G.size(); i++) {\n            myset.insert(G[i]);\n        }\n        int count = 0;\n        bool flag = false;\n        ListNode* tmp = head;\n        while(tmp != nullptr) {\n            int val = tmp->val;\n            it = myset.find(val);\n            if (it != myset.end()) {\n                flag = true;\n            } else {\n                if (flag == true) {\n                    count++;\n                }\n                flag = false;\n            }\n            tmp = tmp->next;\n        }\n        if (flag == true) {\n            count++;\n        }\n        return count;\n        \n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 178709,
                "title": "c-easy-to-understand-solution-with-reading-notes",
                "content": "```\\n    //\\n    // PROBLEM DESCRIPTION: https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\n    //  also note that the linked list nodes may not be in sorted order, although every test case depicts them to be as such.\\n    //\\n    \\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> gSet(G.begin(), G.end());\\n        \\n        int count = 0;\\n        ListNode* n = head;\\n        while (n != NULL)\\n        {\\n            if (gSet.find(n->val) != gSet.end())\\n            {\\n                count++;\\n                \\n                do \\n                {\\n                    n = n->next;\\n                } while(n != NULL && gSet.find(n->val) != gSet.end());\\n            }\\n            \\n            if (n != NULL)\\n                n = n->next;\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    //\\n    // PROBLEM DESCRIPTION: https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\n    //  also note that the linked list nodes may not be in sorted order, although every test case depicts them to be as such.\\n    //\\n    \\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> gSet(G.begin(), G.end());\\n        \\n        int count = 0;\\n        ListNode* n = head;\\n        while (n != NULL)\\n        {\\n            if (gSet.find(n->val) != gSet.end())\\n            {\\n                count++;\\n                \\n                do \\n                {\\n                    n = n->next;\\n                } while(n != NULL && gSet.find(n->val) != gSet.end());\\n            }\\n            \\n            if (n != NULL)\\n                n = n->next;\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142854,
                "title": "java-easy-solution-time-o-n-space-o-size-of-g",
                "content": "Steps:\\n1. Add all the integer array elements to a HashSet (for easy O(1) access).\\n2. Traverse the Linked List. Check if an element exists in the hashset.\\n3. If it does exist: If not counted previuosly, Assign prev_counted to true now and increse your counter (res). \\n4. If it doesn\\'t exist, change it back to false (Starting fresh).\\n5. Keep traversing until the end of the Linked List.\\n6. Return the result (res).\\n\\n\\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head==null) return 0;\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        int res=0;\\n        boolean prev_counted=false;\\n        for(int num:G) hs.add(num);\\n        \\n        ListNode curr=head;\\n        while(curr!=null)\\n        {\\n            int val=curr.val;\\n            if(hs.contains(val))\\n            {\\n                if(!prev_counted) \\n                {\\n                   res++;\\n                   prev_counted=true;\\n                }\\n            }\\n            else\\n            {\\n                prev_counted=false;\\n            }\\n            curr=curr.next;\\n        }\\n        return res;  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head==null) return 0;\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        int res=0;\\n        boolean prev_counted=false;\\n        for(int num:G) hs.add(num);\\n        \\n        ListNode curr=head;\\n        while(curr!=null)\\n        {\\n            int val=curr.val;\\n            if(hs.contains(val))\\n            {\\n                if(!prev_counted) \\n                {\\n                   res++;\\n                   prev_counted=true;\\n                }\\n            }\\n            else\\n            {\\n                prev_counted=false;\\n            }\\n            curr=curr.next;\\n        }\\n        return res;  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126768,
                "title": "c-o-n-g-solution",
                "content": "```\\nint numComponents(ListNode* head, vector<int>& G) \\n    {\\n        auto gSet = unordered_set<int>{begin(G),end(G)};\\n        \\n        int maxSize = 0;\\n        bool groupStart = false;\\n        \\n        while(head!=nullptr)\\n        {\\n            if(gSet.find(head->val) != gSet.end())\\n            {\\n                if(!groupStart)\\n                {\\n                    maxSize++;\\n                    groupStart = true;\\n                }                    \\n            }\\n            else groupStart = false;\\n            head = head->next;   \\n        }\\n        return maxSize;\\n    }",
                "solutionTags": [],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& G) \\n    {\\n        auto gSet = unordered_set<int>{begin(G),end(G)};\\n        \\n        int maxSize = 0;\\n        bool groupStart = false;\\n        \\n        while(head!=nullptr)\\n        {\\n            if(gSet.find(head->val) != gSet.end())\\n            {\\n                if(!groupStart)\\n                {\\n                    maxSize++;\\n                    groupStart = true;\\n                }                    \\n            }\\n            else groupStart = false;\\n            head = head->next;   \\n        }\\n        return maxSize;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 123933,
                "title": "c-13ms-linear-time-without-hash-map",
                "content": "Most solutions posted here use a hash map, which means that the linear running time is only expected. Here is a linear-time solution that does not use a hash map. It is important to exploit the fact that the list is a permutation of `[0, N - 1]`. Therefore, we can build a mask to efficiently look up whether an element belongs to `G`.\\n\\n```\\nclass Solution\\n{\\n  private:\\n    vector<bool> build_mask(size_t n, const vector<int> & G)\\n    {\\n        vector<bool> mask(n, false);\\n        \\n        for (int i : G)\\n            mask[i] = true;\\n        \\n        return mask;\\n    }\\n    \\n    size_t length(ListNode * node)\\n    {\\n        if (! node)\\n            return 0;\\n        \\n        return 1 + length(node->next);\\n    }\\n    \\n  public:\\n    int numComponents(ListNode * head, vector<int> & G)\\n    {\\n        size_t n = length(head);\\n        \\n        vector<bool> mask = build_mask(n + 1, G);\\n        \\n        static ListNode * _head = new ListNode(n);\\n        _head->val = n;\\n        _head->next = head;\\n        \\n        int c = 0;\\n        \\n        for (ListNode * node = _head; node->next; node = node->next)\\n        {\\n            if (! mask[node->val] && mask[node->next->val])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n  private:\\n    vector<bool> build_mask(size_t n, const vector<int> & G)\\n    {\\n        vector<bool> mask(n, false);\\n        \\n        for (int i : G)\\n            mask[i] = true;\\n        \\n        return mask;\\n    }\\n    \\n    size_t length(ListNode * node)\\n    {\\n        if (! node)\\n            return 0;\\n        \\n        return 1 + length(node->next);\\n    }\\n    \\n  public:\\n    int numComponents(ListNode * head, vector<int> & G)\\n    {\\n        size_t n = length(head);\\n        \\n        vector<bool> mask = build_mask(n + 1, G);\\n        \\n        static ListNode * _head = new ListNode(n);\\n        _head->val = n;\\n        _head->next = head;\\n        \\n        int c = 0;\\n        \\n        for (ListNode * node = _head; node->next; node = node->next)\\n        {\\n            if (! mask[node->val] && mask[node->next->val])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123824,
                "title": "c-very-simple-solution",
                "content": "````\\n// General idea:\\n// - iterate through the linked-list and keep track of when you are in/out of component\\n// - every time you EXIT a component, increment your count (ans)\\n// - make sure to check if you finished the list in a component\\n\\nbool in = false;\\nint ans = 0;\\n\\nint numComponents(ListNode* head, vector<int>& G) \\n{\\n    unordered_set<int> v (G.begin (), G.end ());\\n\\n    while (head) \\n    {\\n        if (v.count (head->val)) in = true;\\n        else if (in) ans++, in = false;\\n\\n        head = head->next;\\n    }\\n\\n    if (in) ans++;\\n\\n    return ans;\\n}",
                "solutionTags": [],
                "code": "````\\n// General idea:\\n// - iterate through the linked-list and keep track of when you are in/out of component\\n// - every time you EXIT a component, increment your count (ans)\\n// - make sure to check if you finished the list in a component\\n\\nbool in = false;\\nint ans = 0;\\n\\nint numComponents(ListNode* head, vector<int>& G) \\n{\\n    unordered_set<int> v (G.begin (), G.end ());\\n\\n    while (head) \\n    {\\n        if (v.count (head->val)) in = true;\\n        else if (in) ans++, in = false;\\n\\n        head = head->next;\\n    }\\n\\n    if (in) ans++;\\n\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4100244,
                "title": "cpp-sol",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n) where n is no. of nodes\\n\\n- Space complexity:\\nO(m) for unordered set\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        ListNode* current = head;\\n        int numCount = 0;\\n        bool inComponent = false;\\n\\n        while (current != nullptr) {\\n            if (numSet.count(current->val)) {\\n                if (!inComponent) {\\n                    numCount++;\\n                    inComponent = true;\\n                }\\n            } else {\\n                inComponent = false;\\n            }\\n            current = current->next;\\n        }\\n\\n        return numCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        ListNode* current = head;\\n        int numCount = 0;\\n        bool inComponent = false;\\n\\n        while (current != nullptr) {\\n            if (numSet.count(current->val)) {\\n                if (!inComponent) {\\n                    numCount++;\\n                    inComponent = true;\\n                }\\n            } else {\\n                inComponent = false;\\n            }\\n            current = current->next;\\n        }\\n\\n        return numCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089467,
                "title": "java-hashset",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i : nums){\\n            hs.add(i);\\n        }\\n        int ans = 0;\\n        boolean prev = false;\\n        while(head != null){\\n            int a = head.val;\\n            if(hs.contains(a)){\\n                if(!prev){\\n                    ans++;\\n                    prev = true;\\n                }\\n            }else{\\n                prev = false;\\n            }\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i : nums){\\n            hs.add(i);\\n        }\\n        int ans = 0;\\n        boolean prev = false;\\n        while(head != null){\\n            int a = head.val;\\n            if(hs.contains(a)){\\n                if(!prev){\\n                    ans++;\\n                    prev = true;\\n                }\\n            }else{\\n                prev = false;\\n            }\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081394,
                "title": "my-approach-easy-solution-in-python",
                "content": "class Solution(object):\\n    def numComponents(self, head, nums):\\n        count = 0\\n        d = {}\\n        val = head.val  # Assuming head is the head node of your linked list\\n        curr = head  # Assuming curr starts at the head node\\n        while curr:\\n            if curr.val in nums:\\n                count = 1\\n                d[val] = count\\n            else:\\n                d[curr.val] = None\\n                count = 0\\n                if curr.next:\\n                    val = curr.next.val  # Assuming curr.next is the next node in the linked list\\n            curr = curr.next  # Move to the next node in the linked list\\n        print(d)\\n        sum_of_values = sum(value for value in d.values() if value is not None)\\n        return sum_of_values",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numComponents(self, head, nums):\\n        count = 0\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 4077970,
                "title": "easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a dictionary wheather the value is in nums.For this u have to convert this nums array into dictionary..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.At first check the length of head and nums  are same .If same then the answer is 1!!!(Because all values are eventually connected with each other).\\n2.If the first condition is False then check the consecutive values  in head are present in new_nums(dictionary) using while loop .While consecutive values are present in dictionary then head pointer is increased by head.next .Else increse count value by one.\\n3.Increment head pointer \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n).Head counter will go to the last node !!!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        new_nums={}\\n        for value in nums:\\n            if value not in new_nums:\\n                new_nums[value]=1\\n        count=0\\n        total=0\\n        new_head=head\\n        while new_head:\\n            total+=1\\n            new_head=new_head.next\\n        while head:\\n            if head.val in new_nums:\\n                if total==len(nums):\\n                    return 1\\n                while head.next is not None and head.next.val in new_nums:\\n                    head=head.next\\n                count+=1                \\n            head=head.next\\n        return count \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        new_nums={}\\n        for value in nums:\\n            if value not in new_nums:\\n                new_nums[value]=1\\n        count=0\\n        total=0\\n        new_head=head\\n        while new_head:\\n            total+=1\\n            new_head=new_head.next\\n        while head:\\n            if head.val in new_nums:\\n                if total==len(nums):\\n                    return 1\\n                while head.next is not None and head.next.val in new_nums:\\n                    head=head.next\\n                count+=1                \\n            head=head.next\\n        return count \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061269,
                "title": "easy-python-solution-in-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\n        temp = head\\n        count = 0\\n\\n        connected = False  \\n\\n        while(temp):\\n            if(temp.val in nums):\\n                if(connected == False):\\n                    connected = True\\n                    count += 1\\n            else:\\n                connected = False\\n\\n            temp = temp.next\\n\\n        return count\\n```\\n\\n# Explanation\\n\\n1) Traverse the linked list while keeping track of whether you are within a connected component (in this case, a connected component means a sequence of nodes with values in nums that appear consecutively).\\n\\n2) When you encounter a node with a value in nums, start or continue a connected component.\\n\\n3) When you encounter a node with a value not in nums, end the current connected component.\\n\\n4) Count the number of connected components as you traverse the linked list.\\n\\n\\n\\n##### If you find my solution helpful and worthy, please consider upvoting my solution. Upvotes play a crucial role in ensuring that this valuable content reaches others and helps them as well.\\n\\n##### Only your support motivates me to continue contributing more solutions and assisting the community further.\\n\\n##### Thank You for spending your valuable time.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\n        temp = head\\n        count = 0\\n\\n        connected = False  \\n\\n        while(temp):\\n            if(temp.val in nums):\\n                if(connected == False):\\n                    connected = True\\n                    count += 1\\n            else:\\n                connected = False\\n\\n            temp = temp.next\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060779,
                "title": "c-simple-observation-and-hashing",
                "content": "# Intuition\\nit is stated the we can connect consecutive number from the arrays and make one component so we will check if all the consective number can be a part of our result or not  For ex 0,1,2,3 :: 0 and 1 are part of subset nums also so will keep goind and include them in one subset and stop wehenever the condition is not true \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int>st(nums.begin(),nums.end());\\n         vector<int>v;\\n         while(head!=NULL)\\n          v.push_back(head->val),head=head->next;\\n          int comp=0;\\n          int sz=v.size();\\n          for(int i=0;i<sz;i++)\\n           {\\n             int j=i;\\n              while(j<sz and st.find(v[j])!=st.end())\\n                {\\n                    //one component \\n                    \\n                      j++;\\n                }\\n               \\n                if(i!=j)\\n                 comp++,i=j;\\n                  \\n           }\\n           return comp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int>st(nums.begin(),nums.end());\\n         vector<int>v;\\n         while(head!=NULL)\\n          v.push_back(head->val),head=head->next;\\n          int comp=0;\\n          int sz=v.size();\\n          for(int i=0;i<sz;i++)\\n           {\\n             int j=i;\\n              while(j<sz and st.find(v[j])!=st.end())\\n                {\\n                    //one component \\n                    \\n                      j++;\\n                }\\n               \\n                if(i!=j)\\n                 comp++,i=j;\\n                  \\n           }\\n           return comp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056832,
                "title": "go-easy",
                "content": "```\\nfunc numComponents(head *ListNode, nums []int) int {\\n    targets := make(map[int]bool)\\n\\n    for _, num := range nums {\\n        targets[num] = true\\n    }\\n\\n    components := 0\\n    var prev *ListNode\\n\\n    for cur := head; cur != nil; cur = cur.Next {\\n        if prev != nil {\\n            if !targets[prev.Val] && targets[cur.Val] {\\n                components++\\n            }\\n        } else {\\n            if targets[cur.Val] {\\n                components++\\n            }\\n        }\\n        prev = cur\\n    }\\n\\n    return components\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numComponents(head *ListNode, nums []int) int {\\n    targets := make(map[int]bool)\\n\\n    for _, num := range nums {\\n        targets[num] = true\\n    }\\n\\n    components := 0\\n    var prev *ListNode\\n\\n    for cur := head; cur != nil; cur = cur.Next {\\n        if prev != nil {\\n            if !targets[prev.Val] && targets[cur.Val] {\\n                components++\\n            }\\n        } else {\\n            if targets[cur.Val] {\\n                components++\\n            }\\n        }\\n        prev = cur\\n    }\\n\\n    return components\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055545,
                "title": "self-explanatory-comments-using-set-hash-table-best-ever-c-solution",
                "content": "~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63 \\uD83D\\uDE0A\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHer There! Its Easy Just Take A Look At The Code And Comments Within It, You\\'ll Get It.\\nStill Have Doubts! Feel Free To Comment, I\\'ll Definitely Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Unordered-Set (Accepted)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Program to find the number of connected components in \"nums\" where two values are connected if they appear consecutively in the linked list ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_set>\\n\\n// List template\\nstruct Node {\\n    int val;\\n    Node* next;\\n\\n    // Init constructor\\n    Node(int val, Node* next = nullptr)\\n    :\\n    val(val), next(next) {}\\n\\n    // Init destructor\\n    ~Node() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Method to find the number of connected components - O(N) & O(N) : Where N is the total number of nodes of the list\\nint numComponents(Node* head, std::vector<int> nums) {\\n    std::unordered_set<int> set(begin(nums), end(nums));\\n\\n    // Require to store the number of connected components (resultant value)\\n    int count = 0;\\n\\n    while(head) {\\n        // Increment the count if its the beginning of a new component\\n        if(set.count(head->val)) {\\n            count++;\\n            // Skip the consecutive nodes of the current component\\n            while(head && set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n        // Else, skip the non-component nodes until a potential component node is found\\n        else {\\n            while(head && !set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n// Note: There are also multiple solutions of this problem, do check it out.\\n\\n// Method to print the list using recursion\\nvoid printList(Node* head) {\\n    if(head) {\\n        std::cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating, connecting nodes and initializing their data\\n    Node* head = new Node(0, new Node(1, new Node(2, new Node(3))));\\n\\n    // Print call\\n    printList(head);\\n\\n    // Call to find the number of connected components\\n    int count = numComponents(head, {0,1,3});\\n    std::cout<<\"\\\\nThe number of connected components is : \"<<count;\\n\\n    // Deletion call\\n    delete head;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-components/description/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n// Program to find the number of connected components in \"nums\" where two values are connected if they appear consecutively in the linked list ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_set>\\n\\n// List template\\nstruct Node {\\n    int val;\\n    Node* next;\\n\\n    // Init constructor\\n    Node(int val, Node* next = nullptr)\\n    :\\n    val(val), next(next) {}\\n\\n    // Init destructor\\n    ~Node() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Method to find the number of connected components - O(N) & O(N) : Where N is the total number of nodes of the list\\nint numComponents(Node* head, std::vector<int> nums) {\\n    std::unordered_set<int> set(begin(nums), end(nums));\\n\\n    // Require to store the number of connected components (resultant value)\\n    int count = 0;\\n\\n    while(head) {\\n        // Increment the count if its the beginning of a new component\\n        if(set.count(head->val)) {\\n            count++;\\n            // Skip the consecutive nodes of the current component\\n            while(head && set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n        // Else, skip the non-component nodes until a potential component node is found\\n        else {\\n            while(head && !set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n// Note: There are also multiple solutions of this problem, do check it out.\\n\\n// Method to print the list using recursion\\nvoid printList(Node* head) {\\n    if(head) {\\n        std::cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating, connecting nodes and initializing their data\\n    Node* head = new Node(0, new Node(1, new Node(2, new Node(3))));\\n\\n    // Print call\\n    printList(head);\\n\\n    // Call to find the number of connected components\\n    int count = numComponents(head, {0,1,3});\\n    std::cout<<\"\\\\nThe number of connected components is : \"<<count;\\n\\n    // Deletion call\\n    delete head;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-components/description/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4051027,
                "title": "python-my-approach",
                "content": "# Intuition\\n  use a current pointer to traverse the linked list\\n  fill the stack if you find a element common in linked list and array\\n  when you dont find a common element clear the stack and update count by +1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        curr = head \\n        stack=[]\\n        count=0\\n        while curr:\\n            if curr.val in nums :\\n                stack.append(curr.val)\\n                curr=curr.next\\n                continue\\n            if curr.val not in nums :\\n                if stack :\\n                    stack=[]\\n                    count+=1\\n                curr=curr.next\\n                continue\\n        if stack :\\n            return count+1\\n        else :\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        curr = head \\n        stack=[]\\n        count=0\\n        while curr:\\n            if curr.val in nums :\\n                stack.append(curr.val)\\n                curr=curr.next\\n                continue\\n            if curr.val not in nums :\\n                if stack :\\n                    stack=[]\\n                    count+=1\\n                curr=curr.next\\n                continue\\n        if stack :\\n            return count+1\\n        else :\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045418,
                "title": "beats-96-efficient-solution-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* temp=head;\\n        unordered_set<int> uSet;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) uSet.insert(nums[i]);\\n        bool flag=false;\\n        int count=0;\\n        while(temp){\\n            if(!flag && uSet.find(temp->val)!=uSet.end()){\\n                flag=true;\\n                count++;\\n            }\\n            else if(flag && uSet.find(temp->val)==uSet.end())\\n                flag=false;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* temp=head;\\n        unordered_set<int> uSet;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) uSet.insert(nums[i]);\\n        bool flag=false;\\n        int count=0;\\n        while(temp){\\n            if(!flag && uSet.find(temp->val)!=uSet.end()){\\n                flag=true;\\n                count++;\\n            }\\n            else if(flag && uSet.find(temp->val)==uSet.end())\\n                flag=false;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1565358,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1566275,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1898825,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1570334,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1575123,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1567375,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1994891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1749328,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1571914,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1564891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1565358,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1566275,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1898825,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1570334,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1575123,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1567375,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1994891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1749328,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1571914,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1572098,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1821404,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1643292,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1627810,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1575080,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2052109,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2043669,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2014648,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2005726,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1967090,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Zero Sum Consecutive Nodes from Linked List",
        "question_content": "<p>Given the <code>head</code> of a linked list, we repeatedly delete consecutive sequences of nodes that sum to <code>0</code> until there are no such sequences.</p>\r\n\r\n<p>After doing so, return the head of the final linked list.&nbsp; You may return any such answer.</p>\r\n\n<p>&nbsp;</p>\n<p>(Note that in the examples below, all sequences are serializations of <code>ListNode</code> objects.)</p>\n\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2,-3,3,1]\n<strong>Output:</strong> [3,1]\n<strong>Note:</strong> The answer [1,2,1] would also be accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2,3,-3,4]\n<strong>Output:</strong> [1,2,4]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2,3,-3,-2]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The given linked list will contain between <code>1</code> and <code>1000</code> nodes.</li>\n\t<li>Each node in the linked list has <code>-1000 &lt;= node.val &lt;= 1000</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 366319,
                "title": "java-c-python-greedily-skip-with-hashmap",
                "content": "# **Intuition**\\nAssume the input is an array.\\nDo you know how to solve it?\\nScan from the left, and calculate the prefix sum.\\nWhenever meet the seen prefix,\\nremove all elements of the subarray between them.\\n<br>\\n\\n# **Solution 1**\\nBecause the head ListNode can be removed in the end,\\nI create a `dummy` ListNode and set it as a previous node of `head`.\\n`prefix` calculates the prefix sum from the first node to the current `cur` node.\\n\\nNext step, we need an important hashmap `m` (no good name for it),\\nIt takes a prefix sum as key, and the related node as the value.\\n\\nThen we scan the linked list, accumulate the node\\'s value as `prefix` sum.\\n1. If it\\'s a prefix that we\\'ve never seen, we set `m[prefix] = cur`.\\n2. If we have seen this prefix, `m[prefix]` is the node we achieve this prefix sum.\\nWe want to skip all nodes between `m[prefix]` and `cur.next` (exclusive).\\nSo we simplely do `m[prefix].next = cur.next`.\\n\\nWe keep doing these and it\\'s done.\\n<br>\\n\\n**Complexity**\\nTime `O(N)`, one pass\\nSpace`O(N)`, for hashmap\\n<br>\\n\\n**Java:**\\n```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        int prefix = 0;\\n        Map<Integer, ListNode> m = new HashMap<>();\\n        while (cur != null) {\\n            prefix += cur.val;\\n            if (m.containsKey(prefix)) {\\n                cur =  m.get(prefix).next;\\n                int p = prefix + cur.val;\\n                while (p != prefix) {\\n                    m.remove(p);\\n                    cur = cur.next;\\n                    p += cur.val;\\n                }\\n                m.get(prefix).next = cur.next;\\n            } else {\\n                m.put(prefix, cur);\\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while (cur) {\\n            prefix += cur->val;\\n            if (m.count(prefix)) {\\n                cur =  m[prefix]->next;\\n                int p = prefix + cur->val;\\n                while (p != prefix) {\\n                    m.erase(p);\\n                    cur = cur->next;\\n                    p += cur->val;\\n                }\\n                m[prefix]->next = cur->next;\\n            } else {\\n                m[prefix] = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return dummy->next;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def removeZeroSumSublists(self, head):\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```\\n<br>\\n\\n# Improvement\\nI think that\\'s the best part of my post.\\nIt\\'s a great discuss in the leetcode\\'s discuss.\\n\\nPeople are willing to read my article and help me improve it.\\nTo be honest, I think I take good responsiblilty to maintain my solution.\\n(Though the case I don\\'t have prime membership and canot even read my own post in locked problem)\\n\\nThanks to @alexjst inspired me the follwing solution.\\n<br>\\n\\n# Soluiton 2: Two Passes\\n\\nThe story is that,\\nI wrote the really concise solution,\\nit got accepted but actully it\\'s wrong.\\nI fixed it by adding another while loop.\\nThat is the Solution 1.\\n\\nIf we don\\'t insist on one pass,\\nwe can find the two passes is actually really neat.\\n\\nThat turned back to the intuition that I mentioned:\\nAssume the input is an array.\\nHow will you solve the problem?\\n\\nIterate for the first time,\\ncalculate the `prefix` sum,\\nand save the it to `seen[prefix]`\\n\\nIterate for the second time,\\ncalculate the `prefix` sum,\\nand directly skip to last occurrence of this `prefix`\\n\\n**Java**\\n```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int prefix = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            seen.put(prefix, i);\\n        }\\n        prefix = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            i.next = seen.get(prefix).next;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\n**C++**\\n```\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        int prefix = 0;\\n        unordered_map<int, ListNode*> seen;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            seen[prefix += i->val] = i;\\n        }\\n        prefix = 0;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            i->next = seen[prefix += i->val]->next;\\n        }\\n        return dummy->next;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def removeZeroSumSublists(self, head):\\n        prefix = 0\\n        seen = {}\\n        seen[0] = dummy = ListNode(0)\\n        dummy.next = head\\n        while head:\\n            prefix += head.val\\n            seen[prefix] = head\\n            head = head.next\\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = seen[prefix].next\\n            head = head.next\\n        return dummy.next\\n```\\n<br>\\n\\n# **Update 2019-08-25**\\nThe OJ solution was wrong.\\nIt didn\\'t block the right submit,\\nbut wrong submit can also get accepted.\\n\\nFollowing the test case given by @kay_deep:\\n`[1, 3, 2, -3, -2, 5, 100, -100, 1]`\\nThe expected result should be `[1,5,1]` or `[1,3,2,1]`.\\n\\nSome solution in the discuss part are still wrong.",
                "solutionTags": [],
                "code": "```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        int prefix = 0;\\n        Map<Integer, ListNode> m = new HashMap<>();\\n        while (cur != null) {\\n            prefix += cur.val;\\n            if (m.containsKey(prefix)) {\\n                cur =  m.get(prefix).next;\\n                int p = prefix + cur.val;\\n                while (p != prefix) {\\n                    m.remove(p);\\n                    cur = cur.next;\\n                    p += cur.val;\\n                }\\n                m.get(prefix).next = cur.next;\\n            } else {\\n                m.put(prefix, cur);\\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```cpp\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while (cur) {\\n            prefix += cur->val;\\n            if (m.count(prefix)) {\\n                cur =  m[prefix]->next;\\n                int p = prefix + cur->val;\\n                while (p != prefix) {\\n                    m.erase(p);\\n                    cur = cur->next;\\n                    p += cur->val;\\n                }\\n                m[prefix]->next = cur->next;\\n            } else {\\n                m[prefix] = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return dummy->next;\\n    }\\n```\n```python\\n    def removeZeroSumSublists(self, head):\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```\n```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int prefix = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            seen.put(prefix, i);\\n        }\\n        prefix = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            i.next = seen.get(prefix).next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        int prefix = 0;\\n        unordered_map<int, ListNode*> seen;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            seen[prefix += i->val] = i;\\n        }\\n        prefix = 0;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            i->next = seen[prefix += i->val]->next;\\n        }\\n        return dummy->next;\\n    }\\n```\n```py\\n    def removeZeroSumSublists(self, head):\\n        prefix = 0\\n        seen = {}\\n        seen[0] = dummy = ListNode(0)\\n        dummy.next = head\\n        while head:\\n            prefix += head.val\\n            seen[prefix] = head\\n            head = head.next\\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = seen[prefix].next\\n            head = head.next\\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 366350,
                "title": "c-o-n-explained-with-pictures",
                "content": "**Intuition and Algorithm**\\nImagine that you have this Linked list:\\nhead:      [3,4,2,-6, 1,1,5, -6] \\n\\n**What elements should I remove?**\\nWe will accumulate the values.\\nhead\\u2019 :   [3, 7,9,3,4,5,10,4]\\n(Like an array), head\\'[i] = head[i] + head\\' [i-1]\\nIf we see repeated elements then we have to deleted as follows.\\n\\n![image](https://assets.leetcode.com/users/hamlet_fiis/image_1566705933.png)\\n\\nAfter delete:\\n\\n![image](https://assets.leetcode.com/users/hamlet_fiis/image_1566705946.png)\\n\\n**Answer:**\\nhead: [3,1]\\n\\n**Algorithm**\\n* Iterate LinkedList from left to right\\n* Process each accumulative value in this datastructure. (unordered_map<int,ListNode*>um) um[ac] = currentNode;\\n* Given a current accumulative value check if exists in our map (get previous element).\\n* If they exist  um[ac]->next = currentNode->next, then delete intermediate nodes in our map between  um[ac] and currentNode\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            //found value\\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n                \\n                //delete bad references\\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```\\n\\n<b>Complexity Analysis </b>\\n* Time Complexity: O(n) where n is the length of head\\n* Space Complexity: O(n) where n is the length of head",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            //found value\\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n                \\n                //delete bad references\\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413134,
                "title": "java-o-n-with-detail-explanation",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // The observation here is that the sum from index 0 to index M will be \\n        // equal to sum from index 0 to index N if sum from index (M+1) to index N is 0.\\n        // Thus, here we track the sum from index 0 to each index, using a Map to indicate\\n        // the farthest index N that we can remove from index M, then we shall be able to\\n        // remove M+1 -> N and continue from N+1. This works since we don\\'t have to optimize\\n        // for the number of sequences to be removed\\n        \\n        // Map from sum from index 0 to the farthest value that the sum stays unchanged.\\n        Map<Integer, ListNode> sumToFarthestNodeMap = new HashMap<>();\\n        \\n        // Need the dummy node to track the new head if changed.\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        \\n        // First iteration to compute the map.\\n        int sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            sumToFarthestNodeMap.put(sum, p);\\n        }\\n        \\n        // Second iteration to re-connect the nodes to the farthest node where the sum stays unchanged\\n        sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = sumToFarthestNodeMap.get(sum).next;\\n        }\\n        \\n        // Done, return the head from preHead\\n        return preHead.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // The observation here is that the sum from index 0 to index M will be \\n        // equal to sum from index 0 to index N if sum from index (M+1) to index N is 0.\\n        // Thus, here we track the sum from index 0 to each index, using a Map to indicate\\n        // the farthest index N that we can remove from index M, then we shall be able to\\n        // remove M+1 -> N and continue from N+1. This works since we don\\'t have to optimize\\n        // for the number of sequences to be removed\\n        \\n        // Map from sum from index 0 to the farthest value that the sum stays unchanged.\\n        Map<Integer, ListNode> sumToFarthestNodeMap = new HashMap<>();\\n        \\n        // Need the dummy node to track the new head if changed.\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        \\n        // First iteration to compute the map.\\n        int sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            sumToFarthestNodeMap.put(sum, p);\\n        }\\n        \\n        // Second iteration to re-connect the nodes to the farthest node where the sum stays unchanged\\n        sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = sumToFarthestNodeMap.get(sum).next;\\n        }\\n        \\n        // Done, return the head from preHead\\n        return preHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414285,
                "title": "python-easy-to-understand-solution-with-explanations",
                "content": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # can be solved by finding prefix sum;\\n        # if l1+l2 = l1+l2+...+l5, meaning that l3 + ... + l5 = 0, \\n\\t\\t# then l3 + ... + l5 is the consecutive sequence of nodes we want to delete. \\n\\t\\t# If it\\'s a array we could just remove numbers from index of l3 to l5. \\n\\t\\t# If it\\'s a linked list, we could let l2.next = l5.next, we then need to have two pointers,\\n\\t\\t# one point to l2 and the other point to l5;\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        d = {0:dummy} # key is the prefix sum, value is the last node of getting this sum value, which is l5\\n        while head:\\n            prefix += head.val\\n            d[prefix] = head\\n            head = head.next\\n\\t\\t# Go from the dummy node again to set the next node to be the last node for a prefix sum \\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = d[prefix].next\\n            head = head.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # can be solved by finding prefix sum;\\n        # if l1+l2 = l1+l2+...+l5, meaning that l3 + ... + l5 = 0, \\n\\t\\t# then l3 + ... + l5 is the consecutive sequence of nodes we want to delete. \\n\\t\\t# If it\\'s a array we could just remove numbers from index of l3 to l5. \\n\\t\\t# If it\\'s a linked list, we could let l2.next = l5.next, we then need to have two pointers,\\n\\t\\t# one point to l2 and the other point to l5;\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        d = {0:dummy} # key is the prefix sum, value is the last node of getting this sum value, which is l5\\n        while head:\\n            prefix += head.val\\n            d[prefix] = head\\n            head = head.next\\n\\t\\t# Go from the dummy node again to set the next node to be the last node for a prefix sum \\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = d[prefix].next\\n            head = head.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 507108,
                "title": "java-simple-o-n-solution-with-explanation",
                "content": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        /*\\n        Approach: The idea is, if we calculate sum of values from start and if A and B nodes are having few zero sum nodes\\n                  between them, they will have the same sum. Eg: In [2,4,2,-6,7], node 2 and node -6 both are having sum as\\n                  2, so we can connect node 2 to node 7, essentially removing zero-sum nodes [4,2,-6] from the list.\\n                  Have a HashMap (sumNodeMap) of node and sum till that node (sum --> node).\\n                  Need to have a dummy head node, to handle in case the head should be deleted as it is zero sum,\\n                  eg in [1,-1,4,3].\\n                  Traverse the Linked List. In each node, calculate the sum. If the sum exists in sumNodeMap, that means\\n                  the nodes between when we found the same sum and current node are zero sum. So get that old node and point\\n                  to next node of current node (essentially remving in-between zero-sum nodes). Also, remove those in-between\\n                  nodes from sumNodeMap, to make sure that we don\\'t use the old removed node again in future. Note that\\n                  this removing process can run for max n (number of nodes) times in total. Thus doesn\\'t affect the\\n                  O(n) time complexity of the whole program.\\n                  \\n        Complexity analysis: Time: O(n), Space: O(n)\\n        */\\n        \\n        HashMap<Integer, ListNode> sumNodeMap = new HashMap<>();\\n        \\n        ListNode dummyPreHead = new ListNode(0);\\n        dummyPreHead.next = head;\\n        \\n        sumNodeMap.put(0, dummyPreHead);                                    //Init the stack with prehead.\\n        \\n        ListNode currNode = head;\\n\\n        int sum = 0;\\n        \\n        while(currNode!=null){\\n            \\n            sum += currNode.val;\\n            \\n            if(sumNodeMap.containsKey(sum)){\\n                \\n                ListNode oldNodeWithSameSum = sumNodeMap.get(sum);          //Old node with same sum\\n                \\n                ListNode toBeRemovedNode = oldNodeWithSameSum.next;         //Remove zero-sum in-between nodes from sumNodeMap\\n                int toBeRemovedSum = sum;\\n                while(toBeRemovedNode != currNode){\\n                    toBeRemovedSum = toBeRemovedSum + toBeRemovedNode.val;\\n                    sumNodeMap.remove(toBeRemovedSum);\\n                    toBeRemovedNode = toBeRemovedNode.next;\\n                }\\n                oldNodeWithSameSum.next = currNode.next;                    //Point old node to current next node\\n            }\\n            else{\\n                sumNodeMap.put(sum, currNode);\\n            }\\n            \\n            currNode = currNode.next;\\n        }\\n        \\n        return dummyPreHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        /*\\n        Approach: The idea is, if we calculate sum of values from start and if A and B nodes are having few zero sum nodes\\n                  between them, they will have the same sum. Eg: In [2,4,2,-6,7], node 2 and node -6 both are having sum as\\n                  2, so we can connect node 2 to node 7, essentially removing zero-sum nodes [4,2,-6] from the list.\\n                  Have a HashMap (sumNodeMap) of node and sum till that node (sum --> node).\\n                  Need to have a dummy head node, to handle in case the head should be deleted as it is zero sum,\\n                  eg in [1,-1,4,3].\\n                  Traverse the Linked List. In each node, calculate the sum. If the sum exists in sumNodeMap, that means\\n                  the nodes between when we found the same sum and current node are zero sum. So get that old node and point\\n                  to next node of current node (essentially remving in-between zero-sum nodes). Also, remove those in-between\\n                  nodes from sumNodeMap, to make sure that we don\\'t use the old removed node again in future. Note that\\n                  this removing process can run for max n (number of nodes) times in total. Thus doesn\\'t affect the\\n                  O(n) time complexity of the whole program.\\n                  \\n        Complexity analysis: Time: O(n), Space: O(n)\\n        */\\n        \\n        HashMap<Integer, ListNode> sumNodeMap = new HashMap<>();\\n        \\n        ListNode dummyPreHead = new ListNode(0);\\n        dummyPreHead.next = head;\\n        \\n        sumNodeMap.put(0, dummyPreHead);                                    //Init the stack with prehead.\\n        \\n        ListNode currNode = head;\\n\\n        int sum = 0;\\n        \\n        while(currNode!=null){\\n            \\n            sum += currNode.val;\\n            \\n            if(sumNodeMap.containsKey(sum)){\\n                \\n                ListNode oldNodeWithSameSum = sumNodeMap.get(sum);          //Old node with same sum\\n                \\n                ListNode toBeRemovedNode = oldNodeWithSameSum.next;         //Remove zero-sum in-between nodes from sumNodeMap\\n                int toBeRemovedSum = sum;\\n                while(toBeRemovedNode != currNode){\\n                    toBeRemovedSum = toBeRemovedSum + toBeRemovedNode.val;\\n                    sumNodeMap.remove(toBeRemovedSum);\\n                    toBeRemovedNode = toBeRemovedNode.next;\\n                }\\n                oldNodeWithSameSum.next = currNode.next;                    //Point old node to current next node\\n            }\\n            else{\\n                sumNodeMap.put(sum, currNode);\\n            }\\n            \\n            currNode = currNode.next;\\n        }\\n        \\n        return dummyPreHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366337,
                "title": "java-iterative-recursive-solution",
                "content": "**Method 1: Iterative:**\\n1. Use a hashmap to keep track the prefix sum.\\n2. If current sum is zero, it means the sum from first node to current node is zero. So the new head is the next node.\\n3. If the current sum already exists the hashmap (say node-```i```), it means the sum from node-```(i+1)``` to current node is zero. So, we remove those nodes.\\n    For example,\\n```\\ninput = [1,2,3,-3,1]\\ni = 0, prefixSum = 1\\ni = 1, prefixSum = 3\\ni = 2, prefixSum = 6\\ni = 3, prefixSum = 3  // prefixsum = 3 is already in the hashmap. It means the sum of subarray [2,3] is zero.\\ni = 4, prefixSum = 4\\n```\\n4. Use a dummy head to simplify code.\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            if(map.containsKey(sum)) {\\n                cur = map.get(sum).next;\\n                int key = sum + cur.val;\\n                while(key != sum) {\\n                    map.remove(key);\\n                    cur = cur.next;\\n                    key += cur.val;\\n                }\\n                map.get(sum).next = cur.next;\\n            }\\n            else {\\n                map.put(sum, cur);   \\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\nTime: O(N)\\nSpace: O(N)\\n\\n**Method 2: Recursive:**\\n\\n1. Remove all the nodes have zero sum starting from head.\\n2. Make sure the next node already has a non-zero-sum linked list. \\n    ```head.next = removeZeroSumSublists(head.next);```\\n3. Use a dummy head to simplify code.\\n\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            if(cur.val + sum == 0) dummy.next = cur.next;\\n            sum += cur.val;\\n            cur = cur.next;\\n        }\\n        if(dummy.next != null) dummy.next.next = removeZeroSumSublists(dummy.next.next);   \\n        return dummy.next;\\n    }\\n}\\n```\\nTime: O(N^2)\\nSpace: O(N)",
                "solutionTags": [],
                "code": "```i```\n```(i+1)```\n```\\ninput = [1,2,3,-3,1]\\ni = 0, prefixSum = 1\\ni = 1, prefixSum = 3\\ni = 2, prefixSum = 6\\ni = 3, prefixSum = 3  // prefixsum = 3 is already in the hashmap. It means the sum of subarray [2,3] is zero.\\ni = 4, prefixSum = 4\\n```\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            if(map.containsKey(sum)) {\\n                cur = map.get(sum).next;\\n                int key = sum + cur.val;\\n                while(key != sum) {\\n                    map.remove(key);\\n                    cur = cur.next;\\n                    key += cur.val;\\n                }\\n                map.get(sum).next = cur.next;\\n            }\\n            else {\\n                map.put(sum, cur);   \\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```head.next = removeZeroSumSublists(head.next);```\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            if(cur.val + sum == 0) dummy.next = cur.next;\\n            sum += cur.val;\\n            cur = cur.next;\\n        }\\n        if(dummy.next != null) dummy.next.next = removeZeroSumSublists(dummy.next.next);   \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366382,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nSimilar to finding subarray sum = 0. `sums` keep track of prefix sums seen so far. If we find the current sum `sum` in the prefix sums map, then we found a subarray sum = 0 from the matching entry till the current element. So remove that portion and move on exporing other nodes.\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                int tmp = sum;\\n                ListNode n = sums.get(sum).next;\\n                while(n != curr){\\n                    tmp += n.val;\\n                    sums.remove(tmp);\\n                    n = n.next;\\n                }\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```\\n**Update-1 (8/25)** Fixed the below bug. But I think which solution is efficient depends on the length of the chain which is being removed (subarray sum=0 portion) or the chain that is kept (from `head` upto the start of the removing portion).\\n\\n**Update-0 (8/24)** The above solution has a bug for cases such as `[3,4,2,-6,1,5,-2,2]`\\nMy original solution is below which goes back to `head` and repeat the process.\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                int tmp = sum;\\n                ListNode n = sums.get(sum).next;\\n                while(n != curr){\\n                    tmp += n.val;\\n                    sums.remove(tmp);\\n                    n = n.next;\\n                }\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701518,
                "title": "easiest-approach-clean-concise-well-explained",
                "content": "## IDEA :\\n*If we see with little focus we will come to know that we are removing the nodes with sum value 0.*\\nBut here the question is how we will come to know that sum of  subset nodes is 0. For this we can use **prefix sum**. If we are having sum which has already appeared once before it means that we are having sum of nodes between them = 0.\\n\\n**Algorithm :**\\n* Firstly make a dummy Node of value 0 to connect in front of the LinkedList.\\n* Using `pre` we will store node with sum value upto that node.\\n\\n* After storing we will again go through full linked list and if we get sum which already has stored in `dic` then we will move next pointer to that `dic` node\\'s next node.\\n\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tdummy = ListNode(0,head)\\n\\t\\t\\tpre = 0\\n\\t\\t\\tdic = {0: dummy}\\n\\n\\t\\t\\twhile head:\\n\\t\\t\\t\\tpre+=head.val\\n\\t\\t\\t\\tdic[pre] = head\\n\\t\\t\\t\\thead = head.next\\n\\n\\t\\t\\thead = dummy\\n\\t\\t\\tpre = 0\\n\\t\\t\\twhile head:\\n\\t\\t\\t\\tpre+=head.val\\n\\t\\t\\t\\thead.next = dic[pre].next\\n\\t\\t\\t\\thead = head.next\\n\\n\\t\\t\\treturn dummy.next\\n\\t\\n**Feel free to ask if you have any doubt or want example as Explaination.** \\uD83E\\uDD17\\n### Thanks and Upvote If you got any help or like the Idea !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tdummy = ListNode(0,head)\\n\\t\\t\\tpre = 0\\n\\t\\t\\tdic = {0: dummy}",
                "codeTag": "Java"
            },
            {
                "id": 477112,
                "title": "very-easy-java-solution-with-explanation",
                "content": "This problem can easily be solved with **pointer to the last sum and Greedy approach.**\\nIt is very similar to this problem: https://leetcode.com/problems/contiguous-array/\\n\\nThe point is - any number of items , whose sum is 0 , will have the same sum with previous items and these items. \\nExample explains everything:\\n[3 ,5, 7, -3,-2,-2, 6]\\n\\nWe can deduct that 7,-3,-2,-2 gives us 0.  So the sum of all previous numbers should be equal to all previous + these numbers which give us 0.\\nLet\\'s calculate sum of all elements\\narr  = [3, 5,  7,  -3, -2, -2,  6]\\ncnt = [3, **8**,15, 12,10,  **8**, 14]\\nAs we can see , we have 2 **8** sums. So we\\'re sure that items between 8\\'s are giving 0. \\n\\nBut what if we find another 8 later? The same thing  - the sum between the first 8 and the last will be equal to 0, so all of these items can be removed. \\n\\narr  = [3, 5,  7,  -3, -2, -2,  6,  -6]\\ncnt = [3, **8**,15, 12,10,  **8**, 14, **8**]\\nAll of these items from first till last together will give the sum of 0.\\n\\nAs the result, we need to know where the last 8 (or any other number) is located. \\nTo keep track of the latest item with any sum , we\\'ll use ```HashMap```.\\nBy going through an array, the latest sum will just override previous item. \\n```\\n    HashMap<Integer, ListNode> map = new HashMap(); \\n\\tint sum = 0;\\n\\t\\n\\tfor(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n\\t\\tsum+= pointer.val;\\n\\t\\tmap.put(sum, pointer);\\n\\t}\\n```\\n\\n!! If we see 0 as the sum, we need to delete all items between this last 0 , and first one. The point is that the place where we saw 0 first time was before any sum operations, which means that we have to delete all items before this item. \\nIn our case - just set ```head``` to item with 0 sum. \\n\\nAfter that, we iterate through the same nodes again, but this time we\\'ll be looking for the same sums in the hashmap, and rellocating our pointer there. \\nIf we find 0 sum, we\\'ll rellocate the head to this item as well ( because everything before will give us 0)\\n\\n**Try to play with this solution on paper and try to create your own algorithm similar to this - this is how you learn things! Just reading and copy-pasting will not be enough!**\\n\\nHere\\'s the full solution:\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap();\\n        \\n        int sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            map.put(sum, pointer);\\n        }\\n        \\n        sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            ListNode node = map.get(sum);\\n            if(sum == 0) head = node.next;\\n            if(node != pointer) pointer.next = node.next ;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```HashMap```\n```\\n    HashMap<Integer, ListNode> map = new HashMap(); \\n\\tint sum = 0;\\n\\t\\n\\tfor(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n\\t\\tsum+= pointer.val;\\n\\t\\tmap.put(sum, pointer);\\n\\t}\\n```\n```head```\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap();\\n        \\n        int sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            map.put(sum, pointer);\\n        }\\n        \\n        sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            ListNode node = map.get(sum);\\n            if(sum == 0) head = node.next;\\n            if(node != pointer) pointer.next = node.next ;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367021,
                "title": "python-beats-100-tc-sc-without-a-dummy-node",
                "content": "```\\n\\n\\t    hashMap, runningSum = {}, 0\\n        cur = head \\n        while cur:\\n            runningSum += cur.val\\n            if runningSum == 0:\\n                head = cur.next\\n            else:\\n                if runningSum not in hashMap:\\n                    hashMap[runningSum] = cur \\n                else:\\n                    hashMap[runningSum].next = cur.next\\n            cur = cur.next\\n        return head\\n\\n```\\n\\nLet\\'s go over the explanation:\\n\\n\\t1. Initialize a hashMap to maintain a runningSum \\n\\n\\t2.\\n\\t\\trunningSum = 0\\n\\t\\t[1,2,3,-3,4] <- Example\\n\\n\\t\\trunningSums = [1,3,6,3,7] # we see that 3 has appeared again that means there had been a negtive number which dropped the runninSum \\n\\n\\t\\trunningSums = [1,3,7] # Here we can set the last seen runningSum node.next to cur node.next\\n\\n\\t\\tlastSeen 3.next = currentSeen 3.next\\n\\n\\t3. Corner cases [1,-1]\\n\\t\\tHere just set the head to cur.next as soon as we see a 0\\n",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\n\\n\\t    hashMap, runningSum = {}, 0\\n        cur = head \\n        while cur:\\n            runningSum += cur.val\\n            if runningSum == 0:\\n                head = cur.next\\n            else:\\n                if runningSum not in hashMap:\\n                    hashMap[runningSum] = cur \\n                else:\\n                    hashMap[runningSum].next = cur.next\\n            cur = cur.next\\n        return head\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366426,
                "title": "clean-n-2-ac-solution",
                "content": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        for(ListNode i = dummy; i != null; i = i.next){\\n            int sum = 0;\\n            for(ListNode j = i.next; j != null ;){\\n                sum += j.val;\\n                if(sum == 0){\\n                    i.next = j.next;\\n                }\\n                j = j.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        for(ListNode i = dummy; i != null; i = i.next){\\n            int sum = 0;\\n            for(ListNode j = i.next; j != null ;){\\n                sum += j.val;\\n                if(sum == 0){\\n                    i.next = j.next;\\n                }\\n                j = j.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795180,
                "title": "java-hashmap-prefix-sum",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        Map<Integer,ListNode> m = new HashMap<>();\\n        int prefixsum=0;\\n        ListNode cur = fake;\\n        while(cur!=null)\\n        {\\n            //System.out.println(cur.val);\\n            prefixsum+=cur.val;\\n            if(m.containsKey(prefixsum))\\n            {\\n                m.get(prefixsum).next=cur.next;\\n                m.clear();\\n                prefixsum=0;\\n                cur = fake;\\n            }\\n            else{\\n                m.put(prefixsum,cur);\\n                cur=cur.next;\\n            }\\n        }\\n        return fake.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        Map<Integer,ListNode> m = new HashMap<>();\\n        int prefixsum=0;\\n        ListNode cur = fake;\\n        while(cur!=null)\\n        {\\n            //System.out.println(cur.val);\\n            prefixsum+=cur.val;\\n            if(m.containsKey(prefixsum))\\n            {\\n                m.get(prefixsum).next=cur.next;\\n                m.clear();\\n                prefixsum=0;\\n                cur = fake;\\n            }\\n            else{\\n                m.put(prefixsum,cur);\\n                cur=cur.next;\\n            }\\n        }\\n        return fake.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685304,
                "title": "c-o-n-solution-using-hashing-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/\\n    \\n    Idea is that whenever consecutive 0-sum zublist appears, the cumulative sum becomes the same as\\n    it was just before the start of that sublist.\\n    We use a hash table to update the latest position of each cumulative sum.\\n    Then we again start the traversal computing cumulative sum and checking what is the\\n    latest position where it occurs and delete the sublist in between.\\n*/\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Deletes a linked list\\n    void deleteList(ListNode* head) {\\n        ListNode *nextptr= nullptr;\\n        while(head) {\\n            nextptr = head->next;\\n            //delete head;\\n            head = nextptr;\\n        }\\n    }\\n    \\n    // TC: O(N)\\n    // SC: O(N)\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        // (sum: pos): cumulative sum till a given node\\n        unordered_map<int, ListNode*> sum_pos;\\n        ListNode *start = nullptr, *end = nullptr, \\n                *after_start = nullptr, *after_end = nullptr;\\n        long long sum = 0;\\n        \\n        // dummy head for easier head ops\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        // initial sum 0 for position before head\\n        sum_pos[0] = dummy;\\n        \\n        // Store the cumulative sum till each node,\\n        // for the same cumulative sum we store the latest position\\n        ListNode *curr = head;\\n        while(curr) {\\n            sum += curr->val;\\n            sum_pos[sum] = curr;\\n            curr = curr->next;\\n        }\\n        \\n        // We compute the cumulative sum again, this time\\n        // for each sum we check that farthest position where it is \\n        // found again and delete the list till that position\\n        sum = 0;\\n        curr = dummy;\\n        while(curr) {\\n            sum += curr->val;\\n            // check the position this sum is last seen\\n            ListNode *last_seen_pos = sum_pos[sum];\\n            // delete the sublist to avoid memory leaks\\n            after_start = curr->next;\\n            after_end = last_seen_pos->next;\\n            // when it is not the same node\\n            // and trhere is somethign to delete\\n            if(last_seen_pos != curr) {\\n                last_seen_pos->next = nullptr;\\n                deleteList(after_start);\\n            }\\n            \\n            curr->next = after_end;\\n            curr = curr->next;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/\\n    \\n    Idea is that whenever consecutive 0-sum zublist appears, the cumulative sum becomes the same as\\n    it was just before the start of that sublist.\\n    We use a hash table to update the latest position of each cumulative sum.\\n    Then we again start the traversal computing cumulative sum and checking what is the\\n    latest position where it occurs and delete the sublist in between.\\n*/\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Deletes a linked list\\n    void deleteList(ListNode* head) {\\n        ListNode *nextptr= nullptr;\\n        while(head) {\\n            nextptr = head->next;\\n            //delete head;\\n            head = nextptr;\\n        }\\n    }\\n    \\n    // TC: O(N)\\n    // SC: O(N)\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        // (sum: pos): cumulative sum till a given node\\n        unordered_map<int, ListNode*> sum_pos;\\n        ListNode *start = nullptr, *end = nullptr, \\n                *after_start = nullptr, *after_end = nullptr;\\n        long long sum = 0;\\n        \\n        // dummy head for easier head ops\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        // initial sum 0 for position before head\\n        sum_pos[0] = dummy;\\n        \\n        // Store the cumulative sum till each node,\\n        // for the same cumulative sum we store the latest position\\n        ListNode *curr = head;\\n        while(curr) {\\n            sum += curr->val;\\n            sum_pos[sum] = curr;\\n            curr = curr->next;\\n        }\\n        \\n        // We compute the cumulative sum again, this time\\n        // for each sum we check that farthest position where it is \\n        // found again and delete the list till that position\\n        sum = 0;\\n        curr = dummy;\\n        while(curr) {\\n            sum += curr->val;\\n            // check the position this sum is last seen\\n            ListNode *last_seen_pos = sum_pos[sum];\\n            // delete the sublist to avoid memory leaks\\n            after_start = curr->next;\\n            after_end = last_seen_pos->next;\\n            // when it is not the same node\\n            // and trhere is somethign to delete\\n            if(last_seen_pos != curr) {\\n                last_seen_pos->next = nullptr;\\n                deleteList(after_start);\\n            }\\n            \\n            curr->next = after_end;\\n            curr = curr->next;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902549,
                "title": "c-hashmap-prefixsum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head)\\n    {\\n        ListNode *dummynode=new ListNode(0),*curr=dummynode;\\n        dummynode->next=head;\\n        map<int,ListNode*> mp;\\n        int sum=0;\\n        while(curr)\\n        {\\n            sum+=curr->val;\\n            if(mp.count(sum))\\n            {\\n                curr=mp[sum]->next;\\n                int p=sum+curr->val;\\n                while(p!=sum)\\n                {\\n                    mp.erase(p);\\n                    curr=curr->next;\\n                    p+=curr->val;\\n                }\\n                mp[sum]->next=curr->next;\\n            }\\n            else\\n            {\\n                mp[sum]=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        return dummynode->next;\\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head)\\n    {\\n        ListNode *dummynode=new ListNode(0),*curr=dummynode;\\n        dummynode->next=head;\\n        map<int,ListNode*> mp;\\n        int sum=0;\\n        while(curr)\\n        {\\n            sum+=curr->val;\\n            if(mp.count(sum))\\n            {\\n                curr=mp[sum]->next;\\n                int p=sum+curr->val;\\n                while(p!=sum)\\n                {\\n                    mp.erase(p);\\n                    curr=curr->next;\\n                    p+=curr->val;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 995902,
                "title": "java-two-pass-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        int prefix = 0;\\n        ListNode curr = dummy;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(prefix, dummy);\\n        \\n        while (curr != null) {\\n            prefix += curr.val;\\n            seen.put(prefix, curr);\\n            curr = curr.next;\\n        }\\n        \\n        prefix = 0;\\n        curr = dummy;\\n        while (curr != null) {\\n            prefix += curr.val;\\n            curr.next = seen.get(prefix).next;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        int prefix = 0;\\n        ListNode curr = dummy;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(prefix, dummy);\\n        \\n        while (curr != null) {\\n            prefix += curr.val;\\n            seen.put(prefix, curr);\\n            curr = curr.next;\\n        }\\n        \\n        prefix = 0;\\n        curr = dummy;\\n        while (curr != null) {\\n            prefix += curr.val;\\n            curr.next = seen.get(prefix).next;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366510,
                "title": "python-solution-with-dict",
                "content": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n    p = dummy = ListNode(0)\\n    dummy.next = head\\n    s = 0\\n    s_sum = [s]\\n    vals = {}\\n    while p:\\n        s += p.val\\n        s_sum.append(s)\\n        if s not in vals:\\n            vals[s] = p\\n        else:\\n            vals[s].next = p.next\\n            s_sum.pop() # remove cur, keep the last\\n            while s_sum[-1] != s:\\n                vals.pop(s_sum.pop())\\n        p = p.next\\n    return dummy.next\\n```",
                "solutionTags": [],
                "code": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n    p = dummy = ListNode(0)\\n    dummy.next = head\\n    s = 0\\n    s_sum = [s]\\n    vals = {}\\n    while p:\\n        s += p.val\\n        s_sum.append(s)\\n        if s not in vals:\\n            vals[s] = p\\n        else:\\n            vals[s].next = p.next\\n            s_sum.pop() # remove cur, keep the last\\n            while s_sum[-1] != s:\\n                vals.pop(s_sum.pop())\\n        p = p.next\\n    return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2079419,
                "title": "java-two-pass-solution-using-prefix-sum",
                "content": "\\tpublic static ListNode removeZeroSumSublists(ListNode head) {\\n        int prefixSum = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        Map<Integer, ListNode> hashMap = new HashMap<>();\\n        hashMap.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            hashMap.put(prefixSum, i);\\n        }\\n        prefixSum = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            i.next = hashMap.get(prefixSum).next;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "\\tpublic static ListNode removeZeroSumSublists(ListNode head) {\\n        int prefixSum = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        Map<Integer, ListNode> hashMap = new HashMap<>();\\n        hashMap.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            hashMap.put(prefixSum, i);\\n        }\\n        prefixSum = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            i.next = hashMap.get(prefixSum).next;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 580406,
                "title": "java-92-78-time-100-00-space",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer,ListNode> map = new HashMap<Integer,ListNode>();\\n        ListNode dummy = new ListNode(0),p;\\n        dummy.next = head;\\n        p = dummy;\\n        int sum = 0;\\n        while(p!=null){\\n            sum+=p.val;\\n            map.put(sum,p);\\n            p = p.next;\\n        }\\n        sum = 0;\\n        p = dummy;\\n        while(p!=null){\\n            sum+=p.val;\\n            if(map.containsKey(sum)){\\n                ListNode tmp = map.get(sum);\\n                if(tmp!=p){\\n                    p.next = tmp.next;\\n                }\\n            }\\n            p = p.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer,ListNode> map = new HashMap<Integer,ListNode>();\\n        ListNode dummy = new ListNode(0),p;\\n        dummy.next = head;\\n        p = dummy;\\n        int sum = 0;\\n        while(p!=null){\\n            sum+=p.val;\\n            map.put(sum,p);\\n            p = p.next;\\n        }\\n        sum = 0;\\n        p = dummy;\\n        while(p!=null){\\n            sum+=p.val;\\n            if(map.containsKey(sum)){\\n                ListNode tmp = map.get(sum);\\n                if(tmp!=p){\\n                    p.next = tmp.next;\\n                }\\n            }\\n            p = p.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367211,
                "title": "super-simple-python-solution-commented",
                "content": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \\n        d = dict()          # dictionary of {cumsum : ListNode}\\n        cumsum = 0          # cumulative sum of visited nodes\\n        walk = head         # walks across Linked List\\n        \\n        while walk is not None:\\n            cumsum += walk.val\\n\\n            if cumsum == 0:\\n                # Delete all nodes before and including the\\n                # node marked with cumsum = 0\\n                walk = walk.next\\n                while head != walk:\\n                    delNode = head\\n                    head = head.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            elif cumsum in d:\\n                # Delete all nodes after and including the\\n                # node marked with the same cumsum already\\n                # in the dictionary (they sum up to 0)\\n                ptr = d[cumsum]\\n                walk = walk.next\\n                while ptr.next != walk:\\n                    delNode = ptr.next\\n                    ptr.next = delNode.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            else:\\n                # add cumsum and current node to dictionary\\n                d[cumsum] = walk\\n                walk = walk.next\\n                \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \\n        d = dict()          # dictionary of {cumsum : ListNode}\\n        cumsum = 0          # cumulative sum of visited nodes\\n        walk = head         # walks across Linked List\\n        \\n        while walk is not None:\\n            cumsum += walk.val\\n\\n            if cumsum == 0:\\n                # Delete all nodes before and including the\\n                # node marked with cumsum = 0\\n                walk = walk.next\\n                while head != walk:\\n                    delNode = head\\n                    head = head.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            elif cumsum in d:\\n                # Delete all nodes after and including the\\n                # node marked with the same cumsum already\\n                # in the dictionary (they sum up to 0)\\n                ptr = d[cumsum]\\n                walk = walk.next\\n                while ptr.next != walk:\\n                    delNode = ptr.next\\n                    ptr.next = delNode.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            else:\\n                # add cumsum and current node to dictionary\\n                d[cumsum] = walk\\n                walk = walk.next\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290238,
                "title": "easy-and-simple-detailed-c-solution-using-vector-and-sliding-window-approach",
                "content": "# Intuition\\nAs we can see from the problem statement, we need to check for subsequences in the linked list whose sum is zero, which reminds us of the subarray sum problem. Therefore, it is advisable to use a vector as a supporting data structure, as it is easier to handle and familiar to most of us.\\n\\n# Approach\\n\"Since the problem requires finding sub-sequences with a sum of zero, we will start by using a vector to store the values of the linked list. Then, we will find the indices of the sub-sequences whose sum is zero. To avoid any repetition, we will convert all the values whose sum is zero to zero, so that they don\\'t interfere with the computation of other sub-sequences. Next, we will create a new linked list and add nodes to it from the non-zero values of the vector. Finally, we will end the linked list by setting its last node to point to nullptr. We will return the next of the head of the new linked list as the actual head, as the initial head was created with a dummy value which we don\\'t need\\n\\n# Complexity\\n- Time complexity:\\n**O(N^2)**:- You all will be thinking seeing the loop that is has a time complexity of N^3 but it is not. we are using the same concept of subarray sum to k problem. Hence using sliding window and taking worst time of O(N) for the subarray calculation and N more for the conversion of the all the values to zero.\\noverall complexity. **( O(N+N^2+N)==O(N^2))**\\n\\n- Space complexity:\\n**O(N)**:- As we are using a vector of size the number of nodes are.(Here N is the total number of node in the problem. )\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vec;\\n        ListNode* temp = head;\\n        while (temp) {\\n            vec.push_back(temp->val); // copying the whole linked list to the vector \\n            temp = temp->next;\\n        }\\n        \\n        for (int start = 0; start < vec.size(); start++) {\\n            int sum = 0;\\n            for (int end = start; end < vec.size(); end++) {\\n                sum += vec[end]; // using sliding window to find the subarray with sum as zero\\n                if (sum == 0) {\\n                    for (int i = start; i <= end; i++) {\\n                        vec[i] = 0; // making all the values in the range (start,end) to zero \\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        ListNode alt(0); // dummy node is created so that we can make a linked list with values from the vector\\n        ListNode* a = &alt;\\n        for (int p = 0; p < vec.size(); p++) {\\n            if (vec[p] != 0) { // we take the non-zero values only\\n                a->next = new ListNode(vec[p]);\\n                a = a->next;\\n            }\\n        }\\n        a->next = nullptr;\\n        return alt.next; // as the head has a dummy value and all the required value is in the next of head \\n        // we return the next of the head i.e alt.next\\n    }\\n};\\n```\\n\\n**DO UPVOTE IF THIS WAS HELPFUL, AND FEEDBACK IS ALWAYS WELCOME :)**",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vec;\\n        ListNode* temp = head;\\n        while (temp) {\\n            vec.push_back(temp->val); // copying the whole linked list to the vector \\n            temp = temp->next;\\n        }\\n        \\n        for (int start = 0; start < vec.size(); start++) {\\n            int sum = 0;\\n            for (int end = start; end < vec.size(); end++) {\\n                sum += vec[end]; // using sliding window to find the subarray with sum as zero\\n                if (sum == 0) {\\n                    for (int i = start; i <= end; i++) {\\n                        vec[i] = 0; // making all the values in the range (start,end) to zero \\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        ListNode alt(0); // dummy node is created so that we can make a linked list with values from the vector\\n        ListNode* a = &alt;\\n        for (int p = 0; p < vec.size(); p++) {\\n            if (vec[p] != 0) { // we take the non-zero values only\\n                a->next = new ListNode(vec[p]);\\n                a = a->next;\\n            }\\n        }\\n        a->next = nullptr;\\n        return alt.next; // as the head has a dummy value and all the required value is in the next of head \\n        // we return the next of the head i.e alt.next\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028162,
                "title": "javascript-hashmap-prefix-sum-two-pass-easy-to-read",
                "content": "*Key point*: \\n* When seeing the word **consecutive sequence**, think about using **Prefix Sum** strategy.\\n* The goal is to remove the consequence sequence. We don\\'t really care about the nodes within this sequence.\\n\\n\\n\\n\\n*Algorithm*: \\n\\nStep 1: \\nWe buld the the map to store the accumlative sum with the **last node which holds the same accumlative value**. \\nWe care the last node because **the next of the last node** is where we want to build and connect the output. \\n\\nStep 2: \\nUse the node from our map to build the output.\\n\\n\\n```\\nvar removeZeroSumSublists = function(head) {\\n    if (!head) {\\n        return head;\\n    }\\n    \\n\\t// Initialize\\n    let dummy = new ListNode(0);\\n    dummy.next = head;\\n    \\n    // Step1: build the prefix sum map\\n    let curr = dummy \\n    let prefixSumMap = new Map(); \\n    let runningSum = 0; \\n    \\n    while (curr) {\\n        runningSum += curr.val;\\n        prefixSumMap.set(runningSum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    // Step 2: build the output\\n    curr = dummy;\\n    runningSum = 0;\\n    \\n    while (curr) {\\n        runningSum += curr.val; \\n        curr.next = prefixSumMap.get(runningSum).next;\\n        curr = curr.next; \\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n    if (!head) {\\n        return head;\\n    }\\n    \\n\\t// Initialize\\n    let dummy = new ListNode(0);\\n    dummy.next = head;\\n    \\n    // Step1: build the prefix sum map\\n    let curr = dummy \\n    let prefixSumMap = new Map(); \\n    let runningSum = 0; \\n    \\n    while (curr) {\\n        runningSum += curr.val;\\n        prefixSumMap.set(runningSum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    // Step 2: build the output\\n    curr = dummy;\\n    runningSum = 0;\\n    \\n    while (curr) {\\n        runningSum += curr.val; \\n        curr.next = prefixSumMap.get(runningSum).next;\\n        curr = curr.next; \\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755278,
                "title": "python-o-n-solution-100-speed",
                "content": "**Python O(n) Solution | 100% Speed**\\n\\nThe Python code below corresponds to a solution with O(n) time/space complexity.  The algorithm is based on the concept of cumulative sums, which works as follows:\\n\\n1. Define an initial cummulative sum \"s=0\", and start travelling across the nodes of the linked list (One-Pass loop). Build a stack \"S\" with each cummulative sum \"seen\", and a companion dictionary \"d\" for faster access to the location of each sum (avoid O(n) searches). To track the nodes of the Linked List chosen, define a second stack \"A\".\\n\\n2. If a cummulative sum appears twice, delete all entries that occurred after the first instance, and also remove them from our dictionary \"d\". For example, if we had [2,4,-4], the cummulative sums are [2,6,2], so deleting all nodes/entries after the first \"2\" is the correct choice.\\n\\n3. Iterate repeating the rules of Step 2 until the end of the linked list.\\n\\n4. Fix the pointers of the stack \"A\", to ensure that A[i].next = A[i+1]. Also, make sure that the last pointer is Null (A[-1].next = None)\\n\\n5. Return the Head of our new Linked List \"A[0]\" (if it exists)\\n\\nI hope the explanation was helpful. I think this is a beautiful problem.\\n\\nCheers,\\n\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        #\\n        def yielder(n):\\n            # yielder: Access elements of Linked List (n=head initially)\\n            while n:\\n                yield n\\n                n = n.next\\n        #\\n        # A: nodes found\\n        # S: Running Sum values (always unique, since duplicates triger cleanup)\\n        # d: Companion dictionary for \"S\" (allows quick O(1) access).\\n        #    Entries are d[cumulative_sum] = index \\n        # t: Current Running sum\\n        #\\n        A, S = [], [] \\n        d    = {0:-1} \\n        t    = 0      # s: Current Sum\\n        for n in yielder(head):\\n            t += n.val\\n            if t in d:\\n                # Running Sum seen before, trigger cleanup\\n                for _ in range(d[t]+1,len(A)):\\n                    A.pop()\\n                    d.pop(S.pop())\\n                t = S[-1] if S else 0\\n            else:\\n                # Append new cumulative sum (unseen before)\\n                A.append(n)\\n                S.append(t)\\n                d[t] = len(A) - 1\\n        #\\n        # Fix Linked List Pointers\\n        A.append(None)\\n        for i,x in enumerate(A[:-1]):\\n            x.next = A[i+1]\\n        return A[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        #\\n        def yielder(n):\\n            # yielder: Access elements of Linked List (n=head initially)\\n            while n:\\n                yield n\\n                n = n.next\\n        #\\n        # A: nodes found\\n        # S: Running Sum values (always unique, since duplicates triger cleanup)\\n        # d: Companion dictionary for \"S\" (allows quick O(1) access).\\n        #    Entries are d[cumulative_sum] = index \\n        # t: Current Running sum\\n        #\\n        A, S = [], [] \\n        d    = {0:-1} \\n        t    = 0      # s: Current Sum\\n        for n in yielder(head):\\n            t += n.val\\n            if t in d:\\n                # Running Sum seen before, trigger cleanup\\n                for _ in range(d[t]+1,len(A)):\\n                    A.pop()\\n                    d.pop(S.pop())\\n                t = S[-1] if S else 0\\n            else:\\n                # Append new cumulative sum (unseen before)\\n                A.append(n)\\n                S.append(t)\\n                d[t] = len(A) - 1\\n        #\\n        # Fix Linked List Pointers\\n        A.append(None)\\n        for i,x in enumerate(A[:-1]):\\n            x.next = A[i+1]\\n        return A[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366326,
                "title": "python-o-n-solution-using-cumulative-sum",
                "content": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        hmap = {0: dummy}\\n\\n        node, cumsum = head, 0\\n        while node:\\n            nex = node.next\\n            cumsum += node.val\\n            if cumsum in hmap:\\n                temp = hmap[cumsum]\\n                delnode = temp.next\\n                temp.next = node.next\\n\\n                tcsum = cumsum\\n                while delnode.next != temp.next:\\n                    tcsum += delnode.val\\n                    del hmap[tcsum]\\n                    delnode = delnode.next\\n            else:\\n                hmap[cumsum] = node\\n            node = nex\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        hmap = {0: dummy}\\n\\n        node, cumsum = head, 0\\n        while node:\\n            nex = node.next\\n            cumsum += node.val\\n            if cumsum in hmap:\\n                temp = hmap[cumsum]\\n                delnode = temp.next\\n                temp.next = node.next\\n\\n                tcsum = cumsum\\n                while delnode.next != temp.next:\\n                    tcsum += delnode.val\\n                    del hmap[tcsum]\\n                    delnode = delnode.next\\n            else:\\n                hmap[cumsum] = node\\n            node = nex\\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3526168,
                "title": "solution-using-hash-map-o-n-easiest-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBruteForce Approach:\\n1. Traverse through the linked list using two nested loops.\\n2. For each starting node in the outer loop, calculate the sum of consecutive nodes in the inner loop.\\n3. If the sum of consecutive nodes is zero, remove those nodes from the linked list.\\n4. Repeat this process for all possible starting nodes and check all consecutive nodes for zero sum.\\n5. Return the modified linked list after removing all zero-sum consecutive nodes.\\n\\nSummary: In summary, the brute force approach involves iterating through all possible starting nodes and checking all consecutive nodes for zero sum, and removing them from the linked list when a zero sum is found. This approach has a time complexity of O(n^2), where n is the number of nodes in the linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. So We Will be observing the prefix sum of the linked list. Lets Take First Testcase and on the first Node The Prefix Sum Will Be 1 and in the secong node it will be 1 + 2 = 3. and in thrd node it will be 1 + 2 + 3 = 6, and in the next of that node the prefix sum will be 1 + 2 + 3 + (-3) = 3. so we can observe that we again received the number 3 so that means fromn the first accurance of the 3 to the last occurence there are somem node whose sum is \\'0\\'.\\n2. now we will create an Hash Map unordered_map<int, ListNode*> m; and a dummy node with 0 and pointing the dummy->next = head; why we are doing so ? because head node can also be zero so it can be deleted by this approach so we will be hadling this edge case by this;\\n3. so in map we will be doing lik,e thi : m[0] = dummy; because initialy the prefix sum will be 0.\\n4. further we will initalize the variabnle with prefix sum name and now we will start traveresing the lkinked list for the prefix sum calculation.\\n5. what if we not found any dupicate element ? we sill be doing m[prefixsum] = head bcz we ae pointing the particular prefix sum to the corresponding node \\n6. what if we fond the element agaion ? we will be starting foprk the next odf that particular node so let initialize anothe rlist node with the name if start like: ListNode* start = m[prefix_sum];\\n7. then we will stroe the prefix sum in the new variable sum so that it wil be helping further to delete or erase the values.\\n8. further we will be starting form start->next and we wil check till start != NULL && start != head;\\n9. further we will check i\\n                        f(start != head)\\n                        {\\n                            m.erase(sum);\\n                        }\\nthen increranet the m[prefixsum]->next = head->next;\\nand retrun the dummy->next;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n), where n is the number of nodes in the linked list.\\n\\nThe code iterates through the linked list once, performing constant time operations for each node. Within the while loop, the code checks if the prefix sum exists in the unordered map, which has an average time complexity of O(1) assuming a well-distributed hash function.\\n\\nTherefore, the overall time complexity is dominated by the loop that iterates through the linked list, resulting in O(n) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n), where n is the number of nodes in the linked list.\\n\\nThe code uses an unordered map to store prefix sums and their corresponding node pointers. In the worst case, all nodes in the linked list could have distinct prefix sums, resulting in O(n) entries in the unordered map.\\n\\nAdditionally, the code creates a dummy node and maintains a reference to it throughout the execution, but the space occupied by the dummy node is constant and does not depend on the input size.\\n\\nHence, the overall space complexity is O(n), considering the space used by the unordered map and the constant space used by the dummy node.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head == NULL) return 0;\\n        unordered_map<int, ListNode*> m;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        m[0] = dummy;\\n        int prefix_sum = 0;\\n        while(head != NULL)\\n        {\\n            prefix_sum = prefix_sum + head->val; // prefix_sum += head->val;\\n            if(m.find(prefix_sum) != m.end()){\\n                    ListNode* start = m[prefix_sum];\\n                    int sum = prefix_sum;\\n                    while(start != NULL && start != head)\\n                    {\\n                        start = start->next;\\n                        sum+=start->val;\\n                        if(start != head)\\n                        {\\n                            m.erase(sum);\\n                        }\\n                        \\n                    } \\n                    m[prefix_sum]->next = head->next;     \\n            }\\n            else{\\n                m[prefix_sum] = head; // jaha pr jo sum mila us ke head node ko map se maapp krdenge \\n            }\\n            head = head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head == NULL) return 0;\\n        unordered_map<int, ListNode*> m;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        m[0] = dummy;\\n        int prefix_sum = 0;\\n        while(head != NULL)\\n        {\\n            prefix_sum = prefix_sum + head->val; // prefix_sum += head->val;\\n            if(m.find(prefix_sum) != m.end()){\\n                    ListNode* start = m[prefix_sum];\\n                    int sum = prefix_sum;\\n                    while(start != NULL && start != head)\\n                    {\\n                        start = start->next;\\n                        sum+=start->val;\\n                        if(start != head)\\n                        {\\n                            m.erase(sum);\\n                        }\\n                        \\n                    } \\n                    m[prefix_sum]->next = head->next;     \\n            }\\n            else{\\n                m[prefix_sum] = head; // jaha pr jo sum mila us ke head node ko map se maapp krdenge \\n            }\\n            head = head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523185,
                "title": "java-solution-using-prefix-sum",
                "content": "We take each node and calculate its prefix sum. Prefix sum means the sum of node\\'s val + previous prefix sum\\n\\nInitially, prefix sum is 0 so as we iterate through our linked list, we keep adding the value to this prefix sum and keep adding the entries in map (unless there already is an entry in the map with same prefix sum).\\n\\ne.g. \\n\\n 1 -> 2 -> -3 -> 3 -> 1\\n \\n Initially, our prefix sum is 0. \\n \\nAnd if you are wondering why we used a dummy node, just think of this simple case when linked list is : 0 -> 0\\nIn this case we want to remove both nodes and return null. So that is why, we want a dummy node that sits before this linked list. In simple words, head node can also be a node with 0 value so that\\'s why we have a dummy node.\\n\\nAnyways, coming to 1 -> 2 -> -3 -> 3 -> 1\\n\\nInitially, our prefixSum is 0 and our map only has one entry which is { prefixSum  = 0 and node = dummy }\\n\\nNow, as start traversing. We get 1. prefixSum becomes 0 + 1 = 1. Since map does not have any entry with prefixSum = 1, we put this new entry in map.\\n\\nMap becomes -  {0 : dummy, 1 : 0th node}\\n\\nNext is 2. prefixSum becomes 1 + 2 => 3 Again, we put it in map.\\n\\nMap becomes -  {0 : dummy, \\n\\t\\t\\t\\t\\t\\t\\t1 : 0th node, \\n\\t\\t\\t\\t\\t\\t\\t2 : 1st node}\\n\\t\\t\\t\\t\\t\\t\\t\\nNext is -3. prefixSum becomes 3 + (-3) which is 0. Now we see that 0 already exists in the map. What does this mean? This means that between dummy node and the 2nd node (including it), the sum is 0 that is why we are again getting the same prefixSum at 2nd node.\\n\\nSo this basically means we have to delete all the nodes between dummy node and the 2nd node(including it). \\n\\nWe also need to make sure that when we delete the nodes, we also clear their references from the map i.e., delete all entries for those nodes.\\n\\nWe can do that using the prefixSum again. Since we want to start deleting from 0th node, we take its value, add to current prefixSum => 1 + 0 = 1, find the entry in map with key = 1 and remove it.\\n\\nAnd finally, as we do in linked list, to delete, all we have to do is dummy.next = 2nd node.next\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        \\n       ListNode dummy = new ListNode(0,head);   \\n        \\n       //Map that has key as the prefix sum and value as the node for that respective prefix sum\\n       Map<Integer, ListNode> map = new HashMap<>();\\n        \\n       int prefixSum = 0;\\n        \\n       //Put the dummy node as the value of key 0\\n       map.put(0, dummy);\\n        \\n       while(head != null){\\n           prefixSum += head.val;\\n           \\n           if(map.containsKey(prefixSum)){\\n               //From the map, remove entries of all nodes that we want to delete\\n\\t\\t\\t   ListNode prev = map.get(prefixSum);\\n               ListNode node = prev.next;\\n               int sum = prefixSum;\\n               \\n               while(node != head){\\n                   sum += node.val;\\n                   map.remove(sum);\\n                   node = node.next;\\n               }\\n               //Delete the nodes\\n               prev.next = head.next;\\n           } else{\\n               //If prefixSum does not already exist in map we can safely put the entry in map.\\n               map.put(prefixSum, head);\\n           }\\n           \\n           head = head.next;\\n       }\\n        \\n        return dummy.next;\\n       \\n     }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Prefix Sum"
                ],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        \\n       ListNode dummy = new ListNode(0,head);   \\n        \\n       //Map that has key as the prefix sum and value as the node for that respective prefix sum\\n       Map<Integer, ListNode> map = new HashMap<>();\\n        \\n       int prefixSum = 0;\\n        \\n       //Put the dummy node as the value of key 0\\n       map.put(0, dummy);\\n        \\n       while(head != null){\\n           prefixSum += head.val;\\n           \\n           if(map.containsKey(prefixSum)){\\n               //From the map, remove entries of all nodes that we want to delete\\n\\t\\t\\t   ListNode prev = map.get(prefixSum);\\n               ListNode node = prev.next;\\n               int sum = prefixSum;\\n               \\n               while(node != head){\\n                   sum += node.val;\\n                   map.remove(sum);\\n                   node = node.next;\\n               }\\n               //Delete the nodes\\n               prev.next = head.next;\\n           } else{\\n               //If prefixSum does not already exist in map we can safely put the entry in map.\\n               map.put(prefixSum, head);\\n           }\\n           \\n           head = head.next;\\n       }\\n        \\n        return dummy.next;\\n       \\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1613971,
                "title": "python3-easy-and-clean",
                "content": "```\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        seen = {0: fake}        \\n        prev = 0\\n        \\n        while head:\\n            prev += head.val            \\n            seen[prev] = head\\n            \\n            head = head.next\\n            \\n        head = fake\\n        prev = 0\\n        \\n        while head:\\n            prev += head.val\\n            head.next = seen[prev].next\\n            \\n            head = head.next\\n            \\n        return fake.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        seen = {0: fake}        \\n        prev = 0\\n        \\n        while head:\\n            prev += head.val            \\n            seen[prev] = head\\n            \\n            head = head.next\\n            \\n        head = fake\\n        prev = 0\\n        \\n        while head:\\n            prev += head.val\\n            head.next = seen[prev].next\\n            \\n            head = head.next\\n            \\n        return fake.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1501120,
                "title": "python3-o-n-time-solution-with-hashmap",
                "content": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        d = {0: fake}\\n        \\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            d[prefix_sum] = head\\n            head = head.next\\n            \\n        head = fake\\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            head.next = d[prefix_sum].next\\n            head = head.next\\n            \\n        return fake.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        d = {0: fake}\\n        \\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            d[prefix_sum] = head\\n            head = head.next\\n            \\n        head = fake\\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            head.next = d[prefix_sum].next\\n            head = head.next\\n            \\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976072,
                "title": "java-explanation-using-hashmap",
                "content": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return null;\\n        HashMap < Integer , ListNode> hm = new HashMap<>();\\n        //we make a hashmap so that further we can manipulate sum and nodes.\\n        ListNode dummy = new ListNode(0), curr = head;\\n        hm.put(0 , dummy); //initiating dummy node with 0 not -1 because -1 will hinder the sum value and 0 do not\\n        dummy.next = head;\\n        int sum = 0;\\n        \\n        while(curr != null ){\\n            sum += curr.val;\\n            \\n            // if hashmap contains the sum then it means that the nodes in between the last same sum value and current values may have cancelled each other thus the sum is same again and we need to remove those nodes.\\n            if(hm.containsKey(sum)){\\n                int currSum = sum;\\n                ListNode toRemove = hm.get(sum).next;\\n                while(toRemove != curr){\\n                    \\n                    currSum += toRemove.val;\\n                    hm.remove(currSum);\\n                    toRemove = toRemove.next;\\n                }\\n                hm.get(sum).next = curr.next;\\n            }else{ \\n                // if the hashmap don\\'t contains the same sum value that means the nodes.val do not cancel each other\\n                hm.put(sum , curr);\\n            }\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/1b861087-57c2-4514-b6ac-10f7efc91aa8_1650739122.338251.jpeg)\\n\\n<H3> If the solutions helps please upvote :)",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return null;\\n        HashMap < Integer , ListNode> hm = new HashMap<>();\\n        //we make a hashmap so that further we can manipulate sum and nodes.\\n        ListNode dummy = new ListNode(0), curr = head;\\n        hm.put(0 , dummy); //initiating dummy node with 0 not -1 because -1 will hinder the sum value and 0 do not\\n        dummy.next = head;\\n        int sum = 0;\\n        \\n        while(curr != null ){\\n            sum += curr.val;\\n            \\n            // if hashmap contains the sum then it means that the nodes in between the last same sum value and current values may have cancelled each other thus the sum is same again and we need to remove those nodes.\\n            if(hm.containsKey(sum)){\\n                int currSum = sum;\\n                ListNode toRemove = hm.get(sum).next;\\n                while(toRemove != curr){\\n                    \\n                    currSum += toRemove.val;\\n                    hm.remove(currSum);\\n                    toRemove = toRemove.next;\\n                }\\n                hm.get(sum).next = curr.next;\\n            }else{ \\n                // if the hashmap don\\'t contains the same sum value that means the nodes.val do not cancel each other\\n                hm.put(sum , curr);\\n            }\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665583,
                "title": "c-o-n-using-hashing-with-help-of-unordered-map",
                "content": "**// Upvote if you like it !\\n// Time Complexity   : O(n)\\n// Space Complexity : O(n)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n      dummy->next = head;\\n      unordered_map <int, ListNode*> m;\\n      m[0] = dummy;\\n      int sum = 0;\\n      while(head){\\n         sum += head->val;\\n         m[sum] = head;\\n         head = head->next;\\n      }\\n      head = dummy;\\n      sum = 0;\\n      while(head){\\n         sum += head->val;\\n         ListNode* temp = m[sum];\\n         if(temp != head){\\n            head->next = temp->next;\\n         }\\n         head = head->next;\\n      }\\n      return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n      dummy->next = head;\\n      unordered_map <int, ListNode*> m;\\n      m[0] = dummy;\\n      int sum = 0;\\n      while(head){\\n         sum += head->val;\\n         m[sum] = head;\\n         head = head->next;\\n      }\\n      head = dummy;\\n      sum = 0;\\n      while(head){\\n         sum += head->val;\\n         ListNode* temp = m[sum];\\n         if(temp != head){\\n            head->next = temp->next;\\n         }\\n         head = head->next;\\n      }\\n      return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921144,
                "title": "most-concise-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        int sum = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            sum += cur.val;\\n            cur = cur.next;\\n            if (sum == 0) return removeZeroSumSublists(cur);\\n        }\\n        return new ListNode(head.val, removeZeroSumSublists(head.next));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        int sum = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            sum += cur.val;\\n            cur = cur.next;\\n            if (sum == 0) return removeZeroSumSublists(cur);\\n        }\\n        return new ListNode(head.val, removeZeroSumSublists(head.next));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740995,
                "title": "python-explanation",
                "content": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # Create a dummy node to init the search\\n        pointer = ListNode(float(\"inf\"))\\n        # Point the dummy node to the head of the list\\n        pointer.next = head\\n        # create a reference to the given list and point the head to the dummy node\\n        curr = head\\n        head = pointer\\n\\n        # Iterate over the node\\n        while head:\\n            # Store the current sum\\n            current_sum = 0\\n\\n            # For each node compute the consecutive sum\\n            while curr:\\n                # Add the value of the node to the current sum\\n                current_sum += curr.val\\n\\n                # If the consecutive sum is 0\\n                # Delete the reference to the\\n                # nodes that sum up to 0\\n                if current_sum == 0:\\n                    head.next = curr.next\\n\\n                # Move to the next node\\n                curr = curr.next\\n\\n            # Move the head\\n            head = head.next\\n\\n            # Update the current node\\n            # to be the next element \\n            # of the head. This resets\\n            # the \"state\" as in the start\\n            if head:\\n                curr = head.next\\n\\n        # Return the next element of the \\n        # dummy pointer, which is going\\n        # to be the updated head of the list\\n        return pointer.next            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # Create a dummy node to init the search\\n        pointer = ListNode(float(\"inf\"))\\n        # Point the dummy node to the head of the list\\n        pointer.next = head\\n        # create a reference to the given list and point the head to the dummy node\\n        curr = head\\n        head = pointer\\n\\n        # Iterate over the node\\n        while head:\\n            # Store the current sum\\n            current_sum = 0\\n\\n            # For each node compute the consecutive sum\\n            while curr:\\n                # Add the value of the node to the current sum\\n                current_sum += curr.val\\n\\n                # If the consecutive sum is 0\\n                # Delete the reference to the\\n                # nodes that sum up to 0\\n                if current_sum == 0:\\n                    head.next = curr.next\\n\\n                # Move to the next node\\n                curr = curr.next\\n\\n            # Move the head\\n            head = head.next\\n\\n            # Update the current node\\n            # to be the next element \\n            # of the head. This resets\\n            # the \"state\" as in the start\\n            if head:\\n                curr = head.next\\n\\n        # Return the next element of the \\n        # dummy pointer, which is going\\n        # to be the updated head of the list\\n        return pointer.next            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 675308,
                "title": "python3-simple-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        temp = ListNode(0)\\n        temp.next = head\\n        result = temp\\n        while temp:\\n            s+=head.val\\n            t = s\\n            temp1 = temp.next\\n            flag = 0\\n            next = -1\\n            while temp1:\\n                t+=temp1.val\\n                if t==s:\\n                    next = temp1.next\\n                temp1 = temp1.next\\n            if next!=-1:\\n                temp.next = next\\n            temp = temp.next\\n        return result.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        temp = ListNode(0)\\n        temp.next = head\\n        result = temp\\n        while temp:\\n            s+=head.val\\n            t = s\\n            temp1 = temp.next\\n            flag = 0\\n            next = -1\\n            while temp1:\\n                t+=temp1.val\\n                if t==s:\\n                    next = temp1.next\\n                temp1 = temp1.next\\n            if next!=-1:\\n                temp.next = next\\n            temp = temp.next\\n        return result.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506679,
                "title": "python-40ms-13-1-mb",
                "content": "\\nclass Solution:\\n\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(None)\\n        prev = dummy\\n        dummy.next = head\\n        hm = {}\\n        hm[0] = dummy\\n        count = 0\\n        while head:\\n            count += head.val\\n            if count in hm:\\n                #remove\\n                remove = hm[count].next\\n                dsum = count\\n                while remove!=head:\\n                    dsum += remove.val\\n                    del hm[dsum]\\n                    remove = remove.next\\n                #link\\n                hm[count].next = head.next\\n            else:\\n                hm[count] = head\\n            head = head.next\\n        return dummy.next",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(None)\\n        prev = dummy\\n        dummy.next = head\\n        hm = {}",
                "codeTag": "Java"
            },
            {
                "id": 366323,
                "title": "easy-and-short-solution-c",
                "content": "1. Calculate prefix sum and insert it into hashmap. If prefix sum is zero, we have remove nodes from begining to current the node.\\n2. If the prefix sum is already exist is hashmap, then remove all the intermediate nodes.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> hmap;\\n        int sum=0, flag=0;\\n        ListNode* new_head=head;\\n        ListNode* temp=head;\\n        while(temp){\\n            sum+=temp->val;\\n            if(sum==0){ new_head=temp->next; flag=1;}\\n            else if(hmap.find(sum)==hmap.end()) hmap[sum]=temp;\\n            else {hmap[sum]->next=temp->next; flag=1;}\\n            temp=temp->next;\\n        }\\n        if(flag) return removeZeroSumSublists(new_head);\\n        return new_head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> hmap;\\n        int sum=0, flag=0;\\n        ListNode* new_head=head;\\n        ListNode* temp=head;\\n        while(temp){\\n            sum+=temp->val;\\n            if(sum==0){ new_head=temp->next; flag=1;}\\n            else if(hmap.find(sum)==hmap.end()) hmap[sum]=temp;\\n            else {hmap[sum]->next=temp->next; flag=1;}\\n            temp=temp->next;\\n        }\\n        if(flag) return removeZeroSumSublists(new_head);\\n        return new_head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366320,
                "title": "java-hashmap-sol",
                "content": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        // Remove starting zeroes.\\n        while (head != null && head.val == 0) {\\n            head = head.next;\\n        }\\n        if (head == null) {\\n            return null;\\n        }\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode temp = head;\\n        map.put(0, null);\\n        map.put(head.val, head);\\n        int val = head.val;\\n        temp = temp.next;\\n\\n        while (temp != null) {\\n            val += temp.val;\\n            if (val == 0) {\\n                head = temp.next;\\n            } else if (map.containsKey(val)) {\\n                ListNode node = map.get(val);\\n                node.next = temp.next;\\n            } else {\\n                map.put(val, temp);\\n\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n```\\n**Update**:\\nAs discussed over [this](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/366319/OJ-is-Wrong.) thread:\\nThis solution is incorrect for this case [1,3,2,-3,-2,5,5,-5,1], it returns [1,5,5,-5,1] whereas it should be [1,5,1]\\nThe skipped values need to be cleaned in the map.\\n",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        // Remove starting zeroes.\\n        while (head != null && head.val == 0) {\\n            head = head.next;\\n        }\\n        if (head == null) {\\n            return null;\\n        }\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode temp = head;\\n        map.put(0, null);\\n        map.put(head.val, head);\\n        int val = head.val;\\n        temp = temp.next;\\n\\n        while (temp != null) {\\n            val += temp.val;\\n            if (val == 0) {\\n                head = temp.next;\\n            } else if (map.containsKey(val)) {\\n                ListNode node = map.get(val);\\n                node.next = temp.next;\\n            } else {\\n                map.put(val, temp);\\n\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400899,
                "title": "hash-map-java-with-comments",
                "content": "\\n\\n\\n\\n        ListNode dummy = new ListNode(0);\\n        ListNode cur = dummy;\\n        cur.next = head;\\n        int prefix =0;\\n        HashMap<Integer,ListNode> map = new HashMap<>();\\n        while(cur != null){\\n            prefix += cur.val;          //we are storing the prefix sum\\n            if(map.containsKey(prefix)){            //if we find a sum that is equal to the sum previously in  the map, we can say that some squence of numbers exists which reduced the sum to the zero in the past.\\n                cur = map.get(prefix).next;          //we\\'ll get point from where the sum got reduced, that it map.get(prefix), and start searching for the number that are responsible for the sum to reduced.\\n                int imposters = prefix + cur.val;     //this gives us the key values for the nodes which contains the zero sum, utill the last point where we found the same prefix.\\n                while(imposters != prefix){   //we are checking untill the point of same prefix because, we need the next pointer of that node to be connect with the node before zero sum\\n                    map.remove(imposters);\\n                    cur = cur.next;\\n                    imposters += cur.val;    \\n                }\\n                map.get(prefix).next = cur.next;        // this line, explaination above comment\\n            }\\n            else{\\n                map.put(prefix,cur);\\n            }\\n           cur = cur.next; \\n        }\\n        return dummy.next;\\n",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n        ListNode dummy = new ListNode(0);\\n        ListNode cur = dummy;\\n        cur.next = head;\\n        int prefix =0;\\n        HashMap<Integer,ListNode> map = new HashMap<>();\\n        while(cur != null){\\n            prefix += cur.val;          //we are storing the prefix sum\\n            if(map.containsKey(prefix)){            //if we find a sum that is equal to the sum previously in  the map, we can say that some squence of numbers exists which reduced the sum to the zero in the past.\\n                cur = map.get(prefix).next;          //we\\'ll get point from where the sum got reduced, that it map.get(prefix), and start searching for the number that are responsible for the sum to reduced.\\n                int imposters = prefix + cur.val;     //this gives us the key values for the nodes which contains the zero sum, utill the last point where we found the same prefix.\\n                while(imposters != prefix){   //we are checking untill the point of same prefix because, we need the next pointer of that node to be connect with the node before zero sum\\n                    map.remove(imposters);\\n                    cur = cur.next;\\n                    imposters += cur.val;    \\n                }\\n                map.get(prefix).next = cur.next;        // this line, explaination above comment\\n            }\\n            else{\\n                map.put(prefix,cur);\\n            }\\n           cur = cur.next; \\n        }\\n        return dummy.next;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1262338,
                "title": "simple-c-hashmap-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> m;\\n        ListNode* ptr=head;int prep=0;\\n        ListNode *dummy=new ListNode (0,head);\\n        m[0]=dummy;\\n        while(ptr!=NULL)\\n        {prep=prep+ptr->val;\\n            if(m.find(prep)!=m.end())\\n            { auto it=m[prep]->next;\\n             int SUM=prep;\\n             while(it!=ptr)\\n             {SUM+=it->val;\\n                 m.erase(SUM);\\n              it=it->next;\\n             }\\n                m[prep]->next=ptr->next;    \\n            }\\n            else\\n              m[prep]=ptr;\\n            ptr=ptr->next;   \\n        }\\n        return dummy->next;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> m;\\n        ListNode* ptr=head;int prep=0;\\n        ListNode *dummy=new ListNode (0,head);\\n        m[0]=dummy;\\n        while(ptr!=NULL)\\n        {prep=prep+ptr->val;\\n            if(m.find(prep)!=m.end())\\n            { auto it=m[prep]->next;\\n             int SUM=prep;\\n             while(it!=ptr)\\n             {SUM+=it->val;\\n                 m.erase(SUM);\\n              it=it->next;\\n             }\\n                m[prep]->next=ptr->next;    \\n            }\\n            else\\n              m[prep]=ptr;\\n            ptr=ptr->next;   \\n        }\\n        return dummy->next;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132693,
                "title": "1ms-java-solution-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hm = new HashMap<>();\\n        ListNode dummy  = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        hm.put(0,dummy);\\n        while(head != null) {\\n            sum += head.val;\\n            if(hm.containsKey(sum)) {\\n                ListNode temp = hm.get(sum).next; \\n                int tempSum = sum;\\n                while(temp != head) {\\n                    tempSum += temp.val;\\n                    hm.remove(tempSum);\\n                    temp = temp.next;\\n                }\\n                hm.get(sum).next = head.next;\\n            }else {\\n                hm.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hm = new HashMap<>();\\n        ListNode dummy  = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        hm.put(0,dummy);\\n        while(head != null) {\\n            sum += head.val;\\n            if(hm.containsKey(sum)) {\\n                ListNode temp = hm.get(sum).next; \\n                int tempSum = sum;\\n                while(temp != head) {\\n                    tempSum += temp.val;\\n                    hm.remove(tempSum);\\n                    temp = temp.next;\\n                }\\n                hm.get(sum).next = head.next;\\n            }else {\\n                hm.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707303,
                "title": "cpp-simple-solution",
                "content": "// Runtime: 16 ms, faster than 79.26% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n// Memory Usage: 11.6 MB, less than 43.10% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List\\n// 1,9,-9,-1,5 --> 1,10,1,0,5\\n//if we dont save a value for zero at he begining we will save the first encounter of zero at 4th pos and the logic wont be able to erase previous values and the dummy\\'s next will have 5 as next and that will be our head\\n//we can encounter zero 1. when all value from first upto ith node is zero then head will be i+1 as explained before\\n//2. when node values will be zero 0->0->..->0 then u[0] will have lastest address of zero and we dont count node with zero so its next is our head \\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> u;\\n        ListNode* ptr,*temp;\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ptr = dummy;\\n        int sum = 0;\\n        while(ptr){\\n            sum += ptr->val;\\n            u[sum] = ptr;\\n            ptr = ptr->next;\\n        }\\n        sum = 0;\\n        ptr = dummy;\\n        while(ptr){\\n            sum += ptr->val;\\n             temp = ptr->next;\\n            while(u[sum] != NULL && temp != u[sum]->next){\\n                temp = temp->next;\\n            }\\n            ptr->next = temp;\\n            ptr = temp;\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> u;\\n        ListNode* ptr,*temp;\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ptr = dummy;\\n        int sum = 0;\\n        while(ptr){\\n            sum += ptr->val;\\n            u[sum] = ptr;\\n            ptr = ptr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 610648,
                "title": "c-concise-using-vector",
                "content": "\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* curr=head;\\n        vector<int> A;\\n        \\n        while(curr){\\n            A.push_back(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        int j, sum=0;\\n        for (auto i=0;i<A.size();i++){\\n            sum=0;\\n            for(j=i;j<A.size();j++){\\n                sum += A[j];\\n                if(sum==0)\\n                    break;\\n            }            \\n            if(sum==0) {\\n                A.erase(A.begin()+i,A.begin()+j+1);\\n                i--;\\n            }\\n        }\\n        \\n        if(A.size()==0)\\n            return NULL;\\n        else\\n        {\\n            ListNode* root = new ListNode(A[0]);\\n            curr = root;\\n            for (auto i=1;i<A.size();i++)\\n            {\\n                ListNode* temp = new ListNode;\\n                temp->val=A[i];\\n                root->next=temp;\\n                root=root->next;\\n            }\\n\\n            return curr;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* curr=head;\\n        vector<int> A;\\n        \\n        while(curr){\\n            A.push_back(curr->val);\\n            curr = curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 461539,
                "title": "c-12s-82-85-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int, ListNode*> m;\\n        ListNode* ptr = head, *p;\\n        int consec_sum = 0, sum;\\n        \\n        p = new ListNode(0);\\n        p->next = head;\\n        head = p;\\n        m[0] = head;\\n        \\n        while (ptr) {\\n            \\n            consec_sum += ptr->val;\\n            \\n            if(m.find(consec_sum) != m.end()) {\\n            \\n                ListNode* b = m[consec_sum];\\n                \\n                p = b->next;\\n                \\n                b->next = ptr->next;\\n                \\n                sum = consec_sum;\\n                while (p!=ptr) {\\n                    sum += p->val;\\n                    m.erase(sum);\\n                    p = p->next;\\n                }\\n            } else\\n                m[consec_sum] = ptr;\\n            \\n            ptr = ptr->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```\\nThis code is the same as 8ms code that I saw, but still runs in 12ms. (worse, it also took 16ms in some submissions)\\nIf anybody has an idea as to why it is happening, please let me know in the comments.\\n\\nThe 8ms solution is as follows:\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummyHead = new ListNode(0);\\n        \\n        dummyHead->next = head;\\n        \\n        map<int, ListNode*> mapping;\\n        \\n        mapping[0] = dummyHead;\\n        \\n        ListNode* curr = head;\\n        \\n        int cumsum = 0;\\n        \\n        while(curr != NULL){\\n            \\n            cumsum += curr->val;\\n            \\n            if(mapping.find(cumsum) != mapping.end()){\\n                ListNode* start = mapping[cumsum];\\n                ListNode* end = curr;\\n                ListNode* b = start;\\n                \\n                int aux = cumsum;\\n                while(start != end){\\n                    start = start->next;\\n                    aux += start->val;\\n                    if(start != end) mapping.erase(aux);\\n                }\\n                b->next = end->next;\\n                \\n                \\n            }\\n            else{\\n                mapping[cumsum] = curr;\\n                \\n            }\\n            \\n            curr = curr->next;\\n            \\n            \\n            \\n        }\\n        \\n        // while(dummyHead != NULL){\\n        //     cout << dummyHead->val << \" \";\\n        //     dummyHead = dummyHead ->next;\\n        // }\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int, ListNode*> m;\\n        ListNode* ptr = head, *p;\\n        int consec_sum = 0, sum;\\n        \\n        p = new ListNode(0);\\n        p->next = head;\\n        head = p;\\n        m[0] = head;\\n        \\n        while (ptr) {\\n            \\n            consec_sum += ptr->val;\\n            \\n            if(m.find(consec_sum) != m.end()) {\\n            \\n                ListNode* b = m[consec_sum];\\n                \\n                p = b->next;\\n                \\n                b->next = ptr->next;\\n                \\n                sum = consec_sum;\\n                while (p!=ptr) {\\n                    sum += p->val;\\n                    m.erase(sum);\\n                    p = p->next;\\n                }\\n            } else\\n                m[consec_sum] = ptr;\\n            \\n            ptr = ptr->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummyHead = new ListNode(0);\\n        \\n        dummyHead->next = head;\\n        \\n        map<int, ListNode*> mapping;\\n        \\n        mapping[0] = dummyHead;\\n        \\n        ListNode* curr = head;\\n        \\n        int cumsum = 0;\\n        \\n        while(curr != NULL){\\n            \\n            cumsum += curr->val;\\n            \\n            if(mapping.find(cumsum) != mapping.end()){\\n                ListNode* start = mapping[cumsum];\\n                ListNode* end = curr;\\n                ListNode* b = start;\\n                \\n                int aux = cumsum;\\n                while(start != end){\\n                    start = start->next;\\n                    aux += start->val;\\n                    if(start != end) mapping.erase(aux);\\n                }\\n                b->next = end->next;\\n                \\n                \\n            }\\n            else{\\n                mapping[cumsum] = curr;\\n                \\n            }\\n            \\n            curr = curr->next;\\n            \\n            \\n            \\n        }\\n        \\n        // while(dummyHead != NULL){\\n        //     cout << dummyHead->val << \" \";\\n        //     dummyHead = dummyHead ->next;\\n        // }\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 376823,
                "title": "java-o-n",
                "content": "One pass to find the last occurrences of different prefix sum, second pass to remove.\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            map.put(sum, node);\\n        }\\n        sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            node.next = map.get(sum).next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            map.put(sum, node);\\n        }\\n        sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            node.next = map.get(sum).next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793776,
                "title": "c-explained-simple-and-easy-recursive-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKED \\u2764\\uFE0F**\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\n        //base case\\n\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        //recursive call\\n\\n        ListNode* smallAns=removeZeroSumSublists(head->next);\\n\\n        //our part and small calculation after\\n        //recursion returns it\\'s answer\\n\\n        if(head->val==0) return smallAns;\\n        int sum=head->val;\\n        bool check=false;\\n        ListNode* temp=smallAns;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                check=true;\\n                break;\\n            }\\n            temp=temp->next;\\n        }\\n        if(check){\\n            return temp->next;\\n        }\\n        head->next=smallAns;\\n        return head;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\n        //base case\\n\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        //recursive call\\n\\n        ListNode* smallAns=removeZeroSumSublists(head->next);\\n\\n        //our part and small calculation after\\n        //recursion returns it\\'s answer\\n\\n        if(head->val==0) return smallAns;\\n        int sum=head->val;\\n        bool check=false;\\n        ListNode* temp=smallAns;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                check=true;\\n                break;\\n            }\\n            temp=temp->next;\\n        }\\n        if(check){\\n            return temp->next;\\n        }\\n        head->next=smallAns;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700075,
                "title": "java-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)return head;\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        int  running_sum=0;\\n        while(cur!=null)\\n        {\\n            running_sum += cur.val;\\n            if(running_sum==0)\\n            {\\n                if(prev == null)\\n                head = cur.next;\\n                else\\n                prev.next = cur.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            cur = cur.next;\\n        }\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)return head;\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        int  running_sum=0;\\n        while(cur!=null)\\n        {\\n            running_sum += cur.val;\\n            if(running_sum==0)\\n            {\\n                if(prev == null)\\n                head = cur.next;\\n                else\\n                prev.next = cur.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            cur = cur.next;\\n        }\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535522,
                "title": "simplest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757748,
                "title": "faster-than-100-js",
                "content": "```\\nvar removeZeroSumSublists = function(head) {\\n  const newNode = {\\n    val : 0,\\n    next: head\\n  };\\n\\n\\n  if (head !== null) {\\n    let cur = head;\\n    let sum = 0;\\n\\n    const sumNodeMap = {};\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n        sumNodeMap[sum] = cur;\\n\\n        cur = cur.next;\\n    }\\n\\n    cur = newNode;\\n    sum = 0;\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n\\n        if (sumNodeMap[sum]) {\\n            cur.next = sumNodeMap[sum].next;\\n        }\\n\\n        cur = cur.next;\\n    }\\n  }\\n\\n  return newNode.next;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n  const newNode = {\\n    val : 0,\\n    next: head\\n  };\\n\\n\\n  if (head !== null) {\\n    let cur = head;\\n    let sum = 0;\\n\\n    const sumNodeMap = {};\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n        sumNodeMap[sum] = cur;\\n\\n        cur = cur.next;\\n    }\\n\\n    cur = newNode;\\n    sum = 0;\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n\\n        if (sumNodeMap[sum]) {\\n            cur.next = sumNodeMap[sum].next;\\n        }\\n\\n        cur = cur.next;\\n    }\\n  }\\n\\n  return newNode.next;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711822,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n               \\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n               \\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336374,
                "title": "simple-c-solution-using-iterative-method",
                "content": "### O(n^2) time complexity\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // take a dummy node with val \\'0\\' and at next store head\\n        ListNode* root = new ListNode(0);\\n        root->next = head;\\n        \\n        // in for loop check for each node that the sum is zero or not\\n        for(ListNode* i = root; i!=NULL; i=i->next){\\n            int sum = 0;\\n            for(ListNode* j=i->next;j!=NULL;j=j->next){\\n                sum+=j->val;\\n                // if sum is zero \\n                if(sum==0){\\n                    i->next = j->next;\\n                }\\n            }\\n        }\\n        return root->next;\\n        \\n    }\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "### O(n^2) time complexity\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // take a dummy node with val \\'0\\' and at next store head\\n        ListNode* root = new ListNode(0);\\n        root->next = head;\\n        \\n        // in for loop check for each node that the sum is zero or not\\n        for(ListNode* i = root; i!=NULL; i=i->next){\\n            int sum = 0;\\n            for(ListNode* j=i->next;j!=NULL;j=j->next){\\n                sum+=j->val;\\n                // if sum is zero \\n                if(sum==0){\\n                    i->next = j->next;\\n                }\\n            }\\n        }\\n        return root->next;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2317436,
                "title": "beats-100-other-solutions",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842399,
                "title": "c-goto-iterative-prefix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next=head;\\n\\t\\t//goto statement will lead the program here at point\\n        point:\\n        int sum = 0;\\n\\t\\t//map to store prefix sum and respective node value\\n        unordered_map<int, ListNode*> mp;\\n        mp[0]=dummy;\\n        head=dummy->next;\\n        while(head!=NULL){\\n            sum+=head->val;\\n            if(mp.find(sum)!=mp.end()){\\n                ListNode* temp = mp[sum];\\n                temp->next=head->next;\\n\\t\\t\\t\\t//everytime we delete a part of linked list we start again from the begnning\\n                goto point; \\n            }\\n            else mp[sum]=head;\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next=head;\\n\\t\\t//goto statement will lead the program here at point\\n        point:\\n        int sum = 0;\\n\\t\\t//map to store prefix sum and respective node value\\n        unordered_map<int, ListNode*> mp;\\n        mp[0]=dummy;\\n        head=dummy->next;\\n        while(head!=NULL){\\n            sum+=head->val;\\n            if(mp.find(sum)!=mp.end()){\\n                ListNode* temp = mp[sum];\\n                temp->next=head->next;\\n\\t\\t\\t\\t//everytime we delete a part of linked list we start again from the begnning\\n                goto point; \\n            }\\n            else mp[sum]=head;\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822860,
                "title": "java-recursion-easy-to-understand",
                "content": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // Base Case\\n        if(head == null) return null;\\n        // Current Case: to find zero sum consecutive nodes from HEAD\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            // found\\n            if(sum == 0) break;\\n            cur = cur.next;\\n        }\\n        // found such consecutive nodes, delete them by recursing to cur.next\\n        if(cur != null) return removeZeroSumSublists(cur.next);\\n        // such consecutive nodes don\\'t exist, move on to head.next;\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // Base Case\\n        if(head == null) return null;\\n        // Current Case: to find zero sum consecutive nodes from HEAD\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            // found\\n            if(sum == 0) break;\\n            cur = cur.next;\\n        }\\n        // found such consecutive nodes, delete them by recursing to cur.next\\n        if(cur != null) return removeZeroSumSublists(cur.next);\\n        // such consecutive nodes don\\'t exist, move on to head.next;\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1814290,
                "title": "simplest-solution-easiest-to-understand-faster-than-100",
                "content": "Logic:\\nExample:\\n[3 ,5, 7, -3,-2,-2, 6]\\n\\nWe can observe that sum of **7,-3,-2,-2** gives us 0.\\n\\nLet\\'s calculate sum of all elements\\narr = [3, 5, 7, -3, -2, -2, 6]\\ncnt = [3, **8**,15, 12,10, **8**, 14]\\nAs we can see , we have 2 times **8** sums. ***So we\\'re sure that items between 8\\'s are summing to 0.***\\n\\nBut what if we find another 8 later? The sum between the **first 8 and the last 8** will be equal to 0, so all of the items in between can be removed.\\n\\narr = [3, 5, 7, -3, -2, -2, 6, -6]\\ncnt = [3, **8**,15, 12,10, 8, 14, **8**]\\nSum of the items from **first 8 till last 8** will equal 0.\\n\\nHence, **we need to know where the last 8 (or any other number)** is located.\\n\\nIf we see 0 as the sum, we need to delete all items first 0 and last 0.\\n\\nThen, we iterate through the same nodes again, but this time we\\'ll be looking for the same sum in the hashmap, and rellocating our pointer there.\\nIf we find sum=0, we\\'ll rellocate the head to this item as well ( because everything before will give us 0)\\n\\nCheck the below code, you will understand better!\\n\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        \\n        Map<Integer,ListNode> map= new HashMap<>();\\n        \\n        ListNode fake= new ListNode(0);\\n        fake.next=head;\\n        \\n        int sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            map.put(sum,cur);\\n        }\\n        \\n        sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            cur.next= map.get(sum).next;\\n        }\\n        \\n        return fake.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        \\n        Map<Integer,ListNode> map= new HashMap<>();\\n        \\n        ListNode fake= new ListNode(0);\\n        fake.next=head;\\n        \\n        int sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            map.put(sum,cur);\\n        }\\n        \\n        sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            cur.next= map.get(sum).next;\\n        }\\n        \\n        return fake.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767467,
                "title": "c-hashmap-easy-to-understand",
                "content": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *curr = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while(curr)\\n        {\\n            prefix+=curr->val;\\n            if(m[prefix])\\n            {\\n                ListNode* temp=m[prefix];\\n                int x=prefix;\\n                while(temp->next!=curr)\\n                {\\n                    m.erase(x+temp->next->val);\\n                    x+=temp->next->val;\\n                    temp=temp->next;\\n                }\\n                m[prefix]->next=curr->next;\\n            }\\n            else\\n            {\\n                m[prefix]=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *curr = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while(curr)\\n        {\\n            prefix+=curr->val;\\n            if(m[prefix])\\n            {\\n                ListNode* temp=m[prefix];\\n                int x=prefix;\\n                while(temp->next!=curr)\\n                {\\n                    m.erase(x+temp->next->val);\\n                    x+=temp->next->val;\\n                    temp=temp->next;\\n                }\\n                m[prefix]->next=curr->next;\\n            }\\n            else\\n            {\\n                m[prefix]=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713682,
                "title": "c-o-n-time-complexity-recursive-approach",
                "content": "**Approach:**\\n1. Take a pointer **ptr** pointing towards **head**;\\n2. Take integer variable **sum** initialize it as 0.\\n3. now iterate the linked list through pointer **ptr** and on each iteration add value of node in **sum**. \\n4. check if **sum** becomes zero or not, if it become zero then make **head** next to **ptr** pointer and again make **sum** to zero and continue the interation.\\n5. After this call the **removeZeroSumSublists** function and give next node of **head** as parameter.\\n6. the return value from the recursive call will store in next node of **head**.\\n7. The recursive call will be continue until the **head** become NULL.\\n\\n![image](https://assets.leetcode.com/users/images/51b27929-eb66-4587-af72-7bc92c7094c7_1642960320.7705717.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/e64cbf23-c2a9-4fa8-9fa7-21c0053bec05_1642960349.1322982.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n          \\n        if(head==NULL){\\n            return head;\\n        }\\n        struct ListNode* ptr=head;\\n        int sum=0;\\n        while(ptr!=NULL){\\n            sum+=(ptr->val);\\n            if(sum==0){\\n                head=ptr->next;\\n                sum=0;\\n            }\\n            ptr=ptr->next;\\n        }\\n         if(head!=NULL)\\n        head->next=removeZeroSumSublists(head->next);\\n        return head;\\n    }\\n};\\n```\\n***If you like the Solution then please vote up and comment.***",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n          \\n        if(head==NULL){\\n            return head;\\n        }\\n        struct ListNode* ptr=head;\\n        int sum=0;\\n        while(ptr!=NULL){\\n            sum+=(ptr->val);\\n            if(sum==0){\\n                head=ptr->next;\\n                sum=0;\\n            }\\n            ptr=ptr->next;\\n        }\\n         if(head!=NULL)\\n        head->next=removeZeroSumSublists(head->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701585,
                "title": "c-o-n-time-commented-solution-code-with-explanation",
                "content": "Please UPVOTE if you find it usefull\\n```\\n ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // base condition\\n        if(head->next == NULL)\\n        {\\n            if(head->val == 0)\\n                return NULL;\\n            return head;\\n        }\\n        \\n        \\n        // removing zeros form the initial linklist\\n        ListNode* temp;\\n        temp = head->next;\\n        ListNode* prev = head;\\n        while(temp != NULL)\\n        {\\n            if(temp->val == 0)\\n            {\\n                prev->next = temp->next;\\n                temp = temp->next;\\n            }\\n            else\\n            {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(head->val == 0)\\n        {\\n            head = head->next;\\n        }\\n        \\n        \\n        /* using hash table to find zero sum\\n            condition 1 - if we found the same sum again \\n            contition 2 - if we find zero\\n            else we fill the map with sum and node\\n        */\\n        temp = head;\\n        int sum = 0;\\n        unordered_map<int,ListNode*> freq;\\n        stack<int> rem;\\n        \\n        while(temp != NULL)\\n        {\\n            sum += temp->val;\\n            if(sum == 0)\\n            {\\n                head = temp->next;\\n                freq.clear();\\n            }\\n            else if(freq.count(sum) > 0)\\n            {\\n                ListNode* prev = freq[sum];\\n                \\n                prev->next = temp->next;\\n                while(rem.top() != sum)\\n                {\\n                    int top = rem.top();\\n                    rem.pop();\\n                    freq.erase(top);\\n                }\\n            }\\n            else\\n            {   \\n                rem.push(sum);\\n                freq[sum] = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Please UPVOTE if you find it usefull\\n```\\n ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // base condition\\n        if(head->next == NULL)\\n        {\\n            if(head->val == 0)\\n                return NULL;\\n            return head;\\n        }\\n        \\n        \\n        // removing zeros form the initial linklist\\n        ListNode* temp;\\n        temp = head->next;\\n        ListNode* prev = head;\\n        while(temp != NULL)\\n        {\\n            if(temp->val == 0)\\n            {\\n                prev->next = temp->next;\\n                temp = temp->next;\\n            }\\n            else\\n            {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(head->val == 0)\\n        {\\n            head = head->next;\\n        }\\n        \\n        \\n        /* using hash table to find zero sum\\n            condition 1 - if we found the same sum again \\n            contition 2 - if we find zero\\n            else we fill the map with sum and node\\n        */\\n        temp = head;\\n        int sum = 0;\\n        unordered_map<int,ListNode*> freq;\\n        stack<int> rem;\\n        \\n        while(temp != NULL)\\n        {\\n            sum += temp->val;\\n            if(sum == 0)\\n            {\\n                head = temp->next;\\n                freq.clear();\\n            }\\n            else if(freq.count(sum) > 0)\\n            {\\n                ListNode* prev = freq[sum];\\n                \\n                prev->next = temp->next;\\n                while(rem.top() != sum)\\n                {\\n                    int top = rem.top();\\n                    rem.pop();\\n                    freq.erase(top);\\n                }\\n            }\\n            else\\n            {   \\n                rem.push(sum);\\n                freq[sum] = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1648921,
                "title": "c-o-n-using-stack-map",
                "content": "Using Stack and Map in O(N)\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        stack<ListNode*> st;\\n        int sum = 0;\\n        ListNode* ans = NULL;\\n        unordered_map<int, int> m; //storing possible sum\\n        m[0] = 1;\\n        while(temp){\\n            if(temp->val==0){ //ignorimg 0 values\\n                temp = temp->next;\\n                continue;\\n            }\\n            if(!st.empty()){\\n                int tempsum = sum+temp->val;\\n                if(m[tempsum]==1){ //if already found in map\\n                    while(sum!=tempsum && !st.empty()){ //keep popping and checking\\n                        m[sum] = 0; //removing not useful value\\n                        sum-=(st.top()->val);\\n                        st.pop();\\n                    }\\n                }else{\\n                    sum = tempsum; //update sum\\n                    m[sum] = 1; //enter into map\\n                    st.top()->next = temp; \\n                    st.push(temp); //store in stack\\n                }\\n            }else{\\n                st.push(temp); //store it\\n                sum+=temp->val; //update sum\\n                m[sum] = 1; //add in map\\n                ans = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        if(!st.empty()) st.top()->next = NULL; \\n        else ans = NULL;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        stack<ListNode*> st;\\n        int sum = 0;\\n        ListNode* ans = NULL;\\n        unordered_map<int, int> m; //storing possible sum\\n        m[0] = 1;\\n        while(temp){\\n            if(temp->val==0){ //ignorimg 0 values\\n                temp = temp->next;\\n                continue;\\n            }\\n            if(!st.empty()){\\n                int tempsum = sum+temp->val;\\n                if(m[tempsum]==1){ //if already found in map\\n                    while(sum!=tempsum && !st.empty()){ //keep popping and checking\\n                        m[sum] = 0; //removing not useful value\\n                        sum-=(st.top()->val);\\n                        st.pop();\\n                    }\\n                }else{\\n                    sum = tempsum; //update sum\\n                    m[sum] = 1; //enter into map\\n                    st.top()->next = temp; \\n                    st.push(temp); //store in stack\\n                }\\n            }else{\\n                st.push(temp); //store it\\n                sum+=temp->val; //update sum\\n                m[sum] = 1; //add in map\\n                ans = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        if(!st.empty()) st.top()->next = NULL; \\n        else ans = NULL;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582644,
                "title": "c-using-map-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int sum=0;\\n        unordered_map<int,ListNode*> m;\\n       \\n        ListNode* root=new ListNode(0);\\n        root->next=head;\\n         m[0]=root;\\n        while(head!=NULL){\\n            sum=sum+head->val;\\n            if(m.find(sum)==m.end())\\n                m[sum]=head;\\n            else{\\n                ListNode* temp=m[sum];\\n                int csum=sum;\\n                temp=temp->next;\\n                while(temp!=head){\\n                    csum+=temp->val;\\n                    m.erase(csum);\\n                    temp=temp->next;\\n                }\\n                m[sum]->next=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return root->next;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int sum=0;\\n        unordered_map<int,ListNode*> m;\\n       \\n        ListNode* root=new ListNode(0);\\n        root->next=head;\\n         m[0]=root;\\n        while(head!=NULL){\\n            sum=sum+head->val;\\n            if(m.find(sum)==m.end())\\n                m[sum]=head;\\n            else{\\n                ListNode* temp=m[sum];\\n                int csum=sum;\\n                temp=temp->next;\\n                while(temp!=head){\\n                    csum+=temp->val;\\n                    m.erase(csum);\\n                    temp=temp->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1430485,
                "title": "java-straight-forward-traverse-2ms-78",
                "content": "traverse the whole list. From each node to detect if exists 0 sum over there.If yes,skip to the next node of \"0 sum\" nodes.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode pre = head1; \\n        while(head!=null){\\n            ListNode node = SkipZeroSum(head);\\n            if(node!= head){\\n                pre.next = node;\\n                head = node;\\n            }else{\\n                pre = head;\\n                head = head.next;\\n            }\\n        }\\n        return head1.next;\\n    }\\n    \\n    public ListNode SkipZeroSum(ListNode node){\\n        int sum = 0;\\n        ListNode cur = node;\\n        while(cur != null){\\n            sum += cur.val;\\n            if(sum == 0){\\n                return cur.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode pre = head1; \\n        while(head!=null){\\n            ListNode node = SkipZeroSum(head);\\n            if(node!= head){\\n                pre.next = node;\\n                head = node;\\n            }else{\\n                pre = head;\\n                head = head.next;\\n            }\\n        }\\n        return head1.next;\\n    }\\n    \\n    public ListNode SkipZeroSum(ListNode node){\\n        int sum = 0;\\n        ListNode cur = node;\\n        while(cur != null){\\n            sum += cur.val;\\n            if(sum == 0){\\n                return cur.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430041,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* t=new ListNode(0);\\n        t->next=head;\\n        unordered_map<int,ListNode*> mp;\\n        head=t;\\n        int sum=0;\\n        while(t!=NULL){\\n            sum+=t->val;\\n            \\n            if(mp.count(sum)){\\n                ListNode* it=mp[sum];\\n                int ss=sum;\\n                while(it->next!=t){\\n                    ss+=it->next->val;\\n                    mp.erase(ss);\\n                    it->next=it->next->next;\\n                }\\n                it->next=it->next->next;\\n                t=it->next;\\n            }\\n            else\\n            {\\n                mp[sum]=t;\\n                t=t->next;\\n            }\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* t=new ListNode(0);\\n        t->next=head;\\n        unordered_map<int,ListNode*> mp;\\n        head=t;\\n        int sum=0;\\n        while(t!=NULL){\\n            sum+=t->val;\\n            \\n            if(mp.count(sum)){\\n                ListNode* it=mp[sum];\\n                int ss=sum;\\n                while(it->next!=t){\\n                    ss+=it->next->val;\\n                    mp.erase(ss);\\n                    it->next=it->next->next;\\n                }\\n                it->next=it->next->next;\\n                t=it->next;\\n            }\\n            else\\n            {\\n                mp[sum]=t;\\n                t=t->next;\\n            }\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346035,
                "title": "difference-between-o-n-o-n-solution",
                "content": "-> O(n\\xB2) Brute-Force Solution :-\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode();\\n        ptr -> next = head;\\n        for (ListNode *i = ptr; i != NULL; i = i -> next) {\\n            int sum = 0;\\n            for (ListNode *j = i -> next; j != NULL; j = j -> next) {\\n                sum += j -> val;\\n                if (sum == 0) {\\n                    if(j -> next != NULL)\\n                        i -> next = j -> next;\\n                    else {\\n                        i -> next = NULL; \\n                        break; \\n                    }\\n                }\\n            }\\n        }        \\n        return ptr -> next;\\n    }\\n};\\n```\\n\\n\\n-> O(n) Solution using HashMap :-\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode(0);\\n        ptr -> next = head;\\n        unordered_map<int, ListNode*> map;\\n        map[0] = ptr;\\n        int totalSum = 0;\\n        while (head != NULL) {\\n            totalSum += head -> val;\\n            if (map.find(totalSum) != map.end()) {\\n                ListNode *pre = map[totalSum];\\n                ListNode *cur = pre;\\n                int temp = totalSum;\\n                while (pre != head) {\\n                    pre = pre -> next;\\n                    temp += pre -> val;\\n                    if (pre != head)\\n                        map.erase(temp);\\n                }\\n                cur -> next = head -> next;\\n            }\\n            else \\n                map[totalSum] = head;\\n            head = head -> next;\\n        }\\n        return ptr -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode();\\n        ptr -> next = head;\\n        for (ListNode *i = ptr; i != NULL; i = i -> next) {\\n            int sum = 0;\\n            for (ListNode *j = i -> next; j != NULL; j = j -> next) {\\n                sum += j -> val;\\n                if (sum == 0) {\\n                    if(j -> next != NULL)\\n                        i -> next = j -> next;\\n                    else {\\n                        i -> next = NULL; \\n                        break; \\n                    }\\n                }\\n            }\\n        }        \\n        return ptr -> next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode(0);\\n        ptr -> next = head;\\n        unordered_map<int, ListNode*> map;\\n        map[0] = ptr;\\n        int totalSum = 0;\\n        while (head != NULL) {\\n            totalSum += head -> val;\\n            if (map.find(totalSum) != map.end()) {\\n                ListNode *pre = map[totalSum];\\n                ListNode *cur = pre;\\n                int temp = totalSum;\\n                while (pre != head) {\\n                    pre = pre -> next;\\n                    temp += pre -> val;\\n                    if (pre != head)\\n                        map.erase(temp);\\n                }\\n                cur -> next = head -> next;\\n            }\\n            else \\n                map[totalSum] = head;\\n            head = head -> next;\\n        }\\n        return ptr -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224374,
                "title": "java-one-pass-solution-with-hashmap",
                "content": "We maintain a hashmap to store all the nodes that have the same cummulative sum. The cummulative sum is the key, and the list of all nodes that has this cummulative sum is the value.\\nWe travserse the linked list. For each node, we iterate through all the previous nodes that have the current cummulative sum and remove all nodes between. Then we update the list of nodes that has the same cummulative sum and put the list into map.\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, List<ListNode>> map = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        List<ListNode> first = new ArrayList<>(0);\\n        first.add(dummy);\\n        map.put(sum, first);\\n        ListNode curr = head;\\n        while (curr != null){\\n            sum += curr.val;\\n            List<ListNode> prevs = map.getOrDefault(sum, new ArrayList<>());\\n            for(ListNode prev : prevs) {\\n                prev.next = curr.next;    \\n            }\\n            prevs.add(curr);\\n            map.put(sum, prevs);\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, List<ListNode>> map = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        List<ListNode> first = new ArrayList<>(0);\\n        first.add(dummy);\\n        map.put(sum, first);\\n        ListNode curr = head;\\n        while (curr != null){\\n            sum += curr.val;\\n            List<ListNode> prevs = map.getOrDefault(sum, new ArrayList<>());\\n            for(ListNode prev : prevs) {\\n                prev.next = curr.next;    \\n            }\\n            prevs.add(curr);\\n            map.put(sum, prevs);\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1078468,
                "title": "java-2ms",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode ans = new ListNode(0);;\\n        ListNode prev = ans;\\n        prev.next = head;\\n        \\n        outer:\\n        while(head !=  null){\\n            ListNode curr = head;\\n            int sum = 0;\\n            while(curr != null){\\n                sum += curr.val;\\n                curr = curr.next;\\n                if(sum == 0)\\n                {\\n                    prev.next = curr;\\n                    head = curr;\\n                    continue outer;\\n                }\\n            }\\n            \\n            prev = head;\\n            head = head.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode ans = new ListNode(0);;\\n        ListNode prev = ans;\\n        prev.next = head;\\n        \\n        outer:\\n        while(head !=  null){\\n            ListNode curr = head;\\n            int sum = 0;\\n            while(curr != null){\\n                sum += curr.val;\\n                curr = curr.next;\\n                if(sum == 0)\\n                {\\n                    prev.next = curr;\\n                    head = curr;\\n                    continue outer;\\n                }\\n            }\\n            \\n            prev = head;\\n            head = head.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037914,
                "title": "c-100-faster-fully-commented-easy-to-understand",
                "content": "****ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        \\n        ListNode* dummy=new ListNode(0);//considering a dummy variable poitning to head\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        \\n        while(head)\\n        {\\n            ListNode* curr=head;\\n            int sum=0;int flag=0;\\n            \\n            while(curr)\\n            {\\n                sum+=curr->val;\\n                curr=curr->next;\\n                \\n                if(sum==0)//checking if any consecutive sum is equal to zero \\n                {\\n                    flag=1;break;//if yes then breakout from the loop\\n                }\\n            }\\n            if(flag)\\n            {\\n                prev->next=curr;head=curr;continue;//chaning the value of head after elimination\\n            }\\n            prev=head;\\n            head=head->next;//traversing the loop if no loop is found\\n        }\\n        return dummy->next;//returning the new list\\n    }****",
                "solutionTags": [],
                "code": "****ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        \\n        ListNode* dummy=new ListNode(0);//considering a dummy variable poitning to head\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        \\n        while(head)\\n        {\\n            ListNode* curr=head;\\n            int sum=0;int flag=0;\\n            \\n            while(curr)\\n            {\\n                sum+=curr->val;\\n                curr=curr->next;\\n                \\n                if(sum==0)//checking if any consecutive sum is equal to zero \\n                {\\n                    flag=1;break;//if yes then breakout from the loop\\n                }\\n            }\\n            if(flag)\\n            {\\n                prev->next=curr;head=curr;continue;//chaning the value of head after elimination\\n            }\\n            prev=head;\\n            head=head->next;//traversing the loop if no loop is found\\n        }\\n        return dummy->next;//returning the new list\\n    }****",
                "codeTag": "Unknown"
            },
            {
                "id": 1007175,
                "title": "simple-c-o-n",
                "content": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tListNode *dummy=new ListNode(0);\\n\\tdummy->next=head;\\n\\tListNode *curr=dummy;\\n\\tunordered_map<int,ListNode*> hashmap;\\n\\tint sum=0;\\n\\twhile(curr!=NULL)\\n\\t{\\n\\t\\tsum=sum+curr->val;\\n\\t\\tif(hashmap.find(sum)!=hashmap.end())\\n\\t\\t{\\n\\t\\t\\tListNode *temp=hashmap[sum]->next;\\n\\t\\t\\tint t=sum;\\n\\t\\t\\twhile(temp!=curr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tt=t+temp->val;\\n\\t\\t\\t\\thashmap.erase(t);\\n\\t\\t\\t\\ttemp=temp->next;\\n\\t\\t\\t}\\n\\t\\t\\thashmap[sum]->next=curr->next;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\thashmap[sum]=curr;\\n\\t\\tcurr=curr->next;\\n\\t}\\n\\treturn dummy->next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tListNode *dummy=new ListNode(0);\\n\\tdummy->next=head;\\n\\tListNode *curr=dummy;\\n\\tunordered_map<int,ListNode*> hashmap;\\n\\tint sum=0;\\n\\twhile(curr!=NULL)\\n\\t{\\n\\t\\tsum=sum+curr->val;\\n\\t\\tif(hashmap.find(sum)!=hashmap.end())\\n\\t\\t{\\n\\t\\t\\tListNode *temp=hashmap[sum]->next;\\n\\t\\t\\tint t=sum;\\n\\t\\t\\twhile(temp!=curr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tt=t+temp->val;\\n\\t\\t\\t\\thashmap.erase(t);\\n\\t\\t\\t\\ttemp=temp->next;\\n\\t\\t\\t}\\n\\t\\t\\thashmap[sum]->next=curr->next;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\thashmap[sum]=curr;\\n\\t\\tcurr=curr->next;\\n\\t}\\n\\treturn dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998539,
                "title": "32ms-c-solution-rac101ran-rachit-ranjan",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*node=head;\\n        vector<int> a;\\n        while(node!=nullptr) {\\n           a.push_back(node->val);\\n           node=node->next; \\n        }\\n        for(int i=0; i<a.size(); i++) {\\n            int s=0;\\n            for(int j=i; j<a.size(); j++) {\\n                 s+=a[j];\\n                 if(s==0) {\\n                    a.erase(a.begin()+i,a.begin()+j+1);\\n                    i=-1; \\n                    break; \\n                 }\\n            }\\n        }\\n        node=nullptr;\\n        for(int i=a.size()-1; i>=0; i--) {\\n             node=insert(node,a[i]);\\n        }\\n        return node;\\n    }\\n    ListNode* insert(ListNode* head,int x) {\\n         ListNode*newnode=new ListNode();\\n         newnode->val=x;\\n         newnode->next=head;\\n         head=newnode;\\n         return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*node=head;\\n        vector<int> a;\\n        while(node!=nullptr) {\\n           a.push_back(node->val);\\n           node=node->next; \\n        }\\n        for(int i=0; i<a.size(); i++) {\\n            int s=0;\\n            for(int j=i; j<a.size(); j++) {\\n                 s+=a[j];\\n                 if(s==0) {\\n                    a.erase(a.begin()+i,a.begin()+j+1);\\n                    i=-1; \\n                    break; \\n                 }\\n            }\\n        }\\n        node=nullptr;\\n        for(int i=a.size()-1; i>=0; i--) {\\n             node=insert(node,a[i]);\\n        }\\n        return node;\\n    }\\n    ListNode* insert(ListNode* head,int x) {\\n         ListNode*newnode=new ListNode();\\n         newnode->val=x;\\n         newnode->next=head;\\n         head=newnode;\\n         return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796112,
                "title": "c-prefixsum-solution-without-hashmap",
                "content": "```c\\n#define MAX_NODES 1000\\n\\n// Using prefix sum\\nstruct ListNode *\\nremoveZeroSumSublists(struct ListNode *head)\\n{\\n    struct node {\\n        struct ListNode *curr;\\n        int sum;\\n    };\\n    struct ListNode dummy = {\\n        .val  = 0,\\n        .next = head,\\n    };\\n    struct node prefixSum[MAX_NODES + 1] = {{0}};\\n    int sum                              = 0;\\n    int size                             = 0;\\n    struct ListNode *curr                = &dummy;\\n    while (curr) {\\n        sum                 += curr->val;\\n        prefixSum[size].sum  = sum;\\n        prefixSum[size].curr = curr;\\n        size++;\\n        curr = curr->next;\\n    }\\n    for (int i = 0; i < size; i++) {\\n        for (int j = size - 1; j > i; j--) {\\n            if (prefixSum[i].sum == prefixSum[j].sum) {\\n                prefixSum[i].curr->next = prefixSum[j].curr->next;\\n                i                       = j;\\n                break;\\n            }\\n        }\\n    }\\n    return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\n#define MAX_NODES 1000\\n\\n// Using prefix sum\\nstruct ListNode *\\nremoveZeroSumSublists(struct ListNode *head)\\n{\\n    struct node {\\n        struct ListNode *curr;\\n        int sum;\\n    };\\n    struct ListNode dummy = {\\n        .val  = 0,\\n        .next = head,\\n    };\\n    struct node prefixSum[MAX_NODES + 1] = {{0}};\\n    int sum                              = 0;\\n    int size                             = 0;\\n    struct ListNode *curr                = &dummy;\\n    while (curr) {\\n        sum                 += curr->val;\\n        prefixSum[size].sum  = sum;\\n        prefixSum[size].curr = curr;\\n        size++;\\n        curr = curr->next;\\n    }\\n    for (int i = 0; i < size; i++) {\\n        for (int j = size - 1; j > i; j--) {\\n            if (prefixSum[i].sum == prefixSum[j].sum) {\\n                prefixSum[i].curr->next = prefixSum[j].curr->next;\\n                i                       = j;\\n                break;\\n            }\\n        }\\n    }\\n    return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743470,
                "title": "java-hashmap-storing-listnode-with-recursion",
                "content": "We can use recursion to delete consecutive sequences of nodes that sum to 0 until the list size no longer decreases\\n\\n```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null)\\n            return head;\\n    \\n        return remove(head, Integer.MAX_VALUE);\\n    } \\n    \\n    public ListNode remove(ListNode head, int prevSize) {    \\n        Map<Integer, ListNode> map = new HashMap<>(); \\n        \\n        int sum = 0, size = 0;\\n        ListNode node = head;\\n        map.put(0, null);\\n        \\n        while (node != null) {            \\n            sum += node.val;\\n            \\n            //if sum == 0, remove all prev visited nodes, start head from here\\n            if (sum == 0) {\\n                head = node.next;\\n            } else if (map.containsKey(sum)) {\\n                //skip over these nodes that add up to sum \\n                ListNode prev = map.get(sum);\\n                prev.next = node.next;\\n            } else {\\n                map.put(sum, node);\\n            }            \\n            node = node.next;\\n            size++;\\n        }\\n        \\n        if (prevSize == size)\\n            return head;    \\n        \\n        return remove(head, size);\\n    }\\n```\\n\\nPlease upvote if this made sense thanks\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null)\\n            return head;\\n    \\n        return remove(head, Integer.MAX_VALUE);\\n    } \\n    \\n    public ListNode remove(ListNode head, int prevSize) {    \\n        Map<Integer, ListNode> map = new HashMap<>(); \\n        \\n        int sum = 0, size = 0;\\n        ListNode node = head;\\n        map.put(0, null);\\n        \\n        while (node != null) {            \\n            sum += node.val;\\n            \\n            //if sum == 0, remove all prev visited nodes, start head from here\\n            if (sum == 0) {\\n                head = node.next;\\n            } else if (map.containsKey(sum)) {\\n                //skip over these nodes that add up to sum \\n                ListNode prev = map.get(sum);\\n                prev.next = node.next;\\n            } else {\\n                map.put(sum, node);\\n            }            \\n            node = node.next;\\n            size++;\\n        }\\n        \\n        if (prevSize == size)\\n            return head;    \\n        \\n        return remove(head, size);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 701426,
                "title": "c-solution-with-recursive-way",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* getSum(struct ListNode* head){\\n    struct ListNode *node = head;\\n    int sum = 0;\\n    while(node){\\n        sum+=node->val;\\n        if(sum == 0) return node;\\n        node = node->next;\\n    }\\n    return node;\\n}\\n\\n\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    struct ListNode *tmpHead, *node,*prev, *ret;\\n    tmpHead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    tmpHead->val = -2000;\\n    tmpHead->next = head;\\n    while(1){\\n        prev = tmpHead;\\n        node = tmpHead->next;\\n        int f = 0;\\n        while(node){\\n            ret = getSum(node);\\n            if(ret){\\n                prev->next = ret->next;\\n                f = 1;\\n                break;\\n            } else{\\n                prev = node;\\n                node = node->next;\\n            }\\n        }\\n        if(f ==  0) break;\\n    }\\n    \\n    return tmpHead->next;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* getSum(struct ListNode* head){\\n    struct ListNode *node = head;\\n    int sum = 0;\\n    while(node){\\n        sum+=node->val;\\n        if(sum == 0) return node;\\n        node = node->next;\\n    }\\n    return node;\\n}\\n\\n\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    struct ListNode *tmpHead, *node,*prev, *ret;\\n    tmpHead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    tmpHead->val = -2000;\\n    tmpHead->next = head;\\n    while(1){\\n        prev = tmpHead;\\n        node = tmpHead->next;\\n        int f = 0;\\n        while(node){\\n            ret = getSum(node);\\n            if(ret){\\n                prev->next = ret->next;\\n                f = 1;\\n                break;\\n            } else{\\n                prev = node;\\n                node = node->next;\\n            }\\n        }\\n        if(f ==  0) break;\\n    }\\n    \\n    return tmpHead->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698068,
                "title": "java-no-hashmaps-used-easy-solution-o-n-2-beats-81-time-82-space",
                "content": "\\tpublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummyH = new ListNode(0, head);\\n        ListNode curr = dummyH;\\n        while(curr != null) {\\n            int sum = 0;\\n            while(head != null) {\\n                sum += head.val;\\n                if(sum == 0)    curr.next = head.next;\\n                head = head.next;\\n            }\\n            curr = curr.next;\\n            if(curr != null)    head = curr.next;\\n        }\\n        return dummyH.next;\\n    }",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "\\tpublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummyH = new ListNode(0, head);\\n        ListNode curr = dummyH;\\n        while(curr != null) {\\n            int sum = 0;\\n            while(head != null) {\\n                sum += head.val;\\n                if(sum == 0)    curr.next = head.next;\\n                head = head.next;\\n            }\\n            curr = curr.next;\\n            if(curr != null)    head = curr.next;\\n        }\\n        return dummyH.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 643211,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return 0;\\n        unordered_map<int,ListNode*> um;\\n        int presum=0;\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        um[0]=dummy;\\n        while(head!=NULL)\\n        {\\n            presum+=head->val;\\n            if(um.find(presum)!=um.end())\\n            {\\n                ListNode*prev=um[presum];\\n                // ListNode* start=prev;\\n                int sum=presum;\\n                while(prev!=NULL&&prev!=head)\\n                {\\n                    prev=prev->next;\\n                    sum+=prev->val;\\n                    if(prev!=head)\\n                        um.erase(sum);\\n                }\\n                um[presum]->next=head->next;\\n            }\\n            else\\n                um[presum]=head;\\n            // if(head)\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\nSuggestions are welcome.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return 0;\\n        unordered_map<int,ListNode*> um;\\n        int presum=0;\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        um[0]=dummy;\\n        while(head!=NULL)\\n        {\\n            presum+=head->val;\\n            if(um.find(presum)!=um.end())\\n            {\\n                ListNode*prev=um[presum];\\n                // ListNode* start=prev;\\n                int sum=presum;\\n                while(prev!=NULL&&prev!=head)\\n                {\\n                    prev=prev->next;\\n                    sum+=prev->val;\\n                    if(prev!=head)\\n                        um.erase(sum);\\n                }\\n                um[presum]->next=head->next;\\n            }\\n            else\\n                um[presum]=head;\\n            // if(head)\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549912,
                "title": "c-8ms",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n      \\n        ListNode *prev,*cur,*start,*next;\\n        \\n        start=new ListNode(0);\\n        start->next=head;\\n        prev=start;\\n        cur=head;\\n        \\n        int sum=0;\\n        while(cur)\\n        {\\n            \\n            sum=sum+cur->val;\\n            \\n            if(sum==0)\\n            {\\n                prev->next=cur->next;\\n               \\n            }\\n             cur=cur->next;\\n            if(cur==NULL)\\n            {\\n                prev=prev->next;\\n                if(prev==NULL) break;\\n                cur=prev->next;\\n                sum=0;\\n            }\\n           \\n        }\\n        \\n        \\n        \\n        \\n        return start->next;\\n        \\n        \\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n      \\n        ListNode *prev,*cur,*start,*next;\\n        \\n        start=new ListNode(0);\\n        start->next=head;\\n        prev=start;\\n        cur=head;\\n        \\n        int sum=0;\\n        while(cur)\\n        {\\n            \\n            sum=sum+cur->val;\\n            \\n            if(sum==0)\\n            {\\n                prev->next=cur->next;\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 489912,
                "title": "swift-o-n-solution",
                "content": "```\\nclass Solution {\\n    func removeZeroSumSublists(_ head: ListNode?) -> ListNode? {\\n        var map:[Int:ListNode] = [:]\\n        let dummy = ListNode(0)\\n        dummy.next = head\\n        var node:ListNode? = dummy\\n        var total = 0\\n        while node != nil {\\n            total += node!.val\\n            map[total] = node\\n            node = node?.next\\n        }\\n        \\n        total = 0\\n        node = dummy\\n        while node != nil {\\n            total += node!.val\\n            node!.next = map[total]?.next\\n            node = node?.next\\n        }\\n        return dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeZeroSumSublists(_ head: ListNode?) -> ListNode? {\\n        var map:[Int:ListNode] = [:]\\n        let dummy = ListNode(0)\\n        dummy.next = head\\n        var node:ListNode? = dummy\\n        var total = 0\\n        while node != nil {\\n            total += node!.val\\n            map[total] = node\\n            node = node?.next\\n        }\\n        \\n        total = 0\\n        node = dummy\\n        while node != nil {\\n            total += node!.val\\n            node!.next = map[total]?.next\\n            node = node?.next\\n        }\\n        return dummy.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389737,
                "title": "c-solution-beat-100-using-array-and-running-sum",
                "content": "1. Convert linked list to array, **arr**, and get the running sum of the array, store in **sum**.\\n2. Use 2 pointer, **i** and **j**.\\n\\t**i** from front to back, and **j** from back to front, checking if there is a **j** that **sum[i] == sum[j]**.\\n\\tif **i == j**, which means there is no subarray with 0 sum starting from i, put i to the linked list to return.\\n\\tif **i != j**, all the numbers [i..j - 1] can be removed. Let **i = j**.\\n\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        vector<int> arr, sum = {0};\\n        ListNode* ptr = head;\\n        while(ptr) \\n        {\\n            arr.push_back(ptr->val);\\n            sum.push_back(sum.back() + ptr->val);\\n            ptr = ptr->next;\\n        }\\n        \\n        ListNode* ret = new ListNode(0);   \\n        ptr = ret;\\n        int i = 0;\\n        int n = sum.size();\\n        while(i < n - 1)\\n        {\\n            int j = n - 1;\\n            for(; j > i; --j)\\n            {\\n                if(sum[i] == sum[j]) break;\\n            }\\n            if(j == i)\\n            {\\n                ptr->next = new ListNode(arr[i]);\\n                ptr = ptr->next;\\n                i++;\\n            }\\n            else i = j;\\n        }\\n        return ret->next;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        vector<int> arr, sum = {0}",
                "codeTag": "Java"
            },
            {
                "id": 367374,
                "title": "cpp-violent-solution",
                "content": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\n        auto dummy = new ListNode(-1);\\n        dummy->next = head;\\n        auto p = dummy;\\n        while(p)\\n        {\\n            int sum = 0;\\n            bool flag = false;\\n            auto q = p->next;\\n            \\n            while(q)\\n            {\\n                sum += q->val;\\n                if(sum == 0)\\n                {\\n                    p->next = q->next;\\n                    flag = true;\\n                    break;\\n                }\\n                q = q->next;\\n            }\\n            if(!flag)\\n                p = p->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\n        auto dummy = new ListNode(-1);\\n        dummy->next = head;\\n        auto p = dummy;\\n        while(p)\\n        {\\n            int sum = 0;\\n            bool flag = false;\\n            auto q = p->next;\\n            \\n            while(q)\\n            {\\n                sum += q->val;\\n                if(sum == 0)\\n                {\\n                    p->next = q->next;\\n                    flag = true;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 366711,
                "title": "python-o-n-amazing-d",
                "content": "Short and elegant skip problem with hash map:\\n\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        cur = head\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        d = {0: dummy}\\n        \\n        while cur:\\n            s += cur.val\\n            if s not in d:\\n                d[s] = cur\\n            else:\\n                d[s].next = cur.next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        cur = head\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        d = {0: dummy}\\n        \\n        while cur:\\n            s += cur.val\\n            if s not in d:\\n                d[s] = cur\\n            else:\\n                d[s].next = cur.next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054419,
                "title": "best-java-solution-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    // taken help\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    // taken help\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043979,
                "title": "c-using-map",
                "content": "\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *curr = head;\\n\\n        map<int, ListNode*> m;\\n        m[0] = dummy;\\n\\n        int prefix = 0;\\n        while(curr) {\\n            prefix += curr -> val;\\n\\n            if(m.count(prefix)) {\\n                ListNode *p = m[prefix] -> next;\\n                int val = prefix;\\n                while(p != curr) {\\n                    val += p -> val;\\n                    m.erase(val);\\n                    p = p -> next;\\n                }\\n                m[prefix] -> next = curr -> next;\\n                \\n            }else {\\n                m[prefix] = curr;\\n            }\\n            curr = curr -> next;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *curr = head;\\n\\n        map<int, ListNode*> m;\\n        m[0] = dummy;\\n\\n        int prefix = 0;\\n        while(curr) {\\n            prefix += curr -> val;\\n\\n            if(m.count(prefix)) {\\n                ListNode *p = m[prefix] -> next;\\n                int val = prefix;\\n                while(p != curr) {\\n                    val += p -> val;\\n                    m.erase(val);\\n                    p = p -> next;\\n                }\\n                m[prefix] -> next = curr -> next;\\n                \\n            }else {\\n                m[prefix] = curr;\\n            }\\n            curr = curr -> next;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617727,
                "title": "c-easy-solution-using-recursion-easy-understanding",
                "content": "**pls upvote if it helps**\\n\\n```\\nListNode* solve(ListNode* head , bool & anychange){\\n        \\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            sum+=temp->val;\\n            if(sum == 0)\\n                break;\\n            temp = temp->next;\\n        }\\n        if(sum == 0){\\n            anychange = true;\\n            return temp->next;\\n        }\\n        head->next = solve(head->next,anychange);\\n        return head;\\n    }\\n    \\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        while(true){\\n            bool anychange = false;\\n            head = solve(head , anychange);\\n            \\n            if(head == NULL || anychange == false)\\n                break;\\n        }\\n            \\n            return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nListNode* solve(ListNode* head , bool & anychange){\\n        \\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            sum+=temp->val;\\n            if(sum == 0)\\n                break;\\n            temp = temp->next;\\n        }\\n        if(sum == 0){\\n            anychange = true;\\n            return temp->next;\\n        }\\n        head->next = solve(head->next,anychange);\\n        return head;\\n    }\\n    \\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        while(true){\\n            bool anychange = false;\\n            head = solve(head , anychange);\\n            \\n            if(head == NULL || anychange == false)\\n                break;\\n        }\\n            \\n            return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574319,
                "title": "c-hashmap-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNodes(int sum,ListNode* start,ListNode* end,unordered_map<int,ListNode*>&mp)\\n    {\\n        ListNode* cur = start;\\n        while(cur != end)\\n        {\\n            sum += cur->val;\\n            mp.erase(sum);\\n            cur = cur->next;\\n        }\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        unordered_map<int,ListNode*>mp; \\n        mp[0] = NULL;\\n        ListNode* cur = head;\\n        int sum = 0;\\n        while(cur)\\n        {\\n            sum += cur->val;\\n            if(mp.find(sum) == mp.end())\\n                mp[sum] = cur;\\n            else\\n            {\\n                if(sum == 0)\\n                {\\n                    deleteNodes(0,head,cur,mp);\\n                    head = cur->next;\\n                }\\n                else\\n                {\\n                    deleteNodes(sum,mp[sum]->next,cur,mp);\\n                    mp[sum]->next = cur->next;\\n                }\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNodes(int sum,ListNode* start,ListNode* end,unordered_map<int,ListNode*>&mp)\\n    {\\n        ListNode* cur = start;\\n        while(cur != end)\\n        {\\n            sum += cur->val;\\n            mp.erase(sum);\\n            cur = cur->next;\\n        }\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        unordered_map<int,ListNode*>mp; \\n        mp[0] = NULL;\\n        ListNode* cur = head;\\n        int sum = 0;\\n        while(cur)\\n        {\\n            sum += cur->val;\\n            if(mp.find(sum) == mp.end())\\n                mp[sum] = cur;\\n            else\\n            {\\n                if(sum == 0)\\n                {\\n                    deleteNodes(0,head,cur,mp);\\n                    head = cur->next;\\n                }\\n                else\\n                {\\n                    deleteNodes(sum,mp[sum]->next,cur,mp);\\n                    mp[sum]->next = cur->next;\\n                }\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562923,
                "title": "beginners-approach-memory-leak-warning",
                "content": "class Solution {\\npublic:\\n     ListNode* solve(ListNode* head,bool & change)\\n     {   if(head==NULL) return head;\\n             ListNode*  temp=head;\\n             int sum=0;\\n         while(temp!=NULL)\\n         {\\n             sum=sum+temp->val;\\n             if(sum==0)\\n             {\\n             break;\\n             }\\n             temp=temp->next;\\n         }\\n         \\n         if(sum==0)\\n         {\\n             change=true;\\n             return \\n                 temp->next;\\n         }\\n         \\n         head->next=solve(head->next,change);\\n         \\n         return head;\\n     }\\n    \\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        bool change=false;\\n        \\n        while(true)\\n        {\\n            bool change=false;\\n            head=solve(head,change);\\n            if(head==NULL || change==false) break;\\n            \\n            \\n        }\\n        return head;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     ListNode* solve(ListNode* head,bool & change)\\n     {   if(head==NULL) return head;\\n             ListNode*  temp=head;\\n             int sum=0;\\n         while(temp!=NULL)\\n         {\\n             sum=sum+temp->val;\\n             if(sum==0)\\n             {\\n             break;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2544396,
                "title": "c-o-n-using-prefixsum-and-node-address",
                "content": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int,ListNode*>mp;\\n        ListNode *start,*temp;\\n        int sum=0,total;\\n        start=head;\\n        while(start!=NULL)\\n        {\\n            sum=sum+start->val;\\n            if(sum==0)\\n            {\\n                head=start->next;\\n                mp.clear();\\n                \\n            }\\n            else if(mp[sum])\\n            {\\n                temp=mp[sum];\\n                temp=temp->next;\\n                total=sum;\\n                while(temp!=start)\\n                {\\n                mp.erase(total+temp->val);\\n                    total=total+temp->val;\\n                    temp=temp->next;\\n                }\\n                mp[sum]->next=start->next;   \\n            }\\n            else\\n                mp[sum]=start;\\n            start=start->next;\\n            \\n        }\\n        \\n    return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int,ListNode*>mp;\\n        ListNode *start,*temp;\\n        int sum=0,total;\\n        start=head;\\n        while(start!=NULL)\\n        {\\n            sum=sum+start->val;\\n            if(sum==0)\\n            {\\n                head=start->next;\\n                mp.clear();\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2471376,
                "title": "c-o-n-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        std::unordered_map<int, ListNode*> prefix;\\n        ListNode *dummyNode = new ListNode(0, head);\\n        int sum = 0;\\n        prefix[0] = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            prefix[sum] = head;\\n            head = head->next;\\n        }\\n        sum = 0;\\n        head = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            if(prefix[sum] != head)\\n            {\\n                head->next = prefix[sum]->next;\\n            }\\n            head = head->next;\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        std::unordered_map<int, ListNode*> prefix;\\n        ListNode *dummyNode = new ListNode(0, head);\\n        int sum = 0;\\n        prefix[0] = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            prefix[sum] = head;\\n            head = head->next;\\n        }\\n        sum = 0;\\n        head = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            if(prefix[sum] != head)\\n            {\\n                head->next = prefix[sum]->next;\\n            }\\n            head = head->next;\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454452,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        ListNode* dummy = new ListNode(0);\\n        \\n        dummy->next = head;\\n        \\n        int presum = 0;\\n        \\n        unordered_map<int,ListNode*> mp;\\n        \\n        mp[0] = dummy;\\n        \\n        while(head)\\n        {\\n           \\n            presum += head->val;\\n            \\n            if(mp.count(presum))\\n            {\\n              ListNode* tmp = mp[presum];\\n                \\n              int sum = presum;\\n                \\n              while(tmp && tmp != head)\\n              {\\n                  tmp = tmp->next;\\n                  \\n                  sum += tmp->val;\\n                  \\n                  if(tmp != head)\\n                  {\\n                      mp.erase(sum);\\n                  }\\n                  \\n              }\\n                \\n             mp[presum]->next = head->next;\\n            }\\n            \\n            else\\n            {\\n                mp[presum] = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return dummy->next;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        ListNode* dummy = new ListNode(0);\\n        \\n        dummy->next = head;\\n        \\n        int presum = 0;\\n        \\n        unordered_map<int,ListNode*> mp;\\n        \\n        mp[0] = dummy;\\n        \\n        while(head)\\n        {\\n           \\n            presum += head->val;\\n            \\n            if(mp.count(presum))\\n            {\\n              ListNode* tmp = mp[presum];\\n                \\n              int sum = presum;\\n                \\n              while(tmp && tmp != head)\\n              {\\n                  tmp = tmp->next;\\n                  \\n                  sum += tmp->val;\\n                  \\n                  if(tmp != head)\\n                  {\\n                      mp.erase(sum);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 2400384,
                "title": "cpp-beginner-friendly-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n       vector<int>nums;\\n       for(auto node = head; node; node = node->next){\\n           int value = node->val;\\n           nums.push_back(value);\\n       }\\n       int n = nums.size();\\n        \\n       vector<vector<int>>values(n,vector<int>(3,-1));\\n       for(int i=0;i<n;i++){\\n           int sum = 0;\\n           for(int j=i;j<n;j++){\\n               sum += nums[j];\\n               \\n               if(sum == 0){\\n                   values[i] = {0,i,j};\\n               }\\n           }\\n       }\\n        \\n       \\n        \\n       ListNode* actualHead = new ListNode(-1);\\n       ListNode* root = actualHead;\\n        \\n       for(int i = 0; i<n;i++){\\n           if(values[i][0] == 0){\\n               i = values[i][2];\\n               continue;\\n           }\\n           root->next = new ListNode(nums[i]);\\n           root = root->next;\\n       }\\n       return actualHead->next;\\n       // return head;\\n    }\\n};\\n\\n//  The approach here is that we are skipping those subarrays whose sum is zero\\n// Thank you : ) Please do upvote so that needy one can find over the top\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n       vector<int>nums;\\n       for(auto node = head; node; node = node->next){\\n           int value = node->val;\\n           nums.push_back(value);\\n       }\\n       int n = nums.size();\\n        \\n       vector<vector<int>>values(n,vector<int>(3,-1));\\n       for(int i=0;i<n;i++){\\n           int sum = 0;\\n           for(int j=i;j<n;j++){\\n               sum += nums[j];\\n               \\n               if(sum == 0){\\n                   values[i] = {0,i,j};\\n               }\\n           }\\n       }\\n        \\n       \\n        \\n       ListNode* actualHead = new ListNode(-1);\\n       ListNode* root = actualHead;\\n        \\n       for(int i = 0; i<n;i++){\\n           if(values[i][0] == 0){\\n               i = values[i][2];\\n               continue;\\n           }\\n           root->next = new ListNode(nums[i]);\\n           root = root->next;\\n       }\\n       return actualHead->next;\\n       // return head;\\n    }\\n};\\n\\n//  The approach here is that we are skipping those subarrays whose sum is zero\\n// Thank you : ) Please do upvote so that needy one can find over the top\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364153,
                "title": "java-easy-approach-short-solution",
                "content": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        int sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            map.put(sum, p);\\n        }\\n        sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = map.get(sum).next;\\n        }\\n        return preHead.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        int sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            map.put(sum, p);\\n        }\\n        sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = map.get(sum).next;\\n        }\\n        return preHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2291804,
                "title": "prefixsum-approch",
                "content": "```\\nListNode*deleteVal(ListNode*head,ListNode*curr,ListNode*last){\\n        if(curr==nullptr)\\n                return last->next;\\n        else\\n            curr->next=last->next;\\n        return head;\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*temp=head;\\n        unordered_map<int,ListNode*>mp;\\n        int sum=0;\\n        while(temp!=nullptr){\\n            sum+=temp->val;\\n            if(sum==0){\\n                int t=0;\\n                ListNode*tt=head;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                    cout<<t<<endl;\\n                }\\n               head=deleteVal(head,nullptr,temp);\\n            }\\n            if(mp.find(sum)!=mp.end()){\\n                  int t=sum;\\n                ListNode*tt=mp[sum]->next;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                }\\n                 // cout<<sum<<\" \"<<head->val<<\" \"<<mp[sum]->val<<endl;\\n               head=deleteVal(head,mp[sum],temp);\\n            }\\n            else{\\n                mp[sum]=temp;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Linked List",
                    "Prefix Sum"
                ],
                "code": "```\\nListNode*deleteVal(ListNode*head,ListNode*curr,ListNode*last){\\n        if(curr==nullptr)\\n                return last->next;\\n        else\\n            curr->next=last->next;\\n        return head;\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*temp=head;\\n        unordered_map<int,ListNode*>mp;\\n        int sum=0;\\n        while(temp!=nullptr){\\n            sum+=temp->val;\\n            if(sum==0){\\n                int t=0;\\n                ListNode*tt=head;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                    cout<<t<<endl;\\n                }\\n               head=deleteVal(head,nullptr,temp);\\n            }\\n            if(mp.find(sum)!=mp.end()){\\n                  int t=sum;\\n                ListNode*tt=mp[sum]->next;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                }\\n                 // cout<<sum<<\" \"<<head->val<<\" \"<<mp[sum]->val<<endl;\\n               head=deleteVal(head,mp[sum],temp);\\n            }\\n            else{\\n                mp[sum]=temp;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2263816,
                "title": "python-sol-well-explained-hashmap-prefix-sum-easy-fast",
                "content": "# EXPLANATION\\n```\\n1. How do we know that any substring will have sum = 0\\n2. The idea is if any prefix sum that had occured before occurs again we know that sum of substring\\nbetween them is = 0\\nexample        [ 1,4,2,5,-7]\\nsum will be   [ 1,5,7,12,5] \\nSO 5 occurs twice i.e. sum of [2,5,-7] is 0\\nso we simply make 4.next = 7.next in linklist to remove [2,5,-7]\\nalso we remove [2,5,-7] as node if is in hashmap\\n```\\n\\n\\n\\n\\n# CODE\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        root = ListNode(0,head)\\n        summ , d , node = 0 , {} , root\\n        while node:\\n            summ += node.val\\n            if summ in d:\\n                prev = d[summ]\\n                tmp = prev.next\\n                tmp_sum = summ\\n                while tmp != node:\\n                    tmp_sum += tmp.val\\n                    if tmp_sum in d and d[tmp_sum] == tmp :d.pop(tmp_sum)\\n                    tmp = tmp.next\\n                prev.next = node.next\\n                node = prev\\n            else:\\n                d[summ] = node\\n            node = node.next\\n        \\n        return root.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n1. How do we know that any substring will have sum = 0\\n2. The idea is if any prefix sum that had occured before occurs again we know that sum of substring\\nbetween them is = 0\\nexample        [ 1,4,2,5,-7]\\nsum will be   [ 1,5,7,12,5] \\nSO 5 occurs twice i.e. sum of [2,5,-7] is 0\\nso we simply make 4.next = 7.next in linklist to remove [2,5,-7]\\nalso we remove [2,5,-7] as node if is in hashmap\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        root = ListNode(0,head)\\n        summ , d , node = 0 , {} , root\\n        while node:\\n            summ += node.val\\n            if summ in d:\\n                prev = d[summ]\\n                tmp = prev.next\\n                tmp_sum = summ\\n                while tmp != node:\\n                    tmp_sum += tmp.val\\n                    if tmp_sum in d and d[tmp_sum] == tmp :d.pop(tmp_sum)\\n                    tmp = tmp.next\\n                prev.next = node.next\\n                node = prev\\n            else:\\n                d[summ] = node\\n            node = node.next\\n        \\n        return root.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259780,
                "title": "c-easy-to-understand-prefix-sum-with-hashmap",
                "content": "Problem similar to [560. Subarray-sum-equals-k](https://leetcode.com/problems/subarray-sum-equals-k/)\\nBut here it is Linked list instead of array.\\n\\n**Please Upvote. If It has helped you :)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        \\n        bool sumZeroFound = true;\\n        \\n        while(sumZeroFound){ // we need to check is new list still have zero sum\\n            sumZeroFound = false; // reset \\n            \\n            ListNode* iter = &dummy;\\n            unordered_map<int, ListNode*> prefixSumTable;\\n            prefixSumTable.insert({0, iter});\\n            iter = iter->next; // start from head node\\n            int currSum = 0;\\n\\n            while(iter){\\n                currSum += iter->val;\\n                if(prefixSumTable.find(currSum) != prefixSumTable.end()){\\n                    ListNode* start = prefixSumTable[currSum];\\n                    start->next = iter->next;\\n                    sumZeroFound = true; /// there will be changes in list\\n                }else{\\n                    prefixSumTable.insert({currSum, iter});\\n                }\\n                iter = iter->next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        \\n        bool sumZeroFound = true;\\n        \\n        while(sumZeroFound){ // we need to check is new list still have zero sum\\n            sumZeroFound = false; // reset \\n            \\n            ListNode* iter = &dummy;\\n            unordered_map<int, ListNode*> prefixSumTable;\\n            prefixSumTable.insert({0, iter}",
                "codeTag": "Java"
            },
            {
                "id": 2151121,
                "title": "c-solution-based-on-hashmap",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> prefix_sum_to_node;\\n        if (head == nullptr){\\n            return nullptr;\\n        }\\n        ListNode* guard = new ListNode(0);\\n        guard->next = head;\\n        head = guard;\\n   \\n        ListNode* p = head;\\n        int prefix_sum = 0;\\n        bool happen_change = false;\\n        while(p != nullptr){\\n            prefix_sum += p->val;\\n            if (prefix_sum_to_node.count(prefix_sum) == 0){\\n                prefix_sum_to_node.insert({prefix_sum, p});\\n            }\\n            else{\\n                happen_change = true;\\n                // the prefix sum has already been occured:\\n                ListNode* pre_p = prefix_sum_to_node[prefix_sum];\\n                // the nodes from pre_p->next to p can be deleted\\n                ListNode* next_p = p->next;\\n                pre_p->next = next_p;\\n                p = pre_p;\\n            }\\n            p = p->next;\\n        }\\n        while(head != nullptr){\\n            if (head->val == 0){\\n                head = head->next;    \\n            }\\n            else{\\n                break;\\n            } \\n        }        \\n        if (happen_change){\\n            return removeZeroSumSublists(head);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> prefix_sum_to_node;\\n        if (head == nullptr){\\n            return nullptr;\\n        }\\n        ListNode* guard = new ListNode(0);\\n        guard->next = head;\\n        head = guard;\\n   \\n        ListNode* p = head;\\n        int prefix_sum = 0;\\n        bool happen_change = false;\\n        while(p != nullptr){\\n            prefix_sum += p->val;\\n            if (prefix_sum_to_node.count(prefix_sum) == 0){\\n                prefix_sum_to_node.insert({prefix_sum, p});\\n            }\\n            else{\\n                happen_change = true;\\n                // the prefix sum has already been occured:\\n                ListNode* pre_p = prefix_sum_to_node[prefix_sum];\\n                // the nodes from pre_p->next to p can be deleted\\n                ListNode* next_p = p->next;\\n                pre_p->next = next_p;\\n                p = pre_p;\\n            }\\n            p = p->next;\\n        }\\n        while(head != nullptr){\\n            if (head->val == 0){\\n                head = head->next;    \\n            }\\n            else{\\n                break;\\n            } \\n        }        \\n        if (happen_change){\\n            return removeZeroSumSublists(head);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118437,
                "title": "use-dummy-variable-to-avoid-edge-cases-java-hashmap",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hash = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head; \\n        ListNode curr = dummy;\\n        int sum = 0; \\n        while (curr != null){\\n            sum += curr.val;\\n            hash.put(sum, curr.next);\\n            curr = curr.next; \\n        }\\n        hash.put(sum, null);\\n        curr = dummy;\\n        int tp = 0; \\n        while (curr != null){\\n            tp += curr.val;\\n            if (hash.containsKey(tp)){\\n                curr.next = hash.get(tp);\\n            }\\n            curr = curr.next; \\n        }\\n        if (tp == 0) return null;\\n        return dummy.next; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hash = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head; \\n        ListNode curr = dummy;\\n        int sum = 0; \\n        while (curr != null){\\n            sum += curr.val;\\n            hash.put(sum, curr.next);\\n            curr = curr.next; \\n        }\\n        hash.put(sum, null);\\n        curr = dummy;\\n        int tp = 0; \\n        while (curr != null){\\n            tp += curr.val;\\n            if (hash.containsKey(tp)){\\n                curr.next = hash.get(tp);\\n            }\\n            curr = curr.next; \\n        }\\n        if (tp == 0) return null;\\n        return dummy.next; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071910,
                "title": "c-o-n-s-n-14ms-faster-than-66-10-8mb-less-than-88",
                "content": "Runtime: 14 ms, faster than 66.67% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\nMemory Usage: 10.8 MB, less than 87.90% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        std::vector<int> arr;\\n        buildArray(head, arr);\\n        removeZeroSumSegment(arr);\\n        \\n        ListNode* prev = nullptr;\\n        ListNode* cur = head;\\n        for (int n : arr)\\n        {\\n            cur->val = n;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        if (!prev)\\n            return nullptr;\\n        else\\n            prev->next = nullptr;\\n        \\n        return head;\\n    }\\nprivate:\\n    void buildArray(ListNode* head, std::vector<int>& arr)\\n    {\\n        while (head)\\n        {\\n            arr.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    void removeZeroSumSegment(std::vector<int>& arr)\\n    {\\n        std::vector<int> sum(arr.begin(), arr.end());\\n        for (int i = 1; i < sum.size(); i++)\\n            sum[i] += sum[i - 1];\\n        \\n        std::vector<std::pair<int, int>> zeroSegments;\\n        int is = 0;\\n        while (is < sum.size())\\n        {\\n            for (int i = sum.size() - 1; i >= is; i--)\\n            {\\n                if (sum[i] - sum[is] + arr[is] == 0)\\n                {\\n                    zeroSegments.push_back({ is, i + 1 });\\n                    is = i;\\n                    break;\\n                }\\n            }\\n            \\n            is++;\\n        }\\n        \\n        for (int i = zeroSegments.size() - 1; i >= 0; i--)\\n        {\\n            arr.erase(arr.begin() + zeroSegments[i].first, arr.begin() + zeroSegments[i].second);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        std::vector<int> arr;\\n        buildArray(head, arr);\\n        removeZeroSumSegment(arr);\\n        \\n        ListNode* prev = nullptr;\\n        ListNode* cur = head;\\n        for (int n : arr)\\n        {\\n            cur->val = n;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        if (!prev)\\n            return nullptr;\\n        else\\n            prev->next = nullptr;\\n        \\n        return head;\\n    }\\nprivate:\\n    void buildArray(ListNode* head, std::vector<int>& arr)\\n    {\\n        while (head)\\n        {\\n            arr.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    void removeZeroSumSegment(std::vector<int>& arr)\\n    {\\n        std::vector<int> sum(arr.begin(), arr.end());\\n        for (int i = 1; i < sum.size(); i++)\\n            sum[i] += sum[i - 1];\\n        \\n        std::vector<std::pair<int, int>> zeroSegments;\\n        int is = 0;\\n        while (is < sum.size())\\n        {\\n            for (int i = sum.size() - 1; i >= is; i--)\\n            {\\n                if (sum[i] - sum[is] + arr[is] == 0)\\n                {\\n                    zeroSegments.push_back({ is, i + 1 });\\n                    is = i;\\n                    break;\\n                }\\n            }\\n            \\n            is++;\\n        }\\n        \\n        for (int i = zeroSegments.size() - 1; i >= 0; i--)\\n        {\\n            arr.erase(arr.begin() + zeroSegments[i].first, arr.begin() + zeroSegments[i].second);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023190,
                "title": "java-without-hashmap-o-n-2",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy=new ListNode(0,head);\\n        ListNode prev=dummy;\\n\\t\\t\\n        while(prev!=null)\\n        {\\n            int sum=0;\\n            while(head!=null)\\n            {\\n                sum+=head.val;\\n                if(sum==0)\\n                {\\n                    prev.next=head.next;\\n                }\\n                head=head.next;\\n            }\\n            prev=prev.next;\\n            if(prev!=null)\\n            {\\n               head=prev.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy=new ListNode(0,head);\\n        ListNode prev=dummy;\\n\\t\\t\\n        while(prev!=null)\\n        {\\n            int sum=0;\\n            while(head!=null)\\n            {\\n                sum+=head.val;\\n                if(sum==0)\\n                {\\n                    prev.next=head.next;\\n                }\\n                head=head.next;\\n            }\\n            prev=prev.next;\\n            if(prev!=null)\\n            {\\n               head=prev.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846075,
                "title": "c-solution-hashmap-prefix-sum",
                "content": "\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        map<int,ListNode*> m;\\n        \\n        int prefix_sum=0;\\n        \\n        m[0]=dummy;\\n        \\n        while(head)\\n        {\\n            prefix_sum+=head->val;\\n            \\n            //if prefix_sum is already seen,then erase all prefix_sum we got thereafter.\\n            if(m.find(prefix_sum)!=m.end())\\n            {  \\n                ListNode* temp=m[prefix_sum]->next;\\n                int temp_sum=prefix_sum;\\n                \\n                while(temp!=head)\\n                {\\n                    temp_sum+=temp->val;\\n                    m.erase(temp_sum);\\n                    temp=temp->next;\\n                }\\n                \\n                m[prefix_sum]->next=head->next;\\n            }\\n            else  m[prefix_sum]=head;\\n            \\n            head=head->next;\\n        }\\n       \\n        \\n        return dummy->next;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        map<int,ListNode*> m;\\n        \\n        int prefix_sum=0;\\n        \\n        m[0]=dummy;\\n        \\n        while(head)\\n        {\\n            prefix_sum+=head->val;\\n            \\n            //if prefix_sum is already seen,then erase all prefix_sum we got thereafter.\\n            if(m.find(prefix_sum)!=m.end())\\n            {  \\n                ListNode* temp=m[prefix_sum]->next;\\n                int temp_sum=prefix_sum;\\n                \\n                while(temp!=head)\\n                {\\n                    temp_sum+=temp->val;\\n                    m.erase(temp_sum);\\n                    temp=temp->next;\\n                }\\n                \\n                m[prefix_sum]->next=head->next;\\n            }\\n            else  m[prefix_sum]=head;\\n            \\n            head=head->next;\\n        }\\n       \\n        \\n        return dummy->next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1794309,
                "title": "java-simple-and-short-solution-easy-to-understand-using-hashmap",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        \\n        map.put(0, new ListNode(-1));\\n        map.get(0).next = head;\\n        \\n        ListNode temp = head;\\n        int sum = 0;\\n        while(temp != null){\\n            sum += temp.val;\\n            \\n            // Sum value is coming again, there is subarray with sum zero, remove all these nodes \\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                ListNode next = node.next;\\n                \\n                int auxSum = sum;\\n                while(next != temp){\\n                    auxSum += next.val;\\n                    map.remove(auxSum);\\n                    next = next.next;\\n                }\\n                node.next = temp.next;\\n            }else{  map.put(sum, temp); }\\n            \\n            temp = temp.next;\\n        }\\n        \\n        return map.get(0).next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        \\n        map.put(0, new ListNode(-1));\\n        map.get(0).next = head;\\n        \\n        ListNode temp = head;\\n        int sum = 0;\\n        while(temp != null){\\n            sum += temp.val;\\n            \\n            // Sum value is coming again, there is subarray with sum zero, remove all these nodes \\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                ListNode next = node.next;\\n                \\n                int auxSum = sum;\\n                while(next != temp){\\n                    auxSum += next.val;\\n                    map.remove(auxSum);\\n                    next = next.next;\\n                }\\n                node.next = temp.next;\\n            }else{  map.put(sum, temp); }\\n            \\n            temp = temp.next;\\n        }\\n        \\n        return map.get(0).next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719144,
                "title": "1ms-solution-faster-than-100-no-hashmap-explainations-easy",
                "content": "Idea is to skip the nodes that sum upto 0.\\nSteps: \\n1. Create a pseudo head say head1,  set head1.next = head (in case head is part of the sum=0 franchise : P )\\n2. Create a prev pointer , point it to head1 ( to maintain the head being part of zero sum condition )\\n3. Create temp pointer to traverse through the list \\n4. Traverse the list\\n5. for each iteration call skipZerosum(temp) function \\n6. it iterates through temp till the end of the list\\n7. if sum is found to be zero for a node , node.next is passed back to the parent function , to let it know until when to skip to\\n8. else temp is returned as it is\\n9. if retuned node from skipZerosum(temp) is not equal to temp , skip upto the node ( prev.next = node and temp = node )\\n10. else prev = temp , temp = temp.next\\n11. Return head.next\\n```\\n\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode prev = head1;\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            ListNode node = SkipZeroSum(temp);\\n            \\n            if(node!=temp)\\n            {\\n                prev.next = node;\\n                temp = node;\\n            }\\n            else\\n            {\\n                prev= temp;\\n                temp = temp.next;\\n            }\\n        }\\n        \\n        return head1.next;\\n        \\n    }\\n    \\n    public ListNode SkipZeroSum(ListNode node){\\n        \\n        int sum =0;\\n        ListNode temp = node;\\n        \\n        while(temp!=null)\\n        {\\n            sum+=temp.val;\\n            if(sum==0)\\n            {return temp.next;}\\n            else\\n            {temp=temp.next;}\\n        }\\n        return node;\\n \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode prev = head1;\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            ListNode node = SkipZeroSum(temp);\\n            \\n            if(node!=temp)\\n            {\\n                prev.next = node;\\n                temp = node;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1667395,
                "title": "java-linear-time-and-space-using-running-sum-to-check-for-zero-sum-sublist",
                "content": "```\\n/*\\nApproach: Keep a running sum upto everynode in a map, if the sum already exist in the map, then everything from the previous map value to current map value sums to zero and can be deleted from linked list. At the same time, we will remove the deleted nodes from map as well to prevent checking a deleted node sum.\\n\\nExample:\\n               a b c d  e  f g  i j\\nInput: head = [1,3,2,-3,-2,5,5,-5,1]\\n\\nOutput: a f j\\nThe map would be constructed as:\\n\\n1 : a\\n4: b\\n6: c\\n3: d\\n1: e ----- we need to delete everything from last seen 1(a) to 1(e), otherwise 6(c) would be double counted for \"f\" below\\n6:f\\n11:g\\n6:i ------- same thing, delete from \"f\"\\n7:j\\n\\n0 == delete upto current from head and take next node as head\\nif not, \\n    check if we have seen this sum before, if we have, then that must mean everything in between must sum to zero. e.g. (b+c+d+e)\\nelse,\\n    add the running sum with the assosiated node in the map\\n    \\nAnalysis: Linear time and space\\n\\n*/\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        Map<Integer, ListNode> sumNodeMap = new HashMap<>();\\n\\n        int sum = 0;\\n        ListNode node = head;\\n        while(node != null){\\n            sum += node.val;\\n            \\n            if(sum == 0){\\n                int presum = 0;\\n                removeSumStartsWith(head, node, presum, sumNodeMap); //update map\\n                head = node.next; //update linked list\\n            }else if(sumNodeMap.containsKey(sum)){\\n                ListNode pre = sumNodeMap.get(sum);\\n                int presum = sum;\\n                \\n                removeSumStartsWith(pre.next, node, presum, sumNodeMap); //update map\\n                pre.next = node.next; //update linked list\\n            } else {\\n                sumNodeMap.put(sum, node);\\n            }\\n            \\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    \\n    private void removeSumStartsWith(ListNode start, ListNode end, int presum, Map<Integer, ListNode> sumNodeMap) {\\n        while(start != end) {\\n            presum += start.val;\\n            sumNodeMap.remove(presum);\\n            start = start.next;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nApproach: Keep a running sum upto everynode in a map, if the sum already exist in the map, then everything from the previous map value to current map value sums to zero and can be deleted from linked list. At the same time, we will remove the deleted nodes from map as well to prevent checking a deleted node sum.\\n\\nExample:\\n               a b c d  e  f g  i j\\nInput: head = [1,3,2,-3,-2,5,5,-5,1]\\n\\nOutput: a f j\\nThe map would be constructed as:\\n\\n1 : a\\n4: b\\n6: c\\n3: d\\n1: e ----- we need to delete everything from last seen 1(a) to 1(e), otherwise 6(c) would be double counted for \"f\" below\\n6:f\\n11:g\\n6:i ------- same thing, delete from \"f\"\\n7:j\\n\\n0 == delete upto current from head and take next node as head\\nif not, \\n    check if we have seen this sum before, if we have, then that must mean everything in between must sum to zero. e.g. (b+c+d+e)\\nelse,\\n    add the running sum with the assosiated node in the map\\n    \\nAnalysis: Linear time and space\\n\\n*/\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        Map<Integer, ListNode> sumNodeMap = new HashMap<>();\\n\\n        int sum = 0;\\n        ListNode node = head;\\n        while(node != null){\\n            sum += node.val;\\n            \\n            if(sum == 0){\\n                int presum = 0;\\n                removeSumStartsWith(head, node, presum, sumNodeMap); //update map\\n                head = node.next; //update linked list\\n            }else if(sumNodeMap.containsKey(sum)){\\n                ListNode pre = sumNodeMap.get(sum);\\n                int presum = sum;\\n                \\n                removeSumStartsWith(pre.next, node, presum, sumNodeMap); //update map\\n                pre.next = node.next; //update linked list\\n            } else {\\n                sumNodeMap.put(sum, node);\\n            }\\n            \\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    \\n    private void removeSumStartsWith(ListNode start, ListNode end, int presum, Map<Integer, ListNode> sumNodeMap) {\\n        while(start != end) {\\n            presum += start.val;\\n            sumNodeMap.remove(presum);\\n            start = start.next;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543444,
                "title": "o-n-kotlin-solution-using-linkedhashmap-with-explanation",
                "content": "## The idea: \\nAssume you have an array like this a = [3, 1, 2, -1, -2, 4, 1]\\n\\nThe runinng sum for this array is as follows:\\n\\nsum = [3, 4, 6, 5, 3, 7, 8]\\nwhere sum[i] = a[0] + a[2] ... + a[i]\\n\\nYou can notice that we have two 3s in the sum array, the only way that we can have the number twice in summation is that this summation lost a value equivalent to its value at second occurance of the 3 number in the summation array.\\n\\nfor that we need to remove all numbers starting from the second occurrence of the 3 and stop at when we had the first occurrence.\\n\\nHowever, what if we had a summation that at somepoint became zero at sum[i], this indicate at the the summation from 0 to i is zero. which require us to remove all the numbers.\\n\\n## The Solution:\\nTo check if we have seen a summation number before sum[i] we need to insert the summation in a hash map which store as a key the summatoin and the last node associated with it. once we find that summation in the hash map we need to iterate back to all previouse nodes until we reach the other summation node. for that we need the HashMap keys to be ordered in the same order of inseration, the data structure for that is called LinkedHashMap.\\n\\nBy default the mutableMapOf() and mapOf() creates a LinkedHashMap in koltin which is an orderd hash map where keys are ordered in the order of inseration.\\n\\nOne last thing, to make the code easier and more consistant without many if statements to handle the head removal use case. we can create a dummy node with a value of 0, now if we see zero again in the summation array this is when we remove all nodes and stop at the dummay node. later when we return the answer we can return the dummyNode.next\\n\\n```kotlin\\nclass Solution {\\n    fun removeZeroSumSublists(head: ListNode?): ListNode? {\\n        var dummyNode = ListNode(0).also {\\n            it.next = head\\n        }\\n        \\n        val sumMap = mutableMapOf<Int, ListNode>()\\n        var node: ListNode? = dummyNode\\n        var sum = 0\\n        \\n        while(node != null) {\\n            sum += node!!.`val`\\n            \\n            if(sum !in sumMap) {\\n                sumMap[sum] = node\\n            } else {\\n                val prevNode = sumMap[sum]\\n                prevNode?.next = node?.next\\n                \\n                val keys = sumMap.keys.toMutableList()\\n                var index = keys.lastIndex\\n                \\n                while(index >= 0 && keys[index] != sum) {\\n                    sumMap.remove(keys[index])\\n                    index--\\n                }\\n            }\\n            \\n            node = node?.next\\n        }\\n        \\n        return dummyNode?.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass Solution {\\n    fun removeZeroSumSublists(head: ListNode?): ListNode? {\\n        var dummyNode = ListNode(0).also {\\n            it.next = head\\n        }\\n        \\n        val sumMap = mutableMapOf<Int, ListNode>()\\n        var node: ListNode? = dummyNode\\n        var sum = 0\\n        \\n        while(node != null) {\\n            sum += node!!.`val`\\n            \\n            if(sum !in sumMap) {\\n                sumMap[sum] = node\\n            } else {\\n                val prevNode = sumMap[sum]\\n                prevNode?.next = node?.next\\n                \\n                val keys = sumMap.keys.toMutableList()\\n                var index = keys.lastIndex\\n                \\n                while(index >= 0 && keys[index] != sum) {\\n                    sumMap.remove(keys[index])\\n                    index--\\n                }\\n            }\\n            \\n            node = node?.next\\n        }\\n        \\n        return dummyNode?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524668,
                "title": "ugly-complicated-o-n-javascript-solution-enjoy",
                "content": "`````\\nvar removeZeroSumSublists = function(head) {\\n    const prefixSum = [];\\n    const elements = []\\n    \\n    let headCopy = head;\\n    \\n    while(headCopy){\\n        prefixSum[prefixSum.length] = (prefixSum.length-1) >= 0 ? \\n            prefixSum[prefixSum.length -1] + headCopy.val \\n        : headCopy.val;\\n        \\n        elements[elements.length] = headCopy.val;\\n        \\n        headCopy = headCopy.next;\\n    }\\n    \\n    \\n    let map = new Map();\\n    map.set(0, -1);\\n    \\n    for(let i=0; i<prefixSum.length; i++){\\n        if(!elements[i]){\\n            elements[i] = \\'-\\';\\n        } else {\\n            if(map.has(prefixSum[i])){\\n               const prevIndex = map.get(prefixSum[i]);\\n                for(let j=i; j> prevIndex; j--){\\n                    if(j!=i && prefixSum[j]!=0 && elements[j] != \\'-\\') map.delete(prefixSum[j]);\\n                    elements[j] = \\'-\\';\\n                }\\n            }else{\\n                map.set(prefixSum[i], i);   \\n            }\\n        }   \\n    }\\n    \\n    return elements.reduce((acc, val) => {\\n        if(val != \\'-\\'){\\n            if(acc[0] === null){\\n                const tmp = [];\\n                tmp[0] = new ListNode(val);\\n                tmp[1] = tmp[0];\\n                return tmp;\\n            } else {\\n                acc[1].next = new ListNode(val);\\n                acc[1] = acc[1].next;\\n            }\\n        }\\n        return acc;\\n    }, [null])[0];\\n};\\n",
                "solutionTags": [],
                "code": "`````\\nvar removeZeroSumSublists = function(head) {\\n    const prefixSum = [];\\n    const elements = []\\n    \\n    let headCopy = head;\\n    \\n    while(headCopy){\\n        prefixSum[prefixSum.length] = (prefixSum.length-1) >= 0 ? \\n            prefixSum[prefixSum.length -1] + headCopy.val \\n        : headCopy.val;\\n        \\n        elements[elements.length] = headCopy.val;\\n        \\n        headCopy = headCopy.next;\\n    }\\n    \\n    \\n    let map = new Map();\\n    map.set(0, -1);\\n    \\n    for(let i=0; i<prefixSum.length; i++){\\n        if(!elements[i]){\\n            elements[i] = \\'-\\';\\n        } else {\\n            if(map.has(prefixSum[i])){\\n               const prevIndex = map.get(prefixSum[i]);\\n                for(let j=i; j> prevIndex; j--){\\n                    if(j!=i && prefixSum[j]!=0 && elements[j] != \\'-\\') map.delete(prefixSum[j]);\\n                    elements[j] = \\'-\\';\\n                }\\n            }else{\\n                map.set(prefixSum[i], i);   \\n            }\\n        }   \\n    }\\n    \\n    return elements.reduce((acc, val) => {\\n        if(val != \\'-\\'){\\n            if(acc[0] === null){\\n                const tmp = [];\\n                tmp[0] = new ListNode(val);\\n                tmp[1] = tmp[0];\\n                return tmp;\\n            } else {\\n                acc[1].next = new ListNode(val);\\n                acc[1] = acc[1].next;\\n            }\\n        }\\n        return acc;\\n    }, [null])[0];\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1437007,
                "title": "c-8ms-91-hashmap-of-previous-prefix-sum",
                "content": "Runtime: 8 ms, faster than 91.47% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\nMemory Usage: 11.5 MB, less than 25.71% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n```\\nclass Solution {\\npublic:\\n  \\n  ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode *fh = new ListNode(0, head);\\n    unordered_map<int, ListNode*> mp;\\n    mp[0] = fh;\\n    int sum = 0;\\n    \\n    while( head ){\\n      sum += head->val;\\n      \\n      if(mp.count(sum)){\\n        ListNode *tmp = mp[sum]->next;\\n        for(;tmp != head; tmp = tmp->next){\\n          sum += tmp->val;\\n          mp.erase(sum);\\n        }\\n        sum += head->val;\\n        mp[sum]->next = head->next;\\n      } \\n      else mp[sum] = head; \\n      head = head->next;\\n    }\\n    \\n    return fh->next;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode *fh = new ListNode(0, head);\\n    unordered_map<int, ListNode*> mp;\\n    mp[0] = fh;\\n    int sum = 0;\\n    \\n    while( head ){\\n      sum += head->val;\\n      \\n      if(mp.count(sum)){\\n        ListNode *tmp = mp[sum]->next;\\n        for(;tmp != head; tmp = tmp->next){\\n          sum += tmp->val;\\n          mp.erase(sum);\\n        }\\n        sum += head->val;\\n        mp[sum]->next = head->next;\\n      } \\n      else mp[sum] = head; \\n      head = head->next;\\n    }\\n    \\n    return fh->next;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430314,
                "title": "c-iteration-4ms-solution",
                "content": "```\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n   //create a dummy point prior to original head\\n    struct ListNode* first = calloc(1, sizeof(struct ListNode));\\n    first ->next = head;\\n    head = first;\\n    \\n    while (first != NULL && first->next != NULL) {\\n        int sum = 0;\\n        struct ListNode* sec = first->next;\\n        sum += sec->val;\\n        sec = sec->next;\\n\\n        while (sec != NULL && sum != 0) {\\n            sum += sec->val;\\n            sec = sec->next;\\n        }\\n\\t\\t\\n        if (sum == 0) \\n            first->next = sec;  // Do not move to next since the link is changed after reconnect\\n        else   \\n            first = first->next;\\n    }\\n   \\n    return head->next;\\n}\\n```\\nO(n^2)",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n   //create a dummy point prior to original head\\n    struct ListNode* first = calloc(1, sizeof(struct ListNode));\\n    first ->next = head;\\n    head = first;\\n    \\n    while (first != NULL && first->next != NULL) {\\n        int sum = 0;\\n        struct ListNode* sec = first->next;\\n        sum += sec->val;\\n        sec = sec->next;\\n\\n        while (sec != NULL && sum != 0) {\\n            sum += sec->val;\\n            sec = sec->next;\\n        }\\n\\t\\t\\n        if (sum == 0) \\n            first->next = sec;  // Do not move to next since the link is changed after reconnect\\n        else   \\n            first = first->next;\\n    }\\n   \\n    return head->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430036,
                "title": "java-o-n-two-passes-using-dummy-node-100",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)\\n            return head;\\n        \\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        \\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode curr = dummy;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            map.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        \\n        curr = dummy;\\n        sum = 0;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            curr.next = map.get(sum).next;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)\\n            return head;\\n        \\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        \\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode curr = dummy;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            map.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        \\n        curr = dummy;\\n        sum = 0;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            curr.next = map.get(sum).next;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427316,
                "title": "c-jump-table-approach-unordered-map-2-pass",
                "content": "\\n* parse the list to look for  repeating cumulative sum to detect \"cycle\" to be *skipped*\\n\\t* update the jump table for every sum \\n\\t* if a sum is repeated, we will want to jump ahead to last occurence\\n* parse again the list, recalculating cumulative sum:\\n\\t* update  the next node reference using the jump table previously calculated\\n \\n\\n```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> jump;\\n\\n        int sum {0};\\n        ListNode *origine = new ListNode(0, head);\\n     \\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            jump[sum] = cur; \\n        }\\n        sum = 0;\\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            cur->next = jump[sum]->next;\\n        }\\n        \\n        return origine->next;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n* parse the list to look for  repeating cumulative sum to detect \"cycle\" to be *skipped*\\n\\t* update the jump table for every sum \\n\\t* if a sum is repeated, we will want to jump ahead to last occurence\\n* parse again the list, recalculating cumulative sum:\\n\\t* update  the next node reference using the jump table previously calculated\\n \\n\\n```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> jump;\\n\\n        int sum {0};\\n        ListNode *origine = new ListNode(0, head);\\n     \\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            jump[sum] = cur; \\n        }\\n        sum = 0;\\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            cur->next = jump[sum]->next;\\n        }\\n        \\n        return origine->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1412200,
                "title": "java-0-n-using-hashmap",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode tempHead = new ListNode(0);\\n        tempHead.next = head;\\n        map.put(0, tempHead);\\n        int sum = 0;\\n        while(head != null) {\\n            sum = head.val + sum;\\n            \\n            if(map.containsKey(sum)) {\\n                int prevSum = sum;\\n                ListNode itr = map.get(sum).next;\\n                \\n                while(itr != null && itr != head) {\\n                    sum += itr.val;\\n                    map.remove(sum);\\n                    itr = itr.next;\\n                }\\n                sum = prevSum;\\n                map.get(sum).next = head.next;\\n                \\n            } else {\\n                map.put(sum, head);\\n            }\\n            \\n            head = head.next;\\n        }\\n        return tempHead.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode tempHead = new ListNode(0);\\n        tempHead.next = head;\\n        map.put(0, tempHead);\\n        int sum = 0;\\n        while(head != null) {\\n            sum = head.val + sum;\\n            \\n            if(map.containsKey(sum)) {\\n                int prevSum = sum;\\n                ListNode itr = map.get(sum).next;\\n                \\n                while(itr != null && itr != head) {\\n                    sum += itr.val;\\n                    map.remove(sum);\\n                    itr = itr.next;\\n                }\\n                sum = prevSum;\\n                map.get(sum).next = head.next;\\n                \\n            } else {\\n                map.put(sum, head);\\n            }\\n            \\n            head = head.next;\\n        }\\n        return tempHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411637,
                "title": "java-2-passes-hashmap-solution",
                "content": "2 Passes HashMap solution\\nUse HashMap to store the <prefix sum, ListNode> pair\\nIf the prefix sum exist, that means the sum bewtween previous node (not included) to the current node is 0. So we can point previous node.next to current node.next.\\nThe reason to use 2 passes is that the first pass some skipped nodes is overlapped. Consider the case [1,3,2,-3,-2,5,5,-5,1]\\n1. First pass: put <prefix sum, current node> pair into HashMap, then we can get the **last node** with such prefix sum..\\n2. Second pass: reset prefix sum to 0, point current node to dummy.  Point the current node.next to map.get(sum).next, where map.get(sum) is the **last node** with such prefix sum.\\n\\nNote 1: dummy node can process the situation where sum of the whole list is 0.\\nNote 2: We may not get th shortest list.\\n```\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            map.put(sum, cur);  // get the last node with such prefix sum.\\n        }\\n        sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            cur.next = map.get(sum).next;  // get the last node with such prefix sum.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            map.put(sum, cur);  // get the last node with such prefix sum.\\n        }\\n        sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            cur.next = map.get(sum).next;  // get the last node with such prefix sum.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393840,
                "title": "c-brute-force-99",
                "content": "```\\n\\n```public:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *temp=new ListNode();\\n        temp->next=head;\\n        for(ListNode *i=temp;i!=NULL;i=i->next)\\n        {\\n            int sum=0;\\n            for(ListNode *j=i->next;j!=NULL;j=j->next)\\n            {\\n                sum=sum+j->val;\\n                if(sum==0)\\n                {\\n                    i->next=j->next;\\n                }\\n            }\\n        }\\n        return temp->next;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391873,
                "title": "python-one-pass-solution-with-hashmap-and-stack",
                "content": "The main idea is to keep the prefix sum in a hashmap and if the same prefix sum is observed again, remove all nodes in between. We also need to remove all prefix sum for the in-between deleted nodes from the hashmap. To do that we can keep a stack for the prefix sums and remove each prefix sum from the stack and the hashmap until we get the current prefix sum.\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:return head\\n        head = ListNode(0, head)\\n        sum_dict, stack = {0:head}, [0]\\n        cur,total = head.next, 0\\n        while cur:\\n            total += cur.val\\n            if total not in sum_dict:\\n                sum_dict[total] = cur\\n                stack.append(total)\\n            else:\\n                sum_dict[total].next = cur.next\\n                while stack[-1]!=total:\\n                    val = stack.pop()\\n                    del sum_dict[val]\\n            cur = cur.next\\n        return head.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:return head\\n        head = ListNode(0, head)\\n        sum_dict, stack = {0:head}, [0]\\n        cur,total = head.next, 0\\n        while cur:\\n            total += cur.val\\n            if total not in sum_dict:\\n                sum_dict[total] = cur\\n                stack.append(total)\\n            else:\\n                sum_dict[total].next = cur.next\\n                while stack[-1]!=total:\\n                    val = stack.pop()\\n                    del sum_dict[val]\\n            cur = cur.next\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331542,
                "title": "c-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int n = 0;\\n        vector<int> ans;\\n        ListNode* temp = head;\\n        while(temp){\\n            ans.push_back(temp->val);\\n            temp = temp->next;\\n            n++;\\n        }\\n        vector<int> isDeleted(n,0);\\n        int index = 0;\\n        while(index < n){\\n            if(!isDeleted[index]){\\n                int sum = ans[index];\\n                int j = index + 1;\\n                while(j<n){\\n                    if(sum == 0) break;\\n                    if(!isDeleted[j]) sum = sum + ans[j];\\n                    j++;\\n                }\\n                if(sum == 0){\\n                    for(int k=index; k<j; k++) isDeleted[k] = 1;\\n                }\\n            }\\n            index++;\\n        }\\n        temp = head;\\n        ListNode* root = NULL;\\n        ListNode* prev = NULL;\\n        for(int i=0; i<n; i++){\\n            if(!isDeleted[i]){\\n                temp->val = ans[i];\\n                if(!root) root = temp;\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(prev) prev->next = NULL;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int n = 0;\\n        vector<int> ans;\\n        ListNode* temp = head;\\n        while(temp){\\n            ans.push_back(temp->val);\\n            temp = temp->next;\\n            n++;\\n        }\\n        vector<int> isDeleted(n,0);\\n        int index = 0;\\n        while(index < n){\\n            if(!isDeleted[index]){\\n                int sum = ans[index];\\n                int j = index + 1;\\n                while(j<n){\\n                    if(sum == 0) break;\\n                    if(!isDeleted[j]) sum = sum + ans[j];\\n                    j++;\\n                }\\n                if(sum == 0){\\n                    for(int k=index; k<j; k++) isDeleted[k] = 1;\\n                }\\n            }\\n            index++;\\n        }\\n        temp = head;\\n        ListNode* root = NULL;\\n        ListNode* prev = NULL;\\n        for(int i=0; i<n; i++){\\n            if(!isDeleted[i]){\\n                temp->val = ans[i];\\n                if(!root) root = temp;\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(prev) prev->next = NULL;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290443,
                "title": "simple-brute-force-c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n        \\n        for(ListNode* t=temp;t!=NULL;t=t->next)\\n        {\\n           int sum=0;\\n            for(ListNode* j=t->next;j!=NULL;j=j->next)\\n            {\\n                sum+=j->val;\\n                if(sum==0)\\n                {\\n                    if(j->next!=NULL)\\n                         t->next=j->next;\\n                    else\\n                    {\\n                        t->next=NULL;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return temp->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n        \\n        for(ListNode* t=temp;t!=NULL;t=t->next)\\n        {\\n           int sum=0;\\n            for(ListNode* j=t->next;j!=NULL;j=j->next)\\n            {\\n                sum+=j->val;\\n                if(sum==0)\\n                {\\n                    if(j->next!=NULL)\\n                         t->next=j->next;\\n                    else\\n                    {\\n                        t->next=NULL;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return temp->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148700,
                "title": "followed-the-hints-to-the-letter-but-got-only-26-speed",
                "content": "```\\nclass Solution(object):\\n    def get_data(self, head):\\n        if head is None:\\n            return []\\n        res = []\\n        current = head\\n        while current:\\n            res.append(current.val)\\n            current = current.next\\n        return res\\n\\n    def removeZeroSumSublists(self, head):\\n        lst = [v for v in self.get_data(head) if v]\\n        stack = []\\n        for v in lst:\\n            if not stack:\\n                stack.append(v)\\n            else:\\n                sum_nums = v\\n                for i in range(len(stack) - 1, -1, -1):\\n                    sum_nums += stack[i]\\n                    if not sum_nums:\\n                        stack = stack[:i]\\n                        break\\n                else:\\n                    stack.append(v)\\n        if stack:\\n            new_head = ListNode(stack[0])\\n            tmp = new_head\\n            for i in range(1, len(stack)):\\n                tmp.next = ListNode(stack[i])\\n                tmp = tmp.next\\n        else:\\n            new_head = None\\n        return new_head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def get_data(self, head):\\n        if head is None:\\n            return []\\n        res = []\\n        current = head\\n        while current:\\n            res.append(current.val)\\n            current = current.next\\n        return res\\n\\n    def removeZeroSumSublists(self, head):\\n        lst = [v for v in self.get_data(head) if v]\\n        stack = []\\n        for v in lst:\\n            if not stack:\\n                stack.append(v)\\n            else:\\n                sum_nums = v\\n                for i in range(len(stack) - 1, -1, -1):\\n                    sum_nums += stack[i]\\n                    if not sum_nums:\\n                        stack = stack[:i]\\n                        break\\n                else:\\n                    stack.append(v)\\n        if stack:\\n            new_head = ListNode(stack[0])\\n            tmp = new_head\\n            for i in range(1, len(stack)):\\n                tmp.next = ListNode(stack[i])\\n                tmp = tmp.next\\n        else:\\n            new_head = None\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146108,
                "title": "java-sentinel-head-with-hashmap-o-n-how-o-n-think-of-it-again",
                "content": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        HashMap<Integer,ListNode> map=new HashMap<>();\\n        int sum=0;\\n        ListNode newHead=new ListNode(3003);\\n        map.put(0,newHead);\\n        newHead.next=head;\\n        \\n        while(head!=null)\\n        {\\n            sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode start=map.get(sum);\\n                ListNode temp=start.next;\\n                int tempSum=sum;\\n                while(temp!=head)\\n                {\\n                    tempSum+=temp.val;\\n                    map.remove(tempSum);\\n                    temp=temp.next;\\n                }\\n                start.next=head.next;\\n            }\\n            else\\n                map.put(sum,head);\\n            \\n            head=head.next;\\n        }\\n        return newHead.next;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        HashMap<Integer,ListNode> map=new HashMap<>();\\n        int sum=0;\\n        ListNode newHead=new ListNode(3003);\\n        map.put(0,newHead);\\n        newHead.next=head;\\n        \\n        while(head!=null)\\n        {\\n            sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode start=map.get(sum);\\n                ListNode temp=start.next;\\n                int tempSum=sum;\\n                while(temp!=head)\\n                {\\n                    tempSum+=temp.val;\\n                    map.remove(tempSum);\\n                    temp=temp.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1091989,
                "title": "javascript-solution-brute-force-and-o-n-approach",
                "content": "```\\nvar removeZeroSumSublists = function(head) {\\n    const dummyHead = new ListNode();\\n    dummyHead.next = head;\\n    let prev = dummyHead;\\n    let start = head;\\n    \\n    while (start != null) {\\n        let sum = 0;\\n        let tail = start;\\n        \\n        while (tail != null) {\\n            sum += tail.val;\\n            if (sum === 0) break;\\n            tail = tail.next;\\n        }\\n        \\n        if (tail) {\\n            prev.next = tail.next;\\n            start = tail.next;\\n        }\\n        else {\\n            prev = start;\\n            start = start.next;\\n        }\\n    }\\n    \\n    \\n    return dummyHead.next;\\n};\\n```\\n---\\n\\n```\\nvar removeZeroSumSublists = function(head) {\\n    const map = new Map();\\n    let sum = 0;\\n    let curr = head;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        map.set(sum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    const dummyHead = new ListNode(0);\\n    dummyHead.next = head;\\n    curr = dummyHead;\\n    sum = 0;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        \\n        if (map.has(sum) && map.get(sum) != curr) {\\n            curr.next = map.get(sum).next;\\n            map.delete(sum);\\n        }\\n        curr = curr.next;\\n    }\\n    \\n    return dummyHead.next;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n    const dummyHead = new ListNode();\\n    dummyHead.next = head;\\n    let prev = dummyHead;\\n    let start = head;\\n    \\n    while (start != null) {\\n        let sum = 0;\\n        let tail = start;\\n        \\n        while (tail != null) {\\n            sum += tail.val;\\n            if (sum === 0) break;\\n            tail = tail.next;\\n        }\\n        \\n        if (tail) {\\n            prev.next = tail.next;\\n            start = tail.next;\\n        }\\n        else {\\n            prev = start;\\n            start = start.next;\\n        }\\n    }\\n    \\n    \\n    return dummyHead.next;\\n};\\n```\n```\\nvar removeZeroSumSublists = function(head) {\\n    const map = new Map();\\n    let sum = 0;\\n    let curr = head;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        map.set(sum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    const dummyHead = new ListNode(0);\\n    dummyHead.next = head;\\n    curr = dummyHead;\\n    sum = 0;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        \\n        if (map.has(sum) && map.get(sum) != curr) {\\n            curr.next = map.get(sum).next;\\n            map.delete(sum);\\n        }\\n        curr = curr.next;\\n    }\\n    \\n    return dummyHead.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077389,
                "title": "faster-than-98",
                "content": "```\\nListNode dummy = new ListNode(-1);\\ndummy.next = head;\\nListNode curr = dummy;\\n\\nListNode start = head;\\nint currSum = 0;\\nwhile (start != null)\\n{\\n\\tListNode end = start;\\n\\twhile (end != null)\\n\\t{\\n\\t\\tif (currSum + end.val == 0)\\n\\t\\t{\\n\\t\\t\\tcurr.next = end.next;\\n\\t\\t\\tstart = curr;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrSum += end.val;\\n\\t\\t\\tend = end.next;\\n\\t\\t}\\n\\t}\\n\\tcurr = start;\\n\\tstart = start.next;\\n\\tcurrSum = 0;\\n}\\n\\nreturn dummy.next;\\n```",
                "solutionTags": [],
                "code": "```\\nListNode dummy = new ListNode(-1);\\ndummy.next = head;\\nListNode curr = dummy;\\n\\nListNode start = head;\\nint currSum = 0;\\nwhile (start != null)\\n{\\n\\tListNode end = start;\\n\\twhile (end != null)\\n\\t{\\n\\t\\tif (currSum + end.val == 0)\\n\\t\\t{\\n\\t\\t\\tcurr.next = end.next;\\n\\t\\t\\tstart = curr;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrSum += end.val;\\n\\t\\t\\tend = end.next;\\n\\t\\t}\\n\\t}\\n\\tcurr = start;\\n\\tstart = start.next;\\n\\tcurrSum = 0;\\n}\\n\\nreturn dummy.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1040631,
                "title": "runtime-8-ms-faster-than-89-47-c-iterative-solution",
                "content": "\"\"\"\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    \\n    struct ListNode *p1;\\n    struct ListNode *p2;\\n    struct ListNode *testa;\\n    struct ListNode *prec;\\n    struct ListNode *to_free;\\n\\n    int flag;\\n    int zero;\\n\\n    testa = NULL;\\n    prec = NULL;\\n    p1 = head;\\n    \\n    while(p1 != NULL){\\n        flag = false;\\n        p2 = p1;\\n        zero = 0;\\n        \\n        while(p2!=NULL){\\n            zero += p2->val;\\n            if(zero == 0){\\n                flag = true;\\n                p2 = p2->next;\\n                while(p1 != p2){\\n                     to_free = p1;\\n                    if(p1 == testa)\\n                        testa = NULL;\\n                    \\n                    p1 = p1->next;\\n                    free(to_free);\\n                    to_free = NULL;\\n                }\\n                    \\n                if(testa == NULL){\\n                   testa = p1;\\n                    prec = testa;\\n                }else{\\n                    prec->next = p2;\\n                }\\n\\n            }else\\n                p2 = p2->next;\\n        }\\n        if(testa == NULL){\\n             testa = p1;\\n             prec = testa;\\n         }         \\n        if(flag != true){\\n            prec = p1;\\n            p1 = p1->next;   \\n        }   \\n    }  \\n    return testa;\\n}\\n\\n//this is my iterative code;\\n\\nit involves scrolling through the list with a nested while loop, to allow us to check for all cases. we start from pointer 1 and pointer 2 which are stationary in the same position (at the beginning it will naturally be the head) after which we scroll with pointer 2 and if we find the sum of zero then pointer 2 goes one position forward. obviously it follows that pointer 1 reaches it by eliminating everything it encounters. if, on the other hand, it does not find anything, the head is confirmed and pointer 1 moves forward by one position. for the head question, we have to consider more cases, in fact, in addition to the \"head\" pointer we also have prev which will be in the same position as the head only when it is confirmed, in fact if the head has value the prev pointer will have the task of making section accepted to the one after the eliminated zone.\\n\\n1112-2 8\\n\\nin this case, the head will point to 1, but it will be the task of the previous pointer to go ahead and connect zones 111 to 8.\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    \\n    struct ListNode *p1;\\n    struct ListNode *p2;\\n    struct ListNode *testa;\\n    struct ListNode *prec;\\n    struct ListNode *to_free;\\n\\n    int flag;\\n    int zero;\\n\\n    testa = NULL;\\n    prec = NULL;\\n    p1 = head;\\n    \\n    while(p1 != NULL){\\n        flag = false;\\n        p2 = p1;\\n        zero = 0;\\n        \\n        while(p2!=NULL){\\n            zero += p2->val;\\n            if(zero == 0){\\n                flag = true;\\n                p2 = p2->next;\\n                while(p1 != p2){\\n                     to_free = p1;\\n                    if(p1 == testa)\\n                        testa = NULL;\\n                    \\n                    p1 = p1->next;\\n                    free(to_free);\\n                    to_free = NULL;\\n                }\\n                    \\n                if(testa == NULL){\\n                   testa = p1;\\n                    prec = testa;\\n                }else{\\n                    prec->next = p2;\\n                }\\n\\n            }else\\n                p2 = p2->next;\\n        }\\n        if(testa == NULL){\\n             testa = p1;\\n             prec = testa;\\n         }         \\n        if(flag != true){\\n            prec = p1;\\n            p1 = p1->next;   \\n        }   \\n    }  \\n    return testa;\\n}\\n\\n//this is my iterative code;\\n\\nit involves scrolling through the list with a nested while loop, to allow us to check for all cases. we start from pointer 1 and pointer 2 which are stationary in the same position (at the beginning it will naturally be the head) after which we scroll with pointer 2 and if we find the sum of zero then pointer 2 goes one position forward. obviously it follows that pointer 1 reaches it by eliminating everything it encounters. if, on the other hand, it does not find anything, the head is confirmed and pointer 1 moves forward by one position. for the head question, we have to consider more cases, in fact, in addition to the \"head\" pointer we also have prev which will be in the same position as the head only when it is confirmed, in fact if the head has value the prev pointer will have the task of making section accepted to the one after the eliminated zone.\\n\\n1112-2 8\\n\\nin this case, the head will point to 1, but it will be the task of the previous pointer to go ahead and connect zones 111 to 8.\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1003216,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n    // let cur = head;\\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    for (let i = dummy; i !== null; i= i.next) {\\n        let sum = 0;\\n        for (let j = i.next; j !== null; j = j.next) {\\n            sum += j.val;\\n            if (sum === 0) {\\n                i.next = j.next\\n            }\\n            // j = j.next\\n        }\\n    }\\n    \\n    return dummy.next\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n    // let cur = head;\\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    for (let i = dummy; i !== null; i= i.next) {\\n        let sum = 0;\\n        for (let j = i.next; j !== null; j = j.next) {\\n            sum += j.val;\\n            if (sum === 0) {\\n                i.next = j.next\\n            }\\n            // j = j.next\\n        }\\n    }\\n    \\n    return dummy.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002866,
                "title": "c-o-n-2-brute-force",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode ans(0);\\n        ans.next = head;\\n        \\n        ListNode* prev = &ans;\\n        \\n        while (head) {\\n            int sum = 0;\\n            \\n            ListNode* cur = head;\\n            \\n            while (cur) {\\n                sum += cur->val;\\n            \\n                if (sum == 0) {\\n                    if (prev) {\\n                        prev->next = cur->next;\\n                    }\\n                    \\n                    head = cur->next;\\n                }\\n                \\n                cur = cur->next;\\n            }\\n            \\n            prev = head;\\n            \\n            if (head) {\\n                head = head->next;\\n            }\\n        }\\n        \\n        return ans.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode ans(0);\\n        ans.next = head;\\n        \\n        ListNode* prev = &ans;\\n        \\n        while (head) {\\n            int sum = 0;\\n            \\n            ListNode* cur = head;\\n            \\n            while (cur) {\\n                sum += cur->val;\\n            \\n                if (sum == 0) {\\n                    if (prev) {\\n                        prev->next = cur->next;\\n                    }\\n                    \\n                    head = cur->next;\\n                }\\n                \\n                cur = cur->next;\\n            }\\n            \\n            prev = head;\\n            \\n            if (head) {\\n                head = head->next;\\n            }\\n        }\\n        \\n        return ans.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002848,
                "title": "16-ms-faster-than-78-41-memory-usage-11-8-mb-less-than-61-85",
                "content": "```\\nclass Solution {\\n    #define ln ListNode\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* hd) {\\n        ln*it=hd,*fh=new ln(0,hd);\\n\\tint sum=0;\\n\\tunordered_map<int,ln*>ump;\\n\\tump[0]=fh;\\n\\twhile(it){\\n\\tsum+=it->val;\\n\\tif(ump.find(sum)!=ump.end()){\\n\\t\\tint tmp=sum;\\n\\t\\tln*ti=ump[sum]->next;\\n\\t\\twhile(ti!=it){\\n\\t\\ttmp+=ti->val;\\n\\t\\tump.erase(tmp);\\n\\t\\tti=ti->next;\\n\\t\\t}\\n\\t\\tump[sum]->next=it->next;\\n\\t}\\n\\telse\\n\\t\\tump[sum]=it;\\n\\tit=it->next;\\n\\t}\\n\\treturn fh->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    #define ln ListNode\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* hd) {\\n        ln*it=hd,*fh=new ln(0,hd);\\n\\tint sum=0;\\n\\tunordered_map<int,ln*>ump;\\n\\tump[0]=fh;\\n\\twhile(it){\\n\\tsum+=it->val;\\n\\tif(ump.find(sum)!=ump.end()){\\n\\t\\tint tmp=sum;\\n\\t\\tln*ti=ump[sum]->next;\\n\\t\\twhile(ti!=it){\\n\\t\\ttmp+=ti->val;\\n\\t\\tump.erase(tmp);\\n\\t\\tti=ti->next;\\n\\t\\t}\\n\\t\\tump[sum]->next=it->next;\\n\\t}\\n\\telse\\n\\t\\tump[sum]=it;\\n\\tit=it->next;\\n\\t}\\n\\treturn fh->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995132,
                "title": "suggest-improvement-in-c-o-n-space-o-n-2-time",
                "content": "Could any one suggest any improvment to reduce space and time complexities??\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*>mp;\\n        \\n        ListNode* root=head;\\n        \\n        int sum=0;\\n        \\n        while(root!=NULL){\\n            sum+=root->val;  \\n              if(mp[sum]!=NULL || sum==0){\\n                \\n                  if(sum==0)\\n                      head=root->next;\\n                  else\\n                      mp[sum]->next=root->next;\\n                  \\n                mp.clear();\\n                root=head;\\n                sum=0;\\n              }\\n              else{\\n                mp[sum]=root;\\n                root=root->next;\\n              }\\n        }\\n        \\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*>mp;\\n        \\n        ListNode* root=head;\\n        \\n        int sum=0;\\n        \\n        while(root!=NULL){\\n            sum+=root->val;  \\n              if(mp[sum]!=NULL || sum==0){\\n                \\n                  if(sum==0)\\n                      head=root->next;\\n                  else\\n                      mp[sum]->next=root->next;\\n                  \\n                mp.clear();\\n                root=head;\\n                sum=0;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 955703,
                "title": "beats-93-4-simple-c-code-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        struct ListNode *t, *p, *q; //p is the main pointer, t is a following pointer on\\n        p = t = q = head;           //p and q is the forward moving pointer to check sum\\n        int change = 0, sum = 0;\\n        \\n        if(head->val == 0 && head->next == NULL)\\n            return NULL;\\n        \\n        while(p || change>0)\\n        {\\n            if(change>0)\\n            {\\n                change--;\\n                p = head; //restart checking as a change has been made\\n            }\\n            q = p;\\n            sum = 0;\\n            while(q)\\n            {\\n                sum = sum + q->val;\\n                if(sum == 0)\\n                {\\n                    change++;\\n                    if(p==head)\\n                        head = q->next;\\n                    else\\n                        t->next = q->next;\\n                }\\n                q = q->next;\\n            }\\n            \\n            t = p; //following pointer\\n            if(p != NULL)\\n                p = p->next;    \\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        struct ListNode *t, *p, *q; //p is the main pointer, t is a following pointer on\\n        p = t = q = head;           //p and q is the forward moving pointer to check sum\\n        int change = 0, sum = 0;\\n        \\n        if(head->val == 0 && head->next == NULL)\\n            return NULL;\\n        \\n        while(p || change>0)\\n        {\\n            if(change>0)\\n            {\\n                change--;\\n                p = head; //restart checking as a change has been made\\n            }\\n            q = p;\\n            sum = 0;\\n            while(q)\\n            {\\n                sum = sum + q->val;\\n                if(sum == 0)\\n                {\\n                    change++;\\n                    if(p==head)\\n                        head = q->next;\\n                    else\\n                        t->next = q->next;\\n                }\\n                q = q->next;\\n            }\\n            \\n            t = p; //following pointer\\n            if(p != NULL)\\n                p = p->next;    \\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950258,
                "title": "python-solution-using-hashmap-o-n",
                "content": "This problem is similar to SubArray SUm equal to K.Please solve this problem first which will help in better understanding of this solution.\\nAlgorithm:\\n1.At every node calculate the cumulative sum and store the cumulative sum with its node address in a dictionary.\\n2.When every the cumulative sum repeats it means that the sum of the values in between current node and the node  stored in the dictionary \\nshould be zero.\\n3.When scenario2 comes then we have to delete all the nodes in between these two and also clear the dictionary of these node values.\\n\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy=ListNode(0)\\n        dummy.next=head\\n        sum1=0\\n        prev=dummy\\n        curr=head\\n        values=dict()\\n        values[0]=dummy\\n        \\n        while curr!=None:\\n            \\n            sum1=sum1+curr.val\\n\\n            if sum1 not in values:\\n                values[sum1]=curr\\n            else:\\n                temp=values[sum1].next\\n                values[sum1].next=curr.next\\n                new_sum=sum1\\n                while temp!=curr:\\n                    new_sum=new_sum+temp.val\\n                    del values[new_sum]\\n                    temp=temp.next\\n\\n            prev=curr\\n            curr=curr.next\\n            \\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy=ListNode(0)\\n        dummy.next=head\\n        sum1=0\\n        prev=dummy\\n        curr=head\\n        values=dict()\\n        values[0]=dummy\\n        \\n        while curr!=None:\\n            \\n            sum1=sum1+curr.val\\n\\n            if sum1 not in values:\\n                values[sum1]=curr\\n            else:\\n                temp=values[sum1].next\\n                values[sum1].next=curr.next\\n                new_sum=sum1\\n                while temp!=curr:\\n                    new_sum=new_sum+temp.val\\n                    del values[new_sum]\\n                    temp=temp.next\\n\\n            prev=curr\\n            curr=curr.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926931,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar removeZeroSumSublists = function(head) {\\n    let dummy = new ListNode();\\n    let cur = head;\\n    dummy.next = head;\\n    let m = new Map();\\n    m.set(0, dummy);\\n    let prefixSum = 0;\\n    while (cur !== null) {\\n        prefixSum += cur.val;\\n        if (m.has(prefixSum)) {\\n            // save pointer to next node\\n            let next = cur.next;\\n\\n            // delete the nodes in between from map\\n            let temp = m.get(prefixSum).next;\\n            let tempPrefixSum = prefixSum;\\n            while (temp !== cur && temp !== null) {\\n                tempPrefixSum += temp.val;\\n                m.delete(tempPrefixSum);\\n                temp = temp.next;\\n            }\\n\\n            // set a new cur\\n            cur = m.get(prefixSum);\\n            cur.next = next;\\n        } else {\\n            m.set(prefixSum, cur);\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return dummy.next;\\n    // Time Complexity: O(2n) = O(n);\\n    // Why O(2n)? ex) [1,2,3,4,5,-15]; we scan through the list forth and back here\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n    let dummy = new ListNode();\\n    let cur = head;\\n    dummy.next = head;\\n    let m = new Map();\\n    m.set(0, dummy);\\n    let prefixSum = 0;\\n    while (cur !== null) {\\n        prefixSum += cur.val;\\n        if (m.has(prefixSum)) {\\n            // save pointer to next node\\n            let next = cur.next;\\n\\n            // delete the nodes in between from map\\n            let temp = m.get(prefixSum).next;\\n            let tempPrefixSum = prefixSum;\\n            while (temp !== cur && temp !== null) {\\n                tempPrefixSum += temp.val;\\n                m.delete(tempPrefixSum);\\n                temp = temp.next;\\n            }\\n\\n            // set a new cur\\n            cur = m.get(prefixSum);\\n            cur.next = next;\\n        } else {\\n            m.set(prefixSum, cur);\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return dummy.next;\\n    // Time Complexity: O(2n) = O(n);\\n    // Why O(2n)? ex) [1,2,3,4,5,-15]; we scan through the list forth and back here\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920263,
                "title": "java-solution-stack-and-map-and-removed-the-stack",
                "content": "### map only\\n\\n```java\\n public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode h = map.get(sum);\\n                ListNode t = h;\\n                int x = sum;\\n                h = h.next;\\n                while (h != head) {\\n                    x +=  h.val;\\n                    map.remove(x);\\n                    h = h.next;\\n                }\\n                t.next = head.next;\\n            } else {\\n                map.putIfAbsent(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\n\\n### stack and map\\n```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        Stack<Integer> stack = new Stack<>();\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        stack.push(0);\\n        int sum = 0;\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode t = map.get(sum);\\n                t.next = head.next;\\n                while (!stack.isEmpty() && stack.peek() != sum) {\\n                    map.remove(stack.pop());\\n                }\\n            } else {\\n                map.put(sum, head);\\n                stack.push(sum);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode h = map.get(sum);\\n                ListNode t = h;\\n                int x = sum;\\n                h = h.next;\\n                while (h != head) {\\n                    x +=  h.val;\\n                    map.remove(x);\\n                    h = h.next;\\n                }\\n                t.next = head.next;\\n            } else {\\n                map.putIfAbsent(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        Stack<Integer> stack = new Stack<>();\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        stack.push(0);\\n        int sum = 0;\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode t = map.get(sum);\\n                t.next = head.next;\\n                while (!stack.isEmpty() && stack.peek() != sum) {\\n                    map.remove(stack.pop());\\n                }\\n            } else {\\n                map.put(sum, head);\\n                stack.push(sum);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 912564,
                "title": "javascript-hashmap",
                "content": "Whenever you see \"sum of consecutive numbers\" in the question description, you should immediately think of prefix sum.\\n\\nAnother important technique is storing references to list nodes in a hashmap.\\n\\nHere I will introduce a one-pass solution. The idea is that we want to keep track of the running prefix sum as we visit each node, storing each prefix sum as key and the corresponding node as value in a hashmap. And as soon as we see a redundant prefix sum or 0, we will know that we\\'ve seen a section that evaluates to 0. \\n\\nWhen prefix sum is 0, this means all the values from head to the curr node evaluate to 0.\\n\\nWhen prefix sum is greater than 0, and the sum already exists in the hashmap, this means the section between where that particular sum had occurred and the curr node evaluates to 0. For example, if we have a list `[1,2,-1,-1,3]`, then the prefix sums will be [1,**3,2,1**,4] as we go through the list. Notice in the prefix sum array, 1 occurs twice. That means the nodes corresponding to `3,2,1` (bolded) evaluate to 0. So in order to remove the bolded section, we need to do is look up the node where  `1` occurred first as a prefix sum (I call this `connectingNode` in the code below), and set its `next` pointer to the node where the prefix sum is `4`.\\n\\nAs part of the one-pass solution, we will be calculating the prefix sum and updating the linked list as we go. One tricky part of the logic is that the hashmap needs to be cleared as we delete nodes. We need to partially clear the map because we want the map to be an up-to-date representation of the linked list, in case a deletion allows a new consecutive sum of nums to evaluate to 0. So from the map, we should delete references to nodes that we will remove.\\n\\n```js\\nvar removeZeroSumSublists = function(head) {\\n    let map = {} // maps prefix sum to pointer to node\\n    let sum = 0\\n    let newHead = head\\n    let curr = head\\n    while(curr) {\\n        sum += curr.val\\n        if (sum === 0) {\\n\\t\\t\\t// nums from head to curr node evaluate to 0\\n            newHead = curr.next\\n            map = {} // clear map\\n        } else if (map[sum]) {\\n\\t\\t\\t// this means there is a sub-list that evaluates to 0.\\n            // we also need clear the map, but partially!\\n            // this is the trickiest part of the logic\\n            const connectingNode = map[sum]\\n            \\n            let tempSum = sum\\n            let tempPointer = map[sum].next\\n            while (tempPointer !== curr) {  \\n\\t\\t\\t\\t/* \\n\\t\\t\\t\\tImportant: the above condition is NOT tempPointer !== curr.next. \\n\\t\\t\\t\\tWe shouldn\\'t delete \"sum\" in map because:\\n\\t\\t\\t\\t\\t1) it belongs to the connecting node that is NOT getting deleted, and\\n\\t\\t\\t\\t\\t2) the current node that we\\'re processing hasn\\'t even been added to map\\n\\t\\t\\t\\t*/\\n                tempSum += tempPointer.val\\n                tempPointer = tempPointer.next\\n                \\n                delete map[tempSum]\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// we are done with cleaning up the map\\n\\t\\t\\t// so now actually update the pointer in the linked list\\n            connectingNode.next = curr.next\\n        } else { /* this else case is also super important,\\n\\t\\t\\t\\t\\ti.e., we should NOT be running \"map[sum] = curr\" outside of this else case.\\n\\t\\t\\t\\t\\tThe reason is that if we had just deleted some middle section\\n\\t\\t\\t\\t\\tof the list in the above \"else if\" case, we wouldn\\'t want to record the curr sum \\n\\t\\t\\t\\t\\t(because the curr sum belongs to a node that is now removed)*/\\n            map[sum] = curr\\n        }\\n        \\n        curr = curr.next\\n    }\\n    \\n    return newHead\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar removeZeroSumSublists = function(head) {\\n    let map = {} // maps prefix sum to pointer to node\\n    let sum = 0\\n    let newHead = head\\n    let curr = head\\n    while(curr) {\\n        sum += curr.val\\n        if (sum === 0) {\\n\\t\\t\\t// nums from head to curr node evaluate to 0\\n            newHead = curr.next\\n            map = {} // clear map\\n        } else if (map[sum]) {\\n\\t\\t\\t// this means there is a sub-list that evaluates to 0.\\n            // we also need clear the map, but partially!\\n            // this is the trickiest part of the logic\\n            const connectingNode = map[sum]\\n            \\n            let tempSum = sum\\n            let tempPointer = map[sum].next\\n            while (tempPointer !== curr) {  \\n\\t\\t\\t\\t/* \\n\\t\\t\\t\\tImportant: the above condition is NOT tempPointer !== curr.next. \\n\\t\\t\\t\\tWe shouldn\\'t delete \"sum\" in map because:\\n\\t\\t\\t\\t\\t1) it belongs to the connecting node that is NOT getting deleted, and\\n\\t\\t\\t\\t\\t2) the current node that we\\'re processing hasn\\'t even been added to map\\n\\t\\t\\t\\t*/\\n                tempSum += tempPointer.val\\n                tempPointer = tempPointer.next\\n                \\n                delete map[tempSum]\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// we are done with cleaning up the map\\n\\t\\t\\t// so now actually update the pointer in the linked list\\n            connectingNode.next = curr.next\\n        } else { /* this else case is also super important,\\n\\t\\t\\t\\t\\ti.e., we should NOT be running \"map[sum] = curr\" outside of this else case.\\n\\t\\t\\t\\t\\tThe reason is that if we had just deleted some middle section\\n\\t\\t\\t\\t\\tof the list in the above \"else if\" case, we wouldn\\'t want to record the curr sum \\n\\t\\t\\t\\t\\t(because the curr sum belongs to a node that is now removed)*/\\n            map[sum] = curr\\n        }\\n        \\n        curr = curr.next\\n    }\\n    \\n    return newHead\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859773,
                "title": "c-python-solutions",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode node(0);\\n        ListNode* node_ = &node;\\n        node_->next = head;\\n        ListNode* head_ = node_;\\n        unordered_map<int,ListNode*> d;\\n        vector<int> dv;\\n        int s = 0;\\n\\n        while (node_) {\\n            s += node_->val;\\n\\n            if (d.count(s) == 0) {\\n                d[s] = node_;\\n                dv.push_back(s);\\n            }\\n            else {\\n                d[s]->next = node_->next;\\n                while (dv.back() != s) {\\n                    int t = dv.back();\\n                    dv.pop_back();\\n                    d.erase(t);\\n                }\\n            }\\n            \\n            node_ = node_->next;\\n        }\\n\\n        return head_->next;\\n    }\\n};\\n```\\n\\nPython solution,\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        node = ListNode(0)\\n        node.next = head\\n        d, dv = {}, []\\n        s, node_ = 0, node\\n\\n        while node_:\\n            s += node_.val\\n\\n            if s not in d:\\n                d[s] = node_\\n                dv.append(s)\\n            else:\\n                d[s].next = node_.next\\n                while dv[-1] != s:\\n                    t = dv.pop()\\n                    del d[t]\\n\\n            node_ = node_.next\\n\\n        return node.next\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode node(0);\\n        ListNode* node_ = &node;\\n        node_->next = head;\\n        ListNode* head_ = node_;\\n        unordered_map<int,ListNode*> d;\\n        vector<int> dv;\\n        int s = 0;\\n\\n        while (node_) {\\n            s += node_->val;\\n\\n            if (d.count(s) == 0) {\\n                d[s] = node_;\\n                dv.push_back(s);\\n            }\\n            else {\\n                d[s]->next = node_->next;\\n                while (dv.back() != s) {\\n                    int t = dv.back();\\n                    dv.pop_back();\\n                    d.erase(t);\\n                }\\n            }\\n            \\n            node_ = node_->next;\\n        }\\n\\n        return head_->next;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        node = ListNode(0)\\n        node.next = head\\n        d, dv = {}, []\\n        s, node_ = 0, node\\n\\n        while node_:\\n            s += node_.val\\n\\n            if s not in d:\\n                d[s] = node_\\n                dv.append(s)\\n            else:\\n                d[s].next = node_.next\\n                while dv[-1] != s:\\n                    t = dv.pop()\\n                    del d[t]\\n\\n            node_ = node_.next\\n\\n        return node.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814712,
                "title": "simple-map-solution-c",
                "content": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\t\\t\\n\\t\\t\\tmap<int,ListNode*> m;\\n\\t\\t\\tListNode* current=head;\\n\\t\\t\\tint sum=0;\\n        \\n            while(current!=NULL)\\n            {\\n                sum=sum+current->val;\\n                if(sum==0)\\n                {\\n                    ListNode* left=current->next;\\n                    current->next=NULL;\\n                    head=left;\\n                    current=left;\\n                    m.clear();\\n                }\\n                else if(m.find(sum)!=m.end())\\n                {\\n                    ListNode* left=m[sum];\\n                    \\n                    //removing sum from left->next to current\\n                    ListNode* c=left->next;\\n                    int nsum=sum;\\n                    while(c!=current)\\n                    {\\n                        nsum+=c->val;\\n                        m.erase(nsum);\\n                        c=c->next;\\n                    }\\n                    //after removing map left with prev state\\n                    \\n                    ListNode* right=current->next;\\n                    left->next=right;\\n                    current=right;\\n                }\\n                else if(m.find(sum)==m.end())\\n                {\\n                    m[sum]=current;\\n                    current=current->next;\\n                }\\n            }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\t\\t\\n\\t\\t\\tmap<int,ListNode*> m;\\n\\t\\t\\tListNode* current=head;\\n\\t\\t\\tint sum=0;\\n        \\n            while(current!=NULL)\\n            {\\n                sum=sum+current->val;\\n                if(sum==0)\\n                {\\n                    ListNode* left=current->next;\\n                    current->next=NULL;\\n                    head=left;\\n                    current=left;\\n                    m.clear();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 785062,
                "title": "c-o-n-solution-csp",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* myHead = new ListNode(0, head);\\n        stack<int>sums;\\n        unordered_map<int,ListNode*>dict; //Key = Sum, Val = ListNode\\n        int sum = 0;\\n        \\n        sums.push(0);\\n        dict[0] = myHead;\\n        \\n        while(head != NULL) {\\n            \\n            sum += head->val;\\n            \\n            if (dict.find(sum) != dict.end()) {\\n                \\n                head = head->next;\\n                \\n                while(sums.top() != sum) {\\n                    \\n                    dict.erase(sums.top());\\n                    sums.pop();\\n                    \\n                }//while stack\\n                \\n                dict[sums.top()]->next = head;\\n            }//if val\\n            else {\\n                \\n                sums.push(sum);\\n                dict[sum] = head;\\n                head = head->next;\\n                \\n            }//else val\\n            \\n        }//while\\n        \\n        head = myHead->next;\\n        \\n        myHead->next = NULL;\\n        delete myHead;\\n        \\n        return head;\\n    }\\n};\\n/*\\nKK\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* myHead = new ListNode(0, head);\\n        stack<int>sums;\\n        unordered_map<int,ListNode*>dict; //Key = Sum, Val = ListNode\\n        int sum = 0;\\n        \\n        sums.push(0);\\n        dict[0] = myHead;\\n        \\n        while(head != NULL) {\\n            \\n            sum += head->val;\\n            \\n            if (dict.find(sum) != dict.end()) {\\n                \\n                head = head->next;\\n                \\n                while(sums.top() != sum) {\\n                    \\n                    dict.erase(sums.top());\\n                    sums.pop();\\n                    \\n                }//while stack\\n                \\n                dict[sums.top()]->next = head;\\n            }//if val\\n            else {\\n                \\n                sums.push(sum);\\n                dict[sum] = head;\\n                head = head->next;\\n                \\n            }//else val\\n            \\n        }//while\\n        \\n        head = myHead->next;\\n        \\n        myHead->next = NULL;\\n        delete myHead;\\n        \\n        return head;\\n    }\\n};\\n/*\\nKK\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765186,
                "title": "c-4ms-100-speed-memory-less-than-80-77",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *prev = new ListNode(0);\\n        prev->next = head;\\n        ListNode *temp = prev;\\n        while(temp != NULL)\\n        {\\n            int sum = 0;\\n            while(head != NULL)\\n            {\\n                sum += head->val;\\n                if(sum == 0)\\n                    temp->next = head->next;\\n                head = head->next;\\n            }\\n            temp = temp->next;\\n            if(temp != NULL)\\n                    head = temp->next;\\n        }\\n        return prev->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *prev = new ListNode(0);\\n        prev->next = head;\\n        ListNode *temp = prev;\\n        while(temp != NULL)\\n        {\\n            int sum = 0;\\n            while(head != NULL)\\n            {\\n                sum += head->val;\\n                if(sum == 0)\\n                    temp->next = head->next;\\n                head = head->next;\\n            }\\n            temp = temp->next;\\n            if(temp != NULL)\\n                    head = temp->next;\\n        }\\n        return prev->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744181,
                "title": "java-hashmap-storing-prev-sum-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public void cleanMap(ListNode node, int sum, ListNode head, HashMap<Integer, ListNode> map ) {\\n        if(node == head) return;\\n        sum+=node.val;\\n        map.remove(sum);\\n        cleanMap(node.next, sum, head, map);\\n    }\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode root = new ListNode(0);\\n        root.next = head;\\n        map.put(0, root);\\n        int sum = 0;\\n        while(head!=null){\\n            sum+=head.val;\\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                cleanMap(node.next, sum, head, map);\\n                node.next = head.next;\\n            }\\n            else{\\n                map.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return root.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public void cleanMap(ListNode node, int sum, ListNode head, HashMap<Integer, ListNode> map ) {\\n        if(node == head) return;\\n        sum+=node.val;\\n        map.remove(sum);\\n        cleanMap(node.next, sum, head, map);\\n    }\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode root = new ListNode(0);\\n        root.next = head;\\n        map.put(0, root);\\n        int sum = 0;\\n        while(head!=null){\\n            sum+=head.val;\\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                cleanMap(node.next, sum, head, map);\\n                node.next = head.next;\\n            }\\n            else{\\n                map.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return root.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712211,
                "title": "python-o-n-tedious-solution-though",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        \\n        \\n        \\n        \\n        allNodes = []\\n        \\n        while head:\\n            allNodes.append(head.val)\\n            head = head.next\\n            \\n        \\n        from collections import deque\\n        \\n        \\n        \\n            \\n        \\n        dp = deque()\\n        \\n        j = 0\\n        \\n        while j < len(allNodes) and allNodes[j] == 0:\\n            j+=1\\n        \\n        \\n        if(j == len(allNodes)):\\n            return None\\n        \\n        \\n        dp.append((allNodes[j],j))\\n        \\n        prevSum = {allNodes[j]:j}\\n        \\n        for i in range(j+1,len(allNodes)):\\n            \\n            if(dp):\\n                val = dp[-1][0] + allNodes[i]\\n                \\n            else:\\n                val = allNodes[i]\\n            \\n            if(val == 0):\\n                \\n                while dp:\\n                    dp.pop()\\n                \\n                prevSum = {}\\n                continue\\n                \\n            if(val in prevSum):\\n                \\n                index = prevSum[val]\\n                \\n                while dp and (dp[-1][1] > index):\\n                    _,idx = dp.pop()\\n                    \\n                    temp_dict = prevSum.copy()\\n                    for k,v in prevSum.items():\\n                        if(v == idx):\\n                            del temp_dict[k]\\n                            \\n                    prevSum  = temp_dict.copy()\\n                    temp_dict = {}\\n        \\n            else:\\n                \\n                prevSum[val] = i\\n                dp.append((val,i))\\n                \\n           \\n        root = ListNode(-1)\\n        temp = root\\n        \\n        while dp:\\n            \\n            _,idx = dp.popleft()\\n            \\n            \\n            node = ListNode(allNodes[idx])\\n            root.next = node\\n            root = root.next\\n                \\n                \\n        return temp.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        \\n        \\n        \\n        \\n        allNodes = []\\n        \\n        while head:\\n            allNodes.append(head.val)\\n            head = head.next\\n            \\n        \\n        from collections import deque\\n        \\n        \\n        \\n            \\n        \\n        dp = deque()\\n        \\n        j = 0\\n        \\n        while j < len(allNodes) and allNodes[j] == 0:\\n            j+=1\\n        \\n        \\n        if(j == len(allNodes)):\\n            return None\\n        \\n        \\n        dp.append((allNodes[j],j))\\n        \\n        prevSum = {allNodes[j]:j}\\n        \\n        for i in range(j+1,len(allNodes)):\\n            \\n            if(dp):\\n                val = dp[-1][0] + allNodes[i]\\n                \\n            else:\\n                val = allNodes[i]\\n            \\n            if(val == 0):\\n                \\n                while dp:\\n                    dp.pop()\\n                \\n                prevSum = {}\\n                continue\\n                \\n            if(val in prevSum):\\n                \\n                index = prevSum[val]\\n                \\n                while dp and (dp[-1][1] > index):\\n                    _,idx = dp.pop()\\n                    \\n                    temp_dict = prevSum.copy()\\n                    for k,v in prevSum.items():\\n                        if(v == idx):\\n                            del temp_dict[k]\\n                            \\n                    prevSum  = temp_dict.copy()\\n                    temp_dict = {}\\n        \\n            else:\\n                \\n                prevSum[val] = i\\n                dp.append((val,i))\\n                \\n           \\n        root = ListNode(-1)\\n        temp = root\\n        \\n        while dp:\\n            \\n            _,idx = dp.popleft()\\n            \\n            \\n            node = ListNode(allNodes[idx])\\n            root.next = node\\n            root = root.next\\n                \\n                \\n        return temp.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680488,
                "title": "java-accepted-hash-map-solution",
                "content": "```\\n\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\nHashMap<Integer,ListNode> map = new  HashMap<>();\\n        \\n        \\n        ListNode dummy  = new ListNode(0);\\n        dummy.next=head;\\n        int sum=0;\\n        map.put(0,dummy);\\n        while(head!=null)\\n        {\\n        sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode rem = map.get(sum).next;\\n                int sum2=sum;\\n                while(rem!=head)\\n                {\\n                sum2+=rem.val;\\n                    map.remove(sum2);\\n               rem=rem.next;\\n                }\\n                \\n                \\n                map.get(sum).next=head.next;\\n                \\n            }\\n        else\\n        {\\n            map.put(sum,head);\\n        }\\n        head=head.next;\\n        }\\n        \\n        return dummy.next;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\nHashMap<Integer,ListNode> map = new  HashMap<>();\\n        \\n        \\n        ListNode dummy  = new ListNode(0);\\n        dummy.next=head;\\n        int sum=0;\\n        map.put(0,dummy);\\n        while(head!=null)\\n        {\\n        sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode rem = map.get(sum).next;\\n                int sum2=sum;\\n                while(rem!=head)\\n                {\\n                sum2+=rem.val;\\n                    map.remove(sum2);\\n               rem=rem.next;\\n                }\\n                \\n                \\n                map.get(sum).next=head.next;\\n                \\n            }\\n        else\\n        {\\n            map.put(sum,head);\\n        }\\n        head=head.next;\\n        }\\n        \\n        return dummy.next;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661858,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vals;\\n        vector<int> sum = {0};\\n        ListNode* cur = head;\\n        while (cur){\\n            vals.push_back(cur->val);\\n            cur = cur->next;\\n        }\\n        sum.push_back(vals[0]);\\n        for (int i=1; i<vals.size(); i++){\\n            sum.push_back(sum[i]+vals[i]);\\n        }\\n        ListNode* nhead = new ListNode(0);\\n        ListNode* ntail = nhead;\\n        int i = 0;\\n        while (i < vals.size()){\\n            for (int j=vals.size(); j>=i; j--){\\n                if (i==j){\\n                    ListNode* nnode = new ListNode(vals[i]);\\n                    ntail->next = nnode;\\n                    ntail = nnode;\\n                    i++; break;\\n                }else if (sum[i]==sum[j]){\\n                    i = j; break;\\n                }\\n            }\\n        }\\n        return nhead->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vals;\\n        vector<int> sum = {0};\\n        ListNode* cur = head;\\n        while (cur){\\n            vals.push_back(cur->val);\\n            cur = cur->next;\\n        }\\n        sum.push_back(vals[0]);\\n        for (int i=1; i<vals.size(); i++){\\n            sum.push_back(sum[i]+vals[i]);\\n        }\\n        ListNode* nhead = new ListNode(0);\\n        ListNode* ntail = nhead;\\n        int i = 0;\\n        while (i < vals.size()){\\n            for (int j=vals.size(); j>=i; j--){\\n                if (i==j){\\n                    ListNode* nnode = new ListNode(vals[i]);\\n                    ntail->next = nnode;\\n                    ntail = nnode;\\n                    i++; break;\\n                }else if (sum[i]==sum[j]){\\n                    i = j; break;\\n                }\\n            }\\n        }\\n        return nhead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647343,
                "title": "o-n-java-solution",
                "content": "~~~\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n      Map<Integer,ListNode> map =new HashMap<Integer,ListNode>();\\n      ListNode current =head;\\n      int sum=0;  \\n        \\n        if(head== null) return null;\\n        \\n        while(current!=null){\\n            sum+=current.val;\\n            map.put(sum,current);\\n            current=current.next;\\n        }\\n        \\n        current = head;\\n        sum=0;\\n        while(current!=null){\\n            \\n            sum+=current.val;\\n            if(sum == 0){\\n                head = current.next;\\n            }\\n            else if(map.containsKey(sum)){\\n                \\n                current.next = map.get(sum).next;\\n            }\\n            current=current.next;\\n        }\\n   return head; \\n    }\\n}\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n      Map<Integer,ListNode> map =new HashMap<Integer,ListNode>();\\n      ListNode current =head;\\n      int sum=0;  \\n        \\n        if(head== null) return null;\\n        \\n        while(current!=null){\\n            sum+=current.val;\\n            map.put(sum,current);\\n            current=current.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 647283,
                "title": "javascript-clean-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n  if (!head) return null;\\n  let p = head;\\n  let s = 0;\\n  while (p) {\\n    s += p.val;\\n    if (s == 0) {\\n      return removeZeroSumSublists(p.next);\\n    } else {\\n      p = p.next;\\n    }\\n  }\\n  head.next = removeZeroSumSublists(head.next);\\n  return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n  if (!head) return null;\\n  let p = head;\\n  let s = 0;\\n  while (p) {\\n    s += p.val;\\n    if (s == 0) {\\n      return removeZeroSumSublists(p.next);\\n    } else {\\n      p = p.next;\\n    }\\n  }\\n  head.next = removeZeroSumSublists(head.next);\\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640445,
                "title": "c-o-n-time-and-space-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        unordered_map<int,ListNode*> MAP;\\n        int sum = 0;\\n        int temp_sum;\\n        ListNode* temp2;\\n        ListNode* parent;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                temp2 = head;\\n                temp_sum = 0;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                head = temp->next;\\n            } else if(MAP.find(sum)!=MAP.end()){\\n                parent = MAP[sum];\\n                temp2 = parent->next;\\n                temp_sum = sum;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                parent->next = temp->next;\\n            } else {\\n                MAP[sum] = temp;                \\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        unordered_map<int,ListNode*> MAP;\\n        int sum = 0;\\n        int temp_sum;\\n        ListNode* temp2;\\n        ListNode* parent;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                temp2 = head;\\n                temp_sum = 0;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                head = temp->next;\\n            } else if(MAP.find(sum)!=MAP.end()){\\n                parent = MAP[sum];\\n                temp2 = parent->next;\\n                temp_sum = sum;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                parent->next = temp->next;\\n            } else {\\n                MAP[sum] = temp;                \\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601019,
                "title": "c-hash-map-solution-linked-list-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        if(!head || (head->val == 0 && !head->next))\\n            return NULL;\\n        \\n        ListNode* node = head;\\n        ListNode* startNode = NULL;\\n        \\n        unordered_map<int, ListNode*> hashMap;\\n        int sum = 0;\\n        hashMap[0] = NULL;\\n        bool CLEAREDUP = false;\\n       \\n        while(node)\\n        {\\n            sum += node->val;\\n\\n            if(hashMap.find(sum) == hashMap.end())\\n            {\\n                hashMap[sum] = node;\\n                node = node->next;\\n            }\\n            else\\n            {\\n                startNode = hashMap[sum];\\n                startNode ? startNode->next = node->next : head = node->next; \\n\\n                hashMap = {},   hashMap[0] = NULL;\\n                sum = 0;\\n                node = head;\\n            }\\n        }\\n            \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        if(!head || (head->val == 0 && !head->next))\\n            return NULL;\\n        \\n        ListNode* node = head;\\n        ListNode* startNode = NULL;\\n        \\n        unordered_map<int, ListNode*> hashMap;\\n        int sum = 0;\\n        hashMap[0] = NULL;\\n        bool CLEAREDUP = false;\\n       \\n        while(node)\\n        {\\n            sum += node->val;\\n\\n            if(hashMap.find(sum) == hashMap.end())\\n            {\\n                hashMap[sum] = node;\\n                node = node->next;\\n            }\\n            else\\n            {\\n                startNode = hashMap[sum];\\n                startNode ? startNode->next = node->next : head = node->next; \\n\\n                hashMap = {},   hashMap[0] = NULL;\\n                sum = 0;\\n                node = head;\\n            }\\n        }\\n            \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576417,
                "title": "python-98-100",
                "content": "This python code is based on @arpanbag001\\'s [explanation](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/507108/Java-simple-O(n)-solution-with-explanation). O(n):\\n\\n```\\nclass Solution(object):\\n\\tdef removeZeroSumSublists(self, head):\\n\\t\\t\"\"\"\\n\\t\\tBased on the Java solution explained here:\\n\\t\\thttps://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/507108/Java-simple-O(n)-solution-with-explanation\\n\\n\\t\\tThe main idea is that a cumulative sum will have repeating values when there are zero sum sublists. For e.g. if the original linked list is [1,2,3,-3,-1,1], then a cumulative sum with a prehead (an artificial 0 entry before the head) will be: [0, 1, 3, 6, 3, 2, 3]. As you can see a cumulative sum of 3 occurs three times. Which implies that the sublists [3,-3] and [-1,1] add up to zero.\\n\\n\\t\\t:param head: \\n\\t\\t:return: \\n\\t\\t\"\"\"\\n\\t\\tprehead = ListNode(0)\\n\\t\\tprehead.next = head\\n\\t\\tcurrent = head\\n\\t\\tsum_map = {0: prehead} #cumulative sum map\\n\\t\\tcumsum = 0\\n\\t\\twhile current:\\n\\t\\t\\tcumsum += current.val\\n\\t\\t\\tif cumsum in sum_map: #cumulative sum in the map\\n\\t\\t\\t\\tprevmatch = sum_map[cumsum]\\n\\t\\t\\t\\twalker = prevmatch.next\\n\\t\\t\\t\\twsum = cumsum\\n\\t\\t\\t\\twhile walker != current:\\n\\t\\t\\t\\t\\twsum += walker.val\\n\\t\\t\\t\\t\\t# delete intermediate cumulative sums in zero sublist\\n\\t\\t\\t\\t\\tdel sum_map[wsum] \\n\\t\\t\\t\\t\\twalker = walker.next\\n\\t\\t\\t\\tprevmatch.next = current.next #skip zero sum sublist entries\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsum_map[cumsum] = current\\n\\t\\t\\tcurrent = current.next\\n\\t\\treturn prehead.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef removeZeroSumSublists(self, head):\\n\\t\\t\"\"\"\\n\\t\\tBased on the Java solution explained here:\\n\\t\\thttps://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/507108/Java-simple-O(n)-solution-with-explanation\\n\\n\\t\\tThe main idea is that a cumulative sum will have repeating values when there are zero sum sublists. For e.g. if the original linked list is [1,2,3,-3,-1,1], then a cumulative sum with a prehead (an artificial 0 entry before the head) will be: [0, 1, 3, 6, 3, 2, 3]. As you can see a cumulative sum of 3 occurs three times. Which implies that the sublists [3,-3] and [-1,1] add up to zero.\\n\\n\\t\\t:param head: \\n\\t\\t:return: \\n\\t\\t\"\"\"\\n\\t\\tprehead = ListNode(0)\\n\\t\\tprehead.next = head\\n\\t\\tcurrent = head\\n\\t\\tsum_map = {0: prehead} #cumulative sum map\\n\\t\\tcumsum = 0\\n\\t\\twhile current:\\n\\t\\t\\tcumsum += current.val\\n\\t\\t\\tif cumsum in sum_map: #cumulative sum in the map\\n\\t\\t\\t\\tprevmatch = sum_map[cumsum]\\n\\t\\t\\t\\twalker = prevmatch.next\\n\\t\\t\\t\\twsum = cumsum\\n\\t\\t\\t\\twhile walker != current:\\n\\t\\t\\t\\t\\twsum += walker.val\\n\\t\\t\\t\\t\\t# delete intermediate cumulative sums in zero sublist\\n\\t\\t\\t\\t\\tdel sum_map[wsum] \\n\\t\\t\\t\\t\\twalker = walker.next\\n\\t\\t\\t\\tprevmatch.next = current.next #skip zero sum sublist entries\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsum_map[cumsum] = current\\n\\t\\t\\tcurrent = current.next\\n\\t\\treturn prehead.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561603,
                "title": "java-solution-with-explain",
                "content": "```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        while(prev.next != null){\\n\\t\\t//every time we begin from the first node, and calculate the sum of all the node from the first\\n            int sum = 0;\\n            ListNode cur = prev.next;\\n            for(; cur != null; cur = cur.next){\\n                sum += cur.val;\\n                if(sum == 0) {\\n                    prev.next = cur.next;\\n                    break; //when matches, break the loop\\n                }\\n            }\\n\\t\\t\\t// if no sum from first equals 0, then start from next node\\n            if(cur == null) prev = prev.next;\\n            \\n        }\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        while(prev.next != null){\\n\\t\\t//every time we begin from the first node, and calculate the sum of all the node from the first\\n            int sum = 0;\\n            ListNode cur = prev.next;\\n            for(; cur != null; cur = cur.next){\\n                sum += cur.val;\\n                if(sum == 0) {\\n                    prev.next = cur.next;\\n                    break; //when matches, break the loop\\n                }\\n            }\\n\\t\\t\\t// if no sum from first equals 0, then start from next node\\n            if(cur == null) prev = prev.next;\\n            \\n        }\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 550152,
                "title": "c-recursive",
                "content": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tunordered_map<int, ListNode*> seen;\\n\\tseen[0] = nullptr;\\n\\tint sum = 0;\\n\\tfor (ListNode *curr = head; curr; curr = curr->next) {\\n\\t\\tsum += curr->val;\\n\\t\\tauto it = seen.find(sum);\\n\\t\\tif (it == seen.end()) {\\n\\t\\t\\tseen[sum] = curr;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// remove section\\n\\t\\tif (it->second) {\\n\\t\\t\\tit->second->next = curr->next;\\n\\t\\t\\treturn removeZeroSumSublists(head);\\n\\t\\t}   else {\\n\\t\\t\\treturn removeZeroSumSublists(curr->next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tunordered_map<int, ListNode*> seen;\\n\\tseen[0] = nullptr;\\n\\tint sum = 0;\\n\\tfor (ListNode *curr = head; curr; curr = curr->next) {\\n\\t\\tsum += curr->val;\\n\\t\\tauto it = seen.find(sum);\\n\\t\\tif (it == seen.end()) {\\n\\t\\t\\tseen[sum] = curr;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// remove section\\n\\t\\tif (it->second) {\\n\\t\\t\\tit->second->next = curr->next;\\n\\t\\t\\treturn removeZeroSumSublists(head);\\n\\t\\t}   else {\\n\\t\\t\\treturn removeZeroSumSublists(curr->next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548511,
                "title": "c-skipping-the-nodes-that-doesn-t-sum-effectively-adding-up-to-0",
                "content": "Here `preHead` is required for cases like [-1, 1] where prefix of array can be empty.\\n\\n```csharp\\npublic ListNode RemoveZeroSumSublists(ListNode head) \\n{\\n\\tDictionary<int, ListNode> sumToFurthestNode = new Dictionary<int, ListNode>();      \\n\\tListNode preHead = new ListNode(0);\\n\\tpreHead.next = head;\\n\\n\\tint sum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tsumToFurthestNode[sum] = p;\\n\\t}\\n\\n\\tsum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tp.next = sumToFurthestNode[sum].next;\\n\\t}\\n\\n\\treturn preHead.next;        \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic ListNode RemoveZeroSumSublists(ListNode head) \\n{\\n\\tDictionary<int, ListNode> sumToFurthestNode = new Dictionary<int, ListNode>();      \\n\\tListNode preHead = new ListNode(0);\\n\\tpreHead.next = head;\\n\\n\\tint sum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tsumToFurthestNode[sum] = p;\\n\\t}\\n\\n\\tsum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tp.next = sumToFurthestNode[sum].next;\\n\\t}\\n\\n\\treturn preHead.next;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471085,
                "title": "python-brute-force-and-optimized-solutions",
                "content": "1. Brute force\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        def f(arr, target=0):\\n            if not arr:\\n                return []\\n            d = {0:-1}\\n            so_far = 0\\n            for i, num in enumerate(arr):\\n                so_far += num\\n                if so_far - target in d:\\n                    return arr[:d[so_far - target]+1] + arr[i+1:]\\n                else:\\n                    d[so_far] = i\\n            return arr\\n        \\n        def arr(head):\\n            res = []\\n            c = head\\n            while c:\\n                res.append(c.val)\\n                c = c.next\\n            return res\\n        \\n        a = arr(head)\\n        b = f(a)\\n        while a != b:\\n            a, b = b, f(b)\\n        \\n        dummy = ListNode(\"*\")\\n        current = dummy\\n        for num in b:\\n            tmp = ListNode(num)\\n            current.next = tmp\\n            current = tmp\\n        current.next = None\\n        return dummy.next\\n```\\n\\n2. Without by way of a plain list\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = {0:dummy} # prefix:ListNode\\n        current = head\\n        while current:\\n            prefix += current.val\\n            seen[prefix] = current # seen[prefix] records the most recent seen ListNode with prefix\\n            current = current.next\\n            \\n        prefix, current = 0, dummy\\n        while current:\\n            prefix += current.val\\n            current.next = seen[prefix].next\\n            current = current.next\\n        return dummy.next\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        def f(arr, target=0):\\n            if not arr:\\n                return []\\n            d = {0:-1}\\n            so_far = 0\\n            for i, num in enumerate(arr):\\n                so_far += num\\n                if so_far - target in d:\\n                    return arr[:d[so_far - target]+1] + arr[i+1:]\\n                else:\\n                    d[so_far] = i\\n            return arr\\n        \\n        def arr(head):\\n            res = []\\n            c = head\\n            while c:\\n                res.append(c.val)\\n                c = c.next\\n            return res\\n        \\n        a = arr(head)\\n        b = f(a)\\n        while a != b:\\n            a, b = b, f(b)\\n        \\n        dummy = ListNode(\"*\")\\n        current = dummy\\n        for num in b:\\n            tmp = ListNode(num)\\n            current.next = tmp\\n            current = tmp\\n        current.next = None\\n        return dummy.next\\n```\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = {0:dummy} # prefix:ListNode\\n        current = head\\n        while current:\\n            prefix += current.val\\n            seen[prefix] = current # seen[prefix] records the most recent seen ListNode with prefix\\n            current = current.next\\n            \\n        prefix, current = 0, dummy\\n        while current:\\n            prefix += current.val\\n            current.next = seen[prefix].next\\n            current = current.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466365,
                "title": "c",
                "content": "```\\npublic ListNode RemoveZeroSumSublists(ListNode head) {\\n\\tvar dict = new Dictionary<int, ListNode>();\\n\\tvar stack = new Stack<int>();\\n\\tvar sum = 0;\\n\\n\\tfor (var curr = head; curr != null; curr = curr.next) {\\n\\t\\tsum += curr.val;\\n\\n\\t\\tif (sum == 0) {\\n\\t\\t\\thead = curr.next;\\n\\t\\t\\tdict.Clear();\\n\\t\\t}\\n\\t\\telse if (dict.ContainsKey(sum)) {\\n\\t\\t\\tdict[sum].next = curr.next;\\n\\t\\t\\twhile (stack.Count > 0 && stack.Peek() != sum) \\n\\t\\t\\t\\tdict.Remove(stack.Pop());\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdict.Add(sum, curr);\\n\\t\\t\\tstack.Push(sum);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode RemoveZeroSumSublists(ListNode head) {\\n\\tvar dict = new Dictionary<int, ListNode>();\\n\\tvar stack = new Stack<int>();\\n\\tvar sum = 0;\\n\\n\\tfor (var curr = head; curr != null; curr = curr.next) {\\n\\t\\tsum += curr.val;\\n\\n\\t\\tif (sum == 0) {\\n\\t\\t\\thead = curr.next;\\n\\t\\t\\tdict.Clear();\\n\\t\\t}\\n\\t\\telse if (dict.ContainsKey(sum)) {\\n\\t\\t\\tdict[sum].next = curr.next;\\n\\t\\t\\twhile (stack.Count > 0 && stack.Peek() != sum) \\n\\t\\t\\t\\tdict.Remove(stack.Pop());\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdict.Add(sum, curr);\\n\\t\\t\\tstack.Push(sum);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414088,
                "title": "java-recursive-solution-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        if (head.next == null) return head.val == 0 ? null : head;\\n        ListNode p = removeZeroSumSublists(head.next);\\n        head.next = p;\\n        int sum = head.val;\\n        while (p != null) {\\n            if (sum == 0) return p;\\n            sum += p.val;\\n            p = p.next;\\n        }\\n        if (sum == 0) return p;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        if (head.next == null) return head.val == 0 ? null : head;\\n        ListNode p = removeZeroSumSublists(head.next);\\n        head.next = p;\\n        int sum = head.val;\\n        while (p != null) {\\n            if (sum == 0) return p;\\n            sum += p.val;\\n            p = p.next;\\n        }\\n        if (sum == 0) return p;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411097,
                "title": "easy-to-understand-c-solution-8ms-beats-98",
                "content": "Runtime: 8 ms, faster than 98.40% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\nMemory Usage: 10.4 MB, less than 100.00% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        int prefixSum = 0;\\n        unordered_map<int, ListNode*> mp;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        mp[0] = dummy;\\n        ListNode* ptr = head;\\n        \\n        while(ptr)\\n        {\\n            prefixSum += ptr->val;\\n            \\n            if(mp.find(prefixSum) != mp.end())\\n            {\\n                ListNode* prev = mp[prefixSum];\\n                ListNode* start = prev;\\n                int auxPrefixSum = prefixSum;\\n                \\n                while(prev != ptr)\\n                {\\n                    prev = prev->next;\\n                    auxPrefixSum += prev->val;\\n                    if(prev != ptr) mp.erase(auxPrefixSum);\\n                }\\n                \\n                start->next = ptr->next;\\n            }\\n            else\\n                mp[prefixSum] = ptr;\\n            ptr = ptr->next;\\n        }\\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        int prefixSum = 0;\\n        unordered_map<int, ListNode*> mp;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        mp[0] = dummy;\\n        ListNode* ptr = head;\\n        \\n        while(ptr)\\n        {\\n            prefixSum += ptr->val;\\n            \\n            if(mp.find(prefixSum) != mp.end())\\n            {\\n                ListNode* prev = mp[prefixSum];\\n                ListNode* start = prev;\\n                int auxPrefixSum = prefixSum;\\n                \\n                while(prev != ptr)\\n                {\\n                    prev = prev->next;\\n                    auxPrefixSum += prev->val;\\n                    if(prev != ptr) mp.erase(auxPrefixSum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 401406,
                "title": "python-92-dictionary",
                "content": "Idea: as we traverse the list from the beginning, we store all recorded partial sums in a dictionary of the form {partial_sum : last_node}. As soon as we find a node which has a partial sum we have seen before (meaning the sum of all intermediate elements is 0), we backtrack to the node where the sum was last observed, effectively remove everything in between by modifying the pointer to the next element and once again traverse the list of deleted nodes to mark them as deleted.\\n\\n```class Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        last_sum = 0\\n        data = {0:None}\\n        curr = head\\n        discarded = set()\\n        while curr:\\n            last_sum = last_sum+curr.val\\n            if last_sum in data and data[last_sum] not in discarded:\\n                res = curr.next\\n                if data[last_sum] is None:\\n                    cln = head\\n                    head = res\\n                else:\\n                    cln = data[last_sum].next\\n                    data[last_sum].next = res\\n                while cln!=res:\\n                    discarded.add(cln)\\n                    cln = cln.next\\n            else:\\n                data[last_sum] = curr\\n            curr = curr.next\\n        return head",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        last_sum = 0\\n        data = {0:None}",
                "codeTag": "Java"
            },
            {
                "id": 389613,
                "title": "python-3-91-100-with-comments-fast-asf",
                "content": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        #construct hash map with initial dummy node\\n        self.nodes = {}\\n        #dummy node\\n        dummy = ListNode(-9999)\\n        self.nodes[0] = dummy\\n        #current node\\n        cur = head\\n        dummy.next = cur\\n        #current sum\\n        total = 0\\n        #keep running total and map nodes to running total\\n        while cur is not None:\\n            #add to running total\\n            total += cur.val\\n            #first check if we\\'ve seen this sum before\\n            if total in self.nodes:\\n                #to be removed (one after acc. sum)\\n                to_be_removed = self.nodes[total].next\\n                #second sum\\n                total2 = total\\n                while to_be_removed != cur:\\n                    total2 += to_be_removed.val\\n                    self.nodes.pop(total2)\\n                    to_be_removed = to_be_removed.next\\n                #draw link from sum to next of cur\\n                self.nodes[total].next = cur.next\\n            else:\\n                #map it\\n                self.nodes[total] = cur\\n            #set next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        #construct hash map with initial dummy node\\n        self.nodes = {}\\n        #dummy node\\n        dummy = ListNode(-9999)\\n        self.nodes[0] = dummy\\n        #current node\\n        cur = head\\n        dummy.next = cur\\n        #current sum\\n        total = 0\\n        #keep running total and map nodes to running total\\n        while cur is not None:\\n            #add to running total\\n            total += cur.val\\n            #first check if we\\'ve seen this sum before\\n            if total in self.nodes:\\n                #to be removed (one after acc. sum)\\n                to_be_removed = self.nodes[total].next\\n                #second sum\\n                total2 = total\\n                while to_be_removed != cur:\\n                    total2 += to_be_removed.val\\n                    self.nodes.pop(total2)\\n                    to_be_removed = to_be_removed.next\\n                #draw link from sum to next of cur\\n                self.nodes[total].next = cur.next\\n            else:\\n                #map it\\n                self.nodes[total] = cur\\n            #set next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386323,
                "title": "very-easy-and-intuitive-solution-by-using-stack-and-prefix-sum-set",
                "content": "```scala\\n  def removeZeroSumSublists(head: ListNode): ListNode = {\\n\\n    import scala.collection.mutable.{Set, Stack}\\n    var set = Set[Int]()\\n    set add 0\\n    var result = new ListNode(-1)\\n    result.next = head\\n\\n    var stack = Stack[ListNode]()\\n    var runner = head\\n    var sum = 0\\n    \\n    while (runner != null) {\\n      \\n      val currVal = runner.x\\n      val curr = runner\\n      sum += currVal\\n      \\n      if (set.add(sum)) {\\n        stack push curr\\n      } else {\\n        \\n        val next = curr.next\\n        var tmpSum = sum\\n        sum -= currVal\\n        \\n        while (!stack.isEmpty && tmpSum != sum) {\\n          set remove sum\\n          sum -= (stack pop()).x\\n        }\\n        \\n        if (!stack.isEmpty) {\\n          stack.top.next = next\\n        } else {\\n          result.next = next\\n        }\\n      }\\n      runner = runner.next\\n    }\\n    result.next\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def removeZeroSumSublists(head: ListNode): ListNode = {\\n\\n    import scala.collection.mutable.{Set, Stack}\\n    var set = Set[Int]()\\n    set add 0\\n    var result = new ListNode(-1)\\n    result.next = head\\n\\n    var stack = Stack[ListNode]()\\n    var runner = head\\n    var sum = 0\\n    \\n    while (runner != null) {\\n      \\n      val currVal = runner.x\\n      val curr = runner\\n      sum += currVal\\n      \\n      if (set.add(sum)) {\\n        stack push curr\\n      } else {\\n        \\n        val next = curr.next\\n        var tmpSum = sum\\n        sum -= currVal\\n        \\n        while (!stack.isEmpty && tmpSum != sum) {\\n          set remove sum\\n          sum -= (stack pop()).x\\n        }\\n        \\n        if (!stack.isEmpty) {\\n          stack.top.next = next\\n        } else {\\n          result.next = next\\n        }\\n      }\\n      runner = runner.next\\n    }\\n    result.next\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 375895,
                "title": "python-prefix-sum-solution",
                "content": "The core of the problem is to do ```range query```, and for this purpose, as far as I know, we generally have 2 ways:\\n1. prefix sum array\\n2. Fenwick tree\\n\\nUsing a Fenwick tree would be overkilling, so the intuition that comes to my mind is prefix sum! For an array ```arr=[1, 2, -3, 4, 5]```, a prefix sum array ```pre``` would be ```[0, 1, 3, 0, 4, 9]```, the most important property of prefix sum array is:\\n\\n```pre[j] - pre[i] = sum from arr[i] to arr[j-1]```\\n\\nSo if we\\'re at position j, and find the current sum is the same as position i, then sum of range from i to j-1 must be 0.\\n\\nThere\\'s a similar problem on LeetCode: **560. Subarray Sum Equals K** (https://leetcode.com/problems/subarray-sum-equals-k/) that could give you a better understanding of how the above idea works.\\n\\nAccepted code:\\n```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next, helper = head, head\\n        d[0] = dummy\\n        cur = 0\\n        while helper:\\n            cur += helper.val\\n            if cur in d:\\n                p = d[cur]\\n                q = p.next\\n                tmp = cur + q.val\\n                while tmp != cur:\\n                    d.pop(tmp)\\n                    q = q.next\\n                    tmp += q.val\\n                p.next = helper.next\\n            else:\\n                d[cur] = helper\\n            helper = helper.next if helper else None\\n        return dummy.next\\n```\\nNotice the tricky part is ```d[0]=dummy```, it\\'s corresponding to the first element in ```pre``` array, where ```pre[0]``` is always 0.",
                "solutionTags": [],
                "code": "```range query```\n```arr=[1, 2, -3, 4, 5]```\n```pre```\n```[0, 1, 3, 0, 4, 9]```\n```pre[j] - pre[i] = sum from arr[i] to arr[j-1]```\n```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next, helper = head, head\\n        d[0] = dummy\\n        cur = 0\\n        while helper:\\n            cur += helper.val\\n            if cur in d:\\n                p = d[cur]\\n                q = p.next\\n                tmp = cur + q.val\\n                while tmp != cur:\\n                    d.pop(tmp)\\n                    q = q.next\\n                    tmp += q.val\\n                p.next = helper.next\\n            else:\\n                d[cur] = helper\\n            helper = helper.next if helper else None\\n        return dummy.next\\n```\n```d[0]=dummy```\n```pre```\n```pre[0]```",
                "codeTag": "Java"
            },
            {
                "id": 374273,
                "title": "python3-solution-beats-100-space-and-91-time-48ms-with-hashmap-and-dummy-node",
                "content": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        prefix_sum = 0\\n        seen = {prefix_sum: dummy}\\n        \\n        while head:\\n            prefix_sum += head.val\\n\\t\\t\\t\\n\\t\\t\\t# remove elements in zero sum\\n            if prefix_sum in seen:           \\n                k, v = seen.popitem()\\n                while k != prefix_sum:\\n                    k, v = seen.popitem()\\n                seen[k] = v\\n            else:\\n\\t\\t\\t    # add non zero-sum elements\\n                seen[prefix_sum] = head\\n            \\n            head = head.next\\n        \\n\\t\\t# rebuild the linkedlist\\n        ret = dummy\\n        for i, k in enumerate(seen):\\n            if i > 0:\\n                ret.next = seen[k]\\n                ret = ret.next\\n        \\n        ret.next = None\\n        \\n        return dummy.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        prefix_sum = 0\\n        seen = {prefix_sum: dummy}\\n        \\n        while head:\\n            prefix_sum += head.val\\n\\t\\t\\t\\n\\t\\t\\t# remove elements in zero sum\\n            if prefix_sum in seen:           \\n                k, v = seen.popitem()\\n                while k != prefix_sum:\\n                    k, v = seen.popitem()\\n                seen[k] = v\\n            else:\\n\\t\\t\\t    # add non zero-sum elements\\n                seen[prefix_sum] = head\\n            \\n            head = head.next\\n        \\n\\t\\t# rebuild the linkedlist\\n        ret = dummy\\n        for i, k in enumerate(seen):\\n            if i > 0:\\n                ret.next = seen[k]\\n                ret = ret.next\\n        \\n        ret.next = None\\n        \\n        return dummy.next\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 370857,
                "title": "python-prefix-sum-solution-with-updated-oj",
                "content": "I think OJ is updated. Now it will judge the answer correctly.\\n\\nMy solution uses a hashMap to save all the nodes based on their prefix sum. Nodes with the same prefix sum will point to the last node\\'s next.\\n\\nI have drawn a graph to futher explain it.\\n\\nTest Case: [1,3,2,-3,-2,5,5,-5,1]\\nResult: [1,5,1]\\n![image](https://assets.leetcode.com/users/hl1117/image_1567187677.png)\\n\\n\\nCodes here:\\n\"\"\"\\n\\n    def removeZeroSumSublists(self, head):\\n\\n        dummy = ListNode(-1)\\n        dummy.next= head\\n        ###### save all nodes into dictionary base on their prefix sum\\n        dic = {0: [dummy]}\\n        # current sum \\n        curSum = 0\\n        \\n        # save all the node into hashmap based on their prefix sum\\n        while head:\\n            curSum += head.val\\n            if curSum not in dic:\\n                dic[curSum] = []\\n            dic[curSum].append(head)\\n            head = head.next\\n            \\n        # update nodes with same prefix sum\\n        for nodes in dic.values():\\n            for i in range(len(nodes) - 1):\\n                nodes[i].next = nodes[-1].next\\n        return dummy.next\\n\"\"\"\\n\\n",
                "solutionTags": [],
                "code": "I think OJ is updated. Now it will judge the answer correctly.\\n\\nMy solution uses a hashMap to save all the nodes based on their prefix sum. Nodes with the same prefix sum will point to the last node\\'s next.\\n\\nI have drawn a graph to futher explain it.\\n\\nTest Case: [1,3,2,-3,-2,5,5,-5,1]\\nResult: [1,5,1]\\n![image](https://assets.leetcode.com/users/hl1117/image_1567187677.png)\\n\\n\\nCodes here:\\n\"\"\"\\n\\n    def removeZeroSumSublists(self, head):\\n\\n        dummy = ListNode(-1)\\n        dummy.next= head\\n        ###### save all nodes into dictionary base on their prefix sum\\n        dic = {0: [dummy]}\\n        # current sum \\n        curSum = 0\\n        \\n        # save all the node into hashmap based on their prefix sum\\n        while head:\\n            curSum += head.val\\n            if curSum not in dic:\\n                dic[curSum] = []\\n            dic[curSum].append(head)\\n            head = head.next\\n            \\n        # update nodes with same prefix sum\\n        for nodes in dic.values():\\n            for i in range(len(nodes) - 1):\\n                nodes[i].next = nodes[-1].next\\n        return dummy.next\\n\"\"\"\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 367739,
                "title": "python-hashtable-prefix-sum-20ms-beats-100",
                "content": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(-1)\\n        d[0] = dummy\\n        dummy.next = head\\n        curr = head\\n        prefix_sum = 0\\n        while curr:\\n            prefix_sum += curr.val\\n            if prefix_sum in d:\\n                node = d[prefix_sum]\\n                node.next = curr.next\\n            else:\\n                d[prefix_sum] = curr\\n                \\n            curr = curr.next\\n            \\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(-1)\\n        d[0] = dummy\\n        dummy.next = head\\n        curr = head\\n        prefix_sum = 0\\n        while curr:\\n            prefix_sum += curr.val\\n            if prefix_sum in d:\\n                node = d[prefix_sum]\\n                node.next = curr.next\\n            else:\\n                d[prefix_sum] = curr\\n                \\n            curr = curr.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367016,
                "title": "java-prefix-sum-approach",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int sum = 0;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            map.putIfAbsent(sum, head);\\n            if (map.containsKey(sum)) {\\n                map.get(sum).next = head.next;\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int sum = 0;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            map.putIfAbsent(sum, head);\\n            if (map.containsKey(sum)) {\\n                map.get(sum).next = head.next;\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569607,
                "content": [
                    {
                        "username": "abhinav_singh22",
                        "content": "When you run `[1, 2, 3, 4, -10, 1, 3, -3]` as custom test case, the expected answer shows: `[1,3,-3]` which is wrong.\\n\\nEdit: The test cases are fixed now."
                    },
                    {
                        "username": "Solo_driver07",
                        "content": "that is right"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "you can run your test case in my code ..\\n"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discussion/comments/1569607"
                    },
                    {
                        "username": "her0e1c1",
                        "content": "test returns [3,1,5,-2,2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1572956,
                "content": [
                    {
                        "username": "abhinav_singh22",
                        "content": "When you run `[1, 2, 3, 4, -10, 1, 3, -3]` as custom test case, the expected answer shows: `[1,3,-3]` which is wrong.\\n\\nEdit: The test cases are fixed now."
                    },
                    {
                        "username": "Solo_driver07",
                        "content": "that is right"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "you can run your test case in my code ..\\n"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discussion/comments/1569607"
                    },
                    {
                        "username": "her0e1c1",
                        "content": "test returns [3,1,5,-2,2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761885,
                "content": [
                    {
                        "username": "abhinav_singh22",
                        "content": "When you run `[1, 2, 3, 4, -10, 1, 3, -3]` as custom test case, the expected answer shows: `[1,3,-3]` which is wrong.\\n\\nEdit: The test cases are fixed now."
                    },
                    {
                        "username": "Solo_driver07",
                        "content": "that is right"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "you can run your test case in my code ..\\n"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discussion/comments/1569607"
                    },
                    {
                        "username": "her0e1c1",
                        "content": "test returns [3,1,5,-2,2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Sorted Vowel Strings",
        "question_content": "<p>Given an integer <code>n</code>, return <em>the number of strings of length </em><code>n</code><em> that consist only of vowels (</em><code>a</code><em>, </em><code>e</code><em>, </em><code>i</code><em>, </em><code>o</code><em>, </em><code>u</code><em>) and are <strong>lexicographically sorted</strong>.</em></p>\n\n<p>A string <code>s</code> is <strong>lexicographically sorted</strong> if for all valid <code>i</code>, <code>s[i]</code> is the same as or comes before <code>s[i+1]</code> in the alphabet.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The 5 sorted strings that consist of vowels only are <code>[&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;].</code>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> The 15 sorted strings that consist of vowels only are\n[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;].\nNote that &quot;ea&quot; is not a valid string since &#39;e&#39; comes after &#39;a&#39; in the alphabet.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 33\n<strong>Output:</strong> 66045\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code>&nbsp;</li>\n</ul>\n",
        "solutions": [
            {
                "id": 918498,
                "title": "java-c-python-dp-o-1-time-space",
                "content": "# **Explanation**\\n`dp[n][k]` means the number of strings constructed by at most `k` different characters.\\n\\nIf `k = 1`, use only `u`\\nIf `k = 2`, use only `o,u`\\nIf `k = 3`, use only `i,o,u`\\nIf `k = 4`, use only `e,i,o,u`\\nIf `k = 5`, use only `a,e,i,o,u`\\n<br>\\n\\n\\n# Solution 1: Top Down\\nTime `O(nk)`\\nSpace `O(nk)`\\nwhere k = 5\\n\\n**Python:**\\n```py\\n    def countVowelStrings(self, n):\\n        seen = {}\\n        def dp(n, k):\\n            if k == 1 or n == 1: return k\\n            if (n, k) in seen:\\n                return seen[n, k]\\n            seen[n, k] = sum(dp(n - 1, k) for k in xrange(1, k + 1))\\n            return seen[n, k]\\n        return dp(n, 5)\\n```\\n\\n# Solution 2: Bottom Up\\nTime `O(nk)`\\nSpace `O(nk)`\\nwhere k = 5\\n\\n**Java:**\\n```java\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n + 1][6];\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[i][k] = dp[i][k - 1] + (i > 1 ? dp[i - 1][k] : 1);\\n        return dp[n][5];\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n + 1, vector<int>(6));\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[i][k] = dp[i][k - 1] + (i > 1 ? dp[i - 1][k] : 1);\\n        return dp[n][5];\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def countVowelStrings(self, n):\\n        dp = [[1] * 6] + [[0] * 6 for i in xrange(n)]\\n        for i in xrange(1, n + 1):\\n            for k in xrange(1, 6):\\n                dp[i][k] = dp[i][k - 1] + dp[i - 1][k]\\n        return dp[n][5]\\n```\\n<br>\\n\\n# Solution 3: Bottom up, 1D DP\\nTime `O(nk)`\\nSpace `O(k)`\\nwhere k = 5\\n\\n**Java:**\\n```java\\n    public int countVowelStrings(int n) {\\n        int[] dp = new int[] {0, 1, 1, 1, 1, 1};\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[k] += dp[k - 1];\\n        return dp[5];\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int countVowelStrings(int n) {\\n        vector<int> dp = {0,1,1,1,1,1};\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[k] += dp[k - 1];\\n        return dp[5];\\n    }\\n```\\n**Python:**\\n```py\\n    def countVowelStrings(self, n):\\n        dp = [0] + [1] * 5\\n        for i in xrange(1, n + 1):\\n            for k in xrange(1, 6):\\n                dp[k] += dp[k - 1]\\n        return dp[5]\\n```\\n**Python3**\\n```py\\n    def countVowelStrings(self, n: int) -> int:\\n        dp = [1] * 5\\n        for i in range(n):\\n            dp = accumulate(dp)\\n        return list(dp)[-1]\\n```\\n<br>\\n\\n# Solution 4: Combination number\\nNow we have `n` characters, we are going to insert 4 `l` inside.\\nWe can add in the front, in the middle and in the end.\\nHow many ways do we have?\\nFor the 1st `l`, we have `n+1` position to insert.\\nFor the 2nd `l`, we have `n+2` position to insert.\\nFor the 3rd `l`, we have `n+3` position to insert.\\nFor the 4th `l`, we have `n+4` position to insert.\\nAlso 4 `l` are the same,\\nthere are `(n + 1) * (n + 2) * (n + 3) * (n + 4) / 4!` ways.\\n\\nThe character before the 1st `l`, we set to `a`.\\nThe character before the 2nd `l`, we set to `e`.\\nThe character before the 3rd `l`, we set to `i`.\\nThe character before the 4th `l`, we set to `o`.\\nThe character before the 5th `l`, we set to `u`.\\n\\nWe get the one result for the oringinal problem.\\n\\nTime `O(1)`\\nSpace `O(1)`\\n\\n**Java:**\\n```java\\n    public int countVowelStrings(int n) {\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int countVowelStrings(int n) {\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n    }\\n```\\n**Python:**\\n```py\\n    def countVowelStrings(self, n):\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24\\n```\\n**Python3**\\n@imaginary_user\\n```py\\n    def countVowelStrings(self, n: int) -> int:\\n        return comb(n + 4, 4)\\n```",
                "solutionTags": [],
                "code": "```py\\n    def countVowelStrings(self, n):\\n        seen = {}\\n        def dp(n, k):\\n            if k == 1 or n == 1: return k\\n            if (n, k) in seen:\\n                return seen[n, k]\\n            seen[n, k] = sum(dp(n - 1, k) for k in xrange(1, k + 1))\\n            return seen[n, k]\\n        return dp(n, 5)\\n```\n```java\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n + 1][6];\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[i][k] = dp[i][k - 1] + (i > 1 ? dp[i - 1][k] : 1);\\n        return dp[n][5];\\n    }\\n```\n```cpp\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n + 1, vector<int>(6));\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[i][k] = dp[i][k - 1] + (i > 1 ? dp[i - 1][k] : 1);\\n        return dp[n][5];\\n    }\\n```\n```py\\n    def countVowelStrings(self, n):\\n        dp = [[1] * 6] + [[0] * 6 for i in xrange(n)]\\n        for i in xrange(1, n + 1):\\n            for k in xrange(1, 6):\\n                dp[i][k] = dp[i][k - 1] + dp[i - 1][k]\\n        return dp[n][5]\\n```\n```java\\n    public int countVowelStrings(int n) {\\n        int[] dp = new int[] {0, 1, 1, 1, 1, 1};\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[k] += dp[k - 1];\\n        return dp[5];\\n    }\\n```\n```cpp\\n    int countVowelStrings(int n) {\\n        vector<int> dp = {0,1,1,1,1,1};\\n        for (int i = 1; i <= n; ++i)\\n            for (int k = 1; k <= 5; ++k)\\n                dp[k] += dp[k - 1];\\n        return dp[5];\\n    }\\n```\n```py\\n    def countVowelStrings(self, n):\\n        dp = [0] + [1] * 5\\n        for i in xrange(1, n + 1):\\n            for k in xrange(1, 6):\\n                dp[k] += dp[k - 1]\\n        return dp[5]\\n```\n```py\\n    def countVowelStrings(self, n: int) -> int:\\n        dp = [1] * 5\\n        for i in range(n):\\n            dp = accumulate(dp)\\n        return list(dp)[-1]\\n```\n```java\\n    public int countVowelStrings(int n) {\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n    }\\n```\n```cpp\\n    int countVowelStrings(int n) {\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n    }\\n```\n```py\\n    def countVowelStrings(self, n):\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24\\n```\n```py\\n    def countVowelStrings(self, n: int) -> int:\\n        return comb(n + 4, 4)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 918507,
                "title": "java-dp-o-n-time-easy-to-understand",
                "content": "time: O(n)\\nspace: O(1)\\njust think about the mathematical induction\\nif we know all the string of len k, so the string of len k + 1 will be\\n1 add a before all string of len k\\n2 add e before  the string of len k, which is starts with or after e\\n3 add i before  the string of len k, which starts with or after i\\n4 add o before  the string of len k, which starts with or after o\\n5 add u before  the string of len k, which starts with or after u\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while(n > 1) {\\n\\t\\t\\t// add new char before prev string\\n            a = (a + e + i + o + u); // a, e, i, o, u -> aa, ae, ai, ao, au\\n            e = (e + i + o + u); // e, i, o, u -> ee, ei, eo, eu\\n            i = (i + o + u); // i, o, u -> ii, io, iu\\n            o = (o + u); // o, u -> oo, ou\\n            u = (u);; // u -> uu\\n            n--;\\n        }\\n        \\n        return a + e + i + o + u;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while(n > 1) {\\n\\t\\t\\t// add new char before prev string\\n            a = (a + e + i + o + u); // a, e, i, o, u -> aa, ae, ai, ao, au\\n            e = (e + i + o + u); // e, i, o, u -> ee, ei, eo, eu\\n            i = (i + o + u); // i, o, u -> ii, io, iu\\n            o = (o + u); // o, u -> oo, ou\\n            u = (u);; // u -> uu\\n            n--;\\n        }\\n        \\n        return a + e + i + o + u;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021493,
                "title": "one-line-solution-math-no-dp-no-big-integers-o-1-time-space",
                "content": "Let me start with the answer itself, you just need to return the following:\\n\\n![image](https://assets.leetcode.com/users/images/1c609db6-788a-4742-b5ca-35c53c57611b_1610888570.431183.png)\\n\\nFor example, in Ruby:\\n```\\ndef count_vowel_strings(n)\\n  (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24\\nend\\n```\\n\\nSee the explained solution further down.\\n\\n# 1. Simplify the problem\\nThe \"vowels\" part in the problem statement makes it more confusing and makes it sound more complex, let\\'s rephrase it using numbers:\\n\\n> Given an integer n, return the number of numbers of length n that consist only of digits 1 to 5 and all digits are non-decreasing.\\n\\nFor example, given `n = 2`, we need to count: 11, 12, 13, 14, 15, 22, 23, 24, 25, 33, 34, 35, 44, 45, 55.\\n\\nThe answer to the rephrased problem will be the same as to the original problem, these problems are equivalent. \\n\\n# 2. Solve the simple problem\\nThe problem defined in part 1 is known as a problem counting the number of **combinations with repetitions**.\\nIn particular, we need to choose **n** digits from the pool of **5** digits with repetitions.\\n\\nWhy combinations, but not permutations? Because the number needs to be sorted (the digits should be non-decreasing), so we need to only count \"112\", but not \"121\", \"211\".\\n\\nThe easiest way to calculate the number of combinations with repetitions is to use the folowing formula:\\n![image](https://assets.leetcode.com/users/images/cea1928c-012e-48f6-b8ad-88686529d7cb_1610888870.9998922.png)\\n\\n\\n\\nIf we apply this formula to our problem where we choose n from 5 (k = n, n = 5), it can be then simplified to this:\\n![image](https://assets.leetcode.com/users/images/29776b71-5d21-4319-a998-f3cb6f668f5a_1610888920.7676246.png)\\n\\n\\n\\nwhich is the answer!\\n\\nThank you for reading through :)\\n",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\ndef count_vowel_strings(n)\\n  (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2027503,
                "title": "multiple-c-solutions-with-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n- Here we can observe a pattern to this problem.\\n\\n```\\n\\t\\t  a  e  i  o  u\\n    n=1   1  1  1  1  1  /a, e, i, o, u\\n    n=2   5  4  3  2  1  /a-> aa,ae,ai,ao,au | e-> ee,ei,eo,eu | i-> ii,io,iu | o-> oo,ou | u-> uu\\n    n=3   15 10 6  3  1\\n```\\n\\n- If we observe from last there will be only 1 element which will start with u. Every other element will have the count of previous count + next element count. As example\\nin n=2, i will be previous i(1) + count of next element, o(2) \\u2192 3\\nin n=3, e will be previous e(4) + count of next element, i(6) \\u2192 10\\n\\n### Solution 01\\n\\n- Using ***5 variables.***\\n- Here we are adding previous value with the current next element with serial of a-e-i-o-u.\\n- Return by adding every element.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Using ***dp.***\\n- Here we\\u2019re taking a vector of 5 sizes and initialising with 1.\\n- Iterating from the 2nd last & add the next element to the present element.\\n- Return the sum of every vector element.\\n- **Time complexity:** O(3n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a=1, e=1, i=1, o=1, u=1;\\n        \\n        while(--n){\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        \\n        return a+e+i+o+u;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        int ans = 0;\\n        \\n        while(--n){\\n            for(int i=3; i>=0; i--){\\n                dp[i] += dp[i+1];\\n            }\\n        }\\n        \\n        for(auto x:dp) ans += x;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t\\t  a  e  i  o  u\\n    n=1   1  1  1  1  1  /a, e, i, o, u\\n    n=2   5  4  3  2  1  /a-> aa,ae,ai,ao,au | e-> ee,ei,eo,eu | i-> ii,io,iu | o-> oo,ou | u-> uu\\n    n=3   15 10 6  3  1\\n```\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a=1, e=1, i=1, o=1, u=1;\\n        \\n        while(--n){\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        \\n        return a+e+i+o+u;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        int ans = 0;\\n        \\n        while(--n){\\n            for(int i=3; i>=0; i--){\\n                dp[i] += dp[i+1];\\n            }\\n        }\\n        \\n        for(auto x:dp) ans += x;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027881,
                "title": "vowels-count-simple-math-faster",
                "content": "Hi,\\n\\nWhen we do some paper work for this we could see that vowel \\'a\\' will have all the values including \\'a\\', where as vowel \\'e\\' will have all the letter except \\'a\\'.. as it is already covered in \\'a\\'.\\n\\na -> aa, ae, ai, ao, au\\ne -> ee, ei, eo, eu\\ni -> ii, io, iu\\n0 -> oo, ou\\nu -> uu\\n\\nBecause if we add e with a its again ae, so its already covered while sorting it lexicographically.\\nSo we don\\'t have to append the lexicographically smaller alphabet with bigger one.\\n\\nso the basic math for doing the same is ->\\n1) Initially all the vowels will be 1\\n2) Then each step vowels will go by following figure a = a+e+i+o+u, e = e+i+o+u, i=i+o+u.. etc., \\n3) Till we reach the given number repeat the process\\n\\nKindly upvote if it helps, happy learning\\n\\n```\\n\\tint a=1, e=1, i=1, o=1, u=1;\\n    public int countVowelStrings(int n) { \\n    \\tfor(int j=1; j<n; j++){\\n        \\tincrement();\\n        }\\n    \\treturn a+e+i+o+u;\\n    }\\n\\n    private void increment() {\\n\\t\\ta = a+e+i+o+u;\\n\\t\\te = e+i+o+u;\\n\\t\\ti = i+o+u;\\n\\t\\to = o+u;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nWhen we do some paper work for this we could see that vowel \\'a\\' will have all the values including \\'a\\', where as vowel \\'e\\' will have all the letter except \\'a\\'.. as it is already covered in \\'a\\'.\\n\\na -> aa, ae, ai, ao, au\\ne -> ee, ei, eo, eu\\ni -> ii, io, iu\\n0 -> oo, ou\\nu -> uu\\n\\nBecause if we add e with a its again ae, so its already covered while sorting it lexicographically.\\nSo we don\\'t have to append the lexicographically smaller alphabet with bigger one.\\n\\nso the basic math for doing the same is ->\\n1) Initially all the vowels will be 1\\n2) Then each step vowels will go by following figure a = a+e+i+o+u, e = e+i+o+u, i=i+o+u.. etc., \\n3) Till we reach the given number repeat the process\\n\\nKindly upvote if it helps, happy learning\\n\\n```\\n\\tint a=1, e=1, i=1, o=1, u=1;\\n    public int countVowelStrings(int n) { \\n    \\tfor(int j=1; j<n; j++){\\n        \\tincrement();\\n        }\\n    \\treturn a+e+i+o+u;\\n    }\\n\\n    private void increment() {\\n\\t\\ta = a+e+i+o+u;\\n\\t\\te = e+i+o+u;\\n\\t\\ti = i+o+u;\\n\\t\\to = o+u;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 918760,
                "title": "dynamic-programming-python-100-explanation-code",
                "content": "In this problem, the pattern I observed was prepending \\'a\\' to all the strings of length n-1 does not affect any order. Similarly, \\'e\\' can be prepended to strings starting with \\'e\\' and greater vowels and so on.\\n\\nSo we have our subproblem.\\n\\n**How do we fill the DP Table?**\\nLets, take an example of n = 3\\n\\n![image](https://assets.leetcode.com/users/images/b9b6fce5-8a9a-4428-a969-6dc9beb4f028_1604210585.3769555.png)\\n\\nFor n = 1, number of strings starting with u is 1, with o is 2 (including the ones starting with u) and so on.\\nFor n = 2, number of strings starting with u is 1, but for o its (number of strings of length 2 starting with u + number of strings of length 1 starting with o) and so on.\\ndp[i][j] represents total no. of string of length i , starting with characters of column j and after j. (Thanks @[rkm_coder](https://leetcode.com/rkm_coder/) for the correction)\\n\\nThe recursive expression is : dp[i][j] = dp[i - 1][j] + dp[i][j + 1]\\n\\nFinally, we will get our answer at dp[n][0]\\n\\nThe running time of my algorithm is **O(n)**\\n\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        dp = [[i for i in range(5,0,-1)] for _ in range(n)]   # intialize dp matrix\\n        \\n        for i in range(1,n):\\n            for j in range(3,-1,-1):\\n                dp[i][j] = dp[i - 1][j] + dp[i][j + 1]   # dp expression\\n                \\n        return dp[n-1][0]\\n```\\n\\nAlso check out Java implementation here: https://leetcode.com/problems/count-sorted-vowel-strings/discuss/918728/java-dp-beats-100",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        dp = [[i for i in range(5,0,-1)] for _ in range(n)]   # intialize dp matrix\\n        \\n        for i in range(1,n):\\n            for j in range(3,-1,-1):\\n                dp[i][j] = dp[i - 1][j] + dp[i][j + 1]   # dp expression\\n                \\n        return dp[n-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918392,
                "title": "very-easy-solution-no-dp-no-math-formula-solving-for-n-3-reveals-the-pattern",
                "content": "\\nThe problem seems like it will have a typical recursive solution,\\nbut in reality it has a very trivial solution.\\n\\nImportant part of this problem is to regonize the pattern.\\n\\nFor `n = 3`, let\\'s see how many strings can be formed.\\n\\nIf start of the string is \"aa\", the third letter can be any of\\n`{a, e, i, o, u}` and the string will still be lexicographically\\nsorted. So there will be 5 strings. in total.\\nSo, say` \"aa\" -> 5`.\\nIf the start is \"ae\", the third letter can be `{e, i, o, u}`. \\nNote that `a` can\\'t be the third letter, otherwise the string \\nwill not be lexicographically sorted. So count of strings will\\nbe 4.\\nSo, say` \"ae\" -> 4.`\\nSimilarly, for `\"ai\" -> {i, o, u} -> 3`.\\n```\\n\"ao\" -> {o, u} -> 2.\\n\"au\" -> {u} -> 1.\\n```\\n\\nNow say start of the string is \"ee\".\\n```\\n\"ee\" -> {e, i, o, u} -> 4.\\n\"ei\" -> {i, o, u} -> 3.\\n\"eo\" -> {o, u} -> 2.\\n\"eu\" -> {u} -> 1.\\n```\\n\\nSimilarly,\\n```\\n\"ii\" -> {i, o, u} -> 3.\\n\"io\" -> {o, u} -> 2.\\n\"iu\" -> {u} -> 1.\\n\"oo\" -> {o, u} -> 2.\\n\"ou\" -> {u} -> 1.\\n\"uu\" -> {u} -> 1.```\\n```\\n\\n\\nHence in total, there would be -\\n\\n```\\n5 + 4 + 3 + 2 + 1 +\\n4 + 3 + 2 + 1 +\\n3 + 2 + 1 +\\n2 + 1 +\\n1 \\n= 35 \\n```\\n\\n\\nYou can also try the above pattern n = 2.\\n\\nHere is the very simple code. It can certainly be optized with a mathematical formula.\\nI kept it as is considering that n is very small anyway and not everyone would know the\\nformula.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int ans = 0;\\n        for (int j=1; j<=(n+1); j++) {\\n            int sum = 0;\\n            for (int i=1; i<=j; i++) {\\n                sum += i;\\n                ans += sum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\"ao\" -> {o, u} -> 2.\\n\"au\" -> {u} -> 1.\\n```\n```\\n\"ee\" -> {e, i, o, u} -> 4.\\n\"ei\" -> {i, o, u} -> 3.\\n\"eo\" -> {o, u} -> 2.\\n\"eu\" -> {u} -> 1.\\n```\n```\\n\"ii\" -> {i, o, u} -> 3.\\n\"io\" -> {o, u} -> 2.\\n\"iu\" -> {u} -> 1.\\n\"oo\" -> {o, u} -> 2.\\n\"ou\" -> {u} -> 1.\\n\"uu\" -> {u} -> 1.```\n```\\n\\n\\nHence in total, there would be -\\n\\n```\n```\\n\\n\\nYou can also try the above pattern n = 2.\\n\\nHere is the very simple code. It can certainly be optized with a mathematical formula.\\nI kept it as is considering that n is very small anyway and not everyone would know the\\nformula.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918613,
                "title": "intuitive-c-solution-with-explaination",
                "content": "The solution uses DP but in a way that I found much more intuitive. We start the solution from the right i.e. generate suffixes and keep prepending it to either a, e, i, o, or u.\\na = number of strings that start with a\\ne = number of strings that start with e\\ni = number of strings that start with i\\no = number of strings that start with o\\nu = number of strings that start with u\\n\\nSo, we can simply keep appending the string that starts with:\\n1. a to only string that has a at the beginning.\\n2. e to string that either has a or e at the beginning.\\n3. i to string that has a, e or i at the beginning.\\n.... And so on\\n\\n```\\nint countVowelStrings(int n) {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for(int j=2;j<=n;j++){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n    }\\n```\\nIf you got this, try https://codeforces.com/problemset/problem/166/E, it uses a similar approach.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelStrings(int n) {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for(int j=2;j<=n;j++){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1021397,
                "title": "count-sorted-vowel-strings-o-1-1-line-mathematical-solution-w-explanation",
                "content": "***Idea:***\\n\\nThe mathematical solution is derived from Pascal\\'s Triangle.\\n\\nThe formula for a triangular number is:\\n```\\n       x * (x + 1)\\n\\t  -------------\\n\\t      1 * 2\\n```\\n...and the formula for a tetrahedral number is:\\n```\\n       x * (x + 1) * (x + 2)\\n\\t  -----------------------\\n\\t         1 * 2 * 3\\n```\\n...so the formula for the nth-simplex number is:\\n```\\n       x * (x + 1) * (x + 2) * ... * (x + n - 1)\\n\\t  -------------------------------------------\\n\\t                      n!\\n```\\nWe\\'re dealing with a base of 5 vowels, so x = 5 and this formula starts to look like:\\n```\\n       5 * 6 * 7 * ... * (n + 4)\\n\\t  ---------------------------\\n\\t               n!\\n```\\n...but then we can realize that numbers start to cancel out from top to bottom, taking for example n = 10:\\n```\\n                       5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14\\n\\t  ------------------------------------------------------------\\n\\t   1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10\\n```\\nWe can factor out every number on the bottom greater than 4, and we\\'ll also have the last four remaining numbers on the top, so the final formula ends up:\\n```\\n       (n + 1) * (n + 2) * (n + 3) * (n + 4)\\n\\t  ---------------------------------------\\n\\t               1 * 2 * 3 * 4\\n```\\n\\n` `\\n***Code:***\\n\\n```\\nconst countVowelStrings = n => (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24\\n```",
                "solutionTags": [],
                "code": "```\\n       x * (x + 1)\\n\\t  -------------\\n\\t      1 * 2\\n```\n```\\n       x * (x + 1) * (x + 2)\\n\\t  -----------------------\\n\\t         1 * 2 * 3\\n```\n```\\n       x * (x + 1) * (x + 2) * ... * (x + n - 1)\\n\\t  -------------------------------------------\\n\\t                      n!\\n```\n```\\n       5 * 6 * 7 * ... * (n + 4)\\n\\t  ---------------------------\\n\\t               n!\\n```\n```\\n                       5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14\\n\\t  ------------------------------------------------------------\\n\\t   1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10\\n```\n```\\n       (n + 1) * (n + 2) * (n + 3) * (n + 4)\\n\\t  ---------------------------------------\\n\\t               1 * 2 * 3 * 4\\n```\n```\\nconst countVowelStrings = n => (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2027288,
                "title": "python-4-approaches-dp-maths",
                "content": "1. ##### DP Tabulation\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        dp = [[0] * 6 for _ in range(n+1)]\\n        for i in range(1, 6):\\n            dp[1][i] = i\\n        \\n        for i in range(2, n+1):\\n            dp[i][1]=1\\n            for j in range(2, 6):\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j]\\n        \\n        return dp[n][5]\\n```\\n**Time = O(n)**\\n**Space = O(n)**\\n\\n---\\n2. ##### O(1) Space\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        dp = [1] * 5\\n        \\n        for i in range(2, n+1):\\n            for j in range(4, -1, -1):\\n                dp[j] += sum(dp[:j])            \\n        \\n        return sum(dp)\\n```\\n\\nAlternative solution shared by [@koacosmos](https://leetcode.com/koacosmos/)\\n\\n```\\nclass Solution:\\n    def countVowelStrings(self, k: int) -> int:        \\n        dp = [1] * 5\\n                                \\n        for _ in range(1, k):\\n            for i in range(1, 5):                    \\n                dp[i] = dp[i] + dp[i-1]\\n        \\n        return sum(dp)\\n```\\n**Time = O(n)**\\n**Space = O(1)**\\n\\n---\\n\\n3. ##### Mathematical equation using [Combinations with repetition](https://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition)\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        return (n + 4) * (n + 3) * (n + 2) * (n + 1) // 24;\\n```\\n\\n---\\nSolution shared by [@nithinmanne1](https://leetcode.com/nithinmanne1/) using Python internal library.\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        return math.comb(n + 4, 4)\\n```\\n\\n**Time = O(1)\\nSpace = O(1)**\\n\\n----\\n\\nOther contributers of this post:\\n1. [@nithinmanne1](https://leetcode.com/nithinmanne1/)\\n2. [@koacosmos](https://leetcode.com/koacosmos/)\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        dp = [[0] * 6 for _ in range(n+1)]\\n        for i in range(1, 6):\\n            dp[1][i] = i\\n        \\n        for i in range(2, n+1):\\n            dp[i][1]=1\\n            for j in range(2, 6):\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j]\\n        \\n        return dp[n][5]\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        dp = [1] * 5\\n        \\n        for i in range(2, n+1):\\n            for j in range(4, -1, -1):\\n                dp[j] += sum(dp[:j])            \\n        \\n        return sum(dp)\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, k: int) -> int:        \\n        dp = [1] * 5\\n                                \\n        for _ in range(1, k):\\n            for i in range(1, 5):                    \\n                dp[i] = dp[i] + dp[i-1]\\n        \\n        return sum(dp)\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        return (n + 4) * (n + 3) * (n + 2) * (n + 1) // 24;\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:        \\n        return math.comb(n + 4, 4)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948749,
                "title": "beautiful-c-solution-100-faster",
                "content": "(Updated)\\n\\nThe variable a, e, i, o, or u means the number of strings ended with an a, e, I, o, or u with a given length.\\n\\nIn each iteration, we expend the length by 1. \\u2018a\\u2019 can only come after string ended with \\u2018a\\u2019, so the number of strings ended with an \\'a\\' remains unchanged. \\u2018e\\u2019 can be added to string ended with an \\u2018a\\u2019 or \\u2018e\\u2019, so we update the length using e\\u2019 = e + a. And so forth.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a = 1;\\n        int e = 1;\\n        int i = 1;\\n        int o = 1;\\n        int u = 1;\\n        \\n        while (--n){\\n            e += a;\\n            i += e;\\n            o += i;\\n            u += o;         \\n        }\\n        return a + e + i + o + u;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a = 1;\\n        int e = 1;\\n        int i = 1;\\n        int o = 1;\\n        int u = 1;\\n        \\n        while (--n){\\n            e += a;\\n            i += e;\\n            o += i;\\n            u += o;         \\n        }\\n        return a + e + i + o + u;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918399,
                "title": "python-simple-dp-solution-o-n-o-1",
                "content": "```Python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        \\n        a = e = i = o = u = 1\\n        for _ in range(n - 1):\\n            a, e, i, o, u = a+e+i+o+u, e+i+o+u, i+o+u, o+u, u\\n        \\n        return a+e+i+o+u\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        \\n        a = e = i = o = u = 1\\n        for _ in range(n - 1):\\n            a, e, i, o, u = a+e+i+o+u, e+i+o+u, i+o+u, o+u, u\\n        \\n        return a+e+i+o+u\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021180,
                "title": "python-start-and-bars-explained",
                "content": "Actually, this is very classical combinatorical problem, which can be solved, using so-called **stars and bars** method: https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics). Imagine, that we have string `aa..aee..eii..ioo..ouu..u`, where we have some numbers of `a, e, i, o` and `u`. Then we can look at this problem in the following way: we have `n + 4`, places, and on some of them we need to put bars `|`, for example `aaaeeiuu` is corresponding to `***|**|*||**`. So, final number of solutions is number of combinations from `n+4` to `4,` which can be evaluated as `(n+4)!/n!/4!`.\\n\\n**Complexity**: time and space complexity is `O(1)`, because `n` is small. One quick optimization is to use `(n+4)*(n+3)*(n+2)*(n+1)//24` formula, which will work faster for big `n`, but given problem constraints different is negligible.\\n\\n```\\nclass Solution:\\n    def countVowelStrings(self, n):\\n        return factorial(4+n)//factorial(4)//factorial(n)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n):\\n        return factorial(4+n)//factorial(4)//factorial(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918450,
                "title": "java-python-top-down-dp-clean-concise",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(n, i):\\n            if n == 0: return 1  # Found a valid answer\\n            if i == 5:  return 0  # Reach to length of vowels [a, e, i, o, u]\\n            ans = dp(n, i + 1)  # Skip vowels[i]\\n            ans += dp(n - 1, i)  # Include vowels[i]\\n            return ans\\n\\n        return dp(n, 0)\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        Integer[][] memo = new Integer[n + 1][5];\\n        return dp(n, 0, memo);\\n    }\\n\\n    int dp(int n, int i, Integer memo[][]) {\\n        if (n == 0) return 1; // Found a valid answer\\n        if (i == 5) return 0; // Reach to length of vowels [a, e, i, o, u]\\n        if (memo[n][i] != null) return memo[n][i];\\n        \\n        int ans = dp(n, i+1, memo); // Skip vowels[i]\\n        ans += dp(n-1, i, memo); // Include vowels[i]\\n        \\n        return memo[n][i] = ans;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time: `O(N * vowelsLen * 2)`, where `vowelsLen` is length of vowels (=5).\\n- Space: `O(N* vowelsLen)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(n, i):\\n            if n == 0: return 1  # Found a valid answer\\n            if i == 5:  return 0  # Reach to length of vowels [a, e, i, o, u]\\n            ans = dp(n, i + 1)  # Skip vowels[i]\\n            ans += dp(n - 1, i)  # Include vowels[i]\\n            return ans\\n\\n        return dp(n, 0)\\n```\n```java\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        Integer[][] memo = new Integer[n + 1][5];\\n        return dp(n, 0, memo);\\n    }\\n\\n    int dp(int n, int i, Integer memo[][]) {\\n        if (n == 0) return 1; // Found a valid answer\\n        if (i == 5) return 0; // Reach to length of vowels [a, e, i, o, u]\\n        if (memo[n][i] != null) return memo[n][i];\\n        \\n        int ans = dp(n, i+1, memo); // Skip vowels[i]\\n        ans += dp(n-1, i, memo); // Include vowels[i]\\n        \\n        return memo[n][i] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027686,
                "title": "dp-c-recursion-memoization-tabulation-well-commented",
                "content": "**Recursive Solution** **[ Time-Complexity = O(n^2),  Space-Complexity = O(n) ]**\\n\\t\\n ```\\n\\tint count(int i, int n, string &vowels){\\n\\n\\t\\t\\tif(n==0) return 1; // if a string of length n is formed\\n\\n\\t\\t\\tif(i>=5) return 0; // if i exceeds the length of vowels\\n\\n\\t\\t\\tint pick, notPick;\\n\\t\\t\\t// pick i.e. pick this alphabet\\n\\t\\t\\tpick= count(i, n-1, vowels);\\n\\t\\t\\t// notPick i.e. skip this alphabet\\n\\t\\t\\tnotPick= count(i+1, n, vowels);\\n\\n\\t\\t\\treturn pick + notPick;\\n\\t}\\n\\n\\tint countVowelStrings(int n) {\\n\\t\\t string vowels= \"aeiou\"; // all vowels in lexicographically sorted order\\n\\t\\t return count(0, n, vowels);\\n\\t}\\n\\t\\n```\\n\\t\\n**Memoization** **[ Time-Complexity = O(4 * n),  Space-Complexity = O(5 * n) + O(n) ]**\\n\\n\\n ```\\n\\tint count(int i, int n, string &vowels, vector<vector<int>> &dp){\\n\\n\\t\\t  if(n==0) return 1; // if a string of length n is formed\\n\\n\\t\\t  if(i>=5) return 0; // if i exceeds the length of vowels\\n\\n\\t\\t  if(dp[i][n]!=-1) return dp[i][n]; // check if dp already contains the answer\\n\\n\\t\\t  int pick, notPick;\\n\\t\\t  // pick i.e. pick this alphabet\\n\\t\\t  pick= count(i, n-1, vowels, dp);\\n\\t\\t  // notPick i.e. skip this alphabet\\n\\t\\t  notPick= count(i+1, n, vowels, dp);\\n\\n\\t\\t  return dp[i][n]= pick + notPick; // store the value in dp\\n\\t}\\n\\n\\tint countVowelStrings(int n) {\\n\\t\\t string vowels= \"aeiou\"; // all vowels in lexicographically sorted order\\n\\t\\t vector<vector<int>> dp(5, vector<int>(n+1, -1)); // declare dp vector\\n\\t\\t return count(0, n, vowels, dp);\\n\\t}\\n```\\n\\t\\n**Tabulation** **[ Time-Complexity = O(4 * n),  Space-Complexity = O(5 * n) ]**\\n\\n```\\n\\tint countVowelStrings(int n) {\\n\\n\\t\\tstring vowels= \"aeiou\"; // all vowels in lexicographically sorted order\\n\\n\\t\\tvector<vector<int>> dp(5, vector<int>(n+1)); // dp vector\\n\\n\\t\\t// base-case\\n\\t\\tfor(int i=0; i<5; ++i) dp[i][0]= 1; // if n==0 return 1\\n\\n\\t\\t// tabulation\\n\\t\\tfor(int i=4; i>=0; --i){\\n\\t\\t  for(int j=1; j<=n; ++j){\\n\\t\\t\\tint pick= 0, notPick= 0;\\n\\t\\t\\t// pick i.e. pick this alphabet\\n\\t\\t\\tpick= dp[i][j-1];\\n\\t\\t\\t// notPick i.e. skip this alphabet\\n\\t\\t\\tif(i<4) notPick= dp[i+1][j];\\n\\n\\t\\t\\tdp[i][j]= pick+notPick;\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn dp[0][n]; // return all strings possible starting from 0 index and of n length\\n\\t}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint count(int i, int n, string &vowels){\\n\\n\\t\\t\\tif(n==0) return 1; // if a string of length n is formed\\n\\n\\t\\t\\tif(i>=5) return 0; // if i exceeds the length of vowels\\n\\n\\t\\t\\tint pick, notPick;\\n\\t\\t\\t// pick i.e. pick this alphabet\\n\\t\\t\\tpick= count(i, n-1, vowels);\\n\\t\\t\\t// notPick i.e. skip this alphabet\\n\\t\\t\\tnotPick= count(i+1, n, vowels);\\n\\n\\t\\t\\treturn pick + notPick;\\n\\t}\\n\\n\\tint countVowelStrings(int n) {\\n\\t\\t string vowels= \"aeiou\"; // all vowels in lexicographically sorted order\\n\\t\\t return count(0, n, vowels);\\n\\t}\\n\\t\\n```\n```\\n\\tint count(int i, int n, string &vowels, vector<vector<int>> &dp){\\n\\n\\t\\t  if(n==0) return 1; // if a string of length n is formed\\n\\n\\t\\t  if(i>=5) return 0; // if i exceeds the length of vowels\\n\\n\\t\\t  if(dp[i][n]!=-1) return dp[i][n]; // check if dp already contains the answer\\n\\n\\t\\t  int pick, notPick;\\n\\t\\t  // pick i.e. pick this alphabet\\n\\t\\t  pick= count(i, n-1, vowels, dp);\\n\\t\\t  // notPick i.e. skip this alphabet\\n\\t\\t  notPick= count(i+1, n, vowels, dp);\\n\\n\\t\\t  return dp[i][n]= pick + notPick; // store the value in dp\\n\\t}\\n\\n\\tint countVowelStrings(int n) {\\n\\t\\t string vowels= \"aeiou\"; // all vowels in lexicographically sorted order\\n\\t\\t vector<vector<int>> dp(5, vector<int>(n+1, -1)); // declare dp vector\\n\\t\\t return count(0, n, vowels, dp);\\n\\t}\\n```\n```\\n\\tint countVowelStrings(int n) {\\n\\n\\t\\tstring vowels= \"aeiou\"; // all vowels in lexicographically sorted order\\n\\n\\t\\tvector<vector<int>> dp(5, vector<int>(n+1)); // dp vector\\n\\n\\t\\t// base-case\\n\\t\\tfor(int i=0; i<5; ++i) dp[i][0]= 1; // if n==0 return 1\\n\\n\\t\\t// tabulation\\n\\t\\tfor(int i=4; i>=0; --i){\\n\\t\\t  for(int j=1; j<=n; ++j){\\n\\t\\t\\tint pick= 0, notPick= 0;\\n\\t\\t\\t// pick i.e. pick this alphabet\\n\\t\\t\\tpick= dp[i][j-1];\\n\\t\\t\\t// notPick i.e. skip this alphabet\\n\\t\\t\\tif(i<4) notPick= dp[i+1][j];\\n\\n\\t\\t\\tdp[i][j]= pick+notPick;\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn dp[0][n]; // return all strings possible starting from 0 index and of n length\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1193637,
                "title": "3-different-solutions-backtracking-dynamic-programming-math",
                "content": "\\n\\n**Backtracking solution:**\\n**Time complexity:** `O(n^5)`\\nWe try all the possibilities where adding the new vowel doesn\\'t break the lexicographic order. For example, if the last character of our actual possibility is \\'e\\', we can\\'t add an \\'a\\' after it.\\n```\\ndef count(n, last=\\'\\'):\\n    if n == 0:\\n        return 1\\n    else:\\n        nb = 0\\n        for vowel in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n            if last <= vowel:\\n                nb += count(n-1, vowel)\\n        return nb\\n```\\n\\n\\n**Dynamic programming solution:**\\n**Time complexity:** `O(n)`\\nWe use a dp matrix of n rows and 5 columns (one column for each vowel) where the number of strings of size k that start with a vowel v is the sum of strings of size k-1 with whom we can add the vowel v from the beginning without breaking the order\\nWe can add \\'a\\' before any vowel string without breaking the order, so the number of strings of size k that start with \\'a\\' is the number of strings of size k-1 that start with \\'a\\', \\'e\\', \\'i\\', \\'o\\', or \\'u\\'\\nWe can add \\'e\\' before strings that start with \\'e\\', \\'i\\', \\'o\\', or \\'u\\' without breaking the order, so the number of strings of size k that start with \\'e\\' is the number of strings of size k-1 that start with \\'e\\', \\'i\\', \\'o\\', or \\'u\\'\\nSame logic with remaining vowels (\\'i\\' -> \\'i\\', \\'o\\', or \\'u\\' / \\'o\\' -> \\'o\\' or \\'u\\' / \\'u\\' -> \\'u\\')\\nAfter filling the matrix, the last row will contain the numbers of strings of size n with each vowel, we do the sum\\n```\\ndef count(n):\\n    NB_VOWELS = 5\\n    dp = [[0]*NB_VOWELS for i in range(n)]\\n    dp[0] = [1]*NB_VOWELS\\n    for i in range(1, len(dp)):\\n        dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3] + dp[i-1][4] # a\\n        dp[i][1] = dp[i-1][1] + dp[i-1][2] + dp[i-1][3] + dp[i-1][4] # e\\n        dp[i][2] = dp[i-1][2] + dp[i-1][3] + dp[i-1][4] # i\\n        dp[i][3] = dp[i-1][3] + dp[i-1][4] # o\\n        dp[i][4] = dp[i-1][4] # u\\n    return sum(dp[-1])\\n```\\n\\n\\n**Math solution:**\\n**Time complexity:** `O(1)`\\nThe number of possible sorted strings that we can get by taking n vowels from 5 possible vowels is the number of possible combinations with repetition that we can get by taking n elements from 5 possible elements, and we have a mathematical law for that\\n\\n![image](https://assets.leetcode.com/users/images/e2537376-77ad-4a4d-be05-07c99acad58d_1620271631.6924222.png)\\n\\n```\\ndef count(n):\\n    return (n+4)*(n+3)*(n+2)*(n+1)//24\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\ndef count(n, last=\\'\\'):\\n    if n == 0:\\n        return 1\\n    else:\\n        nb = 0\\n        for vowel in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n            if last <= vowel:\\n                nb += count(n-1, vowel)\\n        return nb\\n```\n```\\ndef count(n):\\n    NB_VOWELS = 5\\n    dp = [[0]*NB_VOWELS for i in range(n)]\\n    dp[0] = [1]*NB_VOWELS\\n    for i in range(1, len(dp)):\\n        dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3] + dp[i-1][4] # a\\n        dp[i][1] = dp[i-1][1] + dp[i-1][2] + dp[i-1][3] + dp[i-1][4] # e\\n        dp[i][2] = dp[i-1][2] + dp[i-1][3] + dp[i-1][4] # i\\n        dp[i][3] = dp[i-1][3] + dp[i-1][4] # o\\n        dp[i][4] = dp[i-1][4] # u\\n    return sum(dp[-1])\\n```\n```\\ndef count(n):\\n    return (n+4)*(n+3)*(n+2)*(n+1)//24\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1021273,
                "title": "python-one-liner-solution-o-1-time-space",
                "content": "Some combinatorics:\\nIt is known that the characters should appear in ascending lexicographic order.\\nIt is known that there are a total of 5 characters.\\nConclusion: There are only 4 places where the character is replaced by the one followed by the sorted order.\\nWe have n + 4 locations in total.\\nHence, the answer is (using a binomial coefficient): n + 4 C 4\\nAfter we simplify the above expression, we will get the solution in front of you.\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countVowelStrings(self, n: int) -> int:\\n\\t\\t\\treturn ((n + 1) * (n + 2) * (n + 3) * (n + 4)) // 24\\n\\nI sincerely hope you understood.\\nIf there are any more questions, feel free to ask.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Some combinatorics:\\nIt is known that the characters should appear in ascending lexicographic order.\\nIt is known that there are a total of 5 characters.\\nConclusion: There are only 4 places where the character is replaced by the one followed by the sorted order.\\nWe have n + 4 locations in total.\\nHence, the answer is (using a binomial coefficient): n + 4 C 4\\nAfter we simplify the above expression, we will get the solution in front of you.\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countVowelStrings(self, n: int) -> int:\\n\\t\\t\\treturn ((n + 1) * (n + 2) * (n + 3) * (n + 4)) // 24\\n\\nI sincerely hope you understood.\\nIf there are any more questions, feel free to ask.",
                "codeTag": "Java"
            },
            {
                "id": 918619,
                "title": "c-4-lines-dp-solution",
                "content": "When `n = 2`, the only valid string starting with `u` is `uu`, valid strings starting with `o` are `[oo, ou]`, and so on. The numbers (we use a vector `cnt` to store them) of valid strings starting with `a, e, i, o, u` are respectively `[5,4,3,2,1]`. \n\nWhen `n = 3`, the only valid string starting with `u` is `uuu`, valid strings starting with `o` are `[ooo, oou, ouu]`, and so on. The numbers of valid strings starting with `a, e, i, o, u` are respectively `[15,10,6,3,1]`. \n\nA typical DP problem, and you can find the pattern here: during each iteration over `1 ~ n`, the values of `cnt` can be calculated with its 'previous values'.\n\n```c++\nclass Solution {\npublic:\n  int countVowelStrings(int n) {\n    vector<int64_t> cnt(5, 1);\n    for (int i = 1; i < n; i++)\n      for (int j = 3; j >= 0; j--) cnt[j] += cnt[j + 1];\n    return std::accumulate(cnt.begin(), cnt.end(), 0);\n  }\n};\n```",
                "solutionTags": [],
                "code": "```c++\nclass Solution {\npublic:\n  int countVowelStrings(int n) {\n    vector<int64_t> cnt(5, 1);\n    for (int i = 1; i < n; i++)\n      for (int j = 3; j >= 0; j--) cnt[j] += cnt[j + 1];\n    return std::accumulate(cnt.begin(), cnt.end(), 0);\n  }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 931037,
                "title": "c-backtracking-vs-dynamic-programming-beats-100-0",
                "content": "First I tried backtracking and find a solution but runtime is ~1200 ms and beats 5.0% only:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int countVowelStrings(int n) {\\n        int count = 0;\\n        countVowelStringsHelper(n, \\' \\', count);\\n        return count;\\n    }\\n    void countVowelStringsHelper(int n, char last, int &count){\\n        if(n == 0){\\n            count++;\\n        }\\n        else{\\n            for(auto e: vowels){\\n                if(last <= e){\\n                    countVowelStringsHelper(n-1, e, count);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\nDP Solution:\\n```\\nn=1, dp = {1,2,3,4,5}      return 5\\nn=2, dp = {1,3,6,10,15}    return 15\\nn=3, dp = {1,4,10,20,35}   return 35\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<5; j++){\\n                dp[j] = dp[j-1] + dp[j];\\n            }\\n        }\\n        return dp[4];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int countVowelStrings(int n) {\\n        int count = 0;\\n        countVowelStringsHelper(n, \\' \\', count);\\n        return count;\\n    }\\n    void countVowelStringsHelper(int n, char last, int &count){\\n        if(n == 0){\\n            count++;\\n        }\\n        else{\\n            for(auto e: vowels){\\n                if(last <= e){\\n                    countVowelStringsHelper(n-1, e, count);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```\\nn=1, dp = {1,2,3,4,5}      return 5\\nn=2, dp = {1,3,6,10,15}    return 15\\nn=3, dp = {1,4,10,20,35}   return 35\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<5; j++){\\n                dp[j] = dp[j-1] + dp[j];\\n            }\\n        }\\n        return dp[4];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924402,
                "title": "java-0-ms-faster-than-100-easy-to-understand-with-explanation",
                "content": "Time Complexity - O(n)\\nSpace Complexity - O(1)\\n\\nOn carefully observing the sequence getting formed you will notice a pattern here:\\n\\nFor n = 1 : a , e , i, o, u  \\nString starting with a = 1, e  = 1, i = 1, o = 1, u = 1 : Total = 5\\n\\nFor n = 2 : aa, ae, ai, ao, au, ee, ei, eo, eu, ii, io, iu, oo, ou, uu \\nString starting with a = 5, e = 4, i = 3, o = 2, u = 1 : Total = 15\\n\\nFor n = 3 : aaa, aae, aai, aao, aau, aee, aei, aeo, aeu, aii, aio, aiu, aoo, aou, auu, eee, eei, eeo,eeu,eii, eio, eiu, eoo, eou, euu, iii, iio, iiu, ioo, iou, iuu, ooo, oou, ouu, uuu : Total = 35\\n\\nOn carefully observing :\\nFor n = 2 : All the sequence formed count is equal to sum of previous sequences (i.e. n  = 1) starting with a, e, i, o, u\\n                 a =  a + e + i + o + u (1 + 1 + 1 + 1+ 1) = 5\\n\\t\\t\\t\\t e = e + i + o +u (1 + 1+ 1+ 1) = 4\\n\\t\\t\\t\\t  i = i + o + u (1 + 1 + 1) = 3\\n\\t\\t\\t\\t  o = o + u ( 1 + 1) = 2\\n\\t\\t\\t\\t  u = u (1) = 1\\n\\t\\t\\t\\t  Total = a + e + i + o + u = 5 + 4 + 3 + 2 + 1 = 15\\n\\t\\t\\t\\t  \\nFor n = 3: All the sequence formed count is equal to sum of previous sequences (i.e. n = 2) starting with a, e, i, o, u \\n                 a =  a + e + i + o + u (5 + 4 + 3 + 2+ 1) = 15\\n\\t\\t\\t\\t e = e + i + o +u (4 + 3+ 2+ 1) = 10\\n\\t\\t\\t\\t  i = i + o + u (3 + 2 + 1) = 6\\n\\t\\t\\t\\t  o = o + u ( 2 + 1) = 3\\n\\t\\t\\t\\t  u = u (1) = 1\\n\\t\\t\\t\\t  Total = a + e + i + o + u = 15 + 10 + 6 + 3 + 1 = 35\\n\\t\\t\\t\\t  \\n\\t\\t\\t\\t  \\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a = 1;\\n        int e = 1;\\n        int i = 1;\\n        int o = 1;\\n        int u = 1;\\n        while(n-- > 1){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a = 1;\\n        int e = 1;\\n        int i = 1;\\n        int o = 1;\\n        int u = 1;\\n        while(n-- > 1){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919754,
                "title": "c-top-down-dp-and-formula",
                "content": "#### Top Down DP\\nTop down DP was the easiest for me to get started. \\n\\n```cpp\\nint dp[51][5] = {};\\nint countVowelStrings(int n, int prev = 0) {\\n    if (n == 1)\\n        return 5 - prev;\\n    if (dp[n][prev] == 0)\\n        for (int i = prev; i < 5; ++i)\\n            dp[n][prev] += countVowelStrings(n - 1, i);\\n    return dp[n][prev]\\n```\\n\\n#### Formula\\nWhile converting the solution above to bottom-up DP, I realized that there is a pattern we can describe with a simple formula.\\n1) 1 + (1 + 2) | + 1\\n2) 1 + (1 + 2) + (1 + 2 + 3) | + 1 + (1 + 2) | + 1\\n3) 1 + (1 + 2) + (1 + 2 + 3) + (1 + 2 + 3 + 4) | + 1 + (1 + 2) + (1 + 2 + 3) | + 1 + (1 + 2) | + 1\\n4) 1 + (1 + 2) + (1 + 2 + 3) + (1 + 2 + 3 + 4) + (1 + 2 + 3 + 4 + 5)| + (#3)\\n- or\\n4) 5 * (5 + 1) / 2 + #3\\n5) 6 * (6 + 1)  /2 + #4\\n\\n```cpp\\nint countVowelStrings(int n) {\\n    int res = 0, sum = 0;\\n    for (int i = 1; i <= n + 1; ++i) {\\n        sum += i * (i + 1) / 2;\\n        res += sum;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[51][5] = {};\\nint countVowelStrings(int n, int prev = 0) {\\n    if (n == 1)\\n        return 5 - prev;\\n    if (dp[n][prev] == 0)\\n        for (int i = prev; i < 5; ++i)\\n            dp[n][prev] += countVowelStrings(n - 1, i);\\n    return dp[n][prev]\\n```\n```cpp\\nint countVowelStrings(int n) {\\n    int res = 0, sum = 0;\\n    for (int i = 1; i <= n + 1; ++i) {\\n        sum += i * (i + 1) / 2;\\n        res += sum;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2027805,
                "title": "c-faster-than-100-dp-and-math-approach",
                "content": "* The problem can be solved with **dynamic programming approach** or from a **direct math formula**. Here I have solved using DP approach.\\n* `dp[vowels[index] - 97]` at every value of `i` stores the number of lexicographically sorted strings which start from `vowels[index]` and is of length `i`.\\n*  `vowels[index]` can come before all the lexicographically sorted strings of length `i` starting from `vowels[idx]` **(idx > index)** to form new set of lexicographically sorted strings starting from `vowels[index`] having length `i + 1`. This is the logic for building answers.\\n* Build upon this answer till `i == n` and in the end accumulate the answers for each vowel.\\n\\n**Dynamic Programming Approach :**\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        string vowels = \"aeiou\";\\n        int ans;\\n        \\n        vector<int> dp(26, 0);\\n        \\n        dp[\\'a\\' - 97] = 1;\\n        dp[\\'e\\' - 97] = 1;\\n        dp[\\'i\\' - 97] = 1;\\n        dp[\\'o\\' - 97] = 1;\\n        dp[\\'u\\' - 97] = 1;\\n        \\n        \\n        \\n        for(int i = 2; i <= n ; i++){\\n            \\n            for(int j = 0; j < 5; j++){\\n                \\n                for(int k = j + 1; k < 5; k++){\\n                    \\n                    dp[vowels[j] - 97] += dp[vowels[k] - 97];\\n                    \\n                }                \\n                \\n            }\\n            \\n        }\\n        \\n        ans = accumulate(dp.begin(), dp.end(), 0);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**Alternate Math Approach :**\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        return (n+4)*(n+3)*(n+2)*(n+1) / 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        string vowels = \"aeiou\";\\n        int ans;\\n        \\n        vector<int> dp(26, 0);\\n        \\n        dp[\\'a\\' - 97] = 1;\\n        dp[\\'e\\' - 97] = 1;\\n        dp[\\'i\\' - 97] = 1;\\n        dp[\\'o\\' - 97] = 1;\\n        dp[\\'u\\' - 97] = 1;\\n        \\n        \\n        \\n        for(int i = 2; i <= n ; i++){\\n            \\n            for(int j = 0; j < 5; j++){\\n                \\n                for(int k = j + 1; k < 5; k++){\\n                    \\n                    dp[vowels[j] - 97] += dp[vowels[k] - 97];\\n                    \\n                }                \\n                \\n            }\\n            \\n        }\\n        \\n        ans = accumulate(dp.begin(), dp.end(), 0);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        return (n+4)*(n+3)*(n+2)*(n+1) / 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028854,
                "title": "java-o-n-visual-explanation",
                "content": "The solution is pretty straightforward once a pattern is visible.\\n```\\nFor n = 2\\na => (a, e,i,o,u)\\ne => (e,i,o,u)\\ni => (i, o, u)\\no => (o, u)\\nu => (u) \\n```\\n```\\nThe resultant strings are:\\naa, ae, ai, ao, au\\nee, ei, eo, eu\\t\\t\\t\\t\\nii, io, iu\\t\\t\\t\\t\\t\\t\\noo, ou\\t\\t\\t\\t\\t\\nuu\\n```\\n```\\nFor n = 3\\naa => (a,e,i,o,u)      5   \\nae => (e, i, o, u)     4  \\nai => (i, o, u)        3  \\nao => (o, u)\\t       2  \\nau => u\\t\\t           1  \\n\\nee => (e,i,o,u)      4   \\nei => (i,o,u)\\t     3   \\neo => (o,u)\\t\\t     2   \\neu => (u)\\t\\t     1   \\n\\n\\nii =>  (i,o,u)         3   \\nio =>  (o,u)\\t       2   \\niu =>\\t  (u)          1   \\n\\noo =>  (o,u)          2   \\nou =>    (u)          1   \\n\\nuu => (u)\\t          1   \\n\\n```\\nThe total comes out to be 35 which is the desired output.\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a,e,i,o,u;\\n        a = e = i = o = u = 1;\\n        \\n        for(int t = 1; t < n; t++){\\n            \\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFor n = 2\\na => (a, e,i,o,u)\\ne => (e,i,o,u)\\ni => (i, o, u)\\no => (o, u)\\nu => (u) \\n```\n```\\nThe resultant strings are:\\naa, ae, ai, ao, au\\nee, ei, eo, eu\\t\\t\\t\\t\\nii, io, iu\\t\\t\\t\\t\\t\\t\\noo, ou\\t\\t\\t\\t\\t\\nuu\\n```\n```\\nFor n = 3\\naa => (a,e,i,o,u)      5   \\nae => (e, i, o, u)     4  \\nai => (i, o, u)        3  \\nao => (o, u)\\t       2  \\nau => u\\t\\t           1  \\n\\nee => (e,i,o,u)      4   \\nei => (i,o,u)\\t     3   \\neo => (o,u)\\t\\t     2   \\neu => (u)\\t\\t     1   \\n\\n\\nii =>  (i,o,u)         3   \\nio =>  (o,u)\\t       2   \\niu =>\\t  (u)          1   \\n\\noo =>  (o,u)          2   \\nou =>    (u)          1   \\n\\nuu => (u)\\t          1   \\n\\n```\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a,e,i,o,u;\\n        a = e = i = o = u = 1;\\n        \\n        for(int t = 1; t < n; t++){\\n            \\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021390,
                "title": "c-code-explained-using-permutation-concept-faster-than-100",
                "content": "Code using permutation \\nWe have total n places to fill with 5 vowels to fill with.In short we have n identical thigs to be distributed among 5 people for which the formulae is \\n(n+5-1)C(5-1)= (n+4)C4=(n+1)*(n+2)*(n+3)*(n+4)/24\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        /// We can assume that there would be 4 transition states \\n        /// Ie from a->e->i->o->u\\n        /// and along with these transitions there would be n vowels in sorted order\\n        /// hence we have total n+4 locations and after choosing 4 of them \\n        /// (for the transitions to take place)\\n        /// the elements at all other positions got fixed \\n        /// hence the answer is n+4 C 4.\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n};\\n```\\nCode using recursion :\\nk denotes number of choices left for next character to be placed \\nn denotes the number of characters left\\nThe function is called recursively for all possible values of vowels \\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n,int k=5) {\\n        if(k<=1)\\n            return k;\\n        if(n==1)\\n            return k;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n            ans+=countVowelStrings(n-1,k-i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        /// We can assume that there would be 4 transition states \\n        /// Ie from a->e->i->o->u\\n        /// and along with these transitions there would be n vowels in sorted order\\n        /// hence we have total n+4 locations and after choosing 4 of them \\n        /// (for the transitions to take place)\\n        /// the elements at all other positions got fixed \\n        /// hence the answer is n+4 C 4.\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n,int k=5) {\\n        if(k<=1)\\n            return k;\\n        if(n==1)\\n            return k;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n            ans+=countVowelStrings(n-1,k-i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027351,
                "title": "image-explanation-distributing-n-balls-into-5-boxes-some-boxes-may-be-empty",
                "content": "[Leetcode](https://leetcode.com/) [1641. Count Sorted Vowel Strings](https://leetcode.com/problems/count-sorted-vowel-strings/).\\n\\n# Math \\n\\nEvery vowel string is start by $a, e, i, o, u$, and there are $N$ strings. \\n\\nHow to distribute $N$ strings into the $5$ boxes, some boxes may be empty?\\n\\nImaging that there are $N$ balls, we have to put them in to $5$ boxes represented by the $5$ vowels, as the picture shows.\\n\\n![1621](https://assets.leetcode.com/users/images/2ae9e3a9-b0a9-4935-b0eb-cc7c41c24f76_1652232736.5699382.png)\\n\\nOnce the number of characters in each box were fixed, the string is fixed.\\n\\nTherefore, how many ways are there to put $N$ balls in $5$ boxes, and the boxes can be empty?\\n\\nThe combinatorics explanation is [Pentatope number](https://en.wikipedia.org/wiki/Pentatope_number).\\n\\n1. $N$ balls in $M$ boxes, box can not empty: $C(n - 1, m - 1)$.\\n2. $N$ balls in $M$ boxes, box can be empty: $C(n + m - 1, m - 1)$.\\n\\n```java\\n    public static int countVowelStrings(int n) {\\n        return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(1)$.\\n- **Space Complexity**: $O(1)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```java\\n    public static int countVowelStrings(int n) {\\n        return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2027366,
                "title": "c-two-solutions-dp-and-math",
                "content": "**Solved LIVE ON stream, link in profile.  Math explained by a mathematician (not me) in my video**\\n\\nHere is the DP solution:\\n```\\nclass Solution {\\n    \\n    int dfs(int n, int i, vector<vector<int>>& memo) {\\n        if(n == 0) return 1;\\n        if(memo[n][i] != -1) return memo[n][i];\\n        int ret = 0;\\n        for(int j = i; j < 5; j++) {\\n            ret += dfs(n-1, j, memo);\\n        }\\n        \\n        return memo[n][i] = ret;\\n        \\n    }\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> memo(n+1, vector<int>(5, -1));\\n        return dfs(n, 0, memo);\\n    }\\n};\\n```\\n\\nHere is the math... Stars n Bars:\\n```\\nclass Solution {\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        return (n+4)*(n+3)*(n+2)*(n+1) / 24;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int dfs(int n, int i, vector<vector<int>>& memo) {\\n        if(n == 0) return 1;\\n        if(memo[n][i] != -1) return memo[n][i];\\n        int ret = 0;\\n        for(int j = i; j < 5; j++) {\\n            ret += dfs(n-1, j, memo);\\n        }\\n        \\n        return memo[n][i] = ret;\\n        \\n    }\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> memo(n+1, vector<int>(5, -1));\\n        return dfs(n, 0, memo);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        return (n+4)*(n+3)*(n+2)*(n+1) / 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027353,
                "title": "python-with-explanation-dynamic-programming",
                "content": "Explanation:\\nn =      1 -> 2 -> 3-> 4 ...\\n____________________________\\na =\\t     1 -> 5 -> 15 -> 35 ...\\ne =\\t     1 -> 4 -> 10 -> 20 ...\\ni =\\t      1 -> 3 ->  6 -> 10 ...\\no =\\t     1 -> 2 ->  3 ->  4 ...\\nu =\\t     1 -> 1 ->  1 ->  1 ...\\n____________________________\\nsum = 5 -> 15 -> 35 -> 70 ... (that\\'s the answer)\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        ## if n == 1: return 5 ##Edited: Actually don\\'t need it!\\n        arr = [1, 1, 1, 1, 1]  ## initial \\n        for i in range(2, n+1):   ## for different values of n\\n            for j in range(5):   ## for 5 vowels\\n                arr[j] = sum(arr[j:])\\n        return sum(arr)    ## return sum of the array\\n```\\n\\nPlease upvote if you like the answer! Happy coding!!\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        ## if n == 1: return 5 ##Edited: Actually don\\'t need it!\\n        arr = [1, 1, 1, 1, 1]  ## initial \\n        for i in range(2, n+1):   ## for different values of n\\n            for j in range(5):   ## for 5 vowels\\n                arr[j] = sum(arr[j:])\\n        return sum(arr)    ## return sum of the array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790576,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity :  O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1, e=1, i=1, o=1, u=1;\\n        while(n-- > 1){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar countVowelStrings = function(n) {\\n    let a=1, e=1, i=1, o=1, u=1\\n    while(n-- > 1){\\n        a = a + e + i + o + u\\n        e = e + i + o + u\\n        i = i + o + u\\n        o = o + u\\n        u = u\\n    }\\n    return a + e + i + o + u\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def countVowelStrings(self, n):\\n        a,e,i,o,u = 1,1,1,1,1\\n        for x in range(n-1):\\n            a = a + e + i + o + u\\n            e = e + i + o + u\\n            i = i + o + u\\n            o = o + u\\n            u = u\\n        return a + e + i + o + u\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1, e=1, i=1, o=1, u=1;\\n        while(n-- > 1){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a + e + i + o + u;\\n    }\\n}\\n```\n```\\nvar countVowelStrings = function(n) {\\n    let a=1, e=1, i=1, o=1, u=1\\n    while(n-- > 1){\\n        a = a + e + i + o + u\\n        e = e + i + o + u\\n        i = i + o + u\\n        o = o + u\\n        u = u\\n    }\\n    return a + e + i + o + u\\n};\\n```\n```\\nclass Solution(object):\\n    def countVowelStrings(self, n):\\n        a,e,i,o,u = 1,1,1,1,1\\n        for x in range(n-1):\\n            a = a + e + i + o + u\\n            e = e + i + o + u\\n            i = i + o + u\\n            o = o + u\\n            u = u\\n        return a + e + i + o + u\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066300,
                "title": "most-simple-solution-with-o-1-time-complexity-and-4-line-of-code-in-c",
                "content": "In my solution I used a basic concept of Permuation and combination that we studied in 11th class for JEE exam. It is about counting the number of ways we can distribute \\'n\\' identical balls in \\'k\\' identical boxes. \\n\\nx1 + x2 + x3 + .......+ xk = n\\n\\nand the formula for this comes out to be (n+k-1)C(k-1) \\n\\nSo imagine here that you need to give some chance X of chance to each vowel so that it can appear in the string X times. \\n\\nhence it is : Xa +Xe +Xi + Xo + Xu = n\\n\\nand for each case there will only be one arrangement of the accending order of the string.\\n\\nso in this question we need to calculate (n+4-1) C (5-1) \\n\\nthe following is the code that is required. (please support me by upvoting this solution \\uD83D\\uDE42)\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int ans =1;\\n        for (int i=n; i>n-4;i--){\\n            ans *= (i+4);\\n        }\\n        return ans/24;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int ans =1;\\n        for (int i=n; i>n-4;i--){\\n            ans *= (i+4);\\n        }\\n        return ans/24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151078,
                "title": "c-3-approaches-recursion-dp-combinations",
                "content": "**Approach 1 : Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int idx, int length, int n, int &count){\\n        ++length;\\n        \\n        if (length == n){\\n           ++count;\\n           return;\\n        }\\n        \\n        for (int i = idx ; i < 5 ; i++){\\n            dfs(i,length,n,count);\\n        }\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        int count = 0;\\n        for (int i = 0 ; i < 5 ; i++)\\n            dfs(i,0,n,count);\\n        return count;\\n    }\\n};\\n```\\n\\n**Approach 2 : Two Dimensional DP**\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int dp[n][5];\\n        \\n        // int dp[i][j] => Nummber of strings of length i+1 and ending at character j\\n        \\n        for (int i = 0 ; i < 5 ; i++)\\n            dp[0][i] = 1;\\n        \\n        for (int i = 1 ; i < n ; i++){\\n            dp[i][0] = dp[i-1][0];\\n            dp[i][1] = dp[i-1][1] + dp[i-1][0];\\n            dp[i][2] = dp[i-1][2] + dp[i-1][1] + dp[i-1][0];\\n            dp[i][3] = dp[i-1][3] + dp[i-1][2] + dp[i-1][1] + dp[i-1][0];\\n            dp[i][4] = dp[i-1][4] + dp[i-1][3] + dp[i-1][2] + dp[i-1][1] + dp[i-1][0];\\n        }\\n        \\n        int sum = 0;\\n        for (int i = 0 ; i < 5 ; i++)\\n            sum += dp[n-1][i];\\n        \\n        return sum;\\n    }   \\n};\\n```\\n\\n**Approach 3: Combinations**\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+4)*(n+3)*(n+2)*(n+1)/24;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int idx, int length, int n, int &count){\\n        ++length;\\n        \\n        if (length == n){\\n           ++count;\\n           return;\\n        }\\n        \\n        for (int i = idx ; i < 5 ; i++){\\n            dfs(i,length,n,count);\\n        }\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        int count = 0;\\n        for (int i = 0 ; i < 5 ; i++)\\n            dfs(i,0,n,count);\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int dp[n][5];\\n        \\n        // int dp[i][j] => Nummber of strings of length i+1 and ending at character j\\n        \\n        for (int i = 0 ; i < 5 ; i++)\\n            dp[0][i] = 1;\\n        \\n        for (int i = 1 ; i < n ; i++){\\n            dp[i][0] = dp[i-1][0];\\n            dp[i][1] = dp[i-1][1] + dp[i-1][0];\\n            dp[i][2] = dp[i-1][2] + dp[i-1][1] + dp[i-1][0];\\n            dp[i][3] = dp[i-1][3] + dp[i-1][2] + dp[i-1][1] + dp[i-1][0];\\n            dp[i][4] = dp[i-1][4] + dp[i-1][3] + dp[i-1][2] + dp[i-1][1] + dp[i-1][0];\\n        }\\n        \\n        int sum = 0;\\n        for (int i = 0 ; i < 5 ; i++)\\n            sum += dp[n-1][i];\\n        \\n        return sum;\\n    }   \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+4)*(n+3)*(n+2)*(n+1)/24;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958588,
                "title": "c-super-easy-soln-with-explaination-o-n-o-1",
                "content": "After working on this problem for quite some time, I figured out the following:\\n1) The vowel \\'a\\' always has 5 children\\n2) The vowel \\'e\\' always has 4 children\\n3) The vowel \\'i\\' always has 3 children\\n4) and so on ...\\n\\n\\n------\\nSo if i was to draw a tree it would look like this:\\n\\n![image](https://assets.leetcode.com/users/images/e7ddc038-d84c-4687-87af-2191b1bde0cd_1607019474.8288138.png)\\n\\nIf you notice each layer of the tree, and analyse it we get the following arrays:\\n\\nDepth = 1 : [5, 4, 3, 2, 1]\\nDepth = 2 : [15, 10, 6, 3, 1]\\nDepth = 3 : [35, 20, 10, 4, 1]\\nand so on..\\n\\n**At each depth the array is the presum array of the one before to it.**\\n\\n#### Presum function : \\n```\\nvoid presum(vector<int>& A)\\n{\\n\\tfor(int i=1;i<5;++i)\\n\\t\\tA[i] += A[i-1];\\n}\\n```\\n\\n------\\n\\nI will start with ``[1, 1, 1, 1, 1]``, say for layer 1.\\n\\n1) We run a loop from **1 to n-1**, to calculate the presum each time. \\n2) Then simply find the sum of the array elements.\\n\\n#### Main function :\\n\\n```\\nint countVowelStrings(int n)\\n{\\n\\tvector<int> A(5, 1);\\n\\tfor(int i=1;i<n;++i)\\n\\t\\tpresum(A);\\n\\n\\tint sum = 0;\\n\\tfor(int i=0;i<5;++i)\\n\\t\\tsum += A[i];\\n\\n\\treturn sum;\\n}\\n```\\n\\n------\\n### Full Code:\\n```\\nclass Solution {\\npublic:\\n    void presum(vector<int>& A)\\n    {\\n        for(int i=1;i<5;++i)\\n            A[i] += A[i-1];\\n    }\\n    \\n    int countVowelStrings(int n)\\n    {\\n        vector<int> A(5, 1);\\n        for(int i=1;i<n;++i)\\n            presum(A);\\n        \\n        int sum = 0;\\n        for(int i=0;i<5;++i)\\n            sum += A[i];\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n*I realize that the code could be optimised a lot, but the point of this is to give a solution that makes sense to most people.*",
                "solutionTags": [],
                "code": "```\\nvoid presum(vector<int>& A)\\n{\\n\\tfor(int i=1;i<5;++i)\\n\\t\\tA[i] += A[i-1];\\n}\\n```\n```\\nint countVowelStrings(int n)\\n{\\n\\tvector<int> A(5, 1);\\n\\tfor(int i=1;i<n;++i)\\n\\t\\tpresum(A);\\n\\n\\tint sum = 0;\\n\\tfor(int i=0;i<5;++i)\\n\\t\\tsum += A[i];\\n\\n\\treturn sum;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void presum(vector<int>& A)\\n    {\\n        for(int i=1;i<5;++i)\\n            A[i] += A[i-1];\\n    }\\n    \\n    int countVowelStrings(int n)\\n    {\\n        vector<int> A(5, 1);\\n        for(int i=1;i<n;++i)\\n            presum(A);\\n        \\n        int sum = 0;\\n        for(int i=0;i<5;++i)\\n            sum += A[i];\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327716,
                "title": "c-easy-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,0));\\n        for(int i=1;i<=5;i++)dp[1][i]=i;\\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<=5;j++){\\n                dp[i][j]= dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n][5];\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/1113c2da-2b1c-4bef-8dc9-c2d00cef4bb0_1679470498.667343.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,0));\\n        for(int i=1;i<=5;i++)dp[1][i]=i;\\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<=5;j++){\\n                dp[i][j]= dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n][5];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028519,
                "title": "5-c-solutions-1-backtracking-1-recursion-tle-1-dp-and-2-other-approach-easy",
                "content": "### **As you scroll down, there is a optimized solution given than the previous one.**\\n\\n* #####  **Approach-1**: **Recursion** *(Shows **TLE for n>40 and works for n<=40**)*\\n\\nHere, every next call for a decreased value of n gives us the required result and then we will add vowels at the start of result we get to get the strings of desired length. ( **i.e for n=2**, solver(n-1) or here, **solver(1) gives us the sorted vowels strings of length=1** and then we will **add up vowels again at the start of the sorted vowels strings we get, (maintaining the lexicographically sorted order) to get the sorted vowels strings of length=2**) \\n\\n***-->CODE:***\\n```\\nclass Solution\\n{\\nprivate:\\n    vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\npublic:\\n    vector<string> solver(int n)\\n    {\\n        if (n == 0)\\n        return {\"\"};\\n        \\n        vector<string> asf = solver(n - 1);\\n        vector<string> ans;\\n\\n        for (string i : asf)\\n        {\\n            for (char j : vowels)\\n            {\\n\\t\\t\\t \\t//check that the character you want to insert \\n\\t\\t\\t\\t//is smaller than the first character of asf(answer so far) string \\n\\t\\t\\t\\t//to maintain lexicographically sorted order\\n                if (j <= i[0] || asf.size() == 1)\\n                    ans.push_back(j + i);\\n                else\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n    int countVowelStrings(int n)\\n    {\\n        vector<string> ans = solver(n);\\n        return ans.size();\\n    }\\n};\\n```\\n\\n* #####  **Approach-2**: **Backtrack** *(**Gets submitted**)*\\n\\n***-->CODE:***\\n```\\n void solver(vector<vector<char>> &ans, vector<char> &temp, vector<char> &vowels, int start, int n)\\n    {\\n        if (temp.size() == n)\\n        {   ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for (int i = start; i < vowels.size(); i++)\\n        {\\n            temp.push_back(vowels[i]);\\n            solver(ans, temp, vowels, i, n);\\n            temp.pop_back();\\n        }\\n        return;\\n    }\\n\\n    int countVowelStrings(int n)\\n    {   vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        vector<char> temp;\\n        vector<vector<char>> ans;\\n        solver(ans, temp, vowels, 0, n);\\n        return ans.size();\\n    }\\n```\\n\\n* ##### **Approach-3**: Dynamic Programming(**DP**), **Time:O(n), Space:O(n)**\\n-Here, you can observe: \\n```\\nn=1, dp = {1,2,3,4,5}      return 5\\nn=2, dp = {1,3,6,10,15}    return 15\\nn=3, dp = {1,4,10,20,35}   return 35\\n```\\n\\n***-->CODE:***\\n```\\n  int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<5; j++){\\n                dp[j] += dp[j-1];\\n            }\\n        }\\n        return dp[4];\\n    }\\n```\\n\\n* ##### **Approach-4:**  **Time:O(n), Space:O(1)**\\n\\n-Here, you can observe a pattern : \\n```\\n\\t\\t   a  e  i  o  u\\n ->  n=1   1  1  1  1  1  \\n ->  n=2   5  4  3  2  1  \\n ->  n=3   15 10 6  3  1\\n```\\n\\t\\nIf we observe every other element will have the count of previous count value + next element count for the same n. As example\\nn=2,  a(in n=1) + count of next element, i.e e(in n=2) =5\\nn=3,  e(in n=2) + count of next element, i.e i(in n=3) =10\\n\\n***-->CODE:***\\n   ```\\n int countVowelStrings(int n)\\n    {\\n        int a, e, i, o, u;\\n        a = e = i = o = u = 1;\\n        while (--n)\\n        {\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        return a + e + i + o + u;\\n    }\\n```\\n\\n* ##### **Approach-5:** **Time:O(1), Space:O(1)**\\n**Visit for detailed explanation**: [https://leetcode.com/problems/count-sorted-vowel-strings/discuss/1021493/One-line-solution-or-Math-or-No-DP-no-Big-Integers-or-O(1)-time-space](http://) \\n\\n***-->CODE:***\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+4)*(n+3)*(n+2)*(n+1) / 24;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\npublic:\\n    vector<string> solver(int n)\\n    {\\n        if (n == 0)\\n        return {\"\"};\\n        \\n        vector<string> asf = solver(n - 1);\\n        vector<string> ans;\\n\\n        for (string i : asf)\\n        {\\n            for (char j : vowels)\\n            {\\n\\t\\t\\t \\t//check that the character you want to insert \\n\\t\\t\\t\\t//is smaller than the first character of asf(answer so far) string \\n\\t\\t\\t\\t//to maintain lexicographically sorted order\\n                if (j <= i[0] || asf.size() == 1)\\n                    ans.push_back(j + i);\\n                else\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n    int countVowelStrings(int n)\\n    {\\n        vector<string> ans = solver(n);\\n        return ans.size();\\n    }\\n};\\n```\n```\\n void solver(vector<vector<char>> &ans, vector<char> &temp, vector<char> &vowels, int start, int n)\\n    {\\n        if (temp.size() == n)\\n        {   ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for (int i = start; i < vowels.size(); i++)\\n        {\\n            temp.push_back(vowels[i]);\\n            solver(ans, temp, vowels, i, n);\\n            temp.pop_back();\\n        }\\n        return;\\n    }\\n\\n    int countVowelStrings(int n)\\n    {   vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        vector<char> temp;\\n        vector<vector<char>> ans;\\n        solver(ans, temp, vowels, 0, n);\\n        return ans.size();\\n    }\\n```\n```\\nn=1, dp = {1,2,3,4,5}      return 5\\nn=2, dp = {1,3,6,10,15}    return 15\\nn=3, dp = {1,4,10,20,35}   return 35\\n```\n```\\n  int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<5; j++){\\n                dp[j] += dp[j-1];\\n            }\\n        }\\n        return dp[4];\\n    }\\n```\n```\\n\\t\\t   a  e  i  o  u\\n ->  n=1   1  1  1  1  1  \\n ->  n=2   5  4  3  2  1  \\n ->  n=3   15 10 6  3  1\\n```\n```\\n int countVowelStrings(int n)\\n    {\\n        int a, e, i, o, u;\\n        a = e = i = o = u = 1;\\n        while (--n)\\n        {\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        return a + e + i + o + u;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+4)*(n+3)*(n+2)*(n+1) / 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783761,
                "title": "dp-solution-tabulation",
                "content": "The solution has **dynamic programming approach**.\\nWe have 5 vowels : [a,e,i,o,u]\\n*If n = 1:*\\n\\t\\tsolution will have {a,e,i,o,u} as possible valid string\\n*If n == 2*:\\nsolution string will have [\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"]\\nthis can be explained as:\\nfor a we can add :\\naa, ae, ai, ao, au\\nfor e:\\nee, ei,eo, eu (we can\\'t have \\'ea\\')\\nsimilary for i, o , u\\nNow I\\'ve tried to show the patter with the help of below table.\\n![image](https://assets.leetcode.com/users/images/5ae8bcb6-ac91-447d-838d-42a00fc3cb7f_1645291350.7443595.png)\\nfrom the table we can see then \\ntable[i][j] = table[i][j+1]+table[i-1][j]\\nNow, this will be the approach to move toward solution.\\n\\nComplete Solution:\\n\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        if n == 1:\\n            return 5\\n\\t\\t#initialised the table with 1\\n        dp = [[1]*5 for i in range(n+1)]\\n\\t\\t\\n        for i in range(1,n+1):\\n            for j in range(3,-1,-1):\\n                dp[i][j] = dp[i][j+1]+dp[i-1][j]\\n                \\n        return dp[n][0]\\n                \\n            \\n\\n        \\n                    \\n                    \\n                    \\n                    \\n                    \\n            \\n            \\n        \\n```\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        if n == 1:\\n            return 5\\n\\t\\t#initialised the table with 1\\n        dp = [[1]*5 for i in range(n+1)]\\n\\t\\t\\n        for i in range(1,n+1):\\n            for j in range(3,-1,-1):\\n                dp[i][j] = dp[i][j+1]+dp[i-1][j]\\n                \\n        return dp[n][0]\\n                \\n            \\n\\n        \\n                    \\n                    \\n                    \\n                    \\n                    \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212962,
                "title": "c-dp-beats100-0ms-solution-prefixsum",
                "content": "IDEA:- \\nInitialise dp of size 5(u,o,i,e,a) with value 1.\\n```\\nLogic:\\nFor n = 1\\nStrings possible \"a\",\"e\",\"i\",\"o\",\"u\".\\n\\nNow in case of n = 2 (i.e string length == 2);\\nFor \"a\" we have 5 choices to make it in sorted order i.e \"a\",\"e\",\"i\",\"o\",\"u\".\\nFor \"e\", similarly we have 4 choices \"e\",\"i\",\"o\",\"u\".\\nSimilarly for \"i\" 3 choices, \"o\" 2 choices, \"u\" 1 choice.\\nAdding up to 15 // that is where prefix sum logic comes from.\\n\\nFor n==3,\\nfor \"a\", we have all 15 choices i.e including all previous choices of n=2;\\nfor \"e\", we have total choices from \"e\".\"i\",\"o\",\"u\" = 10 (which is 15 - choice of \"a\" in n=2)\\nSimilarly for all cases :)\\n```\\nInitially\\n```\\nu  o  i  e  a\\n1  1  1  1  1\\n```\\nNow for n = 1\\n```\\nu  o  i  e  a\\n1  2  3  4  5\\nReturn dp[lastIndex];\\n```\\nNow for n = 2;\\n```\\nu  o  i  e  a\\n1  3  6  10 15\\nreturn dp[lastIndex];\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n    vector<int> dp(5,1);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j <5; j++){\\n                dp[j] += dp[j-1];\\n            }\\n        }\\n        return dp[4];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nLogic:\\nFor n = 1\\nStrings possible \"a\",\"e\",\"i\",\"o\",\"u\".\\n\\nNow in case of n = 2 (i.e string length == 2);\\nFor \"a\" we have 5 choices to make it in sorted order i.e \"a\",\"e\",\"i\",\"o\",\"u\".\\nFor \"e\", similarly we have 4 choices \"e\",\"i\",\"o\",\"u\".\\nSimilarly for \"i\" 3 choices, \"o\" 2 choices, \"u\" 1 choice.\\nAdding up to 15 // that is where prefix sum logic comes from.\\n\\nFor n==3,\\nfor \"a\", we have all 15 choices i.e including all previous choices of n=2;\\nfor \"e\", we have total choices from \"e\".\"i\",\"o\",\"u\" = 10 (which is 15 - choice of \"a\" in n=2)\\nSimilarly for all cases :)\\n```\n```\\nu  o  i  e  a\\n1  1  1  1  1\\n```\n```\\nu  o  i  e  a\\n1  2  3  4  5\\nReturn dp[lastIndex];\\n```\n```\\nu  o  i  e  a\\n1  3  6  10 15\\nreturn dp[lastIndex];\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n    vector<int> dp(5,1);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j <5; j++){\\n                dp[j] += dp[j-1];\\n            }\\n        }\\n        return dp[4];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021555,
                "title": "python-easy-explanation-blackboard",
                "content": "* **The code is well explained in the image below**\\n* **Simple and easy python3 solution**\\n\\n![image](https://assets.leetcode.com/users/images/a2c5f4e3-1b81-4862-9ffa-c9b30f0f54ff_1610892772.240594.png)\\n\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        dp = [[0 for j in range(5)] for i in range(n)]\\n        for i in range(5):\\n            dp[0][i] = 1\\n        for i in range(n):\\n            dp[i][0] = 1\\n        for i in range(1, n):\\n            for j in range(5):\\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\\n        return sum(dp[n - 1])\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        dp = [[0 for j in range(5)] for i in range(n)]\\n        for i in range(5):\\n            dp[0][i] = 1\\n        for i in range(n):\\n            dp[i][0] = 1\\n        for i in range(1, n):\\n            for j in range(5):\\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\\n        return sum(dp[n - 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921024,
                "title": "java-solution-intuition-behind-every-possible-dp-solution-here-of-this-problem",
                "content": "Let\\'s take a generic example where we need to make n character long sorted stings :-\\n*[When I am telling first or second char then it is counted from right]*\\n\\nNow the possible strings possible for **n = 1** is :- a, e, i, o, u\\n\\nNow for **n = 2**, \\nif the first character from end was \\'a\\' then the second char must be \\'a\\' only, right. [1 string possible]\\nSimilarly, if the first character from end was \\'e\\' then the second char can be \\'a\\' and \\'e\\'. \\n[2 strings possible]\\nSimilarly, if the first character from end was \\'i\\' then the second char can be \\'a\\', \\'e\\' and \\'i\\'.\\n[3 strings possible]\\nSimilarly, if the first character from end was \\'o\\' then the second char can be \\'a\\', \\'e\\', \\'i\\' and \\'o\\'.\\n[4 strings possible]\\nSimilarly, if the first character from end was \\'u\\' then the second char can be \\'a\\', \\'e\\', \\'i\\', \\'o\\' and \\'u\\'.\\n[5 strings possible]\\n\\n[At next Index from right i.e. At 2nd index]\\n**a->** can be produced by all strings (As we have total 5 strings, Therefore 5)\\n**e->** can be produced by all strings except which ends with \\'a\\'\\n**i->** can be produced by all strings except which ends with \\'a\\', \\'e\\'\\n**o->** can be produced by all strings except which ends with \\'a\\', \\'e\\', \\'i\\'\\n**u->** can be produced by all strings except which ends with \\'a\\', \\'e\\', \\'i\\', \\'o\\'\\n**5 + 4 + 3 + 2 + 1 = 15**\\n\\nNow for **n = 3**, \\nif the second character from end was \\'a\\' then the third char must be \\'a\\' only, right. \\nNow the possible string with \\'a\\' at second index when n was 2 is **5** [1*5 string possible]\\nAgain take a took at n = 2, when total possible strings have \\'a\\' five times at index = 2. \\n\\nSimilary, \\'e\\' occurs 4 times when n was 2 and \\'e\\' for prev index will result into 2 possible chars \\'a\\' and \\'e\\' at current index, so [2*4 strings possible] \\n\\nSimilarly for other characters at second index we will have sum:-\\n**(15) + (15-5) + (15-5-4) + (15-5-4-3) + (15-5-4-3-2) = 35**\\n\\nNow in similar fashion you can count possible strings of any length, Right.\\nExample: for **n = 4** ->\\n**(35) + (35-15) + (35-15-10) + (35-15-10-6) + (35-15-10-6-3) = 70**\\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[] dp = new int[5]; // It will store count of each char [a, e, i, o, u]\\n        Arrays.fill(dp, 1);\\n        \\n        for(int i = 1; i < n; i++){\\n            int sum = 0;\\n            for(int j = 0; j < 5; j++){\\n                sum += dp[j];\\n            }\\n            \\n            int prev = 0;\\n            for(int idx = 0; idx < 5; idx++){\\n                int temp = dp[idx];\\n                sum -= prev;\\n                dp[idx] = sum;\\n                prev = temp;\\n            }\\n        }\\n        \\n        return dp[0] + dp[1] + dp[2] + dp[3] + dp[4];\\n    }\\n}\\n```\\n\\nIf it helps you then, Please upvote :)\\nSuggestions are most welcome. :D",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[] dp = new int[5]; // It will store count of each char [a, e, i, o, u]\\n        Arrays.fill(dp, 1);\\n        \\n        for(int i = 1; i < n; i++){\\n            int sum = 0;\\n            for(int j = 0; j < 5; j++){\\n                sum += dp[j];\\n            }\\n            \\n            int prev = 0;\\n            for(int idx = 0; idx < 5; idx++){\\n                int temp = dp[idx];\\n                sum -= prev;\\n                dp[idx] = sum;\\n                prev = temp;\\n            }\\n        }\\n        \\n        return dp[0] + dp[1] + dp[2] + dp[3] + dp[4];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028984,
                "title": "one-line-o-1-space-time-no-dp-strings",
                "content": "**Solution**\\n\\n```csharp\\npublic int CountVowelStrings(int n) =>\\n    (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n```\\n\\n**Explanation**\\n\\nThis is a pure math exercise with a single variable, so using DP or actually constructing strings is an overkill. Here is the formula to count [combinations with repetitions](https://math.stackexchange.com/questions/208377/combination-with-repetitions):\\n![image](https://assets.leetcode.com/users/images/1f7a97c0-609e-462d-94d7-b3e4d74d2423_1652275068.9532337.png)\\nwhere `m` is the number of distinct objects at our disposal and `n` is how many we can take.\\n\\nIn this case, we have 5 vowels to choose from, so `m = 5`. We proceed like this:\\n![image](https://assets.leetcode.com/users/images/5ac049b2-e1fe-4896-9c97-4634aa652db9_1652275670.775265.png)\\n\\n",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```csharp\\npublic int CountVowelStrings(int n) =>\\n    (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1021817,
                "title": "python-3-dynamic-programming-explained",
                "content": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        \"\"\"\\n        Given a parameter n and assuming 5 vowels, this program\\n        uses dynamic programming to determine the number of\\n        possible sorted vowel strings of length n.\\n        \\n        The theory behind the dynamic programming is based on:\\n        at length k, the number of times a vowel can be prefixed\\n        to a sorted vowel string of length k - 1. For example,\\n        to create the sorted vowel strings of length 2, we start\\n        with the sorted strings of length 1, which are:\\n        \\n            \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n        \\n        To create the sorted strings of length 2, the vowels\\n        are prefixed to the strings of length 1 as follows:\\n        \\n            \\'u\\':    \\'uu\\'\\n            \\'o\\':    \\'ou\\', \\'oo\\'\\n            \\'i\\':    \\'iu\\', \\'io\\', \\'ii\\'\\n            \\'e\\':    \\'eu\\', \\'eo\\', \\'ei\\', \\'ee\\'\\n            \\'a\\':    \\'au\\', \\'ao\\', \\'ai\\', \\'ae\\', \\'aa\\'\\n        \\n        The dynamic programming has a column for each vowel in\\n        reverse order and a row for each length starting with 1.\\n        The dp can be optimized by overwriting the same row for\\n        length k - 1 to create the dp for length k. For example,\\n        the dp for lengths 1 and 2 will look like:\\n        \\n            \\'u\\' \\'o\\' \\'i\\' \\'e\\' \\'a\\'\\n        1     1   2   3   4   5\\n        2     1   3   6  10  15\\n\\n        :param n: length of vowel string\\n        :type n: int\\n        :return: number of possible sorted vowel strings of\\n                 length n\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] * 5\\n        for k in range(n):\\n            for m in range(1, 5):\\n                dp[m] += dp[m - 1]\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        \"\"\"\\n        Given a parameter n and assuming 5 vowels, this program\\n        uses dynamic programming to determine the number of\\n        possible sorted vowel strings of length n.\\n        \\n        The theory behind the dynamic programming is based on:\\n        at length k, the number of times a vowel can be prefixed\\n        to a sorted vowel string of length k - 1. For example,\\n        to create the sorted vowel strings of length 2, we start\\n        with the sorted strings of length 1, which are:\\n        \\n            \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n        \\n        To create the sorted strings of length 2, the vowels\\n        are prefixed to the strings of length 1 as follows:\\n        \\n            \\'u\\':    \\'uu\\'\\n            \\'o\\':    \\'ou\\', \\'oo\\'\\n            \\'i\\':    \\'iu\\', \\'io\\', \\'ii\\'\\n            \\'e\\':    \\'eu\\', \\'eo\\', \\'ei\\', \\'ee\\'\\n            \\'a\\':    \\'au\\', \\'ao\\', \\'ai\\', \\'ae\\', \\'aa\\'\\n        \\n        The dynamic programming has a column for each vowel in\\n        reverse order and a row for each length starting with 1.\\n        The dp can be optimized by overwriting the same row for\\n        length k - 1 to create the dp for length k. For example,\\n        the dp for lengths 1 and 2 will look like:\\n        \\n            \\'u\\' \\'o\\' \\'i\\' \\'e\\' \\'a\\'\\n        1     1   2   3   4   5\\n        2     1   3   6  10  15\\n\\n        :param n: length of vowel string\\n        :type n: int\\n        :return: number of possible sorted vowel strings of\\n                 length n\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] * 5\\n        for k in range(n):\\n            for m in range(1, 5):\\n                dp[m] += dp[m - 1]\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919090,
                "title": "javascript-backtracking",
                "content": "This is basically the same as the other \"generate permutations\" problems with an extra constraint. (By the way, I quite literally learned 99% of my backtracking and \"generate permutations\" techniques from watching this video series: https://www.youtube.com/watch?v=RkXl5iYoQn4&ab_channel=happygirlzt)\\n\\nSo anyways, what would be the base case? I knew that we\\'d be decrementing N, and that the base case is if the remaining N becomes 0.\\n\\nIt also occurred to me that we should keep track of what the start index is, so that we don\\'t put an \"e\" before an \"a.\"\\n`a -> e -> i -> o -> u`\\n\\nHere is the first version of code that I wrote. In this case, I modelled it after the other permutation problems and actually generated all the different permutations.\\n```js\\nvar countVowelStrings = function(n) {    \\n    const res = []\\n    const curr = []\\n    helper(res, curr, n, [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'], 0)\\n\\n    return res.length\\n};\\n\\nfunction helper(res, curr, n, arr, startIdx) { \\n    // base case\\n    if (n === 0) {\\n        res.push([...curr]) // here I am creating a new copy of `curr` and adding it into `res`\\n        return\\n    }\\n\\n    // recursive case\\n    for (let i = startIdx; i < arr.length; i++) {\\n        // choose \\n        curr.push(arr[i])\\n        helper(res, curr, n - 1, arr, i) // Here, it\\'s important to pass in \"i\" as the new \"startIdx,\" so that we make sure \"e\" does not go before \"a,\" etc.\\n        \\n        // unchoose\\n        curr.pop()\\n    }\\n}\\n```\\n\\nThe above code is needlessly memory-intensive. And that is because the question doesn\\'t actually require us to generate the actual permutations. So here is the code that I wrote, after removing all the part about actually generating the permutations.\\n\\n```js\\nvar countVowelStrings = function(n) {    \\n    let res = 0\\n    \\n    helper(n, 0)\\n\\n    function helper(n, startIdx) { \\n        // base case\\n        if (n === 0) {\\n            res++\\n            return\\n        }\\n\\n        // recursive case\\n        for (let i = startIdx; i < 5; i++) {\\n            helper(n - 1, i)\\n        }\\n    }\\n\\n    return res\\n};\\n```\\n\\nI found the runtime complexity to be tricky to figure out, but I know for sure that it won\\'t be over O(5^N) (O(branches^levels)). Space is O(N) because of the stack frames we are generating via recursion.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar countVowelStrings = function(n) {    \\n    const res = []\\n    const curr = []\\n    helper(res, curr, n, [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'], 0)\\n\\n    return res.length\\n};\\n\\nfunction helper(res, curr, n, arr, startIdx) { \\n    // base case\\n    if (n === 0) {\\n        res.push([...curr]) // here I am creating a new copy of `curr` and adding it into `res`\\n        return\\n    }\\n\\n    // recursive case\\n    for (let i = startIdx; i < arr.length; i++) {\\n        // choose \\n        curr.push(arr[i])\\n        helper(res, curr, n - 1, arr, i) // Here, it\\'s important to pass in \"i\" as the new \"startIdx,\" so that we make sure \"e\" does not go before \"a,\" etc.\\n        \\n        // unchoose\\n        curr.pop()\\n    }\\n}\\n```\n```js\\nvar countVowelStrings = function(n) {    \\n    let res = 0\\n    \\n    helper(n, 0)\\n\\n    function helper(n, startIdx) { \\n        // base case\\n        if (n === 0) {\\n            res++\\n            return\\n        }\\n\\n        // recursive case\\n        for (let i = startIdx; i < 5; i++) {\\n            helper(n - 1, i)\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1021696,
                "title": "java-solution-explanation-with-photos-beats-100-of-submissions",
                "content": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[] arr = new int[5];\\n        for (int i = 0; i<5; i++)\\n            arr[i] = 1;\\n        for (int k = 0; k<n; k++)\\n            for (int j = 1; j<5;j++)\\n                arr[j] = arr[j-1] + arr[j];\\n        return arr[4];         \\n    }\\n}\\n```\\nI hope you understood. \\n![image](https://assets.leetcode.com/users/images/3fa03873-f5fd-40ba-abbf-1e49e4c51131_1610899890.209691.png)\\n![image](https://assets.leetcode.com/users/images/2a4e5fb3-6091-4ce0-8dbb-79be304e4f58_1610899905.4009337.png)\\nFeel free to ask anything about the solution!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[] arr = new int[5];\\n        for (int i = 0; i<5; i++)\\n            arr[i] = 1;\\n        for (int k = 0; k<n; k++)\\n            for (int j = 1; j<5;j++)\\n                arr[j] = arr[j-1] + arr[j];\\n        return arr[4];         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327734,
                "title": "multiple-c-solutions",
                "content": "# Code\\n```\\n//Solution #1:\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a=1, e=1, i=1, o=1, u=1;\\n        while(--n){\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        return a+e+i+o+u;\\n    }\\n};\\n\\n//Solution #2\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,0));\\n        for(int i=1;i<=5;i++)dp[1][i]=i;\\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<=5;j++){\\n                dp[i][j]= dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n][5];\\n    }\\n};\\n\\n//Solution #3\\nclass Solution {\\npublic:\\n    int t(vector<vector<int>>&dp,int n,int i){\\n        if(i==0){\\n            dp[n][i]=0;\\n            return dp[n][i];\\n        }\\n        if(n==1){\\n            dp[n][i]=i;\\n            return dp[n][i];\\n        }\\n        if(dp[n][i]!=-1)return dp[n][i];\\n        dp[n][i] = t(dp,n-1,i) + t(dp,n,i-1);\\n        return dp[n][i];\\n    }\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,-1));\\n        t(dp,n,5);\\n        return dp[n][5];\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/1113c2da-2b1c-4bef-8dc9-c2d00cef4bb0_1679470498.667343.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Solution #1:\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a=1, e=1, i=1, o=1, u=1;\\n        while(--n){\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        return a+e+i+o+u;\\n    }\\n};\\n\\n//Solution #2\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,0));\\n        for(int i=1;i<=5;i++)dp[1][i]=i;\\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<=5;j++){\\n                dp[i][j]= dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n][5];\\n    }\\n};\\n\\n//Solution #3\\nclass Solution {\\npublic:\\n    int t(vector<vector<int>>&dp,int n,int i){\\n        if(i==0){\\n            dp[n][i]=0;\\n            return dp[n][i];\\n        }\\n        if(n==1){\\n            dp[n][i]=i;\\n            return dp[n][i];\\n        }\\n        if(dp[n][i]!=-1)return dp[n][i];\\n        dp[n][i] = t(dp,n-1,i) + t(dp,n,i-1);\\n        return dp[n][i];\\n    }\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,-1));\\n        t(dp,n,5);\\n        return dp[n][5];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974978,
                "title": "c-with-comments-o-n-time-o-1-space-beats-100",
                "content": "The idea is to count the strings ending on a particular vowel. Here are how these counts go:\\n\\n```\\n    a       e       i        o      u\\n\\t1       1       1        1      1\\n\\t1       2       3        4      5\\n\\t1       3       6       10     15\\n```\\n\\nYou get the idea: at each iteration there is a single string ending on \\'a\\', the one with \\'a\\' only. Starting with index 1, the number of strings ending with this letter is the sum off the previous line up to and including the index. We only need to keep the last row, and accumulate all the counts. This is constant space.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        if(n == 0) return 0;\\n        \\n        // Number of strings of length 1 ending on: a, e, i, o, u\\n        array<int, 5> counts = { 1, 1, 1, 1, 1 };\\n        \\n        for(int i = 1; i < n; ++i) {\\n            // Only one string ending on \\'a\\' on each iteration. Start with 1.`\\n            for(int j = 1; j < 5; ++j) {\\n                counts[j] += counts[j-1];\\n            }\\n        }\\n        \\n        return accumulate(counts.begin(), counts.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    a       e       i        o      u\\n\\t1       1       1        1      1\\n\\t1       2       3        4      5\\n\\t1       3       6       10     15\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        if(n == 0) return 0;\\n        \\n        // Number of strings of length 1 ending on: a, e, i, o, u\\n        array<int, 5> counts = { 1, 1, 1, 1, 1 };\\n        \\n        for(int i = 1; i < n; ++i) {\\n            // Only one string ending on \\'a\\' on each iteration. Start with 1.`\\n            for(int j = 1; j < 5; ++j) {\\n                counts[j] += counts[j-1];\\n            }\\n        }\\n        \\n        return accumulate(counts.begin(), counts.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920392,
                "title": "my-java-solutions-1-dp-2-math-formula",
                "content": "```\\n\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        // create a dp array of size 6\\n        int [] dp = new int [6];\\n        // dp[0] must be 0 and the rest 1\\n        for (int i=1; i<dp.length; i++)\\n            dp[i] = 1;\\n        for (int i=1; i<=n; i++) {\\n            for (int k=1; k<=5; k++) {\\n                dp[k] += dp[k-1];\\n            }\\n        }\\n        return dp[5];\\n    }\\n}\\n\\n\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        // from discussions I found the answr is simply (n+4)C(4)\\n        return ((n+1) * (n+2) * (n+3) * (n+4)) / 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        // create a dp array of size 6\\n        int [] dp = new int [6];\\n        // dp[0] must be 0 and the rest 1\\n        for (int i=1; i<dp.length; i++)\\n            dp[i] = 1;\\n        for (int i=1; i<=n; i++) {\\n            for (int k=1; k<=5; k++) {\\n                dp[k] += dp[k-1];\\n            }\\n        }\\n        return dp[5];\\n    }\\n}\\n\\n\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        // from discussions I found the answr is simply (n+4)C(4)\\n        return ((n+1) * (n+2) * (n+3) * (n+4)) / 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028870,
                "title": "0ms-100-c-solution-o-1-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n};\\n```\\n\\n\\nplease upvote!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027987,
                "title": "c-o-1-1-line-code-simplest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        return ((n+4)*(n+3)*(n+2)*(n+1))/24;\\n        \\n    }\\n};\\n```\\n\\n**Explanation :**\\n\\nThink of the problem in this way. We have 5 objects and n slots to fill with these 5 objects (a,e,i,o,u). Objects can be repeated. Since we want only lexicographically smallest solution, we consider each combination as one solution only. \\n\\nSo, say p number of \"a\", q number of \"e\", r number of \"i\", s number of \"o\", t number of \"u\" we want to fill. Then it must happen that p+q+r+s+t = n\\n\\nAssume we have n stars, we want to split them into 5 segments, so for that we want to place 4 bars in between the stars.\\nFor eg: n=12\\nOne possible combination of bars and stars could be |***|***|***|***\\nNow this is just one such combination where p=0, q=3, r=3, s=3, t=3.\\nBut with these n stars and 4 bars, we can in total form (n+4)! permutations... out of which there are (n+4)!/(n!\\\\*4!) unique combinations.\\n\\nSo the answer is just (n+4)!/(n!\\\\*4!) = ((n+4)\\\\*(n+3)\\\\*(n+2)\\\\*(n+1))/24.\\n\\nPlease upvote if you found this helpful :)\\n\\n",
                "solutionTags": [
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        return ((n+4)*(n+3)*(n+2)*(n+1))/24;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021377,
                "title": "c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int>v(5,1); //[1,1,1,1,1] -> (a,e,i,o,u)\\n        //for the n=2 ,consider this, \\n        // if starting is a, then the suffix can be any of the string in vector v from a\\n        // i.e aa,ae,ai,ao,au\\n        //for e, ee,ei,eo,eu and etc\\n        \\n        //for n=3\\n        // beside a any of the 2 character string from vector starting from a can be placed,like:-\\n        // a-> aaa,aae,.,.,aau\\n        //     aee,aei,.,aeu\\n        //     .\\n        //     .\\n        //     auu\\n        \\n        for(int i=2;i<=n;i++){\\n            v[0]=v[0]+v[1]+v[2]+v[3]+v[4];\\n            v[1]=v[1]+v[2]+v[3]+v[4];\\n            v[2]=v[2]+v[3]+v[4];\\n            v[3]=v[3]+v[4];\\n            v[4]=v[4];\\n        }\\n        return v[0]+v[1]+v[2]+v[3]+v[4];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int>v(5,1); //[1,1,1,1,1] -> (a,e,i,o,u)\\n        //for the n=2 ,consider this, \\n        // if starting is a, then the suffix can be any of the string in vector v from a\\n        // i.e aa,ae,ai,ao,au\\n        //for e, ee,ei,eo,eu and etc\\n        \\n        //for n=3\\n        // beside a any of the 2 character string from vector starting from a can be placed,like:-\\n        // a-> aaa,aae,.,.,aau\\n        //     aee,aei,.,aeu\\n        //     .\\n        //     .\\n        //     auu\\n        \\n        for(int i=2;i<=n;i++){\\n            v[0]=v[0]+v[1]+v[2]+v[3]+v[4];\\n            v[1]=v[1]+v[2]+v[3]+v[4];\\n            v[2]=v[2]+v[3]+v[4];\\n            v[3]=v[3]+v[4];\\n            v[4]=v[4];\\n        }\\n        return v[0]+v[1]+v[2]+v[3]+v[4];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918693,
                "title": "c-clean-o-n-code-detailed-explanation",
                "content": "**When n = 1**\\n`a e i o u`\\n`1 1 1 1 1 `\\n\\n**When n = 2**\\n`aa` \\n`ae ee`\\n`ai  ei   ii`\\n`ao eo io oo`\\n`au eu iu  ou uu`\\n`5  4  3   2   1`\\n\\n**When n = 3**\\nYou might realise, the # of three letter sequences begin as `aaa` and ends as `auu`, is exactly the same as the **sum** of all possible two letter sequences.\\nShown here `aaa...auu` = `a` + `(aa...au,ee...eu,ii...iu,oo...ou,uu)` = 5 + 4 + 3 + 2 + 1 = 15\\n\\n\\nThis actually applies to # of three letter sequences begin as `eee` and end as `euu` as well!\\n`eee...euu` = `e` + `(ee...eu,ii...iu,oo...ou,uu)` = 4 + 3 + 2 + 1 = 10\\n\\nAnd for `iii...iuu`, `ooo...ouu`,` uuu` you gussed it!\\n6 (3+2+1), 3 (2+1), and 1 (1) correspondingly\\n\\nThe final result will be\\n`15 10 6 3 1`\\n\\n**When n = 4**\\nYou can apply the same logic\\nSince `aaaa` to `auuu` is same as `a` + `(aaa...uuu)`\\n\\nThe final result will be\\n35 (15+10+6+3+1) 20 (10+6+3+1) 10 (6+3+1) 4 (3+1) 1 (1) or\\n`35 20 10 4 1`\\n\\n**When n = 5**\\nSame method and it gives\\n`70 35 15 5 1`\\n\\nWe can now conclude an algorithmic pattern.\\nFor a list `P`, 0-indexed. \\n`P_0` represents the # of sequences length `n` begin with the letter `u`\\n`P_1` represents the # of sequences length `n` begin with the letter `i`\\n...\\n`P_4` represents the # of sequences length `n` begin with the letter `a`\\n\\nTo find the # of sequences length `n+1`\\nIt can be computed as follows, `0 <= i <= 4`\\n`P_i = P_i + P_i-1 + ... + P_0`\\n\\nHere is the code I wrote in C++\\n```class Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> sums(5,1);\\n        \\n        for (int i = 0; i < n; i++){\\n            for (int j = 1; j < 5; j++){\\n                sums[j] = sums[j] + sums[j-1];\\n            }\\n        }\\n        \\n        return sums[4];\\n    }\\n};\\n```\\n\\nThis is actually my first post with explanations!\\nFeedbacks welcomed!\\n",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> sums(5,1);\\n        \\n        for (int i = 0; i < n; i++){\\n            for (int j = 1; j < 5; j++){\\n                sums[j] = sums[j] + sums[j-1];\\n            }\\n        }\\n        \\n        return sums[4];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918428,
                "title": "python-one-line-math-comb-with-explanation-updated",
                "content": "**Idea**: \\n\\nWe can simplify the question to how many \"vowel\"-ending strings at each n. \\n\"-e\" at n = 2: \"ae\", \"ee\"\\n\\nLet\\'s see how many \"vowel\"-ending strings possible at n:\\n\\nEx:\\n```\\nn  =   1  2  3  4  5  \\n------------------------\\n\"-a\":  1  1  1  1  1  \\n\"-e\":  1  2  3  4  5  \\n\"-i\":  1  3  6 10 15 \\n\"-o\":  1  4 10 20 35 \\n\"-u\":  1  5 15 35 70 \\n------------------------\\nsum :  5 15 35 70 126\\n```\\nWe can see that this is a pascal triangle but it is oblique. Or we can see below:\\n\\n![image](https://assets.leetcode.com/users/images/390a1089-d152-43e9-8ce4-4a0c3419f38f_1604204596.6583333.png)\\n\\nTherefore, the sum of all strings at n is located at the **n+2th** element of **n+6th** row.\\n\\nAccording to Pascal Triangle: kth element at nth row is c(n-1, k-1)\\n\\n**Code:**\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return math.comb(n+4, n)\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nn  =   1  2  3  4  5  \\n------------------------\\n\"-a\":  1  1  1  1  1  \\n\"-e\":  1  2  3  4  5  \\n\"-i\":  1  3  6 10 15 \\n\"-o\":  1  4 10 20 35 \\n\"-u\":  1  5 15 35 70 \\n------------------------\\nsum :  5 15 35 70 126\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return math.comb(n+4, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278599,
                "title": "c-intuitive-solution-dp-and-memoization",
                "content": "**Logic :**\\nThis problem is based on simple pick and non-pick concept. At every index we have a choice either to pick a vowel or skip it. So, here we get the idea of recursion, but while doing so we encounter overlapping problems and hence we go for the memoization part.\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int sz,vector<vector<int>> &dp)\\n    {\\n        if(i<0)\\n        return 0;\\n        if(sz==0)\\n        {\\n            return 1;\\n        }\\n        \\n        if(dp[i][sz]!=-1)\\n        return dp[i][sz];\\n        \\n        int l = solve(i,sz-1,dp);\\n        \\n        int r = solve(i-1,sz,dp);\\n          \\n        return dp[i][sz] = l + r;\\n    }\\n    int countVowelStrings(int n) {\\n        \\n        vector<vector<int>> dp(5,vector<int> (n+1,-1));\\n        return solve(4,n,dp);\\n    }\\n};\\n```\\n\\nIf this solution helps you then,  **Please Upvote!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int sz,vector<vector<int>> &dp)\\n    {\\n        if(i<0)\\n        return 0;\\n        if(sz==0)\\n        {\\n            return 1;\\n        }\\n        \\n        if(dp[i][sz]!=-1)\\n        return dp[i][sz];\\n        \\n        int l = solve(i,sz-1,dp);\\n        \\n        int r = solve(i-1,sz,dp);\\n          \\n        return dp[i][sz] = l + r;\\n    }\\n    int countVowelStrings(int n) {\\n        \\n        vector<vector<int>> dp(5,vector<int> (n+1,-1));\\n        return solve(4,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030032,
                "title": "c-backtracking-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(int n, vector<char> &temp,int &count, int idx, vector<char> &vowels)\\n    {\\n        if(temp.size()==n)\\n        {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i=idx; i<vowels.size(); i++)\\n        {\\n            temp.push_back(vowels[i]);\\n            helper(n, temp, count, i, vowels);\\n            temp.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    int countVowelStrings(int n) \\n    {\\n        vector<char> vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int count=0;\\n        vector<char> temp;\\n        helper(n, temp, count, 0, vowels);\\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(int n, vector<char> &temp,int &count, int idx, vector<char> &vowels)\\n    {\\n        if(temp.size()==n)\\n        {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i=idx; i<vowels.size(); i++)\\n        {\\n            temp.push_back(vowels[i]);\\n            helper(n, temp, count, i, vowels);\\n            temp.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    int countVowelStrings(int n) \\n    {\\n        vector<char> vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int count=0;\\n        vector<char> temp;\\n        helper(n, temp, count, 0, vowels);\\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029413,
                "title": "dp-solution-with-explanation",
                "content": "It is an awesome problem. Lets deep dive in it.\\n\\nSo, they are asking the number of ways in which we can generate  lexographically sorted strings of length n, which only contains vowels.\\n\\nNow lets think about it.\\nSuppose if  `n=1` then the possible strings would be ```\"a\",\"e\",\"i\",\"o\",\"u\"```.\\n\\n\\nNow lets make an approach.\\n\\nLets create a 2-D array of size 5 * n and for our example lets take ```n=3```\\nSo here is our array.\\n\\n![image](https://assets.leetcode.com/users/images/5cfacf83-2f89-4369-9fd6-c9d1b01d3f6a_1652281456.4877005.jpeg)\\n\\nHere we will store the number of strings we that will end on respective vowel for the given n.\\nNow for n=1, all the values will be 1.\\n\\nLets fill it for n=2.\\nFor string to be ending on ```a``` we have only one way i.e all the characters will be ```\\'a\\'```.\\n\\nFor string  to be ending on ```b``` we have two options that either append ```\\'b\\'``` on string which previously ended on ```a``` or append ```\\'b\\'``` to the string which previously ended on ```b```.\\n\\nFor string to be ending on ```c``` we have three options that we append ```\\'c\\'``` on string ending with ```a``` or ```b``` or append ```\\'c\\'``` to the string which previously ended on ```c```.\\n\\nIt hope you got the idea :)\\n\\nNow lets fill our array.\\n\\n![image](https://assets.leetcode.com/users/images/c5cf43d8-ae70-47b7-afba-eb7e3f9c7394_1652282112.450616.jpeg)\\n\\nAt last the sum of last column will be our answer.\\n\\nAwesome we solved it !!!\\n\\nBut can we do better? Can we do it in O(1) space?\\n\\nIf you look closely we are only using the previous values of the column. So there is no need to use this array we will replace it by 5 variables which will be storing the content of column values.\\n\\nHere is my code :\\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1,e=1,i=1,o=1,u=1;\\n        for(int index=1;index<n;index++){\\n            int aNew=a,eNew=a+e,iNew=a+e+i,oNew=a+e+i+o,uNew=a+e+i+o+u;\\n            a=aNew;\\n            e=eNew;\\n            i=iNew;\\n            o=oNew;\\n            u=uNew;\\n        }\\n        return a+e+i+o+u;\\n    }\\n}\\n```\\n\\nHope u understood the solution.\\n\\n \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\"a\",\"e\",\"i\",\"o\",\"u\"```\n```n=3```\n```a```\n```\\'a\\'```\n```b```\n```\\'b\\'```\n```a```\n```\\'b\\'```\n```b```\n```c```\n```\\'c\\'```\n```a```\n```b```\n```\\'c\\'```\n```c```\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1,e=1,i=1,o=1,u=1;\\n        for(int index=1;index<n;index++){\\n            int aNew=a,eNew=a+e,iNew=a+e+i,oNew=a+e+i+o,uNew=a+e+i+o+u;\\n            a=aNew;\\n            e=eNew;\\n            i=iNew;\\n            o=oNew;\\n            u=uNew;\\n        }\\n        return a+e+i+o+u;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027796,
                "title": "easy-approach-simple-to-understand",
                "content": "**Hope you liked it :)**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<char> &v, int n, int currindex, int &count, int l)\\n    {\\n        if(currindex >= n)\\n        {\\n            count++;\\n            return;\\n        }\\n        for(int i=l; i<v.size(); i++)\\n        {\\n            solve(v, n, currindex+1, count, i);\\n        }\\n    }\\n    \\n    int countVowelStrings(int n)\\n    {\\n        vector<char> v={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int count = 0;\\n        solve(v, n, 0, count, 0);\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(vector<char> &v, int n, int currindex, int &count, int l)\\n    {\\n        if(currindex >= n)\\n        {\\n            count++;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1487571,
                "title": "c-dynamic-programming-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> v(n+1);     v[0] = 1;\\n        for(int j = 0; j < 5; ++j){\\n            for(int i = 1; i <= n; ++i){\\n                v[i] += v[i-1];\\n            }\\n        }\\n        return v[n];\\n    }\\n};\\n```\\n\\n**Result-**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Count Sorted Vowel Strings.\\nMemory Usage: 6.2 MB, less than 23.22% of C++ online submissions for Count Sorted Vowel Strings.\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> v(n+1);     v[0] = 1;\\n        for(int j = 0; j < 5; ++j){\\n            for(int i = 1; i <= n; ++i){\\n                v[i] += v[i-1];\\n            }\\n        }\\n        return v[n];\\n    }\\n};\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Count Sorted Vowel Strings.\\nMemory Usage: 6.2 MB, less than 23.22% of C++ online submissions for Count Sorted Vowel Strings.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022459,
                "title": "python-dp-o-n-time-o-1-space-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: dp\\nh: when n = 1, we only have 5 choice,\\n   wheb n = 2, we have 15 options, how they related\\n   consider: [a, e, i, o, u]\\n             [aa, ae, ai, ao, au  -- 5 strings\\n                  ee, ei, eo, eu  -- 4 strings\\n                      ii, io, iu  -- 3 strings\\n                          oo, ou  -- 2 strings\\n                              uu] -- 1 strings\\n                              \\n   we find a can be placed before any vowel, \\n           e can be place before e, i, o, u; \\n           i can be placed before i, o, u...\\n           \\n   so if n = 3, we can place a before any string when n = 2, which is 15\\n                we can place e before string not start with a, which is 10\\n                we can place i before strings not start with a, e, which is 6\\n                \\n   now see the pattern? \\n\\n   let\\'s present the valid number of string for each vowel in a list:\\n   n = 2, [5, 4, 3, 2, 1], 15 in total\\n   n = 3, [15, 10, 6, 3, 1], 35 in total\\n   n = 4, [35, 20, 10, 4, 1], 70 in total\\n   ...\\n   consider n = 2 and n = 3, from the end to the beginining, we can see\\n   3 = 1 + 2, 6 = 3 + 3, 10 = 6 + 4, 15 = 10 + 5 \\n   \\n   now the pattern is clear, and you can try n=3 and n=4\\n\\'\\'\\'\\n\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        # n = 1, base case\\n        dp = [1, 1, 1, 1, 1]\\n        # the valid number of string started with u is always 1\\n        # or you can say dp[-1] is always 1 \\n        u = 1\\n        for i in range(n-1):\\n            dp[4] = u\\n            for j in range(1, 5)[::-1]:   \\n                dp[j-1] = dp[j-1] + dp[j]\\n\\n        return sum(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: dp\\nh: when n = 1, we only have 5 choice,\\n   wheb n = 2, we have 15 options, how they related\\n   consider: [a, e, i, o, u]\\n             [aa, ae, ai, ao, au  -- 5 strings\\n                  ee, ei, eo, eu  -- 4 strings\\n                      ii, io, iu  -- 3 strings\\n                          oo, ou  -- 2 strings\\n                              uu] -- 1 strings\\n                              \\n   we find a can be placed before any vowel, \\n           e can be place before e, i, o, u; \\n           i can be placed before i, o, u...\\n           \\n   so if n = 3, we can place a before any string when n = 2, which is 15\\n                we can place e before string not start with a, which is 10\\n                we can place i before strings not start with a, e, which is 6\\n                \\n   now see the pattern? \\n\\n   let\\'s present the valid number of string for each vowel in a list:\\n   n = 2, [5, 4, 3, 2, 1], 15 in total\\n   n = 3, [15, 10, 6, 3, 1], 35 in total\\n   n = 4, [35, 20, 10, 4, 1], 70 in total\\n   ...\\n   consider n = 2 and n = 3, from the end to the beginining, we can see\\n   3 = 1 + 2, 6 = 3 + 3, 10 = 6 + 4, 15 = 10 + 5 \\n   \\n   now the pattern is clear, and you can try n=3 and n=4\\n\\'\\'\\'\\n\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        # n = 1, base case\\n        dp = [1, 1, 1, 1, 1]\\n        # the valid number of string started with u is always 1\\n        # or you can say dp[-1] is always 1 \\n        u = 1\\n        for i in range(n-1):\\n            dp[4] = u\\n            for j in range(1, 5)[::-1]:   \\n                dp[j-1] = dp[j-1] + dp[j]\\n\\n        return sum(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021234,
                "title": "one-line-c-beats-100-in-time-less-memory-than-98-67",
                "content": "This probelm has a `pattern` you need to find,and when you did it would look like something like this:\\n```\\nint countVowelStrings(int n) {\\n        return ((n+1)*(n+2)*(n+3)*(n+4))/24;\\n    }\\n```\\nIf you have any questions drop them below \\uD83D\\uDC47 and if liked it ,kindly  **Upvote** it \\u2B06",
                "solutionTags": [],
                "code": "```\\nint countVowelStrings(int n) {\\n        return ((n+1)*(n+2)*(n+3)*(n+4))/24;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1021065,
                "title": "java-1-d-dp-beat-100-with-explainations",
                "content": "```\\n    public int countVowelStrings(int n) {\\n        // dp[i][j]: for first i vowels of length j, what is the unique lexicon pattern count\\n        // divid into two groups, one with only i - vowels dp[i-1][j], the other that must contain at least 1 i-th vowel\\n        // the second group\\'s last letter must be i-th vowel, because they all unique, the count of them is actually\\n        // dp[i][j - 1];\\n        // transformation func: dp[i][j] = dp[i -1][j] + dp[i][j-1]\\n        // for init, dp[1][*] = 1, dp[1][0] = 1\\n        // we can transfer the problem into 1-D dp, so dp[i] += dp[i - 1], scan from left to right\\n        // for init dp[0] = 1\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 0; i < 5; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countVowelStrings(int n) {\\n        // dp[i][j]: for first i vowels of length j, what is the unique lexicon pattern count\\n        // divid into two groups, one with only i - vowels dp[i-1][j], the other that must contain at least 1 i-th vowel\\n        // the second group\\'s last letter must be i-th vowel, because they all unique, the count of them is actually\\n        // dp[i][j - 1];\\n        // transformation func: dp[i][j] = dp[i -1][j] + dp[i][j-1]\\n        // for init, dp[1][*] = 1, dp[1][0] = 1\\n        // we can transfer the problem into 1-D dp, so dp[i] += dp[i - 1], scan from left to right\\n        // for init dp[0] = 1\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 0; i < 5; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930168,
                "title": "java-backtrack-solution-very-simple",
                "content": "```\\n int ans;\\n    public int countVowelStrings(int n) {\\n       // char[] ch ={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        ans=0;\\n        count(0,n);\\n        return ans;\\n    }\\n    void count(int src,int n){\\n        if(n==0){ans++;return;}\\n        for(int i=src;i<5;i++){\\n            count(i,n-1);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n int ans;\\n    public int countVowelStrings(int n) {\\n       // char[] ch ={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        ans=0;\\n        count(0,n);\\n        return ans;\\n    }\\n    void count(int src,int n){\\n        if(n==0){ans++;return;}\\n        for(int i=src;i<5;i++){\\n            count(i,n-1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918481,
                "title": "java-back-track",
                "content": "```\\nclass Solution {\\n    //String vowels = \"aeiou\";\\n    int count = 0;\\n    public int countVowelStrings(int n) {\\n        backTrack(n, 0);\\n        return count;\\n    }\\n    private void backTrack(int n, int indexToStart){\\n        if(n == 0){\\n            count++;\\n            return;\\n        }\\n        for(int i = indexToStart; i < 5; i++){\\n            backTrack(n - 1, i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    //String vowels = \"aeiou\";\\n    int count = 0;\\n    public int countVowelStrings(int n) {\\n        backTrack(n, 0);\\n        return count;\\n    }\\n    private void backTrack(int n, int indexToStart){\\n        if(n == 0){\\n            count++;\\n            return;\\n        }\\n        for(int i = indexToStart; i < 5; i++){\\n            backTrack(n - 1, i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918372,
                "title": "c-1-liner-easy-to-understand-beginner-short-concise-interview-with-explanation",
                "content": "```\\n/*\\n\\nEXPLANATION: [C++]-1 LINER-EASY TO UNDERSTAND-BEGINNER-SHORT CONCISE-INTERVIEW-WITH EXPLANATION\\n\\nEXPLANATION:\\n\\nBasically n==1 - 5 combinations. Each ending with a vowel\\n\\nending with a-5,e-4,i-3,o-2,u-1\\nn==2 = 5+4+3+2+1\\n\\nsimilarly n==3 == 35... 15+ (aa-5 , ae-4, ai-3,ao-2, au-1 and so on), which will lead to binomial coefficient of Binomial coefficient binomial(n,4) = n*(n-1)*(n-2)*(n-3)/24 starting from 5th term\\n\\nThus follows https://oeis.org/A000332\\n*/\\n\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return ((n+4)*(n+3)*(n+2)*(n+1))/24;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nEXPLANATION: [C++]-1 LINER-EASY TO UNDERSTAND-BEGINNER-SHORT CONCISE-INTERVIEW-WITH EXPLANATION\\n\\nEXPLANATION:\\n\\nBasically n==1 - 5 combinations. Each ending with a vowel\\n\\nending with a-5,e-4,i-3,o-2,u-1\\nn==2 = 5+4+3+2+1\\n\\nsimilarly n==3 == 35... 15+ (aa-5 , ae-4, ai-3,ao-2, au-1 and so on), which will lead to binomial coefficient of Binomial coefficient binomial(n,4) = n*(n-1)*(n-2)*(n-3)/24 starting from 5th term\\n\\nThus follows https://oeis.org/A000332\\n*/\\n\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return ((n+4)*(n+3)*(n+2)*(n+1))/24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327695,
                "title": "c-dp-beats-100-memoization-and-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int t(vector<vector<int>>&dp,int n,int i){\\n        if(i==0){\\n            dp[n][i]=0;\\n            return dp[n][i];\\n        }\\n        if(n==1){\\n            dp[n][i]=i;\\n            return dp[n][i];\\n        }\\n        if(dp[n][i]!=-1)return dp[n][i];\\n        dp[n][i] = t(dp,n-1,i) + t(dp,n,i-1);\\n        return dp[n][i];\\n    }\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,-1));\\n        t(dp,n,5);\\n        return dp[n][5];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t(vector<vector<int>>&dp,int n,int i){\\n        if(i==0){\\n            dp[n][i]=0;\\n            return dp[n][i];\\n        }\\n        if(n==1){\\n            dp[n][i]=i;\\n            return dp[n][i];\\n        }\\n        if(dp[n][i]!=-1)return dp[n][i];\\n        dp[n][i] = t(dp,n-1,i) + t(dp,n,i-1);\\n        return dp[n][i];\\n    }\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5+1,-1));\\n        t(dp,n,5);\\n        return dp[n][5];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029636,
                "title": "c-easy-recursion-simple-explanation-daily-leetcoding-challenge-may-day-11",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<char> &vowels, vector<char> &tmp, int &ans, int n, int start)\\n    {\\n        // if our tmp.size(), in which we are storing our combination reaches to the n then push that combination into our ans\\n        if(n==tmp.size())\\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        // start viisitng all the remaining vowels with the current vowel \\n\\t\\t// beacuse it can make combination with itself and all the right vowels also\\n        // each time push current vowel to our temp and call the same function for current i\\n        for(int i=start;i<vowels.size();i++)\\n        {\\n            tmp.push_back(vowels[i]);\\n            helper(vowels,tmp,ans,n,i);\\n            tmp.pop_back();                  // backtracking\\n        }\\n        return;\\n    }\\n    \\n    int countVowelStrings(int n) \\n    {\\n        // it is the vector by which we need to create all possible combination of strings\\n        vector<char> vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        \\n        // it will store the current string each time\\n        vector<char> tmp;\\n        \\n        // it will store all the possible combinations count\\n        int ans=0;\\n        \\n        // call the helper function\\n        helper(vowels,tmp,ans,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<char> &vowels, vector<char> &tmp, int &ans, int n, int start)\\n    {\\n        // if our tmp.size(), in which we are storing our combination reaches to the n then push that combination into our ans\\n        if(n==tmp.size())\\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        // start viisitng all the remaining vowels with the current vowel \\n\\t\\t// beacuse it can make combination with itself and all the right vowels also\\n        // each time push current vowel to our temp and call the same function for current i\\n        for(int i=start;i<vowels.size();i++)\\n        {\\n            tmp.push_back(vowels[i]);\\n            helper(vowels,tmp,ans,n,i);\\n            tmp.pop_back();                  // backtracking\\n        }\\n        return;\\n    }\\n    \\n    int countVowelStrings(int n) \\n    {\\n        // it is the vector by which we need to create all possible combination of strings\\n        vector<char> vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        \\n        // it will store the current string each time\\n        vector<char> tmp;\\n        \\n        // it will store all the possible combinations count\\n        int ans=0;\\n        \\n        // call the helper function\\n        helper(vowels,tmp,ans,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028692,
                "title": "java-from-recursion-to-memoization-to-tabulation-easy-and-explained",
                "content": "Recursion -->\\n[ Time-Complexity = exponential, Space-Complexity = O(n) ]\\n```\\nclass Solution {\\n   int count =0;\\n    public int countVowelStrings(int n) {\\n        String[] s= new String[]{\"a\",\"e\",\"i\",\"o\",\"u\"};\\n        \\n       int ans = solve(0,n,s);\\n        return ans;\\n    }\\n    public int solve(int ind , int n ,String[] s){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(ind>=s.length)return 0;\\n        \\n        int pick = solve(ind,n-1,s);\\n        int notPick = solve(ind+1,n,s);\\n        \\n        return (pick+notPick);\\n    }\\n    \\n}\\n```\\n\\nMemoization-->>\\n[ Time-Complexity = O(4*N), Space-Complexity = O(5*n)+O(N) ]\\n```\\nclass Solution {\\n    int count = 0;\\n\\n    public int countVowelStrings(int n) {\\n        String[] s = new String[] { \"a\", \"e\", \"i\", \"o\", \"u\" };\\n        int[][] dp = new int[5][n + 1];\\n        for (int[] x : dp) {\\n            Arrays.fill(x, -1);\\n        }\\n        int ans = solve(0, n, s,dp);\\n        return ans;\\n    }\\n\\n    public int solve(int ind, int n, String[] s,int[][] dp) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (ind >= s.length) return 0;\\n        if(dp[ind][n]!=-1) return dp[ind][n];\\n\\n        int pick = solve(ind, n - 1, s,dp);\\n        int notPick = solve(ind + 1, n, s,dp);\\n\\n        return dp[ind][n] = (pick + notPick);\\n    }\\n}\\n```\\n\\nTabulation-->>\\n[ Time-Complexity = O(4*N), Space-Complexity =O(N) ]\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        String[] s = new String[] { \"a\", \"e\", \"i\", \"o\", \"u\" };\\n        int[][] dp = new int[5][n + 1];\\n        for(int i=0;i<s.length;i++)\\n            dp[i][0] = 1;\\n        for(int i =4;i>=0;i--){\\n            for(int j=1;j<=n;j++){\\n                int pick = dp[i][j-1];\\n                int notPick = 0;\\n              if(i<4) notPick = dp[i+1][j];\\n                dp[i][j] = (pick+notPick);\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n}\\n```\\nplease upvote if helped.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n   int count =0;\\n    public int countVowelStrings(int n) {\\n        String[] s= new String[]{\"a\",\"e\",\"i\",\"o\",\"u\"};\\n        \\n       int ans = solve(0,n,s);\\n        return ans;\\n    }\\n    public int solve(int ind , int n ,String[] s){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(ind>=s.length)return 0;\\n        \\n        int pick = solve(ind,n-1,s);\\n        int notPick = solve(ind+1,n,s);\\n        \\n        return (pick+notPick);\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    int count = 0;\\n\\n    public int countVowelStrings(int n) {\\n        String[] s = new String[] { \"a\", \"e\", \"i\", \"o\", \"u\" };\\n        int[][] dp = new int[5][n + 1];\\n        for (int[] x : dp) {\\n            Arrays.fill(x, -1);\\n        }\\n        int ans = solve(0, n, s,dp);\\n        return ans;\\n    }\\n\\n    public int solve(int ind, int n, String[] s,int[][] dp) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (ind >= s.length) return 0;\\n        if(dp[ind][n]!=-1) return dp[ind][n];\\n\\n        int pick = solve(ind, n - 1, s,dp);\\n        int notPick = solve(ind + 1, n, s,dp);\\n\\n        return dp[ind][n] = (pick + notPick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        String[] s = new String[] { \"a\", \"e\", \"i\", \"o\", \"u\" };\\n        int[][] dp = new int[5][n + 1];\\n        for(int i=0;i<s.length;i++)\\n            dp[i][0] = 1;\\n        for(int i =4;i>=0;i--){\\n            for(int j=1;j<=n;j++){\\n                int pick = dp[i][j-1];\\n                int notPick = 0;\\n              if(i<4) notPick = dp[i+1][j];\\n                dp[i][j] = (pick+notPick);\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028650,
                "title": "python-easy-and-a-hard-way-backtracking-dp",
                "content": "**Using backtracking**\\n```\\n    def countVowelStrings(self, n):\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        res = []\\n        idx = 0\\n\\n        def rec(s, idx):\\n            if len(s) == n:\\n                res.append(s)\\n                return\\n            for i in vowels[idx:]:\\n                rec(s + i, idx)\\n                idx += 1\\n            return res\\n\\t\\t\\t\\n        return len(rec(\\'\\', idx))\\n```\\n\\n**Using DP array**\\n```\\ndef countVowelStrings(self, n):\\n        dp = [1] * 5 \\n        for x in range(n-1):\\n            for i in range(1, 5):\\n                dp[i] = dp[i] + dp[i - 1]\\n                \\n        return sum(dp)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def countVowelStrings(self, n):\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        res = []\\n        idx = 0\\n\\n        def rec(s, idx):\\n            if len(s) == n:\\n                res.append(s)\\n                return\\n            for i in vowels[idx:]:\\n                rec(s + i, idx)\\n                idx += 1\\n            return res\\n\\t\\t\\t\\n        return len(rec(\\'\\', idx))\\n```\n```\\ndef countVowelStrings(self, n):\\n        dp = [1] * 5 \\n        for x in range(n-1):\\n            for i in range(1, 5):\\n                dp[i] = dp[i] + dp[i - 1]\\n                \\n        return sum(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2027910,
                "title": "c-logic-based-2-line-solution",
                "content": "Logic based self explanatory code :\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        n += 4;\\n        \\n        int temp = n * (n - 1) * (n - 2) * (n - 3);\\n        \\n        return temp / 24;\\n    }\\n};\\n```\\n\\nOR\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        int temp = (n + 1) * (n + 2) * (n + 3) * (n + 4);\\n        \\n        return temp / 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        n += 4;\\n        \\n        int temp = n * (n - 1) * (n - 2) * (n - 3);\\n        \\n        return temp / 24;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        int temp = (n + 1) * (n + 2) * (n + 3) * (n + 4);\\n        \\n        return temp / 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027877,
                "title": "easy-peasy-squeasy-dp",
                "content": "well the question is entirely based on previous results as like we know 1 vowel will always make only 1 combinaation no matter how many spaces are given, so we initialize entire dp with 1, now n are given spaces and 5 are number for character we can use (vowels) , further i  noticed n character at 1 space gives us n as answere and then merging both of them i saw every answere is sum of previous two \\n\\'\\'\\'\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n       int dp[][]=new int[n][5];\\n        for(int i=0;i<n;i++)dp[i][0]=1;\\n        for(int i=0;i<5;i++)dp[0][i]=i+1;\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<5;j++)dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        }\\n        return dp[n-1][4];\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int countVowelStrings(int n) {\\n       int dp[][]=new int[n][5];\\n        for(int i=0;i<n;i++)dp[i][0]=1;\\n        for(int i=0;i<5;i++)dp[0][i]=i+1;\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<5;j++)dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2027270,
                "title": "count-sorted-vowel-strings",
                "content": "i) proceed to build string recursively.\\nii) insert next element in the string only if it is greater than the last element present and then decerease the n by 1.\\niii) finally that will be our required string if n==0 i.e string of size n is form.\\n\\nremember : in recursion we have to write a base condition , recursion will handle all other cases.\\n\\nPlease Upvote :) !\\n\\n```\\nclass Solution {\\npublic:\\n    vector<char> vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    \\n    void solve(int n,int last,int& count){\\n        if(n==0){\\n            count++;\\n            return;\\n        }\\n        for(int i=0;i<5;i++){\\n            if(i>=last){\\n                solve(n-1,i,count);\\n            }\\n        }\\n    }\\n    \\n    int countVowelStrings(int n) {\\n         int count=0;\\n        solve(n,0,count);\\n        return count;\\n    }\\n};\\n```\\n\\nMy other Solutions:\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/power-of-four/discuss/1799832/power-of-four-c100bit-manipualtion-easy-solution\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1862025/binary-tree-level-order-traversal-queue-binary-tree-easy-solution\\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/1850726/minimum-remove-to-make-valid-parentheses-c-on-simple-logic-easy-solution\\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/discuss/1849453/maximum-number-of-vowels-in-a-substring-of-given-length-csliding-window\\nhttps://leetcode.com/problems/reverse-prefix-of-word/discuss/1840375/reverse-prefix-of-word-100-c\\nhttps://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/discuss/1826246/find-n-unique-integers-sum-up-to-zero-100-simple-solution\\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1814346/find-minimum-in-rotated-sorted-array-binary-search-100-ceasy-solution\\nhttps://leetcode.com/problems/is-subsequence/discuss/1811098/is-subsequence-100-c-easy-solution\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1808021/search-in-rotated-sorted-array-ologn-solution-simple-solution-binary-search\\nhttps://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/discuss/1799853/check-if-number-is-a-sum-of-powers-of-three-100-easy-solution\\nhttps://leetcode.com/problems/sequential-digits/discuss/1751815/sequential-digits-c-100-easy-solution\\nhttps://leetcode.com/problems/binary-gap/discuss/1749101/binary-gap-100-c-simple-solution\\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1730888/kth-largest-element-in-an-array-c-sorting-simple-solution\\nhttps://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/discuss/1726527/queries-on-number-of-points-inside-a-circle-c-simple-mathematics\\nhttps://leetcode.com/problems/integer-to-roman/discuss/1726042/integer-to-roman-c-easy-to-understand\\nhttps://leetcode.com/problems/rings-and-rods/discuss/1724149/rings-and-rods-100-c-using-hashmap\\nhttps://leetcode.com/problems/number-complement/discuss/1722669/number-compliment\\nhttps://leetcode.com/problems/find-the-duplicate-number/discuss/1809351/find-the-duplicate-number-o1-space-binary-search-easy-solution\\nhttps://leetcode.com/problems/smallest-string-with-a-given-numeric-value/discuss/1872424/Smallest-String-With-A-Given-Numeric-Value-oror-C%2B%2B-O(n)-oror-Simple-Solution-with-Explaination\\nhttps://leetcode.com/problems/broken-calculator/discuss/1875269/Broken-Calculator-oror-C%2B%2B-100-O(n)-oror-Greedy-solution-with-Explanation-oror-Easy-Simple-Solution\\nhttps://leetcode.com/problems/generate-parentheses/discuss/1875357/Generate-Parentheses-oror-C%2B%2B-recursive-Approach-with-explaination-oror-Easy-Approach\\nhttps://leetcode.com/problems/boats-to-save-people/discuss/1877923/Boats-to-Save-People-oror-c%2B%2B-Greedy-oror-two-pointers-oror-sorting-oror-easy-Solution-with-explaination\\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/1901110/Minimum-Add-to-Make-Parentheses-Valid-oror-c%2B%2B-oror-100-oror-Simple-Solution-oror-String\\nhttps://leetcode.com/problems/game-of-life/discuss/1937884/Game-of-Life-oror-100-oror-C%2B%2B-oror-Matrix-IMPLEMENTATION\\nhttps://leetcode.com/problems/letter-case-permutation/discuss/2005077/Letter-Case-Permutation-oror-c%2B%2Boror-RecursionororEasy-Solution\\nhttps://leetcode.com/problems/max-number-of-k-sum-pairs/discuss/2006992/Max-Number-of-K-Sum-Pairs-oror-C%2B%2Boror-HashMapororEasy-Solution\\nhttps://leetcode.com/problems/implement-stack-using-queues/discuss/2009042/Implement-Stack-using-Queues-oror-c%2B%2B-oror-easySolutionoror-100",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<char> vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    \\n    void solve(int n,int last,int& count){\\n        if(n==0){\\n            count++;\\n            return;\\n        }\\n        for(int i=0;i<5;i++){\\n            if(i>=last){\\n                solve(n-1,i,count);\\n            }\\n        }\\n    }\\n    \\n    int countVowelStrings(int n) {\\n         int count=0;\\n        solve(n,0,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826446,
                "title": "c-easy-simple-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<5; j++){dp[j] = dp[j-1] + dp[j];}\\n        }\\n        return dp[4];\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<5; j++){dp[j] = dp[j-1] + dp[j];}\\n        }\\n        return dp[4];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496191,
                "title": "1-line-simple-solution-explained-c-100-faster",
                "content": "Since the order of alphabets has to lexicographic, the relative positions of all 5 vowels is fixed. The only thing we need to find is the count of occurence of each vowel. Let us say the counts are x1,x2...,x5\\nTherefore, x1+x2+x3+x4+x5 = n (All xi\\'s>=0)\\nThe number of ways for the above equation is (4+n)C(n) (I\\'ve added the general formula below), which on simplifying becomes \\n((n+1)*(n+2)*(n+3)*(n+4))/4!\\n```\\n int countVowelStrings(int n) {\\n        return ((n+1)*((n+2)*((n+3)*(n+4))/2)/3)/4;\\n  }\\n  ```\\n  The general formula when we have r non-negative integers which add upto an integer n is: (n+r-1)C(r-1)\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\n int countVowelStrings(int n) {\\n        return ((n+1)*((n+2)*((n+3)*(n+4))/2)/3)/4;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459936,
                "title": "100-faster",
                "content": "***Liked it? Kindly Upvote*** \\uD83D\\uDE0A\\u270C\\n\\n**n = 1 -> dp = [ 1 , 2 , 3 , 4 , 5 ]\\nn = 2 -> dp = [ 1 , 3 , 6 , 10 , 15 ]**\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        vector<int> dp(5 , 1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 1 ; j < 5 ; j++)\\n            {\\n                dp[j] = dp[j - 1] + dp[j];\\n            }\\n        }\\n        return dp[4];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        vector<int> dp(5 , 1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 1 ; j < 5 ; j++)\\n            {\\n                dp[j] = dp[j - 1] + dp[j];\\n            }\\n        }\\n        return dp[4];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100241,
                "title": "c-code-using-recursion-and-memoization-dp-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(int n,int vow,vector<vector<int>>&dp){\\n        if(vow==0) return dp[n][vow] =  0;\\n        if(dp[n][vow] != -1)\\n            return dp[n][vow];\\n        if(n==0) return dp[n][vow] = 1;\\n        dp[n][vow] = count(n,vow - 1,dp) + count(n - 1,vow,dp);\\n        return dp[n][vow];\\n    }\\n    int countVowelStrings(int n) {\\n        vector<vector<int>>dp(n + 1,vector<int>(6,-1));\\n        return count(n,5,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int count(int n,int vow,vector<vector<int>>&dp){\\n        if(vow==0) return dp[n][vow] =  0;\\n        if(dp[n][vow] != -1)\\n            return dp[n][vow];\\n        if(n==0) return dp[n][vow] = 1;\\n        dp[n][vow] = count(n,vow - 1,dp) + count(n - 1,vow,dp);\\n        return dp[n][vow];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1021489,
                "title": "c-recursive-vs-math-solutions-compared-and-explained-100-time-100-space",
                "content": "The core intuition here, came to me by just looking at the second example with `n == 2`.\\n\\n```cpp\\n\"aa\", \"ae\", \"ai\", \"ao\", \"au\", // all the combinations of {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} from the level before with \\'a\\' prepended\\n\"ee\", \"ei\", \"eo\", \"eu\",       // all the combinations of {\\'e\\', \\'i\\', \\'o\\', \\'u\\'} from the level before with \\'e\\' prepended\\n\"ii\", \"io\", \"iu\",             // all the combinations of {\\'i\\', \\'o\\', \\'u\\'} from the level before with \\'i\\' prepended\\n\"oo\", \"ou\",                   // all the combinations of {\\'o\\', \\'u\\'} from the level before with \\'o\\' prepended\\n\"uu\"                          // all the combinations of {\\'u\\'} from the level before with \\'u\\' prepended\\n```\\n\\nIf you consider `n == 3`, it is easier to think that you will get all the elements starting with `\\'a\\'` by just prepending that character in front of our previous results and so on.\\n\\nMore in general we will have `5` times all the combinations you can get with `5` elements for `n - 1`, plus `4` times all the combinations you can get with `4` elements and `n -1` and so on.\\n\\nWhen `n == 1` we can just return `k` (there are only `k` possible permutations of size `1` when you have `k` elements) and that is our base case; we also need to terminate the recursive calls when `k < 1`, since there are no possible combinations and we can add this as another base case, returning `0`.\\n\\nFinally, we can compose the general case as explained in 2 paragraphs above, as the result of calling `countVowelStrings` `5` times, decreasing `n` by `1` and further reducing `k` at each successive call.\\n\\nI know I could have used a loop, but I am a sucker for one-liner, so here it is!\\n\\nThe code, which scores about 5%, time, but almost 100% memory despite all the recursive call stack:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n, int k = 5) {\\n        return k < 1 ? 0 : n == 1 ? k : (countVowelStrings(--n, k--) + countVowelStrings(n, k--) + countVowelStrings(n, k--) + countVowelStrings(n, k--) + countVowelStrings(n, k--));\\n    }\\n};\\n```\\n\\nAnd this is if you could not figure out/remember the math in 30 mins (as I failed to d), otherwise you will just have to bow to the awesomely simplicity of combinatorics and compute the product of all the numbers in the `(n + 1) - (n+ 4)` range and divide it by the `4!`.\\n\\nIf you want to look a bit deeper at it, just consider that after picking `4` elements in our range, we only have one left and thus our solution can be computed at `n + 4` choose `4` - [formula and explanation](https://en.wikipedia.org/wiki/Binomial_coefficient).\\n\\nThe 100% Time, 100% Space code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n, int k = 5) {\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\n\"aa\", \"ae\", \"ai\", \"ao\", \"au\", // all the combinations of {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} from the level before with \\'a\\' prepended\\n\"ee\", \"ei\", \"eo\", \"eu\",       // all the combinations of {\\'e\\', \\'i\\', \\'o\\', \\'u\\'} from the level before with \\'e\\' prepended\\n\"ii\", \"io\", \"iu\",             // all the combinations of {\\'i\\', \\'o\\', \\'u\\'} from the level before with \\'i\\' prepended\\n\"oo\", \"ou\",                   // all the combinations of {\\'o\\', \\'u\\'} from the level before with \\'o\\' prepended\\n\"uu\"                          // all the combinations of {\\'u\\'} from the level before with \\'u\\' prepended\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n, int k = 5) {\\n        return k < 1 ? 0 : n == 1 ? k : (countVowelStrings(--n, k--) + countVowelStrings(n, k--) + countVowelStrings(n, k--) + countVowelStrings(n, k--) + countVowelStrings(n, k--));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n, int k = 5) {\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021160,
                "title": "count-sorted-vowel-strings-python-1-d-dp",
                "content": "```python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        a = [1] * 5\\n        for _ in range(1, n):\\n            for i in range(1, 5):\\n                a[i] += a[i-1]\\n        return sum(a)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        a = [1] * 5\\n        for _ in range(1, n):\\n            for i in range(1, 5):\\n                a[i] += a[i-1]\\n        return sum(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012544,
                "title": "java-one-line-solution-math-o-1-and-o-1",
                "content": "Mathematical Explanation:\\nThe process we count valid results can be considered as **to count combinations when sampling *n* elements with replacement from the set** *S* = { a, e, i, o, u }. Note, we only consider the combinations of the selected elements.\\n\\nFor example, if n = 3, { a, a, e } and { e, a, a } are considered as the same case, because once the elements are determined, their order is determined by the rule of lexicographically sorting. That\\'s why we only need to consider the combination results rather than the permutation.\\n\\nTo count the combination results of sampling ***n*** elements with replacement from a set S, where |S| = ***m***, we have the formula: ***Result = C(m + n - 1, n)***\\n\\nFor this question, we have:\\nresult = C( |S| + n - 1, n) = C(5 + n - 1, n) = C(n + 4, n) = C(n + 4, 4)\\n\\nSince the max value of ***n*** is 50, the maximum cumulative product is 54 * 53 * 52 * 51 = 7,590,024, which is within the valid range of **int**, so we can directly write our code as follows:\\n\\n```\\npublic int countVowelStrings(int n) {\\n  return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic int countVowelStrings(int n) {\\n  return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929417,
                "title": "python-dp-o-1-space-super-easy",
                "content": "```python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        a, e, i, o, u = 1, 1, 1, 1, 1\\n        for _ in range(n):\\n            a, e, i, o, u = a+e+i+o+u, e+i+o+u, i+o+u, o+u, u\\n        return a\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        a, e, i, o, u = 1, 1, 1, 1, 1\\n        for _ in range(n):\\n            a, e, i, o, u = a+e+i+o+u, e+i+o+u, i+o+u, o+u, u\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918400,
                "title": "javascript-math-o-1",
                "content": "1. Choose how many vowels will be used (1~5)\\n2. Get all sets of possible `(k-1)` converting points `C(n-1, k-1)` where `k` is the number of used vowels.\\n\\nSince there are 5 vowels at most, the time complexity is O(1)\\n\\nFor example, if given n = 6, there are 5 cases:\\n\\n1. Choose 1 vowel: 5 cases only;\\n2. Choose 2 vowels:\\nThere are `C(5,2) = 10` types of vowel combinations could be choose. Lets choose `a` and `i` as example.\\nOne case is `a-a-a-a-i-i`. From this case, there is **only one converting point to change `a` to `i`**. There are `n-1 = 5` candidates to be converting point, so the total number of possible strings is `C(5,2)*C(5,1)=50`;\\n3. Choose 3 vowels:\\nTake `a-a-e-i-i-i` as example. We have to **choose 2 positions as converting points** to convert `a->e` and `e->i` respectively. That is, `C(n-1, 2) = C(5, 2) = 10`.\\nSo the total possible number in this case is `C(5,3)C(n-1,2) = 100`\\n4. Choose 4 vowels: `C(5,4)C(n-1,3) = 50`\\n5. Choose 5 vowels: `C(n-1,4) = 5`\\n\\nSum of the 5 cases = `5+50+100+50+5 = 210`\\n\\n```\\nvar countVowelStrings = function(n) {\\n    return 5 + 10 * combination(n-1, 1) + 10 * combination(n-1, 2) + 5 * combination(n-1, 3) + combination(n-1, 4);\\n};\\n\\nfunction combination(n, k) {\\n    if (k === 1)\\n        return n;\\n    \\n    return combination(n-1, k-1)*n/k;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "1. Choose how many vowels will be used (1~5)\\n2. Get all sets of possible `(k-1)` converting points `C(n-1, k-1)` where `k` is the number of used vowels.\\n\\nSince there are 5 vowels at most, the time complexity is O(1)\\n\\nFor example, if given n = 6, there are 5 cases:\\n\\n1. Choose 1 vowel: 5 cases only;\\n2. Choose 2 vowels:\\nThere are `C(5,2) = 10` types of vowel combinations could be choose. Lets choose `a` and `i` as example.\\nOne case is `a-a-a-a-i-i`. From this case, there is **only one converting point to change `a` to `i`**. There are `n-1 = 5` candidates to be converting point, so the total number of possible strings is `C(5,2)*C(5,1)=50`;\\n3. Choose 3 vowels:\\nTake `a-a-e-i-i-i` as example. We have to **choose 2 positions as converting points** to convert `a->e` and `e->i` respectively. That is, `C(n-1, 2) = C(5, 2) = 10`.\\nSo the total possible number in this case is `C(5,3)C(n-1,2) = 100`\\n4. Choose 4 vowels: `C(5,4)C(n-1,3) = 50`\\n5. Choose 5 vowels: `C(n-1,4) = 5`\\n\\nSum of the 5 cases = `5+50+100+50+5 = 210`\\n\\n```\\nvar countVowelStrings = function(n) {\\n    return 5 + 10 * combination(n-1, 1) + 10 * combination(n-1, 2) + 5 * combination(n-1, 3) + combination(n-1, 4);\\n};\\n\\nfunction combination(n, k) {\\n    if (k === 1)\\n        return n;\\n    \\n    return combination(n-1, k-1)*n/k;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3073092,
                "title": "beats-100-in-time-80-in-space-complexity-c-precise",
                "content": "# Code\\n```\\nclass Solution {\\n    int t[6][51];\\n      int solve(int i, int n, int k){\\n         if(k==0){\\n                return 1;\\n            }\\n        if(i==n){\\n                return 0;\\n        }\\n        if(t[i][k] != -1){\\n            return t[i][k];\\n        }\\n        int cnt1=solve(i,n,k-1);\\n        int cnt2=solve(i+1,n, k);\\n        return t[i][k]=cnt1+cnt2;\\n    }\\npublic:\\n    int countVowelStrings(int k) {\\n        memset(t,-1, sizeof(t));\\n       return  solve(0, 5, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int t[6][51];\\n      int solve(int i, int n, int k){\\n         if(k==0){\\n                return 1;\\n            }\\n        if(i==n){\\n                return 0;\\n        }\\n        if(t[i][k] != -1){\\n            return t[i][k];\\n        }\\n        int cnt1=solve(i,n,k-1);\\n        int cnt2=solve(i+1,n, k);\\n        return t[i][k]=cnt1+cnt2;\\n    }\\npublic:\\n    int countVowelStrings(int k) {\\n        memset(t,-1, sizeof(t));\\n       return  solve(0, 5, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029104,
                "title": "java-backtracking-worst-case-but-better-understanding",
                "content": "```\\n`class Solution {\\n    int totalcount = 0;\\n    public int countVowelStrings(int n) {\\n        char[]arr = new char[]{\\'a\\' , \\'e\\' , \\'i\\' , \\'o\\' , \\'u\\'};\\n        dfs(arr , 0 , 0 , n);\\n        return totalcount;\\n    }\\n    public void dfs(char[]arr , int start , int count , int size){\\n        if(count == size){\\n            totalcount ++;\\n            return;\\n        }\\n        for(int i  = start ; i<5 ; i++){\\n            count=count+1;\\n            dfs(arr , i , count , size);\\n            count=count-1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n`class Solution {\\n    int totalcount = 0;\\n    public int countVowelStrings(int n) {\\n        char[]arr = new char[]{\\'a\\' , \\'e\\' , \\'i\\' , \\'o\\' , \\'u\\'};\\n        dfs(arr , 0 , 0 , n);\\n        return totalcount;\\n    }\\n    public void dfs(char[]arr , int start , int count , int size){\\n        if(count == size){\\n            totalcount ++;\\n            return;\\n        }\\n        for(int i  = start ; i<5 ; i++){\\n            count=count+1;\\n            dfs(arr , i , count , size);\\n            count=count-1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028815,
                "title": "python-the-easiest-one-with-mad-skillz-paint-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/4e09b616-ca35-4732-b657-22235cb2d810_1652269151.3420324.png)\\n\\n\\tclass Solution:\\n\\t\\tdef countVowelStrings(self, n: int) -> int:\\n\\t\\t\\tvowels = deque([5,4,3,2,1])\\n\\t\\t\\tsm = temp = sum(vowels)\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tfor _ in range(5):\\n\\t\\t\\t\\t\\tvowels.append(temp)\\n\\t\\t\\t\\t\\ttemp -= vowels.popleft()\\n\\t\\t\\t\\t\\tsm += temp\\n\\t\\t\\t\\ttemp = sm\\n\\t\\t\\treturn vowels[0]",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/4e09b616-ca35-4732-b657-22235cb2d810_1652269151.3420324.png)\\n\\n\\tclass Solution:\\n\\t\\tdef countVowelStrings(self, n: int) -> int:\\n\\t\\t\\tvowels = deque([5,4,3,2,1])\\n\\t\\t\\tsm = temp = sum(vowels)\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tfor _ in range(5):\\n\\t\\t\\t\\t\\tvowels.append(temp)\\n\\t\\t\\t\\t\\ttemp -= vowels.popleft()\\n\\t\\t\\t\\t\\tsm += temp\\n\\t\\t\\t\\ttemp = sm\\n\\t\\t\\treturn vowels[0]",
                "codeTag": "Java"
            },
            {
                "id": 2028535,
                "title": "simple-solution-recursion-memoization-tabular-dynamic-programming",
                "content": "### Recursion || Memoization || Tabular Dynamic Programming\\n\\n**Recursion:**\\n\\n*Thought Process:*\\n1.  Pick an element in repeated times.\\n2. Don\\'t pick the element.\\n(Same thought of `unbounded knapsack` or `combination sum I` problem)\\n\\n> **Void Recursion:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void calculate(vector<char>& v,int n,int index,int& ans){\\n        if(n == 0){\\n\\t\\t/* when the string length becomes 0, then we have found the lexicographically \\n\\t\\tsorted string ,increment ans by 1.*/\\n\\t\\t\\tans++;\\n            return;\\n        }\\n        if(index >= v.size()) return;\\n        //pick - after picking element, string length reduce by 1\\n        calculate(v,n-1,index,ans);\\n        // not pick - if i didn\\'t pick the element, string lenght should be same\\n        calculate(v,n,index+1,ans);\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0; // starting picking elements from index 0\\n        int ans = 0;\\n        calculate(v,n,index,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n> **Value Returning Recustion:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int calculate(vector<char>& v,int n,int index){\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(index >= v.size()) return 0;\\n        //pick\\n        int x = calculate(v,n-1,index);\\n        // not pick\\n        int y = calculate(v,n,index+1);\\n        return x+y;\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0;\\n        int ans = 0;\\n        ans = calculate(v,n,index);\\n        return ans;\\n    }\\n};\\n```\\n\\n> **Memoization:**\\n\\n- Now as we found the returning value Recursion functionn, now we will easily memoize it\\n- See, which parameters are changing in our recursion function\\n\\t1. n\\n\\t2. index\\n- So, our memoization vector is 2d vector.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int calculate(vector<char>& v,int n,int index,vector<vector<int>>& memo){\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(memo[n][index] != -1) return memo[n][index];\\n        if(index >= v.size()) return 0;\\n        //pick\\n        int x = calculate(v,n-1,index,ans,memo);\\n        // not pick\\n        int y = calculate(v,n,index+1,ans,memo);\\n        return memo[n][index] = x+y;\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0;\\n        int ans = 0;\\n        vector<vector<int>> memo(n+1,vector<int>(6,-1)); // 5 vowels\\n        ans = calculate(v,n,index,memo);\\n        return ans;\\n    }\\n};\\n```\\n\\n> **Tabulation**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0;\\n        int ans = 0;\\n        vector<vector<int>> dp(n+1,vector<int>(5,0)); // 5 vowels\\n        \\n        /* base case fill\\n\\t\\t\\t if n == 1 , \\n\\t\\t\\t then a,e,i,o,u :  number if length 1 string starting with a,e,i,o,u is 1\\n        */\\n\\t\\tfor(int i = 1; i < 5 ; i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        /* for the case of u, if n = 1,2,3,4,... \\n\\t\\t\\tthe number of strings generated by u is: u,uu,uuu,uuuu,... \\n\\t\\t\\ti.e., 1 one string respectively.\\n        */\\n\\t\\t\\n\\t\\t/*\\n         base case fill , if char = u\\n\\t\\t\\t- at index 4 char is u in v vector\\n        */\\n\\t\\t\\n\\t\\tfor(int N = 1; N < n+1 ; N++){\\n            dp[N][4] = 1;\\n        }\\n        \\n        \\n        // n->i and index -> j replaceing in recursion memo\\n        for(int i = 1 ; i < n+1 ; i++){\\n\\t\\t// in increasing order of n.\\n            for(int j = 3 ; j >=0 ; j--){ \\n\\t\\t\\t// in decreasing order of vowels as we dp[i][j] depends on dp[i][j+1];\\n                dp[i][j] = dp[i-1][j] + dp[i][j+1];\\n            }\\n        }\\n        return accumulate(dp[n].begin(),dp[n].end(),0); // sum of the last vector dp[n] is our ans.\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void calculate(vector<char>& v,int n,int index,int& ans){\\n        if(n == 0){\\n\\t\\t/* when the string length becomes 0, then we have found the lexicographically \\n\\t\\tsorted string ,increment ans by 1.*/\\n\\t\\t\\tans++;\\n            return;\\n        }\\n        if(index >= v.size()) return;\\n        //pick - after picking element, string length reduce by 1\\n        calculate(v,n-1,index,ans);\\n        // not pick - if i didn\\'t pick the element, string lenght should be same\\n        calculate(v,n,index+1,ans);\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0; // starting picking elements from index 0\\n        int ans = 0;\\n        calculate(v,n,index,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int calculate(vector<char>& v,int n,int index){\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(index >= v.size()) return 0;\\n        //pick\\n        int x = calculate(v,n-1,index);\\n        // not pick\\n        int y = calculate(v,n,index+1);\\n        return x+y;\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0;\\n        int ans = 0;\\n        ans = calculate(v,n,index);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int calculate(vector<char>& v,int n,int index,vector<vector<int>>& memo){\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(memo[n][index] != -1) return memo[n][index];\\n        if(index >= v.size()) return 0;\\n        //pick\\n        int x = calculate(v,n-1,index,ans,memo);\\n        // not pick\\n        int y = calculate(v,n,index+1,ans,memo);\\n        return memo[n][index] = x+y;\\n    }\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0;\\n        int ans = 0;\\n        vector<vector<int>> memo(n+1,vector<int>(6,-1)); // 5 vowels\\n        ans = calculate(v,n,index,memo);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int countVowelStrings(int n) {\\n        vector<char> v{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int index = 0;\\n        int ans = 0;\\n        vector<vector<int>> dp(n+1,vector<int>(5,0)); // 5 vowels\\n        \\n        /* base case fill\\n\\t\\t\\t if n == 1 , \\n\\t\\t\\t then a,e,i,o,u :  number if length 1 string starting with a,e,i,o,u is 1\\n        */\\n\\t\\tfor(int i = 1; i < 5 ; i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        /* for the case of u, if n = 1,2,3,4,... \\n\\t\\t\\tthe number of strings generated by u is: u,uu,uuu,uuuu,... \\n\\t\\t\\ti.e., 1 one string respectively.\\n        */\\n\\t\\t\\n\\t\\t/*\\n         base case fill , if char = u\\n\\t\\t\\t- at index 4 char is u in v vector\\n        */\\n\\t\\t\\n\\t\\tfor(int N = 1; N < n+1 ; N++){\\n            dp[N][4] = 1;\\n        }\\n        \\n        \\n        // n->i and index -> j replaceing in recursion memo\\n        for(int i = 1 ; i < n+1 ; i++){\\n\\t\\t// in increasing order of n.\\n            for(int j = 3 ; j >=0 ; j--){ \\n\\t\\t\\t// in decreasing order of vowels as we dp[i][j] depends on dp[i][j+1];\\n                dp[i][j] = dp[i-1][j] + dp[i][j+1];\\n            }\\n        }\\n        return accumulate(dp[n].begin(),dp[n].end(),0); // sum of the last vector dp[n] is our ans.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027651,
                "title": "simple-solution-easy-understanding",
                "content": "```\\n//Please do upvote, if you like my solution :)\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(int n,vector<char> &v,int idx){\\n        if(n == 0){\\n            ans++;\\n            return;\\n        }\\n        if(idx >= v.size()) return;\\n        solve(n-1,v,idx);\\n        solve(n,v,idx+1);\\n    }\\n    int countVowelStrings(int n) {\\n        vector<char> v = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        solve(n,v,0);\\n        return ans;\\n    }\\n};\\n//Please do upvote, if you like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//Please do upvote, if you like my solution :)\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(int n,vector<char> &v,int idx){\\n        if(n == 0){\\n            ans++;\\n            return;\\n        }\\n        if(idx >= v.size()) return;\\n        solve(n-1,v,idx);\\n        solve(n,v,idx+1);\\n    }\\n    int countVowelStrings(int n) {\\n        vector<char> v = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        solve(n,v,0);\\n        return ans;\\n    }\\n};\\n//Please do upvote, if you like my solution :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027589,
                "title": "c-simplest-approach-pattern-recognizing-and-efficient-o-n",
                "content": "**Question:**\\n```\\nGiven an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\\n\\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\\n```\\n* Before jumping to answering the question, lets understand **lexicographic order**. What it is?\\n* The term **Lexicographical order** is a mathematical term known by names: lexical order, lexicographic(al) product, alphabetical order, or **dictionary order**. \\n* *You can read more at:[Javatpoint](https://www.javatpoint.com/lexicographical-order-java)*\\n* Question is a simple question of permutation and combinations, given there is a length of string given \"n\" we have to find ho many combinations are possible **only of length n** and by using **only vowels** i.e. a,e,i,o,u. Let\\'s understand the same with the given test case.\\n\\n**Example Test Case:**\\n```\\nInput: n = 1\\nOutput: 5\\nExplanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"].\\n```\\n\\n* Now, we need to understand a simple pattern which is being followed in the question:\\n```\\n\\t      a  e  i  o  u\\n    n=1   1  1  1  1  1  /a, e, i, o, u\\n    n=2   5  4  3  2  1  /a-> aa,ae,ai,ao,au | e-> ee,ei,eo,eu | i-> ii,io,iu | o-> oo,ou | u-> uu\\n```\\n**Solution:**\\n* We areu using 5 variables that are given in the question a,e,i,o,u.\\n* Here we are adding previous value with the current next element in serial order of of a-e-i-o-u.\\n* To understand this go to above example where **n=2**, the while loop will run one time and there will be only **one element** which start with **\\'u\\'**. For every other element you can see it is **previous+next count.**\\n* We will return the function by adding every element(variable) at the end.\\n*  Time complexity: O(n).\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a=1,e=1,i=1,o=1,u=1;\\n        while(--n)\\n        {\\n            o+=u;\\n            i+=o;\\n            e+=i;\\n            a+=e;\\n        }\\n        return a+e+i+o+u;\\n    }\\n};\\n```\\n**I hope you guys resolved your doubt/query or have learned a new thing, if you really liked the approach / solution / content / explanation don\\'t forget to upvote!!. Cheers!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nGiven an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\\n\\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\\n```\n```\\nInput: n = 1\\nOutput: 5\\nExplanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"].\\n```\n```\\n\\t      a  e  i  o  u\\n    n=1   1  1  1  1  1  /a, e, i, o, u\\n    n=2   5  4  3  2  1  /a-> aa,ae,ai,ao,au | e-> ee,ei,eo,eu | i-> ii,io,iu | o-> oo,ou | u-> uu\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int a=1,e=1,i=1,o=1,u=1;\\n        while(--n)\\n        {\\n            o+=u;\\n            i+=o;\\n            e+=i;\\n            a+=e;\\n        }\\n        return a+e+i+o+u;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742955,
                "title": "unbounded-knapsack-pattern",
                "content": "**I observed that we can convert this problem in unbounded knapsack by converting [a,e,i,o,u] into [1,1,1,1,1] . Now it became standard subset sum problem we have to find number of subset with subset sum=n and we can pick one element more than once**\\n\\n**this is my first post so please upvote if You like it**\\n```\\nint countVowelStrings(int n) {\\n       vector<int>v(5,1);\\n       int dp[6][n+1];\\n       \\n         for(int i=0;i<n+1;i++){\\n            dp[0][i]=0;\\n        }\\n         \\n        for(int i=0;i<6;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<6;i++){\\n            for(int j=1;j<n+1;j++){\\n                \\n                if(v[i-1]<=j){\\n                    dp[i][j]=dp[i][j-v[i-1]] +dp[i-1][j];\\n                }\\n                else dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[5][n];\\n    } \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelStrings(int n) {\\n       vector<int>v(5,1);\\n       int dp[6][n+1];\\n       \\n         for(int i=0;i<n+1;i++){\\n            dp[0][i]=0;\\n        }\\n         \\n        for(int i=0;i<6;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<6;i++){\\n            for(int j=1;j<n+1;j++){\\n                \\n                if(v[i-1]<=j){\\n                    dp[i][j]=dp[i][j-v[i-1]] +dp[i-1][j];\\n                }\\n                else dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[5][n];\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539994,
                "title": "top-down-dp-runtime-1-ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n    \\n        int [][]dp=new int[5][n+1];\\n        int i,j;\\n       \\n        for(i=0;i<5;i++)\\n        {\\n            for(j=0;j<=n;j++)\\n            {\\n                     if(i==0)\\n                     {\\n                         dp[i][j]=1;\\n                     }\\n                    else if(j==0)\\n                    {\\n                         dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                     dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                    }\\n                }\\n        }\\n        return dp[4][n];\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n    \\n        int [][]dp=new int[5][n+1];\\n        int i,j;\\n       \\n        for(i=0;i<5;i++)\\n        {\\n            for(j=0;j<=n;j++)\\n            {\\n                     if(i==0)\\n                     {\\n                         dp[i][j]=1;\\n                     }\\n                    else if(j==0)\\n                    {\\n                         dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                     dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                    }\\n                }\\n        }\\n        return dp[4][n];\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358029,
                "title": "o-1-time-o-1-space-discrete-math",
                "content": "Given that we have a sorted combinations problem, with respect to permutations, we can apply the *Combinations With Repetitions* formula:\\n\\n![image](https://assets.leetcode.com/users/images/b85a59ce-2ba5-4b5b-84ee-4bad83b4258d_1627068909.2655072.png)\\n\\nWhere n is our object (chars) and k is our repetition (4 vowels)\\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        return ((n + 1) * (n + 2) * (n + 3) * (n + 4))/24;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        return ((n + 1) * (n + 2) * (n + 3) * (n + 4))/24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310727,
                "title": "simple-and-concise-c-solution-with-explanation-100-faster",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\nTry to observe the pattern.\\nNote: Here the element present at each index represents the number of combinations that can be formed by the using the vowels {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\nfor n=1 dp[]={1,1,1,1,1}\\nfor n=2 dp[]={5,4,3,2,1}\\nfor n=3 dp[]={15,10,6,3,1}\\n```\\n int countVowelStrings(int n) {\\n        vector<int> dp(5,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=3;j>=0;j--)\\n            {\\n                dp[j]=dp[j+1]+dp[j];\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<5;i++)\\n        {\\n            res+=dp[i];\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int countVowelStrings(int n) {\\n        vector<int> dp(5,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=3;j>=0;j--)\\n            {\\n                dp[j]=dp[j+1]+dp[j];\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<5;i++)\\n        {\\n            res+=dp[i];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1046698,
                "title": "c-solution-with-explanation-two-methods-with-full-explanation",
                "content": "***Method 1 - (Using Backtracking)***\\n\\nSolution Idea: \\n1. We first create a vector storing all the vowels present in English alphabets.\\n2. We the create a function called *helper* which contains the backtracking algo.\\n3. The code has been further commented in each part, for better understanding.\\n\\n```\\nclass Solution {\\n    \\n    int count = 0;\\n    vector<int> word = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}; //vector containg all the 5 vowels.\\n    \\n    void helper(string &s, int n) // string s contains the answer string.\\n    {\\n        if(s.size() == n)\\n          count++; // if the size of s reaches n (given in the problem), we increase count value by 1.\\n        \\n        for(int i=0;i<=4;i++)\\n        { // iterating over all the elements of vector word.\\n            if(s.size() == 0)\\n            { // initially, when answer string s in empty, we directly put the letter from word vector, and later perform backtracking.\\n\\t\\t\\t\\ts.push_back(word[i]);\\n\\t\\t\\t\\thelper(s, n);\\n\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t}\\n        \\n\\t\\t\\telse if(s.size()<n && s.back()<=word[i])\\n\\t\\t\\t{ // else if size of answer string is greater than 0, but not yet equal to n, and also **the last letter of the string s, is less than the current letter**,\\n\\t\\t\\t  // we push the current letter in the answer string and do the backtracking as usual.\\n\\t\\t\\t\\ts.push_back(word[i]);\\n\\t\\t\\t\\thelper(s, n);\\n\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t}\\n        }\\n    }\\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        string s ;\\n        helper(s, n);\\n        return count; // returning count value as answer.\\n    }\\n};\\n```\\n**Time Complexity = O(5^n)**. \\nFor every letter out of n, we have 5 possibilities.\\n****\\n***Method 2 - (Mathematical Pattern)***\\n\\nSolution Idea: \\n Basic idea is to observe a patern amongst the relationship between the given value of n, and the output.\\n\\nSome observations - \\n\\t1. For n=1, output is 5.\\n\\t2. For n=2, output is 15. \\n\\t   By Triangle number formula, putting N=5 in\\n\\t   [ N*(N+1) ]/ [1* 2], we get 15.   \\n\\t3. For n=3, output is 35.\\n\\t  Putting N=5, in \\n\\t [ N*(N+1)* (N+2) ]/ [ 1* 2* 3 ]\\n\\t \\n\\t \\nSo, for any value n:\\nwe put N=5 in the formula - \\n\\n![image](https://assets.leetcode.com/users/images/953ab72b-8cd5-4c16-aa4a-a57433a47c1a_1612279954.0210714.png)\\n\\n\\t\\nHence we arrive at our needed expression.\\t\\n```  \\nclass Solution {   \\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n};\\n```\\n**Time Complexity = O(1)**.\\n****\\n\\nView more solutions [HERE](https://github.com/noob-hu-yaar/Leetcode/tree/master/nandincpp)\\n****",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int count = 0;\\n    vector<int> word = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}; //vector containg all the 5 vowels.\\n    \\n    void helper(string &s, int n) // string s contains the answer string.\\n    {\\n        if(s.size() == n)\\n          count++; // if the size of s reaches n (given in the problem), we increase count value by 1.\\n        \\n        for(int i=0;i<=4;i++)\\n        { // iterating over all the elements of vector word.\\n            if(s.size() == 0)\\n            { // initially, when answer string s in empty, we directly put the letter from word vector, and later perform backtracking.\\n\\t\\t\\t\\ts.push_back(word[i]);\\n\\t\\t\\t\\thelper(s, n);\\n\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t}\\n        \\n\\t\\t\\telse if(s.size()<n && s.back()<=word[i])\\n\\t\\t\\t{ // else if size of answer string is greater than 0, but not yet equal to n, and also **the last letter of the string s, is less than the current letter**,\\n\\t\\t\\t  // we push the current letter in the answer string and do the backtracking as usual.\\n\\t\\t\\t\\ts.push_back(word[i]);\\n\\t\\t\\t\\thelper(s, n);\\n\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t}\\n        }\\n    }\\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        string s ;\\n        helper(s, n);\\n        return count; // returning count value as answer.\\n    }\\n};\\n```\n```  \\nclass Solution {   \\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971837,
                "title": "the-method-to-obtain-the-answer-of-n-1-n-2-n-3-n-4-24",
                "content": "As we know, when n = 1, the answer = 5 that is 1 + 1 + 1 + 1 + 1;\\nwhen n = 2, the answer = 15 that is 1 + 2 + 3 + 4 + 5\\n         n = 3, the answer = 35, that is 1 + 3 + 6 + 10 + 15\\n\\t\\t ....\\n\\t\\t we can set the f(n) = fn(1) + fn(2) + fn(3) + fn(4) + fn(5)\\n\\t\\t fn(1) = 1; \\n\\t\\t fn(2) = 1 + fn-1(2), so fn(2) = 1+1+... + 1 = n;\\n\\t\\t fn(3) = fn-1(3) + fn(2) = n + fn-1(3), so fn(3) = 1 + 2 + ... + n = n(n+1)/2;\\n\\t\\t as usual, fn(4) = 1*2/2 + 2 * 3/2 + 3*4/2 +... + n(n+1)/2 = n(n+1)(n+2)/6;\\n\\t\\t fn(5) = 1*2*3/6 + 2*3*4/6 +...+n(n+1)(n+2)/6 = n(n+1)(n+2)(n+3)/24;\\n\\t\\t so f(n) = fn(1)+fn(2)+fn(3)+fn(4)+fn(5) = 1 + n + n(n+1)/2 + n(n+1)(n+2)/6+n(n+1)(n+2)(n+3)/24 = (n+1)(n+2)(n+3)(n+4)/24\\n\\t\\t",
                "solutionTags": [],
                "code": "As we know, when n = 1, the answer = 5 that is 1 + 1 + 1 + 1 + 1;\\nwhen n = 2, the answer = 15 that is 1 + 2 + 3 + 4 + 5\\n         n = 3, the answer = 35, that is 1 + 3 + 6 + 10 + 15\\n\\t\\t ....\\n\\t\\t we can set the f(n) = fn(1) + fn(2) + fn(3) + fn(4) + fn(5)\\n\\t\\t fn(1) = 1; \\n\\t\\t fn(2) = 1 + fn-1(2), so fn(2) = 1+1+... + 1 = n;\\n\\t\\t fn(3) = fn-1(3) + fn(2) = n + fn-1(3), so fn(3) = 1 + 2 + ... + n = n(n+1)/2;\\n\\t\\t as usual, fn(4) = 1*2/2 + 2 * 3/2 + 3*4/2 +... + n(n+1)/2 = n(n+1)(n+2)/6;\\n\\t\\t fn(5) = 1*2*3/6 + 2*3*4/6 +...+n(n+1)(n+2)/6 = n(n+1)(n+2)(n+3)/24;\\n\\t\\t so f(n) = fn(1)+fn(2)+fn(3)+fn(4)+fn(5) = 1 + n + n(n+1)/2 + n(n+1)(n+2)/6+n(n+1)(n+2)(n+3)/24 = (n+1)(n+2)(n+3)(n+4)/24\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 918616,
                "title": "c-dp-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countVowelStrings(int n) {\\n        if(n==0)\\n            return 0;\\n        vector<vector<int> > dp(n+1,vector<int> (5,0));\\n        //dp[i][j]=> sorted string of length i ending at vowel no j(a,e,i,o,u)\\n        for(int i=0;i<5;i++){\\n            dp[1][i]=1;\\n        }\\n        \\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<5;j++){\\n                for(int k=0;k<=j;k++)\\n                    dp[i][j]+=dp[i-1][k];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<5;i++){\\n            ans+=dp[n][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countVowelStrings(int n) {\\n        if(n==0)\\n            return 0;\\n        vector<vector<int> > dp(n+1,vector<int> (5,0));\\n        //dp[i][j]=> sorted string of length i ending at vowel no j(a,e,i,o,u)\\n        for(int i=0;i<5;i++){\\n            dp[1][i]=1;\\n        }\\n        \\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<5;j++){\\n                for(int k=0;k<=j;k++)\\n                    dp[i][j]+=dp[i-1][k];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<5;i++){\\n            ans+=dp[n][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515362,
                "title": "t-c-o-n-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1,e=1,i=1,o=1,u=1;\\n        for(int k=1;k<n;k++){\\n            a=a+e+i+o+u;\\n            e=e+i+o+u;\\n            i=i+o+u;\\n            o=o+u;\\n        }\\n        return a+e+i+o+u;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1,e=1,i=1,o=1,u=1;\\n        for(int k=1;k<n;k++){\\n            a=a+e+i+o+u;\\n            e=e+i+o+u;\\n            i=i+o+u;\\n            o=o+u;\\n        }\\n        return a+e+i+o+u;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391096,
                "title": "100-fast-c-solution-recursive-solution-with-memoization",
                "content": "# Intuition\\nwe have to form all permuntation of vowels of length n. we can consider 5 vowel in number as 0 to 4. In recursive approach we have to once iterate till n for count and till 4 to change every character of vowel\\n\\n# Approach\\nBaseCase for recursive function will be \\n```        \\nif(count>=n){\\n    return 1;\\n}\\nif(vowel>=5){\\n    return 0;\\n}\\n```\\n\\nAnd as i explained we need to perform 2 operations\\n```\\n// For increasing vowel\\nint f1=f(vowel+1,count,n,dp);\\n\\n// For increasing count \\nint f2=f(vowel,count+1,n,dp);\\n\\nreturn f1+f2\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n(n*5)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int vowel,int count,int n,vector<vector<int>> &dp){\\n        if(count>=n){\\n            return 1;\\n        }\\n        if(vowel>=5){\\n            return 0;\\n        }\\n\\n        if(dp[count][vowel]!=-1) return dp[count][vowel];\\n\\n        int f1=f(vowel+1,count,n,dp);\\n        int f2=f(vowel,count+1,n,dp);\\n\\n        return dp[count][vowel]=f1+f2;\\n    }\\n\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(5,-1));\\n        return f(0,0,n,dp);\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF IT HELPED YOU.\\nTHANK YOU",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```        \\nif(count>=n){\\n    return 1;\\n}\\nif(vowel>=5){\\n    return 0;\\n}\\n```\n```\\n// For increasing vowel\\nint f1=f(vowel+1,count,n,dp);\\n\\n// For increasing count \\nint f2=f(vowel,count+1,n,dp);\\n\\nreturn f1+f2\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int vowel,int count,int n,vector<vector<int>> &dp){\\n        if(count>=n){\\n            return 1;\\n        }\\n        if(vowel>=5){\\n            return 0;\\n        }\\n\\n        if(dp[count][vowel]!=-1) return dp[count][vowel];\\n\\n        int f1=f(vowel+1,count,n,dp);\\n        int f2=f(vowel,count+1,n,dp);\\n\\n        return dp[count][vowel]=f1+f2;\\n    }\\n\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(5,-1));\\n        return f(0,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561733,
                "title": "using-probability-theory",
                "content": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return (n+4)*(n+3)*(n+2)*(n+1)//24\\n```\\n# Explanation:\\nThe number of strings of length n that consist only of vowels and are lexicographically sorted is equal to the number of strings of length n that consist only of vowels and are lexicographically sorted and end with \\'u\\' plus the number of strings of length n that consist only of vowels and are lexicographically sorted and end with \\'o\\' plus the number of strings of length n that consist only of vowels and are lexicographically sorted and end with \\'i\\' plus the number of strings of length n that consist only of vowels and are lexicographically sorted and end with \\'e\\' plus the number of strings of length n that consist only of vowels and are lexicographically sorted and end with \\'a\\'.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return (n+4)*(n+3)*(n+2)*(n+1)//24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534302,
                "title": "100-faster-c-easy-solution-dp-approach",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int dp[52][52];\\n    int countVowelStrings(int n) {\\n        for(int i=0; i<5; i++) {\\n            dp[0][i] = 1;\\n        }\\n        int sum = 5;\\n        for(int i = 1; i<n; i++) {\\n            dp[i][0] = sum;\\n            \\n            for(int j = 1; j<5; j++) {\\n                dp[i][j] = (dp[i][j-1] - dp[i-1][j-1]);\\n                sum+=dp[i][j];\\n            }\\n        }\\n        return  sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[52][52];\\n    int countVowelStrings(int n) {\\n        for(int i=0; i<5; i++) {\\n            dp[0][i] = 1;\\n        }\\n        int sum = 5;\\n        for(int i = 1; i<n; i++) {\\n            dp[i][0] = sum;\\n            \\n            for(int j = 1; j<5; j++) {\\n                dp[i][j] = (dp[i][j-1] - dp[i-1][j-1]);\\n                sum+=dp[i][j];\\n            }\\n        }\\n        return  sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044148,
                "title": "one-line-code-pattern-5-15-35-70-c-o-1-time-and-space",
                "content": "It show a patter (5,15,35,70,126...) which is solve by  **(n+4)*(n+3)*(n+2)*(n+1)/24** equation.\\n*visit [OEIS](https://oeis.org/search?q=5+15+35+70&language=english&go=Search) for find equation of any pattern.*\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+3)*(n+4)*(n+2)*(n+1)/24;\\n    }\\n};\\n```\\n\\n**TC : O(1) \\nSC : O(1)**\\n\\n\\n\\n![Pattern](https://assets.leetcode.com/users/images/5968be02-562d-4f06-83cd-f08e8c4da9ec_1652687125.3145478.png)\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+3)*(n+4)*(n+2)*(n+1)/24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029719,
                "title": "o-n-runtime-0-ms-faster-than-100-00-intuition-explained",
                "content": "**Appraoch 1 **\\n\\nIntution : At First glance it is easy to understand that this is backtracking related question. All we have to do is count all the combination that can generate string of length n and will be of sorted order.\\n\\nIf we go with backtracking the time complexity will be 2^n. **(OH MY GOD)**. It is too slow. Can we do something better. Lets analyize few test cases to understand the intution may be we can figure out something better.\\n\\n1. n=1\\n\\tnumber of possible string will be 5 (a,e,i,o,u)\\n\\t\\n2.  n=2\\na_  Here we have 5 possible choice for string starting with a\\ne_  Here we have 4 possible choice for string starting with e\\ni_   Here we have 3 possible choice for string starting with i\\no_  Here we have 2 possible choice for string starting with o\\nu_  Here we have 1 possible choice for string starting with u\\n\\nwe have 5 possible choice after a because we need to maintain sorted or so after a we can only place a e i o u ( 5 characters). Similar explaination for string starting with e,i,o,u\\n\\nTotal String 5+4+3+2+1 =15\\n\\n3. n=3\\n\\naa5\\nae4\\nai3\\nao2\\nau1\\ntotal 15\\n\\nee4\\nei3\\neo2\\neu1\\n\\ntotal = 10\\n\\nii3\\nio2\\niu1\\n\\ntotal = 6\\n\\noo2\\nou1\\n\\ntotal = 3\\n\\nuu1\\ntotal=1\\n\\nso sum will be\\n\\n15+10+6+3+1 = 35\\n\\nSo for n=2\\nwe have\\n[5,4,3,2,1]\\n\\nn=3\\n[15,10,6,3,1]\\n\\nDo you see the pattern yet? C\\'mon think a bit..\\n\\nFor array of n=3, element at 0th index is derived from prefix sum of n=2 from 0th to 4th index.\\nsimilarly element at 1th index is derived from prefix sum of n=2 from 1 to 4th index and so on forth.\\n\\nThis is the intituion behind the solution in the code below. If you undestand the intution then try writing the solution on your own. Hope it helps.\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        \\n        if(n==1)\\n            return 5;\\n        \\n        if(n==2)\\n            return 15;\\n        \\n        int arr[] = {5,4,3,2,1};\\n\\n        int sum=0;\\n        \\n        for(int i=3;i<=n;i++) {\\n            sum=0;\\n\\t\\t\\t//this inner loop will always take constant iteration i.e. 5. So time complexity is O(1) for this\\n            for(int j=3;j>=0;j--) {\\n                arr[j]=arr[j]+arr[j+1];\\n                sum+=arr[j];\\n            }\\n        }\\n        \\n        return sum+1;\\n      \\n    }\\n}\\n```\\n\\nT(n) O(5*n) = O(n_\\nSpace O(1)\\n\\n**Approach 2 :**\\nIt is still in progress, but i think we can do some mathematical calculation. Once solution is build I will paste it here.\\n\\n\\nPlease upvote if it helps.~~~~!!!!~~~~~~",
                "solutionTags": [
                    "Backtracking",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        \\n        if(n==1)\\n            return 5;\\n        \\n        if(n==2)\\n            return 15;\\n        \\n        int arr[] = {5,4,3,2,1};\\n\\n        int sum=0;\\n        \\n        for(int i=3;i<=n;i++) {\\n            sum=0;\\n\\t\\t\\t//this inner loop will always take constant iteration i.e. 5. So time complexity is O(1) for this\\n            for(int j=3;j>=0;j--) {\\n                arr[j]=arr[j]+arr[j+1];\\n                sum+=arr[j];\\n            }\\n        }\\n        \\n        return sum+1;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028088,
                "title": "easy-c-using-dp-short-code-comments-added",
                "content": "**Using Dynamic Programming** \\n* The Pattern we can observe for this problem.\\n# \\t\\n          a  e  i  o  u \\n    n=1   1  1  1  1  1  /a, e, i, o, u\\n    n=2   5  4  3  2  1  /a-> aa,ae,ai,ao,au | e-> ee,ei,eo,eu | i-> ii,io,iu | o-> oo,ou | u-> uu\\n    n=3   15 10 6  3  1\\n* If we observe from last there will be only 1 element which will start with u. \\n* Every other element will have the count of previous count + next element count.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        // Here we\\u2019re taking a vector of 5 sizes and initialising with 1.\\n        vector<int> dp(5,1) ;\\n        int ans = 0 ;\\n        \\n        while( --n ){\\n            \\n            // Iterating from the 2nd last & add the next element to the present element.\\n            // Observe the Pattern for more clarification \\n            for( int i=3 ; i>=0 ; i-- ){\\n                dp[i] += dp[i+1];\\n            }\\n        }\\n        \\n        // Return the sum of every vector element.\\n        for( auto it : dp ) ans += it ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        \\n        // Here we\\u2019re taking a vector of 5 sizes and initialising with 1.\\n        vector<int> dp(5,1) ;\\n        int ans = 0 ;\\n        \\n        while( --n ){\\n            \\n            // Iterating from the 2nd last & add the next element to the present element.\\n            // Observe the Pattern for more clarification \\n            for( int i=3 ; i>=0 ; i-- ){\\n                dp[i] += dp[i+1];\\n            }\\n        }\\n        \\n        // Return the sum of every vector element.\\n        for( auto it : dp ) ans += it ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028085,
                "title": "java-dynamic-programming-tabulation-100-0ms-explained",
                "content": "```\\n/*\\nAlgorithm: \\n-----------------------------------------------------------------------\\n1. Have a dp table with 7 rows and `n` number of columns where\\n   0th row is for `null`, 1-5 are for each of the vowel from\\n   `a` to `e` and the 6th holds the total number, i.e the sum\\n   of row 1 to row 5.\\n2. The intuation is-\\n        for ith column the number of words being started with\\n        say jth vowel is the summation of all words of (i-1)th\\n        column except those who start with vowels which come\\n        lexicographically before to that of the jth vowel. \\n        Therefore, the dynamic relationship we have here is -\\n   dp[i][j] = dp[i-1][6]-sum(dp[i-1][j-1]+dp[i-1][j-2]+...dp[i-1][0])\\n   where dp[i-1][6] holds the total number of such words of the \\n   (i-1)th column.\\n3. Return dp[n][6].\\n   \\n\\nAs a sample example of the DP table where  input n is 5 is shown \\nbelow -\\n    /----------\\\\\\n    |vowels / n| ->  0   1   2   3   4   5\\n    \\\\----------/\\n    |\\n    V\\n    null             0   0   0   0   0   0   \\n    a                0   1   5   15  35  70\\n    e                0   1   4   10  20  35\\n    i                0   1   3   6   10  15\\n    o                0   1   2   3   4   5\\n    u                0   1   1   1   1   1\\n    total            0   5   15  35  70  126\\n    \\nHere our answer is dp[5][6] which is 126.\\n-----------------------------------------------------------------------\\n*/\\n\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n+1][7];\\n        Arrays.fill(dp[1], 1);\\n        dp[1][0] = dp[1][6] = 0;\\n        sum(dp[1]);\\n        for(int i=2; i<=n; i++){\\n            int temp = 0;\\n            for(int j=1; j<6; j++){\\n                temp += dp[i-1][j-1];\\n                dp[i][j] = dp[i-1][6]-temp;\\n            }\\n            sum(dp[i]);\\n        }\\n        return dp[n][6];\\n    }\\n    public void sum(int[] dp){\\n        for(int i=1; i<6; i++)\\n            dp[6] += dp[i];\\n    }\\n}\\n```\\n\\nUpvote if you like the soluton.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nAlgorithm: \\n-----------------------------------------------------------------------\\n1. Have a dp table with 7 rows and `n` number of columns where\\n   0th row is for `null`, 1-5 are for each of the vowel from\\n   `a` to `e` and the 6th holds the total number, i.e the sum\\n   of row 1 to row 5.\\n2. The intuation is-\\n        for ith column the number of words being started with\\n        say jth vowel is the summation of all words of (i-1)th\\n        column except those who start with vowels which come\\n        lexicographically before to that of the jth vowel. \\n        Therefore, the dynamic relationship we have here is -\\n   dp[i][j] = dp[i-1][6]-sum(dp[i-1][j-1]+dp[i-1][j-2]+...dp[i-1][0])\\n   where dp[i-1][6] holds the total number of such words of the \\n   (i-1)th column.\\n3. Return dp[n][6].\\n   \\n\\nAs a sample example of the DP table where  input n is 5 is shown \\nbelow -\\n    /----------\\\\\\n    |vowels / n| ->  0   1   2   3   4   5\\n    \\\\----------/\\n    |\\n    V\\n    null             0   0   0   0   0   0   \\n    a                0   1   5   15  35  70\\n    e                0   1   4   10  20  35\\n    i                0   1   3   6   10  15\\n    o                0   1   2   3   4   5\\n    u                0   1   1   1   1   1\\n    total            0   5   15  35  70  126\\n    \\nHere our answer is dp[5][6] which is 126.\\n-----------------------------------------------------------------------\\n*/\\n\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n+1][7];\\n        Arrays.fill(dp[1], 1);\\n        dp[1][0] = dp[1][6] = 0;\\n        sum(dp[1]);\\n        for(int i=2; i<=n; i++){\\n            int temp = 0;\\n            for(int j=1; j<6; j++){\\n                temp += dp[i-1][j-1];\\n                dp[i][j] = dp[i-1][6]-temp;\\n            }\\n            sum(dp[i]);\\n        }\\n        return dp[n][6];\\n    }\\n    public void sum(int[] dp){\\n        for(int i=1; i<6; i++)\\n            dp[6] += dp[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027785,
                "title": "java-0ms-soln-maths-easy-soln-with-explanation",
                "content": "Finding the start position of all possible combinations of five vowels, using nCr.\\nLetters will repeat in the string untill start position of next letter.\\nAlso, the start position of first letter is fixed 1, thats why finiding rest combinations in n-1 length string.\\n\\nThe nCm fn calculates possible combinations of start position of \\'m\\' vowels and the mutiplied num denotes the possible combination of \\'m\\' vowels in the rest vowels.\\n\\nans += 5 : cases when whole string contains only one vowel.\\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int ans = 0;\\n        \\n        ans += nCm(n - 1, 4);\\n        ans += (nCm(n - 1, 3) * 5);\\n        ans += (nCm(n - 1, 2) * 10);\\n        ans += (nCm(n - 1, 1) * 10);\\n        ans += 5;\\n        \\n        return ans;\\n    }\\n    \\n    public int nCm(int n, int m){\\n        if(m > n) return 0;\\n        \\n        long num = 1;\\n        long den = 1;\\n        \\n        while(m > 0){\\n            num *= n;\\n            den *= m;\\n            n--;\\n            m--;\\n        }\\n        \\n        return (int) (num / den);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int ans = 0;\\n        \\n        ans += nCm(n - 1, 4);\\n        ans += (nCm(n - 1, 3) * 5);\\n        ans += (nCm(n - 1, 2) * 10);\\n        ans += (nCm(n - 1, 1) * 10);\\n        ans += 5;\\n        \\n        return ans;\\n    }\\n    \\n    public int nCm(int n, int m){\\n        if(m > n) return 0;\\n        \\n        long num = 1;\\n        long den = 1;\\n        \\n        while(m > 0){\\n            num *= n;\\n            den *= m;\\n            n--;\\n            m--;\\n        }\\n        \\n        return (int) (num / den);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027708,
                "title": "c-dp-easy-100-faster",
                "content": "The intiution is that if you have the following character at i-th place then corresponding letters can only be at i+1th place in the string\\n\\na -> \\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'\\ne -> \\'e\\',\\'i\\',\\'o\\',\\'u\\'\\ni -> \\'i\\',\\'o\\',\\'u\\'\\no -> \\'o\\',\\'u\\'\\nu -> \\'u\\'\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int sum=0;\\n        vector<vector<int>>dp(n,vector<int>(5,0));\\n        for(int i=0;i<dp[0].size();i++)dp[0][i]=1;\\n        for(int i=1;i<dp.size();i++)dp[i][4]=1;\\n        \\n        for(int i=1;i<dp.size();i++)\\n        {\\n            for(int j=3;j>=0;j--)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j+1];\\n            }\\n        }\\n        for(int i=0;i<5;i++)\\n        {\\n            sum+=dp[dp.size()-1][i];\\n        }\\n        \\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int sum=0;\\n        vector<vector<int>>dp(n,vector<int>(5,0));\\n        for(int i=0;i<dp[0].size();i++)dp[0][i]=1;\\n        for(int i=1;i<dp.size();i++)dp[i][4]=1;\\n        \\n        for(int i=1;i<dp.size();i++)\\n        {\\n            for(int j=3;j>=0;j--)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j+1];\\n            }\\n        }\\n        for(int i=0;i<5;i++)\\n        {\\n            sum+=dp[dp.size()-1][i];\\n        }\\n        \\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027470,
                "title": "a-valid-solution-beats-90-o-1-no-dp",
                "content": "Beats 85% in time, and better than 90% in space.\\n\\nUses an advanced feature called \"case-switch\" to achive O(1) time & space in only 100 lines of code.\\n\\n```public class Solution {\\n    public int CountVowelStrings(int n) {\\n        switch(n) {\\n            case 1:\\n                return 5;\\n            case 2:\\n                return 15;\\n            case 3:\\n                return 35;\\n            case 4:\\n                return 70;\\n            case 5:\\n                return 126;\\n            case 6:\\n                return 210;\\n            case 7:\\n                return 330;\\n            case 8:\\n                return 495;\\n            case 9:\\n                return 715;\\n            case 10:\\n                return 1001;\\n            case 11:\\n                return 1365;\\n            case 12:\\n                return 1820;\\n            case 13:\\n                return 2380;\\n            case 14:\\n                return 3060;\\n            case 15:\\n                return 3876;\\n            case 16:\\n                return 4845;\\n            case 17:\\n                return 5985;\\n            case 18:\\n                return 7315;\\n            case 19:\\n                return 8855;\\n            case 20:\\n                return 10626;\\n            case 21:\\n                return 12650;\\n            case 22:\\n                return 14950;\\n            case 23:\\n                return 17550;\\n            case 24:\\n                return 20475;\\n            case 25:\\n                return 23751;\\n            case 26:\\n                return 27405;\\n            case 27:\\n                return 31465;\\n            case 28:\\n                return 35960;\\n            case 29:\\n                return 40920;\\n            case 30:\\n                return 46376;\\n            case 31:\\n                return 52360;\\n            case 32:\\n                return 58905;\\n            case 33:\\n                return 66045;\\n            case 34:\\n                return 73815;\\n            case 35:\\n                return 82251;\\n            case 36:\\n                return 91390;\\n            case 37:\\n                return 101270;\\n            case 38:\\n                return 111930;\\n            case 39:\\n                return 123410;\\n            case 40:\\n                return 135751;\\n            case 41:\\n                return 148995;\\n            case 42:\\n                return 163185;\\n            case 43:\\n                return 178365;\\n            case 44:\\n                return 194580;\\n            case 45:\\n                return 211876;\\n            case 46:\\n                return 230300;\\n            case 47:\\n                return 249900;\\n            case 48:\\n                return 270725;\\n            case 49:\\n                return 292825;\\n            case 50:\\n                return 316251;\\n        }\\n        return 0;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```public class Solution {\\n    public int CountVowelStrings(int n) {\\n        switch(n) {\\n            case 1:\\n                return 5;\\n            case 2:\\n                return 15;\\n            case 3:\\n                return 35;\\n            case 4:\\n                return 70;\\n            case 5:\\n                return 126;\\n            case 6:\\n                return 210;\\n            case 7:\\n                return 330;\\n            case 8:\\n                return 495;\\n            case 9:\\n                return 715;\\n            case 10:\\n                return 1001;\\n            case 11:\\n                return 1365;\\n            case 12:\\n                return 1820;\\n            case 13:\\n                return 2380;\\n            case 14:\\n                return 3060;\\n            case 15:\\n                return 3876;\\n            case 16:\\n                return 4845;\\n            case 17:\\n                return 5985;\\n            case 18:\\n                return 7315;\\n            case 19:\\n                return 8855;\\n            case 20:\\n                return 10626;\\n            case 21:\\n                return 12650;\\n            case 22:\\n                return 14950;\\n            case 23:\\n                return 17550;\\n            case 24:\\n                return 20475;\\n            case 25:\\n                return 23751;\\n            case 26:\\n                return 27405;\\n            case 27:\\n                return 31465;\\n            case 28:\\n                return 35960;\\n            case 29:\\n                return 40920;\\n            case 30:\\n                return 46376;\\n            case 31:\\n                return 52360;\\n            case 32:\\n                return 58905;\\n            case 33:\\n                return 66045;\\n            case 34:\\n                return 73815;\\n            case 35:\\n                return 82251;\\n            case 36:\\n                return 91390;\\n            case 37:\\n                return 101270;\\n            case 38:\\n                return 111930;\\n            case 39:\\n                return 123410;\\n            case 40:\\n                return 135751;\\n            case 41:\\n                return 148995;\\n            case 42:\\n                return 163185;\\n            case 43:\\n                return 178365;\\n            case 44:\\n                return 194580;\\n            case 45:\\n                return 211876;\\n            case 46:\\n                return 230300;\\n            case 47:\\n                return 249900;\\n            case 48:\\n                return 270725;\\n            case 49:\\n                return 292825;\\n            case 50:\\n                return 316251;\\n        }\\n        return 0;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2027418,
                "title": "both-iterative-and-recursive-dp-approach-in-c",
                "content": "**Idea:** There will be two dp states n and m.\\n* n : represents how many letters left to fullfill the word from this state.\\n* m : represents the number of vowel left from this state.\\n* base case : for all i = 1 - n, dp[i][0] will be 1.\\n* base case : for all i = 1 - 5, dp[0][i] will be 0.\\n\\nComplexity: O(n * n * 5)\\n\\nRecursive code:\\n```\\nclass Solution {\\npublic:\\n    int dp[55][6];\\n    int countVowelStrings(int n) {\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=5;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return call(n, 5);\\n    }\\n    \\n    int call(int n, int m){\\n        if(n==0) return 1;\\n        if(m==0) return 0;\\n        \\n        if(dp[n][m] != -1){\\n            return dp[n][m];\\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<=n;i++){\\n            res += call(n - i, m - 1);\\n        }\\n        \\n        return dp[n][m] = res;\\n    }\\n};\\n```\\n\\nIterative code;\\n```\\nclass Solution {\\npublic:\\n    int dp[55][6];\\n    int countVowelStrings(int n) {        \\n        for(int i=0;i<=5;i++){\\n            dp[0][i] = 1;\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            dp[i][0] = 0;\\n        }\\n        \\n            \\n        for(int m=1;m<=5;m++){\\n            for(int i=1;i<=n;i++){\\n                int res = 0;\\n                for(int j=0;j<=i;j++){\\n                    res += dp[i - j][m-1];\\n                }\\n                dp[i][m] = res;\\n            }\\n        } \\n        \\n        return dp[n][5];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[55][6];\\n    int countVowelStrings(int n) {\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=5;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return call(n, 5);\\n    }\\n    \\n    int call(int n, int m){\\n        if(n==0) return 1;\\n        if(m==0) return 0;\\n        \\n        if(dp[n][m] != -1){\\n            return dp[n][m];\\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<=n;i++){\\n            res += call(n - i, m - 1);\\n        }\\n        \\n        return dp[n][m] = res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[55][6];\\n    int countVowelStrings(int n) {        \\n        for(int i=0;i<=5;i++){\\n            dp[0][i] = 1;\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            dp[i][0] = 0;\\n        }\\n        \\n            \\n        for(int m=1;m<=5;m++){\\n            for(int i=1;i<=n;i++){\\n                int res = 0;\\n                for(int j=0;j<=i;j++){\\n                    res += dp[i - j][m-1];\\n                }\\n                dp[i][m] = res;\\n            }\\n        } \\n        \\n        return dp[n][5];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875057,
                "title": "c-easiest-solution",
                "content": "Not the best solution but it\\'s very easy to understand, just basic arithmetic. Please give me an upvote if you find this helpful! Also comment down below if you need help understanding this.\\n\\n```\\nint countVowelStrings(int n) {\\n        return helper(n, 0);   \\n    }\\n    \\n    int helper(int n, int index){\\n        if(n == 0)\\n            return 1;\\n        \\n        int ans = 0;\\n        \\n        for(int i = index; i < 5; ++i)\\n            ans += helper(n - 1, i);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countVowelStrings(int n) {\\n        return helper(n, 0);   \\n    }\\n    \\n    int helper(int n, int index){\\n        if(n == 0)\\n            return 1;\\n        \\n        int ans = 0;\\n        \\n        for(int i = index; i < 5; ++i)\\n            ans += helper(n - 1, i);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672474,
                "title": "javascript-o-n-dynamic-programming-detail-explanation",
                "content": "```\\n/** https://leetcode.com/problems/count-sorted-vowel-strings/\\n * @param {number} n\\n * @return {number}\\n */\\nvar countVowelStrings = function(n) {\\n  // Since the string has to be ordered, it means for every addition of a character, each vowel can add all combinations from itself to the last vowel\\n  // In the example below, when `n` is 2, vowel `a` can add all combinations (from `n = 1` result) from `a` to `u`, vowel `e` can add all combinations from `e` to `u`, and so on\\n  // When `n` is 3, again vowel `a` can add all combinations (from `n = 2` result) from `a` to `u`, and so on\\n  \\n  // When n is 1, result is [a, e, i, o, u]\\n  // When n is 2, result is\\n  //  [aa, ae, ai, ao, au,\\n  //    ee, ei, eo, eu,\\n  //    ii, io, iu\\n  //    oo, ou,\\n  //    uu]\\n  // When n is 3, result is\\n  //  [aaa, aae, aai, aao, aau, aee, aei, aeo, aeu, aii, aio, aiu, aoo, aou, auu\\n  //    eee, eei, eeo, eeu, eii, eio, eiu, eoo, eou, euu\\n  //    iii, iio, iiu, ioo, iou,\\n  //    ooo, oou, ouu\\n  //    uuu]\\n  \\n  // But instead of list all the possible vowel combinations, we can simplified this with calculation\\n  // In the example below, when `n` is 1, each vowel can only combined itself so total possible combination is 5\\n  // When `n` is 2\\n  //    vowel `a` can combined itself with starting from vowel `a` in `n = 1` result (1 + 1 + 1 + 1 + 1 = 5)\\n  //    vowel `e` can combined itself with any combinations starting from vowel `e` in `n = 1` result (1 + 1 + 1 + 1 = 4)\\n  // When `n` is 3\\n  //    vowel `a` can combined itself with starting from vowel `a` in `n = 2` result (5 + 4 + 3 + 2 + 1 = 15)\\n  //    vowel `e` can combined itself with any combinations starting from vowel `e` in `n = 2` result (4 + 3 + 2 + 1 = 10)\\n  // And so on\\n  \\n  // n    a   e   i   o   u\\n  // 1    1   1   1   1   1 = 5\\n  // 2    5   4   3   2   1 = 15\\n  // 3    15  10  6   3   1 = 35\\n  // 4    35  20  10  4   1 = 70\\n  // 5    70  35  15  5   1 = 126\\n  // 6    126 56  21  6   1 = 210\\n  \\n  // So this problem can be solved with matrix or array, by looping through `n` and count possible combination for each vowel by adding all previous possible combinations from `v` (for vowel) to 5 (for 5 vowels)\\n  \\n  let count = Array(5).fill(1);\\n  \\n  for (let i = 1; i < n; i++) {\\n    for (let v = 0; v < count.length; v++) {\\n      count[v] = count.slice(v).reduce((sum, vow) => sum + vow, 0);\\n    }\\n  }\\n  \\n  return count.reduce((sum, vow) => sum + vow, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/** https://leetcode.com/problems/count-sorted-vowel-strings/\\n * @param {number} n\\n * @return {number}\\n */\\nvar countVowelStrings = function(n) {\\n  // Since the string has to be ordered, it means for every addition of a character, each vowel can add all combinations from itself to the last vowel\\n  // In the example below, when `n` is 2, vowel `a` can add all combinations (from `n = 1` result) from `a` to `u`, vowel `e` can add all combinations from `e` to `u`, and so on\\n  // When `n` is 3, again vowel `a` can add all combinations (from `n = 2` result) from `a` to `u`, and so on\\n  \\n  // When n is 1, result is [a, e, i, o, u]\\n  // When n is 2, result is\\n  //  [aa, ae, ai, ao, au,\\n  //    ee, ei, eo, eu,\\n  //    ii, io, iu\\n  //    oo, ou,\\n  //    uu]\\n  // When n is 3, result is\\n  //  [aaa, aae, aai, aao, aau, aee, aei, aeo, aeu, aii, aio, aiu, aoo, aou, auu\\n  //    eee, eei, eeo, eeu, eii, eio, eiu, eoo, eou, euu\\n  //    iii, iio, iiu, ioo, iou,\\n  //    ooo, oou, ouu\\n  //    uuu]\\n  \\n  // But instead of list all the possible vowel combinations, we can simplified this with calculation\\n  // In the example below, when `n` is 1, each vowel can only combined itself so total possible combination is 5\\n  // When `n` is 2\\n  //    vowel `a` can combined itself with starting from vowel `a` in `n = 1` result (1 + 1 + 1 + 1 + 1 = 5)\\n  //    vowel `e` can combined itself with any combinations starting from vowel `e` in `n = 1` result (1 + 1 + 1 + 1 = 4)\\n  // When `n` is 3\\n  //    vowel `a` can combined itself with starting from vowel `a` in `n = 2` result (5 + 4 + 3 + 2 + 1 = 15)\\n  //    vowel `e` can combined itself with any combinations starting from vowel `e` in `n = 2` result (4 + 3 + 2 + 1 = 10)\\n  // And so on\\n  \\n  // n    a   e   i   o   u\\n  // 1    1   1   1   1   1 = 5\\n  // 2    5   4   3   2   1 = 15\\n  // 3    15  10  6   3   1 = 35\\n  // 4    35  20  10  4   1 = 70\\n  // 5    70  35  15  5   1 = 126\\n  // 6    126 56  21  6   1 = 210\\n  \\n  // So this problem can be solved with matrix or array, by looping through `n` and count possible combination for each vowel by adding all previous possible combinations from `v` (for vowel) to 5 (for 5 vowels)\\n  \\n  let count = Array(5).fill(1);\\n  \\n  for (let i = 1; i < n; i++) {\\n    for (let v = 0; v < count.length; v++) {\\n      count[v] = count.slice(v).reduce((sum, vow) => sum + vow, 0);\\n    }\\n  }\\n  \\n  return count.reduce((sum, vow) => sum + vow, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661968,
                "title": "c-0ms-faster-than-100-with-comments-easy",
                "content": "```\\nint dp[N+1][150]={0};\\n\\n// now the base states\\ndp[1][\\'a\\']=1;\\ndp[1][\\'e\\']=1;\\ndp[1][\\'i\\']=1;\\ndp[1][\\'o\\']=1;\\ndp[1][\\'u\\']=1;\\n\\nfor(int n=2;n<=N;n++){\\n\\t dp[n][\\'a\\']=dp[n-1][\\'a\\'];\\n\\t dp[n][\\'e\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\'];\\n\\t dp[n][\\'i\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\']+dp[n-1][\\'i\\'];\\n\\t dp[n][\\'o\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\']+dp[n-1][\\'i\\']+dp[n-1][\\'o\\'];\\n\\t dp[n][\\'u\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\']+dp[n-1][\\'i\\']+dp[n-1][\\'o\\']+dp[n-1][\\'u\\'];\\n}\\nreturn dp[N][\\'a\\']+dp[N][\\'e\\']+dp[N][\\'i\\']+dp[N][\\'o\\']+dp[N][\\'u\\'];\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint dp[N+1][150]={0};\\n\\n// now the base states\\ndp[1][\\'a\\']=1;\\ndp[1][\\'e\\']=1;\\ndp[1][\\'i\\']=1;\\ndp[1][\\'o\\']=1;\\ndp[1][\\'u\\']=1;\\n\\nfor(int n=2;n<=N;n++){\\n\\t dp[n][\\'a\\']=dp[n-1][\\'a\\'];\\n\\t dp[n][\\'e\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\'];\\n\\t dp[n][\\'i\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\']+dp[n-1][\\'i\\'];\\n\\t dp[n][\\'o\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\']+dp[n-1][\\'i\\']+dp[n-1][\\'o\\'];\\n\\t dp[n][\\'u\\']=dp[n-1][\\'a\\']+dp[n-1][\\'e\\']+dp[n-1][\\'i\\']+dp[n-1][\\'o\\']+dp[n-1][\\'u\\'];\\n}\\nreturn dp[N][\\'a\\']+dp[N][\\'e\\']+dp[N][\\'i\\']+dp[N][\\'o\\']+dp[N][\\'u\\'];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621818,
                "title": "java-o-n-solution",
                "content": "```\\npublic int countVowelStrings(int n) {\\n\\tint a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n\\twhile (--n > 0) {\\n\\t\\ta += e + i + o + u;\\n\\t\\te += i + o + u;\\n\\t\\ti += o + u;\\n\\t\\to += u;\\n\\t}\\n\\n\\treturn a + e + i + o + u;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countVowelStrings(int n) {\\n\\tint a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n\\twhile (--n > 0) {\\n\\t\\ta += e + i + o + u;\\n\\t\\te += i + o + u;\\n\\t\\ti += o + u;\\n\\t\\to += u;\\n\\t}\\n\\n\\treturn a + e + i + o + u;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585185,
                "title": "c-o-n-dp-solution",
                "content": "Here CountA represents words starting with vowel A.\\nCountE represents words starting with vowel E and so on.\\nFor length n, we are storing all these counts for no. of strings starting with particular vowel.\\nTo calculate for n+1 length, we can simply use these formulaes,\\n`countA=countA+countE+countI+countO+countU` bcz vowel A can be added in all cases for length n.\\n`countE=countE+countI+countO+countU` bcz vowel E can only be added for all length n strings with starting vowel E, I, O, U\\nand so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int countA=1, countE=1, countI=1, countO=1, countU=1;\\n        n--;\\n        while(n--)\\n        {\\n            countA+=countE+countI+countO+countU;\\n            countE+=countI+countO+countU;\\n            countI+=countO+countU;\\n            countO+=countU;\\n        }\\n        return countA+countE+countI+countO+countU;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        int countA=1, countE=1, countI=1, countO=1, countU=1;\\n        n--;\\n        while(n--)\\n        {\\n            countA+=countE+countI+countO+countU;\\n            countE+=countI+countO+countU;\\n            countI+=countO+countU;\\n            countO+=countU;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1519071,
                "title": "c-easy-to-understand-time-o-n-space-o-1",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for (int N = 2; N <= n; N++)\\n        {\\n            u = a + e + i + o + u;\\n            o = a + e + i + o;\\n            i = a + e + i;\\n            e = a + e;\\n            a = a;\\n        }\\n        return a + e + i + o + u;\\n    }\\n};`\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int countVowelStrings(int n)\\n    {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for (int N = 2; N <= n; N++)\\n        {\\n            u = a + e + i + o + u;\\n            o = a + e + i + o;\\n            i = a + e + i;\\n            e = a + e;\\n            a = a;\\n        }\\n        return a + e + i + o + u;\\n    }\\n};`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457677,
                "title": "c-dp-simple-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> T(n+1,vector<int> (6,0));\\n        for(int i=1;i<=5;i++)\\n            T[0][i]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=5;j++)\\n            {   \\n                T[i][j]=T[i][j-1]+T[i-1][j];\\n            }\\n        }return T[n][5];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> T(n+1,vector<int> (6,0));\\n        for(int i=1;i<=5;i++)\\n            T[0][i]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=5;j++)\\n            {   \\n                T[i][j]=T[i][j-1]+T[i-1][j];\\n            }\\n        }return T[n][5];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294416,
                "title": "simple-recursion-approach-c",
                "content": "class Solution {\\npublic:\\n    \\n    int vowels(int index,int n)\\n    {\\n        if(n==0)     //If chars required to be inserted becomes zero.\\n            return 1;\\n        int count=0;\\n        for(int i=index;i<5;i++)\\n        {\\n            count+=vowels(i,n-1);\\n        }\\n        return count;\\n    }\\n    int countVowelStrings(int n) {\\n        \\n        int count=0;\\n\\t\\tfor(int i=0;i<5;i++)   //As number of vowels are 5 , adding each vowel one by one to the start.\\n        {\\n            count+=vowels(i,n-1);\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int vowels(int index,int n)\\n    {\\n        if(n==0)     //If chars required to be inserted becomes zero.\\n            return 1;\\n        int count=0;\\n        for(int i=index;i<5;i++)\\n        {\\n            count+=vowels(i,n-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1245101,
                "title": "easy-java-100-dp",
                "content": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n+1][6];\\n        for(int i=1; i<= n ; i++){\\n            for(int j=1; j<=5; j++){\\n                dp[i][j] = (i>1 ? dp[i-1][j]:1) + dp[i][j-1];\\n            }\\n        }\\n        return dp[n][5];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n+1][6];\\n        for(int i=1; i<= n ; i++){\\n            for(int j=1; j<=5; j++){\\n                dp[i][j] = (i>1 ? dp[i-1][j]:1) + dp[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1241290,
                "title": "java-100-faster-dynamic-programming-using-1d-array-explained",
                "content": "Example: Lets, n=3 and see how this solution iterates 3 to 0 and uses DP in 1D array.\\nAdd, memo[i]+memo[i-1] element and keep updating the memory array in each pass of N.\\n\\n**When n=3**\\ni=1,  memo[1] = memo[1] +memo[0] = 1+1 = 2\\ni=2,  memo[2] = memo[2] +memo[1] = 1+2 = 3\\ni=3,  memo[3] = memo[3] +memo[2] = 1+3 = 4\\ni=4,  memo[4] = memo[4] +memo[3] = 1+4 = 5\\nNew Memory Array : [1,2,3,4,5]\\n\\n**When n=2**\\ni=1,  memo[1] = memo[1] +memo[0] = 2+1 = 3\\ni=2,  memo[2] = memo[2] +memo[1] = 3+3 = 6\\ni=3,  memo[3] = memo[3] +memo[2] = 4+6 = 10\\ni=4,  memo[4] = memo[4] +memo[3] = 5+10 = 15\\nNew Memory Array : [1,3,6,10,15]\\n\\n**When n=1**\\ni=1,  memo[1] = memo[1] +memo[0] = 3+1 = 4\\ni=2,  memo[2] = memo[2] +memo[1] = 6+4 = 10\\ni=3,  memo[3] = memo[3] +memo[2] = 10+10 = 20\\ni=4,  memo[4] = memo[4] +memo[3] = 15+20 = **35**\\nNew Memory Array : [1,4,10,20,35]\\n\\nWhen n=0,\\nreturn memo[4], i.e., 35\\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[] memo = new int[]{1,1,1,1,1};\\n        while(n>0){\\n            for(int i=1;i<5;i++){\\n               memo[i] += memo[i-1];  \\n            }\\n            n--;\\n        }\\n        return memo[4];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[] memo = new int[]{1,1,1,1,1};\\n        while(n>0){\\n            for(int i=1;i<5;i++){\\n               memo[i] += memo[i-1];  \\n            }\\n            n--;\\n        }\\n        return memo[4];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238441,
                "title": "dp-solution-c-fater-than-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    char arr[6] = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    int dp[51][6];\\n    int countVowelStringsHelp(int n, int arrSize = 5) {\\n\\t\\tif(n == 1){\\t\\n\\t\\t\\treturn arrSize;\\n\\t\\t}\\n        \\n        if(dp[n][arrSize] != -1){\\n            return dp[n][arrSize];\\n        }\\n        int ans = 0;\\n        for(int i=0;i<arrSize;i++){\\n            ans += countVowelStringsHelp(n-1,arrSize-i);\\n        }\\n        dp[n][arrSize] = ans;\\n        \\n        return ans;\\n    }\\n    \\n    int countVowelStrings(int n){\\n        memset(dp,-1,sizeof(dp));\\n        return countVowelStringsHelp(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char arr[6] = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    int dp[51][6];\\n    int countVowelStringsHelp(int n, int arrSize = 5) {\\n\\t\\tif(n == 1){\\t\\n\\t\\t\\treturn arrSize;\\n\\t\\t}\\n        \\n        if(dp[n][arrSize] != -1){\\n            return dp[n][arrSize];\\n        }\\n        int ans = 0;\\n        for(int i=0;i<arrSize;i++){\\n            ans += countVowelStringsHelp(n-1,arrSize-i);\\n        }\\n        dp[n][arrSize] = ans;\\n        \\n        return ans;\\n    }\\n    \\n    int countVowelStrings(int n){\\n        memset(dp,-1,sizeof(dp));\\n        return countVowelStringsHelp(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207519,
                "title": "java-3-methods-time-beats-100",
                "content": "**Method 1:** Brute force\\n**T/S:** O(n^4)/O(n) (not certain about time, best guess)\\n```\\npublic int countVowelStrings(int n) {\\n\\treturn countVowelStrings(n, 0);\\n}\\n\\nprivate int countVowelStrings(int n, int v) {\\n\\tif (n == 0)\\n\\t\\treturn 1;\\n\\tvar count = 0;\\n\\tfor (var i = v; i < 5; i++)\\n\\t\\tcount += countVowelStrings(n - 1, i);\\n\\treturn count;\\n}\\n```\\n\\n**Method 2:** Inject Memoization in method 1\\n**T/S:** O(n)/O(n)\\n```\\npublic int countVowelStrings(int n) {\\n\\treturn countVowelStrings(n, 0, new char[]{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}, new HashMap<>());\\n}\\n\\nprivate int countVowelStrings(int n, int v, char[] chars, Map<String, Integer> map) {\\n\\tif (n == 0)\\n\\t\\treturn 1;\\n\\tvar key = chars[v] + \",\" + n;\\n\\tif (map.containsKey(key))\\n\\t\\treturn map.get(key);\\n\\tvar count = 0;\\n\\tfor (var i = v; i < 5; i++)\\n\\t\\tcount += countVowelStrings(n - 1, i, chars, map);\\n\\tmap.put(key, count);\\n\\treturn count;\\n}\\n```\\n\\n**Method 3:** Tabulation. Time beats 100%\\n**T/S:** O(n)/O(n)\\n```\\npublic int countVowelStrings(int n) {\\n\\tvar count = new int[n + 1][5];\\n\\tfor (var i = 0; i < n + 1; i++)\\n\\t\\tcount[i][0] = 1;\\n\\tArrays.fill(count[0], 1);\\n\\tfor (var i = 1; i < n + 1; i++)\\n\\t\\tfor (var j = 1; j < 5; j++)\\n\\t\\t\\tcount[i][j] = count[i - 1][j] + count[i][j - 1];\\n\\treturn count[n][4];\\n}\\n```\\n\\n```\\nHow count matrix builds up the solution for countVowelStrings(3) for Method 3\\n\\n[1, 1, 1, 1, 1]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 0, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 10, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 10, 20, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 10, 20, 35]\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic int countVowelStrings(int n) {\\n\\treturn countVowelStrings(n, 0);\\n}\\n\\nprivate int countVowelStrings(int n, int v) {\\n\\tif (n == 0)\\n\\t\\treturn 1;\\n\\tvar count = 0;\\n\\tfor (var i = v; i < 5; i++)\\n\\t\\tcount += countVowelStrings(n - 1, i);\\n\\treturn count;\\n}\\n```\n```\\npublic int countVowelStrings(int n) {\\n\\treturn countVowelStrings(n, 0, new char[]{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}, new HashMap<>());\\n}\\n\\nprivate int countVowelStrings(int n, int v, char[] chars, Map<String, Integer> map) {\\n\\tif (n == 0)\\n\\t\\treturn 1;\\n\\tvar key = chars[v] + \",\" + n;\\n\\tif (map.containsKey(key))\\n\\t\\treturn map.get(key);\\n\\tvar count = 0;\\n\\tfor (var i = v; i < 5; i++)\\n\\t\\tcount += countVowelStrings(n - 1, i, chars, map);\\n\\tmap.put(key, count);\\n\\treturn count;\\n}\\n```\n```\\npublic int countVowelStrings(int n) {\\n\\tvar count = new int[n + 1][5];\\n\\tfor (var i = 0; i < n + 1; i++)\\n\\t\\tcount[i][0] = 1;\\n\\tArrays.fill(count[0], 1);\\n\\tfor (var i = 1; i < n + 1; i++)\\n\\t\\tfor (var j = 1; j < 5; j++)\\n\\t\\t\\tcount[i][j] = count[i - 1][j] + count[i][j - 1];\\n\\treturn count[n][4];\\n}\\n```\n```\\nHow count matrix builds up the solution for countVowelStrings(3) for Method 3\\n\\n[1, 1, 1, 1, 1]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 0, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 0]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 0, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 0, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 0]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 0, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 0, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 10, 0, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 10, 20, 0]\\n\\n[1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5]\\n[1, 3, 6, 10, 15]\\n[1, 4, 10, 20, 35]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170234,
                "title": "superrrrrrr-smooth-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp(int n,int i){\\n        if(i==0||n==1)\\n            return i+1;\\n            \\n        int here = 0;\\n        for(int j=0;j<=i;j++){\\n            here += dp(n-1,j);\\n        }\\n        return here;\\n    }\\n    int countVowelStrings(int n) {\\n        return dp(n,4);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(int n,int i){\\n        if(i==0||n==1)\\n            return i+1;\\n            \\n        int here = 0;\\n        for(int j=0;j<=i;j++){\\n            here += dp(n-1,j);\\n        }\\n        return here;\\n    }\\n    int countVowelStrings(int n) {\\n        return dp(n,4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150420,
                "title": "beats-100-solution",
                "content": "In order to make a string of length n from the given set of vowels a , e , i , o , u consider them in an array so they are already sorted in order to make a given length of string we have two options for every index of array(vowels) we can either consider that particular index and decrease our length by 1 or we can simply skip it with our length as same  and we have to do this for every index \\nhere is a recurssive tree for this problem \\n\\nn = 2;\\n\\n                                                             ( 0 , 2)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t(0 , 1 )   | (1 , 2)   ( 2 ,2 )   ( 3, 2 )    ( 4 , 2 )\\n\\nHope so this will give u an intuition \\n\\nhere is the implementation with dp as it will definately have overlapping subproblems\\n\\nclass Solution {\\npublic:\\n    \\n    int solve( int index ,int n , vector<vector<int>>&dp , int  size){\\n        \\n        if ( n == 0 ){\\n\\t\\t  // we created a string of given length// \\n            return 1;\\n        }\\n        if ( index == size ){ \\n\\t\\t  // is my index becomes 5 i am out of my range of array //\\n            return 0;\\n        }\\n        if (dp[index][n] != -1){\\n            return dp[index][n];\\n        }\\n        \\n        int pick = 0 , nonpick = 0;\\n        \\n        for (int i = index ; i<size ; i++){\\n            \\n            pick = solve(index , n-1 , dp , size); \\n\\t\\t\\t// if we pick that element simply decrease length as we can again choose that element later on eg : \"aa\" //  \\n \\n           nonpick = solve(index+1 , n , dp , size); \\n           // or simply move to the next element //  \\n        }\\n            return dp[index][n] = pick+nonpick;\\n    }\\n\\n    int countVowelStrings(int n) {\\n        \\n        vector<vector<int>>dp(5,vector<int>(n+1,-1));\\n        \\n       int ans = solve( 0 , n  , dp , 5 );\\n        return ans ;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int solve( int index ,int n , vector<vector<int>>&dp , int  size){\\n        \\n        if ( n == 0 ){\\n\\t\\t  // we created a string of given length// \\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1146804,
                "title": "recursion-and-memoization-in-python",
                "content": "for 1 ; a,e,i,o,u                 value = 5\\nfor 2: \\naa, ae, ai, ao, au\\n\\t\\t\\t   ee, ei, eo, eu\\n\\t\\t\\t\\t\\t ii,  io,  iu\\n\\t\\t\\t\\t\\t\\t oo, ou\\n\\t\\t\\t\\t\\t\\t\\t   uu      \\n\\t\\t\\t\\t\\t\\t\\t   value = 15\\nfor 3: we can add a to all the strings in previous case so 15 will already be there.value will be  (n = 2, w = 5) = 15\\nlets look at the remaining cases.\\n\\tnow we need to find values with 4 vowels {e,i,o,u} and need to have 3 lettered strings. i.e (n = 3, vow = 4)\\n```\\nwe can say f(n = 3, vow = 5) = f(n = 2, vow = 5) # for a case\\n\\t\\t\\t\\t\\t+ f(n = 3, vow = 4) #after removal of a left with vow = 4\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\n\\tso we are getting a recursion: \\n\\t recur(n,w) = recur(n-1, w) //here in the previous case, (2,5)\\n\\t\\t\\t\\t\\t\\t + recur(n,w-1) // after using a we are left with {e,i,o,u} so w-1 for that\\n```\\ndef countVowelStrings(self, n: int) -> int:\\n        def count(n,vow):\\n            if vow == 0: return 0\\n            if n == 0: return 1\\n            return count(n,vow-1)+count(n-1,vow)\\n        return count(n,5)\\n```\\nFor memoization: \\njust use a table of size (n+1) * (w+1) and fill it with -1. \\nassign values to table and use it whenever its not -1( which means already assigned)\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        def count(n,vow):\\n            if vow == 0: \\n                mem[n][vow] =  0\\n                return mem[n][vow]\\n            if n == 0: \\n                mem[n][vow] = 1\\n                return mem[n][vow]\\n            if mem[n][vow]!=-1:\\n                return mem[n][vow]\\n            mem[n][vow] = count(n,vow-1)+count(n-1,vow)\\n            return mem[n][vow]\\n        mem = [[-1]*6 for i in range(n+1)]\\n        return count(n,5)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nwe can say f(n = 3, vow = 5) = f(n = 2, vow = 5) # for a case\\n\\t\\t\\t\\t\\t+ f(n = 3, vow = 4) #after removal of a left with vow = 4\\n```\n```\\ndef countVowelStrings(self, n: int) -> int:\\n        def count(n,vow):\\n            if vow == 0: return 0\\n            if n == 0: return 1\\n            return count(n,vow-1)+count(n-1,vow)\\n        return count(n,5)\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        def count(n,vow):\\n            if vow == 0: \\n                mem[n][vow] =  0\\n                return mem[n][vow]\\n            if n == 0: \\n                mem[n][vow] = 1\\n                return mem[n][vow]\\n            if mem[n][vow]!=-1:\\n                return mem[n][vow]\\n            mem[n][vow] = count(n,vow-1)+count(n-1,vow)\\n            return mem[n][vow]\\n        mem = [[-1]*6 for i in range(n+1)]\\n        return count(n,5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022654,
                "title": "c-one-pass-simple-easy-to-understand-solution",
                "content": "Time Complexity - O(n) \\nSpace Complexity - O(1) as using constant space only.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> count(5,0);\\n        for(int i=4;i>=0;i--){\\n            count[i]=(5-i);\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=3;j>=0;j--){\\n                 count[j]+=count[j+1];\\n            }\\n        }\\n        return count[0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> count(5,0);\\n        for(int i=4;i>=0;i--){\\n            count[i]=(5-i);\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=3;j>=0;j--){\\n                 count[j]+=count[j+1];\\n            }\\n        }\\n        return count[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022075,
                "title": "python-multiple-methods-dp-backtrace-recursive-recursive-with-memorization",
                "content": "- Method 1: DP  with time complexity: (O(n))\\n```\\n    def countVowelStrings(self, n: int) -> int:\\n        # dp[i][j]: the count with j number of vowels and string length i.\\n        dp = [[0 for vowel in range(6)] for i in range(n+1)]\\n        \\n        # for str length 1\\n        for v in range(1, 6):\\n            dp[1][v] = v\\n        \\n        # for string length 2..n\\n        for i in range(2, n+1):\\n            dp[i][1] = 1\\n            for v in range(2, 6):\\n                dp[i][v] = dp[i][v-1] + dp[i-1][v]\\n        \\n        return dp[n][5]\\n```\\n- Method 2: Backtrace with DFS. Time Complex: O(n^5)\\n```\\n    def countVowelStrings(self, n: int) -> int:\\n        def dfs(idx, n):\\n            if n == 0:\\n                return 1\\n            ret = 0\\n            for i in range(idx, 5):\\n                ret += dfs(i, n - 1)\\n            return ret\\n\\n        return dfs(0, n)\\n```\\n\\n- Method 3: Recursive with time complexity O(n^5)\\n```\\n    def countVowelStrings_recursive(self, n: int) -> int:\\n        def count(n, vowels):\\n            if n == 1:\\n                return vowels\\n\\n            if vowels == 1:\\n                return 1\\n\\n            return count(n, vowels - 1) + count(n - 1, vowels)\\n\\n        return count(n, 5)\\n```\\t\\t\\n- Method 4: Recursive with memorization (Improve based on Method 3). Time complex: O(n)\\n```\\n    def countVowelStrings_recursive_with_mem(self, n: int) -> int:\\n        mem = defaultdict(int)\\n\\n        def count(n, vowels):\\n            if n == 1:\\n                return vowels\\n\\n            if vowels == 1:\\n                return 1\\n\\n            if (n, vowels) in mem:\\n                return mem[(n, vowels)]\\n\\n            mem[(n, vowels)] = count(n, vowels - 1) + count(n - 1, vowels)\\n            return mem[(n, vowels)]\\n\\n        return count(n, 5)",
                "solutionTags": [],
                "code": "```\\n    def countVowelStrings(self, n: int) -> int:\\n        # dp[i][j]: the count with j number of vowels and string length i.\\n        dp = [[0 for vowel in range(6)] for i in range(n+1)]\\n        \\n        # for str length 1\\n        for v in range(1, 6):\\n            dp[1][v] = v\\n        \\n        # for string length 2..n\\n        for i in range(2, n+1):\\n            dp[i][1] = 1\\n            for v in range(2, 6):\\n                dp[i][v] = dp[i][v-1] + dp[i-1][v]\\n        \\n        return dp[n][5]\\n```\n```\\n    def countVowelStrings(self, n: int) -> int:\\n        def dfs(idx, n):\\n            if n == 0:\\n                return 1\\n            ret = 0\\n            for i in range(idx, 5):\\n                ret += dfs(i, n - 1)\\n            return ret\\n\\n        return dfs(0, n)\\n```\n```\\n    def countVowelStrings_recursive(self, n: int) -> int:\\n        def count(n, vowels):\\n            if n == 1:\\n                return vowels\\n\\n            if vowels == 1:\\n                return 1\\n\\n            return count(n, vowels - 1) + count(n - 1, vowels)\\n\\n        return count(n, 5)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1021481,
                "title": "easy-to-understand-dynamic-programming-approach-time-complexity-o-n",
                "content": "There is a simple logic behind this approach which is as follows,\\n* To make string of **length n** which starts with **\"a\"** can be formed by concating strings of **length n-1** which can start with **{a,e,i,o,u}**.\\n* To make string of **length n** which starts with **\"e\"** can be formed by concating strings of **length n-1** which can start with **{e,i,o,u}**.\\n* To make string of **length n** which starts with **\"i\"** can be formed by concating strings of **length n-1** which can start with **{i,o,u}**.\\n* To make string of **length n** which starts with **\"o\"** can be formed by concating strings of **length n-1** which can start with **{o,u}**.\\n* To make string of **length n** which starts with **\"u\"** can be formed by concating strings of **length n-1** which can start with **{u}**.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> adp(n+1) , edp(n+1) , idp(n+1) , odp(n+1) , udp(n+1,1);\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            odp[i] += odp[i-1];\\n            odp[i] += udp[i-1];\\n        }\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            idp[i] += idp[i-1];\\n            idp[i] += odp[i-1];\\n            idp[i] += udp[i-1];\\n        }\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            edp[i] += idp[i-1];\\n            edp[i] += odp[i-1];\\n            edp[i] += udp[i-1];\\n            edp[i] += edp[i-1];\\n        }\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            adp[i] += edp[i-1];\\n            adp[i] += odp[i-1];\\n            adp[i] += idp[i-1];\\n            adp[i] += udp[i-1];\\n            adp[i] += adp[i-1];\\n        }\\n        int ans = adp[n] + odp[n] + edp[n] + idp[n] + udp[n];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> adp(n+1) , edp(n+1) , idp(n+1) , odp(n+1) , udp(n+1,1);\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            odp[i] += odp[i-1];\\n            odp[i] += udp[i-1];\\n        }\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            idp[i] += idp[i-1];\\n            idp[i] += odp[i-1];\\n            idp[i] += udp[i-1];\\n        }\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            edp[i] += idp[i-1];\\n            edp[i] += odp[i-1];\\n            edp[i] += udp[i-1];\\n            edp[i] += edp[i-1];\\n        }\\n        for(int i = 1 ; i <= n ; i++ )\\n        {\\n            adp[i] += edp[i-1];\\n            adp[i] += odp[i-1];\\n            adp[i] += idp[i-1];\\n            adp[i] += udp[i-1];\\n            adp[i] += adp[i-1];\\n        }\\n        int ans = adp[n] + odp[n] + edp[n] + idp[n] + udp[n];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021338,
                "title": "easy-c-count-sorted-vowel-strings",
                "content": "# 1.Naive Approach\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> lks(5,1);\\n        while(n--) lks[4]+=lks[3]+=lks[2]+=lks[1]+=lks[0];\\n        return lks[4];\\n    }\\n};\\n```\\n# 2. Using Mathematical Formula\\n` f(n) = k1 + k2 + k3 + k4 + k5 : where k1 = n(n+1)(n+2)(n+3)/ 24 , k2 = n(n+1)(n+2)/6 , k3 = n(n+1)/2 , k4 = n , k5 = 1. After algebraic transformaition we have solution: where k1 - all combinations with first 1 and so etc`\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (pow(n,4)+10*pow(n,3)+35*pow(n,2)+50*n)/24 +1;\\n    }\\n};\\n```\\n# 3. Recursive Approach \\n```\\nint countVowelStrings(int n) \\n{\\n   return n==1 ? 5 : (n+4)*countVowelStrings(n-1)/n;\\n} \\n```\\n# 4. Some Mathematical Approach\\n```\\nint countVowelStrings(int n) {\\n    int res = 0, sum = 0;\\n    for (int i = 1; i <= n + 1; ++i) {\\n        sum += i * (i + 1) / 2;\\n        res += sum;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> lks(5,1);\\n        while(n--) lks[4]+=lks[3]+=lks[2]+=lks[1]+=lks[0];\\n        return lks[4];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (pow(n,4)+10*pow(n,3)+35*pow(n,2)+50*n)/24 +1;\\n    }\\n};\\n```\n```\\nint countVowelStrings(int n) \\n{\\n   return n==1 ? 5 : (n+4)*countVowelStrings(n-1)/n;\\n} \\n```\n```\\nint countVowelStrings(int n) {\\n    int res = 0, sum = 0;\\n    for (int i = 1; i <= n + 1; ++i) {\\n        sum += i * (i + 1) / 2;\\n        res += sum;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021158,
                "title": "rust-dp-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn count_vowel_strings(n: i32) -> i32 {\\n        let mut v = [1; 5];\\n        for _ in 1..n {\\n            for i in 1..5 {\\n                v[i] += v[i - 1];\\n            }\\n        }\\n        v.iter().sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn count_vowel_strings(n: i32) -> i32 {\\n        let mut v = [1; 5];\\n        for _ in 1..n {\\n            for i in 1..5 {\\n                v[i] += v[i - 1];\\n            }\\n        }\\n        v.iter().sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927079,
                "title": "backtracking-solution-java-accepted",
                "content": "**Backtracking solution -** \\n1.choose \\n2.explore\\n3.unchoose\\nKeep in mind that repetitions is allowed.\\n\\n\\n```\\nclass Solution {\\n   \\n    \\n    public int countVowelStrings(int n) {\\n         char[] arr = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        List<String> l = new ArrayList<>();\\n        back(l,arr,n,new StringBuilder(),0);\\n       // System.out.println(l);\\n        return l.size();\\n    }\\n    private void back(List<String> l  , char[] arr ,int n,StringBuilder s, int start)\\n    {\\n        if(n==0)\\n        {\\n            l.add(s.toString());\\n            return ;\\n        }\\n        for(int i=start;i<arr.length;i++)\\n        {\\n\\t\\t//choose\\n            s.append(arr[i]);\\n\\t\\t\\t/explore\\n            back(l,arr,n-1,s,i);\\n\\t\\t\\t//unchoose\\n            s.deleteCharAt(s.length()-1);\\n        }\\n    }\\n}\\n```\\n\\nUnlike other backtracking questions ,  we do not have to really store each result but actually just decrease \\'n\\' at each step of recursion until \\'n\\' reaches to zero .\\n\\n**Optimised Solution -**\\n\\n```\\nclass Solution {\\n    int ans=0;\\n    public int countVowelStrings(int n) {\\n        char[] arr= {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        \\n        back(arr, 0 , n);\\n       \\n            return ans;\\n    }\\n    private void back(char[] arr , int  start, int n)\\n    {  \\n        if(n==0)\\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int i=start ; i<arr.length;i++)\\n        {     \\n\\t\\t//for each character explore all other lexicographically viable solutions\\n                back(arr,i,n-1);   \\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n   \\n    \\n    public int countVowelStrings(int n) {\\n         char[] arr = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        List<String> l = new ArrayList<>();\\n        back(l,arr,n,new StringBuilder(),0);\\n       // System.out.println(l);\\n        return l.size();\\n    }\\n    private void back(List<String> l  , char[] arr ,int n,StringBuilder s, int start)\\n    {\\n        if(n==0)\\n        {\\n            l.add(s.toString());\\n            return ;\\n        }\\n        for(int i=start;i<arr.length;i++)\\n        {\\n\\t\\t//choose\\n            s.append(arr[i]);\\n\\t\\t\\t/explore\\n            back(l,arr,n-1,s,i);\\n\\t\\t\\t//unchoose\\n            s.deleteCharAt(s.length()-1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int ans=0;\\n    public int countVowelStrings(int n) {\\n        char[] arr= {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        \\n        back(arr, 0 , n);\\n       \\n            return ans;\\n    }\\n    private void back(char[] arr , int  start, int n)\\n    {  \\n        if(n==0)\\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int i=start ; i<arr.length;i++)\\n        {     \\n\\t\\t//for each character explore all other lexicographically viable solutions\\n                back(arr,i,n-1);   \\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918733,
                "title": "python-5-lines-simple-solution-and-well-commented-given-intuition",
                "content": "class Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        \\n        \"\"\"\\n        Intution of the problem\\n        in this problem we can see the pattern\\n        \\n        n=1  \"a\" \"e\" \"i\" \"o\" \"u\"\\n        \\n        n=2  \"aa\" \"ae\" \"ai\" \"ao\" \"au\" \"ee\" \"ei\" \"eo\" \"eu\" \"ii\" \"io\" \"iu\" \"oo\" \"ou\" \"uu\"\\n        here we need to add all vowels to its right side one\\'s \\n        \\n        n=2:\"a\" to  \"a\" \"e\" \"i\" \"o\" \"u\"   (5)\\n            \"e\" to  \"e\" \"i\" \"o\" \"u\"  (4)\\n            \"i\" to  \"i\" \"o\" \"u\"  (3)\\n            \"o\" to  \"o\" \"u\"  (2)\\n            \"u\" to  \"u\"  (1)\\n\\t\\t\\t\\n\\t\\t\\t\\t5+4+3+2+1 = 15\\n\\t\\t\\tso total=15\\n            \\n        n=3  we need to add vowel for strings which has prefix as the same vowel.\\n        \\n        n=3:\"a\" to  \"aa\" \"ae\" \"ai\" \"ao\" \"au\" \"ee\" \"ei\" \"eo\" \"eu\" \"ii\" \"io\" \"iu\" \"oo\" \"ou\" \"uu\"  (15)\\n            \"e\" to  \"ee\" \"ei\" \"eo\" \"eu\" \"ii\" \"io\" \"iu\"  \"oo\" \"ou\" \"uu\"  (10)\\n            \"i\" to  \"ii\" \"io\" \"iu\" \"oo\" \"ou\" \"uu\"  (6)\\n            \"o\" to  \"oo\" \"ou\" \"uu\"  (3)\\n            \"u\" to  \"uu\"  (1)\\n\\t\\t\\t\\n\\t\\t\\t15+10+6+3+1 = 35\\n        so total =35   \\n          \\n         \\n        \\n        \\n        if n==1 (dp = [1,1,1,1,1]) sum=5\\n        \\n        if n==2 (dp = [5,4,3,2,1]) sum=15\\n        \\n        if n==3 (dp = [15,10,6,3,1]) sum=35\\n        \\n        observations:\\n        \\n            the \"o\" position value was not changing so we can skip that col\\n         \\n            the first row(n==1) was the base no need to touch it\\n        \\n        relation: let\\'s understand with example\\n        let us we have n==2(it\\'s filled already)\\n        n==2  [5,4,3,2,1]\\n        n==3  [1,1,1,1,1]\\n        \\n        we need to skip last col ( as the value for \\'u\\' col will be always 1)\\n         \\n        next we need assign values with this formula \\n        \\n        *here j is the column no\\n        dp[3][j] = d[3][j+1]+ dp[2][j]\\n        \\n        after assigning the values for column=0 to 3(which mean for [a,e,i,o]). why because u will be always 1\\n        n==3 [15,10,6,3,1]\\n        \\n        we need to return the sum\\n        \"\"\"\\n        \\n        #here we are creating the dp table of length n and width \\'5\\' because we have 5 vowels \\n        dp=[[1]*5 for i in range(n)]\\n        \\n        #this is the first loop which will take care of the n\\n        for i in range(1,n):\\n            \\n            #this will fill the values by row\\n            for j in range(3,-1,-1):\\n                dp[i][j]=dp[i][j+1]+dp[i-1][j]\\n        #we need to return the whole sum of that row\\n        return sum(dp[n-1])\\n                                \\n            \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        \\n        \"\"\"\\n        Intution of the problem\\n        in this problem we can see the pattern\\n        \\n        n=1  \"a\" \"e\" \"i\" \"o\" \"u\"\\n        \\n        n=2  \"aa\" \"ae\" \"ai\" \"ao\" \"au\" \"ee\" \"ei\" \"eo\" \"eu\" \"ii\" \"io\" \"iu\" \"oo\" \"ou\" \"uu\"\\n        here we need to add all vowels to its right side one\\'s \\n        \\n        n=2:\"a\" to  \"a\" \"e\" \"i\" \"o\" \"u\"   (5)\\n            \"e\" to  \"e\" \"i\" \"o\" \"u\"  (4)\\n            \"i\" to  \"i\" \"o\" \"u\"  (3)\\n            \"o\" to  \"o\" \"u\"  (2)\\n            \"u\" to  \"u\"  (1)\\n\\t\\t\\t\\n\\t\\t\\t\\t5+4+3+2+1 = 15\\n\\t\\t\\tso total=15\\n            \\n        n=3  we need to add vowel for strings which has prefix as the same vowel.\\n        \\n        n=3:\"a\" to  \"aa\" \"ae\" \"ai\" \"ao\" \"au\" \"ee\" \"ei\" \"eo\" \"eu\" \"ii\" \"io\" \"iu\" \"oo\" \"ou\" \"uu\"  (15)\\n            \"e\" to  \"ee\" \"ei\" \"eo\" \"eu\" \"ii\" \"io\" \"iu\"  \"oo\" \"ou\" \"uu\"  (10)\\n            \"i\" to  \"ii\" \"io\" \"iu\" \"oo\" \"ou\" \"uu\"  (6)\\n            \"o\" to  \"oo\" \"ou\" \"uu\"  (3)\\n            \"u\" to  \"uu\"  (1)\\n\\t\\t\\t\\n\\t\\t\\t15+10+6+3+1 = 35\\n        so total =35   \\n          \\n         \\n        \\n        \\n        if n==1 (dp = [1,1,1,1,1]) sum=5\\n        \\n        if n==2 (dp = [5,4,3,2,1]) sum=15\\n        \\n        if n==3 (dp = [15,10,6,3,1]) sum=35\\n        \\n        observations:\\n        \\n            the \"o\" position value was not changing so we can skip that col\\n         \\n            the first row(n==1) was the base no need to touch it\\n        \\n        relation: let\\'s understand with example\\n        let us we have n==2(it\\'s filled already)\\n        n==2  [5,4,3,2,1]\\n        n==3  [1,1,1,1,1]\\n        \\n        we need to skip last col ( as the value for \\'u\\' col will be always 1)\\n         \\n        next we need assign values with this formula \\n        \\n        *here j is the column no\\n        dp[3][j] = d[3][j+1]+ dp[2][j]\\n        \\n        after assigning the values for column=0 to 3(which mean for [a,e,i,o]). why because u will be always 1\\n        n==3 [15,10,6,3,1]\\n        \\n        we need to return the sum\\n        \"\"\"\\n        \\n        #here we are creating the dp table of length n and width \\'5\\' because we have 5 vowels \\n        dp=[[1]*5 for i in range(n)]\\n        \\n        #this is the first loop which will take care of the n\\n        for i in range(1,n):\\n            \\n            #this will fill the values by row\\n            for j in range(3,-1,-1):\\n                dp[i][j]=dp[i][j+1]+dp[i-1][j]\\n        #we need to return the whole sum of that row\\n        return sum(dp[n-1])\\n                                \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 918728,
                "title": "java-dp-beats-100",
                "content": "The main intuition behind this solution is, if we know number of valid permutations of sorted strings of length n-1 starting with a, e, i, o, u, say a(n-1), e(n-1), i(n-1), o(n-1), u(n-1).\\nIn order to get sorted n length strings we can add a, e, i, o, u before n-1 length strings. Now we can not add u before strings starting with a/e/i/o. We can only add u before string starting with u.\\nso,          u(n) = u(n-1)              [u(n) will always be 1 as if a string starts with u, to keep it sorted we can only add u to it.)\\nsimillarly o(n) = o(n-1) + u(n-1)  = o(n-1) + u(n)   add o before strings starting with o/u\\ni(n) = i(n-1) + o(n-1) + u(n-1) = i(n-1) + o(n)     add i before strings starting with i/o/u\\ne(n) = e(n-1) + i(n-1) + o(n-1) + u(n-1) = e(n-1) + i(n)    add e before strings starting with e/i/o/u\\na(n) = a(n-1)  +  e(n-1) + i(n-1) + o(n-1) + u(n-1) = a(n-1) + e(n)\\n\\nAnd finally Total T(n) = a(n) + e(n) + i(n) + o(n) + u(n)\\nbase case is a(1) = 1, e(1) =1, i(1) =1, o(1) =1 and u(!) = 1.\\n     \\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n][5];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<n;i++){\\n            for(int j=4;j>=0;j--){\\n                dp[i][j] = j==4?1:dp[i-1][j] + dp[i][j+1];\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0;i<5;i++){\\n            res+=dp[n-1][i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int[][] dp = new int[n][5];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<n;i++){\\n            for(int j=4;j>=0;j--){\\n                dp[i][j] = j==4?1:dp[i-1][j] + dp[i][j+1];\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0;i<5;i++){\\n            res+=dp[n-1][i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918580,
                "title": "simple-javascript-backtracking",
                "content": "This approach can also be used to list all the strings if needed.\\n\\n```\\nvar countVowelStrings = function(n) {\\n    let str = \\'aeiou\\'\\n    let res = 0\\n    \\n    function backtrack(i, arr){\\n        if(arr.length == n){\\n            res++\\n            return\\n        }\\n        \\n        for(let j=i;j<str.length;j++){\\n            arr.push(j)\\n            backtrack(j, arr)\\n            arr.pop()\\n        }\\n    }\\n    \\n    backtrack(0, [])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar countVowelStrings = function(n) {\\n    let str = \\'aeiou\\'\\n    let res = 0\\n    \\n    function backtrack(i, arr){\\n        if(arr.length == n){\\n            res++\\n            return\\n        }\\n        \\n        for(let j=i;j<str.length;j++){\\n            arr.push(j)\\n            backtrack(j, arr)\\n            arr.pop()\\n        }\\n    }\\n    \\n    backtrack(0, [])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918553,
                "title": "swift-two-solutions",
                "content": "Solution 1 : Understand The Pattern\\n```\\nfunc countVowelStrings(_ n: Int) -> Int {\\n        var a = 1, e = 1, i = 1, o = 1, u = 1\\n        for j in 1..<n{\\n            a = (a+e+i+o+u)\\n            e = (e+i+o+u)\\n            i = (i+o+u)\\n            o = (o+u)\\n        }\\n        return (a+e+i+o+u)\\n    }\\n```\\nSolution 2 : Combinations (nCr)\\n```\\nfunc countVowelStrings(_ n: Int) -> Int {\\n        return (n+4) * (n+3) * (n+2) * (n+1) / 24\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc countVowelStrings(_ n: Int) -> Int {\\n        var a = 1, e = 1, i = 1, o = 1, u = 1\\n        for j in 1..<n{\\n            a = (a+e+i+o+u)\\n            e = (e+i+o+u)\\n            i = (i+o+u)\\n            o = (o+u)\\n        }\\n        return (a+e+i+o+u)\\n    }\\n```\n```\\nfunc countVowelStrings(_ n: Int) -> Int {\\n        return (n+4) * (n+3) * (n+2) * (n+1) / 24\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918452,
                "title": "c-1-line-mathematical-solution-with-brief-explanations",
                "content": "We have counts of a + e + i + o + u = n\\nTherefore, we can use combination with repetition formula to solve it as:\\nanswer = H(5, n) = C(5 + n - 1, n) = C(4 + n, n) = C(n + 4, 4) = (n+4) * (n+3) * (n+2) * (n+1) / 4!\\n\\nMore information of combination with repetition formula can be found here:\\nhttps://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition\\nThe notation of H above corresponds to the double parentheses in the link. The transformation of H and C is also included in the wiki page.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+4) * (n+3) * (n+2) * (n+1) / 24;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        return (n+4) * (n+3) * (n+2) * (n+1) / 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918370,
                "title": "python-1-liner",
                "content": "```\\nreturn math.comb(n+4, 4)\\n```",
                "solutionTags": [],
                "code": "```\\nreturn math.comb(n+4, 4)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3889457,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        if(n==1) return 5;\\n        vector<int>v{1,2,3,4,5};\\n        for(int i=3;i<=n;i++){\\n        vector<int>tmp;\\n            for(int j=0;j<5;j++){\\n                int a=0;\\n                for(int k=0;k<=j;k++){\\n                    \\n                    a+=v[k];\\n                }\\n                tmp.emplace_back(a);\\n            }\\n            copy(tmp.begin(), tmp.end(), v.begin());\\n\\n        }\\n        int ans=0;\\n        for(int i=0;i<5;i++){\\n            ans+=v[i];\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        if(n==1) return 5;\\n        vector<int>v{1,2,3,4,5};\\n        for(int i=3;i<=n;i++){\\n        vector<int>tmp;\\n            for(int j=0;j<5;j++){\\n                int a=0;\\n                for(int k=0;k<=j;k++){\\n                    \\n                    a+=v[k];\\n                }\\n                tmp.emplace_back(a);\\n            }\\n            copy(tmp.begin(), tmp.end(), v.begin());\\n\\n        }\\n        int ans=0;\\n        for(int i=0;i<5;i++){\\n            ans+=v[i];\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555473,
                "title": "simple-approach-using-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1,b=1,c=1,d=1,e=1;\\n        for(int i=1;i<n;i++){\\n            a=a+b+c+d+e;\\n            b=b+c+d+e;\\n            c=c+d+e;\\n            d=d+e;\\n        }\\n        return a+b+c+d+e;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a=1,b=1,c=1,d=1,e=1;\\n        for(int i=1;i<n;i++){\\n            a=a+b+c+d+e;\\n            b=b+c+d+e;\\n            c=c+d+e;\\n            d=d+e;\\n        }\\n        return a+b+c+d+e;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427364,
                "title": "identify-the-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> v(5,1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=4;j>0;j--)\\n            {\\n                v[j-1] += v[j]; \\n            }\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> v(5,1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=4;j>0;j--)\\n            {\\n                v[j-1] += v[j]; \\n            }\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312419,
                "title": "one-line-code-math-sol-recursion-approach-bottom-up-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return ((n+4)*(n+3)*(n+2)*(n+1))//24\\n```\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        def helper(n,vowel):\\n            if n==0:\\n                return 1\\n            res=0\\n            for x in range(vowel,5):\\n                res+=helper(n-1,x)\\n            return res\\n        return helper(n,0)\\n```\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        def bottomup(n):\\n            tb=[1,1,1,1,1]\\n            for j in range(n-1):\\n                for i in range(len(tb)-2,-1,-1):\\n                    tb[i]=tb[i+1]+tb[i]\\n            return sum(tb)\\n        return bottomup(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return ((n+4)*(n+3)*(n+2)*(n+1))//24\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        def helper(n,vowel):\\n            if n==0:\\n                return 1\\n            res=0\\n            for x in range(vowel,5):\\n                res+=helper(n-1,x)\\n            return res\\n        return helper(n,0)\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        def bottomup(n):\\n            tb=[1,1,1,1,1]\\n            for j in range(n-1):\\n                for i in range(len(tb)-2,-1,-1):\\n                    tb[i]=tb[i+1]+tb[i]\\n            return sum(tb)\\n        return bottomup(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922222,
                "title": "100-fast-0ms-java-solution-easy-implementation-of-dp",
                "content": "\\n# Easiest method : By using direct formulation\\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n}\\n\\n```\\n# Simple solution using DP\\n```\\nclass Solution {\\n    int[][] dp = new int[51][6];\\n    int sum = 0;\\n    public int countVowelStrings(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            for(int i=1;i<6;i++){\\n                dp[n][i] = 1;\\n                sum += dp[1][i];\\n            }\\n            return sum;\\n        }\\n        if(dp[n-1][1]==0){\\n            countVowelStrings(n-1);\\n            dp[n][1] = sum;\\n            for(int i=2;i<6;i++){\\n                dp[n][i] = dp[n][i-1]-dp[n-1][i-1];\\n                sum += dp[n][i];\\n            }\\n            return sum;\\n        }\\n        for(int i=1;i<6;i++)\\n            sum += dp[n][i];\\n        return sum;\\n    }\\n}\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        return (n+1)*(n+2)*(n+3)*(n+4)/24;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    int[][] dp = new int[51][6];\\n    int sum = 0;\\n    public int countVowelStrings(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            for(int i=1;i<6;i++){\\n                dp[n][i] = 1;\\n                sum += dp[1][i];\\n            }\\n            return sum;\\n        }\\n        if(dp[n-1][1]==0){\\n            countVowelStrings(n-1);\\n            dp[n][1] = sum;\\n            for(int i=2;i<6;i++){\\n                dp[n][i] = dp[n][i-1]-dp[n-1][i-1];\\n                sum += dp[n][i];\\n            }\\n            return sum;\\n        }\\n        for(int i=1;i<6;i++)\\n            sum += dp[n][i];\\n        return sum;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856298,
                "title": "0-ms-faster-than-100-00-c-cp",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Sorted Vowel Strings.\\nMemory Usage: 5.9 MB, less than 60.93% of C++ online submissions for Count Sorted Vowel Strings.**\\n\\n# \\t**c++**\\n\\n\\t int a=1, e=1, i=1, o=1, u=1;\\n        while(--n){\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        return a+e+i+o+u;\\n\\t\\t\\n**upvote supported**",
                "solutionTags": [
                    "C"
                ],
                "code": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Sorted Vowel Strings.\\nMemory Usage: 5.9 MB, less than 60.93% of C++ online submissions for Count Sorted Vowel Strings.**\\n\\n# \\t**c++**\\n\\n\\t int a=1, e=1, i=1, o=1, u=1;\\n        while(--n){\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }\\n        return a+e+i+o+u;\\n\\t\\t\\n**upvote supported**",
                "codeTag": "Unknown"
            },
            {
                "id": 2819357,
                "title": "c-easy-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        int ans = 0;\\n        \\n        while(--n){\\n            for(int i=3; i>=0; i--){\\n                dp[i] += dp[i+1];\\n            }\\n        }\\n        \\n        for(auto x:dp) ans += x;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int> dp(5, 1);\\n        int ans = 0;\\n        \\n        while(--n){\\n            for(int i=3; i>=0; i--){\\n                dp[i] += dp[i+1];\\n            }\\n        }\\n        \\n        for(auto x:dp) ans += x;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680293,
                "title": "top-down-and-bottom-up-dp-solutions-in-python",
                "content": "## Bottom Up\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        table = [[1]*5 for _ in range(n)]\\n        \\n        for r in range(1, n):\\n            for v in reversed(range(4)):\\n                a = table[r-1][v]\\n                b = table[r][v+1]\\n                \\n                table[r][v] = a + b\\n                \\n        return sum(table[n-1])\\n```\\n\\n## Top Down\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        self.items = \\'aeiou\\'\\n        \\n        return self.explore(n, \\'a\\')\\n        \\n    @cache\\n    def explore(self, n, last):\\n        if n == 0:\\n            return 1\\n        \\n        if n < 0:\\n            return 0\\n        \\n        total = 0\\n        for ch in self.items:\\n            if ch >= last:\\n                total += self.explore(n - 1, ch)\\n                \\n        return total\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        table = [[1]*5 for _ in range(n)]\\n        \\n        for r in range(1, n):\\n            for v in reversed(range(4)):\\n                a = table[r-1][v]\\n                b = table[r][v+1]\\n                \\n                table[r][v] = a + b\\n                \\n        return sum(table[n-1])\\n```\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        self.items = \\'aeiou\\'\\n        \\n        return self.explore(n, \\'a\\')\\n        \\n    @cache\\n    def explore(self, n, last):\\n        if n == 0:\\n            return 1\\n        \\n        if n < 0:\\n            return 0\\n        \\n        total = 0\\n        for ch in self.items:\\n            if ch >= last:\\n                total += self.explore(n - 1, ch)\\n                \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667835,
                "title": "faster-solution-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) \\n    {\\n       vector<int>v1(5,1);\\n   \\n       if(n==1)\\n       {\\n           int sum=0;\\n           for(int i=0;i<v1.size();i++)\\n           {\\n              sum=sum+v1[i];\\t\\n           }\\n           return sum;\\n       }\\n\\n       int count=2;\\n       while(count<=n)\\n       {\\n         vector<int>temp(5,0);\\n         int currsum=0;\\n\\n         for(int i=v1.size()-1;i>=0;i--)\\n         {\\n            currsum=currsum+v1[i];\\n            temp[i]=currsum;\\t\\n         }\\n         v1=temp;\\n         temp.clear();\\n         count++;\\n       }\\n       int sum=0;\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           sum=sum+v1[i];\\t\\n       }\\n       return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) \\n    {\\n       vector<int>v1(5,1);\\n   \\n       if(n==1)\\n       {\\n           int sum=0;\\n           for(int i=0;i<v1.size();i++)\\n           {\\n              sum=sum+v1[i];\\t\\n           }\\n           return sum;\\n       }\\n\\n       int count=2;\\n       while(count<=n)\\n       {\\n         vector<int>temp(5,0);\\n         int currsum=0;\\n\\n         for(int i=v1.size()-1;i>=0;i--)\\n         {\\n            currsum=currsum+v1[i];\\n            temp[i]=currsum;\\t\\n         }\\n         v1=temp;\\n         temp.clear();\\n         count++;\\n       }\\n       int sum=0;\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           sum=sum+v1[i];\\t\\n       }\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586637,
                "title": "time-100-beats-space-98-beats-c-easy-simple-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int &n) {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while(--n){\\n            o = o+u;\\n            i = i+o;\\n            e = e+i;\\n            a = a+e;\\n        }\\n        return (a+e+i+o+u);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int &n) {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while(--n){\\n            o = o+u;\\n            i = i+o;\\n            e = e+i;\\n            a = a+e;\\n        }\\n        return (a+e+i+o+u);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565696,
                "title": "simple-java-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution \\n  {\\n    int a=1,e=1,i=1,u=1,o=1;\\n    \\n    public int countVowelStrings(int n) \\n    {\\n        for(int k=1; k<n; k++)\\n            increase();\\n        \\n        return a + e + i + o + u;\\n    }\\n    \\n    private void increase()\\n    {\\n        o = o + u;\\n        i = i + o;\\n        e = e + i;\\n        a = a + e;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n  {\\n    int a=1,e=1,i=1,u=1,o=1;\\n    \\n    public int countVowelStrings(int n) \\n    {\\n        for(int k=1; k<n; k++)\\n            increase();\\n        \\n        return a + e + i + o + u;\\n    }\\n    \\n    private void increase()\\n    {\\n        o = o + u;\\n        i = i + o;\\n        e = e + i;\\n        a = a + e;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433041,
                "title": "no-dp-0ms-c",
                "content": "class Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n             int ans = 0;\\n        for (int i=1; i<=n+1; i++) {\\n            int cnt=0;\\n            for (int j=1; j<=i; j++) {\\n                cnt=cnt +  j;\\n                ans=ans + cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n             int ans = 0;\\n        for (int i=1; i<=n+1; i++) {\\n            int cnt=0;\\n            for (int j=1; j<=i; j++) {\\n                cnt=cnt +  j;\\n                ans=ans + cnt;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2419982,
                "title": "dp-o-1-time-space-faster-than-100",
                "content": "1. Take ```a,e,i,o,u``` as constants and mark their value as 1. This is for scenario when the value of ```n``` is 1. (Base case).\\n2. For subsequent ```n```, we will take help of the fact that with the help of ```a``` we can generate total ```a+e+i+o+u``` strings. Why? Because any previous string ending in ```a,e,i,o,u``` can have ```a``` as their new suffix. Similarly we will do for all other vowels.\\n3. At last return the final sum of ```a+e+i+o+u``` \\n\\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a =1, e=1, i=1, o=1, u=1;\\n        for(int j=1; j<n; j++){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a+e+i+o+u;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```a,e,i,o,u```\n```n```\n```n```\n```a```\n```a+e+i+o+u```\n```a,e,i,o,u```\n```a```\n```a+e+i+o+u```\n```\\nclass Solution {\\n    public int countVowelStrings(int n) {\\n        int a =1, e=1, i=1, o=1, u=1;\\n        for(int j=1; j<n; j++){\\n            a = a + e + i + o + u;\\n            e = e + i + o + u;\\n            i = i + o + u;\\n            o = o + u;\\n            u = u;\\n        }\\n        return a+e+i+o+u;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352283,
                "title": "c-dp-0ms-100-faster",
                "content": "This problem can be solve using recursion, but we can observe that there will be lots of overlapping subproblem calls happening. So, we can use  Dynamic Programming to solve this problem.\\n\\nThe idea is: if there is only one element to pick. The possibility depends only on the previous occuring element. if the previous element is \"i\" then we can choose next \"i\", \"o\" or \"u\".\\ndp[i][j] -> combinations possible with \"i\"-th vowel and \"j\" elements.\\nand the tabulation filling equation can be obtained from the recursive function.\\n\\n\\n```\\nclass Solution {\\n  const char sample[5] = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\npublic:\\n  // recursive approach to solve the problem\\n  // int countValidStrings(int n, char prev_char)\\n  // {\\n  //   if(n==1)\\n  //   {\\n  //     if(prev_char == \\'a\\') return 5;\\n  //     if(prev_char == \\'e\\') return 4;\\n  //     if(prev_char == \\'i\\') return 3;\\n  //     if(prev_char == \\'o\\') return 2;\\n  //     if(prev_char == \\'u\\') return 1;\\n  //   }\\n  //   int ans = 0;\\n  //   for(int i=0; i<5; i++)\\n  //   {\\n  //     if(prev_char<=sample[i])\\n  //       ans += countValidStrings(n-1, sample[i]);\\n  //   }\\n  //   return ans;\\n  // }\\n  int countVowelStrings(int n)\\n  {\\n    // dp tabulation\\n\\n    int dp[5][n];\\n    for(int i=0; i<5; i++)\\n      dp[i][0] = i+1;\\n    for(int i=0; i<n; i++)\\n      dp[0][i]=1;\\n\\n    // make tabulation formula\\n    int prev_sum = 1;\\n    for(int i=1; i<n; i++)\\n    {\\n      for(int j=1; j<5; j++)\\n      {\\n        dp[j][i] = prev_sum + dp[j][i-1];\\n        prev_sum = dp[j][i];\\n      }\\n      prev_sum = 1;\\n    }\\n\\n    // return the last element\\n    return dp[4][n-1];\\n  }\\n};\\n```\\nTime complexity: O(n) or more precisely O(5n)\\nAuxiliary Space: O(n) or more precisely O(5n)\\n\\nWe can optimise the dp[][] a bit, as we don\\'t need vaues before 1 column. But anyway, have a good day.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  const char sample[5] = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\npublic:\\n  // recursive approach to solve the problem\\n  // int countValidStrings(int n, char prev_char)\\n  // {\\n  //   if(n==1)\\n  //   {\\n  //     if(prev_char == \\'a\\') return 5;\\n  //     if(prev_char == \\'e\\') return 4;\\n  //     if(prev_char == \\'i\\') return 3;\\n  //     if(prev_char == \\'o\\') return 2;\\n  //     if(prev_char == \\'u\\') return 1;\\n  //   }\\n  //   int ans = 0;\\n  //   for(int i=0; i<5; i++)\\n  //   {\\n  //     if(prev_char<=sample[i])\\n  //       ans += countValidStrings(n-1, sample[i]);\\n  //   }\\n  //   return ans;\\n  // }\\n  int countVowelStrings(int n)\\n  {\\n    // dp tabulation\\n\\n    int dp[5][n];\\n    for(int i=0; i<5; i++)\\n      dp[i][0] = i+1;\\n    for(int i=0; i<n; i++)\\n      dp[0][i]=1;\\n\\n    // make tabulation formula\\n    int prev_sum = 1;\\n    for(int i=1; i<n; i++)\\n    {\\n      for(int j=1; j<5; j++)\\n      {\\n        dp[j][i] = prev_sum + dp[j][i-1];\\n        prev_sum = dp[j][i];\\n      }\\n      prev_sum = 1;\\n    }\\n\\n    // return the last element\\n    return dp[4][n-1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329962,
                "title": "c-easy-and-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int>v{1,1,1,1,1};// declare a vector with all five elements to 1\\n        // change vector v after every iteration \\n        //first time {1,1,1,1,1}--5\\n        // next time {5,4,3,2,1}--15\\n        // next time {15,10,6,3,1}--35\\n        // next time {35,20,10,4,1}--70\\n        //next time {70,35,15,5,1}--126\\n        // we get a pattern\\n        // dp vector\\n        vector<int>dp(n,0);\\n        // first value of dp to 5\\n        dp[0]=5;\\n        for(int i=1;i<n;i++){\\n            vector<int>v1(5,0);\\n            v1[0]=dp[i-1];\\n            v1[1]=v1[0]-v[0];\\n            v1[2]=v1[1]-v[1];\\n            v1[3]=v1[2]-v[2];\\n            v1[4]=v1[3]-v[3];\\n            v=v1;\\n            dp[i]=v1[0]+v1[1]+v1[2]+v1[3]+v1[4];\\n        }\\n       return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int>v{1,1,1,1,1};// declare a vector with all five elements to 1\\n        // change vector v after every iteration \\n        //first time {1,1,1,1,1}--5\\n        // next time {5,4,3,2,1}--15\\n        // next time {15,10,6,3,1}--35\\n        // next time {35,20,10,4,1}--70\\n        //next time {70,35,15,5,1}--126\\n        // we get a pattern\\n        // dp vector\\n        vector<int>dp(n,0);\\n        // first value of dp to 5\\n        dp[0]=5;\\n        for(int i=1;i<n;i++){\\n            vector<int>v1(5,0);\\n            v1[0]=dp[i-1];\\n            v1[1]=v1[0]-v[0];\\n            v1[2]=v1[1]-v[1];\\n            v1[3]=v1[2]-v[2];\\n            v1[4]=v1[3]-v[3];\\n            v=v1;\\n            dp[i]=v1[0]+v1[1]+v1[2]+v1[3]+v1[4];\\n        }\\n       return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321538,
                "title": "backtracking-c",
                "content": "```\\nclass Solution {\\n    void dfs(int i, string &s, vector<char> &v, int &n, int &ans) {\\n        if(s.size() == n){\\n            ans++;\\n            return;\\n        }\\n        for(int j=i; j<v.size(); j++) {\\n            s += v[j];\\n            dfs(j, s, v, n, ans);\\n            s.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        int ans = 0;\\n        vector<char> v = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        string s;\\n        dfs(0, s, v, n, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, string &s, vector<char> &v, int &n, int &ans) {\\n        if(s.size() == n){\\n            ans++;\\n            return;\\n        }\\n        for(int j=i; j<v.size(); j++) {\\n            s += v[j];\\n            dfs(j, s, v, n, ans);\\n            s.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    int countVowelStrings(int n) {\\n        int ans = 0;\\n        vector<char> v = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        string s;\\n        dfs(0, s, v, n, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249905,
                "title": "pattern-recognition-beats-100-easy-explanation",
                "content": "For n=1, each vowel will give 1 string (1*5)=5 [1, 1, 1, 1, 1]\\nFor n=2, each vowel will give [5, 4, 3, 2, 1] strings respectively\\nFor n=3, each vowel will give [15, 10, 6, 3, 1] strings respectively\\n\\n* sequence of vowels considered here is **a, e, i, o, u**\\n\\nWe can observe a pattern here, for nth integer a, e, i, o, u will generate certain number of string (which are lexographically sorted) can be calculated by number of strings they generated for (n-1)th integer.\\n\\nFor ex, if \\'o\\' is generating 2 strings & \\'u\\' is generating 1 string for n=2, then for n=3 \\'o\\' will generate 2 (no. of \\'o\\' strings for n=2) + 1 (no. of \\'u\\' strings for n=2) i.e. 2+1 = 3.\\n\\n**PS. Try to write down number of strings possible for n=1, 2, 3 & match the pattern.**\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n\\n        vector<int> dp(5, 1);\\n        int ans=0;\\n        n--;\\n        while(n--){\\n            for(int i=3;i>=0;i--){\\n                dp[i]+=dp[i+1];\\n            }\\n        }\\n        for(int i:dp) ans+=i;\\n        return ans;\\n    }\\n};\\n```\\n\\n*Let\\'s discuss in comments if you\\'ve any questions, suggestions or edits.*",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n\\n        vector<int> dp(5, 1);\\n        int ans=0;\\n        n--;\\n        while(n--){\\n            for(int i=3;i>=0;i--){\\n                dp[i]+=dp[i+1];\\n            }\\n        }\\n        for(int i:dp) ans+=i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219275,
                "title": "1-liner-combinational-logic",
                "content": "It is known that the characters should appear in ascending lexicographic order.\\nIt is known that there are a total of 5 characters.\\nConclusion: There are only 4 places where the character is replaced by the one followed by the sorted order.\\nWe have (n + 4) locations in total.\\n\\tHence, the answer is (using a binomial coefficient):   (n + 4) C 4\\nAfter we simplify the above expression, we will get the solution in front of you.\\n\\n```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) // 24\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelStrings(self, n: int) -> int:\\n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) // 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205033,
                "title": "c-recursion-memoization-tabulation-both-0ms-and-100-beat",
                "content": "**RECURSION**\\n\\n\"\"\"\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint solve(int i,vector<char>& vowels,int n){\\n\\t\\t\\tif(i==5) return 0;\\n\\t\\t\\tif(n==0) return 1;\\n\\t\\t\\t\\n\\t\\t\\treturn solve(i,vowels,n-1) + solve(i+1,vowels,n);\\n\\t\\t}\\n\\t\\tint countVowelStrings(int n) {\\n\\t\\t\\tvector<char> vowels {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\t\\t\\treturn solve(0,vowels,n);\\n\\t\\t}\\n\\t};\\n\\t\\n\"\"\"\\n\\n**MEMOIZATION (TOP-DOWN)**\\n\\n\"\"\"\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint solve(int i,vector<char>& vowels,int n,vector<vector<int>>& dp){\\n\\t\\t\\tif(i==-1) return 0;\\n\\t\\t\\tif(n==0) return 1;\\n\\t\\t\\t\\n\\t\\t\\tif(dp[i][n]!=-1) return dp[i][n];\\n\\t\\t\\treturn dp[i][n] = solve(i,vowels,n-1,dp) + solve(i-1,vowels,n,dp);\\n\\t\\t}\\n\\t\\tint countVowelStrings(int n) {\\n\\t\\t\\tvector<char> vowels {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\t\\t\\tvector<vector<int>> dp(5,vector<int>(n+1,-1));\\n\\t\\t\\treturn solve(4,vowels,n,dp);\\n\\t\\t}\\n\\t};\\n\\t\\n\"\"\"\\n\\n**TABULATION (TOP - DOWN)**\\n\\n\"\"\"\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countVowelStrings(int n) {\\n\\t\\t\\tvector<vector<int>> dp(5,vector<int>(n+1,0));\\n\\t\\t\\tfor(int i=0;i<5;i++) dp[i][0] = 1;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<5;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=n;j++){\\n\\t\\t\\t\\t\\tint pick = dp[i][j-1];\\n\\t\\t\\t\\t\\tint notPick = 0;\\n\\t\\t\\t\\t\\tif(i>0) notPick = dp[i-1][j];\\n\\t\\t\\t\\t\\tdp[i][j] = pick + notPick;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[4][n];\\n\\t\\t}\\n\\t};\\n\\n\"\"\"\\n\\n***UPVOTE IF YOU FOUND IT USEFUL***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint solve(int i,vector<char>& vowels,int n){\\n\\t\\t\\tif(i==5) return 0;\\n\\t\\t\\tif(n==0) return 1;\\n\\t\\t\\t\\n\\t\\t\\treturn solve(i,vowels,n-1) + solve(i+1,vowels,n);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2182246,
                "title": "c-solution-using-dp-o-1-time-space",
                "content": "# **EXPLANATION:**\\n## The following cases for different values of n where all 5 values are shown w.r.t the cases possible for the vowels.****\\n// for 1: 1+1+1+1+1\\n// for 2: (1+1+1+1+1)+(1+1+1+1)+(1+1+1)+(1+1)+(1)    = 15\\n// for 3: (5+4+3+2+1)+(4+3+2+1)+(3+2+1)+(2+1)+(1)    = 35\\n// for 4: ((5+4+3+2+1)+(4+3+2+1)+(3+2+1)+(2+1)+(1))+((4+3+2+1)+(3+2+1)+(2+1)+(1))+((3+2+1)+(2+1)+(1))+((2+1)+(1))+((1))                                    = 70\\n// or for 4: 35 + 20 + 10 + 4 + 1                    = 70\\n// for 5:  70 + 35 + 15 + 5 + 1                      = 126\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int>dp = {0,1,1,1,1,1};\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=1;i<=5;i++)\\n            {\\n                dp[i] += dp[i-1];\\n            }\\n        }\\n        return dp[5];\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n        vector<int>dp = {0,1,1,1,1,1};\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=1;i<=5;i++)\\n            {\\n                dp[i] += dp[i-1];\\n            }\\n        }\\n        return dp[5];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153247,
                "title": "easy-100-fastest-solution",
                "content": "Approach: if we select a vovel we can add it one or mutiple times so helper(n-1,i) we are adding a selected vovel multiple time, helper(n,i+1) we didn\\'t added the vowel in the string and moved to the next vovel, Since 0 to 5 represent the vovel in lexicographical order of vovel and we are only selecting the vovel in lexico order therefore string formed is in lexicographical order\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int i,vector<vector<int>> &dp)\\n    {\\n        if(dp[n][i]!=-1)\\n            return dp[n][i];\\n        if(i==5)\\n            return dp[n][i]=0;\\n        if(n==0)\\n            return dp[n][i]=1;\\n        return dp[n][i]=helper(n-1,i,dp)+helper(n,i+1,dp);\\n            \\n    }\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> dp(n+1,vector<int> (6,-1));\\n        return helper(n,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int n,int i,vector<vector<int>> &dp)\\n    {\\n        if(dp[n][i]!=-1)\\n            return dp[n][i];\\n        if(i==5)\\n            return dp[n][i]=0;\\n        if(n==0)\\n            return dp[n][i]=1;\\n        return dp[n][i]=helper(n-1,i,dp)+helper(n,i+1,dp);\\n            \\n    }\\n    int countVowelStrings(int n) {\\n        vector<vector<int>> dp(n+1,vector<int> (6,-1));\\n        return helper(n,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050080,
                "title": "c-100-faster-using-maths-easy-solution",
                "content": "**Easy Solution**\\n\\n**It can be solved by Using Simple Math Formula**\\n**`ans=(5*6*7*8*9....*(n+4))/n!`**\\n\\n`for n=2`\\n`ans=(5*6)/(2*1)=15`\\n\\n`for n=4`\\n`ans=(5*6*7*8)/(4*3*2*1)=70`\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n     if(n==1)\\n         return 5;\\n\\t\\n        int ans=5;\\n        int temp=5;\\n        for(int i=2;i<=n;i++)\\n\\t\\t{\\n\\t\\t\\tans=ans*(temp+1)/i;\\n\\t\\t\\ttemp++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If YOU Find it helpful Kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelStrings(int n) {\\n     if(n==1)\\n         return 5;\\n\\t\\n        int ans=5;\\n        int temp=5;\\n        for(int i=2;i<=n;i++)\\n\\t\\t{\\n\\t\\t\\tans=ans*(temp+1)/i;\\n\\t\\t\\ttemp++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570874,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1566439,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1570263,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1574763,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1574547,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1844168,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1576740,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1977327,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1867926,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1818801,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1570874,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1566439,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1570263,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1574763,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1574547,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1844168,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1576740,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1977327,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1867926,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            },
            {
                "id": 1818801,
                "content": [
                    {
                        "username": "imanmalik",
                        "content": "Let\\'s notice that for each list of letters [a, e, e, a, a, o, i, i, u, i] there is one and only one way to place them in a lexicographic order. Thus, we can sort our letters and assume that they occur in 5 batches (possibly, some of them empty) and sizes of those batches add up to n. \\n\\nNow let\\'s assume we have n identicall balls in a row. Then if we place 4 partitions between them, it would be safe to say we obtained the desired 5 batches that will represent our desired string. \\n\\nSo we have n+4 objects in total - n balls and 4 partitions. The number of ways to place those partitions is a combination without replacement of 4 from (n+4) objects.\\n\\n![image](https://assets.leetcode.com/users/images/babea18f-39cf-475b-b581-77e67ca1fa70_1652239723.11787.jpeg)\\n\\nP.S. one could easily miscalculate the number of ways to place partitions. One of the common mistakes would be to choose places between the balls. But then you will have to take into account the combinations where two or more partitions are side-by-side. It is challenging, because you should not differentiate between partitions, and you have to exclude cases where you placed 1st and 2nd, or 2nd and 1st which becomes very hectic and hard to scale"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "That\\'s really great explanation.. I was also doing same mistake of putting partition, making calculations quite complicated.. But your perspective to see it differently is really great and easy.. \\uD83E\\uDD18\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB\\uD83D\\uDC4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-sorted-vowel-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Backtracking\n\n  \n**Approach 2:** Decoding the Pattern, Using Recursion\n\n  \n**Approach 3:** Using Recursion + Memoization, Top Down Dynamic Programming\n\n  \n**Approach 4:** Bottom Up Dynamic Programming, Tabulation\n\n  \n**Approach 5:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dd2233",
                        "content": "This problem does not need iteration or recurssion to solve.  DP is overkill since the recurrence relations making up this problem have very nice solutions (after all, they are linear recurrence relations --- they *must* have very nice solutions).\\n\\nAs others have pointed out, we know that all strings that end in \\'a\\' will consist entirely of \\'a\\' (e.g., a, aa, aaa, etc).\\nThis means that our recurrence relation for the number of strings ending in \\'a\\' is straightforward: A[n] = 1.\\n\\nE[n] is next.  Stings ending in \\'e\\' are either \\'e\\', for n = 1, or the the strings which ended in \\'e\\' and the strings ending in \\'a\\' for n-1 concattenated with an \\'e\\'.  This means E[1] = 1, and E[n] = E[n-1] + A[n-1] = E[n-1] + 1 = n.\\n\\nI[n] is next.  Similarly, I[1] = 1 (\\'i\\'), and I[n] = I[n-1] + E[n-1] + A[n-1] = I[n-1] + E[n] = I[n-1] + n = n*(n+1) / 2 --- a very famous recurrence relation\\n\\nO[n] is next.  O[1] = 1 (\\'o\\'), and O[n] = O[n-1] + I[n-1] + E[n-1] + A[n-1] = O[n-1] + n*(n+1)/2 = n*(n+1)*(n+2)/6\\n\\nFinally U[n].  U[1] = 1 (\\'u\\'), and U[n] = U[n-1] + .... = U[n-1] + O[n-1] = U[n-1] + n*(n+1)*(n+2)/6= n*(n+1)*(n+2)*(n+3)/24\\n\\nAs pointed out by https://leetcode.com/problems/count-sorted-vowel-strings/discuss/981224/Python-one-line-soultion\\n\\nthis sum of A[n] + E[n} ... + U[n] simplifies into (n+1)*(n+2)*(n+3)*(n+4) / 24.\\n\\nSo there you go, the solution in any language in constant time and space."
                    },
                    {
                        "username": "naroju",
                        "content": "bruh this is giving me 11th math sigma sigma summation vibes .... lol"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "UJJWAL_MITTAL",
                        "content": "This  problem can be solved using combinatorics as well . \\nOne can see this problem as \" no of ways to select  N vowels out of 5 vowels where each vowel can be repeated . We already know the formula of no of ways of selecting r things out of n things whe repetition is allowed\" \\n\\nThe formulae is  (n+r-1)C r \\n\\nWhich when simplified according to this problem \\n\\n r = N \\n N = 5 \\n hence formulae becomes (N + 4)C N \\n \\n on simpifying ,\\n \\n our answer reduces to \\n \\n (N+1 * N+2 * N+3 * N+4)/24"
                    },
                    {
                        "username": "heshan1234",
                        "content": "Basically, the output is going to be something like `a...ae...ei...io...ou...u` where we have groups of `a, e, i, o, u` and each group can have 0 or more elements.\\n\\nImagine we insert 4 delimiters, so it becomes `a...a|e...e|i...i|o...o|u...u`, where the characters between the delimiters are fixed to be one of `a, e, i, o, u`. The delimiters can cover cases like e.g., `a...a||||` where only `a` is used.\\n\\nSo we have positions for n characters and 4 delimiters, and we need to select 4 positions out for the delimiters, hence C(n+4, 4)."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "It may be easily  solved by using DP indirectly"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Let us imagine a typical valid Sorted Vowel String as aaa...eee...iii...o...uu..., where the order is already fixed.\\nSo, as long as the order is correct and the sum of all letters is equal to n, the string is valid.\\nThis problem can therefore be reduced to finding the number of solutions of the equation a+e+i+o+u= n, where 0 <= a,e,i,o,u <= n ( Here the letters a,e,i,o,u represent the frequency of itself in the string).\\nImagine 4 identical dividers and n identical boxes, the number of different ways to place them is therefore (n+4)! / ( n!*4!) .\\n\\nActually the Time Complexity of this Combinatorics solution is also O(n) as it takes n operations to calculate the value of n! ."
                    },
                    {
                        "username": "yuldashevazizbekb",
                        "content": "thank everbody i do it only for your help (sorry for english i cant speak i just translate it in google)\\n"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple combination technique(nCr)\\nhint:- think solution for  x+y+z+w+.......=n;"
                    },
                    {
                        "username": "user8228j",
                        "content": "i just did the first 3 by hand and found a simple pattern for a O(n) solution"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Matrix Sum",
        "question_content": "<p>You are given an <code>n x n</code> integer <code>matrix</code>. You can do the following operation <strong>any</strong> number of times:</p>\n\n<ul>\n\t<li>Choose any two <strong>adjacent</strong> elements of <code>matrix</code> and <strong>multiply</strong> each of them by <code>-1</code>.</li>\n</ul>\n\n<p>Two elements are considered <strong>adjacent</strong> if and only if they share a <strong>border</strong>.</p>\n\n<p>Your goal is to <strong>maximize</strong> the summation of the matrix&#39;s elements. Return <em>the <strong>maximum</strong> sum of the matrix&#39;s elements using the operation mentioned above.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex1.png\" style=\"width: 401px; height: 81px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,-1],[-1,1]]\n<strong>Output:</strong> 4\n<b>Explanation:</b> We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex2.png\" style=\"width: 321px; height: 121px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\n<strong>Output:</strong> 16\n<b>Explanation:</b> We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 250</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1417606,
                "title": "c-the-basic-idea-is-to-eliminate-negative-signs",
                "content": "Recognize that if there is an even amount of negative numbers, you can eliminate all the negatives signs in the following fashion:\\n* If there is a pair of adjacent negative numbers, just remove both negative signs\\n* If the remaining negative numbers are separated from each other, just **swap** their negative signs with the adjacent positive number until they are adjacent to each other, and then you can remove 2 negative signs at a time\\n\\nIf there is an odd amount of negative sign, there will be a negative sign in the end, and we can move that negative sign to the smallest number in the matrix (by *swapping* as above)\\n\\n**So, if the number of negative signs is even, the answer is the sum of the absolute value of all elements. If it is odd, we will have to minus 2 times the number with smallest absolute value (*for we have to change `+` sign to `-`*) to get the answer:**\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& a) {\\n        long long neg_cnt = 0, ans = 0, size = a.size(), minn = 1000000;\\n        for (int i = 0; i < size; ++i)\\n            for (int j = 0; j < size; ++j) {\\n                ans += abs(a[i][j]);\\n                if (a[i][j] < 0)\\n                    neg_cnt++;\\n                minn = minn < abs(a[i][j])? minn: abs(a[i][j]);\\n            }\\n        if (neg_cnt % 2 == 0)\\n            return ans;\\n        else \\n            return ans - 2*minn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& a) {\\n        long long neg_cnt = 0, ans = 0, size = a.size(), minn = 1000000;\\n        for (int i = 0; i < size; ++i)\\n            for (int j = 0; j < size; ++j) {\\n                ans += abs(a[i][j]);\\n                if (a[i][j] < 0)\\n                    neg_cnt++;\\n                minn = minn < abs(a[i][j])? minn: abs(a[i][j]);\\n            }\\n        if (neg_cnt % 2 == 0)\\n            return ans;\\n        else \\n            return ans - 2*minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417574,
                "title": "c-explained-with-diagram",
                "content": "### Logic \\n\\nIt is clearly mentioned that we can pick any two adjacent cells and mutliply them by -1. Also, this operation can be repeated any number of times.\\n\\n`You may notice that we can change the sign of any two elements just by selecting them and multiplying them by -1. `This means that the position of negative and positive numbers doesn\\'t matter because we can definitely reach every cell and perform the same operation. \\n\\n`Another observation is that for any number, if we do this operation even number of times, then the sign of the element doesn\\'t change. `\\n\\n![image](https://assets.leetcode.com/users/images/54792ad4-4553-4586-83eb-a25b0ed2374c_1629562215.8919232.png)\\n\\n<br>\\n\\nBingo !! We will make use of this logic and one by one, make the negative numbers positive as much as we can. \\n\\n`NOTICE : If there are odd number of positive numbers in the matrix, then no matter what move you chose, you will always end up having one negative number at the end in the complete matrix because at any moment, we will be having odd number of negatives.  `\\n\\n![image](https://assets.leetcode.com/users/images/90f3314d-293d-48bc-a0ac-27ee387a6beb_1629562245.588995.png)\\n\\n<br>\\n\\n\\n\\n`We can make the smallest number is the matrix negative by performing this operation some x number of times and then we can get the result. `\\n\\n\\n### Approach \\n\\n1. Find the absolute sum of all the numbers in the matrix\\n2. Find the absolute value of the smallest number in the matrix\\n3. Count of negative numbers in the matrix\\n\\n- `If count of negatives is even`, then all elements can be made positive by performing the operation, so just return the total sum of the matrix\\n- `If count of negatives is odd`, then we can make the smallest number in the matrix as negative and then return the `sum` \\n\\t- NOTE : Here the result will be `sum-2*minElement` as you are not including this element. \\n\\n<br>\\n\\n##### Please upvote if you like the explanation and the approach\\n\\n<br>\\n\\n\\n### Accepted Solution\\n\\n```\\n/**\\n * @author      : archit\\n * @GitHub      : archit-1997\\n * @Email       : architsingh456@gmail.com\\n * @file        : maximumMatrixSum.cpp\\n * @created     : Saturday Aug 21, 2021 20:11:56 IST\\n */\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int r=matrix.size(),c=matrix[0].size();\\n\\n        //we need to find the min number in the matrix and also count of negative numbers in the matrix\\n        int small=INT_MAX,count=0;\\n        long long int sum=0;\\n\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                int val=matrix[i][j];\\n\\t\\t\\t\\t//finding the smallest absolute value in the matrix\\n                small=min(small,abs(val));\\n\\t\\t\\t\\t//counting the negative numbers\\n                if(val<0)\\n                    count++;\\n\\t\\t\\t\\t//finding the sum of all the values\\n                sum+=abs(val);\\n            }\\n        }\\n\\t\\t//if even number of negatives, then just return sum\\n        if(count%2==0)\\n            return sum;\\n        else\\n\\t\\t//subtract the value of the min absolute element\\n            return sum-2*small;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @author      : archit\\n * @GitHub      : archit-1997\\n * @Email       : architsingh456@gmail.com\\n * @file        : maximumMatrixSum.cpp\\n * @created     : Saturday Aug 21, 2021 20:11:56 IST\\n */\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int r=matrix.size(),c=matrix[0].size();\\n\\n        //we need to find the min number in the matrix and also count of negative numbers in the matrix\\n        int small=INT_MAX,count=0;\\n        long long int sum=0;\\n\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                int val=matrix[i][j];\\n\\t\\t\\t\\t//finding the smallest absolute value in the matrix\\n                small=min(small,abs(val));\\n\\t\\t\\t\\t//counting the negative numbers\\n                if(val<0)\\n                    count++;\\n\\t\\t\\t\\t//finding the sum of all the values\\n                sum+=abs(val);\\n            }\\n        }\\n\\t\\t//if even number of negatives, then just return sum\\n        if(count%2==0)\\n            return sum;\\n        else\\n\\t\\t//subtract the value of the min absolute element\\n            return sum-2*small;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1420247,
                "title": "3-rules",
                "content": "1. If we have a zero anywhere we can use it to flip all negatives into positives.\\n2. If we have even number of negatives, we can turn all negatives into positives.\\n3. Otherwise, we turn the smallest absolute value into a negative, and everything else - into positives.\\n\\n**C++**\\n```cpp\\nlong long maxMatrixSum(vector<vector<int>>& m) {\\n    long long sum = 0, zeros = 0, negs = 0, min_abs = INT_MAX;\\n    for (int i = 0; i < m.size(); ++i)\\n        for (int j = 0; j < m[i].size(); ++j) {\\n            sum += abs(m[i][j]);\\n            zeros += m[i][j] == 0;\\n            negs += m[i][j] < 0;\\n            min_abs = min(min_abs, (long long)abs(m[i][j]));\\n        }\\n    return sum - (zeros || negs % 2 == 0 ? 0 : 2 * min_abs);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nlong long maxMatrixSum(vector<vector<int>>& m) {\\n    long long sum = 0, zeros = 0, negs = 0, min_abs = INT_MAX;\\n    for (int i = 0; i < m.size(); ++i)\\n        for (int j = 0; j < m[i].size(); ++j) {\\n            sum += abs(m[i][j]);\\n            zeros += m[i][j] == 0;\\n            negs += m[i][j] < 0;\\n            min_abs = min(min_abs, (long long)abs(m[i][j]));\\n        }\\n    return sum - (zeros || negs % 2 == 0 ? 0 : 2 * min_abs);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417725,
                "title": "java-python-3-odd-or-even-occurrences-of-negatives-w-brief-explanation-and-analysis",
                "content": "If there are even occurrences of negatives, we can always change them to positives; otherwise, we can change the number with minimum `abs` to negative, and others to positive.\\n\\n----\\n\\n**Q & A**\\n\\nQ: Why are we subtracting `2 * minVal` from the ans when there are odd number of negative elements?\\nA: Because the sum of absolute values, `absTotal` was already added to the final sum here: `absTotal += Math.abs(matrix[i][j]);` That\\'s why we have to subtract it twice.\\n\\n**End of Q & A**\\n\\n----\\n\\nThe followings are quoted from geeks4geeks:\\n\\nApproach: To maximize the sum of the given matrix, perform the given operations such that the smallest element in a row or column is negative (if it is not possible to make all row and column elements positive). Follow the steps below to maximize the sum: \\n\\n\\n1. Let the number of cells having negative values be x. If x is 0 i.e., there are no negative values, then the sum of the matrix is already maximum possible.\\n2. Otherwise, take any negative value from the matrix and perform the given operations on that element and any of its adjacent cells. This results in the chosen element becoming positive.\\n3. Now if the value of the chosen adjacent element is negative, then it will become positive or vice versa. This way, in each turn two negative values can be made positive. Now following two cases arise:\\n\\nIf x is even: In this case, after x/2 turns, all the negative values can be made positive. Therefore, the maximum sum possible is equal to the sum of the absolute values of all cells.\\n\\nIf x is odd: In this case, there will be one negative value left after performing operations in the manner described above. Now, to maximize the sum, the value getting subtracted or having a negative sign needs to be minimized. To do this, move the negative sign to the cell having minimum absolute value, say minVal. Therefore, the maximum sum possible is sum of the absolute values of all cells \\u2013 2*minVal.\\n\\n\\n```java\\n    public long maxMatrixSum(int[][] matrix) {\\n        long absTotal = 0, negative = 0, mi = Long.MAX_VALUE;\\n        for (int r = 0; r < matrix.length; ++r) {\\n            for (int c = 0; c < matrix.length; ++c) {\\n                if (matrix[r][c] < 0) {\\n                    ++negative;\\n                }\\n                absTotal += Math.abs(matrix[r][c]);\\n                mi = Math.min(mi, Math.abs(matrix[r][c]));\\n            }\\n        } \\n        return absTotal - (negative % 2 == 0 ? 0 : 2 * mi);\\n    }\\n```\\n```python\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        abs_total = neg = 0\\n        mi= math.inf\\n        for row in matrix:\\n            for num in row:\\n                abs_total += abs(num)\\n                if num < 0:\\n                    neg += 1\\n                mi = min(mi, abs(num))\\n        return abs_total if neg % 2 == 0 else abs_total - 2 * mi\\n```\\n**Analysis:**\\nTime: `O(n * n)`, space: `O(1)`, where `n = matrix.length`.\\n\\n```python\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        arr = [num for row in matrix for num in row]\\n        abs_total = sum(map(abs, arr))\\n        neg = sum([num  < 0 for num in arr])\\n        mi= min(map(abs, arr))\\n        return abs_total if neg % 2 == 0 else abs_total - 2 * mi\\n```\\n\\n**Analysis:**\\nTime & space: `O(n * n)`, where `n = matrix.length`.",
                "solutionTags": [],
                "code": "```java\\n    public long maxMatrixSum(int[][] matrix) {\\n        long absTotal = 0, negative = 0, mi = Long.MAX_VALUE;\\n        for (int r = 0; r < matrix.length; ++r) {\\n            for (int c = 0; c < matrix.length; ++c) {\\n                if (matrix[r][c] < 0) {\\n                    ++negative;\\n                }\\n                absTotal += Math.abs(matrix[r][c]);\\n                mi = Math.min(mi, Math.abs(matrix[r][c]));\\n            }\\n        } \\n        return absTotal - (negative % 2 == 0 ? 0 : 2 * mi);\\n    }\\n```\n```python\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        abs_total = neg = 0\\n        mi= math.inf\\n        for row in matrix:\\n            for num in row:\\n                abs_total += abs(num)\\n                if num < 0:\\n                    neg += 1\\n                mi = min(mi, abs(num))\\n        return abs_total if neg % 2 == 0 else abs_total - 2 * mi\\n```\n```python\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        arr = [num for row in matrix for num in row]\\n        abs_total = sum(map(abs, arr))\\n        neg = sum([num  < 0 for num in arr])\\n        mi= min(map(abs, arr))\\n        return abs_total if neg % 2 == 0 else abs_total - 2 * mi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1417742,
                "title": "c-easy-to-understand-commented-approach",
                "content": "```\\n/*\\n\\tIf number of -ve numbers are even, it means you can ALWAYS shift -1 in a\\n\\tfashion that you can cancel out the negative signs and make the numbers positive.\\n\\tSo in that case, total sum (absolute value of all elements) will be your answer\\n\\t\\n\\tIf number of -ve numbers are odd, then you can cancel out the negative sign \\n\\tof large numbers so that they contribute to our over all sum.\\n\\tAnd notice that at the end, you will be left with one negative number.\\n\\tSo, shift this negative sign to the smallest number\\n*/\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        long long sum = 0;\\n        int negCount = 0;\\n        int smallestMin = INT_MAX;\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                sum += abs(matrix[i][j]); //Add all the numbers\\n                \\n                if(matrix[i][j] < 0)\\n                    negCount++; //keep track of count of -ve numbers\\n                \\n\\t\\t\\t\\t//keep track of the smallest number which can be negative\\n                smallestMin = min(smallestMin, abs(matrix[i][j]));\\n            }\\n        }\\n        \\n        return negCount%2 == 0 ? sum : sum-2*smallestMin;\\n\\t\\t/*\\t\\t\\n\\t\\t\\tWhy (sum-2*smallestMin) ????\\n\\t\\t\\t\\tIn simple words : You had first added that number, \\n\\t\\t\\t\\tso you need to subtract that addition and also in the\\n\\t\\t\\t\\tend, you need to reduce the sum with that number.\\n\\t\\t\\t\\tThat\\'s why we have to substract 2 times.\\n\\t\\t\\t\\tSee with the example below :\\n\\t\\t\\t\\t[1,   2, 3]\\n\\t\\t\\t\\t[-1, -2,-3]\\n\\t\\t\\t\\t[1,   2, 3]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\tOver all Sum \"S\"(all elements with abs value) = 18\\n\\t\\t\\t\\tNegative count = 3 which is odd\\n\\t\\t\\t\\tSmallest number which can be negative is \"Min\"= 1\\n\\n\\t\\t\\t\\tso, \\n\\t\\t\\t\\t[1,   2, 3]\\n\\t\\t\\t\\t[-1,  2, 3]\\n\\t\\t\\t\\t[1,   2, 3]\\n\\n\\t\\t\\t\\tNow, final sum \"F\" = 1 + 2 + 3 + (-1) + 2 + 3 + 1 + 2 + 3 = 16\\n\\n\\t\\t\\t\\tSo, final result \"F\" = \"S\" - 2*Min  (i.e. 18 - 2*1) = 16\\n\\t\\t*/\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tIf number of -ve numbers are even, it means you can ALWAYS shift -1 in a\\n\\tfashion that you can cancel out the negative signs and make the numbers positive.\\n\\tSo in that case, total sum (absolute value of all elements) will be your answer\\n\\t\\n\\tIf number of -ve numbers are odd, then you can cancel out the negative sign \\n\\tof large numbers so that they contribute to our over all sum.\\n\\tAnd notice that at the end, you will be left with one negative number.\\n\\tSo, shift this negative sign to the smallest number\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        long long sum = 0;\\n        int negCount = 0;\\n        int smallestMin = INT_MAX;\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                sum += abs(matrix[i][j]); //Add all the numbers\\n                \\n                if(matrix[i][j] < 0)\\n                    negCount++; //keep track of count of -ve numbers\\n                \\n\\t\\t\\t\\t//keep track of the smallest number which can be negative\\n                smallestMin = min(smallestMin, abs(matrix[i][j]));\\n            }\\n        }\\n        \\n        return negCount%2 == 0 ? sum : sum-2*smallestMin;\\n\\t\\t/*\\t\\t\\n\\t\\t\\tWhy (sum-2*smallestMin) ????\\n\\t\\t\\t\\tIn simple words : You had first added that number, \\n\\t\\t\\t\\tso you need to subtract that addition and also in the\\n\\t\\t\\t\\tend, you need to reduce the sum with that number.\\n\\t\\t\\t\\tThat\\'s why we have to substract 2 times.\\n\\t\\t\\t\\tSee with the example below :\\n\\t\\t\\t\\t[1,   2, 3]\\n\\t\\t\\t\\t[-1, -2,-3]\\n\\t\\t\\t\\t[1,   2, 3]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\tOver all Sum \"S\"(all elements with abs value) = 18\\n\\t\\t\\t\\tNegative count = 3 which is odd\\n\\t\\t\\t\\tSmallest number which can be negative is \"Min\"= 1\\n\\n\\t\\t\\t\\tso, \\n\\t\\t\\t\\t[1,   2, 3]\\n\\t\\t\\t\\t[-1,  2, 3]\\n\\t\\t\\t\\t[1,   2, 3]\\n\\n\\t\\t\\t\\tNow, final sum \"F\" = 1 + 2 + 3 + (-1) + 2 + 3 + 1 + 2 + 3 = 16\\n\\n\\t\\t\\t\\tSo, final result \"F\" = \"S\" - 2*Min  (i.e. 18 - 2*1) = 16\\n\\t\\t*/\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417592,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        ans = mult = 0\\n        val = inf \\n        for i in range(len(matrix)): \\n            for j in range(len(matrix)):\\n                ans += abs(matrix[i][j])\\n                val = min(val, abs(matrix[i][j]))\\n                if matrix[i][j] < 0: mult ^= 1\\n        return ans - 2*mult*val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        ans = mult = 0\\n        val = inf \\n        for i in range(len(matrix)): \\n            for j in range(len(matrix)):\\n                ans += abs(matrix[i][j])\\n                val = min(val, abs(matrix[i][j]))\\n                if matrix[i][j] < 0: mult ^= 1\\n        return ans - 2*mult*val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419035,
                "title": "java-explanation-simple-easy-and-concise-solution-faster-than-100-5ms",
                "content": "The main important point is that:\\nIf the numbers with negative sign are even, than all can be converted to postitive numbers.\\nIf the numbers with negative sign are odd, than one will be left negative and others can be converted to positive.\\nAlso, in case of odd no. of negative numbers, we can make all numbers positive and make smallest number negative, in order to maximise the sum.\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long ans = 0;\\n        int neg = 0;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] < 0) {\\n                    neg++;\\n                }\\n                ans += Math.abs(matrix[i][j]);\\n                if(min > Math.abs(matrix[i][j]))\\n                \\tmin = Math.abs(matrix[i][j]);\\n            }\\n        }\\n        if(neg % 2 == 0)\\n        \\treturn ans;\\n        else\\n        \\treturn ans - 2*min;\\n    }\\n}\\n```\\nPlease upvote, if you Like and Understand the approach.",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long ans = 0;\\n        int neg = 0;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] < 0) {\\n                    neg++;\\n                }\\n                ans += Math.abs(matrix[i][j]);\\n                if(min > Math.abs(matrix[i][j]))\\n                \\tmin = Math.abs(matrix[i][j]);\\n            }\\n        }\\n        if(neg % 2 == 0)\\n        \\treturn ans;\\n        else\\n        \\treturn ans - 2*min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417579,
                "title": "java-simple",
                "content": "If the matrix contains even number of negative numbers, return sum (of abs values)\\nelse return sum(of abs values) - min of abs values * 2\\n\\n```\\npublic long maxMatrixSum(int[][] matrix) {\\n\\tlong sum = 0, count = 0, min = Integer.MAX_VALUE;\\n\\tfor(int i=0;i<matrix.length;i++)\\n\\t\\tfor(int j=0;j<matrix[0].length;j++) {\\n\\t\\t\\tif(matrix[i][j] < 0) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tmatrix[i][j] *= -1;\\n\\t\\t\\t}\\n\\t\\t\\tmin = Math.min(min, matrix[i][j]);\\n\\t\\t\\tsum += matrix[i][j];\\n\\t\\t}\\n\\treturn count%2!=0 ? sum-min*2 : sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long maxMatrixSum(int[][] matrix) {\\n\\tlong sum = 0, count = 0, min = Integer.MAX_VALUE;\\n\\tfor(int i=0;i<matrix.length;i++)\\n\\t\\tfor(int j=0;j<matrix[0].length;j++) {\\n\\t\\t\\tif(matrix[i][j] < 0) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tmatrix[i][j] *= -1;\\n\\t\\t\\t}\\n\\t\\t\\tmin = Math.min(min, matrix[i][j]);\\n\\t\\t\\tsum += matrix[i][j];\\n\\t\\t}\\n\\treturn count%2!=0 ? sum-min*2 : sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417643,
                "title": "python-simplest-with-explaination",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        \\n        num = [j for i in matrix for j in i] #make all as plain list\\n        negative = (sum(1 for i in num if i<0))%2 #see the number of negative is odd or even\\n        num = [abs(i) for i in num] #turn all to positive\\n        \\n        if negative: #if odd, only 1 will become negative\\n            min_ = min(num) #get the minimum \\n            return sum(num) - min_*2 #substract it from the sum\\n        else:\\n            return sum(num) #return sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        \\n        num = [j for i in matrix for j in i] #make all as plain list\\n        negative = (sum(1 for i in num if i<0))%2 #see the number of negative is odd or even\\n        num = [abs(i) for i in num] #turn all to positive\\n        \\n        if negative: #if odd, only 1 will become negative\\n            min_ = min(num) #get the minimum \\n            return sum(num) - min_*2 #substract it from the sum\\n        else:\\n            return sum(num) #return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426275,
                "title": "c-single-pass-solution-explained-100-time-96-space",
                "content": "Cute one that really rewards quick thinking over rote memorisation of algos and other tricks.\\n\\nGiven the constraints, it is pretty clear that we canNOT even begin to attempt computing all the permutations of how we might flip pairs of cells. But the point is that we really should not care!\\n\\nDon\\'t believe me? Bear with me as I explain my thought process!\\n\\nLet\\'s start with a simple consideration: if all numbers were non-negative, we might get away with it just summing each cell - that I guess is pretty clear and it also gives us a lower bound: we can\\'t do less than linear time here!\\n\\nNow, what happens if we have negative numbers?\\n\\nSince there is no limit to how many times we can flip cell, we can demonstrate that given an arbirtrarily large matrix `m`, we can always end up flipping cells in pairs so that we can would end up with `1` negative cell (if the initial amount of negative cells was odd) or `0` (if the initial amount of them was even) - try to think about it by induction.\\n\\nAnd, in the former case, what element should we keep negative? But of course the one with the lesser absolute value!\\n\\nNow, having cells with value of `0` would seem to complicate things a bit, but not even that much: after all, if we have even just one `0`, we know that we can just keep summing without a care, since we can just finish having a `0` cell flipped to `0` with no change whatsoever :)\\n\\nOkay, enough description - time to code and as usual we will start with declaring our support variables:\\n* `res` will be our accumulator variable, storing our ongoing sum of cells, preset to `0`;\\n* `flippables` will keep track of all the non-positive numbers (yes, `0`s and negatives will be bucketed together here), initially set to `0`;\\n* `smallest` will keep track of the smallest element (in absolute value) we have seen so far, initially set to `INT_MIN`.\\n\\nWe will then loop through each `row` of `matrix` (taken as a reference, of course) and through each value `n` of `row` and deal with 2 base cases:\\n* if `n <= 0`, we will:\\n\\t* increase `flippables` by `1`;\\n\\t* update `smallest` to be the minimum absolute value between its current one and `n` (and since we know both are always going to be non positive numbers, we can do so by merely using `max`, with no need of swapping signs);\\n\\t* increase `res` by `-n` (ie: adding its absolute value);\\n* otherwise, we will:\\n\\t* increase `res` by `n`;\\n\\t* update `smallest` by the maximum between its current value and `-n` - because, yes, we might wish to flip even an initially positive number, if its absolute value is lesser than any other negative number encountered so far.\\n\\nOnce done, we can just `return` `res` plus `smallest` if `flippables` was odd or plus `0` otherwise :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        // support variables\\n        long long res = 0;\\n        int flippables = 0, smallest = INT_MIN;\\n        // parsing matrix\\n        for (auto &row: matrix) {\\n            for (int n: row) {\\n                // flippable cells (non positive)\\n                if (n <= 0) {\\n                    flippables++;\\n                    smallest = max(smallest, n);\\n                    res -= n;\\n                }\\n                // non flipppable cells (positive)\\n                else {\\n                    res += n;\\n                    smallest = max(smallest, -n);\\n                }\\n            }\\n        }\\n        return res + (flippables & 1 ? smallest * 2 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        // support variables\\n        long long res = 0;\\n        int flippables = 0, smallest = INT_MIN;\\n        // parsing matrix\\n        for (auto &row: matrix) {\\n            for (int n: row) {\\n                // flippable cells (non positive)\\n                if (n <= 0) {\\n                    flippables++;\\n                    smallest = max(smallest, n);\\n                    res -= n;\\n                }\\n                // non flipppable cells (positive)\\n                else {\\n                    res += n;\\n                    smallest = max(smallest, -n);\\n                }\\n            }\\n        }\\n        return res + (flippables & 1 ? smallest * 2 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418386,
                "title": "c-simple-short-and-easy-solution-with-explanation",
                "content": "**Idea:**\\nIf we have an even amount of negative numbers, we can always swap two adjacent elements two make two negative numbers adjacent and make both positive. So in such a case our result will be the sum of all absolute values of the matrix.\\nIf the amount of negative values is odd, then we can do the same until we are left with one negative number and also make that last number be the minimum. So our result is the sum of all absolute values of the matrix minus the minimum absolute value * 2. (To make it negative, we have to subtract one time to make 0 and another to make minus).\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long count = 0, mini = INT_MAX, sum_abs = 0;\\n        for (int i = 0; i < matrix.size(); i++) {\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                if (matrix[i][j] < 0) {\\n                    count++;\\n                }\\n                mini = min(mini, (long long)abs(matrix[i][j]));\\n                sum_abs += abs(matrix[i][j]);\\n            }\\n        }\\n        sum_abs -= count % 2 ? 2 * mini : 0;\\n        return sum_abs;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long count = 0, mini = INT_MAX, sum_abs = 0;\\n        for (int i = 0; i < matrix.size(); i++) {\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                if (matrix[i][j] < 0) {\\n                    count++;\\n                }\\n                mini = min(mini, (long long)abs(matrix[i][j]));\\n                sum_abs += abs(matrix[i][j]);\\n            }\\n        }\\n        sum_abs -= count % 2 ? 2 * mini : 0;\\n        return sum_abs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064329,
                "title": "easiest-soln-adobe",
                "content": "**#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 3 : Adobe\\nQ10. Max matrix Sum**\\n\\n# Complexity\\n- Time complexity:  O(n*m), where n and m are the number of rows and columns in the matrix respectively.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //function to calculate the maximum matrix sum\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n    long long int totalSum = 0; // variable to store the total sum of the matrix\\n    bool zeroExists = false; // variable to check if there is any 0 in the matrix\\n    int negativeCount = 0; // variable to store the count of negative numbers in the matrix\\n    int minimumAbsoluteValue = INT_MAX; // variable to store the minimum absolute value of the matrix\\n        //iterating through the matrix\\n    for(auto it: matrix)\\n    {\\n        for(auto i: it)\\n        {\\n            if(i==0)\\n                zeroExists = true; // setting the zeroExists variable to true if there is 0 in the matrix\\n            if(i<0)\\n                negativeCount++; // incrementing the negativeCount variable if the current number is negative\\n            totalSum += abs(i); // adding the absolute value of the current number to the totalSum\\n            if(abs(i)<minimumAbsoluteValue)\\n                minimumAbsoluteValue = abs(i); // updating the minimumAbsoluteValue variable if the current absolute value is less than the current value\\n        }\\n    }\\n    //if there is zero or even number of negative numbers\\n    if(zeroExists || negativeCount%2==0)\\n        return totalSum;\\n    return totalSum-2*minimumAbsoluteValue; // returning the totalSum - 2* minimumAbsoluteValue\\n}\\n};\\n\\n```\\n![upvotee.jpg](https://assets.leetcode.com/users/images/9acdd574-622b-4fbf-814a-2eea1920d178_1674020092.05819.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function to calculate the maximum matrix sum\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n    long long int totalSum = 0; // variable to store the total sum of the matrix\\n    bool zeroExists = false; // variable to check if there is any 0 in the matrix\\n    int negativeCount = 0; // variable to store the count of negative numbers in the matrix\\n    int minimumAbsoluteValue = INT_MAX; // variable to store the minimum absolute value of the matrix\\n        //iterating through the matrix\\n    for(auto it: matrix)\\n    {\\n        for(auto i: it)\\n        {\\n            if(i==0)\\n                zeroExists = true; // setting the zeroExists variable to true if there is 0 in the matrix\\n            if(i<0)\\n                negativeCount++; // incrementing the negativeCount variable if the current number is negative\\n            totalSum += abs(i); // adding the absolute value of the current number to the totalSum\\n            if(abs(i)<minimumAbsoluteValue)\\n                minimumAbsoluteValue = abs(i); // updating the minimumAbsoluteValue variable if the current absolute value is less than the current value\\n        }\\n    }\\n    //if there is zero or even number of negative numbers\\n    if(zeroExists || negativeCount%2==0)\\n        return totalSum;\\n    return totalSum-2*minimumAbsoluteValue; // returning the totalSum - 2* minimumAbsoluteValue\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417653,
                "title": "java-solutions-easy-approach",
                "content": "**Idea**\\nIf their are even negatives then go return **the absolute sum** \\nelse return **the absolute sum- smallest absolute positve integer twice!**\\n```\\nIn JAVA\\n\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        \\n    \\tint i,j,n=matrix.length,neg_nums=0,m=matrix[0].length,min=Integer.MAX_VALUE;\\n    \\tlong ans=0;\\n    \\tfor(i=0;i<n;i++)\\n    \\t\\tfor(j=0;j<m;j++) {\\n    \\t\\t\\tif(matrix[i][j]<0)\\n    \\t\\t\\t\\tneg_nums++;\\n    \\t\\t\\tmin=Math.min(min, Math.abs(matrix[i][j]));\\n    \\t\\t\\tans+=Math.abs(matrix[i][j]);\\n    \\t\\t}\\n    \\tif(neg_nums%2==0)\\n    \\t\\treturn ans;\\n    \\treturn ans-min-min;\\n    \\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nIn JAVA\\n\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        \\n    \\tint i,j,n=matrix.length,neg_nums=0,m=matrix[0].length,min=Integer.MAX_VALUE;\\n    \\tlong ans=0;\\n    \\tfor(i=0;i<n;i++)\\n    \\t\\tfor(j=0;j<m;j++) {\\n    \\t\\t\\tif(matrix[i][j]<0)\\n    \\t\\t\\t\\tneg_nums++;\\n    \\t\\t\\tmin=Math.min(min, Math.abs(matrix[i][j]));\\n    \\t\\t\\tans+=Math.abs(matrix[i][j]);\\n    \\t\\t}\\n    \\tif(neg_nums%2==0)\\n    \\t\\treturn ans;\\n    \\treturn ans-min-min;\\n    \\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016746,
                "title": "simple-maths-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long int sum=0;\\n        bool zero=false;\\n        int neg=0,  mn=INT_MAX;\\n        for(auto it: matrix)\\n        {\\n            for(auto i: it)\\n            {\\n                if(i==0)\\n                    zero=true;\\n                if(i<0)\\n                    neg++;\\n                sum+=abs(i);\\n                if(abs(i)<mn)\\n                    mn=abs(i);\\n            }\\n        }\\n        if(zero || neg%2==0)\\n            return sum;\\n        return sum-2*mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long int sum=0;\\n        bool zero=false;\\n        int neg=0,  mn=INT_MAX;\\n        for(auto it: matrix)\\n        {\\n            for(auto i: it)\\n            {\\n                if(i==0)\\n                    zero=true;\\n                if(i<0)\\n                    neg++;\\n                sum+=abs(i);\\n                if(abs(i)<mn)\\n                    mn=abs(i);\\n            }\\n        }\\n        if(zero || neg%2==0)\\n            return sum;\\n        return sum-2*mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937919,
                "title": "c-o-n-track-sum-min-negs",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n\\t\\t//each pair of negative signs can be cancelled\\n\\t\\t//if there is one negative sign left over, move it to the smallest value\\n\\t\\t//delete this value from the sum of absolute values twice - once to cancel the previously-added\\n\\t\\t//abs value of that number, and once to account for the negative contribution\\n        int negs = 0;\\n        long long min_val = INT_MAX;\\n        long long sum = 0;\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                sum += abs(matrix[i][j]);\\n                if(matrix[i][j] < 0) negs++;\\n                if(abs(matrix[i][j]) < min_val) min_val = abs(matrix[i][j]);\\n            }\\n        }\\n        if(negs % 2 == 0) return sum;\\n        else return sum - min_val*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n\\t\\t//each pair of negative signs can be cancelled\\n\\t\\t//if there is one negative sign left over, move it to the smallest value\\n\\t\\t//delete this value from the sum of absolute values twice - once to cancel the previously-added\\n\\t\\t//abs value of that number, and once to account for the negative contribution\\n        int negs = 0;\\n        long long min_val = INT_MAX;\\n        long long sum = 0;\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                sum += abs(matrix[i][j]);\\n                if(matrix[i][j] < 0) negs++;\\n                if(abs(matrix[i][j]) < min_val) min_val = abs(matrix[i][j]);\\n            }\\n        }\\n        if(negs % 2 == 0) return sum;\\n        else return sum - min_val*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463526,
                "title": "python-simple-line-of-thought-faster-than-99",
                "content": "Ok, so let\\'s start with the requirements. There\\'s a matrix with some positive and negative values. Let\\'s forget about the actual values for now, and only consider the sign. Since we want to obtain the maximum sum of the whole matrix, when we take a pair of adjacent values there can only be three cases: \\n- Both are negative: In this case we simply flip both values, and we are done\\n- One is positive and one is negative: This is the most interesting! The element that was negative now will be positive, while the element that was positive will now be negative. This is equivalent to moving the negative sign from one cell to another which is adjacent.\\n- Both are positive: No need to flip anything.\\n\\nThinking about the second case led me in 15m to the solution. Let\\'s say I\\'have found a negative cell X, now I could scan the whole matrix, find another lonely negative cell Y, and using the second case, move the negative from X to a cell adjacent Y and then flip both values using the third case. \\n\\nAfter this, I realized that there was a catch when the number of negative values was odd, and here the actual values do matter. After doing all the steps, I would still be stuck with a negative cell [since I can move a negative to anywhere in the matrix, but i still need to have two adjacent negatives to make them both positive], but since I could move it around using case 2, I could make sure that the value most close to 0 (ideally 0 itself) would be the only negative.\\n\\nWhat I did was have the absolute sum of all the values, how many values where negative and the closest value to 0 (minAbsValue). If the number of negative values is odd, I need to remove `minAbsValue` two times, since the first one was a \\'miscalculation\\' (I considered it to be positive, while in fact was negative) and the second one was simply subtracting the correct value\\n\\n\\n\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        negCount = 0\\n        absTotal = 0\\n        minAbsValue = float(\\'inf\\')\\n        \\n        for row in matrix:\\n            for val in row:\\n                av = abs(val)\\n                if av < minAbsValue:\\n                    minAbsValue = av\\n                \\n                absTotal += av\\n                if val < 0:\\n                    negCount += 1\\n        \\n        if negCount % 2 == 0:\\n            return absTotal\\n        else:\\n            return absTotal - minAbsValue - minAbsValue\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        negCount = 0\\n        absTotal = 0\\n        minAbsValue = float(\\'inf\\')\\n        \\n        for row in matrix:\\n            for val in row:\\n                av = abs(val)\\n                if av < minAbsValue:\\n                    minAbsValue = av\\n                \\n                absTotal += av\\n                if val < 0:\\n                    negCount += 1\\n        \\n        if negCount % 2 == 0:\\n            return absTotal\\n        else:\\n            return absTotal - minAbsValue - minAbsValue\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461891,
                "title": "greedy-java-solution-with-detailed-explanation",
                "content": "Analyze:\\n1. The operation can move all negative cells together.\\n2. At most 1 negative cell can left while put all negative numbers together.\\n3. The last negative cell can move the the global smallest cell.\\n4. If the min cell value is 0, then the last negative cell will be turn to positive.\\n\\nSolution:\\n1. sum absolute value of entire matrix\\n2. tracking the number of negative cells is even or not\\n3. get global min vlaue of the matrix.\\n\\nIf even negatives, return sum of absolute values;\\nelse return (sum - 2 * min).\\n\\nSince sum already includes min, so we need to exclude the min cell first (sum - min), then reduce it again [(sum - min) - min].\\n\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        boolean even = true;  //track the number of negative cells is even or not\\n        int min = Integer.MAX_VALUE; //global absolute min value\\n        long sum = 0;\\n        \\n        for (int[] row : matrix) {\\n            for (int x : row) {\\n                if (x < 0) {\\n                    even = !even;\\n                    x = -x;\\n                }\\n                min = Math.min(min, x);\\n                sum += x;\\n            }\\n        }\\n        return even ? sum : sum - 2 * min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        boolean even = true;  //track the number of negative cells is even or not\\n        int min = Integer.MAX_VALUE; //global absolute min value\\n        long sum = 0;\\n        \\n        for (int[] row : matrix) {\\n            for (int x : row) {\\n                if (x < 0) {\\n                    even = !even;\\n                    x = -x;\\n                }\\n                min = Math.min(min, x);\\n                sum += x;\\n            }\\n        }\\n        return even ? sum : sum - 2 * min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422593,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int count=0;\\n        int min=1000000;\\n        long sum=0;\\n        int l=0;\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                sum=sum+Math.abs(matrix[i][j]);\\n                int p=Math.abs(matrix[i][j]);\\n                    if(p<min)\\n                    {\\n                        min=p;\\n                    }\\n                if(matrix[i][j]<0)\\n                {\\n                    count++;\\n                    \\n                    if((i+1)<matrix.length)\\n                    {\\n                        if(matrix[i+1][j]==0)\\n                        {\\n                            l++;\\n                        }\\n                    }\\n                     if(j+1<matrix[i].length)\\n                        {\\n                            if(matrix[i][j+1]==0)\\n                            {\\n                                l++;\\n                            }\\n                        }\\n                   if(j-1>=0)\\n                    {\\n                        if(matrix[i][j-1]==0)\\n                            {\\n                                l++;\\n                            }\\n                    }\\n                    if(i-1>=0)\\n                    {\\n                        if(matrix[i-1][j]==0)\\n                            {\\n                                l++;\\n                            }\\n                    }\\n                }\\n            }\\n        }\\n        if(count%2!=0)\\n        {\\n            if(l==0)\\n            {              \\n              sum=sum-(2*min);\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int count=0;\\n        int min=1000000;\\n        long sum=0;\\n        int l=0;\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                sum=sum+Math.abs(matrix[i][j]);\\n                int p=Math.abs(matrix[i][j]);\\n                    if(p<min)\\n                    {\\n                        min=p;\\n                    }\\n                if(matrix[i][j]<0)\\n                {\\n                    count++;\\n                    \\n                    if((i+1)<matrix.length)\\n                    {\\n                        if(matrix[i+1][j]==0)\\n                        {\\n                            l++;\\n                        }\\n                    }\\n                     if(j+1<matrix[i].length)\\n                        {\\n                            if(matrix[i][j+1]==0)\\n                            {\\n                                l++;\\n                            }\\n                        }\\n                   if(j-1>=0)\\n                    {\\n                        if(matrix[i][j-1]==0)\\n                            {\\n                                l++;\\n                            }\\n                    }\\n                    if(i-1>=0)\\n                    {\\n                        if(matrix[i-1][j]==0)\\n                            {\\n                                l++;\\n                            }\\n                    }\\n                }\\n            }\\n        }\\n        if(count%2!=0)\\n        {\\n            if(l==0)\\n            {              \\n              sum=sum-(2*min);\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419824,
                "title": "c-iteration-and-count-with-explantaion",
                "content": "We need to just count the number of negative numbers in the given matrix, if it is even than all negative numbers can be made positive so the sum will be sum of absolute value of all elements.\\n\\nIf the count of negative numbers is odd then we\\'ll have 1 negative number so add sum of absolute value of all numbers and then subtract 2*minelement  this is because we included it once in the absolute sum,\\nso first we need to undo the addition of the absolute value\\nthen we need to add the negative.\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& A) {\\n      long long sum = 0;\\n\\tlong long negative = 0;\\n       long long N= A.size();\\n\\n\\tlong long minVal = INT_MAX;\\n\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tsum += abs(A[i][j]);\\n\\t\\t\\t\\n\\t\\t\\tif (A[i][j] < 0) \\n\\t\\t\\t\\tnegative++;\\n\\t\\t\\t\\n            if(minVal>abs(A[i][j]))\\n                minVal=abs(A[i][j]);\\n\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif (negative % 2) \\n\\t\\tsum -= 2 * minVal;\\n\\t\\n\\treturn sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& A) {\\n      long long sum = 0;\\n\\tlong long negative = 0;\\n       long long N= A.size();\\n\\n\\tlong long minVal = INT_MAX;\\n\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\tsum += abs(A[i][j]);\\n\\t\\t\\t\\n\\t\\t\\tif (A[i][j] < 0) \\n\\t\\t\\t\\tnegative++;\\n\\t\\t\\t\\n            if(minVal>abs(A[i][j]))\\n                minVal=abs(A[i][j]);\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1417593,
                "title": "java-accepted-solution-clear-explanation-one-traversal",
                "content": "IDEA : Given that any two numbers can be multiplied with -1 for any number of times, even if the negative numbers are not adjacent we can bring negatives to adjacent by multiplying there entire path of 2-2 elements with -1,  if there are even number of negative numbers we can multiply them with -1 and make them even,if there are odd number of negative values(2*n+1) we can make 2*n elements to positive and remain with 1 element. \\n\\nNow problem comes down to 1 element, we will have to look out for element which has a smaller value and shift our minus sign to that element.\\n\\nAt the end, we remove that minimum number from total sum\\n\\nNOTE : if matrix contains atleast one zero, then we can make every element positive(by dragging neg sign towards zero and multiplying it with -1)\\n\\n```\\npublic long maxMatrixSum(int[][] matrix) {\\n        int count =0;    \\t\\t//To store number of negative values\\n        long sum =0;     \\t\\t//To store sum of all elements of matrix\\n        boolean haszero = false;\\t//Boolean value to check if mat has a zero\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]<0){\\n                    count++;\\n                }\\n                if(matrix[i][j]==0) haszero = true;\\n                sum+=Math.abs(matrix[i][j]);\\t\\t//Adding absolute value, because we are going to remove neg signs to maximize sum\\n                min = Math.min(min,Math.abs(matrix[i][j]));\\t//keeping track of min element, for case where we will have odd number of neg signs\\n            }\\n        }\\n        if(count%2==0 || haszero){\\t\\t\\t//If there are even number of neg values or matrix has a zero then we can change \\n            return sum;\\t\\t\\t\\t//every element to postive\\n        }\\n        return sum-2*min;\\t\\t\\t//Else removing our minimum number from total sum and also subracting that value\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long maxMatrixSum(int[][] matrix) {\\n        int count =0;    \\t\\t//To store number of negative values\\n        long sum =0;     \\t\\t//To store sum of all elements of matrix\\n        boolean haszero = false;\\t//Boolean value to check if mat has a zero\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]<0){\\n                    count++;\\n                }\\n                if(matrix[i][j]==0) haszero = true;\\n                sum+=Math.abs(matrix[i][j]);\\t\\t//Adding absolute value, because we are going to remove neg signs to maximize sum\\n                min = Math.min(min,Math.abs(matrix[i][j]));\\t//keeping track of min element, for case where we will have odd number of neg signs\\n            }\\n        }\\n        if(count%2==0 || haszero){\\t\\t\\t//If there are even number of neg values or matrix has a zero then we can change \\n            return sum;\\t\\t\\t\\t//every element to postive\\n        }\\n        return sum-2*min;\\t\\t\\t//Else removing our minimum number from total sum and also subracting that value\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775445,
                "title": "python-5loc-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nif there are even numbers of neg, then we can just filp them all.\\n\\nif there are odd numbers of neg, then we can just filp them remaining only one.\\n\\n**comes the point:**\\n\\nIf it\\'s the abs smallest val, leave it be.\\n\\nElse, we can always exchange it with smaller positive number.\\n\\nfor example: now there are -4,1\\n\\nchange to 4,-1 to get larger sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nif even neg: done\\n\\nif odd neg: sum up, then subtract the min * 2\\n\\n4 - 1 = 4 + 1 - (-1)*2\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$O(n^2)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$O(1)$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        neg = sum(1 for x in matrix for x in x if x < 0)\\n        if neg % 2 == 0:\\n            return sum(abs(x) for x in matrix for x in x)\\n        else:\\n            return sum(abs(x) for x in matrix for x in x) - 2 * abs(min((x for x in matrix for x in x),key=abs))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        neg = sum(1 for x in matrix for x in x if x < 0)\\n        if neg % 2 == 0:\\n            return sum(abs(x) for x in matrix for x in x)\\n        else:\\n            return sum(abs(x) for x in matrix for x in x) - 2 * abs(min((x for x in matrix for x in x),key=abs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494166,
                "title": "simple-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int neg=0;\\n        long long sum=0;\\n        int mini=INT_MAX;\\n        for (int i=0; i<matrix.size(); i++)\\n        {\\n            for (int j=0; j<matrix[0].size(); j++)\\n            {\\n                if (matrix[i][j]<0)\\n                {\\n                    neg+=1;\\n                }\\n                sum+= abs(matrix[i][j]);\\n                if (abs(matrix[i][j]) <mini)\\n                {\\n                    mini= abs(matrix[i][j]);\\n                }\\n            }\\n        }\\n        return(neg%2)?sum-(2*mini):sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int neg=0;\\n        long long sum=0;\\n        int mini=INT_MAX;\\n        for (int i=0; i<matrix.size(); i++)\\n        {\\n            for (int j=0; j<matrix[0].size(); j++)\\n            {\\n                if (matrix[i][j]<0)\\n                {\\n                    neg+=1;\\n                }\\n                sum+= abs(matrix[i][j]);\\n                if (abs(matrix[i][j]) <mini)\\n                {\\n                    mini= abs(matrix[i][j]);\\n                }\\n            }\\n        }\\n        return(neg%2)?sum-(2*mini):sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090075,
                "title": "java-one-pass-greedy-approach-explained-completely",
                "content": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        // Java greedy approach\\n        long sum =0;\\n        int count =0;\\n        long min = Integer.MAX_VALUE;\\n        // we find the positive sum of all the values, \\n        // if count of negative elements is odd then one element negative will be left after using the given operation\\n        // if count of negative elements is even then no element negative will be left after using the given operation\\n        for(int i =0;i<matrix.length;i++)\\n        {\\n            for(int j =0;j<matrix[0].length;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    count++;\\n                sum  += Math.abs(matrix[i][j]);\\n                \\n                if(Math.abs(matrix[i][j])<min)\\n                min = Math.abs(matrix[i][j]);\\n            }\\n        }\\n       // for even count all the negative elements can be converted to positive values  \\n        if(count%2 ==0)\\n        {\\n            return sum;\\n        }\\n        // for negative subtract the smallest negative element from the sum \\n        return sum - 2*min;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        // Java greedy approach\\n        long sum =0;\\n        int count =0;\\n        long min = Integer.MAX_VALUE;\\n        // we find the positive sum of all the values, \\n        // if count of negative elements is odd then one element negative will be left after using the given operation\\n        // if count of negative elements is even then no element negative will be left after using the given operation\\n        for(int i =0;i<matrix.length;i++)\\n        {\\n            for(int j =0;j<matrix[0].length;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    count++;\\n                sum  += Math.abs(matrix[i][j]);\\n                \\n                if(Math.abs(matrix[i][j])<min)\\n                min = Math.abs(matrix[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3049535,
                "title": "easy-simple-c-solution",
                "content": "## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        bool neg=0;\\n        long long sum=0;\\n        int mini=INT_MAX;\\n        for (int i=0; i<matrix.size(); i++){\\n            for (int j=0; j<matrix[0].size(); j++){\\n                if (matrix[i][j]<0)neg= !neg;\\n                sum+= abs(matrix[i][j]);\\n                if (abs(matrix[i][j]) <mini)mini= abs(matrix[i][j]);\\n            }\\n        }\\n        if (neg)sum-= 2*mini;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        bool neg=0;\\n        long long sum=0;\\n        int mini=INT_MAX;\\n        for (int i=0; i<matrix.size(); i++){\\n            for (int j=0; j<matrix[0].size(); j++){\\n                if (matrix[i][j]<0)neg= !neg;\\n                sum+= abs(matrix[i][j]);\\n                if (abs(matrix[i][j]) <mini)mini= abs(matrix[i][j]);\\n            }\\n        }\\n        if (neg)sum-= 2*mini;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793082,
                "title": "concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long mn = INT_MAX, cnt = 0, sum = 0;\\n        for(auto r : matrix) {\\n            for(int i : r) {\\n                if(i < 0) cnt++;\\n                mn = min(mn, (long long)abs(i));\\n                sum += abs(i);\\n            }\\n        }\\n        return cnt % 2 ? sum - 2 * mn : sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long mn = INT_MAX, cnt = 0, sum = 0;\\n        for(auto r : matrix) {\\n            for(int i : r) {\\n                if(i < 0) cnt++;\\n                mn = min(mn, (long long)abs(i));\\n                sum += abs(i);\\n            }\\n        }\\n        return cnt % 2 ? sum - 2 * mn : sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733037,
                "title": "proper-explanation-in-hindi-c-greedy-intuition",
                "content": "```\\n long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        long long sum=0;\\n        int mino=INT_MAX,neg=0;\\n        \\n        // Step 1 -> Find absolute sum of all elements in the matrix\\n        for(auto i:matrix)\\n        {\\n            for(auto j:i)\\n            {\\n                sum+=abs(j); \\n                \\n                if(j<=0)   //IMPORTANT 0s are also counted as -1 0 if adjacent 0 \\n                     neg++;  // will help to nullify the -ve sign as -0 is also 0\\n                \\n                mino=min(mino,abs(j)); \\n            }\\n        }\\n        \\n//IMPORTANT -> If no -ve or even -ve numbers then they will all somehow become +ve \\n        if(mino==INT_MAX or neg%2==0)  \\n            return sum;\\n        \\n        return sum-2*abs(mino);  //IMPORTANT --> if odd -ve the remaining odd negative sign will come to the smallest abs value to maximize the sum\\n    }",
                "solutionTags": [],
                "code": "```\\n long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        long long sum=0;\\n        int mino=INT_MAX,neg=0;\\n        \\n        // Step 1 -> Find absolute sum of all elements in the matrix\\n        for(auto i:matrix)\\n        {\\n            for(auto j:i)\\n            {\\n                sum+=abs(j); \\n                \\n                if(j<=0)   //IMPORTANT 0s are also counted as -1 0 if adjacent 0 \\n                     neg++;  // will help to nullify the -ve sign as -0 is also 0\\n                \\n                mino=min(mino,abs(j)); \\n            }\\n        }\\n        \\n//IMPORTANT -> If no -ve or even -ve numbers then they will all somehow become +ve \\n        if(mino==INT_MAX or neg%2==0)  \\n            return sum;\\n        \\n        return sum-2*abs(mino);  //IMPORTANT --> if odd -ve the remaining odd negative sign will come to the smallest abs value to maximize the sum\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2467310,
                "title": "easiest-c-o-n-2-approach-o-1-space-complexity",
                "content": "Intuition - If there are even negative numbers, then they can always be converted into positive numbers, and if there are odd negative numbers, then 1 number will ways be negative, we find the smallest number, and subtract it twice from the final sum (as it would be counted once already)\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        long long sum=0,negatives=0;\\n        int minele=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum+=abs(matrix[i][j]);\\n                minele=min(minele,abs(matrix[i][j]));\\n                if(matrix[i][j]<0) negatives++;\\n            }\\n        }\\n        if(negatives%2!=0){\\n            sum-=(2*minele);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        long long sum=0,negatives=0;\\n        int minele=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum+=abs(matrix[i][j]);\\n                minele=min(minele,abs(matrix[i][j]));\\n                if(matrix[i][j]<0) negatives++;\\n            }\\n        }\\n        if(negatives%2!=0){\\n            sum-=(2*minele);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446609,
                "title": "logic",
                "content": "```  long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int mini = 1e8;\\n        int cnt=0;\\n        \\n        //Here the main logic is if the number of negative number is even then after operation all the numbers can become positive and if the count is odd then we will make the smallest number negative and then calculate the sum by subtracting the minimum number twice.\\n        long long int sum=0;\\n        for(int i=0; i<n ;i++){\\n            for(int j=0; j<n;j++){\\n                if(matrix[i][j]<0)cnt++;\\n                mini = min(mini, abs(matrix[i][j]));\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n        if(cnt%2)return sum-(2*mini);\\n        else return sum;\\n        \\n    }\\n\\t```\\n\\t",
                "solutionTags": [],
                "code": "```  long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int mini = 1e8;\\n        int cnt=0;\\n        \\n        //Here the main logic is if the number of negative number is even then after operation all the numbers can become positive and if the count is odd then we will make the smallest number negative and then calculate the sum by subtracting the minimum number twice.\\n        long long int sum=0;\\n        for(int i=0; i<n ;i++){\\n            for(int j=0; j<n;j++){\\n                if(matrix[i][j]<0)cnt++;\\n                mini = min(mini, abs(matrix[i][j]));\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n        if(cnt%2)return sum-(2*mini);\\n        else return sum;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2124838,
                "title": "python-greedy-solution-faster-than-85",
                "content": "\\tclass Solution:\\n\\t\\tdef maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n\\t\\t\\tsm = 0\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tmn = float(\\'inf\\')\\n\\t\\t\\tfor row in matrix:\\n\\t\\t\\t\\tfor col in row:\\n\\t\\t\\t\\t\\tcnt += 1 if col < 0 else 0\\n\\t\\t\\t\\t\\tsm += abs(col)\\n\\t\\t\\t\\t\\tmn = min(mn, abs(col))\\n\\n\\t\\t\\tif cnt % 2:\\n\\t\\t\\t\\treturn sm-2*mn\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn sm\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n\\t\\t\\tsm = 0\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tmn = float(\\'inf\\')\\n\\t\\t\\tfor row in matrix:\\n\\t\\t\\t\\tfor col in row:\\n\\t\\t\\t\\t\\tcnt += 1 if col < 0 else 0\\n\\t\\t\\t\\t\\tsm += abs(col)\\n\\t\\t\\t\\t\\tmn = min(mn, abs(col))\\n\\n\\t\\t\\tif cnt % 2:\\n\\t\\t\\t\\treturn sm-2*mn\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn sm\\n",
                "codeTag": "Java"
            },
            {
                "id": 2089285,
                "title": "python-o-n-with-explanation-faster-than-80",
                "content": "Basic idea: Count the number of negatives\\n* If a row has an even number of negatives, all negatives can be deleted\\n* If a row has an odd number of negatives, it can be made such that only one negative remains. This negative can be moved to the column of our choosing: [-1, -1, -1, -1, -1] --> [-1, 1, 1, 1, 1] -> [1, -1, 1, 1, 1]\\n* A negative can be moved up a row by doing the operation with it and the cell above: [[1], [-1]] to [[-1][1]]\\n* ==> If the matrix has an even number of negatives, all negatives can be eliminated\\n* ==> If the number of negatives is odd, set it to the lowest value in the matrix\\n\\n```\\n\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        # count -\\'s\\n        count = 0\\n        for row in matrix:\\n            for col_num in row:\\n                if col_num < 0:\\n                    count += 1\\n        tot_sum = sum([sum([abs(x) for x in row])\\n                       for row in matrix])\\n        if count % 2 == 0:\\n            return tot_sum\\n        else:\\n            min_val = min([min([abs(x) for x in row])\\n                       for row in matrix])\\n            return tot_sum - 2 * min_val\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        # count -\\'s\\n        count = 0\\n        for row in matrix:\\n            for col_num in row:\\n                if col_num < 0:\\n                    count += 1\\n        tot_sum = sum([sum([abs(x) for x in row])\\n                       for row in matrix])\\n        if count % 2 == 0:\\n            return tot_sum\\n        else:\\n            min_val = min([min([abs(x) for x in row])\\n                       for row in matrix])\\n            return tot_sum - 2 * min_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857673,
                "title": "python-intuitive-solution-with-explanation",
                "content": "**Basic Idea** :- The idea is to see how we can minimise the number of negative signs. If you design an example matrix with any number of negative elements, you can always reduce the number of negative signs to 0 or 1. If there are even number of signs you can reduce to 0 else to 1.\\nSo in case of 1 negative sign we can always place that sign in front of the minimum magnitude number .\\n\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        tot_sum = 0\\n        neg_nums, min_val = 0, float(\\'inf\\')\\n        for row in matrix:\\n            for col_val in row:\\n                tot_sum += abs(col_val)\\n                min_val = min(min_val, abs(col_val))\\n                if col_val < 0:\\n                    neg_nums += 1\\n        if neg_nums % 2 == 0:\\n            return tot_sum\\n        else:\\n            return tot_sum - 2*min_val\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        tot_sum = 0\\n        neg_nums, min_val = 0, float(\\'inf\\')\\n        for row in matrix:\\n            for col_val in row:\\n                tot_sum += abs(col_val)\\n                min_val = min(min_val, abs(col_val))\\n                if col_val < 0:\\n                    neg_nums += 1\\n        if neg_nums % 2 == 0:\\n            return tot_sum\\n        else:\\n            return tot_sum - 2*min_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778184,
                "title": "c-odd-even-trick-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll maxMatrixSum(vector<vector<int>>& arr) {\\n        int N = arr.size() , negs = 0 , mini = INT_MAX ;\\n        ll sum = 0 ;\\n        for(int i = 0 ; i < N ; i ++ ){\\n            for(int j = 0 ; j< N ; j++ ){\\n                sum += abs(arr[i][j]) ;\\n                mini = min(mini,abs(arr[i][j])) ;\\n                if(arr[i][j] < 0) negs ++ ;\\n            }\\n        }\\n        if(negs % 2 == 0) return sum ;\\n        return sum -2*mini ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll maxMatrixSum(vector<vector<int>>& arr) {\\n        int N = arr.size() , negs = 0 , mini = INT_MAX ;\\n        ll sum = 0 ;\\n        for(int i = 0 ; i < N ; i ++ ){\\n            for(int j = 0 ; j< N ; j++ ){\\n                sum += abs(arr[i][j]) ;\\n                mini = min(mini,abs(arr[i][j])) ;\\n                if(arr[i][j] < 0) negs ++ ;\\n            }\\n        }\\n        if(negs % 2 == 0) return sum ;\\n        return sum -2*mini ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706395,
                "title": "easy-c-greedy-observations",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> pos;\\n        vector<int> neg;\\n     long long    int sum=0;\\n        bool zero=false;\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    zero=true;\\n                }\\n                sum+=abs(matrix[i][j]);\\n                if(matrix[i][j]>0){\\n                    pos.push_back(matrix[i][j]);\\n                }else if(matrix[i][j]<0){\\n                      neg.push_back(abs(matrix[i][j]));\\n                }\\n            }\\n        }\\n        cout<<sum<<endl;\\n        sort(neg.begin(),neg.end());\\n        sort(pos.begin(),pos.end());\\n        if((neg.size()==0)||(neg.size()%2==0)||(zero==true)){\\n            return sum;\\n        }else{\\n            sum-=2*min(neg[0],pos.size()>0?pos[0]:INT_MAX);\\n            return sum;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> pos;\\n        vector<int> neg;\\n     long long    int sum=0;\\n        bool zero=false;\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    zero=true;\\n                }\\n                sum+=abs(matrix[i][j]);\\n                if(matrix[i][j]>0){\\n                    pos.push_back(matrix[i][j]);\\n                }else if(matrix[i][j]<0){\\n                      neg.push_back(abs(matrix[i][j]));\\n                }\\n            }\\n        }\\n        cout<<sum<<endl;\\n        sort(neg.begin(),neg.end());\\n        sort(pos.begin(),pos.end());\\n        if((neg.size()==0)||(neg.size()%2==0)||(zero==true)){\\n            return sum;\\n        }else{\\n            sum-=2*min(neg[0],pos.size()>0?pos[0]:INT_MAX);\\n            return sum;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1645239,
                "title": "c-solution",
                "content": "If number of negative numbers is even then the sum will be sum of all the elements and if it is odd then we  can eliminate the abs(smallest number in the matrix) as we can perform as many operations we want to get max sum.\\n```\\nlong long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int c=0,mini=INT_MAX; long long sum=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]<0) c++;\\n                sum+=abs(matrix[i][j]);\\n                mini = min(mini,abs(matrix[i][j]));\\n            }\\n        }\\n        if(c%2==0) return sum;\\n        return sum - 2 * mini;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "If number of negative numbers is even then the sum will be sum of all the elements and if it is odd then we  can eliminate the abs(smallest number in the matrix) as we can perform as many operations we want to get max sum.\\n```\\nlong long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int c=0,mini=INT_MAX; long long sum=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]<0) c++;\\n                sum+=abs(matrix[i][j]);\\n                mini = min(mini,abs(matrix[i][j]));\\n            }\\n        }\\n        if(c%2==0) return sum;\\n        return sum - 2 * mini;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1640958,
                "title": "c-144ms-92-simple-easy-small-commented",
                "content": "**Absolutely clear :**\\n**1.** **if we have two adjaced negative value we can transform this numbers into positive**\\n**2.** **if we have negative value with only positive neighbours we can multiply this number on pair of minus and move minus to other single minus and after it have step 1**\\n**3.** **if we have last single minus we can move it to minimal value in matrix**\\n**4.** **total : calculate sum of absolutelly values and number of negative values : if we will have even value of minuses - our sum will be answer , if - odd : subtruct from sum doubled minimal value from matrix** \\nRuntime: 144 ms, faster than 92.33% of C++ online submissions for Maximum Matrix Sum.\\nMemory Usage: 35.3 MB, less than 62.78% of C++ online submissions for Maximum Matrix Sum.\\n```\\nclass Solution {\\npublic:\\n  long long maxMatrixSum(vector<vector<int>>& matrix) {\\n    int n = 0, mini = INT_MAX;\\n    long sum = 0;\\n    \\n    for(auto &row: matrix)\\n      for(auto x: row) \\n        if(x < 0) sum -= x, n++, mini = min(mini, -x);\\n        else sum += x, mini = min(mini, x);\\n    \\n    return sum - ( n&1 ? (mini<<1) : 0);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long maxMatrixSum(vector<vector<int>>& matrix) {\\n    int n = 0, mini = INT_MAX;\\n    long sum = 0;\\n    \\n    for(auto &row: matrix)\\n      for(auto x: row) \\n        if(x < 0) sum -= x, n++, mini = min(mini, -x);\\n        else sum += x, mini = min(mini, x);\\n    \\n    return sum - ( n&1 ? (mini<<1) : 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623599,
                "title": "clever-observation-c",
                "content": "```\\n    long long maxMatrixSum(vector<vector<int>>& g) {\\n        \\n        long long res = 0; int neg = 0;\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        \\n        for(int i = 0 ; i < g.size() ; i++)\\n            for(int j = 0 ; j < g[0].size() ; j++) {\\n                \\n                if(g[i][j] <= 0) neg++; \\n                q.push(abs(g[i][j]));\\n                res += abs(g[i][j]);\\n            }\\n        \\n        if(neg % 2 && q.size()) res -= 2 * q.top();\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    long long maxMatrixSum(vector<vector<int>>& g) {\\n        \\n        long long res = 0; int neg = 0;\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        \\n        for(int i = 0 ; i < g.size() ; i++)\\n            for(int j = 0 ; j < g[0].size() ; j++) {\\n                \\n                if(g[i][j] <= 0) neg++; \\n                q.push(abs(g[i][j]));\\n                res += abs(g[i][j]);\\n            }\\n        \\n        if(neg % 2 && q.size()) res -= 2 * q.top();\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539858,
                "title": "c",
                "content": "```\\nif count of -ve sign is even they will eliminate themselves  so just print sum\\nif count of -ve sign is odd then one of them cannot be replaced so optimal element is minimal of matrix\\n\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        \\n        int mina=INT_MAX;\\n        int cnt=0;\\n        long long sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                mina=min(abs(matrix[i][j]),mina);\\n                sum+=abs(matrix[i][j]);\\n                if(matrix[i][j]<0)\\n                    cnt++;\\n            }\\n        }\\n        \\n        if(cnt%2==0)\\n            return sum;\\n        else\\n            return sum-2*mina;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        \\n        int mina=INT_MAX;\\n        int cnt=0;\\n        long long sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                mina=min(abs(matrix[i][j]),mina);\\n                sum+=abs(matrix[i][j]);\\n                if(matrix[i][j]<0)\\n                    cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1496364,
                "title": "python-easy-to-understand-with-explanation",
                "content": "```\\n# Approach 1: \\n# Find the absolute sum of all the numbers in the matrix\\n# Find the absolute value of the smallest number in the matrix\\n# Count of negative numbers in the matrix\\n#   If count of negatives is even, then all elements can be made positive by performing the operation, so just return the total sum of the matrix\\n#   If count of negatives is odd, then we can make the smallest number in the matrix as negative and then return the sum\\n# NOTE : Here the result will be sum-2*minElement as you are not including this element.\\n\\ndef maxMatrixSum(matrix):\\n\\n    \"\"\"\\n    :type matrix: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    totSum = nNegative = 0\\n    minNegAbsVal = float(\\'inf\\')\\n    nr = nc = len(matrix)\\n    for r in range(nr):\\n        for c in range(nc):\\n            elem = matrix[r][c]\\n            if elem <= 0:               # \\'=\\' is to account for occurrence of \\'0\\'\\n                nNegative+=1\\n            minNegAbsVal = min(minNegAbsVal,abs(elem))\\n            totSum += abs(elem)\\n    \\n    if nNegative % 2 == 0: \\n        return totSum\\n    else:\\n        return totSum - 2*minNegAbsVal\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Approach 1: \\n# Find the absolute sum of all the numbers in the matrix\\n# Find the absolute value of the smallest number in the matrix\\n# Count of negative numbers in the matrix\\n#   If count of negatives is even, then all elements can be made positive by performing the operation, so just return the total sum of the matrix\\n#   If count of negatives is odd, then we can make the smallest number in the matrix as negative and then return the sum\\n# NOTE : Here the result will be sum-2*minElement as you are not including this element.\\n\\ndef maxMatrixSum(matrix):\\n\\n    \"\"\"\\n    :type matrix: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    totSum = nNegative = 0\\n    minNegAbsVal = float(\\'inf\\')\\n    nr = nc = len(matrix)\\n    for r in range(nr):\\n        for c in range(nc):\\n            elem = matrix[r][c]\\n            if elem <= 0:               # \\'=\\' is to account for occurrence of \\'0\\'\\n                nNegative+=1\\n            minNegAbsVal = min(minNegAbsVal,abs(elem))\\n            totSum += abs(elem)\\n    \\n    if nNegative % 2 == 0: \\n        return totSum\\n    else:\\n        return totSum - 2*minNegAbsVal\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1491055,
                "title": "simple-java-solution",
                "content": "Idea is to count the number of negative number in the matrix. If total count of negative numbers are even we can convert all of them to positive number but if count is odd, there will be atleast one number remain negative. So we will try to make the smallest number to negative to get the max sum.\\n\\n```class Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int count = 0, min = Integer.MAX_VALUE;\\n        long sum = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] < 0){\\n                    count++;\\n                }\\n                min = Math.min(min, Math.abs(matrix[i][j]));\\n                sum+=Math.abs(matrix[i][j]);\\n            }\\n        }\\n        if(count%2 == 0){\\n            return sum;\\n        }else{\\n            return sum - 2*min;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int count = 0, min = Integer.MAX_VALUE;\\n        long sum = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] < 0){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1489999,
                "title": "o-size-of-matrix-complexity-and-o-1-space-in-python",
                "content": "\\n        \\n\\t\\t\\n\\t\\tsumi=0\\n        mini=sys.maxsize\\n        cnt=0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]<0:\\n                    cnt+=1\\n                matrix[i][j]=abs(matrix[i][j])\\n                sumi+=matrix[i][j]\\n                mini=min(matrix[i][j],mini)\\n        \\n        if cnt%2==0:\\n            return sumi\\n        else:\\n            sumi=sumi-2*mini\\n            return sumi",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        \\n\\t\\t\\n\\t\\tsumi=0\\n        mini=sys.maxsize\\n        cnt=0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]<0:\\n                    cnt+=1\\n                matrix[i][j]=abs(matrix[i][j])\\n                sumi+=matrix[i][j]\\n                mini=min(matrix[i][j],mini)\\n        \\n        if cnt%2==0:\\n            return sumi\\n        else:\\n            sumi=sumi-2*mini\\n            return sumi",
                "codeTag": "Unknown"
            },
            {
                "id": 1488186,
                "title": "python-o-n-m-runtime-o-1-space-concise-solution-beats-100-with-explanation",
                "content": "The fundamental concept to understand here is that we can apply the negative shiting operator between any 2 numbers in the array after a given number of steps.\\n\\nThere\\'s 3 cases:\\n1. Even number of negative numbers. In this case, we can cancel out every even number together to get all positive numbers in the array.\\n2. Odd number of negative numbers. In this case, we\\'ll have 1 negative number left. Choose the smallest absolute value in the array to get the max answer in this case.\\n3. There exists 0\\'s in the array. We can take any negative number in the array and make it positive by applying it against the 0. This is then the same as the 1st case of even negative numbers.\\n\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        numNeg = sum(1 for row in matrix for col in row if col < 0)\\n        matrixSum = sum(abs(col) for row in matrix for col in row)\\n        if numNeg % 2 == 0 or any(col == 0 for row in matrix for col in row):\\n            return matrixSum \\n        \\n        return matrixSum - 2 * min(abs(col) for row in matrix for col in row)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        numNeg = sum(1 for row in matrix for col in row if col < 0)\\n        matrixSum = sum(abs(col) for row in matrix for col in row)\\n        if numNeg % 2 == 0 or any(col == 0 for row in matrix for col in row):\\n            return matrixSum \\n        \\n        return matrixSum - 2 * min(abs(col) for row in matrix for col in row)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454990,
                "title": "simple-python",
                "content": "If you observe carefully, it\\'s really easy to bring negative signs adjacent to other, eg for [-1,1,-1] we choose 0th and 1st index and get [1,-1,-1]. similar approach can be used for vertical cells. Two adjacent negative cells can be both made positive. In case of off odd number of negative or 0 cells in matrix, all cells except one will remain positive. The only negative will be cell with lowest absolute value. In case of even numbers of negative or 0 cells, all cells will remain positive.\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        (tot,count,mini) = (0,0,float(\\'inf\\'))\\n        for i in matrix:\\n            for j in i:\\n                if j <= 0:\\n                    count += 1\\n                mini = min(mini,abs(j))\\n                tot += abs(j)\\n        if count % 2 != 0:\\n            tot -= 2*mini\\n        return tot\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        (tot,count,mini) = (0,0,float(\\'inf\\'))\\n        for i in matrix:\\n            for j in i:\\n                if j <= 0:\\n                    count += 1\\n                mini = min(mini,abs(j))\\n                tot += abs(j)\\n        if count % 2 != 0:\\n            tot -= 2*mini\\n        return tot\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1437650,
                "title": "python-3-lines",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        count = sum(sum(z<0 for z in row) for row in matrix)\\n        s = sum(sum(abs(z) for z in row) for row in matrix)\\n        return s - 2*(count%2)*min(min(abs(z) for z in row) for row in matrix)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        count = sum(sum(z<0 for z in row) for row in matrix)\\n        s = sum(sum(abs(z) for z in row) for row in matrix)\\n        return s - 2*(count%2)*min(min(abs(z) for z in row) for row in matrix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418016,
                "title": "my-java-solution-by-counting-the-number-of-negative-numbers",
                "content": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        // even number of negative number -> abs(sum)\\n        // odd number of negative number -> sum - 2 * min\\n        if (matrix == null || matrix.length == 0)\\n            return 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        long countNegativeNumbers = 0l;\\n        long totalSum = 0l;\\n        int minimumInMatrix = Integer.MAX_VALUE;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (matrix[i][j] < 0) {\\n                    countNegativeNumbers += 1;\\n                    matrix[i][j] *= -1;\\n                }\\n                totalSum += Math.abs(matrix[i][j]);\\n                minimumInMatrix = Math.min(minimumInMatrix, matrix[i][j]);\\n            }\\n        }\\n        return countNegativeNumbers % 2 == 1 ? totalSum - 2 * minimumInMatrix : totalSum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        // even number of negative number -> abs(sum)\\n        // odd number of negative number -> sum - 2 * min\\n        if (matrix == null || matrix.length == 0)\\n            return 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        long countNegativeNumbers = 0l;\\n        long totalSum = 0l;\\n        int minimumInMatrix = Integer.MAX_VALUE;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (matrix[i][j] < 0) {\\n                    countNegativeNumbers += 1;\\n                    matrix[i][j] *= -1;\\n                }\\n                totalSum += Math.abs(matrix[i][j]);\\n                minimumInMatrix = Math.min(minimumInMatrix, matrix[i][j]);\\n            }\\n        }\\n        return countNegativeNumbers % 2 == 1 ? totalSum - 2 * minimumInMatrix : totalSum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418001,
                "title": "if-there-is-0-you-can-always-eliminate-negative-number",
                "content": "I saw most answers check if the count of negative number is odd or even. When there is a 0, you can always eliminate negative number regardless if their count is even or not. If you only consider odd/even on negative number, you may not pass the following test case:\\n[[0, -1],[0, 0]].\\n\\nIt seems test cases should be enhanced.\\n```\\npublic long maxMatrixSum(int[][] matrix) {\\n        int rn = matrix.length, cn = matrix[0].length;\\n        long sum = 0;\\n        int neg = 0;\\n        int zero = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < rn; i++) {\\n            for (int j = 0; j < cn; j++) {\\n                if (matrix[i][j] > 0) {\\n                    sum += matrix[i][j];\\n                    min = Math.min(min, matrix[i][j]);\\n                } else if (matrix[i][j] < 0) {\\n                    neg += 1;\\n                    sum -= matrix[i][j];\\n                    min = Math.min(min, -matrix[i][j]);\\n                } else {\\n                    zero++;\\n                }\\n            }\\n        }\\n        return zero > 0 || neg % 2 == 0 ? sum : sum - 2 * min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long maxMatrixSum(int[][] matrix) {\\n        int rn = matrix.length, cn = matrix[0].length;\\n        long sum = 0;\\n        int neg = 0;\\n        int zero = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < rn; i++) {\\n            for (int j = 0; j < cn; j++) {\\n                if (matrix[i][j] > 0) {\\n                    sum += matrix[i][j];\\n                    min = Math.min(min, matrix[i][j]);\\n                } else if (matrix[i][j] < 0) {\\n                    neg += 1;\\n                    sum -= matrix[i][j];\\n                    min = Math.min(min, -matrix[i][j]);\\n                } else {\\n                    zero++;\\n                }\\n            }\\n        }\\n        return zero > 0 || neg % 2 == 0 ? sum : sum - 2 * min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417792,
                "title": "easy-short-even-all-positive-odd-all-positive-2-min-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0;\\n        int counter = 0;\\n        int mn = INT_MAX;\\n        int n = matrix.size();\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if(matrix[i][j] < 0){\\n                    counter++;\\n                }\\n                int val = abs(matrix[i][j]);\\n                sum+=val;\\n                mn = min(mn, val);\\n            }\\n        }\\n        if(counter & 2)\\n            sum -= 2 * mn;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0;\\n        int counter = 0;\\n        int mn = INT_MAX;\\n        int n = matrix.size();\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if(matrix[i][j] < 0){\\n                    counter++;\\n                }\\n                int val = abs(matrix[i][j]);\\n                sum+=val;\\n                mn = min(mn, val);\\n            }\\n        }\\n        if(counter & 2)\\n            sum -= 2 * mn;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417723,
                "title": "c-count-negative-easy-solution",
                "content": "**Approach** : By the given operation we can make any cell negative (we are able to move -ve sign everywhere) .\\nNow there are two conditions -\\n1) count of -ve elements are even , if so then we can able to remove all -ve\\'s , means answer is sum of absoulute value of each cell.\\n2) count of -ve elements are odd , if so then we can able to remove all -ve\\'s , except one -ve element and we will make -ve which cell ? , the cell which have least absolute value so the answer is sum of  absoulute value of each cell - 2* min value *(why ? , let say we have array a =[1,2,3,4] sum is 10 but we apply one -ve sign before 3 so array is [1,2-3,4] sum is 4 which is same as 10-2  (3) = 4]*\\n\\n**Below is the solution -**\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& mat) {\\n        long long int sum = 0 , mini = INT_MAX ,  cnt=0;\\n\\t\\tint n=mat.size();\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=0;j<n;j++){\\n                sum += abs(mat[i][j]);\\n                if(mat[i][j]<0)\\n                    cnt++;\\n                mini = min(mini , abs(mat[i][j])*1LL);\\n            }\\n        }\\n        if(cnt%2)\\n            return sum-2*mini;\\n        else\\n            return sum;\\n    }\\n};\\n```\\n**Upvote if you like \\u2764\\uFE0F**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& mat) {\\n        long long int sum = 0 , mini = INT_MAX ,  cnt=0;\\n\\t\\tint n=mat.size();\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=0;j<n;j++){\\n                sum += abs(mat[i][j]);\\n                if(mat[i][j]<0)\\n                    cnt++;\\n                mini = min(mini , abs(mat[i][j])*1LL);\\n            }\\n        }\\n        if(cnt%2)\\n            return sum-2*mini;\\n        else\\n            return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417632,
                "title": "java-just-observe-the-pattern",
                "content": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int count = 0;\\n        long sum = 0;\\n        int min1 = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(mat[i][j] < 0){\\n                    count++;\\n                    sum = sum - (long)mat[i][j];\\n                    min1 = Math.min(min1, -mat[i][j]);\\n                }\\n                else{\\n                    sum = sum + (long)mat[i][j];\\n                    min1 = Math.min(min1, mat[i][j]);\\n                }\\n                \\n            }\\n        }\\n        \\n        if(count%2 == 0){\\n            return sum;\\n        }\\n        else{\\n            return sum - (long)min1*2;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int count = 0;\\n        long sum = 0;\\n        int min1 = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(mat[i][j] < 0){\\n                    count++;\\n                    sum = sum - (long)mat[i][j];\\n                    min1 = Math.min(min1, -mat[i][j]);\\n                }\\n                else{\\n                    sum = sum + (long)mat[i][j];\\n                    min1 = Math.min(min1, mat[i][j]);\\n                }\\n                \\n            }\\n        }\\n        \\n        if(count%2 == 0){\\n            return sum;\\n        }\\n        else{\\n            return sum - (long)min1*2;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417612,
                "title": "java-simple-one-pass-solution-o-n-2",
                "content": "The logic is very simple, If you iterate it maximum number of times, you can get rid of all the negatives if :\\n1. There is a ZERO as a value in the matrix \\n2. Count of negative characters are even.\\n\\nElse you can end up having only 1 negative number.\\nFor that, choose the min number of absolute values in the matrix.\\n\\n\\tpublic long maxMatrixSum(int[][] matrix) {\\n\\t\\t\\tint negCount = 0;\\n\\t\\t\\tlong totalSum = 0;\\n\\t\\t\\tint lowest = Integer.MAX_VALUE;\\n\\t\\t\\tboolean ifZeroPresent = false;\\n\\t\\t\\tfor(int i = 0 ; i < matrix.length ; i++) {\\n\\t\\t\\t\\tfor(int j = 0 ; j < matrix.length ; j++) {\\n\\t\\t\\t\\t\\tif(matrix[i][j] < 0)  negCount++;\\n\\t\\t\\t\\t\\tint num = Math.abs(matrix[i][j]);\\n\\t\\t\\t\\t\\ttotalSum += num;\\n\\t\\t\\t\\t\\tlowest = Math.min(num, lowest);\\n\\t\\t\\t\\t\\tif(num == 0) ifZeroPresent = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(negCount % 2 == 1 && !ifZeroPresent) {\\n\\t\\t\\t\\ttotalSum -= 2*lowest;\\n\\t\\t\\t}\\n\\t\\t\\treturn totalSum;\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The logic is very simple, If you iterate it maximum number of times, you can get rid of all the negatives if :\\n1. There is a ZERO as a value in the matrix \\n2. Count of negative characters are even.\\n\\nElse you can end up having only 1 negative number.\\nFor that, choose the min number of absolute values in the matrix.\\n\\n\\tpublic long maxMatrixSum(int[][] matrix) {\\n\\t\\t\\tint negCount = 0;\\n\\t\\t\\tlong totalSum = 0;\\n\\t\\t\\tint lowest = Integer.MAX_VALUE;\\n\\t\\t\\tboolean ifZeroPresent = false;\\n\\t\\t\\tfor(int i = 0 ; i < matrix.length ; i++) {\\n\\t\\t\\t\\tfor(int j = 0 ; j < matrix.length ; j++) {\\n\\t\\t\\t\\t\\tif(matrix[i][j] < 0)  negCount++;\\n\\t\\t\\t\\t\\tint num = Math.abs(matrix[i][j]);\\n\\t\\t\\t\\t\\ttotalSum += num;\\n\\t\\t\\t\\t\\tlowest = Math.min(num, lowest);\\n\\t\\t\\t\\t\\tif(num == 0) ifZeroPresent = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(negCount % 2 == 1 && !ifZeroPresent) {\\n\\t\\t\\t\\ttotalSum -= 2*lowest;\\n\\t\\t\\t}\\n\\t\\t\\treturn totalSum;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1417589,
                "title": "greedy-clean-concise-well-explained-easy-approach",
                "content": "## IDEA:\\nTo solve this we have to check three conditions :\\n\\uD83D\\uDC49 *Get the sum of all positive and negative numbers separetly.\\n\\uD83D\\uDC49 If there exist 0 in matrix then sum all the absolute values.\\n\\uD83D\\uDC49 If the count of negative number is odd then there will exist atleast one negative number So find the smallest absolute number to make it negative(sum will get maximized.\\n\\uD83D\\uDC49 if count of negative numbers is even then directly sum all the absolute values because we can make all positive with given operations.*\\n****\\nFeel free to ask if you have any doubt.\\uD83E\\uDD1E(answer with in 24hrs)\\n****\\n\\'\\'\\'\\n\\n\\ts -> sum of all absolute values\\n\\tc-> counter for negative numbers\\n\\tz-> zero is there or not in matrix\\n\\tm-> absolute minimum number\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        s,c,z,m=0,0,0,float(\\'inf\\')\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]<0:\\n                    c+=1\\n                if matrix[i][j]==0:\\n                    z=1\\n                s+=abs(matrix[i][j])\\n                m=min(m,abs(matrix[i][j]))\\n                \\n        if c%2==0 or z>0:\\n            return s\\n        else:\\n            return s-m*2\\n\\n****\\n### Thanks & **Upvote** if you got any help !!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\nTo solve this we have to check three conditions :\\n\\uD83D\\uDC49 *Get the sum of all positive and negative numbers separetly.\\n\\uD83D\\uDC49 If there exist 0 in matrix then sum all the absolute values.\\n\\uD83D\\uDC49 If the count of negative number is odd then there will exist atleast one negative number So find the smallest absolute number to make it negative(sum will get maximized.\\n\\uD83D\\uDC49 if count of negative numbers is even then directly sum all the absolute values because we can make all positive with given operations.*\\n****\\nFeel free to ask if you have any doubt.\\uD83E\\uDD1E(answer with in 24hrs)\\n****\\n\\'\\'\\'\\n\\n\\ts -> sum of all absolute values\\n\\tc-> counter for negative numbers\\n\\tz-> zero is there or not in matrix\\n\\tm-> absolute minimum number\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        s,c,z,m=0,0,0,float(\\'inf\\')\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]<0:\\n                    c+=1\\n                if matrix[i][j]==0:\\n                    z=1\\n                s+=abs(matrix[i][j])\\n                m=min(m,abs(matrix[i][j]))\\n                \\n        if c%2==0 or z>0:\\n            return s\\n        else:\\n            return s-m*2\\n\\n****\\n### Thanks & **Upvote** if you got any help !!",
                "codeTag": "Java"
            },
            {
                "id": 4046268,
                "title": "simple-python-beginners",
                "content": "# please upvote if code is helpful\\n**add all numbers first then if odd number of negatives are there then substract 2*min last three if conditions tells the rules**\\n```\\nclass Solution(object):\\n    def maxMatrixSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        total = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        zeros = 0\\n        negs = 0\\n        negs_list = []\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeros += 1\\n                if matrix[i][j] < 0:\\n                    negs += 1\\n                    \\n                total += abs(matrix[i][j])\\n                negs_list.append(abs(matrix[i][j]))\\n        if negs % 2 == 0:\\n            return total\\n        if negs%2 != 0 and zeros >= 1:\\n            return total\\n        if negs%2 != 0 and zeros == 0:\\n            return total - 2*min(negs_list)\\n        \\n        \\n```\\n**please upvote**",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxMatrixSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        total = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        zeros = 0\\n        negs = 0\\n        negs_list = []\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeros += 1\\n                if matrix[i][j] < 0:\\n                    negs += 1\\n                    \\n                total += abs(matrix[i][j])\\n                negs_list.append(abs(matrix[i][j]))\\n        if negs % 2 == 0:\\n            return total\\n        if negs%2 != 0 and zeros >= 1:\\n            return total\\n        if negs%2 != 0 and zeros == 0:\\n            return total - 2*min(negs_list)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900638,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n\\n        int count=0;\\n        long long sum=0;\\n        // int zero=0;\\n\\n        int mn=INT_MAX;\\n\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]<=0){\\n                    count++;\\n                }\\n                 mn=min(mn,abs(matrix[i][j]));\\n\\n                // if()\\n\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n\\n        // cout<<mn<<endl;\\n\\n\\n        if(count%2 !=0){\\n\\n            if(mn!=INT_MAX){\\n\\n               sum-=mn;\\n               sum-=mn;\\n            }\\n           \\n        }\\n\\n        return sum;\\n\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n\\n        int count=0;\\n        long long sum=0;\\n        // int zero=0;\\n\\n        int mn=INT_MAX;\\n\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]<=0){\\n                    count++;\\n                }\\n                 mn=min(mn,abs(matrix[i][j]));\\n\\n                // if()\\n\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n\\n        // cout<<mn<<endl;\\n\\n\\n        if(count%2 !=0){\\n\\n            if(mn!=INT_MAX){\\n\\n               sum-=mn;\\n               sum-=mn;\\n            }\\n           \\n        }\\n\\n        return sum;\\n\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3849748,
                "title": "simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int count=0;\\n        int n = matrix.size(), m = matrix[0].size();\\n        long long sum=0;\\n        long long mini = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                sum += abs(matrix[i][j]);\\n                mini = min(mini, (long long)abs(matrix[i][j]));\\n                if(matrix[i][j] < 0) count++;\\n            }\\n        }\\n\\n        if(count % 2 == 1){\\n            sum -= mini*2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int count=0;\\n        int n = matrix.size(), m = matrix[0].size();\\n        long long sum=0;\\n        long long mini = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                sum += abs(matrix[i][j]);\\n                mini = min(mini, (long long)abs(matrix[i][j]));\\n                if(matrix[i][j] < 0) count++;\\n            }\\n        }\\n\\n        if(count % 2 == 1){\\n            sum -= mini*2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738584,
                "title": "python-simple-greedy",
                "content": "Observations from 2 examples:\\n\\n**Example 1: even number of negative vals**\\n```\\n 1  1 -1\\n 1  1  1\\n-1  1  1\\n```\\n\\nYou can move **negative sign** across the matrix in any direction. When you have 2 negative signs adjacent to each other they turn positive. So here you can swap and move `-1` next to another `-1` and you\\'ll see the idea. We are not asked to provide number of steps to make them positive, just sum of all elements in the matrix after we do allowed operations.\\n`>> any 2 negative nums can be turned into 2 positive nums`\\n\\n**Example 2: odd number of negative vals**\\n```\\n 5  4 -5\\n 3  5  6\\n 1  3  5\\n```\\nHere you can see that again you can move **negative sign** anywhere you want. Just swap it with any positive number, but which one???\\nGreedy usually \"get max with min or vice versa\". In this case they ask us to get **max possible sum** which means that we need to substract **minimum possible value** from the sum of all.\\n\\nSo we go and swap signs in `-5` and `1`. You need to understand what\\'s **min value**. The min value in our case is no `-10_000_000` but the minimum value that we can substract from the total and have the max sum. So it\\'s `abs(min_value)`\\n`>> any negative sign should be moved to ` **abs(min_val)** (or not) `in order to maximize sum of the matrix`\\n\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        neg_count = 0\\n        total = 0\\n        min_abs = float(inf)\\n        for row in matrix:\\n            for val in row:\\n                min_abs = min(min_abs, abs(val))\\n                total += abs(val)\\n                neg_count += val < 0\\n        return total - 2 * min_abs if neg_count % 2 else total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n 1  1 -1\\n 1  1  1\\n-1  1  1\\n```\n```\\n 5  4 -5\\n 3  5  6\\n 1  3  5\\n```\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        neg_count = 0\\n        total = 0\\n        min_abs = float(inf)\\n        for row in matrix:\\n            for val in row:\\n                min_abs = min(min_abs, abs(val))\\n                total += abs(val)\\n                neg_count += val < 0\\n        return total - 2 * min_abs if neg_count % 2 else total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571323,
                "title": "negate-pairs-of-negatives",
                "content": "# Intuition\\nIf there are adjacent negatives, we could get rid both of them.\\n\\nIf one of adjacent numbers are negative, the negative could disseminate the minus sign to one of it\\'s neighbor. \\nHence the minus signs are gathered and annihilated until at most one minus sign remains.\\n\\n# Complexity\\n- Time complexity: O(n ** 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        Min = 10 ** 5 + 1\\n        nn = 0\\n        Sum = 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix)):\\n                Min = min(Min, abs(matrix[r][c]))\\n\\n                if matrix[r][c] < 0:\\n                    nn += 1\\n                \\n                Sum += abs(matrix[r][c])\\n        \\n        if nn % 2 == 0:\\n            return Sum\\n        else:\\n            return Sum - 2 * Min\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        Min = 10 ** 5 + 1\\n        nn = 0\\n        Sum = 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix)):\\n                Min = min(Min, abs(matrix[r][c]))\\n\\n                if matrix[r][c] < 0:\\n                    nn += 1\\n                \\n                Sum += abs(matrix[r][c])\\n        \\n        if nn % 2 == 0:\\n            return Sum\\n        else:\\n            return Sum - 2 * Min\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523321,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate 2 times the whole matrix.\\nFirst time to find if odd or even number of elements.\\nSecond to find sum.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int r = matrix.length, c = matrix[0].length;\\n\\t\\tlong ans = 0;\\n        boolean alwaystakeAbs = true; // means even number of -ve elements\\n        int min = Integer.MAX_VALUE;\\n        \\n        outer: for (int i = 0; i < r; i++) {\\n        \\tfor (int j = 0; j < c; j++) {\\n        \\t\\tif (matrix[i][j] == 0) {\\n        \\t\\t\\talwaystakeAbs = true;\\n        \\t\\t\\tbreak outer;\\n        \\t\\t}\\n        \\t\\tif (matrix[i][j] < 0) {\\n        \\t\\t\\talwaystakeAbs = !alwaystakeAbs;\\n        \\t\\t}\\n        \\t\\tmin = Math.min(min, Math.abs(matrix[i][j]));\\n        \\t}\\n        }\\n        \\n        for (int i = 0; i < r; i++) {\\n        \\tfor (int j = 0; j < c; j++) {\\n        \\t\\tif (alwaystakeAbs) {\\n        \\t\\t\\tans += Math.abs(matrix[i][j]);\\n        \\t\\t}\\n        \\t\\telse {\\n        \\t\\t\\tif (Math.abs(matrix[i][j]) == min) {\\n        \\t\\t\\t\\talwaystakeAbs = true;\\n        \\t\\t\\t\\tans -= min;\\n        \\t\\t\\t}\\n        \\t\\t\\telse {\\n        \\t\\t\\t\\tans += Math.abs(matrix[i][j]);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int r = matrix.length, c = matrix[0].length;\\n\\t\\tlong ans = 0;\\n        boolean alwaystakeAbs = true; // means even number of -ve elements\\n        int min = Integer.MAX_VALUE;\\n        \\n        outer: for (int i = 0; i < r; i++) {\\n        \\tfor (int j = 0; j < c; j++) {\\n        \\t\\tif (matrix[i][j] == 0) {\\n        \\t\\t\\talwaystakeAbs = true;\\n        \\t\\t\\tbreak outer;\\n        \\t\\t}\\n        \\t\\tif (matrix[i][j] < 0) {\\n        \\t\\t\\talwaystakeAbs = !alwaystakeAbs;\\n        \\t\\t}\\n        \\t\\tmin = Math.min(min, Math.abs(matrix[i][j]));\\n        \\t}\\n        }\\n        \\n        for (int i = 0; i < r; i++) {\\n        \\tfor (int j = 0; j < c; j++) {\\n        \\t\\tif (alwaystakeAbs) {\\n        \\t\\t\\tans += Math.abs(matrix[i][j]);\\n        \\t\\t}\\n        \\t\\telse {\\n        \\t\\t\\tif (Math.abs(matrix[i][j]) == min) {\\n        \\t\\t\\t\\talwaystakeAbs = true;\\n        \\t\\t\\t\\tans -= min;\\n        \\t\\t\\t}\\n        \\t\\t\\telse {\\n        \\t\\t\\t\\tans += Math.abs(matrix[i][j]);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470538,
                "title": "java-simple-and-clear-solution",
                "content": "# Approach\\n1. Looking at the numbers in the matrix, just ignore any number and look at the signs: + and -.\\n2. From this graphical view, ask the question: can you bring the minuses together to pair them?\\n3. Yes, flipping 2 cells will move/shift the minuses together.\\n4. Knowing this, all you need to know if how many negatives you have: \\n    - if you have an even number of negatives, then all can be paired and flipped, becoming positives. \\n    - if you have an ODD number of negatives, then one negative can\\'t be paired.\\n5. Traverse the matrix and calculate the sum of absolute values. Also count the negatives and keep track of the minimum absolute value.\\n    - If you have a 0, then any negative can be flipped to become a positive: [-5, 0] -> [5,0], so you know that ALL negatives can become positive\\n6. If you have an ODD number of negatives, a number will be left out to be negative. You want to pick the minimum absolute number for that in order to maximize your sum.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long absSum = 0L;\\n        int negativeCount = 0;\\n        int minAbs = 100_001;\\n        for (int[] row : matrix) {\\n            for (int num : row) {\\n                if (num < 0) {\\n                    negativeCount++;\\n                }\\n                absSum += Math.abs(num);\\n                minAbs = Math.min(minAbs, Math.abs(num));\\n            }\\n        }\\n        // if you have a 0 or even negatives, then all negatives can be flipped to be positive\\n        // ELSE, just pick the minimum absolute number and keep that as negative.\\n        return minAbs == 0 || negativeCount % 2 == 0 ? absSum : absSum - 2 * minAbs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long absSum = 0L;\\n        int negativeCount = 0;\\n        int minAbs = 100_001;\\n        for (int[] row : matrix) {\\n            for (int num : row) {\\n                if (num < 0) {\\n                    negativeCount++;\\n                }\\n                absSum += Math.abs(num);\\n                minAbs = Math.min(minAbs, Math.abs(num));\\n            }\\n        }\\n        // if you have a 0 or even negatives, then all negatives can be flipped to be positive\\n        // ELSE, just pick the minimum absolute number and keep that as negative.\\n        return minAbs == 0 || negativeCount % 2 == 0 ? absSum : absSum - 2 * minAbs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443157,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) \\n    {\\n        long long sum=0, neg=0, mn=INT_MAX;\\n        for(int x=0; x<matrix.size(); x++)\\n        {\\n            for(int y=0; y<matrix[x].size(); y++)\\n            {\\n                sum+=abs(matrix[x][y]);\\n                if(matrix[x][y]<0) neg++;\\n                mn=min(mn,(long long)abs(matrix[x][y]));\\n            }\\n        }\\n        if(neg%2) sum-=(2*mn);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) \\n    {\\n        long long sum=0, neg=0, mn=INT_MAX;\\n        for(int x=0; x<matrix.size(); x++)\\n        {\\n            for(int y=0; y<matrix[x].size(); y++)\\n            {\\n                sum+=abs(matrix[x][y]);\\n                if(matrix[x][y]<0) neg++;\\n                mn=min(mn,(long long)abs(matrix[x][y]));\\n            }\\n        }\\n        if(neg%2) sum-=(2*mn);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435277,
                "title": "easy-python-solution-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can perform any number of operations, then we will always be able to continue \"moving\" the negative values around until they collide with another negative value. \\n\\nWe will always be able to pair all negative values if the total number of negative elements is even, or be left with a single negative value if the number of negative elements is odd. In that case, we will make sure we leave the element with the smallest absolute value negative.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith one pass through the matrix, we can collect all the information we need, which includes:\\n\\n- The sum the absolute values of all the elements in the matrix\\n- The element with the smallest absolute value\\n- The count of negative elements\\n\\nFrom those values, if the count of negative elements is odd, we can return the sum of the absolute values of all elements, minus the smallest element times 2 (we multiply by two because we are going from a positive value to a negative value, which is a reduction of double its absolute value). If the count of negative elements is even, then we will be able to pair all negative values and therefore just return the sum of the absolute value of all elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the number of elements in the matrix (one pass)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n\\n        negative_elements = 0\\n        elements_sum = 0\\n        min_element = sys.maxsize\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                element = matrix[i][j]\\n                elements_sum += abs(element)\\n                if element < 0:\\n                    negative_elements += 1\\n                min_element = min(min_element, abs(element))\\n        \\n        if negative_elements % 2 != 0:\\n            return elements_sum - (2 * min_element)\\n        else:\\n            return elements_sum\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n\\n        negative_elements = 0\\n        elements_sum = 0\\n        min_element = sys.maxsize\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                element = matrix[i][j]\\n                elements_sum += abs(element)\\n                if element < 0:\\n                    negative_elements += 1\\n                min_element = min(min_element, abs(element))\\n        \\n        if negative_elements % 2 != 0:\\n            return elements_sum - (2 * min_element)\\n        else:\\n            return elements_sum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379403,
                "title": "c",
                "content": "# Intuition\\nIf we can split signs of two agcent cells we can split signs of any two cells. So, if number of negative numbers is even the result is the sum of absolute values, but it is odd we need to subscribe the minimal number from the sum. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) \\n    {\\n        long result = 0;\\n        long min = int.MaxValue;\\n        int negativeCount = 0;\\n\\n        for(int i = 0; i < matrix.Length; ++i)\\n        {\\n            for(int j = 0; j < matrix[0].Length; ++j)\\n            {\\n                result += Math.Abs(matrix[i][j]);\\n                min = Math.Min(min, Math.Abs(matrix[i][j]));\\n                if(matrix[i][j] < 0)\\n                {\\n                    negativeCount++;\\n                }\\n            }\\n        }\\n\\n        return negativeCount % 2 == 0 ? result : result - 2*min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) \\n    {\\n        long result = 0;\\n        long min = int.MaxValue;\\n        int negativeCount = 0;\\n\\n        for(int i = 0; i < matrix.Length; ++i)\\n        {\\n            for(int j = 0; j < matrix[0].Length; ++j)\\n            {\\n                result += Math.Abs(matrix[i][j]);\\n                min = Math.Min(min, Math.Abs(matrix[i][j]));\\n                if(matrix[i][j] < 0)\\n                {\\n                    negativeCount++;\\n                }\\n            }\\n        }\\n\\n        return negativeCount % 2 == 0 ? result : result - 2*min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378954,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) \\n    {\\n        long long ans=0;\\n        int mn=INT_MAX;\\n        long long negCnt=0;\\n        int zero=0;\\n        for (int i=0;i<matrix.size();i++)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (matrix[i][j]<0) negCnt++;\\n                if (matrix[i][j]==0) zero++;\\n                ans+=(long long)abs(matrix[i][j]);\\n                mn=min(mn,abs(matrix[i][j]));\\n            }\\n        }\\n        if (negCnt%2==1)\\n        {\\n            if (zero==0)\\n            {\\n              ans-=mn;\\n              ans-=mn;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) \\n    {\\n        long long ans=0;\\n        int mn=INT_MAX;\\n        long long negCnt=0;\\n        int zero=0;\\n        for (int i=0;i<matrix.size();i++)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (matrix[i][j]<0) negCnt++;\\n                if (matrix[i][j]==0) zero++;\\n                ans+=(long long)abs(matrix[i][j]);\\n                mn=min(mn,abs(matrix[i][j]));\\n            }\\n        }\\n        if (negCnt%2==1)\\n        {\\n            if (zero==0)\\n            {\\n              ans-=mn;\\n              ans-=mn;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304268,
                "title": "python-super-easy-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        ans = 0\\n        m = float(\"inf\")\\n        n = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] < 0:\\n                    n +=1\\n                ans += abs(matrix[i][j])\\n                m = min(m, abs(matrix[i][j]))\\n        \\n\\n        if n % 2 == 0:\\n            return ans\\n        \\n        return  ans - 2 * m \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        ans = 0\\n        m = float(\"inf\")\\n        n = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] < 0:\\n                    n +=1\\n                ans += abs(matrix[i][j])\\n                m = min(m, abs(matrix[i][j]))\\n        \\n\\n        if n % 2 == 0:\\n            return ans\\n        \\n        return  ans - 2 * m \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301845,
                "title": "c-invariant",
                "content": "# Intuition\\nthe num of nagtive value % 2 is invariant for the operation.\\nso 2 cases of num of nagtive value % 2:\\ncase 0: all the value can be transform to positive\\ncase 1: at least one value is nagtive, so greedly, choose the one with smallest absolute value.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0, xmin = 1e6, numNag = 0;\\n        for(auto& v: matrix) for(auto x:v){\\n            if(x<0) numNag++;\\n            xmin = min<long long>(xmin, abs(x));\\n            sum += abs(x);\\n        }\\n        if(numNag % 2 == 0) return sum;\\n        else return sum - xmin*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0, xmin = 1e6, numNag = 0;\\n        for(auto& v: matrix) for(auto x:v){\\n            if(x<0) numNag++;\\n            xmin = min<long long>(xmin, abs(x));\\n            sum += abs(x);\\n        }\\n        if(numNag % 2 == 0) return sum;\\n        else return sum - xmin*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253873,
                "title": "java-greedy-o-n-clear-explanation-and-easy-to-understand-code",
                "content": "# Intuition\\nRule 1: two negatives turn to two positives \\nRule 2: one positive and one negative can swap the sign with each other \\nSummarize: ultimately, we can group all negative signs together by using rule 2 and turn all of them into one negative with rule 1, so if there are odd negative signs, only one will be left, otherwisde all of them will turn to positive signs \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int numNegative = 0;\\n        int minNumber = Integer.MAX_VALUE;\\n        long negativeSum = 0;\\n        long positiveSum = 0;\\n        for (int row = 0; row < matrix.length; row++) {\\n            for (int col = 0; col < matrix[0].length; col++) {\\n                if (matrix[row][col] <= 0) {\\n                    numNegative += 1;\\n                    negativeSum += matrix[row][col];      \\n                } else {\\n                    positiveSum += matrix[row][col];\\n                }\\n                 minNumber = Math.min(minNumber, Math.abs(matrix[row][col]));\\n            }\\n        }\\n        if (numNegative % 2 == 0) {\\n            return positiveSum + Math.abs(negativeSum);\\n        }\\n        return positiveSum - 2 * minNumber + Math.abs(negativeSum);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int numNegative = 0;\\n        int minNumber = Integer.MAX_VALUE;\\n        long negativeSum = 0;\\n        long positiveSum = 0;\\n        for (int row = 0; row < matrix.length; row++) {\\n            for (int col = 0; col < matrix[0].length; col++) {\\n                if (matrix[row][col] <= 0) {\\n                    numNegative += 1;\\n                    negativeSum += matrix[row][col];      \\n                } else {\\n                    positiveSum += matrix[row][col];\\n                }\\n                 minNumber = Math.min(minNumber, Math.abs(matrix[row][col]));\\n            }\\n        }\\n        if (numNegative % 2 == 0) {\\n            return positiveSum + Math.abs(negativeSum);\\n        }\\n        return positiveSum - 2 * minNumber + Math.abs(negativeSum);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242281,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_matrix_sum(matrix: Vec<Vec<i32>>) -> i64 {\\n        let matrix = matrix\\n            .iter()\\n            .map(|row| row.iter().map(|&x| x as i64).collect::<Vec<_>>())\\n            .collect::<Vec<_>>();\\n        let mut neg = false;\\n        let mut sum = 0_i64;\\n        let mut mini = i64::MAX;\\n        for row in matrix.iter() {\\n            for &x in row.iter() {\\n                if x < 0 {\\n                    neg = !neg;\\n                }\\n                let x = x.abs();\\n                sum += x;\\n                if x < mini {\\n                    mini = x;\\n                }\\n            }\\n        }\\n        if neg {\\n            sum -= 2 * mini;\\n        }\\n        sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_matrix_sum(matrix: Vec<Vec<i32>>) -> i64 {\\n        let matrix = matrix\\n            .iter()\\n            .map(|row| row.iter().map(|&x| x as i64).collect::<Vec<_>>())\\n            .collect::<Vec<_>>();\\n        let mut neg = false;\\n        let mut sum = 0_i64;\\n        let mut mini = i64::MAX;\\n        for row in matrix.iter() {\\n            for &x in row.iter() {\\n                if x < 0 {\\n                    neg = !neg;\\n                }\\n                let x = x.abs();\\n                sum += x;\\n                if x < mini {\\n                    mini = x;\\n                }\\n            }\\n        }\\n        if neg {\\n            sum -= 2 * mini;\\n        }\\n        sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3175469,
                "title": "very-simple-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic long maxMatrixSum(int[][] matrix) {\\n        int n = matrix[0].length, minValue = Integer.MAX_VALUE, nagativeStatus = 1;\\n        long sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sum += Math.abs(matrix[i][j]);\\n                if (matrix[i][j] < 0) nagativeStatus *= -1;\\n                minValue = Math.min(minValue, Math.abs(matrix[i][j]));\\n            } \\n        }\\n        return sum - minValue +  nagativeStatus * minValue;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long maxMatrixSum(int[][] matrix) {\\n        int n = matrix[0].length, minValue = Integer.MAX_VALUE, nagativeStatus = 1;\\n        long sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sum += Math.abs(matrix[i][j]);\\n                if (matrix[i][j] < 0) nagativeStatus *= -1;\\n                minValue = Math.min(minValue, Math.abs(matrix[i][j]));\\n            } \\n        }\\n        return sum - minValue +  nagativeStatus * minValue;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172792,
                "title": "easy-to-understand-c-solution-time-complexity-o-n-2-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif there are even negative number then they all can become positive by applying operation some number of times .\\nbut if there are odd negative number then one negative number  will always left in the matrix and that number should be minimum ```abs(number)  ``` so to make the sum of matrix maximum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        ll sum=0;\\n        ll n = matrix.size();\\n        ll min_pos_ele = INT_MAX;\\n        ll count_negative = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j] < 0){\\n                    count_negative++;  \\n                }\\n                sum += abs(matrix[i][j]);\\n                if(abs(matrix[i][j]) < min_pos_ele){\\n                      min_pos_ele = abs(matrix[i][j]);\\n                }\\n            }\\n        }\\n        if(count_negative % 2==1) sum -= 2*min_pos_ele;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```abs(number)  ```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        ll sum=0;\\n        ll n = matrix.size();\\n        ll min_pos_ele = INT_MAX;\\n        ll count_negative = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j] < 0){\\n                    count_negative++;  \\n                }\\n                sum += abs(matrix[i][j]);\\n                if(abs(matrix[i][j]) < min_pos_ele){\\n                      min_pos_ele = abs(matrix[i][j]);\\n                }\\n            }\\n        }\\n        if(count_negative % 2==1) sum -= 2*min_pos_ele;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170890,
                "title": "c-count-of-negative-even-return-sum-odd-return-sum-smallest-num",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long ans = 0, smallest = INT_MAX, negCount = 0;\\n        int negCount = 0;\\n        for (int i = 0; i < matrix.size(); ++i)\\n            for (int y = 0; y < matrix[0].size(); ++y){\\n                ans += abs(matrix[i][y]);\\n                smallest = min(smallest, abs(matrix[i][y]));\\n                negCount += matrix[i][y] < 0;\\n            }\\n        return negCount % 2 == 0 ? ans : ans - 2 * smallest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long ans = 0, smallest = INT_MAX, negCount = 0;\\n        int negCount = 0;\\n        for (int i = 0; i < matrix.size(); ++i)\\n            for (int y = 0; y < matrix[0].size(); ++y){\\n                ans += abs(matrix[i][y]);\\n                smallest = min(smallest, abs(matrix[i][y]));\\n                negCount += matrix[i][y] < 0;\\n            }\\n        return negCount % 2 == 0 ? ans : ans - 2 * smallest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088994,
                "title": "python-3-line-solution-negative-frequency-is-even-odd",
                "content": "```\\ndef maxMatrixSum(self, mat: List[List[int]]) -> int:\\n\\tneg = sum(x<1 for r in mat for x in r)%2\\n\\tm = min(abs(x) for r in mat for x in r) if neg else 0\\n\\treturn sum(abs(x) for r in mat for x in r)-2*m\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxMatrixSum(self, mat: List[List[int]]) -> int:\\n\\tneg = sum(x<1 for r in mat for x in r)%2\\n\\tm = min(abs(x) for r in mat for x in r) if neg else 0\\n\\treturn sum(abs(x) for r in mat for x in r)-2*m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3063079,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n       \\n        long long sum = 0;\\n        int count = 0;\\n        int mini = INT_MAX;\\n        int n = matrix.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                sum += abs(matrix[i][j]);\\n                if(matrix[i][j] < 0){\\n                    count++;\\n                }\\n                mini = min(mini, abs(matrix[i][j]));\\n                \\n                \\n            }\\n        }\\n        \\n        if(count == 0 || count%2 == 0){\\n            return sum;\\n        }\\n        return sum - 2*mini;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n       \\n        long long sum = 0;\\n        int count = 0;\\n        int mini = INT_MAX;\\n        int n = matrix.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                sum += abs(matrix[i][j]);\\n                if(matrix[i][j] < 0){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3059921,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int count=0;\\n        long sum=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n       for(int i=0;i<matrix.length;i++){\\n           for(int j=0;j<matrix[0].length;j++){\\n               if(matrix[i][j]<0){\\n                   count++;\\n               }\\n              \\n               pq.add(Math.abs(matrix[i][j]));\\n               sum+=Math.abs(matrix[i][j]);\\n               \\n           }\\n       }\\n       if(count%2==0){\\n           return sum;\\n       }\\n       return sum-(2*pq.poll());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int count=0;\\n        long sum=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n       for(int i=0;i<matrix.length;i++){\\n           for(int j=0;j<matrix[0].length;j++){\\n               if(matrix[i][j]<0){\\n                   count++;\\n               }\\n              \\n               pq.add(Math.abs(matrix[i][j]));\\n               sum+=Math.abs(matrix[i][j]);\\n               \\n           }\\n       }\\n       if(count%2==0){\\n           return sum;\\n       }\\n       return sum-(2*pq.poll());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059331,
                "title": "basic-simple-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple C++ Approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Basic] Simple C++ Approach\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n        \\n        int total_neg = 0; \\n        int max_neg = INT_MIN; \\n        int least_pos = INT_MAX; \\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j] < 0){\\n                    total_neg++; \\n                    max_neg = max(max_neg, matrix[i][j]); \\n                }else{\\n                    least_pos = min(least_pos, matrix[i][j]); \\n                }\\n            }\\n        }\\n        long long ans = 0 ;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                ans += abs(matrix[i][j]); \\n            }\\n        }\\n        if(total_neg%2 == 0) return ans; \\n        \\n        if(abs(max_neg) > least_pos){\\n           ans -= (long long)2*least_pos; \\n        }else{\\n           ans -= (long long)2*abs(max_neg); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n        \\n        int total_neg = 0; \\n        int max_neg = INT_MIN; \\n        int least_pos = INT_MAX; \\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j] < 0){\\n                    total_neg++; \\n                    max_neg = max(max_neg, matrix[i][j]); \\n                }else{\\n                    least_pos = min(least_pos, matrix[i][j]); \\n                }\\n            }\\n        }\\n        long long ans = 0 ;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                ans += abs(matrix[i][j]); \\n            }\\n        }\\n        if(total_neg%2 == 0) return ans; \\n        \\n        if(abs(max_neg) > least_pos){\\n           ans -= (long long)2*least_pos; \\n        }else{\\n           ans -= (long long)2*abs(max_neg); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054715,
                "title": "c-solution-with-comments-easy-explanation",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n  = matrix.size();\\n        int m = matrix[0].size();\\n\\n        //basically in this ques, we dont need to change each number\\n        //just calculate the sum]\\n        //if the number is +ve, add such\\n        //if the number is -ve, add by multiplying -1 to it,\\n        long long sum = 0; //this will store the sum \\n        long long mini = INT_MAX; //it will store the minimum element, if the no. of -ve numbers are odd\\n        long long count = 0;  //will store the number of -ve numbers \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                long long curr = abs(matrix[i][j]);\\n                mini = min(mini, curr);\\n                if(matrix[i][j] < 0){\\n                    count++;\\n                }\\n                sum += curr;\\n            }\\n        }\\n\\n        if(count % 2 == 0){\\n            return sum;\\n        }\\n        else{\\n            return (sum - 2*(mini));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n  = matrix.size();\\n        int m = matrix[0].size();\\n\\n        //basically in this ques, we dont need to change each number\\n        //just calculate the sum]\\n        //if the number is +ve, add such\\n        //if the number is -ve, add by multiplying -1 to it,\\n        long long sum = 0; //this will store the sum \\n        long long mini = INT_MAX; //it will store the minimum element, if the no. of -ve numbers are odd\\n        long long count = 0;  //will store the number of -ve numbers \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                long long curr = abs(matrix[i][j]);\\n                mini = min(mini, curr);\\n                if(matrix[i][j] < 0){\\n                    count++;\\n                }\\n                sum += curr;\\n            }\\n        }\\n\\n        if(count % 2 == 0){\\n            return sum;\\n        }\\n        else{\\n            return (sum - 2*(mini));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047324,
                "title": "easy-soln-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n//Intitution-\\n// if count of negative numbers is even then we can cancel each other and abs sum of matrix will be ans \\n// if count of negative numbers is odd then our aim is to make min element negative \\n// which is left out after cancelling others ,so ans =absolute value sum-2*minimum_element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int minimum_element=INT_MAX;\\n        int count_negative=0;\\n        for(auto it:matrix)\\n        {\\n            for(auto element:it)\\n            {\\n                if(element<0)\\n                count_negative++;\\n                sum+=abs(element);//absolute value sum\\n                minimum_element=min(minimum_element,abs(element));\\n            }\\n            \\n        }\\n        if(count_negative%2==0)//then negative will cancel\\n        return sum;\\n        else//min_element will be left as negative\\n        return sum-2*minimum_element;\\n\\n    }\\n};\\n//Intitution-\\n// if count of negative numbers is even then we can cancel each other and abs sum of matrix will be ans \\n// if count of negative numbers is odd then our aim is to make min element negative \\n// which is left out after cancelling others ,so ans =absolute value sum-2*minimum_element\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int minimum_element=INT_MAX;\\n        int count_negative=0;\\n        for(auto it:matrix)\\n        {\\n            for(auto element:it)\\n            {\\n                if(element<0)\\n                count_negative++;\\n                sum+=abs(element);//absolute value sum\\n                minimum_element=min(minimum_element,abs(element));\\n            }\\n            \\n        }\\n        if(count_negative%2==0)//then negative will cancel\\n        return sum;\\n        else//min_element will be left as negative\\n        return sum-2*minimum_element;\\n\\n    }\\n};\\n//Intitution-\\n// if count of negative numbers is even then we can cancel each other and abs sum of matrix will be ans \\n// if count of negative numbers is odd then our aim is to make min element negative \\n// which is left out after cancelling others ,so ans =absolute value sum-2*minimum_element\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045406,
                "title": "java-solution-greedy-o-1-space-complexity",
                "content": "# Intuition\\nFirst things that comes to my mind is we can reduce the couple of non +ve elements into +ve elements.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere Count the non +ve elements ans sum of the matrix then if count of non +ve elements is odd then we have it twice from sum(Twice because you have already add it to your answer)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int c=0, min=Integer.MAX_VALUE;\\n        long sum=0;\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]<=0) c++; \\n                matrix[i][j]=Math.abs(matrix[i][j]);\\n                sum+=matrix[i][j];\\n                min=Math.min(min, matrix[i][j]);\\n            }\\n        }\\n        if(c%2==1) sum-=(2*min);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int c=0, min=Integer.MAX_VALUE;\\n        long sum=0;\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]<=0) c++; \\n                matrix[i][j]=Math.abs(matrix[i][j]);\\n                sum+=matrix[i][j];\\n                min=Math.min(min, matrix[i][j]);\\n            }\\n        }\\n        if(c%2==1) sum-=(2*min);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038670,
                "title": "c-greedy-100-faster",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0;\\n        int cntNeg = 0,Min=INT_MAX;\\n        for(auto x:matrix){\\n            for(auto y:x){\\n                if(y<0){\\n                    sum -= y;\\n                    cntNeg+=1;\\n                    if(-y<Min){\\n                        Min = -y;\\n                    }\\n                }\\n                else {sum += y;Min = min(Min,y);}\\n            }\\n        }\\n        if(cntNeg%2){\\n            sum -= 2*Min;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0;\\n        int cntNeg = 0,Min=INT_MAX;\\n        for(auto x:matrix){\\n            for(auto y:x){\\n                if(y<0){\\n                    sum -= y;\\n                    cntNeg+=1;\\n                    if(-y<Min){\\n                        Min = -y;\\n                    }\\n                }\\n                else {sum += y;Min = min(Min,y);}\\n            }\\n        }\\n        if(cntNeg%2){\\n            sum -= 2*Min;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036869,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0, neg = 0;\\n        int min = abs(matrix[0][0]);\\n        for(int i=0; i < matrix.size(); i++){\\n            for(int j=0; j < matrix[0].size(); j++){\\n                sum += abs(matrix[i][j]);\\n                if(abs(matrix[i][j]) < min)\\n                    min = abs(matrix[i][j]);\\n                if(matrix[i][j] < 0)\\n                    neg++;\\n            }\\n        }\\n        return (neg & 1 ? sum - 2 * min : sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum = 0, neg = 0;\\n        int min = abs(matrix[0][0]);\\n        for(int i=0; i < matrix.size(); i++){\\n            for(int j=0; j < matrix[0].size(); j++){\\n                sum += abs(matrix[i][j]);\\n                if(abs(matrix[i][j]) < min)\\n                    min = abs(matrix[i][j]);\\n                if(matrix[i][j] < 0)\\n                    neg++;\\n            }\\n        }\\n        return (neg & 1 ? sum - 2 * min : sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036102,
                "title": "python-checking-parity-of-minus-100-faster",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        parity = 0\\n        res = 0\\n        minv = float(\\'inf\\')\\n        for row in matrix:\\n            for num in row:\\n                if num < 0: \\n                    parity = 1 - parity\\n                res += abs(num)\\n                if minv > abs(num):\\n                    minv = abs(num)\\n        if parity:\\n            return res - 2*minv \\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        parity = 0\\n        res = 0\\n        minv = float(\\'inf\\')\\n        for row in matrix:\\n            for num in row:\\n                if num < 0: \\n                    parity = 1 - parity\\n                res += abs(num)\\n                if minv > abs(num):\\n                    minv = abs(num)\\n        if parity:\\n            return res - 2*minv \\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021826,
                "title": "c-count-negative-numbers",
                "content": "# Approach\\nOnly need to consider the negative numbers are odd or even. If is odd number, we suppose that the minimum absulute number of the matrix is negative number and othews are positive number. If is even numbber, we suppose that all the number are positive number.\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) {\\n        var set = new List<long>();\\n        bool sign = true;\\n        long sum = 0;\\n        for (var i = 0; i < matrix.Length; i++)  \\n        {\\n            for (var j = 0; j < matrix[i].Length; j++) \\n            {\\n                if (matrix[i][j] < 0)\\n                {\\n                    sign = (!sign);\\n                }\\n\\n                set.Add(Math.Abs(matrix[i][j]));\\n            }\\n        }\\n\\n        sum = set.Sum();\\n\\n        if (!sign)\\n        {\\n            sum -= 2 * set.Min();\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) {\\n        var set = new List<long>();\\n        bool sign = true;\\n        long sum = 0;\\n        for (var i = 0; i < matrix.Length; i++)  \\n        {\\n            for (var j = 0; j < matrix[i].Length; j++) \\n            {\\n                if (matrix[i][j] < 0)\\n                {\\n                    sign = (!sign);\\n                }\\n\\n                set.Add(Math.Abs(matrix[i][j]));\\n            }\\n        }\\n\\n        sum = set.Sum();\\n\\n        if (!sign)\\n        {\\n            sum -= 2 * set.Min();\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991974,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        int neg = 0;\\n\\n        long long sum = 0;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < matrix.size(); i++) {\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(matrix[i][j] < 0) neg++;\\n                sum += abs(matrix[i][j]);\\n                mini = min(mini, abs(matrix[i][j]));\\n            }\\n        }\\n\\n        return sum - (neg % 2 == 0 ? 0 : 2 * mini);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        int neg = 0;\\n\\n        long long sum = 0;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < matrix.size(); i++) {\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(matrix[i][j] < 0) neg++;\\n                sum += abs(matrix[i][j]);\\n                mini = min(mini, abs(matrix[i][j]));\\n            }\\n        }\\n\\n        return sum - (neg % 2 == 0 ? 0 : 2 * mini);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988009,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer[][]} matrix\\n# @return {Integer}\\ndef max_matrix_sum(matrix)\\n    matrix_sum, negs, mini = 0, 0, nil\\n\\n    matrix.each do |row|\\n        pos_row = row.map do |val|\\n            negs += 1 if val < 0\\n            val.abs\\n        end\\n\\n        matrix_sum += pos_row.sum\\n        mini = mini == nil ? pos_row.min : [pos_row.min, mini].min\\n    end\\n    \\n    return negs % 2 == 0 ? matrix_sum : matrix_sum - mini*2\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} matrix\\n# @return {Integer}\\ndef max_matrix_sum(matrix)\\n    matrix_sum, negs, mini = 0, 0, nil\\n\\n    matrix.each do |row|\\n        pos_row = row.map do |val|\\n            negs += 1 if val < 0\\n            val.abs\\n        end\\n\\n        matrix_sum += pos_row.sum\\n        mini = mini == nil ? pos_row.min : [pos_row.min, mini].min\\n    end\\n    \\n    return negs % 2 == 0 ? matrix_sum : matrix_sum - mini*2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2964202,
                "title": "clean-and-simple-and-beginners-friendly-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int mini=INT_MAX;\\n        int n =matrix.size();\\n        int cnt=0;\\n        int m= matrix[0].size();\\n        for(int i=0;i<n; i++) {\\n            for(int j=0;j<m;j++) {\\n                sum+=abs(matrix[i][j]);\\n                mini=min(mini,abs(matrix[i][j]));\\n                if(matrix[i][j]<0)cnt++;\\n            }\\n        }\\n        if(cnt%2==0)return sum;\\n        else return sum-abs(2*mini);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int mini=INT_MAX;\\n        int n =matrix.size();\\n        int cnt=0;\\n        int m= matrix[0].size();\\n        for(int i=0;i<n; i++) {\\n            for(int j=0;j<m;j++) {\\n                sum+=abs(matrix[i][j]);\\n                mini=min(mini,abs(matrix[i][j]));\\n                if(matrix[i][j]<0)cnt++;\\n            }\\n        }\\n        if(cnt%2==0)return sum;\\n        else return sum-abs(2*mini);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803155,
                "title": "python-greedy",
                "content": "Just count the number of negative values, if it is an odd number, (sum - 2 x min) else just sum\\n\\nWe can move negative numbers all over the board, if they collide, the cancel eachother out. Otherwise they don\\'t.\\n\\n```\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        s = 0\\n        m = inf\\n        odd = False\\n        for r in matrix:\\n            for v in r:\\n                if v < 0:\\n                    v = -v\\n                    odd = not odd\\n                if v < m:\\n                    m = v\\n                s += v\\n        return s - (2*m if odd else 0)\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        s = 0\\n        m = inf\\n        odd = False\\n        for r in matrix:\\n            for v in r:\\n                if v < 0:\\n                    v = -v\\n                    odd = not odd\\n                if v < m:\\n                    m = v\\n                s += v\\n        return s - (2*m if odd else 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2787330,
                "title": "c",
                "content": "Runtime: 234 ms, faster than 100.00% of C online submissions for Maximum Matrix Sum.\\nMemory Usage: 12.9 MB, less than 100.00% of C online submissions for Maximum Matrix Sum.\\n```\\nlong long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    long long sum = 0;\\n    int nonPositive = 0;\\n    int min = INT_MAX;\\n    for(int i = 0; i < matrixSize; i++){\\n        for(int j = 0; j < matrixSize; j++){\\n            if(matrix[i][j] <= 0){\\n                nonPositive++;\\n                sum += -1 * matrix[i][j];\\n            }\\n            else\\n                sum +=  matrix[i][j];\\n            min = fmin(min, fabs(matrix[i][j]));\\n        }        \\n    }\\n    if(nonPositive % 2 == 0)\\n        return sum;\\n    else\\n        return sum - 2 * min;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    long long sum = 0;\\n    int nonPositive = 0;\\n    int min = INT_MAX;\\n    for(int i = 0; i < matrixSize; i++){\\n        for(int j = 0; j < matrixSize; j++){\\n            if(matrix[i][j] <= 0){\\n                nonPositive++;\\n                sum += -1 * matrix[i][j];\\n            }\\n            else\\n                sum +=  matrix[i][j];\\n            min = fmin(min, fabs(matrix[i][j]));\\n        }        \\n    }\\n    if(nonPositive % 2 == 0)\\n        return sum;\\n    else\\n        return sum - 2 * min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2785098,
                "title": "greedy",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        total_sum = 0\\n        arr = []\\n        neg = []\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                arr.append(abs(matrix[i][j]))\\n                if matrix[i][j]<0:\\n                    neg.append(matrix[i][j])\\n        if len(neg)%2 == 0:\\n            return sum(abs(i) for i in arr)\\n        \\n        else:\\n            return sum(abs(i) for i in arr) - 2*min(arr)\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        total_sum = 0\\n        arr = []\\n        neg = []\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                arr.append(abs(matrix[i][j]))\\n                if matrix[i][j]<0:\\n                    neg.append(matrix[i][j])\\n        if len(neg)%2 == 0:\\n            return sum(abs(i) for i in arr)\\n        \\n        else:\\n            return sum(abs(i) for i in arr) - 2*min(arr)\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772390,
                "title": "easy-soln",
                "content": "```C++\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int minVal = INT_MAX;\\n        long long sum = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<m; j++){\\n                sum += abs(matrix[i][j]);\\n                if(matrix[i][j]<0)\\n                    count++;\\n                minVal = min(minVal, abs(matrix[i][j]));   \\n            }\\n        }\\n        \\n        if(count%2==0)\\n            return sum;\\n        else\\n            return sum - 2 * minVal;\\n    }\\n};\\n```\\n\\nMore discussion: https://leetcode.com/problems/maximum-matrix-sum/discuss/1417606/C%2B%2B-The-basic-idea-is-to-eliminate-negative-signs",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int minVal = INT_MAX;\\n        long long sum = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<m; j++){\\n                sum += abs(matrix[i][j]);\\n                if(matrix[i][j]<0)\\n                    count++;\\n                minVal = min(minVal, abs(matrix[i][j]));   \\n            }\\n        }\\n        \\n        if(count%2==0)\\n            return sum;\\n        else\\n            return sum - 2 * minVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718577,
                "title": "very-easy-solution-java-for-beginners",
                "content": "Step 1 :-> FIRST COUNT ALL NEGATIVE NUMBERS IN THE MATRIX \\n\\nStep 2 :-> IF NUMBER OF NEGATIVE INTEGERS IS EVEN THEN SIMPLY GIVE THE SUM OF THE MATRIX AS ALL NEGATIVE NUMBERS WILL BECOME POSITIVE \\n\\nStep 3 -> IF NUMBER OF NEGATIVE INTEGERS IS ODD THEN FIND THE MINIMUM NUMBER FROM THE MATRIX THEN FIND THE SUM OF MATRIX  AND PERFORM THE FOLLOWING OPERATION \\nSUM -= 2*MINIMUM ;\\n\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int countNegative = 0 ;\\n        for(int[] inner : matrix){\\n            for(int i : inner){\\n                if(i < 0) countNegative++ ;\\n            }\\n        }\\n        \\n        long sum = 0 ;      \\n        if(countNegative%2 == 0 || countNegative == 0){\\n            for(int[] inner : matrix){\\n                for(int i : inner){\\n                    if(i < 0) sum += Math.abs(i);\\n                    else sum += i ;\\n                }\\n            }\\n        } \\n        else {\\n            int min = Integer.MAX_VALUE ;\\n            for(int[] inner : matrix){\\n                for(int i : inner){\\n                    min = Math.min(min,Math.abs(i));\\n                }\\n            }\\n            \\n            for(int[] inner : matrix){\\n                for(int i : inner){\\n                    if(i < 0) sum += Math.abs(i);\\n                    else sum += i ;\\n                }\\n            }\\n            \\n            sum -= 2*min ;\\n        }\\n        \\n        return sum ;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int countNegative = 0 ;\\n        for(int[] inner : matrix){\\n            for(int i : inner){\\n                if(i < 0) countNegative++ ;\\n            }\\n        }\\n        \\n        long sum = 0 ;      \\n        if(countNegative%2 == 0 || countNegative == 0){\\n            for(int[] inner : matrix){\\n                for(int i : inner){\\n                    if(i < 0) sum += Math.abs(i);\\n                    else sum += i ;\\n                }\\n            }\\n        } \\n        else {\\n            int min = Integer.MAX_VALUE ;\\n            for(int[] inner : matrix){\\n                for(int i : inner){\\n                    min = Math.min(min,Math.abs(i));\\n                }\\n            }\\n            \\n            for(int[] inner : matrix){\\n                for(int i : inner){\\n                    if(i < 0) sum += Math.abs(i);\\n                    else sum += i ;\\n                }\\n            }\\n            \\n            sum -= 2*min ;\\n        }\\n        \\n        return sum ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718078,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long int tempSum = 0;\\n        int count = 0;\\n        int min = INT_MAX;\\n        for(int i=0;i<matrix.size();i++){\\n            long long int sum = 0;\\n            for(int j=0;j<matrix[i].size();j++){                 \\n                if(matrix[i][j]<0){\\n                    matrix[i][j] *= (-1);\\n                    count++;\\n                }\\n                if(min>matrix[i][j]){\\n                    min=matrix[i][j];\\n                }\\n                sum += matrix[i][j];  \\n            }\\n            tempSum+=sum;\\n        }\\n        if(count%2==0){\\n            return tempSum;\\n        }\\n        else{\\n            return tempSum-(2*min);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long int tempSum = 0;\\n        int count = 0;\\n        int min = INT_MAX;\\n        for(int i=0;i<matrix.size();i++){\\n            long long int sum = 0;\\n            for(int j=0;j<matrix[i].size();j++){                 \\n                if(matrix[i][j]<0){\\n                    matrix[i][j] *= (-1);\\n                    count++;\\n                }\\n                if(min>matrix[i][j]){\\n                    min=matrix[i][j];\\n                }\\n                sum += matrix[i][j];  \\n            }\\n            tempSum+=sum;\\n        }\\n        if(count%2==0){\\n            return tempSum;\\n        }\\n        else{\\n            return tempSum-(2*min);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717796,
                "title": "java-greedy-approach-odd-even-occurrences-of-negatives",
                "content": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long maxSum = 0 ;\\n        int negativeCount = 0 ;\\n        int minValue = Integer.MAX_VALUE ;\\n        int n = matrix.length ;\\n        \\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++) {\\n                int val = Math.abs(matrix[i][j]) ;\\n                maxSum += val ;\\n                if (matrix[i][j] < 0) negativeCount++ ;\\n                minValue = Math.min(minValue, val) ;\\n            }\\n        \\n        if (negativeCount % 2 != 0)\\n            maxSum -= (2 * minValue) ;\\n        return maxSum ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long maxSum = 0 ;\\n        int negativeCount = 0 ;\\n        int minValue = Integer.MAX_VALUE ;\\n        int n = matrix.length ;\\n        \\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++) {\\n                int val = Math.abs(matrix[i][j]) ;\\n                maxSum += val ;\\n                if (matrix[i][j] < 0) negativeCount++ ;\\n                minValue = Math.min(minValue, val) ;\\n            }\\n        \\n        if (negativeCount % 2 != 0)\\n            maxSum -= (2 * minValue) ;\\n        return maxSum ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715069,
                "title": "count-ve-and-find-min-thats-all-simple-c",
                "content": "**Plz upvote to motivate this poor :\\')**\\n```\\nlong long maxMatrixSum(vector<vector<int>>& mat) {\\n        int m=INT_MAX,neg=0;\\n        long long sum=0;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]<0){neg++; mat[i][j]=0-mat[i][j];}\\n                m=min(m,mat[i][j]);\\n                sum+=mat[i][j];\\n            }\\n        }\\n        if(m==0 || neg%2==0)return sum;\\n        return sum-2*m;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nlong long maxMatrixSum(vector<vector<int>>& mat) {\\n        int m=INT_MAX,neg=0;\\n        long long sum=0;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]<0){neg++; mat[i][j]=0-mat[i][j];}\\n                m=min(m,mat[i][j]);\\n                sum+=mat[i][j];\\n            }\\n        }\\n        if(m==0 || neg%2==0)return sum;\\n        return sum-2*m;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680042,
                "title": "c-solution-527-ms-faster-than-5-20-o-n-2",
                "content": "~~~\\nlong long maxMatrixSum(vector<vector<int>>& m) {\\n        long long sum=0,min=INT_MAX,flag=0;\\n        for(int i=0;i<m.size();++i){\\n            for(int j=0;j<m[0].size();++j){\\n                sum+=abs(m[i][j]);\\n                if(min>abs(m[i][j]))\\n                    min=abs(m[i][j]);\\n                if(m[i][j]<0)\\n                    flag++;\\n            }\\n        }\\n        if(flag%2==0)\\n            return sum;\\n        return sum-2*min;\\n    }\\n~~~",
                "solutionTags": [
                    "C"
                ],
                "code": "~~~\\nlong long maxMatrixSum(vector<vector<int>>& m) {\\n        long long sum=0,min=INT_MAX,flag=0;\\n        for(int i=0;i<m.size();++i){\\n            for(int j=0;j<m[0].size();++j){\\n                sum+=abs(m[i][j]);\\n                if(min>abs(m[i][j]))\\n                    min=abs(m[i][j]);\\n                if(m[i][j]<0)\\n                    flag++;\\n            }\\n        }\\n        if(flag%2==0)\\n            return sum;\\n        return sum-2*min;\\n    }\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2665668,
                "title": "java-logical-solution",
                "content": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long sumOfAllElements = 0;\\n        int countNegatives = 0, min = Integer.MAX_VALUE;\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = 0;j<matrix.length;j++){\\n                sumOfAllElements += Math.abs(matrix[i][j]);\\n            }\\n        }\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = 0;j<matrix.length;j++){\\n                if(matrix[i][j] < 0){\\n                    countNegatives++;\\n                }\\n            }\\n        }\\n        if(countNegatives % 2 == 0){\\n            return sumOfAllElements;\\n        }\\n        else{\\n            for(int i = 0;i<matrix.length;i++){\\n                for(int j = 0;j<matrix.length;j++){\\n                    min = Math.min(min, Math.abs(matrix[i][j]));\\n                }\\n            }\\n            return sumOfAllElements - 2*(long)min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long sumOfAllElements = 0;\\n        int countNegatives = 0, min = Integer.MAX_VALUE;\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = 0;j<matrix.length;j++){\\n                sumOfAllElements += Math.abs(matrix[i][j]);\\n            }\\n        }\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = 0;j<matrix.length;j++){\\n                if(matrix[i][j] < 0){\\n                    countNegatives++;\\n                }\\n            }\\n        }\\n        if(countNegatives % 2 == 0){\\n            return sumOfAllElements;\\n        }\\n        else{\\n            for(int i = 0;i<matrix.length;i++){\\n                for(int j = 0;j<matrix.length;j++){\\n                    min = Math.min(min, Math.abs(matrix[i][j]));\\n                }\\n            }\\n            return sumOfAllElements - 2*(long)min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661476,
                "title": "do-dfs-on-negative-islands-and-count-islands-with-odd-number-of-nodes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {1,-1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    int dfs(int r,int c,int n,vector<vector<int>>& mat){\\n        mat[r][c] = INT_MAX;\\n        int sz = 1;\\n        for(int i=0;i<4;i++){\\n            int x = r+dx[i], y = c+dy[i];\\n            if(x>=0 and x<n and y>=0 and y<n and mat[x][y]<=0) sz += dfs(x,y,n,mat);\\n        }\\n        return sz;\\n    }\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        long long ans = 0;\\n        int mn = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                mn = min(mn,abs(matrix[i][j]));\\n                ans += abs(matrix[i][j]);\\n            }\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]<0){\\n                    int sz = dfs(i,j,n,matrix);\\n                    if(sz%2) cnt++;\\n                }\\n            }\\n        }\\n        if(cnt%2) ans -= 2*mn;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {1,-1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    int dfs(int r,int c,int n,vector<vector<int>>& mat){\\n        mat[r][c] = INT_MAX;\\n        int sz = 1;\\n        for(int i=0;i<4;i++){\\n            int x = r+dx[i], y = c+dy[i];\\n            if(x>=0 and x<n and y>=0 and y<n and mat[x][y]<=0) sz += dfs(x,y,n,mat);\\n        }\\n        return sz;\\n    }\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        long long ans = 0;\\n        int mn = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                mn = min(mn,abs(matrix[i][j]));\\n                ans += abs(matrix[i][j]);\\n            }\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]<0){\\n                    int sz = dfs(i,j,n,matrix);\\n                    if(sz%2) cnt++;\\n                }\\n            }\\n        }\\n        if(cnt%2) ans -= 2*mn;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636143,
                "title": "c-simple-solution",
                "content": "1. find  total sum of absolute values of all numbers.\\n2. find smallest absolute number.\\n3. find total no. of negative numbers,(for that i have used carry), if 0,return sum. else subtract twice the smallest value from total sum and return it.\\n\\nBy absolute i mean considering only values not signs.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        int min_value=INT_MAX;\\n        int carry=0;\\n       long long int sum=0;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(abs(matrix[i][j])<min_value) \\n                   min_value=abs(matrix[i][j]);\\n                if(matrix[i][j]<0)\\n                {\\n                    carry=1-carry;\\n                }\\n                sum=sum+abs(matrix[i][j]);\\n            }\\n        }\\n        if(carry==1)\\n        {\\n          sum-=(2*min_value);  \\n        }\\n          return sum;\\n    }\\n  \\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        int min_value=INT_MAX;\\n        int carry=0;\\n       long long int sum=0;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(abs(matrix[i][j])<min_value) \\n                   min_value=abs(matrix[i][j]);\\n                if(matrix[i][j]<0)\\n                {\\n                    carry=1-carry;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2630939,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n      int neg=0;\\n        long long sum=0;\\n        int count_zero=0;\\n        int minabs=INT_MAX;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix.size();j++){\\n                sum+=abs(matrix[i][j]);\\n                  minabs=min(abs(matrix[i][j]),minabs);\\n                if(matrix[i][j]<0){\\n                    neg++;\\n                }\\n                if(matrix[i][j]==0) {\\n                    count_zero=1;\\n                }\\n            }\\n        }\\n        cout<<sum<<endl;\\n        if(count_zero)return sum;\\n        else if(neg%2){\\n            sum-=2*minabs;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n      int neg=0;\\n        long long sum=0;\\n        int count_zero=0;\\n        int minabs=INT_MAX;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix.size();j++){\\n                sum+=abs(matrix[i][j]);\\n                  minabs=min(abs(matrix[i][j]),minabs);\\n                if(matrix[i][j]<0){\\n                    neg++;\\n                }\\n                if(matrix[i][j]==0) {\\n                    count_zero=1;\\n                }\\n            }\\n        }\\n        cout<<sum<<endl;\\n        if(count_zero)return sum;\\n        else if(neg%2){\\n            sum-=2*minabs;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2626993,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        minPositiveNum, maxNegativeNum, dim, res, countNegative = math.inf, -math.inf, len(matrix), 0, 0\\n        for row in range(dim):\\n            for col in range(dim):\\n                res += abs(matrix[row][col])\\n                if matrix[row][col] <= 0:\\n                    countNegative += 1\\n                    maxNegativeNum = max(maxNegativeNum, matrix[row][col])\\n                else:\\n                    minPositiveNum = min(minPositiveNum, matrix[row][col])\\n        if countNegative % 2 == 0:\\n            maxNegativeNum = 0\\n        return max(res + 2 * maxNegativeNum, res - 2 * minPositiveNum)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        minPositiveNum, maxNegativeNum, dim, res, countNegative = math.inf, -math.inf, len(matrix), 0, 0\\n        for row in range(dim):\\n            for col in range(dim):\\n                res += abs(matrix[row][col])\\n                if matrix[row][col] <= 0:\\n                    countNegative += 1\\n                    maxNegativeNum = max(maxNegativeNum, matrix[row][col])\\n                else:\\n                    minPositiveNum = min(minPositiveNum, matrix[row][col])\\n        if countNegative % 2 == 0:\\n            maxNegativeNum = 0\\n        return max(res + 2 * maxNegativeNum, res - 2 * minPositiveNum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589981,
                "title": "maximum-negative-and-minimum-positive",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        n = len(matrix)\\n        res = 0\\n        maxneg = float(\\'-inf\\')\\n        minpos = float(\\'inf\\')\\n        ctr = 0\\n        for i in range(n):\\n            for j in range(n):\\n                res += abs(matrix[i][j])\\n                if matrix[i][j] <= 0:\\n                    ctr += 1\\n                    maxneg = max(maxneg, matrix[i][j])\\n                else:\\n                    minpos = min(minpos, matrix[i][j])\\n        if ctr % 2 == 0:\\n            maxneg = 0\\n        return max(res + 2 * maxneg, res - 2 * minpos)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        n = len(matrix)\\n        res = 0\\n        maxneg = float(\\'-inf\\')\\n        minpos = float(\\'inf\\')\\n        ctr = 0\\n        for i in range(n):\\n            for j in range(n):\\n                res += abs(matrix[i][j])\\n                if matrix[i][j] <= 0:\\n                    ctr += 1\\n                    maxneg = max(maxneg, matrix[i][j])\\n                else:\\n                    minpos = min(minpos, matrix[i][j])\\n        if ctr % 2 == 0:\\n            maxneg = 0\\n        return max(res + 2 * maxneg, res - 2 * minpos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584115,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int x=0,n=matrix.size(),mini=INT_MAX;\\n        long long sum=0;\\n        for (int i=0;i<n;i++) {\\n            for (int j=0;j<n;j++) {\\n                sum+=abs(matrix[i][j]);\\n                if (matrix[i][j]<0) x++;\\n                mini=min(mini,abs(matrix[i][j]));\\n            }\\n        }\\n        if (x%2) sum-=2*mini;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int x=0,n=matrix.size(),mini=INT_MAX;\\n        long long sum=0;\\n        for (int i=0;i<n;i++) {\\n            for (int j=0;j<n;j++) {\\n                sum+=abs(matrix[i][j]);\\n                if (matrix[i][j]<0) x++;\\n                mini=min(mini,abs(matrix[i][j]));\\n            }\\n        }\\n        if (x%2) sum-=2*mini;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506643,
                "title": "ts-using-math-instead",
                "content": "Looking at the flip operations we have, we can always invert the current cell + a neightbor. We can also invert using two actions any cell + neighbor of neighbor (the neighbor itself gets flipped twice). We can therefore infer that we can flip any pair => the sum will be the sum over the positive matrix minus the smalles negative number * 2, if the pairity is odd, or 0 when the parity is even.\\n\\n```ts\\nfunction maxMatrixSum(matrix: number[][]): number {\\n    let min = 100_000;\\n    let sum = 0;\\n    let parity = 0\\n    for (let row of matrix) {\\n        for (let x of row) {\\n            if (x < 0) {\\n                parity += 1;\\n                x = -x\\n            }\\n            min = Math.min(x, min);\\n            sum += x\\n        } \\n    }\\n    return sum - (2 * min * (parity%2));\\n};\\n```",
                "solutionTags": [],
                "code": "```ts\\nfunction maxMatrixSum(matrix: number[][]): number {\\n    let min = 100_000;\\n    let sum = 0;\\n    let parity = 0\\n    for (let row of matrix) {\\n        for (let x of row) {\\n            if (x < 0) {\\n                parity += 1;\\n                x = -x\\n            }\\n            min = Math.min(x, min);\\n            sum += x\\n        } \\n    }\\n    return sum - (2 * min * (parity%2));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2479712,
                "title": "simple-logic",
                "content": "Ver simple and easy approch\\n class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int maxy=INT_MAX,cnt=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n               if(matrix[i][j]<0)\\n                   cnt++;\\n                maxy = min(maxy, abs(matrix[i][j]));\\n                                 \\n                sum+=abs(matrix[i][j]);\\n               \\n            }\\n        }\\n        if(cnt%2)\\n            sum-=2*maxy;\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int maxy=INT_MAX,cnt=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n               if(matrix[i][j]<0)\\n                   cnt++;\\n                maxy = min(maxy, abs(matrix[i][j]));\\n                                 \\n                sum+=abs(matrix[i][j]);\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2448033,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        m=float(\\'inf\\')\\n        count=0\\n        sum=0\\n        for i in matrix:\\n            for j in i:\\n                sum+=abs(j)\\n                if j<0:\\n                    count+=1\\n                m=min(m,abs(j))\\n                \\n        if count%2==0:\\n            return sum\\n        else:\\n            return sum-abs(2*m)              \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        m=float(\\'inf\\')\\n        count=0\\n        sum=0\\n        for i in matrix:\\n            for j in i:\\n                sum+=abs(j)\\n                if j<0:\\n                    count+=1\\n                m=min(m,abs(j))\\n                \\n        if count%2==0:\\n            return sum\\n        else:\\n            return sum-abs(2*m)              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446612,
                "title": "cpp",
                "content": "**//Here the main logic is if the number of negative number is even then after operation all the numbers can become positive and if the count is odd then we will make the smallest number negative and then calculate the sum by subtracting the minimum number twice.**\\n```\\nclass Solution { \\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int mini = 1e8;\\n        int cnt=0;\\n        long long int sum=0;\\n        for(int i=0; i<n ;i++){\\n            for(int j=0; j<n;j++){\\n                if(matrix[i][j]<0)cnt++;\\n                mini = min(mini, abs(matrix[i][j]));\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n        if(cnt%2)return sum-(2*mini);\\n        else return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int mini = 1e8;\\n        int cnt=0;\\n        long long int sum=0;\\n        for(int i=0; i<n ;i++){\\n            for(int j=0; j<n;j++){\\n                if(matrix[i][j]<0)cnt++;\\n                mini = min(mini, abs(matrix[i][j]));\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n        if(cnt%2)return sum-(2*mini);\\n        else return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429656,
                "title": "python-easy-solution",
                "content": "Runtime: 1159 ms, faster than 75.45% of Python3 online submissions for Maximum Matrix Sum.\\nMemory Usage: 22.7 MB, less than 71.82% of Python3 online submissions for Maximum Matrix Sum.\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        abs_sum, negative_count, zero_count, min_value = 0, 0, 0, float(inf)\\n        \\n        for row in range(len(matrix)):\\n            for col in range(len(matrix)):\\n                # print(\"Element\", matrix[row][col])\\n                \\n                if matrix[row][col] < 0: \\n                    negative_count += 1\\n                    # print(\"Neg Count\", negative_count)\\n                if matrix[row][col] == 0: \\n                    zero_count = 1\\n                    # print(\"Zero Count\", zero_count)\\n                    \\n                abs_sum += abs(matrix[row][col])\\n                # print(\"Sum\", abs_sum)\\n                min_value = min(min_value, abs(matrix[row][col]))\\n                # print(\"Min\", min_value, \"\\\\n\")\\n                \\n        if negative_count % 2 == 0 or zero_count > 0:\\n            return abs_sum\\n        else:\\n            return abs_sum - (min_value * 2)\\n```\\n\\nTest Case 2:\\nInput: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\\nOutput: 16\\nExplanation: We can follow the following step to reach sum equals 16: Multiply the 2 last elements in the second row by -1.\\n\\nElement 1\\nSum 1\\nMin 1 \\n\\nElement 2\\nSum 3\\nMin 1 \\n\\nElement 3\\nSum 6\\nMin 1 \\n\\nElement -1\\nNeg Count 1\\nSum 7\\nMin 1 \\n\\nElement -2\\nNeg Count 2\\nSum 9\\nMin 1 \\n\\nElement -3\\nNeg Count 3\\nSum 12\\nMin 1 \\n\\nElement 1\\nSum 13\\nMin 1 \\n\\nElement 2\\nSum 15\\nMin 1 \\n\\nElement 3\\nSum 18\\nMin 1 \\n\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        abs_sum, negative_count, zero_count, min_value = 0, 0, 0, float(inf)\\n        \\n        for row in range(len(matrix)):\\n            for col in range(len(matrix)):\\n                # print(\"Element\", matrix[row][col])\\n                \\n                if matrix[row][col] < 0: \\n                    negative_count += 1\\n                    # print(\"Neg Count\", negative_count)\\n                if matrix[row][col] == 0: \\n                    zero_count = 1\\n                    # print(\"Zero Count\", zero_count)\\n                    \\n                abs_sum += abs(matrix[row][col])\\n                # print(\"Sum\", abs_sum)\\n                min_value = min(min_value, abs(matrix[row][col]))\\n                # print(\"Min\", min_value, \"\\\\n\")\\n                \\n        if negative_count % 2 == 0 or zero_count > 0:\\n            return abs_sum\\n        else:\\n            return abs_sum - (min_value * 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406557,
                "title": "simple-c-code-definintely-understandble",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        //if even number of -ve element then it will be definetly terminated and if odd number of -ve element then we need to subtract the -ve number having least absolute value from our ans\\n//the main thing is if ct is odd then -ve sign can be shifted to absolutely smallest value     \\n        long long ans=0;\\n        int ct = 0,minEle = INT_MAX;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                int num = abs(matrix[i][j]);\\n                ans += num;\\n                if(matrix[i][j] < 0){\\n                    ct++;\\n                }\\n                minEle = min(minEle,num);\\n            }\\n        }\\n        if(ct%2) ans -= 2*minEle;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        //if even number of -ve element then it will be definetly terminated and if odd number of -ve element then we need to subtract the -ve number having least absolute value from our ans\\n//the main thing is if ct is odd then -ve sign can be shifted to absolutely smallest value     \\n        long long ans=0;\\n        int ct = 0,minEle = INT_MAX;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                int num = abs(matrix[i][j]);\\n                ans += num;\\n                if(matrix[i][j] < 0){\\n                    ct++;\\n                }\\n                minEle = min(minEle,num);\\n            }\\n        }\\n        if(ct%2) ans -= 2*minEle;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396967,
                "title": "c-simple-c-code-o-n-2",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long mn = INT_MAX, n = matrix.size(), m = matrix[0].size(), ans = 0, cnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(matrix[i][j] < 0)\\n                    cnt++;\\n                mn = min(mn, (long long)abs(matrix[i][j]));\\n                ans += abs(matrix[i][j]);\\n            }\\n        }\\n        //cout << ans << mn;\\n        if(cnt&1)\\n            ans -= 2*mn;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long mn = INT_MAX, n = matrix.size(), m = matrix[0].size(), ans = 0, cnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(matrix[i][j] < 0)\\n                    cnt++;\\n                mn = min(mn, (long long)abs(matrix[i][j]));\\n                ans += abs(matrix[i][j]);\\n            }\\n        }\\n        //cout << ans << mn;\\n        if(cnt&1)\\n            ans -= 2*mn;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2375952,
                "title": "c-solution",
                "content": "Here is my C solution for the same:\\n```\\nint min(int a ,int b);\\n\\nlong long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    int m=matrixSize;\\n     int *n=matrixColSize;\\n     long long sum=0;\\n     int mini=100000;\\n     int cnt=0;\\n     for(int i=0;i<m;i++)\\n     {\\n         for(int j=0;j<*n;j++){\\n             sum+=abs(matrix[i][j]); //counting sum\\n             mini=min(mini,abs(matrix[i][j])); //keeping the recordof minimum number\\n             if(matrix[i][j]<0) //if -ve, then count\\n                 cnt++;\\n         }\\n     }\\n        if(cnt%2==0) \\n            return sum;\\n        else \\n            return sum-2*mini;\\n}\\n\\nint min(int a,int b){\\n    return (a<b)? a : b ;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint min(int a ,int b);\\n\\nlong long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    int m=matrixSize;\\n     int *n=matrixColSize;\\n     long long sum=0;\\n     int mini=100000;\\n     int cnt=0;\\n     for(int i=0;i<m;i++)\\n     {\\n         for(int j=0;j<*n;j++){\\n             sum+=abs(matrix[i][j]); //counting sum\\n             mini=min(mini,abs(matrix[i][j])); //keeping the recordof minimum number\\n             if(matrix[i][j]<0) //if -ve, then count\\n                 cnt++;\\n         }\\n     }\\n        if(cnt%2==0) \\n            return sum;\\n        else \\n            return sum-2*mini;\\n}\\n\\nint min(int a,int b){\\n    return (a<b)? a : b ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2360933,
                "title": "simple-o-n-only-one-or-zero-negative-number-easy-soln",
                "content": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long ans = 0;\\n        int m=INT_MAX;\\n        int f=1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]<0){\\n                    f *= -1;\\n                }\\n                ans += abs(matrix[i][j]);\\n                m = min (m ,abs(matrix[i][j]));\\n            }\\n        }\\n        if(f==-1)\\n            ans -= 2*m;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long ans = 0;\\n        int m=INT_MAX;\\n        int f=1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]<0){\\n                    f *= -1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2345197,
                "title": "java-easy-solution",
                "content": "Logic : We need to count the number of negative integers in the matrix.\\nIf it is even, return sum of absolute value of matrix.\\nIf it is odd, return sum - smallest negative number.\\n\\n```class Solution {\\n    public long maxMatrixSum(int[][] a) {\\n        long res=0;\\n        boolean flag=false;\\n        long min=Integer.MAX_VALUE;\\n        for(int i=0;i < a.length;i++){\\n            for(int j=0;j < a[0].length;j++){\\n                res+=Math.abs(a[i][j]);\\n                min=Math.min(min,Math.abs(a[i][j]));\\n                if(a[i][j]<0){\\n                    flag=!flag;\\n                }\\n            }\\n        }\\n        \\n        if(flag)\\n            res-=2*min;\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long maxMatrixSum(int[][] a) {\\n        long res=0;\\n        boolean flag=false;\\n        long min=Integer.MAX_VALUE;\\n        for(int i=0;i < a.length;i++){\\n            for(int j=0;j < a[0].length;j++){\\n                res+=Math.abs(a[i][j]);\\n                min=Math.min(min,Math.abs(a[i][j]));\\n                if(a[i][j]<0){\\n                    flag=!flag;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2339790,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        negCount = 0\\n        matSum  = 0\\n        minEle = float(\\'inf\\')\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] < 0:\\n                    negCount += 1\\n                matSum += abs(matrix[i][j])\\n                minEle = min(minEle, abs(matrix[i][j]))\\n                    \\n        if negCount % 2 != 0:\\n            return matSum - 2 * minEle\\n        return matSum\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        negCount = 0\\n        matSum  = 0\\n        minEle = float(\\'inf\\')\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] < 0:\\n                    negCount += 1\\n                matSum += abs(matrix[i][j])\\n                minEle = min(minEle, abs(matrix[i][j]))\\n                    \\n        if negCount % 2 != 0:\\n            return matSum - 2 * minEle\\n        return matSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312391,
                "title": "c-simple-nested-loops",
                "content": "If we have *even* number of negative items we can turn all of them into positive; in this case we can just sum all the items of the `matrix`. If we have *odd* number of negative items we can turn all but arbitrary one into positive; let this *arbitrary* one be the minimum by absolute value:\\n\\n```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) {\\n        bool even = true;\\n        \\n        int min = int.MaxValue;\\n        \\n        long result = 0;\\n        \\n        foreach (int[] line in matrix) {\\n            foreach (int v in line) {\\n                result += Math.Abs(v);\\n                \\n                min = Math.Min(min, Math.Abs(v));\\n                \\n                if (v < 0)\\n                    even = !even;\\n            }\\n        }    \\n        \\n        if (even)\\n            return result;\\n        \\n        return result - 2 * min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) {\\n        bool even = true;\\n        \\n        int min = int.MaxValue;\\n        \\n        long result = 0;\\n        \\n        foreach (int[] line in matrix) {\\n            foreach (int v in line) {\\n                result += Math.Abs(v);\\n                \\n                min = Math.Min(min, Math.Abs(v));\\n                \\n                if (v < 0)\\n                    even = !even;\\n            }\\n        }    \\n        \\n        if (even)\\n            return result;\\n        \\n        return result - 2 * min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291661,
                "title": "greedy-c",
                "content": "```\\n    public long MaxMatrixSum(int[][] matrix) {\\n        \\n        var min = Int32.MaxValue;\\n        long sum = 0;\\n        var negative = 0;\\n        for(int i=0; i<matrix.Length; i++)\\n        {\\n            for(int j=0; j<matrix[0].Length; j++)\\n            {\\n                if(matrix[i][j] <0)negative++;\\n                \\n                min = Math.Min(min, Math.Abs(matrix[i][j]));\\n                sum+= Math.Abs(matrix[i][j]);\\n            }\\n        }\\n        if((negative&1)==0) return sum;\\n        return (sum - 2*min);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long MaxMatrixSum(int[][] matrix) {\\n        \\n        var min = Int32.MaxValue;\\n        long sum = 0;\\n        var negative = 0;\\n        for(int i=0; i<matrix.Length; i++)\\n        {\\n            for(int j=0; j<matrix[0].Length; j++)\\n            {\\n                if(matrix[i][j] <0)negative++;\\n                \\n                min = Math.Min(min, Math.Abs(matrix[i][j]));\\n                sum+= Math.Abs(matrix[i][j]);\\n            }\\n        }\\n        if((negative&1)==0) return sum;\\n        return (sum - 2*min);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2287382,
                "title": "o-n-2-solution-c",
                "content": "```\\nlong long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long int sum=0;bool seen=false;int minn=abs(matrix[0][0]);long long int parity;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){seen=true;}\\n                if(matrix[i][j]<0){parity++;}\\n                minn=min(minn,abs(matrix[i][j]));\\n                sum=sum+abs(matrix[i][j]);\\n            }\\n        }\\n        if(seen){return sum;}\\n        if(parity%2==0){return sum;}\\n        \\n        else{return sum-2*(abs(minn));}\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nlong long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long int sum=0;bool seen=false;int minn=abs(matrix[0][0]);long long int parity;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){seen=true;}\\n                if(matrix[i][j]<0){parity++;}\\n                minn=min(minn,abs(matrix[i][j]));\\n                sum=sum+abs(matrix[i][j]);\\n            }\\n        }\\n        if(seen){return sum;}\\n        if(parity%2==0){return sum;}\\n        \\n        else{return sum-2*(abs(minn));}\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2218286,
                "title": "not-enough-test-cases",
                "content": "Why did they not include a test case with an input such as \\nmatrix=\\n[[1,-1,-1,-1,1],\\n [1,-1,-1,-1,-1],\\n [1,-1,-1,-1,1],\\n [1,1,1,1,1],\\n[1,1,1,1,1]], \\nwhere the expected output must be 21?",
                "solutionTags": [],
                "code": "Why did they not include a test case with an input such as \\nmatrix=\\n[[1,-1,-1,-1,1],\\n [1,-1,-1,-1,-1],\\n [1,-1,-1,-1,1],\\n [1,1,1,1,1],\\n[1,1,1,1,1]], \\nwhere the expected output must be 21?",
                "codeTag": "Unknown"
            },
            {
                "id": 2214833,
                "title": "c-easy-solution",
                "content": "The trick is realizing that if there are an even number of negative numbers, all negatives can be eliminated and the answer is the sum of the absolute values of all elements. If there are an odd number of negative numbers, all negatives can be eliminated except for one. This one negative can be any number in the matrix, so we pick the smallest.\\n\\nThe code below loops through the matrix once keeping track of the sum of the absolute value of each element, the closest to zero element (minimum element after taking absolute value), and the number of negative numbers.\\n\\nAfter the loop if there are an even number of negative numbers, we simply return the sum. If there are an odd number, we subtract two times the minimum element from the sum and return it.\\n\\n```\\nlong long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    long long matrixSum = 0;\\n    int numNegative = 0, minimum = INT_MAX;\\n    \\n    for (int i = 0; i < matrixSize; i++) {\\n        for (int j = 0; j < matrixSize; j++) {\\n            if (matrix[i][j] < 0) numNegative++;\\n            if (abs(matrix[i][j]) < minimum) minimum = abs(matrix[i][j]);\\n            matrixSum += abs(matrix[i][j]);\\n        }\\n    }\\n    \\n    if (numNegative % 2 == 0) return matrixSum;\\n    return matrixSum - (2 * minimum);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    long long matrixSum = 0;\\n    int numNegative = 0, minimum = INT_MAX;\\n    \\n    for (int i = 0; i < matrixSize; i++) {\\n        for (int j = 0; j < matrixSize; j++) {\\n            if (matrix[i][j] < 0) numNegative++;\\n            if (abs(matrix[i][j]) < minimum) minimum = abs(matrix[i][j]);\\n            matrixSum += abs(matrix[i][j]);\\n        }\\n    }\\n    \\n    if (numNegative % 2 == 0) return matrixSum;\\n    return matrixSum - (2 * minimum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151786,
                "title": "easy-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n                             //LOGIC//\\n    // if number of negative numbers are even we return the total absolute sum\\n    \\n    // else we swap negative to minimum absolute number and subtract from total absolute sum\\n    \\n    \\n    \\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int mini=INT_MAX,neg=0;\\n        for(auto i:matrix)\\n        {\\n            for(auto j:i)\\n            {\\n                sum+=(abs(j));\\n                if(j<0)\\n                {\\n                    neg++;\\n                }\\n                mini=min(mini,abs(j));\\n            }\\n        }\\n        if(neg&1)\\n        {\\n            return sum-2*mini;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n                             //LOGIC//\\n    // if number of negative numbers are even we return the total absolute sum\\n    \\n    // else we swap negative to minimum absolute number and subtract from total absolute sum\\n    \\n    \\n    \\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        long long sum=0;\\n        int mini=INT_MAX,neg=0;\\n        for(auto i:matrix)\\n        {\\n            for(auto j:i)\\n            {\\n                sum+=(abs(j));\\n                if(j<0)\\n                {\\n                    neg++;\\n                }\\n                mini=min(mini,abs(j));\\n            }\\n        }\\n        if(neg&1)\\n        {\\n            return sum-2*mini;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120036,
                "title": "python-odd-even-number-of-negatives-with-explanation",
                "content": "we can always move the negative sign anywhere in the matrix and flip a pair if there are 2 or more negative numbers in the matrix.  So - if the number of negative numbers is even we can turn them all into positives.  If it\\'s odd we will be left with one negative number, so we choose one with the least absolute value (which may include zero).  The answer in that case is the total ```sum(abs values) - 2*(min abs value)```\\n```\\n\\ndef maxMatrixSum(self, g: List[List[int]]) -> int:\\n\\tval=[abs(k) for l in g for k in l]\\n\\ttot=sum(val)\\n\\tcntneg=sum(k<0 for l in g for k in l)  # how many negative\\n\\tif cntneg%2==0:   # flip all in pairs\\n\\t\\treturn tot \\n\\telse:\\n\\t\\treturn tot-min(val)*2  # zero is taken care of here\\n\\t",
                "solutionTags": [],
                "code": "```sum(abs values) - 2*(min abs value)```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105547,
                "title": "python-3-greedy-solution-o-n-2-o-1",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        odd = False  # is there an odd number of negative values?\\n        s, m = 0, math.inf  # sum, min\\n\\n        for row in matrix:\\n            for num in row:\\n                if num < 0:\\n                    odd = not odd\\n                    num = -num\\n                s += num\\n                m = min(m, num)\\n        \\n        return -2*m*odd + s",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        odd = False  # is there an odd number of negative values?\\n        s, m = 0, math.inf  # sum, min\\n\\n        for row in matrix:\\n            for num in row:\\n                if num < 0:\\n                    odd = not odd\\n                    num = -num\\n                s += num\\n                m = min(m, num)\\n        \\n        return -2*m*odd + s",
                "codeTag": "Java"
            },
            {
                "id": 2081808,
                "title": "c-mark",
                "content": "The idea here is a negative sign \"-\" can \"move\" all around the matrix, basically means the negative sign can move to any position if there are odd number of negatives.\\nso if the number of negative values is odd (while no zero exists), that means we will definitely leave one number in negavive value, we  can optimize it to the minizied -abs(minValue).\\nso the result = total abs sum -  2* abs(minValue).\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),minValue=INT_MAX,zeroCount=0,negativeCount=0,v=0,i,j;\\n        long long absSum=0;\\n        for( i=0;i<n;++i)\\n            for( j=0;j<n;++j) {\\n                v = matrix[i][j];\\n                negativeCount+= v<0;\\n                zeroCount+=v==0;\\n                absSum+= abs(v);                \\n                \\n                if(v!=0) minValue = min(minValue, abs(v));\\n            }\\n        return (negativeCount%2==0 || zeroCount>0) ? absSum : (absSum-2*minValue);\\n    }\\n};\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),minValue=INT_MAX,zeroCount=0,negativeCount=0,v=0,i,j;\\n        long long absSum=0;\\n        for( i=0;i<n;++i)\\n            for( j=0;j<n;++j) {\\n                v = matrix[i][j];\\n                negativeCount+= v<0;\\n                zeroCount+=v==0;\\n                absSum+= abs(v);                \\n                \\n                if(v!=0) minValue = min(minValue, abs(v));\\n            }\\n        return (negativeCount%2==0 || zeroCount>0) ? absSum : (absSum-2*minValue);\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003023,
                "title": "scala",
                "content": "```\\nimport scala.math.abs\\n\\nobject Solution {\\n  def maxMatrixSum(matrix: Array[Array[Int]]): Long = {\\n    val n = matrix.length\\n\\n    def indices = Iterator.range(0, n).flatMap(i => Iterator.tabulate(n)(i -> _))\\n\\n    def get(index: (Int, Int)) = matrix(index._1)(index._2).toLong\\n\\n    def absoluteElems = indices.map(get).map(abs)\\n\\n    val absoluteSum = absoluteElems.sum\\n\\n    indices.count(get(_) < 0) % 2 match {\\n      case 0 => absoluteSum\\n      case _ => absoluteSum - 2 * absoluteElems.minOption.getOrElse(0L)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.math.abs\\n\\nobject Solution {\\n  def maxMatrixSum(matrix: Array[Array[Int]]): Long = {\\n    val n = matrix.length\\n\\n    def indices = Iterator.range(0, n).flatMap(i => Iterator.tabulate(n)(i -> _))\\n\\n    def get(index: (Int, Int)) = matrix(index._1)(index._2).toLong\\n\\n    def absoluteElems = indices.map(get).map(abs)\\n\\n    val absoluteSum = absoluteElems.sum\\n\\n    indices.count(get(_) < 0) % 2 match {\\n      case 0 => absoluteSum\\n      case _ => absoluteSum - 2 * absoluteElems.minOption.getOrElse(0L)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1980262,
                "title": "javascript-solution-greedy-approach",
                "content": "There are fourth key observations that help me solve this problem.\\n\\nFirst observation is that we would want the least # of negative signs as possible in the matrix. In other words, we want to cancel out as many pairs of negative numbers as possible by multiplying them by -1.\\n\\nSecond observation is that we want the negative signs to be on the smallest absolute numbers as possible. \\n\\nThird observation is that when you have 1 negative and 1 positive adjacent numbers and we perform the -1 multplication on them, it is like moving the negative signs around. Imagine the operation as a way to herd all the negative signs into one area where they will be paired up and canceled out by multiplying them with -1.\\n\\nThe final observation is that if there is an odd number of negative signs in the matrix, we should have 1 negative sign left. If there is an even number of negative signs in the matrix, then we should have 0 negative sign left.\\n\\nIf we do have a negative sign, we would want to assign it to the smallest **absolute** valued number in the matrix. I hope this made sense!\\n\\n\\n```\\nvar maxMatrixSum = function(matrix) {\\n    const MAX= Number.MAX_SAFE_INTEGER;\\n    \\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    \\n    let negs = 0;\\n    \\n    let totAbsSum = 0;\\n    let minAbsNum = MAX;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            if (matrix[i][j] < 0) ++negs;\\n            \\n            totAbsSum += Math.abs(matrix[i][j]);\\n            minAbsNum = Math.min(minAbsNum, Math.abs(matrix[i][j]));\\n        }\\n    }\\n    \\n    if (negs % 2 === 1) totAbsSum -= (2 * minAbsNum);\\n    \\n\\treturn totAbsSum;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar maxMatrixSum = function(matrix) {\\n    const MAX= Number.MAX_SAFE_INTEGER;\\n    \\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    \\n    let negs = 0;\\n    \\n    let totAbsSum = 0;\\n    let minAbsNum = MAX;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            if (matrix[i][j] < 0) ++negs;\\n            \\n            totAbsSum += Math.abs(matrix[i][j]);\\n            minAbsNum = Math.min(minAbsNum, Math.abs(matrix[i][j]));\\n        }\\n    }\\n    \\n    if (negs % 2 === 1) totAbsSum -= (2 * minAbsNum);\\n    \\n\\treturn totAbsSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971922,
                "title": "python3-clean-greedy-solution",
                "content": "The intuition is that we can always get down to only one negative number or none at all with adjacent-chaining sign-flip operations. Afterwards, we just need handle those two cases separately. Here\\'s the full solution:\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        cnt = 0\\n        su = 0\\n        mi = float(\\'inf\\')\\n        contains_zero = False\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] <= 0:\\n                    cnt += 1\\n                if abs(matrix[i][j]) > 0:\\n                    mi = min(mi, abs(matrix[i][j]))\\n                else:\\n                    contains_zero = True\\n                su += abs(matrix[i][j])\\n        if cnt % 2 == 0 or contains_zero:\\n            return su\\n        return su + 2 * -abs(mi)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        cnt = 0\\n        su = 0\\n        mi = float(\\'inf\\')\\n        contains_zero = False\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] <= 0:\\n                    cnt += 1\\n                if abs(matrix[i][j]) > 0:\\n                    mi = min(mi, abs(matrix[i][j]))\\n                else:\\n                    contains_zero = True\\n                su += abs(matrix[i][j])\\n        if cnt % 2 == 0 or contains_zero:\\n            return su\\n        return su + 2 * -abs(mi)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929392,
                "title": "c-easy-to-understand-with-explain-fast-than-all",
                "content": "Because you can do any number of *-1 operations, so finally there will be only 1 or no negative value left in matrix.\\nBecause we can swap any two neighbors, so we can assign the only negative sign to any one in matrix.\\nSo we just get the sum of Math.Abs() of all other values and minus the minimium Abs value. \\n\\n```\\n        public long MaxMatrixSum(int[][] matrix)\\n        {\\n            long res = 0;\\n            int min = int.MaxValue;//min of abs\\n            int count = 0;//count of negative\\n            foreach(var m in matrix)\\n                foreach(var n in m)\\n                {\\n                    if (n >= 0)\\n                    {\\n                        res += n;\\n                        min = Math.Min(min, n);\\n                    }\\n                    else\\n                    {\\n                        res -= n;\\n                        min = Math.Min(min, -n);\\n                        count++;\\n                    }\\n                }\\n            return count%2==0?res:res-2*min;//remember double it because res already sum the abs of the min value\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public long MaxMatrixSum(int[][] matrix)\\n        {\\n            long res = 0;\\n            int min = int.MaxValue;//min of abs\\n            int count = 0;//count of negative\\n            foreach(var m in matrix)\\n                foreach(var n in m)\\n                {\\n                    if (n >= 0)\\n                    {\\n                        res += n;\\n                        min = Math.Min(min, n);\\n                    }\\n                    else\\n                    {\\n                        res -= n;\\n                        min = Math.Min(min, -n);\\n                        count++;\\n                    }\\n                }\\n            return count%2==0?res:res-2*min;//remember double it because res already sum the abs of the min value\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912629,
                "title": "python-explained",
                "content": "For each row:\\n* If there is no negative elements, all is good.\\n* If there is at least 1 negative elements:\\n\\t* If there\\'s an odd number of negative elements in the row, we can narrow it to 1.\\n\\t* If there\\'s an even number of negative elements in the row, we can narrow it to 0.\\n\\nAfter this round of processing, there should be only 0 or 1 negative element in each row.\\n\\nNext, we look across rows:\\n* If there is an even number of rows with 1 negative number in each row, we can position these negative numbers such that we can cancel them out across rows.\\n* If there is an odd number of rows with 1 negative number in each row, we can narrow it to 1 such element.\\n\\nAfter this round of processing, there should be only 0 or 1 negative element in the entire matrix.\\nIf 0 negative element, we sum up the absolute value of each item in the matrix and return it.\\nIf there is 1 negative element, we will want it to be the item in the matrix with the smallest absolute value, so take the sum of absolute value across matrix and minus 2 * this value (once to remove the addition effect, once to have the minus effect).\\n\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        rowsCounter = []\\n        mmin = float(\\'inf\\')\\n        res = 0\\n        for row in matrix:\\n            counter  = 0\\n            for item in row:\\n                if item < 0:\\n                    counter += 1\\n                if abs(item) < mmin:\\n                    mmin = abs(item)\\n                res += abs(item)\\n            if counter % 2 == 0:\\n                rowsCounter.append(0)\\n            else:\\n                rowsCounter.append(1)\\n        \\n        if sum(rowsCounter) % 2 == 0:\\n            return res\\n        else:\\n            return res - 2 * mmin\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        rowsCounter = []\\n        mmin = float(\\'inf\\')\\n        res = 0\\n        for row in matrix:\\n            counter  = 0\\n            for item in row:\\n                if item < 0:\\n                    counter += 1\\n                if abs(item) < mmin:\\n                    mmin = abs(item)\\n                res += abs(item)\\n            if counter % 2 == 0:\\n                rowsCounter.append(0)\\n            else:\\n                rowsCounter.append(1)\\n        \\n        if sum(rowsCounter) % 2 == 0:\\n            return res\\n        else:\\n            return res - 2 * mmin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876119,
                "title": "python-simple-code",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        minx, s, odd = float(\\'inf\\'), 0, 0\\n        for r in matrix:\\n            for x in r:\\n                odd ^= x<0\\n                minx = min(minx, abs(x))\\n                s += abs(x)\\n        return s - 2*minx*odd\\n```\\n\\nWe don\\'t need to count the number of negative entries explicitly, it\\'s enough to know if it\\'s an odd number or not. If it is, then we need to subtract twice the minumum entry from the sum of all absolute values in the matrix.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        minx, s, odd = float(\\'inf\\'), 0, 0\\n        for r in matrix:\\n            for x in r:\\n                odd ^= x<0\\n                minx = min(minx, abs(x))\\n                s += abs(x)\\n        return s - 2*minx*odd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852899,
                "title": "1975-maximum-matrix-sum-c",
                "content": "It is observation based problem as far as what I saw. After taking 1-2 examples, I realised that either 0/1 number would be negative at the end and that number would definitely be minimum number in the matrix. My approach was that to count those continuous chains of negative number that have odd length.\\n\\n**Detailed Explanation**\\n\\nNow if you look closely in the below picture, If we have even length of a chain of negative numbers, then then among themselves would nullify every negative numbers and we won\\'t have any negative numbers at the last. You can see that eventually even length chains would nullify every negatuve numbers among themselves..\\n\\n![image](https://assets.leetcode.com/users/images/22a74d68-990e-495d-9ae2-59e46446251f_1647378481.9152632.jpeg)\\n\\nNow if we have odd length chain, then we will have one element left at last no matter what we do. So the catch here is if we have odd length chains and if we want to maximise our sum then there are 2 cases:\\n\\n1) If we have odd number of odd length chains : Then we will choose the minimum number from our matrix and make it negative. That\\'s we can do as if there are 5 chains of odd length, then we will have 5 negative numbers from all chains. So out of them, 4 will make pair among themselves while 1 number will still be there. So what we will do is make minimum number negative and that would be our answer.\\n2) If we have even number of odd length chains : Then we wont have any negative number at the last as all the negative numbers that would be left from each odd length chain would make pair among themselves and no negative number would be left at last(as we have even number of that negative number left from each odd length chain).\\n\\nThere maybe some confusion and I can understand that. Once you dry run 2-3 examples covering each case, you will have a clear picture of my approach.\\n\\nHere in my code, To find odd length chains count, I used dfs and after that, all that\\'s left are calculations.\\n\\n**Note** : If anyone is having confusion that how come we should select in case 1) the minimum number. Like how we are sure that it will become negative in the end. Then imagine that from one odd chain you got -4, from other you got -6 and from 3rd you got -7. Now see, you can nullify -4 and -6(even if they are not adjacent as you can make pair with postive number and reach the other negative number) and you have -4 left and so you can in the same fashion, search for the minimum number and make that negative.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> vis;\\n    \\n    int dfs(vector<vector<int>>& matrix,int i,int j){\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        if(i<0 || j<0 || i==m || j==n || vis[i][j] || matrix[i][j]>=0){\\n            return 0;\\n        }\\n        vis[i][j]=true;\\n        long long ans= 1+dfs(matrix,i+1,j) + dfs(matrix,i,j+1) + dfs(matrix,i-1,j) + dfs(matrix,i,j-1);\\n        return ans;\\n    }\\n    \\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vis.resize(m,vector<bool>(n,false));\\n        long long odd=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vis[i][j] || matrix[i][j]>=0){\\n                    continue;\\n                }\\n                int len = dfs(matrix,i,j);\\n                if(len%2){\\n                    odd++;\\n                }\\n            }\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans += abs(matrix[i][j]);\\n            }\\n        }\\n        if(odd%2){\\n            int mine=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    mine=min(mine,abs(matrix[i][j]));\\n                }\\n            }\\n            ans=ans-2*mine;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> vis;\\n    \\n    int dfs(vector<vector<int>>& matrix,int i,int j){\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        if(i<0 || j<0 || i==m || j==n || vis[i][j] || matrix[i][j]>=0){\\n            return 0;\\n        }\\n        vis[i][j]=true;\\n        long long ans= 1+dfs(matrix,i+1,j) + dfs(matrix,i,j+1) + dfs(matrix,i-1,j) + dfs(matrix,i,j-1);\\n        return ans;\\n    }\\n    \\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vis.resize(m,vector<bool>(n,false));\\n        long long odd=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vis[i][j] || matrix[i][j]>=0){\\n                    continue;\\n                }\\n                int len = dfs(matrix,i,j);\\n                if(len%2){\\n                    odd++;\\n                }\\n            }\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans += abs(matrix[i][j]);\\n            }\\n        }\\n        if(odd%2){\\n            int mine=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    mine=min(mine,abs(matrix[i][j]));\\n                }\\n            }\\n            ans=ans-2*mine;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827542,
                "title": "c-solution-clean-code",
                "content": "\\n            \\n             int m=matrix.size();\\n            int n=matrix[0].size();\\n           // long long sum=0;\\n            \\n\\t\\t\\tint minno=INT_MAX;\\n            long long sum=0;\\n            int c=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                    for(int j=0;j<n;j++)\\n                    {\\n                            if(matrix[i][j]<=0)\\n                            {\\n                                    c++;\\n                                   \\n                            }\\n                            minno=min(minno,abs(matrix[i][j]));\\n                            sum+=(abs(matrix[i][j]));\\n                    }\\n            }\\n            if(c%2==0)\\n            {\\n                    return sum;\\n            }\\n            \\n            sum-=(2*abs(minno));\\n            \\n            return sum;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "\\n            \\n             int m=matrix.size();\\n            int n=matrix[0].size();\\n           // long long sum=0;\\n            \\n\\t\\t\\tint minno=INT_MAX;\\n            long long sum=0;\\n            int c=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                    for(int j=0;j<n;j++)\\n                    {\\n                            if(matrix[i][j]<=0)\\n                            {\\n                                    c++;\\n                                   \\n                            }\\n                            minno=min(minno,abs(matrix[i][j]));\\n                            sum+=(abs(matrix[i][j]));\\n                    }\\n            }\\n            if(c%2==0)\\n            {\\n                    return sum;\\n            }\\n            \\n            sum-=(2*abs(minno));\\n            \\n            return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 1823348,
                "title": "clean-and-simple-c-solution",
                "content": "```\\n\\tlong long maxMatrixSum(vector<vector<int>>& matrix) \\n\\t{\\n\\t\\t\\tlong running_sum = 0;\\n\\t\\t\\tint remove = INT_MAX;\\n\\t\\t\\tint negatives = 0;\\n\\n\\t\\t\\tfor ( auto& row : matrix )\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor ( auto& ele : row )\\n\\t\\t\\t\\t{             \\n\\t\\t\\t\\t\\tif ( ele <= 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t++negatives;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tele = std::abs( ele );\\n\\t\\t\\t\\t\\trunning_sum += ele;\\n\\t\\t\\t\\t\\tremove = std::min( remove, ele );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn ( negatives % 2 == 0 || remove == 0 ) ? running_sum : running_sum - 2 * remove;\\n\\t}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tlong long maxMatrixSum(vector<vector<int>>& matrix) \\n\\t{\\n\\t\\t\\tlong running_sum = 0;\\n\\t\\t\\tint remove = INT_MAX;\\n\\t\\t\\tint negatives = 0;\\n\\n\\t\\t\\tfor ( auto& row : matrix )\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor ( auto& ele : row )\\n\\t\\t\\t\\t{             \\n\\t\\t\\t\\t\\tif ( ele <= 0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t++negatives;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tele = std::abs( ele );\\n\\t\\t\\t\\t\\trunning_sum += ele;\\n\\t\\t\\t\\t\\tremove = std::min( remove, ele );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn ( negatives % 2 == 0 || remove == 0 ) ? running_sum : running_sum - 2 * remove;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806095,
                "title": "short-and-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        long long abssum = 0;\\n        int nve = 0, absmin = INT_MAX;\\n        bool containZero = false;\\n        \\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j=0; j<matrix.size(); j++){\\n                \\n                abssum += abs(matrix[i][j]);\\n                if(matrix[i][j] < 0) nve++;\\n                if(matrix[i][j] == 0) containZero = true;\\n                absmin = min(absmin, abs(matrix[i][j]));\\n            \\n            }\\n        }\\n        \\n        return (containZero || nve % 2 == 0) ? abssum : abssum - 2 * absmin; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        long long abssum = 0;\\n        int nve = 0, absmin = INT_MAX;\\n        bool containZero = false;\\n        \\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j=0; j<matrix.size(); j++){\\n                \\n                abssum += abs(matrix[i][j]);\\n                if(matrix[i][j] < 0) nve++;\\n                if(matrix[i][j] == 0) containZero = true;\\n                absmin = min(absmin, abs(matrix[i][j]));\\n            \\n            }\\n        }\\n        \\n        return (containZero || nve % 2 == 0) ? abssum : abssum - 2 * absmin; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804528,
                "title": "java-solution-o-n-2",
                "content": "\\nYou can see that in each row there are two outputs. \\nIf there are odd number of minus numbers there has to be one number that after the multiply will still be a minus number. \\nIf there are even number of minus numbers all the number can become positive. \\nbeacuse adjacent elemntes are also defined by column you can move minus numbers from one row to another so all we have to do is to count the number of all minus numbers in the matrix. \\nIf they are even we can just return the abs sum of the matrix, and if they are odd we can play with the operations to remain with the closest number to zero as our only minus number .\\nI hope it\\'s help \\n\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long sum = 0;\\n        int min = Integer.MAX_VALUE;\\n        int minusCounter = 0;\\n        for (int i = 0; i < matrix.length; i++ ) {\\n            for (int j = 0; j < matrix.length; j++) {\\n                if (matrix[i][j] < 0) {\\n                    minusCounter++;\\n                    sum +=(long) -matrix[i][j];\\n                    min = Math.min(min, -matrix[i][j]);\\n                } else {\\n                    sum +=(long) matrix[i][j];\\n                    min = Math.min(min, matrix[i][j]);\\n                }\\n            }\\n        }\\n        return minusCounter % 2 == 0 ? sum : sum - (long) 2*min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long sum = 0;\\n        int min = Integer.MAX_VALUE;\\n        int minusCounter = 0;\\n        for (int i = 0; i < matrix.length; i++ ) {\\n            for (int j = 0; j < matrix.length; j++) {\\n                if (matrix[i][j] < 0) {\\n                    minusCounter++;\\n                    sum +=(long) -matrix[i][j];\\n                    min = Math.min(min, -matrix[i][j]);\\n                } else {\\n                    sum +=(long) matrix[i][j];\\n                    min = Math.min(min, matrix[i][j]);\\n                }\\n            }\\n        }\\n        return minusCounter % 2 == 0 ? sum : sum - (long) 2*min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799442,
                "title": "java-100-easy-solution",
                "content": "I like to waste my time over-optimizing things :)\\n\\nThe idea is that you can negate anything unless the number of negative numbers if non-pair, so you only have to take into account the smallest \"solo\" negative number.\\n\\nI wans\\'t really sure it would work but well, it looks like my instinct was correct.\\n\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int numNegatives = 0;\\n        long totalSum=0;\\n        int minNeg = Integer.MIN_VALUE;\\n        int minPos = Integer.MAX_VALUE;        \\n        for (int i=0; i<matrix.length; i++) {\\n            for (int e=0; e<matrix[0].length; e++) {\\n                int value = matrix[i][e];\\n                if (value<0) {\\n                    numNegatives++;\\n                    totalSum = totalSum - value;\\n                    minNeg = value > minNeg ? value : minNeg;\\n                } else {\\n                    totalSum = totalSum + value;\\n                    minPos = value < minPos ? value : minPos;\\n                }\\n            }\\n        }        \\n        \\n        int min= Math.min(minPos, -minNeg);\\n        \\n        return totalSum - numNegatives%2*(min+min);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int numNegatives = 0;\\n        long totalSum=0;\\n        int minNeg = Integer.MIN_VALUE;\\n        int minPos = Integer.MAX_VALUE;        \\n        for (int i=0; i<matrix.length; i++) {\\n            for (int e=0; e<matrix[0].length; e++) {\\n                int value = matrix[i][e];\\n                if (value<0) {\\n                    numNegatives++;\\n                    totalSum = totalSum - value;\\n                    minNeg = value > minNeg ? value : minNeg;\\n                } else {\\n                    totalSum = totalSum + value;\\n                    minPos = value < minPos ? value : minPos;\\n                }\\n            }\\n        }        \\n        \\n        int min= Math.min(minPos, -minNeg);\\n        \\n        return totalSum - numNegatives%2*(min+min);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780937,
                "title": "any-2-minuses-eliminate-each-other",
                "content": "Would the task be easier with the following description?\\n_You are given an n x n integer matrix. You can do the following operation any number of times: take any two negative numbers and convert them to positive_ \\n\\nThe problem states: \\n_Choose any two adjacent elements of matrix and multiply each of them by -1_\\nAs if you can eliminate minuses of two adjacent cells only.\\nBut actually you can eliminate any two minuses on the field, because all intermediate cells keep their signs when you build a path through them. \\nLet\\'s construct a path from \"two adjacent cells\" building blocks. It can turn but for the simplicity we draw a horizontal path. Notice, that all intermediate cells in the path will be reverted twice => will keep their signs. \\n![image](https://assets.leetcode.com/users/images/70b573bf-e8d6-45b8-9439-07fec21e2d17_1645198456.8017545.png)\\n\\nNow we know that any two negative numbers can be changed to positive numbers. We are good if there is an even amount of negative numbers. If there is an odd amount, we can\\'t eliminate 1 negative number.  \\n\\n```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int N = matrix.length;\\n        int min = Math.abs(matrix[0][0]);\\n        long sum = 0;\\n        int minuses = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int abs = Math.abs(matrix[i][j]);\\n                sum += abs;\\n                min = Math.min(min, abs);\\n                if (matrix[i][j] < 0) {\\n                    minuses++;\\n                }\\n            }\\n        }\\n        if (minuses % 2 == 1) {\\n            sum -= (2 * min);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int N = matrix.length;\\n        int min = Math.abs(matrix[0][0]);\\n        long sum = 0;\\n        int minuses = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int abs = Math.abs(matrix[i][j]);\\n                sum += abs;\\n                min = Math.min(min, abs);\\n                if (matrix[i][j] < 0) {\\n                    minuses++;\\n                }\\n            }\\n        }\\n        if (minuses % 2 == 1) {\\n            sum -= (2 * min);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776875,
                "title": "c-156ms-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        //negCnt Counts the number of negative numbers.\\n        //mini stores the abs() minimum number that can be assigned the negative sign.\\n        //negCnt&2, if there is even number of non positive number it doesn\\'t subtract mini\\n        //else the negative sign is assigned to mini and subtracted from sum.\\n        \\n        long long int negCnt=0,sum=0,mini=100000;\\n        for(long long i=0;i<matrix.size();i++){\\n            for(long long j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]<=0)negCnt++;\\n                mini= mini<abs(matrix[i][j]) ? mini: abs(matrix[i][j]);\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n        if(negCnt%2)return sum-2*mini;\\n        else return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        \\n        //negCnt Counts the number of negative numbers.\\n        //mini stores the abs() minimum number that can be assigned the negative sign.\\n        //negCnt&2, if there is even number of non positive number it doesn\\'t subtract mini\\n        //else the negative sign is assigned to mini and subtracted from sum.\\n        \\n        long long int negCnt=0,sum=0,mini=100000;\\n        for(long long i=0;i<matrix.size();i++){\\n            for(long long j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]<=0)negCnt++;\\n                mini= mini<abs(matrix[i][j]) ? mini: abs(matrix[i][j]);\\n                sum+=abs(matrix[i][j]);\\n            }\\n        }\\n        if(negCnt%2)return sum-2*mini;\\n        else return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767445,
                "title": "swift-easy-solution",
                "content": "Number of non positive numbers are even then we can make all values non negative.\\nNumber of non positive numbers are odd then we can make all values non negative except one value. (one value should be minimum abs value)\\n\\n\\n```\\nclass Solution {\\n    func maxMatrixSum(_ matrix: [[Int]]) -> Int {\\n        let n = matrix.count\\n        let m = matrix.first?.count\\n        var ans = 0\\n        var minimum = Int.max\\n        var negative = 0\\n\\n        for i in 0..<n {\\n            for j in 0..<m! {\\n                if matrix[i][j] < 0 {\\n                    negative = negative + 1\\n                }\\n                ans = ans + abs(matrix[i][j])\\n                minimum = min(minimum, abs(matrix[i][j]))\\n            }\\n        }\\n        \\n        if negative % 2 == 0 {\\n            return ans\\n        }  else {\\n            return ans - minimum - minimum\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxMatrixSum(_ matrix: [[Int]]) -> Int {\\n        let n = matrix.count\\n        let m = matrix.first?.count\\n        var ans = 0\\n        var minimum = Int.max\\n        var negative = 0\\n\\n        for i in 0..<n {\\n            for j in 0..<m! {\\n                if matrix[i][j] < 0 {\\n                    negative = negative + 1\\n                }\\n                ans = ans + abs(matrix[i][j])\\n                minimum = min(minimum, abs(matrix[i][j]))\\n            }\\n        }\\n        \\n        if negative % 2 == 0 {\\n            return ans\\n        }  else {\\n            return ans - minimum - minimum\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757319,
                "title": "java-easy-approach",
                "content": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long ans=0;\\n        int min =Integer.MAX_VALUE;\\n        int negativeNumber =0;\\n        \\n        for(int i=0 ; i<matrix.length ; i++){\\n            for(int j=0; j<matrix[0].length ; j++){\\n                if(matrix[i][j]<0){\\n                    negativeNumber++;\\n                }\\n                min = Math.min(min,Math.abs(matrix[i][j]));\\n                ans = ans+ Math.abs(matrix[i][j]);\\n                                             \\n            }\\n                             \\n        }\\n        if(negativeNumber%2!=0){\\n              return ans-min-min;\\n        }\\n      return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long ans=0;\\n        int min =Integer.MAX_VALUE;\\n        int negativeNumber =0;\\n        \\n        for(int i=0 ; i<matrix.length ; i++){\\n            for(int j=0; j<matrix[0].length ; j++){\\n                if(matrix[i][j]<0){\\n                    negativeNumber++;\\n                }\\n                min = Math.min(min,Math.abs(matrix[i][j]));\\n                ans = ans+ Math.abs(matrix[i][j]);\\n                                             \\n            }\\n                             \\n        }\\n        if(negativeNumber%2!=0){\\n              return ans-min-min;\\n        }\\n      return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728177,
                "title": "easy-odd-even-case",
                "content": "there can be only two cases \\n1. number of non positive numbers are even \\n2. number of non positive numbers are odd\\n\\nwe can solve both one by one \\nfor even we can make all values non negative\\nfor odd we can make all values nno negative except one value\\nwe can change that one number to least abs value of the matrix\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int x = 0 ;\\n        long long sum = 0 ;\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = 0 ; j < matrix[i].size() ; j++)\\n            {\\n                if(matrix[i][j] <= 0)\\n                {\\n                    sum -= matrix[i][j];\\n                    matrix[i][j] *= -1 ;\\n                    x++;\\n                }\\n                else\\n                {\\n                    sum += matrix[i][j];\\n                }\\n            }\\n        }\\n        int mn = INT_MAX ;\\n        if(x % 2 == 0 && x > 0)\\n        {\\n            return sum ;\\n        }\\n        else if(x % 2 == 1 && x > 0)\\n        {\\n            for(auto it : matrix)\\n            {\\n                for(auto i : it)\\n                {\\n                    mn = min(mn , i);\\n                }\\n            }\\n            cout<<mn<<endl;\\n            sum -= 2 * mn ;\\n            return sum ;\\n        }\\n        \\n        return sum ;\\n    }\\n};\\n```\\n\\nANY SUGGESTIONS ARE WELCOMED :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int x = 0 ;\\n        long long sum = 0 ;\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = 0 ; j < matrix[i].size() ; j++)\\n            {\\n                if(matrix[i][j] <= 0)\\n                {\\n                    sum -= matrix[i][j];\\n                    matrix[i][j] *= -1 ;\\n                    x++;\\n                }\\n                else\\n                {\\n                    sum += matrix[i][j];\\n                }\\n            }\\n        }\\n        int mn = INT_MAX ;\\n        if(x % 2 == 0 && x > 0)\\n        {\\n            return sum ;\\n        }\\n        else if(x % 2 == 1 && x > 0)\\n        {\\n            for(auto it : matrix)\\n            {\\n                for(auto i : it)\\n                {\\n                    mn = min(mn , i);\\n                }\\n            }\\n            cout<<mn<<endl;\\n            sum -= 2 * mn ;\\n            return sum ;\\n        }\\n        \\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1715731,
                "title": "java-solution-with-explanation",
                "content": "If you observe the pattern, Any row or column can contain negative values.\\nBy multiplying adjucent values with -1, example row: [-1,2,3,-4] -> [-1,2,-3,4] -> [-1,-2,3,4] -> [1,2,3,4]\\nThis is applicable to columns as well.\\n\\nIf it contains odd number of negative elements then it is impossible to convert last \\'one\\' value into a positive value.\\nAnd we need to get the maximum sum.\\nIn this case by making minimum value as a negative value will give us the maximum sum.\\n\\nclass Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int rLen = matrix.length;\\n        int cLen = matrix[0].length;\\n        \\n        int count = 0;\\n        long result = 0;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<rLen;i++) {\\n            for(int j=0;j<cLen;j++) {\\n                if(matrix[i][j]<0) \\n                    count++;\\n                \\n                min = Math.min(min,Math.abs(matrix[i][j]));\\n                result = result + Math.abs(matrix[i][j]);\\n            }\\n        }\\n        \\n        if(count%2 !=0) {\\n            result = result - (2 * min);\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int rLen = matrix.length;\\n        int cLen = matrix[0].length;\\n        \\n        int count = 0;\\n        long result = 0;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<rLen;i++) {\\n            for(int j=0;j<cLen;j++) {\\n                if(matrix[i][j]<0) \\n                    count++;\\n                \\n                min = Math.min(min,Math.abs(matrix[i][j]));\\n                result = result + Math.abs(matrix[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1684990,
                "title": "c-solution-using-observations-about-the-matrix-sum-time-o-n-2-space-o-1",
                "content": "```\\n// 3 Observations:\\n// - Matrix with zeroes can flush out any number of negative integers through\\n//   swaps.\\n// - Matrix with no zeroes and an odd number of negatives will always have a\\n//   leftover negative integer, therefore we minimize the negative value.\\n// - Matrix with no zeroes and an even number of negatives will always be capable\\n//   of erasing all negative integers.\\nlong long maxMatrixSum(\\n\\tvector<vector<int>>& matrix)\\n{\\n   long long answer = 0;\\n   if (matrix.size() && matrix[0].size() && matrix.size() == matrix[0].size()) {\\n\\t   int dimension = matrix.size();\\n\\t   int zeroCount = 0;\\n\\t   int negCount = 0;\\n\\t   int minAbs = INT_MAX;\\n\\t   for (int y = 0; y < dimension; y++)\\n\\t   for (int x = 0; x < dimension; x++) {\\n\\t\\t   negCount = (matrix[y][x] < 0) ? negCount + 1 : negCount;\\n\\t\\t   zeroCount = (matrix[y][x] == 0) ? zeroCount + 1 : zeroCount;\\n\\t\\t   minAbs = (minAbs > abs(matrix[y][x])) ? abs(matrix[y][x]) : minAbs;\\n\\t\\t   answer += abs(matrix[y][x]);\\n\\t   }\\n\\t   answer -= ((zeroCount == 0) && (negCount % 2)) ? 2 * minAbs : 0;\\n   }\\n   return answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// 3 Observations:\\n// - Matrix with zeroes can flush out any number of negative integers through\\n//   swaps.\\n// - Matrix with no zeroes and an odd number of negatives will always have a\\n//   leftover negative integer, therefore we minimize the negative value.\\n// - Matrix with no zeroes and an even number of negatives will always be capable\\n//   of erasing all negative integers.\\nlong long maxMatrixSum(\\n\\tvector<vector<int>>& matrix)\\n{\\n   long long answer = 0;\\n   if (matrix.size() && matrix[0].size() && matrix.size() == matrix[0].size()) {\\n\\t   int dimension = matrix.size();\\n\\t   int zeroCount = 0;\\n\\t   int negCount = 0;\\n\\t   int minAbs = INT_MAX;\\n\\t   for (int y = 0; y < dimension; y++)\\n\\t   for (int x = 0; x < dimension; x++) {\\n\\t\\t   negCount = (matrix[y][x] < 0) ? negCount + 1 : negCount;\\n\\t\\t   zeroCount = (matrix[y][x] == 0) ? zeroCount + 1 : zeroCount;\\n\\t\\t   minAbs = (minAbs > abs(matrix[y][x])) ? abs(matrix[y][x]) : minAbs;\\n\\t\\t   answer += abs(matrix[y][x]);\\n\\t   }\\n\\t   answer -= ((zeroCount == 0) && (negCount % 2)) ? 2 * minAbs : 0;\\n   }\\n   return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672589,
                "title": "racket-solution",
                "content": "Here\\'s my Racket solution. I\\'m a complete beginner though.\\n```lisp\\n(define/contract (max-matrix-sum matrix)\\n  (-> (listof (listof exact-integer?)) exact-integer?)\\n  (for*/fold ([mini #f]\\n              [is-odd #f]\\n              [sum 0]\\n              #:result (if is-odd (- sum (* 2 mini)) sum))\\n             ([row (in-list matrix)]\\n              [elem (in-list row)])\\n    (define val (abs elem))\\n    (values\\n      (if mini (min mini val) val)\\n      (if (< elem 0) (not is-odd) is-odd)\\n      (+ sum val))))\\n\\t  ```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```lisp\\n(define/contract (max-matrix-sum matrix)\\n  (-> (listof (listof exact-integer?)) exact-integer?)\\n  (for*/fold ([mini #f]\\n              [is-odd #f]\\n              [sum 0]\\n              #:result (if is-odd (- sum (* 2 mini)) sum))\\n             ([row (in-list matrix)]\\n              [elem (in-list row)])\\n    (define val (abs elem))\\n    (values\\n      (if mini (min mini val) val)\\n      (if (< elem 0) (not is-odd) is-odd)\\n      (+ sum val))))\\n\\t  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1618084,
                "title": "c-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        int columns=matrix[0].size();\\n        \\n        int minElement=INT_MAX;\\n        long long int totalSum=0;\\n        int countNegativeNums=0;\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<columns;j++){\\n                minElement=min(minElement,abs(matrix[i][j]));\\n                \\n                if(matrix[i][j]<0)\\n                    countNegativeNums++;\\n                \\n                totalSum+=abs(matrix[i][j]);\\n            }\\n        }\\n        \\n        if(countNegativeNums&1)\\n            return totalSum-(2*minElement);\\n        return totalSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        int columns=matrix[0].size();\\n        \\n        int minElement=INT_MAX;\\n        long long int totalSum=0;\\n        int countNegativeNums=0;\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<columns;j++){\\n                minElement=min(minElement,abs(matrix[i][j]));\\n                \\n                if(matrix[i][j]<0)\\n                    countNegativeNums++;\\n                \\n                totalSum+=abs(matrix[i][j]);\\n            }\\n        }\\n        \\n        if(countNegativeNums&1)\\n            return totalSum-(2*minElement);\\n        return totalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581906,
                "title": "python-6-lines",
                "content": "- In a given row, if there\\'re even number of negatives, we can turn all into positives; \\n- If there\\'re odd number, we can turn all except leave one negative\\n- Across rows, if there\\'re even number of negatives, they\\'re already all turned to positives\\n- If there\\'re odd number, we can move them into one column, and turn all except leave one negative\\n\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        ct = sum(sum(c < 0 for c in r) for r in matrix)\\n        if ct % 2 == 0:\\n            return sum(abs(c) for r in matrix for c in r)\\n        else:\\n            s = sorted(abs(c) for r in matrix for c in r)\\n            return -s[0] + sum(s[1:])\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "- In a given row, if there\\'re even number of negatives, we can turn all into positives; \\n- If there\\'re odd number, we can turn all except leave one negative\\n- Across rows, if there\\'re even number of negatives, they\\'re already all turned to positives\\n- If there\\'re odd number, we can move them into one column, and turn all except leave one negative\\n\\n```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        ct = sum(sum(c < 0 for c in r) for r in matrix)\\n        if ct % 2 == 0:\\n            return sum(abs(c) for r in matrix for c in r)\\n        else:\\n            s = sorted(abs(c) for r in matrix for c in r)\\n            return -s[0] + sum(s[1:])\\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1557584,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public long maxMatrixSum(int[][] matrix) \\n    {\\n        long sum = 0, min = Integer.MAX_VALUE;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i = 0; i < matrix.length; i++)\\n        {\\n            for(int j = 0; j < matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] >= 0)\\n                {\\n                    min = Math.min(min, matrix[i][j]);\\n                    sum += matrix[i][j];\\n                }\\n                else if(matrix[i][j] < 0)\\n                {\\n                    pq.add(matrix[i][j]);\\n                }\\n            }\\n        }\\n        \\n        while(pq.size() > 1)\\n        {\\n            sum += Math.abs(pq.poll());\\n            sum += Math.abs(pq.poll());\\n        }\\n        \\n        if(!pq.isEmpty())\\n        {\\n            int last = pq.poll();\\n            if(min == 0)\\n            {\\n                sum += Math.abs(last);\\n            }\\n            else if(Math.abs(last) > min)\\n            {\\n                sum -= 2*min;\\n                sum += Math.abs(last);\\n            }\\n            else\\n            {\\n                sum += last;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maxMatrixSum(int[][] matrix) \\n    {\\n        long sum = 0, min = Integer.MAX_VALUE;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i = 0; i < matrix.length; i++)\\n        {\\n            for(int j = 0; j < matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] >= 0)\\n                {\\n                    min = Math.min(min, matrix[i][j]);\\n                    sum += matrix[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1537192,
                "title": "c-solution",
                "content": "Time O(n) Space O(1)\\n```\\n    public long MaxMatrixSum(int[][] matrix) {\\n        int negativeCnt=0, absMin=int.MaxValue;\\n        long absTotal=0;\\n        int m=matrix.Length, n=matrix[0].Length;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    negativeCnt++;\\n                absMin=Math.Min(absMin,Math.Abs(matrix[i][j]));\\n                absTotal+=Math.Abs(matrix[i][j]);\\n            }\\n        }\\n        if(negativeCnt%2==0)\\n            return absTotal;\\n        else\\n            return absTotal-2*absMin;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long MaxMatrixSum(int[][] matrix) {\\n        int negativeCnt=0, absMin=int.MaxValue;\\n        long absTotal=0;\\n        int m=matrix.Length, n=matrix[0].Length;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    negativeCnt++;\\n                absMin=Math.Min(absMin,Math.Abs(matrix[i][j]));\\n                absTotal+=Math.Abs(matrix[i][j]);\\n            }\\n        }\\n        if(negativeCnt%2==0)\\n            return absTotal;\\n        else\\n            return absTotal-2*absMin;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522104,
                "title": "c-simplest-code",
                "content": "class Solution {\\npublic:\\n   long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        long long sum = 0;\\n        int mini = 1000000;\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                sum += abs(matrix[i][j]);\\n                mini = min(mini,abs(matrix[i][j]));\\n                if(matrix[i][j]<0)\\n                    cnt++;\\n            }\\n        }\\n        return (cnt%2==0)?sum:sum-2*mini;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        long long sum = 0;\\n        int mini = 1000000;\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                sum += abs(matrix[i][j]);\\n                mini = min(mini,abs(matrix[i][j]));\\n                if(matrix[i][j]<0)\\n                    cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1495981,
                "title": "python-solution-maximum-matrix-sum",
                "content": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        given : n*n matrix\\n        goal : maximize summation of all elements in matrix\\n        \\n        1. The max possible sum can be sum of all positive elements in matrix i.e when all are positive.\\n        2. Now suppose if there are even number of -ve elements then they can be all turned to positive numbers \\n        and then again we can achieve the maximum result .\\n        eg : -1 2 1 -2\\n              3 1 -1 0\\n              1 -1 3 1\\n        see here even if all the negative elements are not adjacent to each other but it is given that\\n        we can perform this operation any number of times s\\n        \\n        so we can start with any one negative element keep multiplyting it with its adjacent element until \\n        we reach a point where both the elements are -ve and after multiplying each of them by -1 we get positive\\n        numbers .\\n        \\n        3. if there are odd number of -ve elements then we need to get the minimum number (greater than\\n        0 .\\n        \\n        Note : One catch here is that we can treat 0s and use them to swap with negative elements \\n        in this eg : \\n        -3 0 0\\n        0 0 0\\n        0 3 2\\n        zero = 6\\n        neg = 1\\n        since here only one negative element is present we might end up thinking that we cant make this \\n        to a positive number but instead we can make use of 0s . we ll use only that many number of zeros \\n        such that the count of negative number becomes even.\\n             \\n        \\'\\'\\'\\n        tot,min1,neg,zero = 0,sys.maxsize,0,0\\n        n = len(matrix)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                val = matrix[i][j]\\n                if val < 0:\\n                    neg += 1\\n                elif val == 0:\\n                    zero += 1\\n                    \\n                val = abs(matrix[i][j])\\n                tot += val\\n                if 0 < val < min1 :\\n                    min1 = val\\n                    \\n        while zero >=1 and neg%2 != 0:\\n            neg += 1\\n            zero -= 1\\n            \\n        if neg%2 != 0:\\n            return tot-(2*min1)\\n        return tot\\n                    \\n                    \\n                \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        given : n*n matrix\\n        goal : maximize summation of all elements in matrix\\n        \\n        1. The max possible sum can be sum of all positive elements in matrix i.e when all are positive.\\n        2. Now suppose if there are even number of -ve elements then they can be all turned to positive numbers \\n        and then again we can achieve the maximum result .\\n        eg : -1 2 1 -2\\n              3 1 -1 0\\n              1 -1 3 1\\n        see here even if all the negative elements are not adjacent to each other but it is given that\\n        we can perform this operation any number of times s\\n        \\n        so we can start with any one negative element keep multiplyting it with its adjacent element until \\n        we reach a point where both the elements are -ve and after multiplying each of them by -1 we get positive\\n        numbers .\\n        \\n        3. if there are odd number of -ve elements then we need to get the minimum number (greater than\\n        0 .\\n        \\n        Note : One catch here is that we can treat 0s and use them to swap with negative elements \\n        in this eg : \\n        -3 0 0\\n        0 0 0\\n        0 3 2\\n        zero = 6\\n        neg = 1\\n        since here only one negative element is present we might end up thinking that we cant make this \\n        to a positive number but instead we can make use of 0s . we ll use only that many number of zeros \\n        such that the count of negative number becomes even.\\n             \\n        \\'\\'\\'\\n        tot,min1,neg,zero = 0,sys.maxsize,0,0\\n        n = len(matrix)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                val = matrix[i][j]\\n                if val < 0:\\n                    neg += 1\\n                elif val == 0:\\n                    zero += 1\\n                    \\n                val = abs(matrix[i][j])\\n                tot += val\\n                if 0 < val < min1 :\\n                    min1 = val\\n                    \\n        while zero >=1 and neg%2 != 0:\\n            neg += 1\\n            zero -= 1\\n            \\n        if neg%2 != 0:\\n            return tot-(2*min1)\\n        return tot\\n                    \\n                    \\n                \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490412,
                "title": "golang-sort-solution",
                "content": "```go\\nfunc maxMatrixSum(matrix [][]int) int64 {\\n\\tvalues := make([]int, 0, len(matrix)*len(matrix[0]))\\n\\tnegative := 0\\n\\tfor _, row := range matrix {\\n\\t\\tfor _, item := range row {\\n\\t\\t\\tif item < 0 {\\n\\t\\t\\t\\tnegative++\\n\\t\\t\\t\\tvalues = append(values, -item)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalues = append(values, +item)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(values)\\n\\tif negative % 2 == 1 {\\n\\t\\tvalues[0] = -values[0]\\n\\t}\\n\\tsummary := int64(0)\\n\\tfor _, v := range values {\\n\\t\\tsummary += int64(v)\\n\\t}\\n\\treturn summary\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxMatrixSum(matrix [][]int) int64 {\\n\\tvalues := make([]int, 0, len(matrix)*len(matrix[0]))\\n\\tnegative := 0\\n\\tfor _, row := range matrix {\\n\\t\\tfor _, item := range row {\\n\\t\\t\\tif item < 0 {\\n\\t\\t\\t\\tnegative++\\n\\t\\t\\t\\tvalues = append(values, -item)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalues = append(values, +item)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(values)\\n\\tif negative % 2 == 1 {\\n\\t\\tvalues[0] = -values[0]\\n\\t}\\n\\tsummary := int64(0)\\n\\tfor _, v := range values {\\n\\t\\tsummary += int64(v)\\n\\t}\\n\\treturn summary\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486043,
                "title": "c-solution",
                "content": "**Intuition**\\n- Any two non-positive numbers can be moved adjacent and made non-negative, ignoring their positions.\\n- If the number of non-positive numbers is odd, there will be one non-positive number left at the end.\\n- In order to maximize the sum, we should keep the maximum non-positive number at the end.\\n\\n**Complexity**\\n- Time: O(m * n). We will traverse the matrix one time.\\n-  Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return 0;\\n        \\n        long sum = 0;\\n        int m = matrix.Length, n = matrix[0].Length, nonPostiveNumCnt = 0, minNonPostiveNum = Int32.MaxValue;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] <= 0)\\n                {\\n                    sum -= matrix[i][j];\\n                    minNonPostiveNum = Math.Min(minNonPostiveNum, -matrix[i][j]);\\n                    nonPostiveNumCnt++;\\n                }\\n                else\\n                {\\n                    sum += matrix[i][j];\\n                    minNonPostiveNum = Math.Min(minNonPostiveNum, matrix[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return nonPostiveNumCnt % 2 == 0? sum : sum - 2 * minNonPostiveNum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long MaxMatrixSum(int[][] matrix) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return 0;\\n        \\n        long sum = 0;\\n        int m = matrix.Length, n = matrix[0].Length, nonPostiveNumCnt = 0, minNonPostiveNum = Int32.MaxValue;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] <= 0)\\n                {\\n                    sum -= matrix[i][j];\\n                    minNonPostiveNum = Math.Min(minNonPostiveNum, -matrix[i][j]);\\n                    nonPostiveNumCnt++;\\n                }\\n                else\\n                {\\n                    sum += matrix[i][j];\\n                    minNonPostiveNum = Math.Min(minNonPostiveNum, matrix[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return nonPostiveNumCnt % 2 == 0? sum : sum - 2 * minNonPostiveNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475605,
                "title": "go-more-thinking-than-coding",
                "content": "Note, for any 2 negative cells in the matrix, you can make them positive by making a few 2-ajacent-cell flippings. \\nMore, if the matrix contains even number of negative cells, you can make them all positive; if the matrix contains odd number of negative cells, you will have one negative cell left, but you can choose the one with the minimum absolute value to left, so that you can get the maximum sum.\\n```\\nfunc maxMatrixSum(matrix [][]int) int64 {\\n    sum, neg, minAbs := int64(0), false, 100001\\n    for _, row := range matrix {\\n        for _, cell := range row {\\n            cellAbs := absInt(cell)\\n            sum += int64(cellAbs)\\n            if cell < 0 {\\n                neg = !neg\\n            }\\n            if minAbs > cellAbs {\\n                minAbs = cellAbs\\n            }\\n        }\\n    }\\n    if neg {\\n        sum -= int64(minAbs) * 2\\n    }\\n    return sum\\n}\\n\\nfunc absInt(v int) int {\\n    if v < 0 {\\n        return -v\\n    }\\n    return v\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxMatrixSum(matrix [][]int) int64 {\\n    sum, neg, minAbs := int64(0), false, 100001\\n    for _, row := range matrix {\\n        for _, cell := range row {\\n            cellAbs := absInt(cell)\\n            sum += int64(cellAbs)\\n            if cell < 0 {\\n                neg = !neg\\n            }\\n            if minAbs > cellAbs {\\n                minAbs = cellAbs\\n            }\\n        }\\n    }\\n    if neg {\\n        sum -= int64(minAbs) * 2\\n    }\\n    return sum\\n}\\n\\nfunc absInt(v int) int {\\n    if v < 0 {\\n        return -v\\n    }\\n    return v\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1442495,
                "title": "c-easy-solution-90-beat-o-n-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int total_negative=0;\\n        long long ans=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if(matrix[i][j]<0)\\n                {\\n                    total_negative++;\\n                }\\n            }\\n        }\\n        if(total_negative%2==0)\\n        {\\n            long long ans1=0;\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[i].size();j++)\\n                {\\n                    ans1+=abs(matrix[i][j]);\\n                }\\n            }\\n            return ans1;\\n        }\\n        else\\n        {\\n            int mini=INT_MAX;\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[i].size();j++)\\n                {\\n                    mini = min(abs(matrix[i][j]),mini);\\n                }\\n            }\\n            bool flag=false;\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[i].size();j++)\\n                {\\n                    if(abs(matrix[i][j])==mini && flag==false)\\n                    {\\n                        flag=true;\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        ans+=abs(matrix[i][j]);\\n                    }\\n                }\\n            }\\n            ans-=mini;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n        int total_negative=0;\\n        long long ans=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if(matrix[i][j]<0)\\n                {\\n                    total_negative++;\\n                }\\n            }\\n        }\\n        if(total_negative%2==0)\\n        {\\n            long long ans1=0;\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[i].size();j++)\\n                {\\n                    ans1+=abs(matrix[i][j]);\\n                }\\n            }\\n            return ans1;\\n        }\\n        else\\n        {\\n            int mini=INT_MAX;\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[i].size();j++)\\n                {\\n                    mini = min(abs(matrix[i][j]),mini);\\n                }\\n            }\\n            bool flag=false;\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[i].size();j++)\\n                {\\n                    if(abs(matrix[i][j])==mini && flag==false)\\n                    {\\n                        flag=true;\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        ans+=abs(matrix[i][j]);\\n                    }\\n                }\\n            }\\n            ans-=mini;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438192,
                "title": "c-simple-solution-beats-80",
                "content": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n    \\n        \\n        long long int ans = 0;\\n        int val = INT_MAX;\\n        int cnt = 0;\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                ans += abs(matrix[i][j]);\\n                val = min(val, abs(matrix[i][j]));\\n                if(matrix[i][j] <= 0){\\n                    cnt++;\\n                    //val = max(val, matrix[i][j]);\\n                }\\n            }\\n        }\\n        \\n        if(cnt % 2 == 0){\\n            return ans;\\n        }\\n        \\n        \\n        return ans - 2*abs(val);\\n    }\\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\\n    \\n        \\n        long long int ans = 0;\\n        int val = INT_MAX;\\n        int cnt = 0;\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                ans += abs(matrix[i][j]);\\n                val = min(val, abs(matrix[i][j]));\\n                if(matrix[i][j] <= 0){\\n                    cnt++;\\n                    //val = max(val, matrix[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1438123,
                "title": "c-negative-number-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {        \\n        int M = matrix.size(), Min = abs(matrix[0][0]), cnt2 = 0;\\n        long long sum = 0;\\n        for(int r=0; r<M; ++r) {\\n            int cnt = 0;\\n            for(int c=0; c<M; ++c) {\\n                sum += abs(matrix[r][c]);\\n                Min = min(Min, abs(matrix[r][c]));\\n                if(matrix[r][c] < 0) ++cnt;\\n            }\\n            if(cnt % 2) cnt2++;\\n        }\\n        if(cnt2&1)\\n            return sum - 2 * (Min);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxMatrixSum(vector<vector<int>>& matrix) {        \\n        int M = matrix.size(), Min = abs(matrix[0][0]), cnt2 = 0;\\n        long long sum = 0;\\n        for(int r=0; r<M; ++r) {\\n            int cnt = 0;\\n            for(int c=0; c<M; ++c) {\\n                sum += abs(matrix[r][c]);\\n                Min = min(Min, abs(matrix[r][c]));\\n                if(matrix[r][c] < 0) ++cnt;\\n            }\\n            if(cnt % 2) cnt2++;\\n        }\\n        if(cnt2&1)\\n            return sum - 2 * (Min);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1691340,
                "content": [
                    {
                        "username": "topswe",
                        "content": "observe : 1. if there are an even number of negatives, we can get rid of them all! just bubble the negatives towards each other... and pairwise become positive\\n\\n2. if there\\'s an odd number, we greedily pairwise the largest negatives in abs value. The remaining negative, we can actually transfer into the smallest absolute value... This is consistent with the case of a 0, we can transfer the last negative into the 0."
                    },
                    {
                        "username": "nezarnidam",
                        "content": "[@Day_Tripper](/Day_Tripper) Try initializing minm with number greater than 10^5. "
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "My Code does not work for the following testcase: 98 th Testcase.\\n\\nMy Code :\\n\\n\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        num_neg, summ, minm = 0,0,99999\\n        n = len(matrix)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                summ += abs(matrix[i][j])\\n\\n                minm = min(minm,abs(matrix[i][j]))\\n\\n                if matrix[i][j] < 0:\\n                    num_neg += 1\\n        \\n\\n        if num_neg % 2:\\n            return summ - 2*minm\\n        else:\\n            return summ\\n\\n"
                    },
                    {
                        "username": "francolai",
                        "content": "Hint:\\nIn the end we always want to have only 0 or 1 negative number in the matrix, and this is always possible."
                    },
                    {
                        "username": "Raman_Lamba",
                        "content": "don\\'t think it like a matrix but in terms of odd even number of -ve integers"
                    }
                ]
            },
            {
                "id": 2023078,
                "content": [
                    {
                        "username": "topswe",
                        "content": "observe : 1. if there are an even number of negatives, we can get rid of them all! just bubble the negatives towards each other... and pairwise become positive\\n\\n2. if there\\'s an odd number, we greedily pairwise the largest negatives in abs value. The remaining negative, we can actually transfer into the smallest absolute value... This is consistent with the case of a 0, we can transfer the last negative into the 0."
                    },
                    {
                        "username": "nezarnidam",
                        "content": "[@Day_Tripper](/Day_Tripper) Try initializing minm with number greater than 10^5. "
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "My Code does not work for the following testcase: 98 th Testcase.\\n\\nMy Code :\\n\\n\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        num_neg, summ, minm = 0,0,99999\\n        n = len(matrix)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                summ += abs(matrix[i][j])\\n\\n                minm = min(minm,abs(matrix[i][j]))\\n\\n                if matrix[i][j] < 0:\\n                    num_neg += 1\\n        \\n\\n        if num_neg % 2:\\n            return summ - 2*minm\\n        else:\\n            return summ\\n\\n"
                    },
                    {
                        "username": "francolai",
                        "content": "Hint:\\nIn the end we always want to have only 0 or 1 negative number in the matrix, and this is always possible."
                    },
                    {
                        "username": "Raman_Lamba",
                        "content": "don\\'t think it like a matrix but in terms of odd even number of -ve integers"
                    }
                ]
            },
            {
                "id": 2015250,
                "content": [
                    {
                        "username": "topswe",
                        "content": "observe : 1. if there are an even number of negatives, we can get rid of them all! just bubble the negatives towards each other... and pairwise become positive\\n\\n2. if there\\'s an odd number, we greedily pairwise the largest negatives in abs value. The remaining negative, we can actually transfer into the smallest absolute value... This is consistent with the case of a 0, we can transfer the last negative into the 0."
                    },
                    {
                        "username": "nezarnidam",
                        "content": "[@Day_Tripper](/Day_Tripper) Try initializing minm with number greater than 10^5. "
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "My Code does not work for the following testcase: 98 th Testcase.\\n\\nMy Code :\\n\\n\\nclass Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        num_neg, summ, minm = 0,0,99999\\n        n = len(matrix)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                summ += abs(matrix[i][j])\\n\\n                minm = min(minm,abs(matrix[i][j]))\\n\\n                if matrix[i][j] < 0:\\n                    num_neg += 1\\n        \\n\\n        if num_neg % 2:\\n            return summ - 2*minm\\n        else:\\n            return summ\\n\\n"
                    },
                    {
                        "username": "francolai",
                        "content": "Hint:\\nIn the end we always want to have only 0 or 1 negative number in the matrix, and this is always possible."
                    },
                    {
                        "username": "Raman_Lamba",
                        "content": "don\\'t think it like a matrix but in terms of odd even number of -ve integers"
                    }
                ]
            }
        ]
    }
]