[
    {
        "title": "Find the Width of Columns of a Grid",
        "question_content": "You are given a 0-indexed m x n integer matrix grid. The width of a column is the maximum length of its integers.\n\n\tFor example, if grid = [[-10], [3], [12]], the width of the only column is 3 since -10 is of length 3.\n\nReturn an integer array ans of size n where ans[i] is the width of the ith column.\nThe length of an integer x with len digits is equal to len if x is non-negative, and len + 1 otherwise.\n&nbsp;\nExample 1:\n\nInput: grid = [[1],[22],[333]]\nOutput: [3]\nExplanation: In the 0th column, 333 is of length 3.\n\nExample 2:\n\nInput: grid = [[-15,1,3],[15,7,12],[5,6,-2]]\nOutput: [3,1,2]\nExplanation: \nIn the 0th column, only -15 is of length 3.\nIn the 1st column, all integers are of length 1. \nIn the 2nd column, both 12 and -2 are of length 2.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 100 \n\t-109 <= grid[r][c] <= 109",
        "solutions": [
            {
                "id": 3419979,
                "title": "python-1-liner-solution",
                "content": "# **Explanation**\\ntranspose the grid `zip(*A)` first,\\nthen get the string length of each element,\\nreturn the max length of each row.\\n<br>\\n\\n\\n**Python**\\n```py\\n    def findColumnWidth(self, A: List[List[int]]) -> List[int]:\\n        return [max(len(str(a)) for a in r) for r in zip(*A)]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def findColumnWidth(self, A: List[List[int]]) -> List[int]:\\n        return [max(len(str(a)) for a in r) for r in zip(*A)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420183,
                "title": "c-simplest-solution-ever-exists-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are going to traverse the matrix column wise and then storing the maximum length of number in that column index of `ans` vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the maximum length of any number we can just convert it to a string and find it length.\\nIn this way, we can easily find the maximum width of each column.\\n\\n# Complexity\\n- **Time complexity:** O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe need to traverse the matrix and perform a constant operation for every number.\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n    \\n        for(int j=0; j<n; j++){\\n            int l=0;\\n            for(int i=0; i<m; i++){\\n                l = max(l, int(to_string(grid[i][j]).size()));\\n            }\\n            ans[j] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n    \\n        for(int j=0; j<n; j++){\\n            int l=0;\\n            for(int i=0; i<m; i++){\\n                l = max(l, int(to_string(grid[i][j]).size()));\\n            }\\n            ans[j] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420289,
                "title": "iteration-with-string-conversion-very-simple-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans(grid[0].size(), 1);\\n        for(auto i = 0; i < grid[0].size(); ++i){\\n            for(auto j = 0; j < grid.size(); ++j){\\n                int t = to_string(grid[j][i]).size(); \\n                ans[i] = max(ans[i], t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans(grid[0].size(), 1);\\n        for(auto i = 0; i < grid[0].size(); ++i){\\n            for(auto j = 0; j < grid.size(); ++j){\\n                int t = to_string(grid[j][i]).size(); \\n                ans[i] = max(ans[i], t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420023,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                max=Math.max(max,String.valueOf(grid[j][i]).length());\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                max=Math.max(max,String.valueOf(grid[j][i]).length());\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426059,
                "title": "easy-c-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert each integer into a string. Strings are easier to handle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse from every column row wise, convert cell data into the string, use string.size() to compare the length of integers and keep track of largest length.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(number of columns)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> res;\\n        string s;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int digit=0;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                    s=to_string(grid[j][i]);\\n                    if(digit<s.size())\\n                        digit=s.size();\\n            }\\n            res.push_back(digit);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> res;\\n        string s;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int digit=0;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                    s=to_string(grid[j][i]);\\n                    if(digit<s.size())\\n                        digit=s.size();\\n            }\\n            res.push_back(digit);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421661,
                "title": "leetcode-the-hard-way-transpose-and-count-digits",
                "content": "The idea is to first transpose `grid` using `zip`. Then we calculate the number of digits and take the max. Alternatively we can convert to string and check the length.\\n\\n```py\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        def cal(x):\\n            res = 0\\n            if x == 0:\\n                res += 1\\n            if x < 0:\\n                res += 1\\n                x = -x\\n            while x > 0:\\n                x //= 10\\n                res += 1\\n            return res\\n        res = []\\n        for x in zip(*grid):\\n            mx = 1\\n            for y in x:\\n                mx = max(mx, cal(y))\\n            res.append(mx)\\n        return res\\n```\\n\\nOf course it can be further simplifed to \\n\\n```py\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        def cal(x):\\n            res = 0\\n            if x == 0:\\n                res += 1\\n            if x < 0:\\n                res += 1\\n                x = -x\\n            while x > 0:\\n                x //= 10\\n                res += 1\\n            return res\\n        \\n        return [max(cal(y) for y in x) for x in zip(*grid)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        def cal(x):\\n            res = 0\\n            if x == 0:\\n                res += 1\\n            if x < 0:\\n                res += 1\\n                x = -x\\n            while x > 0:\\n                x //= 10\\n                res += 1\\n            return res\\n        res = []\\n        for x in zip(*grid):\\n            mx = 1\\n            for y in x:\\n                mx = max(mx, cal(y))\\n            res.append(mx)\\n        return res\\n```\n```py\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        def cal(x):\\n            res = 0\\n            if x == 0:\\n                res += 1\\n            if x < 0:\\n                res += 1\\n                x = -x\\n            while x > 0:\\n                x //= 10\\n                res += 1\\n            return res\\n        \\n        return [max(cal(y) for y in x) for x in zip(*grid)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421145,
                "title": "c-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& g) {\\n        vector<int>a;\\n        int n=g.size();\\n        int m=g[0].size();\\n        for(int i=0;i<m;i++){\\n            int mx=0;\\n            for(int j=0;j<n;j++){\\n                long long h=g[j][i];\\n                int a=0;\\n                if(h<0)a++;\\n                h=abs(h);\\n                if(h==0)a=1;\\n                while(h){\\n                    a++;\\n                    h/=10;\\n                }\\n                mx=max(mx,a);\\n            }\\n            a.push_back(mx);\\n        }\\n        return a;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/adcc5c41-3614-49cb-b16a-ef9c15c202b7_1681589876.6375532.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& g) {\\n        vector<int>a;\\n        int n=g.size();\\n        int m=g[0].size();\\n        for(int i=0;i<m;i++){\\n            int mx=0;\\n            for(int j=0;j<n;j++){\\n                long long h=g[j][i];\\n                int a=0;\\n                if(h<0)a++;\\n                h=abs(h);\\n                if(h==0)a=1;\\n                while(h){\\n                    a++;\\n                    h/=10;\\n                }\\n                mx=max(mx,a);\\n            }\\n            a.push_back(mx);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420288,
                "title": "c-solution-beats-100",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m * n) * log10(grid[i][j])$$\\nm = grid[0].size(), n = grid.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int length(int n) {\\n        int count = n > 0 ? 0 : 1;\\n        while(n) {\\n            n /= 10;\\n            count++;\\n        }\\n        return count;\\n    }\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans(m);\\n        for(int j = 0; j < m; j++) {\\n            for(int i = 0; i < n; i++) {\\n                int len = length(grid[i][j]);\\n                ans[j] = max(ans[j], len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int length(int n) {\\n        int count = n > 0 ? 0 : 1;\\n        while(n) {\\n            n /= 10;\\n            count++;\\n        }\\n        return count;\\n    }\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans(m);\\n        for(int j = 0; j < m; j++) {\\n            for(int i = 0; i < n; i++) {\\n                int len = length(grid[i][j]);\\n                ans[j] = max(ans[j], len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420198,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nWe need to calculate the maximum width of each column in the given matrix. We can do this by iterating over each element in the matrix and keeping track of the maximum width of each column.\\n\\n\\n# Approach\\n1. Initialize a list widths of size n with all elements as 0.\\n2. Iterate over each column j in the matrix, and for each column, iterate over all rows i.\\n3. For each element grid[i][j], calculate its width width by finding the length of its absolute value (using abs()) and adding 1 if it is negative.\\n4. Update the maximum width of the column j by taking the maximum of width and the current maximum width widths[j].\\n5. Return the list widths containing the maximum width of each column.\\n# Complexity\\n- Time complexity:\\nWe are iterating over all elements in the matrix once, so the time complexity is O(mn)\\n- Space complexity:\\nWe are using a list of size n to store the maximum width of each column, so the space complexity is O(n).\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        widths = [0] * n  \\n        for j in range(n):\\n            for i in range(m):\\n                width = len(str(abs(grid[i][j])))\\n                if grid[i][j] < 0:\\n                    width += 1 \\n                widths[j] = max(widths[j], width)\\n        return widths\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        widths = [0] * n  \\n        for j in range(n):\\n            for i in range(m):\\n                width = len(str(abs(grid[i][j])))\\n                if grid[i][j] < 0:\\n                    width += 1 \\n                widths[j] = max(widths[j], width)\\n        return widths\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420047,
                "title": "java-python-3-java-8-liner-and-python-1-liner-w-brief-analysis",
                "content": "\\n\\n```java\\n    public int[] findColumnWidth(int[][] grid) {\\n        int C = grid[0].length;\\n        int[] ans = new int[C];\\n        for (int c = 0, R = grid.length; c < C; ++c) {\\n            for (int r = 0; r < R; ++r) {\\n                ans[c] = Math.max(ans[c], Integer.toString(grid[r][c]).length());\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(map(len, map(str, col))) for col in zip(*grid)]\\n```\\n\\n**Analysis:**\\n\\nTime: `O(R * C)`, space: `O(C)`, where `R = grid.length, C = grid[0].length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int[] findColumnWidth(int[][] grid) {\\n        int C = grid[0].length;\\n        int[] ans = new int[C];\\n        for (int c = 0, R = grid.length; c < C; ++c) {\\n            for (int r = 0; r < R; ++r) {\\n                ans[c] = Math.max(ans[c], Integer.toString(grid[r][c]).length());\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(map(len, map(str, col))) for col in zip(*grid)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420018,
                "title": "c-using-log10",
                "content": "# Intuition\\nThe number of digits in an integer x can be found by calculating the logarithm of x to the base 10 and adding 1. This is because the logarithm of a number to base 10 gives the power to which 10 must be raised to obtain that number. \\nFor example, log10(1000) = 3, because 10 raised to the power of 3 gives 1000.\\n\\nIn the code, the log10 function is used to calculate the logarithm of the integer in each grid element to base 10. The resulting value is then added to 1 to get the number of digits in the integer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int>ans(n);\\n        for(int j=0;j<n;++j){\\n            int len=1;\\n            for(int i=0;i<m;++i){\\n                if(grid[i][j]<0) len=max(len,int(log10(-grid[i][j]) + 1)+1);\\n                else if(grid[i][j]>9) len=max(len,int(log10(grid[i][j]) + 1));\\n            }\\n            ans[j]=len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int>ans(n);\\n        for(int j=0;j<n;++j){\\n            int len=1;\\n            for(int i=0;i<m;++i){\\n                if(grid[i][j]<0) len=max(len,int(log10(-grid[i][j]) + 1)+1);\\n                else if(grid[i][j]>9) len=max(len,int(log10(grid[i][j]) + 1));\\n            }\\n            ans[j]=len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422821,
                "title": "java-easy-explained-beats-100-2ms-using-log10",
                "content": "# Intuition\\nLength of an Integer can be found out using log<sub>10</sub>(n) + 1\\nWe need understand that \\nif (x > y) \\nthen \\nlength of x >= length of y\\n\\n<b>for example</b>\\n=> 1923 > 100 \\n=> length of 1923 >= length of 100 \\n=> 4 >= 3\\n\\nor 1001 > 1000 i.e 4 >= 4\\nso with the value of a integer we can tell whose length largest\\n\\nbut what happens when the no. is < 0 here we have to count \"-\" and cannot compare with positive integers, so to overcome this we can convert the negative integer into positive one which has same length by multiplying it with -10.\\n<b>for example</b> -: \\n=> -3564*(-10) \\n=> 35640 , still have the same length.\\n\\nNow just find the largest no. in a column and take its logarithm.  \\n\\n# Approach\\nBasic use of log<sub>10</sub>(n)\\n\\n# Complexity\\n- Time complexity:  O(m*n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n     public int[] findColumnWidth(int[][] grid) {\\n        int len = grid.length;\\n        int len1 = grid[0].length;\\n        int ans[] = new int[len1];\\n        for(int i = 0; i < len1; i++)\\n        {\\n            long ma = 0;\\n            for(int j = 0; j < len;j++)\\n            {\\n                long c = grid[j][i];\\n                if(c < 0)\\n                    c *= -10;\\n                if(c > ma)\\n                    ma = c;\\n            }\\n            if(ma > 0)\\n                ans[i] = (int)(Math.log10(ma));\\n            ans[i]++;\\n        }\\n        return ans;\\n    }\\n }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n class Solution {\\n     public int[] findColumnWidth(int[][] grid) {\\n        int len = grid.length;\\n        int len1 = grid[0].length;\\n        int ans[] = new int[len1];\\n        for(int i = 0; i < len1; i++)\\n        {\\n            long ma = 0;\\n            for(int j = 0; j < len;j++)\\n            {\\n                long c = grid[j][i];\\n                if(c < 0)\\n                    c *= -10;\\n                if(c > ma)\\n                    ma = c;\\n            }\\n            if(ma > 0)\\n                ans[i] = (int)(Math.log10(ma));\\n            ans[i]++;\\n        }\\n        return ans;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420119,
                "title": "number-to-string",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        res = []\\n        for i in range(len(grid[0])):\\n            max_ = 0\\n            for j in range(len(grid)):\\n                max_ = max(max_, len(str(grid[j][i])))\\n            res.append(max_)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        res = []\\n        for i in range(len(grid[0])):\\n            max_ = 0\\n            for j in range(len(grid)):\\n                max_ = max(max_, len(str(grid[j][i])))\\n            res.append(max_)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420005,
                "title": "short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int [] arr = new int[grid[0].length];\\n        for(int i=0; i<grid[0].length; i++){\\n            for(int j=0; j<grid.length; j++){\\n                arr[i] = Math.max(arr[i],String.valueOf(grid[j][i]).length());\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int [] arr = new int[grid[0].length];\\n        for(int i=0; i<grid[0].length; i++){\\n            for(int j=0; j<grid.length; j++){\\n                arr[i] = Math.max(arr[i],String.valueOf(grid[j][i]).length());\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518753,
                "title": "c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size(),i,j;\\n        vector<int> ans(n);\\n        int y=0;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                y = 0;\\n                if(grid[i][j]<0 || grid[i][j]==0){y++;grid[i][j]*=-1;}\\n                while(grid[i][j]>0){\\n                    y++;\\n                    grid[i][j] /= 10;\\n                }\\n                ans[j] = max(ans[j],y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size(),i,j;\\n        vector<int> ans(n);\\n        int y=0;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                y = 0;\\n                if(grid[i][j]<0 || grid[i][j]==0){y++;grid[i][j]*=-1;}\\n                while(grid[i][j]>0){\\n                    y++;\\n                    grid[i][j] /= 10;\\n                }\\n                ans[j] = max(ans[j],y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420404,
                "title": "one-liner",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def findColumnWidth(self, g: List[List[int]]) -> List[int]:\\n        return [max(len(str(n)) for n in row) for row in list(map(list, zip(*g)))]\\n```\\n\\n**C++**\\n```cpp\\nvector<int> findColumnWidth(vector<vector<int>>& g) {\\n    vector<int> res(g[0].size());\\n    for (const auto& r : g)\\n        for (int i = 0; i < r.size(); ++i)\\n            res[i] = max(res[i], (int)to_string(r[i]).size());\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findColumnWidth(self, g: List[List[int]]) -> List[int]:\\n        return [max(len(str(n)) for n in row) for row in list(map(list, zip(*g)))]\\n```\n```cpp\\nvector<int> findColumnWidth(vector<vector<int>>& g) {\\n    vector<int> res(g[0].size());\\n    for (const auto& r : g)\\n        for (int i = 0; i < r.size(); ++i)\\n            res[i] = max(res[i], (int)to_string(r[i]).size());\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439432,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        l=[0]*len(grid[0])\\n        for i in grid:\\n            for j in range(len(i)):\\n                x=len(str(i[j]))\\n                l[j]=max(x,l[j])\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        l=[0]*len(grid[0])\\n        for i in grid:\\n            for j in range(len(i)):\\n                x=len(str(i[j]))\\n                l[j]=max(x,l[j])\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420106,
                "title": "c-number-to-string-short-sweet-code-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        vector<int> ans(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                k = to_string(grid[i][j]).length();\\n                ans[j] = max(ans[j],k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        vector<int> ans(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                k = to_string(grid[i][j]).length();\\n                ans[j] = max(ans[j],k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420090,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int> ansf;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans=INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n                string temp=to_string(grid[j][i]);\\n                int sz=temp.size();\\n                ans=max(ans,sz);\\n            }\\n            ansf.push_back(ans);\\n        }\\n        \\n        return ansf;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int> ansf;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans=INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n                string temp=to_string(grid[j][i]);\\n                int sz=temp.size();\\n                ans=max(ans,sz);\\n            }\\n            ansf.push_back(ans);\\n        }\\n        \\n        return ansf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420077,
                "title": "simple-easiest-solution-python3-faster-than-100",
                "content": "## Python3\\nT:C = O(m*n)\\nS.C = O(n)\\n\\n```class Solution:\\n    def findColumnWidth(self, matrix: List[List[int]]) -> List[int]:\\n        result = [0] * len(matrix[0])\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                result[j] = max(result[j],len(str(matrix[i][j])))\\n        return result\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## Python3\\nT:C = O(m*n)\\nS.C = O(n)\\n\\n```class Solution:\\n    def findColumnWidth(self, matrix: List[List[int]]) -> List[int]:\\n        result = [0] * len(matrix[0])\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                result[j] = max(result[j],len(str(matrix[i][j])))\\n        return result\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3920270,
                "title": "optimal-approach-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n X m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m)\\nFor storing the answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<int> ans;\\n        int len = 0;\\n        int maxLen = 0;\\n        string temp;\\n        \\n        for(int col=0;col<m;col++) {\\n            temp = \"\";\\n            len = 0;\\n            maxLen = 0;\\n            \\n            for(int row=0;row<n;row++) {\\n                temp = to_string(grid[row][col]);\\n                len = temp.length();\\n                maxLen = max(maxLen,len);\\n            }\\n            ans.push_back(maxLen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<int> ans;\\n        int len = 0;\\n        int maxLen = 0;\\n        string temp;\\n        \\n        for(int col=0;col<m;col++) {\\n            temp = \"\";\\n            len = 0;\\n            maxLen = 0;\\n            \\n            for(int row=0;row<n;row++) {\\n                temp = to_string(grid[row][col]);\\n                len = temp.length();\\n                maxLen = max(maxLen,len);\\n            }\\n            ans.push_back(maxLen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425953,
                "title": "if-else-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int>ans;\\n\\t//processing the query of the every \\n\\tfor(int j=0;j<n;j++)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t{\\n\\t\\t\\tint val = mat[i][j];\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tbool neg = false;\\n\\t\\t\\t\\n\\t\\t\\tif(val < 0){\\n\\t\\t\\t    neg = true;\\n\\t\\t\\t\\tval = abs(val);\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\tlen = getlen(val);\\n\\t\\t\\tif(neg == true) len++;\\n            if(val == 0) len++;\\n\\t\\t\\tresult = max(result,len);\\n\\t\\t}\\n\\t\\tans.push_back(result);\\n\\t}\\n\\treturn ans;\\n}\\nint getlen(int val)\\n{\\n\\tint len = 0;\\n\\twhile(val > 0)\\n\\t{\\n\\t\\tlen++;\\n\\t\\tval = val/10;\\n\\t}\\n\\treturn len;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int>ans;\\n\\t//processing the query of the every \\n\\tfor(int j=0;j<n;j++)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t{\\n\\t\\t\\tint val = mat[i][j];\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tbool neg = false;\\n\\t\\t\\t\\n\\t\\t\\tif(val < 0){\\n\\t\\t\\t    neg = true;\\n\\t\\t\\t\\tval = abs(val);\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\tlen = getlen(val);\\n\\t\\t\\tif(neg == true) len++;\\n            if(val == 0) len++;\\n\\t\\t\\tresult = max(result,len);\\n\\t\\t}\\n\\t\\tans.push_back(result);\\n\\t}\\n\\treturn ans;\\n}\\nint getlen(int val)\\n{\\n\\tint len = 0;\\n\\twhile(val > 0)\\n\\t{\\n\\t\\tlen++;\\n\\t\\tval = val/10;\\n\\t}\\n\\treturn len;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425865,
                "title": "javascript-solution-easy-to-understand-short-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    const m = grid.length\\n    const n = grid[0].length\\n    const ans = []\\n    for (let j = 0; j < n; j++) {\\n      let len = 1\\n      for (let i = 0; i < m; i++) {\\n        len = Math.max(len, grid[i][j].toString().length)\\n      }\\n      ans.push(len)\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    const m = grid.length\\n    const n = grid[0].length\\n    const ans = []\\n    for (let j = 0; j < n; j++) {\\n      let len = 1\\n      for (let i = 0; i < m; i++) {\\n        len = Math.max(len, grid[i][j].toString().length)\\n      }\\n      ans.push(len)\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424781,
                "title": "c-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int len(int n){\\n        int ans=0;\\n        while (n>0){\\n            ans++;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int n= grid.size(); int m= grid[0].size();\\n        for (int i=0; i<m; i++){\\n            int mini= INT_MAX; int maxi= INT_MIN;\\n            for(int j=0; j<n; j++){\\n                mini= min(grid[j][i],mini);\\n                maxi= max(grid[j][i],maxi);\\n            }\\n            int n1=0; int n2=0;\\n            if (mini<0 && maxi<0){\\n                ans.push_back(len(abs(mini))+1);\\n            }\\n            else if (maxi>0 && mini>0){\\n                ans.push_back(len(abs(maxi)));\\n            }\\n            else{\\n                ans.push_back(max(len(abs(mini))+1,len(maxi)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int len(int n){\\n        int ans=0;\\n        while (n>0){\\n            ans++;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int n= grid.size(); int m= grid[0].size();\\n        for (int i=0; i<m; i++){\\n            int mini= INT_MAX; int maxi= INT_MIN;\\n            for(int j=0; j<n; j++){\\n                mini= min(grid[j][i],mini);\\n                maxi= max(grid[j][i],maxi);\\n            }\\n            int n1=0; int n2=0;\\n            if (mini<0 && maxi<0){\\n                ans.push_back(len(abs(mini))+1);\\n            }\\n            else if (maxi>0 && mini>0){\\n                ans.push_back(len(abs(maxi)));\\n            }\\n            else{\\n                ans.push_back(max(len(abs(mini))+1,len(maxi)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424551,
                "title": "java-no-explanation-required",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                String s = grid[i][j] + \"\";\\n                ans[j] = Math.max(ans[j], s.length());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n### Time complexity: $$O(nm)$$\\n### Space complexity: $$O(m)$$",
                "solutionTags": [
                    "Java",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                String s = grid[i][j] + \"\";\\n                ans[j] = Math.max(ans[j], s.length());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422770,
                "title": "c-easy-solution-using-to-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        vector<int> ans;\\n        \\n        for(int row=0;row<n;row++){\\n            int maxi=1;\\n            for( int col=0;col<m;col++){\\n                    \\n                    string s=to_string(grid[col][row]);\\n                    int size=s.size();\\n\\n                    maxi=max(maxi,size);\\n    \\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        vector<int> ans;\\n        \\n        for(int row=0;row<n;row++){\\n            int maxi=1;\\n            for( int col=0;col<m;col++){\\n                    \\n                    string s=to_string(grid[col][row]);\\n                    int size=s.size();\\n\\n                    maxi=max(maxi,size);\\n    \\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422288,
                "title": "java-simple-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans[]=new int[n];\\n        \\n        for(int j=0;j<n;j++){\\n            int max=1;\\n            for(int i=0;i<m;i++){\\n                int len=find(Math.abs(grid[i][j]));\\n                if(grid[i][j]<0){\\n                    len=len+1;\\n                }\\n                max=Math.max(max,len);\\n            }\\n            ans[j]=max;\\n        }\\n        return ans;\\n    }\\n    \\n    public int find(int number){\\n        int count=0;\\n        while(number!=0){\\n            number=number/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans[]=new int[n];\\n        \\n        for(int j=0;j<n;j++){\\n            int max=1;\\n            for(int i=0;i<m;i++){\\n                int len=find(Math.abs(grid[i][j]));\\n                if(grid[i][j]<0){\\n                    len=len+1;\\n                }\\n                max=Math.max(max,len);\\n            }\\n            ans[j]=max;\\n        }\\n        return ans;\\n    }\\n    \\n    public int find(int number){\\n        int count=0;\\n        while(number!=0){\\n            number=number/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422196,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_column_width(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans = vec![0; grid[0].len()];\\n        for row in grid {\\n            for (i, col) in row.iter().enumerate() {\\n                ans[i] = ans[i].max(col.to_string().len() as i32);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_column_width(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans = vec![0; grid[0].len()];\\n        for row in grid {\\n            for (i, col) in row.iter().enumerate() {\\n                ans[i] = ans[i].max(col.to_string().len() as i32);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422024,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int>v;\\n        for(int i=0; i<grid[0].size(); i++){\\n            int ans=0;\\n            for(int j=0; j<grid.size(); j++){\\n                int cnt1=0;\\n                if(grid[j][i]<=0){cnt1++;}\\n                int l=abs(grid[j][i]);\\n                while(l){\\n                    l/=10;\\n                    cnt1++;\\n                }\\n                ans=max(ans, cnt1);\\n            }\\n            v.push_back(ans);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int>v;\\n        for(int i=0; i<grid[0].size(); i++){\\n            int ans=0;\\n            for(int j=0; j<grid.size(); j++){\\n                int cnt1=0;\\n                if(grid[j][i]<=0){cnt1++;}\\n                int l=abs(grid[j][i]);\\n                while(l){\\n                    l/=10;\\n                    cnt1++;\\n                }\\n                ans=max(ans, cnt1);\\n            }\\n            v.push_back(ans);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421660,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nWe iterate through 2D array and keep track of max lengthed element on that particular index by changing values in array that we need to return. Figuring out length can be done easily by using methods of Java Library. We did it by converting number to string and then getting its length.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M x N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        // To store max length at index j\\n        int[] ans=new int[grid[0].length];\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                // Converting number to string\\n                int x=Integer.toString(grid[i][j]).length();\\n\\n                // checking if current length is greater than max length\\n                if(x>ans[j])\\n                    ans[j]=x;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        // To store max length at index j\\n        int[] ans=new int[grid[0].length];\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                // Converting number to string\\n                int x=Integer.toString(grid[i][j]).length();\\n\\n                // checking if current length is greater than max length\\n                if(x>ans[j])\\n                    ans[j]=x;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420819,
                "title": "python-rotate-matrix-and-calc",
                "content": "```python\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        a = list(zip(*grid[::-1]))\\n        r = []\\n\\n        for col in a:\\n            m = 0\\n            for n in col:\\n                m = max(m, len(str(n)))\\n            r.append(m)\\n            \\n        return r\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        a = list(zip(*grid[::-1]))\\n        r = []\\n\\n        for col in a:\\n            m = 0\\n            for n in col:\\n                m = max(m, len(str(n)))\\n            r.append(m)\\n            \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420746,
                "title": "c-easytounderstand-stringconversion-optimalsolution-clean-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        \\n        vector<int> ans;\\n        for(int i=0;i<grid[0].size();i++){\\n            int maxi = 0;\\n            for(int j=0;j<grid.size();j++){\\n                string str = to_string(grid[j][i]);\\n                int n = str.size();\\n                maxi = max(n,maxi);\\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        \\n        vector<int> ans;\\n        for(int i=0;i<grid[0].size();i++){\\n            int maxi = 0;\\n            for(int j=0;j<grid.size();j++){\\n                string str = to_string(grid[j][i]);\\n                int n = str.size();\\n                maxi = max(n,maxi);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3420650,
                "title": "easy-solution-you-must-feel-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int ans [] = new int[grid[0].length];\\n\\n        for( int i = 0 ; i < grid[0].length ; i++ ){\\n            int max = 0;\\n            for( int j = 0 ; j < grid.length ; j++ ){\\n                max = Math.max( max , String.valueOf( grid[j][i] ).length() );\\n            }\\n            ans[i] = max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int ans [] = new int[grid[0].length];\\n\\n        for( int i = 0 ; i < grid[0].length ; i++ ){\\n            int max = 0;\\n            for( int j = 0 ; j < grid.length ; j++ ){\\n                max = Math.max( max , String.valueOf( grid[j][i] ).length() );\\n            }\\n            ans[i] = max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420532,
                "title": "best-solution-you-will-ever-see-convert-to-string-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> ans;\\n        for(int j=0; j<m; j++) //first write iterator for column\\n        {\\n            int maxLen = INT_MIN;\\n            for(int i=0; i<n; i++) //then write iterator fo row\\n            {\\n                int k = to_string(grid[i][j]).size(); //this will give number of chracters in current number\\n                maxLen = max(maxLen,k);\\n             }\\n            ans.push_back(maxLen); //push maximum length of the element found in this column in the answer vector                 \\n        }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> ans;\\n        for(int j=0; j<m; j++) //first write iterator for column\\n        {\\n            int maxLen = INT_MIN;\\n            for(int i=0; i<n; i++) //then write iterator fo row\\n            {\\n                int k = to_string(grid[i][j]).size(); //this will give number of chracters in current number\\n                maxLen = max(maxLen,k);\\n             }\\n            ans.push_back(maxLen); //push maximum length of the element found in this column in the answer vector                 \\n        }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420353,
                "title": "c-well-explained-o-n-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply take every element from a column and calculate the length of this element and store the max value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N * M)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n)    {\\n        if(n==0)    return 1;\\n        int cnt = 0;\\n        if(n<0) cnt++;\\n        n = abs(n);\\n        while(n)    {\\n            cnt++;\\n            n /= 10;\\n        }\\n        return cnt;\\n    }\\n    \\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<m; i++)  {   // for every column\\n            int maxi = 0;\\n            // here column is fixed and traverse every row\\n            // for i = 0 : (0, 0) , (1, 0), (2, 0) .... (n - 1, 0)\\n            // for i = 1 : (0, 1) , (1, 1), (2, 1) .... (n - 1, 1)\\n            // for i = 2 : (0, 2) , (1, 2), (2, 2) .... (n - 1, 2)\\n\\n\\n            // for i = m-1 : (0, m-1) , (1, m-1), (2, m-1) .... (n - 1, m-1)\\n            for(int j=0; j<n; j++)  {   // for every row\\n                maxi = max(maxi, solve(grid[j][i]));\\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n)    {\\n        if(n==0)    return 1;\\n        int cnt = 0;\\n        if(n<0) cnt++;\\n        n = abs(n);\\n        while(n)    {\\n            cnt++;\\n            n /= 10;\\n        }\\n        return cnt;\\n    }\\n    \\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<m; i++)  {   // for every column\\n            int maxi = 0;\\n            // here column is fixed and traverse every row\\n            // for i = 0 : (0, 0) , (1, 0), (2, 0) .... (n - 1, 0)\\n            // for i = 1 : (0, 1) , (1, 1), (2, 1) .... (n - 1, 1)\\n            // for i = 2 : (0, 2) , (1, 2), (2, 2) .... (n - 1, 2)\\n\\n\\n            // for i = m-1 : (0, m-1) , (1, m-1), (2, m-1) .... (n - 1, m-1)\\n            for(int j=0; j<n; j++)  {   // for every row\\n                maxi = max(maxi, solve(grid[j][i]));\\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420276,
                "title": "c-tostring",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int[] FindColumnWidth(int[][] grid) \\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            int lenght = 0;\\n            for (int j = 0; j < m; j++)\\n            {\\n                lenght = Math.Max(lenght, grid[j][i].ToString().Length);\\n            }\\n            result[i] = lenght;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] FindColumnWidth(int[][] grid) \\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            int lenght = 0;\\n            for (int j = 0; j < m; j++)\\n            {\\n                lenght = Math.Max(lenght, grid[j][i].ToString().Length);\\n            }\\n            result[i] = lenght;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420239,
                "title": "easy-c",
                "content": "# Intuition\\nHere we traverse the grid columnwise \\nand just maintain maximum of all cell\\'s length\\nlength for positive would be ( e.g. 50 then convert to string and find length )\\nlength for negative was length + 1 ( e.g. -50 then convert to string and find length ( now this length will have +1 of the negative sign itself ))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<int> ans(m,0);\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(to_string(grid[i][j]).length() > ans[j])\\n                {\\n                    ans[j] = to_string(grid[i][j]).length();\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<int> ans(m,0);\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(to_string(grid[i][j]).length() > ans[j])\\n                {\\n                    ans[j] = to_string(grid[i][j]).length();\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420197,
                "title": "short-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        vector<int> ans(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                k = to_string(grid[i][j]).length();\\n                ans[j] = max(ans[j],k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        vector<int> ans(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                k = to_string(grid[i][j]).length();\\n                ans[j] = max(ans[j],k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420158,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < grid[0].length; i++) {\\n            int maxLength = 0;\\n            for(int j = 0; j < grid.length; j++) {\\n                int len = lengthOfNumber(grid[j][i]);\\n                maxLength = Math.max(maxLength, len);\\n            }\\n            ans[index++] = maxLength;\\n        }\\n        return ans;\\n    }\\n    \\n    private int lengthOfNumber(int n) {\\n        int length = 0;\\n        if(n <= 0) {\\n            length++;\\n            n = -n;\\n        }\\n        \\n        while(n > 0) {\\n            n = n / 10;\\n            length++;\\n        }\\n        return length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < grid[0].length; i++) {\\n            int maxLength = 0;\\n            for(int j = 0; j < grid.length; j++) {\\n                int len = lengthOfNumber(grid[j][i]);\\n                maxLength = Math.max(maxLength, len);\\n            }\\n            ans[index++] = maxLength;\\n        }\\n        return ans;\\n    }\\n    \\n    private int lengthOfNumber(int n) {\\n        int length = 0;\\n        if(n <= 0) {\\n            length++;\\n            n = -n;\\n        }\\n        \\n        while(n > 0) {\\n            n = n / 10;\\n            length++;\\n        }\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420133,
                "title": "python3-oneliner-explained",
                "content": "# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(len(str(x)) for x in row) for row in list(zip(*grid))]\\n```\\n# Explanation in Python\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        R,C=len(grid),len(grid[0])\\n        answ=[0]*C\\n        for r in range(R):\\n            for c in range(C):\\n                answ[c]=max(answ[c],len(str(grid[r][c])))\\n        return answ\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(len(str(x)) for x in row) for row in list(zip(*grid))]\\n```\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        R,C=len(grid),len(grid[0])\\n        answ=[0]*C\\n        for r in range(R):\\n            for c in range(C):\\n                answ[c]=max(answ[c],len(str(grid[r][c])))\\n        return answ\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420122,
                "title": "python-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the maximum width of each column in a grid of integers. One possible solution would be to iterate over each column of the grid and determine the maximum width of that column.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve the problem by creating an empty list called columns of length n, where n is the number of columns in the grid. We can then iterate over each column of the grid and for each integer in that column, we can calculate the width of that integer and add it to the corresponding column in the columns list.\\n\\nOnce we have collected the widths of all the integers in each column, we can then iterate over the columns list and find the maximum width for each column. We can then return the list of maximum widths as our answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(m*n), where m is the number of rows and n is the number of columns in the grid. This is because we need to iterate over each element in the grid once.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n), where n is the number of columns in the grid. We use a list of length n to store the widths of each column.\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        columns = [[] for i in range(n)]\\n        ans = []\\n        \\n        cn = 0\\n        for col in grid:\\n            for j in range(len(col)):\\n                columns[j].append(len(str(col[j])))\\n    \\n        for column in columns:\\n            ans.append(max(column))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        columns = [[] for i in range(n)]\\n        ans = []\\n        \\n        cn = 0\\n        for col in grid:\\n            for j in range(len(col)):\\n                columns[j].append(len(str(col[j])))\\n    \\n        for column in columns:\\n            ans.append(max(column))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420076,
                "title": "java-clean-self-explanatory",
                "content": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n        int m = grid.length, n = grid[0].length, max = -1;\\n        \\n        for(int i=0;i<n;i++){\\n           max = -1;\\n           for(int j=0;j<m;j++){\\n              max = Math.max(max, len(grid[j][i]));\\n            }\\n            ans[i] = max;\\n          }\\n        return ans;\\n    }\\n    \\n    int len(int n){\\n       return String.valueOf(n).length(); //Returns length of the integer(both +ive & -ive)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n        int m = grid.length, n = grid[0].length, max = -1;\\n        \\n        for(int i=0;i<n;i++){\\n           max = -1;\\n           for(int j=0;j<m;j++){\\n              max = Math.max(max, len(grid[j][i]));\\n            }\\n            ans[i] = max;\\n          }\\n        return ans;\\n    }\\n    \\n    int len(int n){\\n       return String.valueOf(n).length(); //Returns length of the integer(both +ive & -ive)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420057,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int getWidth(const vector<vector<int>>&v, int col){\\n        int ans=0;\\n        for(int row=0; row<v.size(); ++row){\\n            ans=max(ans, (int)to_string(v[row][col]).size());\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> findColumnWidth(const vector<vector<int>>&v) {\\n        int m=v.size(), n=v[0].size();\\n        vector<int>ans(n);\\n        for(int col=0; col<n; ++col){\\n            ans[col]=getWidth(v, col);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getWidth(const vector<vector<int>>&v, int col){\\n        int ans=0;\\n        for(int row=0; row<v.size(); ++row){\\n            ans=max(ans, (int)to_string(v[row][col]).size());\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> findColumnWidth(const vector<vector<int>>&v) {\\n        int m=v.size(), n=v[0].size();\\n        vector<int>ans(n);\\n        for(int col=0; col<n; ++col){\\n            ans[col]=getWidth(v, col);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420056,
                "title": "c-simple-solution-with-linq",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] FindColumnWidth(int[][] grid)\\n    {\\n        var result = new int[grid[0].Length];\\n\\n        for (var i = 0; i < grid[0].Length; i++)\\n            result[i] = grid.Select(e => e[i].ToString().Length).Max();\\n\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] FindColumnWidth(int[][] grid)\\n    {\\n        var result = new int[grid[0].Length];\\n\\n        for (var i = 0; i < grid[0].Length; i++)\\n            result[i] = grid.Select(e => e[i].ToString().Length).Max();\\n\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420042,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    const ans = [];\\n    for (let i = 0; i < grid[0].length; i++) {\\n        let mx = 0;\\n        for (let j = 0; j < grid.length; j++) {\\n            mx = Math.max(mx, grid[j][i].toString().length);\\n        }\\n        ans.push(mx);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    const ans = [];\\n    for (let i = 0; i < grid[0].length; i++) {\\n        let mx = 0;\\n        for (let j = 0; j < grid.length; j++) {\\n            mx = Math.max(mx, grid[j][i].toString().length);\\n        }\\n        ans.push(mx);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420030,
                "title": "python3-solution",
                "content": "\\n\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        n=len(grid)\\n        m=len(grid[0])\\n        max_widths=[0]*m\\n        \\n        for j in range(m):\\n            max_width=0\\n            for i in range(n):\\n                num=abs(grid[i][j])\\n                width=len(str(num))\\n                if grid[i][j]<0:\\n                    width+=1\\n                    \\n                max_width=max(max_width,width)    \\n                \\n            max_widths[j]=max_width\\n            \\n        return max_widths  \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        n=len(grid)\\n        m=len(grid[0])\\n        max_widths=[0]*m\\n        \\n        for j in range(m):\\n            max_width=0\\n            for i in range(n):\\n                num=abs(grid[i][j])\\n                width=len(str(num))\\n                if grid[i][j]<0:\\n                    width+=1\\n                    \\n                max_width=max(max_width,width)    \\n                \\n            max_widths[j]=max_width\\n            \\n        return max_widths  \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420017,
                "title": "cpp-easy-solution",
                "content": "\\n\\n#### If you helped, Please upvote.\\n#### Complexity\\n* Time Complexity `O(m * n)`\\n* Space Complexity `O(n)`\\n\\n\\n### Solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n        for(int c = 0; c < n; c++) {\\n            int mx = 0;\\n            for(int r = 0; r < m; r++)\\n                mx = max((int)to_string(grid[r][c]).size(), mx);\\n            ans[c] = mx;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n> Have a good day!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n        for(int c = 0; c < n; c++) {\\n            int mx = 0;\\n            for(int r = 0; r < m; r++)\\n                mx = max((int)to_string(grid[r][c]).size(), mx);\\n            ans[c] = mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419977,
                "title": "c-simple-convert-to-string-and-check-size",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans(grid[0].size());\\n        for(int i=0;i<grid[0].size();i++){\\n            int a=0;\\n            for(int j=0;j<grid.size();j++){\\n                string s = to_string(grid[j][i]);\\n                if(a<s.size()) a=s.size();\\n            }\\n            ans[i] = a;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans(grid[0].size());\\n        for(int i=0;i<grid[0].size();i++){\\n            int a=0;\\n            for(int j=0;j<grid.size();j++){\\n                string s = to_string(grid[j][i]);\\n                if(a<s.size()) a=s.size();\\n            }\\n            ans[i] = a;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419975,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int arr[] = new int[grid[0].length];\\n        for(int i = 0; i<grid[0].length; i++){\\n            for(int j = 0; j<grid.length; j++){\\n                String s = grid[j][i]+\"\";\\n                arr[i] = Math.max(arr[i], s.length());\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int arr[] = new int[grid[0].length];\\n        for(int i = 0; i<grid[0].length; i++){\\n            for(int j = 0; j<grid.length; j++){\\n                String s = grid[j][i]+\"\";\\n                arr[i] = Math.max(arr[i], s.length());\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101134,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(map(lambda n: len(str(n)), row)) for row in zip(*grid)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(map(lambda n: len(str(n)), row)) for row in zip(*grid)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077318,
                "title": "c-clean-without-string-conversion",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // add 1 to width if 0 or negative\\n                int tmp = grid[i][j], size = tmp <= 0 ? 1 : 0;\\n                // count digits\\n                while (tmp) { ++size; tmp /= 10; }\\n                ans[j] = max(ans[j], size); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // add 1 to width if 0 or negative\\n                int tmp = grid[i][j], size = tmp <= 0 ? 1 : 0;\\n                // count digits\\n                while (tmp) { ++size; tmp /= 10; }\\n                ans[j] = max(ans[j], size); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070046,
                "title": "java-python3-c-solution-simple",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int[] result = new int[n];\\n        for (int c = 0; c < n; c++) {\\n            int maxWidth = -1;\\n            for (int r = 0; r < m; r++) {\\n                int width = this.getWidth(grid[r][c]);\\n                maxWidth = Math.max(maxWidth, width);\\n            }\\n            result[c] = maxWidth;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int getWidth(int num) {\\n        int width = (num <= 0) ? 1 : 0;\\n\\n        while (num != 0) {\\n            width++;\\n            num = num / 10;\\n        }\\n\\n        return width;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        result = [0] * n\\n        for c in range(n):\\n            maxWidth = -1\\n            for r in range(m):\\n                width = self.getWidth(grid[r][c])\\n                maxWidth = max(maxWidth, width)\\n            result[c] = maxWidth\\n        \\n        return result\\n        \\n    def getWidth(self, num: int):\\n        width = 1 if num <= 0 else 0\\n        num = abs(num)\\n\\n        while num != 0:\\n            width += 1\\n            num = num // 10\\n        \\n        return width\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> result(n);\\n        for (int c = 0; c < n; c++) {\\n            int maxWidth = -1;\\n            for (int r = 0; r < m; r++) {\\n                int width = this->getWidth(grid[r][c]);\\n                maxWidth = max(maxWidth, width);\\n            }\\n            result[c] = maxWidth;\\n        }\\n\\n        return result;\\n    }\\nprivate:\\n    int getWidth(int num) {\\n        int width = (num <= 0) ? 1 : 0;\\n\\n        while (num != 0) {\\n            width++;\\n            num = num / 10;\\n        }\\n\\n        return width;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int[] result = new int[n];\\n        for (int c = 0; c < n; c++) {\\n            int maxWidth = -1;\\n            for (int r = 0; r < m; r++) {\\n                int width = this.getWidth(grid[r][c]);\\n                maxWidth = Math.max(maxWidth, width);\\n            }\\n            result[c] = maxWidth;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int getWidth(int num) {\\n        int width = (num <= 0) ? 1 : 0;\\n\\n        while (num != 0) {\\n            width++;\\n            num = num / 10;\\n        }\\n\\n        return width;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        result = [0] * n\\n        for c in range(n):\\n            maxWidth = -1\\n            for r in range(m):\\n                width = self.getWidth(grid[r][c])\\n                maxWidth = max(maxWidth, width)\\n            result[c] = maxWidth\\n        \\n        return result\\n        \\n    def getWidth(self, num: int):\\n        width = 1 if num <= 0 else 0\\n        num = abs(num)\\n\\n        while num != 0:\\n            width += 1\\n            num = num // 10\\n        \\n        return width\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> result(n);\\n        for (int c = 0; c < n; c++) {\\n            int maxWidth = -1;\\n            for (int r = 0; r < m; r++) {\\n                int width = this->getWidth(grid[r][c]);\\n                maxWidth = max(maxWidth, width);\\n            }\\n            result[c] = maxWidth;\\n        }\\n\\n        return result;\\n    }\\nprivate:\\n    int getWidth(int num) {\\n        int width = (num <= 0) ? 1 : 0;\\n\\n        while (num != 0) {\\n            width++;\\n            num = num / 10;\\n        }\\n\\n        return width;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064025,
                "title": "something-like-that",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0] * len(grid[0])\\n        for i in grid:\\n            for j in range(len(i)):\\n                if res[j] < len(str(i[j])):\\n                    res[j] = len(str(i[j]))\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0] * len(grid[0])\\n        for i in grid:\\n            for j in range(len(i)):\\n                if res[j] < len(str(i[j])):\\n                    res[j] = len(str(i[j]))\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062485,
                "title": "simple-for-beginners-beatz-95",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n- Space complexity:O( n )\\n- n => no . coloums\\n- m => no . rows\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        res = [0] * len(grid[0])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                res[j] = max(res[j] , len(str(grid[i][j])))\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        res = [0] * len(grid[0])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                res[j] = max(res[j] , len(str(grid[i][j])))\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037223,
                "title": "python-one-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use `zip(*grid)` to iterate over the columns, and `map(str, col)` to transform each number from a given column into a string. We then calculate the lenght of each string and find the `max`.\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(map(len, map(str, col))) for col in zip(*grid)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max(map(len, map(str, col))) for col in zip(*grid)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031449,
                "title": "self-explanatory-and-simple-cpp-solution-that-beats-98-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid[0].size(),m = grid.size();\\n        vector<int> ans(n);\\n        for(int j = 0;j<n;j++)\\n        {\\n            int l=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                int n = (int)(to_string(grid[i][j])).size();\\n                l = max(l,n);\\n            }\\n            ans[j] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n = grid[0].size(),m = grid.size();\\n        vector<int> ans(n);\\n        for(int j = 0;j<n;j++)\\n        {\\n            int l=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                int n = (int)(to_string(grid[i][j])).size();\\n                l = max(l,n);\\n            }\\n            ans[j] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031360,
                "title": "c-beginner-friendly-solution-with-efficient-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> ans(n , 1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int t = to_string(grid[j][i]).size();\\n                ans[i] = max(ans[i],t);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> ans(n , 1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int t = to_string(grid[j][i]).size();\\n                ans[i] = max(ans[i],t);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985590,
                "title": "javascript-o-m-n",
                "content": "# Code\\n```\\nvar findColumnWidth = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const res = [];\\n    for (let i = 0; i < n; i++) {\\n        let max = 0;\\n        for (let j = 0; j < m; j++) {\\n            max = Math.max(max, grid[j][i].toString().length);\\n        }\\n        res.push(max);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findColumnWidth = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const res = [];\\n    for (let i = 0; i < n; i++) {\\n        let max = 0;\\n        for (let j = 0; j < m; j++) {\\n            max = Math.max(max, grid[j][i].toString().length);\\n        }\\n        res.push(max);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980203,
                "title": "easy-to-understand-solution-python",
                "content": "# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        answer = [0 for _ in range(len(grid[0]))]\\n\\n        for col in grid:\\n            for i in range(len(col)):\\n                answer[i] = max(answer[i], len(str(col[i])))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        answer = [0 for _ in range(len(grid[0]))]\\n\\n        for col in grid:\\n            for i in range(len(col)):\\n                answer[i] = max(answer[i], len(str(col[i])))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972299,
                "title": "beats-96-gl-figuring-this-out",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        \\n        ans = []\\n        small = 0\\n        t_s = 0\\n        \\n        for i in grid:\\n            l_g = len(i)\\n            if l_g > small:\\n                small = l_g\\n        \\n        for y in range(small):\\n            counter = 0\\n            for index,item in enumerate(grid):\\n                t_s = len(str(item[y]))\\n                if t_s > counter:\\n                    counter = t_s\\n            ans.append(counter)\\n        return ans\\n                \\n                \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        \\n        ans = []\\n        small = 0\\n        t_s = 0\\n        \\n        for i in grid:\\n            l_g = len(i)\\n            if l_g > small:\\n                small = l_g\\n        \\n        for y in range(small):\\n            counter = 0\\n            for index,item in enumerate(grid):\\n                t_s = len(str(item[y]))\\n                if t_s > counter:\\n                    counter = t_s\\n            ans.append(counter)\\n        return ans\\n                \\n                \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954334,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        clen = len(grid[0])\\n        rlen = len(grid)\\n        \\n        res = []\\n\\n        for c in range(clen):\\n            maxval = 0\\n            for r in range(rlen):\\n                if len(str(grid[r][c])) > maxval:\\n                    maxval = len(str(grid[r][c]))\\n            res.append(maxval)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        clen = len(grid[0])\\n        rlen = len(grid)\\n        \\n        res = []\\n\\n        for c in range(clen):\\n            maxval = 0\\n            for r in range(rlen):\\n                if len(str(grid[r][c])) > maxval:\\n                    maxval = len(str(grid[r][c]))\\n            res.append(maxval)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939518,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leng(int x)\\n    {\\n        if(x==0)\\n        return 1;\\n        int a=x;\\n        int c=0;\\n        while(a)\\n        {\\n            c++;\\n            a=a/10;\\n        }\\n        if(x<0) return c+1; else return c;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid[0].size();\\n        int n=grid.size();\\n        vector<int>ans(m);\\n        for(int j=0;j<m;j++)\\n        {\\n            int ma=INT_MIN;\\n            for(int i=0;i<n;i++)\\n            {\\n                ma=max(ma,leng(grid[i][j]));\\n            }\\n            ans[j]=ma;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leng(int x)\\n    {\\n        if(x==0)\\n        return 1;\\n        int a=x;\\n        int c=0;\\n        while(a)\\n        {\\n            c++;\\n            a=a/10;\\n        }\\n        if(x<0) return c+1; else return c;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid[0].size();\\n        int n=grid.size();\\n        vector<int>ans(m);\\n        for(int j=0;j<m;j++)\\n        {\\n            int ma=INT_MIN;\\n            for(int i=0;i<n;i++)\\n            {\\n                ma=max(ma,leng(grid[i][j]));\\n            }\\n            ans[j]=ma;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938049,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] g) {\\n        int m=g.length;\\n        int n= g[0].length;\\n        int[] ans = new int[n];\\n       \\n        for(int i=0;i<n;i++){\\n            int max=Integer.MIN_VALUE;\\n            for(int j=0;j<m;j++){\\n                max=Math.max(max,String.valueOf(g[j][i]).length());\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] g) {\\n        int m=g.length;\\n        int n= g[0].length;\\n        int[] ans = new int[n];\\n       \\n        for(int i=0;i<n;i++){\\n            int max=Integer.MIN_VALUE;\\n            for(int j=0;j<m;j++){\\n                max=Math.max(max,String.valueOf(g[j][i]).length());\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929307,
                "title": "find-the-width-of-columns-of-a-grid-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        for(int i=0;i<grid[0].size();i++){\\n            int max=0;\\n            for(int j=0;j<grid.size();j++){\\n                int a=to_string(grid[j][i]).size();\\n                if(max<a){\\n                    max=a;\\n                }\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        for(int i=0;i<grid[0].size();i++){\\n            int max=0;\\n            for(int j=0;j<grid.size();j++){\\n                int a=to_string(grid[j][i]).size();\\n                if(max<a){\\n                    max=a;\\n                }\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928098,
                "title": "easiest-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int rows=grid.length;\\n        int cols=grid[0].length;\\n        int result[]=new int[cols];\\n        for(int i=0;i<cols;i++)\\n        {\\n            int max=-1;\\n            for(int j=0;j<rows;j++)\\n            {\\n                String no=Integer.toString(grid[j][i]);\\n                max=Math.max(max,no.length());\\n            }\\n            result[i]=max;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int rows=grid.length;\\n        int cols=grid[0].length;\\n        int result[]=new int[cols];\\n        for(int i=0;i<cols;i++)\\n        {\\n            int max=-1;\\n            for(int j=0;j<rows;j++)\\n            {\\n                String no=Integer.toString(grid[j][i]);\\n                max=Math.max(max,no.length());\\n            }\\n            result[i]=max;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915605,
                "title": "c-simple-solution",
                "content": "# Intuition\\nGo over the matrix, keep track of max width for each columns.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1) (O(n) - if we would count memory usage for result vector)\\n\\n# Code\\n```\\nclass Solution {\\n    int getLen(int v) {\\n        if (v == 0) {\\n            return 1;\\n        }\\n        \\n        int t = abs(v);\\n\\n        int l = 0;\\n        while (t > 0) {\\n            t = t / 10;\\n            l ++;\\n        }\\n\\n        return v < 0 ? l + 1 : l;\\n    }\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        const int M = grid.size();\\n        const int N = grid[0].size();\\n\\n        vector<int> result(N, INT_MIN);\\n        for (int r = 0;r < M;r ++) {\\n            for (int c = 0; c < N;c ++) {\\n                result[c] = max(result[c], getLen(grid[r][c]));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int getLen(int v) {\\n        if (v == 0) {\\n            return 1;\\n        }\\n        \\n        int t = abs(v);\\n\\n        int l = 0;\\n        while (t > 0) {\\n            t = t / 10;\\n            l ++;\\n        }\\n\\n        return v < 0 ? l + 1 : l;\\n    }\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        const int M = grid.size();\\n        const int N = grid[0].size();\\n\\n        vector<int> result(N, INT_MIN);\\n        for (int r = 0;r < M;r ++) {\\n            for (int c = 0; c < N;c ++) {\\n                result[c] = max(result[c], getLen(grid[r][c]));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887394,
                "title": "easy-beginner-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>ans;\\n        for(int i=0;i<m;i++){\\n            int current=0;\\n            for(int j=0;j<n;j++){\\n                string s=to_string(grid[j][i]);\\n                int length=s.size();;\\n                current=max(current,length);\\n            }\\n            ans.push_back(current);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>ans;\\n        for(int i=0;i<m;i++){\\n            int current=0;\\n            for(int j=0;j<n;j++){\\n                string s=to_string(grid[j][i]);\\n                int length=s.size();;\\n                current=max(current,length);\\n            }\\n            ans.push_back(current);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887313,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n\\n        vector<int> result;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(int c=0; c < n; ++c) {\\n\\n            int maxMod = 0;\\n            for(int r=0; r < m; ++r) {\\n                \\n                int mod = 1;\\n                int value = grid[r][c];\\n                \\n                if(value < 0) {\\n                    ++mod;\\n                    value = value * -1;\\n                }\\n\\n                while(value >= 10) {\\n                    value /= 10;\\n                    ++mod;\\n                }\\n                \\n                maxMod = max(maxMod, mod);\\n            }\\n\\n            result.push_back(maxMod);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n\\n        vector<int> result;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(int c=0; c < n; ++c) {\\n\\n            int maxMod = 0;\\n            for(int r=0; r < m; ++r) {\\n                \\n                int mod = 1;\\n                int value = grid[r][c];\\n                \\n                if(value < 0) {\\n                    ++mod;\\n                    value = value * -1;\\n                }\\n\\n                while(value >= 10) {\\n                    value /= 10;\\n                    ++mod;\\n                }\\n                \\n                maxMod = max(maxMod, mod);\\n            }\\n\\n            result.push_back(maxMod);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881343,
                "title": "easy-to-understand-for-begineers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGood and easy for begineers\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\neasy approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbeats 89%\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nbeats 80%\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        z=[]\\n        for j in range(len(grid[0])):\\n            a=0\\n            for i in range(len(grid)):\\n                a=max(len(str(grid[i][j])),a)\\n            z.append(a)\\n        return z\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        z=[]\\n        for j in range(len(grid[0])):\\n            a=0\\n            for i in range(len(grid)):\\n                a=max(len(str(grid[i][j])),a)\\n            z.append(a)\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879934,
                "title": "find-the-width-of-columns-of-a-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] arr = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<m;j++)\\n            {\\n                String s = String.valueOf(grid[j][i]);\\n                max = Math.max(max,s.length());\\n            }\\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] arr = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<m;j++)\\n            {\\n                String s = String.valueOf(grid[j][i]);\\n                max = Math.max(max,s.length());\\n            }\\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875446,
                "title": "rust-with-iterators",
                "content": "\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_column_width(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        \\n        (0..grid[0].len())\\n            .map(|col_index| {\\n                grid\\n                .iter()\\n                .map(|row| {\\n                    row[col_index]\\n                        .to_string()\\n                        .chars()\\n                        .count() as i32\\n                })\\n                .max()\\n                .unwrap()\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_column_width(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        \\n        (0..grid[0].len())\\n            .map(|col_index| {\\n                grid\\n                .iter()\\n                .map(|row| {\\n                    row[col_index]\\n                        .to_string()\\n                        .chars()\\n                        .count() as i32\\n                })\\n                .max()\\n                .unwrap()\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867379,
                "title": "for-loop-vs-complicated-one-line-of-code",
                "content": "## For loop\\n![image.png](https://assets.leetcode.com/users/images/40672a8f-5e7b-4f8c-b0e7-54861c30751d_1691241512.3061278.png)\\n\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        result = []\\n        for i in range(len(grid[0])):\\n            result.append(max(len(str(grid[j][i])) for j in range(len(grid))))\\n        return result\\n```\\n\\n## One line\\n![image.png](https://assets.leetcode.com/users/images/87dc9203-6a2f-47c5-a94c-b71b84d8519c_1691241329.0060642.png)\\n\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max([len(str(grid[i][j])) for i in range(len(grid))]) for j in range(len(grid[0]))]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        result = []\\n        for i in range(len(grid[0])):\\n            result.append(max(len(str(grid[j][i])) for j in range(len(grid))))\\n        return result\\n```\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max([len(str(grid[i][j])) for i in range(len(grid))]) for j in range(len(grid[0]))]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863639,
                "title": "java-3ms-beats-96-80",
                "content": "\\n# Complexity\\n- Time complexity: O(mn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n\\n        int[] maxWidth = new int[grid[0].length];\\n\\n        for (int m = 0; m < grid.length; ++m) {\\n            for (int n = 0; n < grid[0].length; ++n) {\\n                int numDigits = getNumDigits(grid[m][n]);\\n                if (numDigits > maxWidth[n]) {\\n                    maxWidth[n] = numDigits;\\n                }\\n            }\\n        }\\n\\n        return maxWidth;\\n    }\\n\\n    int getNumDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int numDigits = 0;\\n        if (n < 0) {\\n            ++numDigits;\\n            n *= -1;\\n        }\\n        while (n > 0) {\\n            n /= 10;\\n            ++numDigits;\\n        }\\n        return numDigits;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n\\n        int[] maxWidth = new int[grid[0].length];\\n\\n        for (int m = 0; m < grid.length; ++m) {\\n            for (int n = 0; n < grid[0].length; ++n) {\\n                int numDigits = getNumDigits(grid[m][n]);\\n                if (numDigits > maxWidth[n]) {\\n                    maxWidth[n] = numDigits;\\n                }\\n            }\\n        }\\n\\n        return maxWidth;\\n    }\\n\\n    int getNumDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int numDigits = 0;\\n        if (n < 0) {\\n            ++numDigits;\\n            n *= -1;\\n        }\\n        while (n > 0) {\\n            n /= 10;\\n            ++numDigits;\\n        }\\n        return numDigits;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863230,
                "title": "swift-one-liner",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func findColumnWidth(_ grid: [[Int]]) -> [Int] {\\n        (0..<grid[0].count).map {\\n            column in grid.reduce(0) { maxWidth,row in max(maxWidth,String(row[column]).count) }}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findColumnWidth(_ grid: [[Int]]) -> [Int] {\\n        (0..<grid[0].count).map {\\n            column in grid.reduce(0) { maxWidth,row in max(maxWidth,String(row[column]).count) }}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851265,
                "title": "java-simple-and-clear-solution",
                "content": "\\n# Complexity\\n1. Time complexity: *O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int n = grid[0].length, m = grid.length;\\n        int ans[] = new int[n];\\n\\n        for(int i = 0; i < n; i++){\\n            int max = 0;\\n            for(int j = 0; j < m; j++)\\n                max = Math.max(String.valueOf(grid[j][i]).length(), max);\\n            ans[i] = max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int n = grid[0].length, m = grid.length;\\n        int ans[] = new int[n];\\n\\n        for(int i = 0; i < n; i++){\\n            int max = 0;\\n            for(int j = 0; j < m; j++){\\n                int k = grid[j][i];\\n                int count = 0;\\n\\n                if(k <= 0){\\n                    count = 1;\\n                    k *= -1;\\n                }\\n\\n                while( k > 0){\\n                    count++;\\n                    k /= 10;\\n                }\\n\\n                max = Math.max(count, max);\\n            }\\n            ans[i] = max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int n = grid[0].length, m = grid.length;\\n        int ans[] = new int[n];\\n\\n        for(int i = 0; i < n; i++){\\n            int max = 0;\\n            for(int j = 0; j < m; j++)\\n                max = Math.max(String.valueOf(grid[j][i]).length(), max);\\n            ans[i] = max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int n = grid[0].length, m = grid.length;\\n        int ans[] = new int[n];\\n\\n        for(int i = 0; i < n; i++){\\n            int max = 0;\\n            for(int j = 0; j < m; j++){\\n                int k = grid[j][i];\\n                int count = 0;\\n\\n                if(k <= 0){\\n                    count = 1;\\n                    k *= -1;\\n                }\\n\\n                while( k > 0){\\n                    count++;\\n                    k /= 10;\\n                }\\n\\n                max = Math.max(count, max);\\n            }\\n            ans[i] = max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848634,
                "title": "for-those-who-don-t-know-advanced-syntax",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        rL = len(grid[0])\\n        l = len(grid)\\n        result = []\\n        for i in range(rL):\\n            colMax = -1\\n            for j in range(l):\\n                length = len(str(grid[j][i]))\\n                if length > colMax :\\n                    colMax = length\\n            result.append(colMax)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        rL = len(grid[0])\\n        l = len(grid)\\n        result = []\\n        for i in range(rL):\\n            colMax = -1\\n            for j in range(l):\\n                length = len(str(grid[j][i]))\\n                if length > colMax :\\n                    colMax = length\\n            result.append(colMax)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834127,
                "title": "runtime-100-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        a=[]\\n        for i in range(0,len(grid[0])) :\\n            a.append([])\\n        # print(a)\\n        for j in range(0,len(grid[0])) :\\n            for i in range(0,len(grid)) :\\n                a[j].append(len(str(grid[i][j])))\\n        # print(a)\\n        b=[]\\n        for i in a :\\n            b.append(max(i))\\n        return b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        a=[]\\n        for i in range(0,len(grid[0])) :\\n            a.append([])\\n        # print(a)\\n        for j in range(0,len(grid[0])) :\\n            for i in range(0,len(grid)) :\\n                a[j].append(len(str(grid[i][j])))\\n        # print(a)\\n        b=[]\\n        for i in a :\\n            b.append(max(i))\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831428,
                "title": "c-easy-approach-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int maxi=-1e6;\\n            for(int j=0;j<n;j++){\\n                int digits =0;\\n                if(grid[j][i]!=0)\\n                digits = (int)log10(abs(grid[j][i])) + 1;\\n                else digits=1;\\n                if (grid[j][i] < 0) {\\n                 digits++; // Add 1 for the negative sign\\n                }  \\n                maxi=max(maxi,digits);\\n\\n            }\\n         ans[i]=maxi;\\n\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int maxi=-1e6;\\n            for(int j=0;j<n;j++){\\n                int digits =0;\\n                if(grid[j][i]!=0)\\n                digits = (int)log10(abs(grid[j][i])) + 1;\\n                else digits=1;\\n                if (grid[j][i] < 0) {\\n                 digits++; // Add 1 for the negative sign\\n                }  \\n                maxi=max(maxi,digits);\\n\\n            }\\n         ans[i]=maxi;\\n\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827568,
                "title": "standard-java-solution",
                "content": "### Theory\\nFor each column go through and find the maximum length of each number in that column.\\n\\n### Solution\\n```\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] res = new int[grid[0].length];\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int max = 0;\\n            for (int j = 0; j < grid.length; j++) {\\n                int len = getLen(grid[j][i]);\\n                max = Math.max(max, len);\\n            }\\n            res[i] = max;\\n        }\\n        return res;\\n    }\\n    \\n    private int getLen(int val) {\\n        if (val == 0) return 1;\\n        int len = val < 0 ? 1 : 0;\\n        while (val != 0) {\\n            len++;\\n            val /= 10;\\n        }\\n        \\n        return len;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] res = new int[grid[0].length];\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int max = 0;\\n            for (int j = 0; j < grid.length; j++) {\\n                int len = getLen(grid[j][i]);\\n                max = Math.max(max, len);\\n            }\\n            res[i] = max;\\n        }\\n        return res;\\n    }\\n    \\n    private int getLen(int val) {\\n        if (val == 0) return 1;\\n        int len = val < 0 ? 1 : 0;\\n        while (val != 0) {\\n            len++;\\n            val /= 10;\\n        }\\n        \\n        return len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818284,
                "title": "c-solution-using-to-string",
                "content": "\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n       \\n        for(int i=0;i<grid[0].size();i++){\\n             int len=INT_MIN;\\n            for(int j=0;j<grid.size();j++){\\n                string s=to_string(grid[j][i]);\\n                int r=s.size();\\n                len=max(len,r);\\n            }\\n            ans.push_back(len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n       \\n        for(int i=0;i<grid[0].size();i++){\\n             int len=INT_MIN;\\n            for(int j=0;j<grid.size();j++){\\n                string s=to_string(grid[j][i]);\\n                int r=s.size();\\n                len=max(len,r);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3817979,
                "title": "5ms-easy-java-solution-easypeasy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int i,j;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int arr[]=new int[m];\\n        int c=0;\\n        int max=Integer.MIN_VALUE;\\n        for(i=0;i<=m-1;i++){\\n            max=Integer.MIN_VALUE;\\n            for(j=0;j<=n-1;j++){\\n                c=0;\\n                if(grid[j][i]<0){\\n                    c++;\\n                }\\n                int u=Math.abs(grid[j][i]);\\n                 while(u!=0){\\n                    int rem=u%10;\\n                    c++;\\n                    u=u/10;\\n                  } \\n                if(c>max){\\n                    max=c;\\n                }\\n            }\\n            // System.out.print(max);\\n            if(max==0){\\n                arr[i]=1;\\n            }\\n            else{\\n                arr[i]=max;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int i,j;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int arr[]=new int[m];\\n        int c=0;\\n        int max=Integer.MIN_VALUE;\\n        for(i=0;i<=m-1;i++){\\n            max=Integer.MIN_VALUE;\\n            for(j=0;j<=n-1;j++){\\n                c=0;\\n                if(grid[j][i]<0){\\n                    c++;\\n                }\\n                int u=Math.abs(grid[j][i]);\\n                 while(u!=0){\\n                    int rem=u%10;\\n                    c++;\\n                    u=u/10;\\n                  } \\n                if(c>max){\\n                    max=c;\\n                }\\n            }\\n            // System.out.print(max);\\n            if(max==0){\\n                arr[i]=1;\\n            }\\n            else{\\n                arr[i]=max;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793504,
                "title": "python-3-easy-solution",
                "content": "# Please  UpVote\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/f07668af-137c-4495-9003-e710a29105a4_1689872171.4824429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans = []\\n        for i in range(len(grid[0])):\\n            ans.append(max([len(str(grid[j][i])) for j in range(len(grid))]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans = []\\n        for i in range(len(grid[0])):\\n            ans.append(max([len(str(grid[j][i])) for j in range(len(grid))]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791388,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n  O(m*n)\\n\\n- Space complexity:\\n  O(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(int mx,int mn){\\n        int m1=abs(mx),m2=abs(mn);\\n        int c1=0,c2=0;\\n        if(m1==0)c1=1;\\n        if(m2==0)c2=1;\\n        while(m1>0){\\n            c1++;\\n            m1=m1/10;\\n        }\\n        while(m2>0){\\n            c2++;\\n            m2=m2/10;\\n        }\\n        if(mx<0 && mn<0){\\n            return max(c1+1,c2+1);\\n        }\\n        else if(mx<0 && mn>0){\\n            return max(c1+1,c2);\\n        }\\n        else if(mx>0 && mn<0){\\n            return max(c1,c2+1);\\n        }\\n        return max(c1,c2);\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>res;\\n        for(int j=0;j<m;j++){\\n            int mx=INT_MIN,mn=INT_MAX;\\n            for(int i=0;i<n;i++){\\n              mx=max(mx,grid[i][j]);\\n              mn=min(mn,grid[i][j]);\\n            }\\n            int ans=check(mx,mn);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int mx,int mn){\\n        int m1=abs(mx),m2=abs(mn);\\n        int c1=0,c2=0;\\n        if(m1==0)c1=1;\\n        if(m2==0)c2=1;\\n        while(m1>0){\\n            c1++;\\n            m1=m1/10;\\n        }\\n        while(m2>0){\\n            c2++;\\n            m2=m2/10;\\n        }\\n        if(mx<0 && mn<0){\\n            return max(c1+1,c2+1);\\n        }\\n        else if(mx<0 && mn>0){\\n            return max(c1+1,c2);\\n        }\\n        else if(mx>0 && mn<0){\\n            return max(c1,c2+1);\\n        }\\n        return max(c1,c2);\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>res;\\n        for(int j=0;j<m;j++){\\n            int mx=INT_MIN,mn=INT_MAX;\\n            for(int i=0;i<n;i++){\\n              mx=max(mx,grid[i][j]);\\n              mn=min(mn,grid[i][j]);\\n            }\\n            int ans=check(mx,mn);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787687,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] output = new int[grid[0].length];\\n        int index = 0;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int max = Integer.MIN_VALUE;\\n            for (int j = 0; j < grid.length; j++) {\\n                max = Math.max(max, new StringBuilder().append(grid[j][i]).length());\\n                if (j == grid.length - 1) {\\n                    output[index++] = max;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] output = new int[grid[0].length];\\n        int index = 0;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int max = Integer.MIN_VALUE;\\n            for (int j = 0; j < grid.length; j++) {\\n                max = Math.max(max, new StringBuilder().append(grid[j][i]).length());\\n                if (j == grid.length - 1) {\\n                    output[index++] = max;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786064,
                "title": "one-line-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [len(str(max(i, key = lambda x: len(str(x))))) for i in zip(*grid)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [len(str(max(i, key = lambda x: len(str(x))))) for i in zip(*grid)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779546,
                "title": "width-of-columns-nitishman",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will need two arrays and we will need to think backward for the first array i.e we first check the last columns then slowly we decrement back to the first element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) figure out the length of the last array (any array will do they will have same length). i.e [[1,2,3],[3,4,5]] length of [3,4,5] is 2,\\n0 to 2 and store it in index var\\n\\n2) Create vars counter, result[] \\n3) create loop untill the index is not 0\\n    \\n    a) create var to store the max no and initialize it to lowest   possible integer value\\n    b) loop through the 2d array i.e. outer main array \\n            i) set counter var to 0\\n            ii) if value less than equal 0 then increment counter\\n            iii) use while loop to get no of digits\\n            iv) compare and store max value in max\\n    c)store the max in result\\n4) return result\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int counter = 0,max = Integer.MIN_VALUE;\\n        \\n        int index = grid[grid.length-1].length-1;\\n        //index give n-1 if we have n element so we want the array to be size n\\n        //so we add 1 \\n        int[] result = new int[index+1];\\n        \\n        while( index >= 0){\\n            max = Integer.MIN_VALUE;\\n            for(int i = 0;i<grid.length;i++){\\n                counter = 0;\\n                //if number is less than or equal to zero add 1 \\n                if(grid[i][index] <= 0){\\n                    counter++;\\n                }\\n\\n                int pos = Math.abs(grid[i][index]);\\n                \\n                //get count\\n                while(pos != 0){\\n                    counter++;\\n                    pos = pos/10;\\n                }\\n\\n                //store the max value\\n                max = Math.max(max,counter);\\n            }\\n            result[index] = max;\\n            index--;\\n        }\\n           \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int counter = 0,max = Integer.MIN_VALUE;\\n        \\n        int index = grid[grid.length-1].length-1;\\n        //index give n-1 if we have n element so we want the array to be size n\\n        //so we add 1 \\n        int[] result = new int[index+1];\\n        \\n        while( index >= 0){\\n            max = Integer.MIN_VALUE;\\n            for(int i = 0;i<grid.length;i++){\\n                counter = 0;\\n                //if number is less than or equal to zero add 1 \\n                if(grid[i][index] <= 0){\\n                    counter++;\\n                }\\n\\n                int pos = Math.abs(grid[i][index]);\\n                \\n                //get count\\n                while(pos != 0){\\n                    counter++;\\n                    pos = pos/10;\\n                }\\n\\n                //store the max value\\n                max = Math.max(max,counter);\\n            }\\n            result[index] = max;\\n            index--;\\n        }\\n           \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777343,
                "title": "easy-to-understand-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans=[]\\n        for col in range(len(grid[0])):\\n            v=len(str(grid[0][col]))\\n            for row in range(len(grid)):\\n                tmp=len(str(grid[row][col]))\\n                if v<tmp:\\n                    v=tmp\\n            #print(f\"This is v={v}\")\\n            ans.append(v)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans=[]\\n        for col in range(len(grid[0])):\\n            v=len(str(grid[0][col]))\\n            for row in range(len(grid)):\\n                tmp=len(str(grid[row][col]))\\n                if v<tmp:\\n                    v=tmp\\n            #print(f\"This is v={v}\")\\n            ans.append(v)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772721,
                "title": "max-length-of-strings",
                "content": "![image.png](https://assets.leetcode.com/users/images/9011c52c-dab9-4fcd-a114-0d64ec546e60_1689497673.0553825.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans = [0] * len(grid[0])\\n        for row in grid:\\n            for i, (a, r) in enumerate(zip(ans, row)):\\n                ans[i] = max(a, len(str(r)))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans = [0] * len(grid[0])\\n        for row in grid:\\n            for i, (a, r) in enumerate(zip(ans, row)):\\n                ans[i] = max(a, len(str(r)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761177,
                "title": "java-easy-solution-beats-98-2-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: (n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n       int m = grid.length;\\n       int n = grid[0].length;\\n       long temp, maxArr[] = new long [n];\\n       for(int i = 0; i < m ; i ++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] >= 0)\\n                {\\n                    if(grid[i][j] > maxArr[j])\\n                        maxArr[j] = grid[i][j];\\n                }else\\n                {\\n                    temp = grid[i][j] * -10L;\\n                    if(temp > maxArr[j])\\n                        maxArr[j] = temp;\\n                }\\n        \\n        int ans[] = new int [n];\\n        for(int j = 0; j < n; j++)\\n            ans[j] = String.valueOf(maxArr[j]).length();\\n        return ans;                    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n       int m = grid.length;\\n       int n = grid[0].length;\\n       long temp, maxArr[] = new long [n];\\n       for(int i = 0; i < m ; i ++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] >= 0)\\n                {\\n                    if(grid[i][j] > maxArr[j])\\n                        maxArr[j] = grid[i][j];\\n                }else\\n                {\\n                    temp = grid[i][j] * -10L;\\n                    if(temp > maxArr[j])\\n                        maxArr[j] = temp;\\n                }\\n        \\n        int ans[] = new int [n];\\n        for(int j = 0; j < n; j++)\\n            ans[j] = String.valueOf(maxArr[j]).length();\\n        return ans;                    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757164,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)2$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    let result = [];\\n    let len =0;\\n    let count = 0;\\n    for(let i=0; i < grid[0].length; i++){\\n        for(let j=0; j < grid.length; j++){\\n            len = String(grid[j][i]).length;\\n            if(len>count){\\n                count=len;\\n            }\\n        }\\n        result.push(count);\\n        count=0;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    let result = [];\\n    let len =0;\\n    let count = 0;\\n    for(let i=0; i < grid[0].length; i++){\\n        for(let j=0; j < grid.length; j++){\\n            len = String(grid[j][i]).length;\\n            if(len>count){\\n                count=len;\\n            }\\n        }\\n        result.push(count);\\n        count=0;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741481,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun findColumnWidth(grid: Array<IntArray>): IntArray {\\n        val result = IntArray(grid[0].size)\\n        var col = 0\\n\\n        while (col < grid[0].size) {\\n            var width = 0\\n            var row = 0\\n\\n            while (row < grid.size) {\\n                width = Math.max(width, getWidth(grid[row][col]))\\n                row++\\n            }\\n\\n            result[col] = width\\n            row = 0\\n            col++\\n        }\\n\\n        return result\\n    }\\n\\n    private fun getWidth(num: Int): Int {\\n        var n = Math.abs(num)\\n        var width = if (num > 0) 0 else 1\\n\\n        while (n > 0) {\\n            width++\\n            n /= 10\\n        }\\n\\n        return width\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findColumnWidth(grid: Array<IntArray>): IntArray {\\n        val result = IntArray(grid[0].size)\\n        var col = 0\\n\\n        while (col < grid[0].size) {\\n            var width = 0\\n            var row = 0\\n\\n            while (row < grid.size) {\\n                width = Math.max(width, getWidth(grid[row][col]))\\n                row++\\n            }\\n\\n            result[col] = width\\n            row = 0\\n            col++\\n        }\\n\\n        return result\\n    }\\n\\n    private fun getWidth(num: Int): Int {\\n        var n = Math.abs(num)\\n        var width = if (num > 0) 0 else 1\\n\\n        while (n > 0) {\\n            width++\\n            n /= 10\\n        }\\n\\n        return width\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736282,
                "title": "easy-go-solution",
                "content": "```\\nfunc findColumnWidth(grid [][]int) []int {\\n        m := len(grid)\\n        n := len(grid[0])\\n\\n        res := make([]int, 0, n)\\n        for i := 0; i < n; i++ {\\n                var max int\\n\\n                for j := 0; j < m; j++ {\\n                        num := grid[j][i]\\n                        length := numLen(num)\\n\\n                        if length > max {\\n                                max = length\\n                        }\\n                }\\n\\n                res = append(res, max)\\n        }\\n\\n        return res\\n}\\n\\nfunc numLen(num int) int {\\n        var isNegative bool\\n\\n        if num <= 0 {\\n                isNegative = true\\n                num *= -1\\n        }\\n\\n        var counter int\\n        for num > 0 {\\n                num /= 10\\n                counter++\\n        }\\n\\n        if isNegative {\\n                counter++\\n        }\\n\\n        return counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findColumnWidth(grid [][]int) []int {\\n        m := len(grid)\\n        n := len(grid[0])\\n\\n        res := make([]int, 0, n)\\n        for i := 0; i < n; i++ {\\n                var max int\\n\\n                for j := 0; j < m; j++ {\\n                        num := grid[j][i]\\n                        length := numLen(num)\\n\\n                        if length > max {\\n                                max = length\\n                        }\\n                }\\n\\n                res = append(res, max)\\n        }\\n\\n        return res\\n}\\n\\nfunc numLen(num int) int {\\n        var isNegative bool\\n\\n        if num <= 0 {\\n                isNegative = true\\n                num *= -1\\n        }\\n\\n        var counter int\\n        for num > 0 {\\n                num /= 10\\n                counter++\\n        }\\n\\n        if isNegative {\\n                counter++\\n        }\\n\\n        return counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728206,
                "title": "easy-explanation-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nread the comments for more clarificaton\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->convert the integer format to string format and calculate the size using .size().\\n\\n# Complexity\\n- Time complexity:o(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //return vector required\\n        vector<int> answer(n,0);\\n        int k=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                //converting the integer to string using t0_string \\n                string temp=to_string(grid[j][i]);\\n                    // calculate the size \\n                int sz=temp.size();\\n                ans=max(ans,sz);\\n            }\\n            answer[k++]=ans;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n// upvote please if u like the solution\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //return vector required\\n        vector<int> answer(n,0);\\n        int k=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                //converting the integer to string using t0_string \\n                string temp=to_string(grid[j][i]);\\n                    // calculate the size \\n                int sz=temp.size();\\n                ans=max(ans,sz);\\n            }\\n            answer[k++]=ans;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n// upvote please if u like the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716355,
                "title": "three-easy-java-code",
                "content": "# Code\\n```\\n//1st Method:\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int []arr=new int[grid[0].length];\\n        for(int j=0;j<grid[0].length;j++){\\n            for(int i=0;i<grid.length;i++){\\n                String numString = String.valueOf(Math.abs(grid[i][j]));//Convert int to str\\n                int width = numString.length(); // Get the length of the string\\n                if(grid[i][j]<0){\\n                    width++;\\n                }\\n                if(width>arr[j]){\\n                    arr[j]=width;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n//2nd Method:\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] arr = new int[grid[0].length]; // Number of columns in the grid\\n        for (int j = 0; j < grid[0].length; j++) {\\n            for (int i = 0; i < grid.length; i++) {\\n                int num = grid[i][j];\\n                int width = (num < 0) ? String.valueOf(Math.abs(num)).length() + 1 : String.valueOf(num).length();\\n                if (width > arr[j]) {\\n                    arr[j] = width; // Update the maximum width for column j\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n//3rd Method:\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                max=Math.max(max,String.valueOf(grid[j][i]).length());\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//1st Method:\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int []arr=new int[grid[0].length];\\n        for(int j=0;j<grid[0].length;j++){\\n            for(int i=0;i<grid.length;i++){\\n                String numString = String.valueOf(Math.abs(grid[i][j]));//Convert int to str\\n                int width = numString.length(); // Get the length of the string\\n                if(grid[i][j]<0){\\n                    width++;\\n                }\\n                if(width>arr[j]){\\n                    arr[j]=width;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n//2nd Method:\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] arr = new int[grid[0].length]; // Number of columns in the grid\\n        for (int j = 0; j < grid[0].length; j++) {\\n            for (int i = 0; i < grid.length; i++) {\\n                int num = grid[i][j];\\n                int width = (num < 0) ? String.valueOf(Math.abs(num)).length() + 1 : String.valueOf(num).length();\\n                if (width > arr[j]) {\\n                    arr[j] = width; // Update the maximum width for column j\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n//3rd Method:\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                max=Math.max(max,String.valueOf(grid[j][i]).length());\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716247,
                "title": "shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& v) {\\n        vector<int>p,q;\\n        int j=0;\\n        label:\\n        for(int i=0;i<v.size();i++){\\n            string k=to_string(v[i][j]);\\n            p.push_back(k.length());\\n        }\\n        q.push_back(*max_element(p.begin(),p.end()));\\n        p.clear();\\n        j++;\\n        if(j!=v[0].size())goto label;\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& v) {\\n        vector<int>p,q;\\n        int j=0;\\n        label:\\n        for(int i=0;i<v.size();i++){\\n            string k=to_string(v[i][j]);\\n            p.push_back(k.length());\\n        }\\n        q.push_back(*max_element(p.begin(),p.end()));\\n        p.clear();\\n        j++;\\n        if(j!=v[0].size())goto label;\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708426,
                "title": "python3-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n\\n        max_len = 0\\n\\n        return [max(max(max_len, len(str(j))) for j in i) for i in [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))]]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n\\n        max_len = 0\\n\\n        return [max(max(max_len, len(str(j))) for j in i) for i in [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))]]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700566,
                "title": "simple-solutions-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int ans[]=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++){\\n            int cnt,max=0;\\n            for(int j=0;j<grid.length;j++){\\n                cnt=0;\\n                if(grid[j][i]<0)cnt++;\\n                grid[j][i]=Math.abs(grid[j][i]);\\n                if(grid[j][i]==0)cnt++;\\n                while(grid[j][i]>0){\\n                    cnt++;\\n                    grid[j][i]/=10;\\n                }\\n                max=Math.max(max,cnt);\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int ans[]=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++){\\n            int cnt,max=0;\\n            for(int j=0;j<grid.length;j++){\\n                cnt=0;\\n                if(grid[j][i]<0)cnt++;\\n                grid[j][i]=Math.abs(grid[j][i]);\\n                if(grid[j][i]==0)cnt++;\\n                while(grid[j][i]>0){\\n                    cnt++;\\n                    grid[j][i]/=10;\\n                }\\n                max=Math.max(max,cnt);\\n            }\\n            ans[i]=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698505,
                "title": "6-line-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> res(n, 0);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++) \\n                res[i] = max(res[i], int(size(to_string(grid[j][i]))));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> res(n, 0);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++) \\n                res[i] = max(res[i], int(size(to_string(grid[j][i]))));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693760,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m*k)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    private int size(int n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        int s = 0;\\n        while(n > 0){\\n            s++;\\n            n /= 10;\\n        }\\n\\n        return s;\\n    }\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int ans[] = new int[n];\\n\\n        for(int i = 0 ; i < n ; i++){\\n            int max = 0;\\n            for(int j = 0 ; j < m ; j++){\\n                int s = size(Math.abs(grid[j][i]));\\n                if(grid[j][i] < 0){\\n                    s++;\\n                }\\n                max = Math.max(max , s);\\n            }\\n            ans[i] = max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int size(int n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        int s = 0;\\n        while(n > 0){\\n            s++;\\n            n /= 10;\\n        }\\n\\n        return s;\\n    }\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int ans[] = new int[n];\\n\\n        for(int i = 0 ; i < n ; i++){\\n            int max = 0;\\n            for(int j = 0 ; j < m ; j++){\\n                int s = size(Math.abs(grid[j][i]));\\n                if(grid[j][i] < 0){\\n                    s++;\\n                }\\n                max = Math.max(max , s);\\n            }\\n            ans[i] = max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690239,
                "title": "c-easy-solution-without-using-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n\\n        for (int i = 0; i < grid[0].size(); i++) {\\n            int count = 0;\\n            int max = 0;\\n            for (int j = 0; j < grid.size(); j++) {  \\n                if (grid[j][i] < 0) {\\n                    count++;\\n                }\\n               long long int t = grid[j][i];\\n               if(t==0) count++;\\n               else\\n                while (t) {\\n                    count++;\\n                    t = t / 10;\\n                }\\n                if (count > max) {\\n                    max = count;\\n                }\\n                count=0;\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n\\n        for (int i = 0; i < grid[0].size(); i++) {\\n            int count = 0;\\n            int max = 0;\\n            for (int j = 0; j < grid.size(); j++) {  \\n                if (grid[j][i] < 0) {\\n                    count++;\\n                }\\n               long long int t = grid[j][i];\\n               if(t==0) count++;\\n               else\\n                while (t) {\\n                    count++;\\n                    t = t / 10;\\n                }\\n                if (count > max) {\\n                    max = count;\\n                }\\n                count=0;\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690188,
                "title": "c-easy-solution-without-using-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        for(int i=0; i<grid[0].size(); i++){\\n            int count=0,maxi=0;\\n            int j=0;\\n            for(; j<grid.size(); j++){\\n                if(grid[j][i]<0)\\n                    count++;\\n                    int t=grid[j][i];\\n                    if(t==0) count++;\\n                    else\\n                while(t){\\n                        count++;\\n                        t/=10;\\n                   \\n                }\\n                if(count>maxi){\\n                maxi=count;\\n                }\\n                count=0;\\n            }\\n            \\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        for(int i=0; i<grid[0].size(); i++){\\n            int count=0,maxi=0;\\n            int j=0;\\n            for(; j<grid.size(); j++){\\n                if(grid[j][i]<0)\\n                    count++;\\n                    int t=grid[j][i];\\n                    if(t==0) count++;\\n                    else\\n                while(t){\\n                        count++;\\n                        t/=10;\\n                   \\n                }\\n                if(count>maxi){\\n                maxi=count;\\n                }\\n                count=0;\\n            }\\n            \\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683091,
                "title": "c-using-for-loops-to-find-the-maximum-length-for-each-column",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all, the wording of the question is confusing.  The question is to check the length of each integer as if it is converted to a string.  Repeat the process for all the columns and return the results as an array of int[].\\nI\\'ve opted to use a helper function to calculate the length of a given integer.  The performance of working with integers is better than converting it to string and find the length of it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Instantiate a new int array **result** with the length of **grid[0].Length**.\\n2. Create a for loop with a nested for loop.  The outer for loop is for the column and the inner loop is for the row.  This allows checking one column at a time\\n3. Instantiate int max = 0.  And use Math.Max inside the nested for loop to find the length of each integer, compare each value against the current max and replace as needed, then assign the max value to the corresponding element in **result**.\\n4. The helper function **findLen** take an integer.  If it is negative, the length is incremented by one and use the positive value to calculate the length. \\n5. Return **result** as the output\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindColumnWidth(int[][] grid) {\\n\\n        var result = new int[grid[0].Length];\\n\\n        for (int j = 0; j < grid[0].Length; j++)\\n        {\\n            int max = 0;\\n            for(int i = 0; i < grid.Length; i++)\\n            {\\n                max = Math.Max(max, findLen(grid[i][j]));\\n            }\\n            result[j] = max;\\n        }\\n        return result;\\n\\n        int findLen(int num)\\n        {\\n            if (num == 0) return 1;\\n\\n            int count = 0;\\n            if (num < 0) { count++; num *= -1; }\\n            while (num > 0)\\n            {\\n                count++;\\n                num /= 10;\\n            }\\n            return count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindColumnWidth(int[][] grid) {\\n\\n        var result = new int[grid[0].Length];\\n\\n        for (int j = 0; j < grid[0].Length; j++)\\n        {\\n            int max = 0;\\n            for(int i = 0; i < grid.Length; i++)\\n            {\\n                max = Math.Max(max, findLen(grid[i][j]));\\n            }\\n            result[j] = max;\\n        }\\n        return result;\\n\\n        int findLen(int num)\\n        {\\n            if (num == 0) return 1;\\n\\n            int count = 0;\\n            if (num < 0) { count++; num *= -1; }\\n            while (num > 0)\\n            {\\n                count++;\\n                num /= 10;\\n            }\\n            return count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675930,
                "title": "java-solution-count-the-digits-without-converting-to-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We need to traverse the column and row.\\n- To count the digit of each integer, we can use simple math approach.\\n- remainder = n%10 and n = n/10 \\n- increase the count++ till (n > 0)\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n- O(m)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int rLength = grid.length;\\n        int cLength = grid[0].length;\\n        int[] ans = new int[cLength];\\n        for (int i=0; i<cLength; i++) { // column traversing\\n            int colCount = 0;\\n            for (int j=0; j<rLength; j++) { // row traversing\\n                int n = grid[j][i], tempCount = 0;\\n                if (n<0) {\\n                    n = -(n);\\n                    tempCount++;\\n                }\\n                if (n==0) {\\n                    tempCount = 1;\\n                }\\n                // count the digits\\n                while (n>0) {\\n                    int remainder = n%10;\\n                    n = n/10;\\n                    tempCount++;\\n                }\\n                colCount = (tempCount > colCount) ? tempCount : colCount;\\n            }\\n            ans[i] = colCount;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int rLength = grid.length;\\n        int cLength = grid[0].length;\\n        int[] ans = new int[cLength];\\n        for (int i=0; i<cLength; i++) { // column traversing\\n            int colCount = 0;\\n            for (int j=0; j<rLength; j++) { // row traversing\\n                int n = grid[j][i], tempCount = 0;\\n                if (n<0) {\\n                    n = -(n);\\n                    tempCount++;\\n                }\\n                if (n==0) {\\n                    tempCount = 1;\\n                }\\n                // count the digits\\n                while (n>0) {\\n                    int remainder = n%10;\\n                    n = n/10;\\n                    tempCount++;\\n                }\\n                colCount = (tempCount > colCount) ? tempCount : colCount;\\n            }\\n            ans[i] = colCount;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656949,
                "title": "fast-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& a) {\\n        vector<int> ans(a[0].size());\\n        int n=a.size();\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int temp=0,mx=INT_MIN;\\n            for(int j=0;j<a[i].size();j++)\\n            {\\n                int val=a[i][j];\\n                if(val<0)\\n                {\\n                    val=val*(-1);\\n                    temp++;\\n                }\\n                if(val==0){\\n                    ans[j]=max(ans[j],1);\\n                    continue;\\n                }\\n                temp+=log10(val)+1;\\n                // cout<<a[i][j]<<\" \"<<temp<<endl;\\n                ans[j]=max(ans[j],temp);\\n                temp=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& a) {\\n        vector<int> ans(a[0].size());\\n        int n=a.size();\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int temp=0,mx=INT_MIN;\\n            for(int j=0;j<a[i].size();j++)\\n            {\\n                int val=a[i][j];\\n                if(val<0)\\n                {\\n                    val=val*(-1);\\n                    temp++;\\n                }\\n                if(val==0){\\n                    ans[j]=max(ans[j],1);\\n                    continue;\\n                }\\n                temp+=log10(val)+1;\\n                // cout<<a[i][j]<<\" \"<<temp<<endl;\\n                ans[j]=max(ans[j],temp);\\n                temp=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3653299,
                "title": "easy-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPLEASE UPVOTE !!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> a;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                string str=\"\";\\n                str=str+to_string(grid[j][i]);\\n                if(len<str.size())\\n                    len=str.size();\\n            }\\n            a.push_back(len);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> a;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                string str=\"\";\\n                str=str+to_string(grid[j][i]);\\n                if(len<str.size())\\n                    len=str.size();\\n            }\\n            a.push_back(len);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647213,
                "title": "simple-solution-and-easy-to-understand-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid):\\n        l=len(grid)   # finding length of the matrix\\n        org=[]\\n        # columns wise traversing\\n        for i in range(len(grid[0])):\\n            col=[]\\n            for j in range(l):\\n                col+=[str(grid[j][i])]     # adding columns wise elements to the \\'col\\' list\\n            org+=[sorted(col,key=len,reverse=True)]  # sort the elements based on \\'key\\' length after converting into strings , reverse=True for descending order\\n        res=[]\\n        for i in org:   # traversing org list\\n            res+=[len(i[0])]   # adding every first index length to the res list\\n        return res\\nobj=Solution()\\nobj.findColumnWidth([[1],[22],[333]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid):\\n        l=len(grid)   # finding length of the matrix\\n        org=[]\\n        # columns wise traversing\\n        for i in range(len(grid[0])):\\n            col=[]\\n            for j in range(l):\\n                col+=[str(grid[j][i])]     # adding columns wise elements to the \\'col\\' list\\n            org+=[sorted(col,key=len,reverse=True)]  # sort the elements based on \\'key\\' length after converting into strings , reverse=True for descending order\\n        res=[]\\n        for i in org:   # traversing org list\\n            res+=[len(i[0])]   # adding every first index length to the res list\\n        return res\\nobj=Solution()\\nobj.findColumnWidth([[1],[22],[333]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638853,
                "title": "easy-js-solution-runtime-beats-89-73",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    let result = [], col = []\\n\\n    for(let i = 0; i < grid[0].length; i++) {\\n        for(let j = 0; j < grid.length; j++) {\\n            col.push(grid[j][i] < 0 ? (grid[j][i] * -1).toString().length + 1 : grid[j][i].toString().length)\\n        }\\n\\n        result.push(Math.max(...col))\\n        col = []\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function(grid) {\\n    let result = [], col = []\\n\\n    for(let i = 0; i < grid[0].length; i++) {\\n        for(let j = 0; j < grid.length; j++) {\\n            col.push(grid[j][i] < 0 ? (grid[j][i] * -1).toString().length + 1 : grid[j][i].toString().length)\\n        }\\n\\n        result.push(Math.max(...col))\\n        col = []\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3635104,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        const auto m = grid.size(), n = grid[0].size();\\n        vector<int> result;\\n        for (auto j = 0; j < n; ++j) {\\n            auto width = 0;\\n            for (auto i = 0; i < m; ++i)\\n                width = max(width, int(to_string(grid[i][j]).size()));\\n            result.push_back(width);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        const auto m = grid.size(), n = grid[0].size();\\n        vector<int> result;\\n        for (auto j = 0; j < n; ++j) {\\n            auto width = 0;\\n            for (auto i = 0; i < m; ++i)\\n                width = max(width, int(to_string(grid[i][j]).size()));\\n            result.push_back(width);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627341,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans=[0]*len(grid[0])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                ans[j] = max(len(str(grid[i][j])),ans[j])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        ans=[0]*len(grid[0])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                ans[j] = max(len(str(grid[i][j])),ans[j])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595482,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        res=[] # create empty list to store max lengths in\\n\\n        for x in zip(*grid):  # zip the nested list so we can iterate through the tuples\\n            toplength=0       # create a variable to keep track of top length in each tuple\\n            for i in x:\\n                length = len(str(i))  # variable for all lengths in tuples\\n                if length>toplength: \\n                    toplength=length  \\n            res.append(toplength)   # put the max lengths in the result list \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        res=[] # create empty list to store max lengths in\\n\\n        for x in zip(*grid):  # zip the nested list so we can iterate through the tuples\\n            toplength=0       # create a variable to keep track of top length in each tuple\\n            for i in x:\\n                length = len(str(i))  # variable for all lengths in tuples\\n                if length>toplength: \\n                    toplength=length  \\n            res.append(toplength)   # put the max lengths in the result list \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566511,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint get_length(int x)\\n{\\n    int ans = 0;\\n    if(x>0)\\n    {\\n        while(x!=0) \\n        {\\n            ans++;\\n            x = x/10;\\n        }\\n        return ans;\\n    }\\n    else if(x<0)\\n    {\\n        x = x * -1;\\n         while(x!=0) \\n        {\\n            ans++;\\n            x = x/10;\\n        }\\n        return ans + 1;\\n    }\\n    else return 1;\\n}\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> ans = {};\\n        int maximum=0;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                int x = get_length(grid[j][i]);\\n                maximum = max(x,maximum);\\n            }\\n            ans.push_back(maximum);\\n            maximum = 0;\\n        }\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint get_length(int x)\\n{\\n    int ans = 0;\\n    if(x>0)\\n    {\\n        while(x!=0) \\n        {\\n            ans++;\\n            x = x/10;\\n        }\\n        return ans;\\n    }\\n    else if(x<0)\\n    {\\n        x = x * -1;\\n         while(x!=0) \\n        {\\n            ans++;\\n            x = x/10;\\n        }\\n        return ans + 1;\\n    }\\n    else return 1;\\n}\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> ans = {};\\n        int maximum=0;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                int x = get_length(grid[j][i]);\\n                maximum = max(x,maximum);\\n            }\\n            ans.push_back(maximum);\\n            maximum = 0;\\n        }\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558170,
                "title": "python3-short-and-easy-to-understand-solution-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        res=[]\\n        \\n        for c in range(len(grid[0])):\\n            maxEle=0\\n            ch=0\\n            for r in range(len(grid)):\\n                ch=0\\n                if grid[r][c]<0:\\n                    ch=len(str(abs(grid[r][c])))+1\\n                else:\\n                    ch=(len(str(grid[r][c]))) \\n                maxEle=max(maxEle,ch)\\n            res.append(maxEle)\\n                    \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        res=[]\\n        \\n        for c in range(len(grid[0])):\\n            maxEle=0\\n            ch=0\\n            for r in range(len(grid)):\\n                ch=0\\n                if grid[r][c]<0:\\n                    ch=len(str(abs(grid[r][c])))+1\\n                else:\\n                    ch=(len(str(grid[r][c]))) \\n                maxEle=max(maxEle,ch)\\n            res.append(maxEle)\\n                    \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534616,
                "title": "worst-solution-ever-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] a) {\\n        int[] ans= new int[a[0].length];\\n        for(int i=0;i<a[0].length;i++){\\n            for(int j=0;j<a.length;j++){\\n                int c=a[j][i] > 0 ? 0 : 1;\\n                a[j][i]=a[j][i] > 0 ? a[j][i] : a[j][i]*(-1);\\n                System.out.printf(\"%d\\\\n\",c);\\n                if(a[j][i]!=0){\\n                    c=c+(int)Math.log10(a[j][i]);\\n                    c++;\\n                }\\n                if(c>ans[i]){\\n                    ans[i]=c;\\n                }\\n                System.out.printf(\"%d\",c);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] a) {\\n        int[] ans= new int[a[0].length];\\n        for(int i=0;i<a[0].length;i++){\\n            for(int j=0;j<a.length;j++){\\n                int c=a[j][i] > 0 ? 0 : 1;\\n                a[j][i]=a[j][i] > 0 ? a[j][i] : a[j][i]*(-1);\\n                System.out.printf(\"%d\\\\n\",c);\\n                if(a[j][i]!=0){\\n                    c=c+(int)Math.log10(a[j][i]);\\n                    c++;\\n                }\\n                if(c>ans[i]){\\n                    ans[i]=c;\\n                }\\n                System.out.printf(\"%d\",c);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533087,
                "title": "java-o-n-m-beginner-friendly-no-maths",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] findColumnWidth(int[][] grid) \\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int ans[] = new int[m];\\n\\n        for(int i = 0; i < m; i++)\\n        {\\n            int maxLen = String.valueOf(grid[0][i]).length();\\n            for(int j = 0; j < n; j++)\\n            {\\n                maxLen = Math.max(maxLen, String.valueOf(grid[j][i]).length());\\n            }\\n            ans[i] = maxLen;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] findColumnWidth(int[][] grid) \\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int ans[] = new int[m];\\n\\n        for(int i = 0; i < m; i++)\\n        {\\n            int maxLen = String.valueOf(grid[0][i]).length();\\n            for(int j = 0; j < n; j++)\\n            {\\n                maxLen = Math.max(maxLen, String.valueOf(grid[j][i]).length());\\n            }\\n            ans[i] = maxLen;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532370,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] FindColumnWidth(int[][] grid) \\n    {\\n        var widths = new int[grid[0].Length];\\n\\n        for (var m = 0; m < grid.Length; m++)\\n        {\\n            for (var n = 0; n < grid[0].Length; n++)\\n            {\\n                var num = grid[m][n];\\n                var width = 0;\\n\\n                if (num < 1)\\n                    width++;\\n\\n                while (num != 0)\\n                {\\n                    width++;\\n                    num /= 10;\\n                }\\n                \\n                widths[n] = Math.Max(widths[n], width);\\n            }\\n        }\\n\\n        return widths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] FindColumnWidth(int[][] grid) \\n    {\\n        var widths = new int[grid[0].Length];\\n\\n        for (var m = 0; m < grid.Length; m++)\\n        {\\n            for (var n = 0; n < grid[0].Length; n++)\\n            {\\n                var num = grid[m][n];\\n                var width = 0;\\n\\n                if (num < 1)\\n                    width++;\\n\\n                while (num != 0)\\n                {\\n                    width++;\\n                    num /= 10;\\n                }\\n                \\n                widths[n] = Math.Max(widths[n], width);\\n            }\\n        }\\n\\n        return widths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531136,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findLen(int i){\\n        int count = 0;\\n        if(i == 0)\\n            return 1;\\n        if(i < 0)\\n            count++;\\n        while(i != 0){\\n            count++;\\n            i /=10;\\n        }\\n        return count;\\n    }\\n    public int[] findColumnWidth(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[] arr = new int[m];\\n        for(int i = 0;i < m;i++){\\n            int max = findLen(grid[0][i]);\\n            for(int j = 1;j < n;j++){\\n                max = Math.max(max,findLen(grid[j][i]));\\n            }\\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLen(int i){\\n        int count = 0;\\n        if(i == 0)\\n            return 1;\\n        if(i < 0)\\n            count++;\\n        while(i != 0){\\n            count++;\\n            i /=10;\\n        }\\n        return count;\\n    }\\n    public int[] findColumnWidth(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[] arr = new int[m];\\n        for(int i = 0;i < m;i++){\\n            int max = findLen(grid[0][i]);\\n            for(int j = 1;j < n;j++){\\n                max = Math.max(max,findLen(grid[j][i]));\\n            }\\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526579,
                "title": "c-mins-and-maxs-columns-144ms-97",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] FindColumnWidth(int[][] grid) \\n    {\\n        var (rows, cols) = (grid.Length, grid[0].Length);\\n\\n        var mins = new int[cols];\\n        var maxs = new int[cols];\\n\\n        for(var i = 0; i < cols; i++)\\n        {\\n            mins[i] = int.MaxValue;\\n            maxs[i] = int.MinValue;\\n        }\\n\\n        for(var c=0; c < cols; c++)\\n        {\\n            for(var r=0; r < rows; r++)\\n            {\\n                mins[c] = Math.Min(grid[r][c], mins[c]);\\n                maxs[c] = Math.Max(grid[r][c], maxs[c]);\\n            }\\n        }\\n\\n        for(var i = 0; i < cols; i++)\\n        {\\n            if(mins[i] >= 0)\\n            {\\n                mins[i] = maxs[i].ToString().Length;\\n            }\\n            else if(maxs[i] < 0)\\n            {\\n                mins[i] = mins[i].ToString().Length;\\n            }\\n            else\\n            {\\n                var lenMin = mins[i].ToString();\\n                var lenMax = maxs[i].ToString();\\n\\n                mins[i] = Math.Max(lenMin.Length, lenMax.Length);\\n            }\\n        }\\n\\n        return mins;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindColumnWidth(int[][] grid) \\n    {\\n        var (rows, cols) = (grid.Length, grid[0].Length);\\n\\n        var mins = new int[cols];\\n        var maxs = new int[cols];\\n\\n        for(var i = 0; i < cols; i++)\\n        {\\n            mins[i] = int.MaxValue;\\n            maxs[i] = int.MinValue;\\n        }\\n\\n        for(var c=0; c < cols; c++)\\n        {\\n            for(var r=0; r < rows; r++)\\n            {\\n                mins[c] = Math.Min(grid[r][c], mins[c]);\\n                maxs[c] = Math.Max(grid[r][c], maxs[c]);\\n            }\\n        }\\n\\n        for(var i = 0; i < cols; i++)\\n        {\\n            if(mins[i] >= 0)\\n            {\\n                mins[i] = maxs[i].ToString().Length;\\n            }\\n            else if(maxs[i] < 0)\\n            {\\n                mins[i] = mins[i].ToString().Length;\\n            }\\n            else\\n            {\\n                var lenMin = mins[i].ToString();\\n                var lenMax = maxs[i].ToString();\\n\\n                mins[i] = Math.Max(lenMin.Length, lenMax.Length);\\n            }\\n        }\\n\\n        return mins;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523512,
                "title": "c-solution-beats-90-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int ele){\\n        if(ele==0) return 1;\\n        int len=0;\\n        if(ele<0){\\n            while(ele!=0){\\n                ele=ele/10;\\n                len++;\\n            }\\n            len++;\\n        }\\n        else{\\n            while(ele!=0){\\n                ele=ele/10;\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int count=0,maxi=0;\\n        if(grid.size()==1 && grid[0].size()==1){\\n            int ele=grid[0][0];\\n            count=find(ele);\\n            ans.push_back(count);\\n            return ans;\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                int ele=grid[j][i];\\n                count=find(ele);\\n                if(maxi<count){\\n                    maxi=count;\\n                }\\n            }\\n            ans.push_back(maxi);\\n            maxi=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int ele){\\n        if(ele==0) return 1;\\n        int len=0;\\n        if(ele<0){\\n            while(ele!=0){\\n                ele=ele/10;\\n                len++;\\n            }\\n            len++;\\n        }\\n        else{\\n            while(ele!=0){\\n                ele=ele/10;\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int count=0,maxi=0;\\n        if(grid.size()==1 && grid[0].size()==1){\\n            int ele=grid[0][0];\\n            count=find(ele);\\n            ans.push_back(count);\\n            return ans;\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                int ele=grid[j][i];\\n                count=find(ele);\\n                if(maxi<count){\\n                    maxi=count;\\n                }\\n            }\\n            ans.push_back(maxi);\\n            maxi=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518609,
                "title": "java-clean-fast-log10",
                "content": "# Complexity\\n- Time complexity: O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] widths = new int[grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                int num = grid[i][j];\\n                int len = (num < 0 ? 1: 0) + (int) (Math.log10(Math.abs(num)) + 1);\\n                if (num == 0) len = 1;\\n                widths[j] = Math.max(widths[j], len);\\n            }\\n        }\\n        return widths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] widths = new int[grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                int num = grid[i][j];\\n                int len = (num < 0 ? 1: 0) + (int) (Math.log10(Math.abs(num)) + 1);\\n                if (num == 0) len = 1;\\n                widths[j] = Math.max(widths[j], len);\\n            }\\n        }\\n        return widths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517630,
                "title": "js-interesting-solution-beats-7-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar findColumnWidth = function (grid) {\\n    let ans = []\\n    let temp = []\\n\\n\\n    let x = 0;\\n    for (let j = 0; j < grid[0].length; j++) {\\n        for (let i = 0; i < grid.length; i++) {\\n            temp.push(grid[i][x].toString().length)\\n        }\\n        let max = Math.max(...temp);\\n        ans.push(max);\\n        temp = []\\n        x++;\\n    }\\n\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findColumnWidth = function (grid) {\\n    let ans = []\\n    let temp = []\\n\\n\\n    let x = 0;\\n    for (let j = 0; j < grid[0].length; j++) {\\n        for (let i = 0; i < grid.length; i++) {\\n            temp.push(grid[i][x].toString().length)\\n        }\\n        let max = Math.max(...temp);\\n        ans.push(max);\\n        temp = []\\n        x++;\\n    }\\n\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508245,
                "title": "runtime-6-ms-beats-78-99-memory-44-1-mb-beats-40-44",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int[] len = new int[col];\\n        int temp = 0;\\n\\n        for (int j = 0; j < col; j++) {\\n            int max = Integer.MIN_VALUE;\\n            for (int i = 0; i < row; i++) {\\n                if(String.valueOf(grid[i][j]).length() > max){\\n                    max = String.valueOf(grid[i][j]).length();\\n                }\\n            }\\n            len[temp] = max;\\n            temp++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int[] len = new int[col];\\n        int temp = 0;\\n\\n        for (int j = 0; j < col; j++) {\\n            int max = Integer.MIN_VALUE;\\n            for (int i = 0; i < row; i++) {\\n                if(String.valueOf(grid[i][j]).length() > max){\\n                    max = String.valueOf(grid[i][j]).length();\\n                }\\n            }\\n            len[temp] = max;\\n            temp++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502708,
                "title": "java-easy-string-conversion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int arr[]= new int[grid[0].length];\\n        int maxLength=0;\\n        for(int i=0;i<grid[0].length;i++){\\n            for(int j=0;j<grid.length;j++){\\n                String temp=String.valueOf(grid[j][i]);\\n                maxLength=Math.max(maxLength,temp.length());\\n            }\\n            arr[i]=maxLength;\\n            maxLength=0;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int arr[]= new int[grid[0].length];\\n        int maxLength=0;\\n        for(int i=0;i<grid[0].length;i++){\\n            for(int j=0;j<grid.length;j++){\\n                String temp=String.valueOf(grid[j][i]);\\n                maxLength=Math.max(maxLength,temp.length());\\n            }\\n            arr[i]=maxLength;\\n            maxLength=0;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499575,
                "title": "find-the-width-javascript-check-all-grid-elements-65-ms",
                "content": "```\\nvar findColumnWidth = function(grid) {\\n    arr = new Array(grid[0].length).fill(0)\\n \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {  \\n            len = grid[i][j].toString().length\\n            arr[j] = Math.max(arr[j], len)\\n        }\\n    }\\n\\n    return arr\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findColumnWidth = function(grid) {\\n    arr = new Array(grid[0].length).fill(0)\\n \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {  \\n            len = grid[i][j].toString().length\\n            arr[j] = Math.max(arr[j], len)\\n        }\\n    }\\n\\n    return arr\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497125,
                "title": "using-vector-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int col=grid[0].size();\\n        vector<int> ans(col,0);\\n            \\n            for(auto r:grid){\\n                for(int j=0;j<col;j++){ \\n                        int len = r[j]<0 ? 1 : 0;\\n                        if(abs(r[j])==0) { \\n                             ans[j]=max(ans[j],1);\\n                            continue;\\n                        }\\n                        len+=floor(log10(abs(r[j]))+1);\\n                        ans[j]=max(ans[j],len);\\n                }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int col=grid[0].size();\\n        vector<int> ans(col,0);\\n            \\n            for(auto r:grid){\\n                for(int j=0;j<col;j++){ \\n                        int len = r[j]<0 ? 1 : 0;\\n                        if(abs(r[j])==0) { \\n                             ans[j]=max(ans[j],1);\\n                            continue;\\n                        }\\n                        len+=floor(log10(abs(r[j]))+1);\\n                        ans[j]=max(ans[j],len);\\n                }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492233,
                "title": "python-1-line-of-code-matrix-traversal",
                "content": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max([len(str(grid[j][i])) for j in range(len(grid))]) for i in range(len(grid[0]))]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        return [max([len(str(grid[j][i])) for j in range(len(grid))]) for i in range(len(grid[0]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489297,
                "title": "simple-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) \\n    {\\n     int res[]=new int[grid[0].length];\\n     int c=0;\\n     while(c<res.length)\\n     {\\n         int max=1;\\n         for(int i=0;i<grid.length;i++)\\n         {\\n             max=Math.max(max,(grid[i][c]+\"\").length());\\n         }\\n         res[c]=max;\\n         c++;\\n     }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) \\n    {\\n     int res[]=new int[grid[0].length];\\n     int c=0;\\n     while(c<res.length)\\n     {\\n         int max=1;\\n         for(int i=0;i<grid.length;i++)\\n         {\\n             max=Math.max(max,(grid[i][c]+\"\").length());\\n         }\\n         res[c]=max;\\n         c++;\\n     }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487915,
                "title": "c-straightforward-solution-with-lambda",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] FindColumnWidth(int[][] grid) {\\n        int[] res = new int[grid[0].Length];\\n\\n        for(int i=0; i<grid[0].Length; i++)\\n        {\\n            res[i] = grid.Select(g => g[i]).Max(g => g.ToString().Length);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindColumnWidth(int[][] grid) {\\n        int[] res = new int[grid[0].Length];\\n\\n        for(int i=0; i<grid[0].Length; i++)\\n        {\\n            res[i] = grid.Select(g => g[i]).Max(g => g.ToString().Length);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487367,
                "title": "easy-cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> a;\\n        int max,\\n        n=grid[0].size(),\\n        m=grid.size();\\n        for(int i=0;i<n;i++){\\n              max=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[j][i]>=0){\\n                    if(max<noDigits(grid[j][i]))\\n                    max=noDigits(grid[j][i]);\\n                }\\n                else{\\n                    if(max<1+noDigits(-grid[j][i]))\\n                    max=1+noDigits(-grid[j][i]);\\n                }\\n            }\\n            a.push_back(max);\\n           \\n        }\\n         return a;\\n    }\\n    int noDigits(int n){\\n         if (n == 0)\\n        return 1;\\n    int count = 0;\\n    while (n != 0) {\\n        n = n / 10;\\n        ++count;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> a;\\n        int max,\\n        n=grid[0].size(),\\n        m=grid.size();\\n        for(int i=0;i<n;i++){\\n              max=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[j][i]>=0){\\n                    if(max<noDigits(grid[j][i]))\\n                    max=noDigits(grid[j][i]);\\n                }\\n                else{\\n                    if(max<1+noDigits(-grid[j][i]))\\n                    max=1+noDigits(-grid[j][i]);\\n                }\\n            }\\n            a.push_back(max);\\n           \\n        }\\n         return a;\\n    }\\n    int noDigits(int n){\\n         if (n == 0)\\n        return 1;\\n    int count = 0;\\n    while (n != 0) {\\n        n = n / 10;\\n        ++count;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486286,
                "title": "java-0ms-beats-100-and-clean-code",
                "content": "# Approach\\n1. Declare an int[] of size n (n columns).\\n2. For each column j 0..n, determine and set the width:\\n    - determine the min and max of that column.\\n    - return the maxLength of (min, max).\\n3. Return the answer. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] maxColLength = new int[grid[0].length];\\n        for (int j = 0; j < maxColLength.length; j++) {\\n            maxColLength[j] = getMaxColLength(grid, j);\\n        }\\n        return maxColLength;\\n    }\\n\\n    private int getMaxColLength(int[][] grid, int col) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 0; i < grid.length; i++) {\\n            min = Math.min(min, grid[i][col]);\\n            max = Math.max(max, grid[i][col]);\\n        }\\n        return Math.max(getIntLength(min), getIntLength(max));\\n    }\\n\\n    private int getIntLength(int num) {\\n        int len = num <= 0 ? 1 : 0;\\n        while (num != 0) {\\n            num = num / 10;\\n            len++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] maxColLength = new int[grid[0].length];\\n        for (int j = 0; j < maxColLength.length; j++) {\\n            maxColLength[j] = getMaxColLength(grid, j);\\n        }\\n        return maxColLength;\\n    }\\n\\n    private int getMaxColLength(int[][] grid, int col) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 0; i < grid.length; i++) {\\n            min = Math.min(min, grid[i][col]);\\n            max = Math.max(max, grid[i][col]);\\n        }\\n        return Math.max(getIntLength(min), getIntLength(max));\\n    }\\n\\n    private int getIntLength(int num) {\\n        int len = num <= 0 ? 1 : 0;\\n        while (num != 0) {\\n            num = num / 10;\\n            len++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484585,
                "title": "brute-force-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n\\n        vector<int> answer;\\n        for(int j = 0; j < columns; j++ ){\\n            int max_size = 0;\\n            // checking for every element columnwise\\n            for(int i = 0; i < rows; i++){\\n                //converting to string and then checking\\n                string val = to_string(grid[i][j]);\\n                int size = val.size();\\n                //comparing with every element for maxsize\\n                if(size > max_size){\\n                    max_size = size;\\n                }\\n            }\\n        answer.push_back(max_size);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n\\n        vector<int> answer;\\n        for(int j = 0; j < columns; j++ ){\\n            int max_size = 0;\\n            // checking for every element columnwise\\n            for(int i = 0; i < rows; i++){\\n                //converting to string and then checking\\n                string val = to_string(grid[i][j]);\\n                int size = val.size();\\n                //comparing with every element for maxsize\\n                if(size > max_size){\\n                    max_size = size;\\n                }\\n            }\\n        answer.push_back(max_size);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482483,
                "title": "simple-java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int arr[]=new int[grid[0].length];\\n        int k=0;\\n        for(int i=0;i<grid[0].length;i++){\\n            int max=Integer.MIN_VALUE;\\n            for(int j=0;j<grid.length;j++){\\n                String s=Integer.toString(grid[j][i]);\\n                char a[]=s.toCharArray();\\n                max=Math.max(max,a.length);\\n            }\\n            arr[k]=max;\\n            k++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int arr[]=new int[grid[0].length];\\n        int k=0;\\n        for(int i=0;i<grid[0].length;i++){\\n            int max=Integer.MIN_VALUE;\\n            for(int j=0;j<grid.length;j++){\\n                String s=Integer.toString(grid[j][i]);\\n                char a[]=s.toCharArray();\\n                max=Math.max(max,a.length);\\n            }\\n            arr[k]=max;\\n            k++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480765,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n    \\t\\n    \\tint[] ret=new int[grid[0].length];\\n\\n     \\tfor(int j=0;j<grid[0].length;j++) {\\n     \\t\\tint cmax=-1;\\n    \\t\\tfor(int i=0;i<grid.length;i++) {\\n    \\t\\t\\tif(cmax<String.valueOf(grid[i][j]).length()) {\\n    \\t\\t\\t\\tcmax=String.valueOf(grid[i][j]).length();\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tret[j]=cmax;\\n    \\t}\\n    \\treturn ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n    \\t\\n    \\tint[] ret=new int[grid[0].length];\\n\\n     \\tfor(int j=0;j<grid[0].length;j++) {\\n     \\t\\tint cmax=-1;\\n    \\t\\tfor(int i=0;i<grid.length;i++) {\\n    \\t\\t\\tif(cmax<String.valueOf(grid[i][j]).length()) {\\n    \\t\\t\\t\\tcmax=String.valueOf(grid[i][j]).length();\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tret[j]=cmax;\\n    \\t}\\n    \\treturn ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470474,
                "title": "easy-java-solution-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < grid.length; j++) {\\n                count = Math.max(count, Integer.toString(grid[j][i]).length());\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] ans = new int[grid[0].length];\\n\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < grid.length; j++) {\\n                count = Math.max(count, Integer.toString(grid[j][i]).length());\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465924,
                "title": "couldn-t-be-simpler",
                "content": "# Code\\n```\\nint num_len(long int a)\\n{\\n  if(a == 0){ return 1; }\\n  int s = 0;\\n  if(a < 0){ s++; }\\n  a = abs(a);\\n  while(a > 0){ a /= 10; s++; }\\n  return s;\\n}\\n\\nint* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize)\\n{\\n  *returnSize = *gridColSize;\\n  int * ans = malloc(*returnSize * sizeof(int));\\n  for(int i = 0; i < *returnSize; i++)\\n  {\\n    int max = 0;\\n    for(int j = 0 ; j < gridSize; j++)\\n    {\\n       max = max < num_len(grid[j][i]) ? num_len(grid[j][i]) : max;\\n    }\\n    ans[i] = max;\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nint num_len(long int a)\\n{\\n  if(a == 0){ return 1; }\\n  int s = 0;\\n  if(a < 0){ s++; }\\n  a = abs(a);\\n  while(a > 0){ a /= 10; s++; }\\n  return s;\\n}\\n\\nint* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize)\\n{\\n  *returnSize = *gridColSize;\\n  int * ans = malloc(*returnSize * sizeof(int));\\n  for(int i = 0; i < *returnSize; i++)\\n  {\\n    int max = 0;\\n    for(int j = 0 ; j < gridSize; j++)\\n    {\\n       max = max < num_len(grid[j][i]) ? num_len(grid[j][i]) : max;\\n    }\\n    ans[i] = max;\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464574,
                "title": "java-2-methods-simple",
                "content": "\\n**Version 1:** With string conversion\\n>**T/S:** O(mn lg w)/O(n), where m x n are dimensions of the grid and w is the number of characters in grid[i][j] on average\\n```\\npublic int[] findColumnWidth(int[][] grid) {\\n\\tvar ans = new int[grid[0].length];\\n\\n\\tfor (var i = 0; i < ans.length; i++)\\n\\t\\tfor (var row : grid)\\n\\t\\t\\tans[i] = Math.max(ans[i], String.valueOf(row[i]).length());\\n\\n\\treturn ans;\\n}\\n```\\n**Version 2:** Without string conversion\\n>**T/S:** O(mn)/O(n)\\n```\\npublic int[] findColumnWidth(int[][] grid) {\\n\\tvar ans = new int[grid[0].length];\\n\\n\\tfor (var i = 0; i < ans.length; i++)\\n\\t\\tfor (var row : grid) {\\n\\t\\t\\tvar width = row[i] < 0 ? 2 : 1;\\n\\t\\t\\t\\n\\t\\t\\tif (row[i] != 0)\\n\\t\\t\\t\\twidth += Math.log10(Math.abs(row[i]));\\n\\t\\t\\t\\t\\n\\t\\t\\tans[i] = Math.max(ans[i], width);\\n\\t\\t}\\n\\n\\treturn ans;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] findColumnWidth(int[][] grid) {\\n\\tvar ans = new int[grid[0].length];\\n\\n\\tfor (var i = 0; i < ans.length; i++)\\n\\t\\tfor (var row : grid)\\n\\t\\t\\tans[i] = Math.max(ans[i], String.valueOf(row[i]).length());\\n\\n\\treturn ans;\\n}\\n```\n```\\npublic int[] findColumnWidth(int[][] grid) {\\n\\tvar ans = new int[grid[0].length];\\n\\n\\tfor (var i = 0; i < ans.length; i++)\\n\\t\\tfor (var row : grid) {\\n\\t\\t\\tvar width = row[i] < 0 ? 2 : 1;\\n\\t\\t\\t\\n\\t\\t\\tif (row[i] != 0)\\n\\t\\t\\t\\twidth += Math.log10(Math.abs(row[i]));\\n\\t\\t\\t\\t\\n\\t\\t\\tans[i] = Math.max(ans[i], width);\\n\\t\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464301,
                "title": "easy-to-understand-java-code",
                "content": "# Intuition\\n<!-- Just convert each integer to string and then find its length and compare them -->\\n\\n# Approach\\n<!-- Just convert each integer to string and then find its length and compare them -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- o(m*n) -->\\n\\n- Space complexity:\\n<!--o(1) -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int a[]=new int[n];\\n        for(int j=0;j<n;j++){\\n            String str=Integer.toString(grid[0][j]);\\n            int len=str.length();\\n            for(int i=1;i<m;i++){\\n            String str1=Integer.toString(grid[i][j]);\\n            int len1=str1.length();\\n            if(len1>len) len=len1;\\n            }\\n            a[j]=len;\\n        }\\n        return a;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int a[]=new int[n];\\n        for(int j=0;j<n;j++){\\n            String str=Integer.toString(grid[0][j]);\\n            int len=str.length();\\n            for(int i=1;i<m;i++){\\n            String str1=Integer.toString(grid[i][j]);\\n            int len1=str1.length();\\n            if(len1>len) len=len1;\\n            }\\n            a[j]=len;\\n        }\\n        return a;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461914,
                "title": "ruby-one-liner-faster-than-100",
                "content": "```\\n# @param {Integer[][]} grid\\n# @return {Integer[]}\\ndef find_column_width(grid)\\n  grid.transpose.map { |col| col.minmax.map { _1.to_s.size }.max }  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer[]}\\ndef find_column_width(grid)\\n  grid.transpose.map { |col| col.minmax.map { _1.to_s.size }.max }  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3461540,
                "title": "java-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] mat) {\\n        int r=mat.length;\\n        int c=mat[0].length;\\n        int[] ans = new int[c];\\n        int k=0;\\n        for(int i=0;i<c;i++){\\n            int len=0;\\n            for(int j=0;j<r;j++){\\n                String s=\"\"+(mat[j][i]);\\n                len=Math.max(len,s.length());\\n            }\\n            ans[k]=len;\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] mat) {\\n        int r=mat.length;\\n        int c=mat[0].length;\\n        int[] ans = new int[c];\\n        int k=0;\\n        for(int i=0;i<c;i++){\\n            int len=0;\\n            for(int j=0;j<r;j++){\\n                String s=\"\"+(mat[j][i]);\\n                len=Math.max(len,s.length());\\n            }\\n            ans[k]=len;\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460897,
                "title": "simplest-3-lines-long-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(cols * rows)\\n\\n- Space complexity:\\nO(cols * rows)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        return [max([len(str(grid[row][col])) for row in range(rows)]) for col in range(cols)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        return [max([len(str(grid[row][col])) for row in range(rows)]) for col in range(cols)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460758,
                "title": "fastest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] res = new int[grid[0].length];\\n        for(int j=0; j<grid[0].length; j++){\\n            int sum = 0;\\n            for(int i=0; i<grid.length; i++){\\n                int count = 0, t = grid[i][j]<0 ? -grid[i][j] : grid[i][j];\\n                if(grid[i][j]<=0)\\n                   count = 1;\\n                while(t>0){\\n                    count++;\\n                    t /= 10;\\n                }\\n                sum = Math.max(sum, count);\\n            }\\n            res[j] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] res = new int[grid[0].length];\\n        for(int j=0; j<grid[0].length; j++){\\n            int sum = 0;\\n            for(int i=0; i<grid.length; i++){\\n                int count = 0, t = grid[i][j]<0 ? -grid[i][j] : grid[i][j];\\n                if(grid[i][j]<=0)\\n                   count = 1;\\n                while(t>0){\\n                    count++;\\n                    t /= 10;\\n                }\\n                sum = Math.max(sum, count);\\n            }\\n            res[j] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449075,
                "title": "rust-convert-to-string-then-get-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimulation the logic\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert i32 to string, then get length\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(rows * cols)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn find_column_width(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let rows = grid.len();\\n        let cols = grid[0].len();\\n        let mut res = vec![0; cols];\\n        for c in 0..cols {\\n            let mut wid = 0_i32;\\n            for r in 0..rows {\\n                let i_str = grid[r][c].to_string();\\n                wid = max(wid, i_str.len() as i32);\\n            }\\n            res[c] = wid;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn find_column_width(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let rows = grid.len();\\n        let cols = grid[0].len();\\n        let mut res = vec![0; cols];\\n        for c in 0..cols {\\n            let mut wid = 0_i32;\\n            for r in 0..rows {\\n                let i_str = grid[r][c].to_string();\\n                wid = max(wid, i_str.len() as i32);\\n            }\\n            res[c] = wid;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447878,
                "title": "python3-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        cols = len(grid[0])\\n        res = [0] * cols\\n        for r in range(len(grid)):\\n            for c in range(cols):\\n                L = len(str(grid[r][c]))\\n                res[c] = max(res[c], L)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        cols = len(grid[0])\\n        res = [0] * cols\\n        for r in range(len(grid)):\\n            for c in range(cols):\\n                L = len(str(grid[r][c]))\\n                res[c] = max(res[c], L)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446870,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> max(grid[0].size(),0);\\n        for(int i=0;i<grid[0].size();++i){\\n            for(int j=0;j<grid.size();++j){\\n                max[i] = std::max(int(to_string(grid[j][i]).length()),max[i]);  \\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> max(grid[0].size(),0);\\n        for(int i=0;i<grid[0].size();++i){\\n            for(int j=0;j<grid.size();++j){\\n                max[i] = std::max(int(to_string(grid[j][i]).length()),max[i]);  \\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446498,
                "title": "java-simple-solution-bruteforce-counting",
                "content": "# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int index = 0;\\n        int[] ans = new int[grid[0].length];\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int maxCount = 1;\\n            for (int[] ints : grid) {\\n                int currentCount = getCount(ints[i]);\\n                if (currentCount > maxCount) {\\n                    maxCount = currentCount;\\n                }\\n            }\\n            ans[index++] = maxCount;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static int getCount(int n) {\\n        int counter = 0;\\n        if (n < 0) {\\n            counter++;\\n            n *= -1;\\n        }\\n        \\n        while (n > 0) {\\n            n = n / 10;\\n            counter++;\\n        }\\n        \\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int index = 0;\\n        int[] ans = new int[grid[0].length];\\n        for (int i = 0; i < grid[0].length; i++) {\\n            int maxCount = 1;\\n            for (int[] ints : grid) {\\n                int currentCount = getCount(ints[i]);\\n                if (currentCount > maxCount) {\\n                    maxCount = currentCount;\\n                }\\n            }\\n            ans[index++] = maxCount;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static int getCount(int n) {\\n        int counter = 0;\\n        if (n < 0) {\\n            counter++;\\n            n *= -1;\\n        }\\n        \\n        while (n > 0) {\\n            n = n / 10;\\n            counter++;\\n        }\\n        \\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444362,
                "title": "two-loops-with-log10-abs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        for (int c = 0; c < size(grid[0]); ++c) {\\n            int w = 0;\\n            for (int r = 0; r < size(grid); ++r) {\\n                const int x = grid[r][c], len = (x != 0 ? (int)log10(abs(x))+1 : 1) + (x < 0);\\n                w = max(w, len);\\n            }\\n            ans.push_back(w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        for (int c = 0; c < size(grid[0]); ++c) {\\n            int w = 0;\\n            for (int r = 0; r < size(grid); ++r) {\\n                const int x = grid[r][c], len = (x != 0 ? (int)log10(abs(x))+1 : 1) + (x < 0);\\n                w = max(w, len);\\n            }\\n            ans.push_back(w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444206,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] maxWidthForEachColumn = new int[grid[0].length];\\n\\n        for (int column = 0; column < grid[0].length; ++column) {\\n\\n            int maxColumnWidth = 0;\\n            for (int row = 0; row < grid.length; ++row) {\\n                int additionForFirstDigit = 1;\\n                int additionForNegativeValue = grid[row][column] < 0 ? 1 : 0;\\n\\n                int currentColumnWidth = grid[row][column] != 0\\n                        ? ((int) Math.log10(Math.abs(grid[row][column])) + additionForFirstDigit + additionForNegativeValue)\\n                        : 1;\\n\\n                maxColumnWidth = Math.max(maxColumnWidth, currentColumnWidth);\\n            }\\n            maxWidthForEachColumn[column] = maxColumnWidth;\\n        }\\n\\n        return maxWidthForEachColumn;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function (grid) {\\n    const maxWidthForEachColumn = new Array(grid[0].length);\\n\\n    for (let column = 0; column < grid[0].length; ++column) {\\n\\n        let maxColumnWidth = 0;\\n        for (let row = 0; row < grid.length; ++row) {\\n            const additionForFirstDigit = 1;\\n            const additionForNegativeValue = grid[row][column] < 0 ? 1 : 0;\\n\\n            const currentColumnWidth = grid[row][column] !== 0\\n                    ? (Math.floor(Math.log10(Math.abs(grid[row][column]))) + additionForFirstDigit + additionForNegativeValue)\\n                    : 1;\\n\\n            maxColumnWidth = Math.max(maxColumnWidth, currentColumnWidth);\\n        }\\n        maxWidthForEachColumn[column] = maxColumnWidth;\\n    }\\n\\n    return maxWidthForEachColumn;\\n};\\n```\\n**C++**\\n```\\n#include <cmath>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> findColumnWidth(const vector<vector<int>>& grid) const {\\n        vector<int> maxWidthForEachColumn;\\n\\n        for (int column = 0; column < grid[0].size(); ++column) {\\n\\n            int maxColumnWidth = 0;\\n            for (int row = 0; row < grid.size(); ++row) {\\n                int additionForFirstDigit = 1;\\n                int additionForNegativeValue = grid[row][column] < 0 ? 1 : 0;\\n\\n                int currentColumnWidth = grid[row][column] != 0\\n                         //in this context, log10(...) is implicitly converted to int\\n                        ? (log10(abs(grid[row][column])) + additionForFirstDigit + additionForNegativeValue)\\n                        : 1;\\n\\n                maxColumnWidth = max(maxColumnWidth, currentColumnWidth);\\n            }\\n            maxWidthForEachColumn.push_back(maxColumnWidth);\\n        }\\n\\n        return maxWidthForEachColumn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int[] findColumnWidth(int[][] grid) {\\n        int[] maxWidthForEachColumn = new int[grid[0].length];\\n\\n        for (int column = 0; column < grid[0].length; ++column) {\\n\\n            int maxColumnWidth = 0;\\n            for (int row = 0; row < grid.length; ++row) {\\n                int additionForFirstDigit = 1;\\n                int additionForNegativeValue = grid[row][column] < 0 ? 1 : 0;\\n\\n                int currentColumnWidth = grid[row][column] != 0\\n                        ? ((int) Math.log10(Math.abs(grid[row][column])) + additionForFirstDigit + additionForNegativeValue)\\n                        : 1;\\n\\n                maxColumnWidth = Math.max(maxColumnWidth, currentColumnWidth);\\n            }\\n            maxWidthForEachColumn[column] = maxColumnWidth;\\n        }\\n\\n        return maxWidthForEachColumn;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findColumnWidth = function (grid) {\\n    const maxWidthForEachColumn = new Array(grid[0].length);\\n\\n    for (let column = 0; column < grid[0].length; ++column) {\\n\\n        let maxColumnWidth = 0;\\n        for (let row = 0; row < grid.length; ++row) {\\n            const additionForFirstDigit = 1;\\n            const additionForNegativeValue = grid[row][column] < 0 ? 1 : 0;\\n\\n            const currentColumnWidth = grid[row][column] !== 0\\n                    ? (Math.floor(Math.log10(Math.abs(grid[row][column]))) + additionForFirstDigit + additionForNegativeValue)\\n                    : 1;\\n\\n            maxColumnWidth = Math.max(maxColumnWidth, currentColumnWidth);\\n        }\\n        maxWidthForEachColumn[column] = maxColumnWidth;\\n    }\\n\\n    return maxWidthForEachColumn;\\n};\\n```\n```\\n#include <cmath>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> findColumnWidth(const vector<vector<int>>& grid) const {\\n        vector<int> maxWidthForEachColumn;\\n\\n        for (int column = 0; column < grid[0].size(); ++column) {\\n\\n            int maxColumnWidth = 0;\\n            for (int row = 0; row < grid.size(); ++row) {\\n                int additionForFirstDigit = 1;\\n                int additionForNegativeValue = grid[row][column] < 0 ? 1 : 0;\\n\\n                int currentColumnWidth = grid[row][column] != 0\\n                         //in this context, log10(...) is implicitly converted to int\\n                        ? (log10(abs(grid[row][column])) + additionForFirstDigit + additionForNegativeValue)\\n                        : 1;\\n\\n                maxColumnWidth = max(maxColumnWidth, currentColumnWidth);\\n            }\\n            maxWidthForEachColumn.push_back(maxColumnWidth);\\n        }\\n\\n        return maxWidthForEachColumn;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3443640,
                "title": "python-3-solutions",
                "content": "# **1. GET THE LENGTH OF A NUMBER WITHOUT CONVERTING IT TO STRING**\\n\\n```\\nclass Solution:\\n    # Helper method to get the length of a number\\n    def lengthOfNumber (self, n):\\n        if n == 0: return 1\\n        \\n        # Length of the number\\n        length = 0 \\n        \\n        # If n is negative, increment length by 1\\n        if n < 0: \\n            length += 1\\n            n = abs(n)\\n        \\n        while n > 0:\\n            length += 1\\n            n = n // 10\\n            \\n        return length\\n\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        # Rows\\n        rows = len(grid)\\n        \\n        # Columns\\n        cols = len(grid[0])\\n        \\n        # Output list to return\\n        output = []\\n        \\n        # Go through each column\\n        for col in range(cols):\\n            maxLength = 1\\n            \\n            for row in range(rows):\\n                # Current number\\'s length\\n                currentLength = self.lengthOfNumber(grid[row][col])\\n                \\n                # Update the max length if required\\n                maxLength = max(maxLength, currentLength)\\n            \\n            # Finally, push the maximum length of this column in the output list\\n            output.append(maxLength)\\n        \\n        return output\\n```\\n\\n# **2. GET THE LENGTH OF A NUMBER BY CONVERTING IT TO STRING**\\n\\n```\\ndef findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        # Rows\\n        rows = len(grid)\\n        \\n        # Columns\\n        cols = len(grid[0])\\n        \\n        # Output list to return\\n        output = []\\n        \\n        # Go through each column\\n        for col in range(cols):\\n            maxLength = 1\\n            \\n            for row in range(rows):\\n                # Current number\\'s length\\n                currentLength = len(str(grid[row][col]))\\n                \\n                # Update the max length if required\\n                maxLength = max(maxLength, currentLength)\\n            \\n            # Finally, push the maximum length of this column in the output list\\n            output.append(maxLength)\\n        \\n        return output\\n```\\n\\n# **3. GET THE LENGTH OF A NUMBER USING MATH.LOG10**\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to get the length of a number\\n    def lengthOfNumber (self, n):\\n        # If it is a zero\\n        if n == 0: return 1\\n        \\n        # If it is a positive number\\n        elif n > 0: return int(math.log10(n))+1\\n        \\n        # If it is a negative number (add an extra 1)\\n        return int(math.log10(-n))+2\\n\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        # Rows\\n        rows = len(grid)\\n        \\n        # Columns\\n        cols = len(grid[0])\\n        \\n        # Output list to return\\n        output = []\\n        \\n        # Go through each column\\n        for col in range(cols):\\n            maxLength = 1\\n            \\n            for row in range(rows):\\n                # Current number\\'s length\\n                currentLength = self.lengthOfNumber(grid[row][col])\\n                \\n                # Update the max length if required\\n                maxLength = max(maxLength, currentLength)\\n            \\n            # Finally, push the maximum length of this column in the output list\\n            output.append(maxLength)\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    # Helper method to get the length of a number\\n    def lengthOfNumber (self, n):\\n        if n == 0: return 1\\n        \\n        # Length of the number\\n        length = 0 \\n        \\n        # If n is negative, increment length by 1\\n        if n < 0: \\n            length += 1\\n            n = abs(n)\\n        \\n        while n > 0:\\n            length += 1\\n            n = n // 10\\n            \\n        return length\\n\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        # Rows\\n        rows = len(grid)\\n        \\n        # Columns\\n        cols = len(grid[0])\\n        \\n        # Output list to return\\n        output = []\\n        \\n        # Go through each column\\n        for col in range(cols):\\n            maxLength = 1\\n            \\n            for row in range(rows):\\n                # Current number\\'s length\\n                currentLength = self.lengthOfNumber(grid[row][col])\\n                \\n                # Update the max length if required\\n                maxLength = max(maxLength, currentLength)\\n            \\n            # Finally, push the maximum length of this column in the output list\\n            output.append(maxLength)\\n        \\n        return output\\n```\n```\\ndef findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        # Rows\\n        rows = len(grid)\\n        \\n        # Columns\\n        cols = len(grid[0])\\n        \\n        # Output list to return\\n        output = []\\n        \\n        # Go through each column\\n        for col in range(cols):\\n            maxLength = 1\\n            \\n            for row in range(rows):\\n                # Current number\\'s length\\n                currentLength = len(str(grid[row][col]))\\n                \\n                # Update the max length if required\\n                maxLength = max(maxLength, currentLength)\\n            \\n            # Finally, push the maximum length of this column in the output list\\n            output.append(maxLength)\\n        \\n        return output\\n```\n```\\nclass Solution:\\n    \\n    # Helper method to get the length of a number\\n    def lengthOfNumber (self, n):\\n        # If it is a zero\\n        if n == 0: return 1\\n        \\n        # If it is a positive number\\n        elif n > 0: return int(math.log10(n))+1\\n        \\n        # If it is a negative number (add an extra 1)\\n        return int(math.log10(-n))+2\\n\\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        # Rows\\n        rows = len(grid)\\n        \\n        # Columns\\n        cols = len(grid[0])\\n        \\n        # Output list to return\\n        output = []\\n        \\n        # Go through each column\\n        for col in range(cols):\\n            maxLength = 1\\n            \\n            for row in range(rows):\\n                # Current number\\'s length\\n                currentLength = self.lengthOfNumber(grid[row][col])\\n                \\n                # Update the max length if required\\n                maxLength = max(maxLength, currentLength)\\n            \\n            # Finally, push the maximum length of this column in the output list\\n            output.append(maxLength)\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443474,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countDigits(int n)\\n    {\\n        if(n==0) return 1;\\n        int cnt=0;\\n        bool neg=n<0;\\n        while(n)\\n        {\\n            n/=10;\\n            cnt++;\\n        }\\n        if(neg) cnt++;\\n        return cnt;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) \\n    {\\n        int rows=grid.size(), cols=grid[0].size();\\n        vector<int> ans(cols,0);\\n        for(int c=0; c<cols; c++)\\n        {\\n            int mx=0;\\n            for(int r=0; r<rows; r++)\\n            {\\n                mx=max(mx,countDigits(grid[r][c]));\\n            }\\n            ans[c]=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countDigits(int n)\\n    {\\n        if(n==0) return 1;\\n        int cnt=0;\\n        bool neg=n<0;\\n        while(n)\\n        {\\n            n/=10;\\n            cnt++;\\n        }\\n        if(neg) cnt++;\\n        return cnt;\\n    }\\n    vector<int> findColumnWidth(vector<vector<int>>& grid) \\n    {\\n        int rows=grid.size(), cols=grid[0].size();\\n        vector<int> ans(cols,0);\\n        for(int c=0; c<cols; c++)\\n        {\\n            int mx=0;\\n            for(int r=0; r<rows; r++)\\n            {\\n                mx=max(mx,countDigits(grid[r][c]));\\n            }\\n            ans[c]=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442842,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        #m=0\\n        ls=[0]*len(grid[0])\\n        for item in grid:\\n            for i,j in enumerate(item):\\n                ls[i]=max(len(str(j)),ls[i])\\n        return ls\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findColumnWidth(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        #m=0\\n        ls=[0]*len(grid[0])\\n        for item in grid:\\n            for i,j in enumerate(item):\\n                ls[i]=max(len(str(j)),ls[i])\\n        return ls\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442065,
                "title": "c-19-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int numLenght(int num) {\\n        int lenght = num <= 0 ? 1 : 0;\\n        while(num) { ++lenght; num/=10; }\\n        return lenght;\\n    }\\n\\n    vector<int> findColumnWidth(const vector<vector<int>>& grid) {\\n        vector<int> result(grid[0].size());\\n        for(const auto& row : grid)\\n            for(size_t i = 0; i < row.size(); ++i)\\n                result[i] = max(result[i], numLenght(row[i]));\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int numLenght(int num) {\\n        int lenght = num <= 0 ? 1 : 0;\\n        while(num) { ++lenght; num/=10; }\\n        return lenght;\\n    }\\n\\n    vector<int> findColumnWidth(const vector<vector<int>>& grid) {\\n        vector<int> result(grid[0].size());\\n        for(const auto& row : grid)\\n            for(size_t i = 0; i < row.size(); ++i)\\n                result[i] = max(result[i], numLenght(row[i]));\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864221,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "People solving all the questions in Just 7 minute and me only after solving 2/4 , continuous watching  my rank that how much more decreases...\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "same here \\uD83E\\uDD23"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python users, it\\'s helpful that the Leetcode implementation of Python allows us to import numpy."
                    },
                    {
                        "username": "Msey",
                        "content": "There are two types of people: the ones who uses val.ToString() and who uses log10"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Iterate the columns -> convert them to string -> find the max length of element in that particular column.\n\nPython 1 line code - https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/solutions/3420889/python-clean-1-liner/"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@ma5termiind](/ma5termiind) Let me know if u find a faster approach !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@cybersimar](/cybersimar) You will have to traverse the whole matrix once which makes the time complexity O(mn) , but since the constraint is low this time complexity shouldn't be a problem"
                    },
                    {
                        "username": "cybersimar",
                        "content": "But, the problem to this approach in c++ is that it is running in O(n^2) because of which it is taking too much time. "
                    },
                    {
                        "username": "c4tdog",
                        "content": "if n > 0 it\\'s length is Math.log10(n) + 1 ;)"
                    }
                ]
            },
            {
                "id": 2076318,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "People solving all the questions in Just 7 minute and me only after solving 2/4 , continuous watching  my rank that how much more decreases...\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "same here \\uD83E\\uDD23"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python users, it\\'s helpful that the Leetcode implementation of Python allows us to import numpy."
                    },
                    {
                        "username": "Msey",
                        "content": "There are two types of people: the ones who uses val.ToString() and who uses log10"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Iterate the columns -> convert them to string -> find the max length of element in that particular column.\n\nPython 1 line code - https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/solutions/3420889/python-clean-1-liner/"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@ma5termiind](/ma5termiind) Let me know if u find a faster approach !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@cybersimar](/cybersimar) You will have to traverse the whole matrix once which makes the time complexity O(mn) , but since the constraint is low this time complexity shouldn't be a problem"
                    },
                    {
                        "username": "cybersimar",
                        "content": "But, the problem to this approach in c++ is that it is running in O(n^2) because of which it is taking too much time. "
                    },
                    {
                        "username": "c4tdog",
                        "content": "if n > 0 it\\'s length is Math.log10(n) + 1 ;)"
                    }
                ]
            },
            {
                "id": 1864452,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "People solving all the questions in Just 7 minute and me only after solving 2/4 , continuous watching  my rank that how much more decreases...\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "same here \\uD83E\\uDD23"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python users, it\\'s helpful that the Leetcode implementation of Python allows us to import numpy."
                    },
                    {
                        "username": "Msey",
                        "content": "There are two types of people: the ones who uses val.ToString() and who uses log10"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Iterate the columns -> convert them to string -> find the max length of element in that particular column.\n\nPython 1 line code - https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/solutions/3420889/python-clean-1-liner/"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@ma5termiind](/ma5termiind) Let me know if u find a faster approach !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@cybersimar](/cybersimar) You will have to traverse the whole matrix once which makes the time complexity O(mn) , but since the constraint is low this time complexity shouldn't be a problem"
                    },
                    {
                        "username": "cybersimar",
                        "content": "But, the problem to this approach in c++ is that it is running in O(n^2) because of which it is taking too much time. "
                    },
                    {
                        "username": "c4tdog",
                        "content": "if n > 0 it\\'s length is Math.log10(n) + 1 ;)"
                    }
                ]
            },
            {
                "id": 1864426,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "People solving all the questions in Just 7 minute and me only after solving 2/4 , continuous watching  my rank that how much more decreases...\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "same here \\uD83E\\uDD23"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python users, it\\'s helpful that the Leetcode implementation of Python allows us to import numpy."
                    },
                    {
                        "username": "Msey",
                        "content": "There are two types of people: the ones who uses val.ToString() and who uses log10"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Iterate the columns -> convert them to string -> find the max length of element in that particular column.\n\nPython 1 line code - https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/solutions/3420889/python-clean-1-liner/"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@ma5termiind](/ma5termiind) Let me know if u find a faster approach !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@cybersimar](/cybersimar) You will have to traverse the whole matrix once which makes the time complexity O(mn) , but since the constraint is low this time complexity shouldn't be a problem"
                    },
                    {
                        "username": "cybersimar",
                        "content": "But, the problem to this approach in c++ is that it is running in O(n^2) because of which it is taking too much time. "
                    },
                    {
                        "username": "c4tdog",
                        "content": "if n > 0 it\\'s length is Math.log10(n) + 1 ;)"
                    }
                ]
            },
            {
                "id": 1864282,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "People solving all the questions in Just 7 minute and me only after solving 2/4 , continuous watching  my rank that how much more decreases...\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "same here \\uD83E\\uDD23"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python users, it\\'s helpful that the Leetcode implementation of Python allows us to import numpy."
                    },
                    {
                        "username": "Msey",
                        "content": "There are two types of people: the ones who uses val.ToString() and who uses log10"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Iterate the columns -> convert them to string -> find the max length of element in that particular column.\n\nPython 1 line code - https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/solutions/3420889/python-clean-1-liner/"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@ma5termiind](/ma5termiind) Let me know if u find a faster approach !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@cybersimar](/cybersimar) You will have to traverse the whole matrix once which makes the time complexity O(mn) , but since the constraint is low this time complexity shouldn't be a problem"
                    },
                    {
                        "username": "cybersimar",
                        "content": "But, the problem to this approach in c++ is that it is running in O(n^2) because of which it is taking too much time. "
                    },
                    {
                        "username": "c4tdog",
                        "content": "if n > 0 it\\'s length is Math.log10(n) + 1 ;)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Nested Array Generator",
        "question_content": "<p>Given a&nbsp;<strong>multi-dimensional array</strong> of integers, return&nbsp;a generator object which&nbsp;yields integers in the same order as&nbsp;<strong>inorder traversal</strong>.</p>\n\n<p>A&nbsp;<strong>multi-dimensional array</strong>&nbsp;is a recursive data structure that contains both integers and other&nbsp;<strong>multi-dimensional arrays</strong>.</p>\n\n<p><strong>inorder traversal</strong>&nbsp;iterates over&nbsp;each array from left to right, yielding any integers it encounters or applying&nbsp;<strong>inorder traversal</strong>&nbsp;to any arrays it encounters.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [[[6]],[1,3],[]]\n<strong>Output:</strong> [6,1,3]\n<strong>Explanation:</strong>\nconst generator = inorderTraversal(arr);\ngenerator.next().value; // 6\ngenerator.next().value; // 1\ngenerator.next().value; // 3\ngenerator.next().done; // true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no integers so the generator doesn&#39;t yield anything.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr.flat()[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>maxNestingDepth &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Can you solve this without creating a new flattened version of the array?</strong>",
        "solutions": [
            {
                "id": 3439989,
                "title": "javascript-recursive-generator-o-n-time-and-o-d-space",
                "content": "Generator is a feature introduced in Javascript ES6. Through the `yield` keyword, we can pause function execution and return an intermediate value until the next time the generator is invoked.\\n\\n`yield*` is used when we want to delegate to another Generator (in this case the recursive call).\\n\\nTime complexity: O(n), where n is the # of *total* elements in array, i.e. `arr.flat().length`\\nSpace complexity: O(d), where d is the maximum depth of the nested array\\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let element of arr) {\\n        if (Array.isArray(element)) {\\n            yield* inorderTraversal(element);\\n        } else {\\n            yield element;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    for (let element of arr) {\\n        if (Array.isArray(element)) {\\n            yield* inorderTraversal(element);\\n        } else {\\n            yield element;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591354,
                "title": "inorder-yield-with-explanation",
                "content": "The `inorderTraversal` function uses a generator `(function*)` to yield integers in the same order as an inorder traversal of the multi-dimensional array.\\n\\nThe function iterates over each element in the array. If the element is an array itself, the function recursively calls `inorderTraversal` on that subarray using the `yield*` syntax to yield integers from the subarray in the correct order. If the element is an integer, it is immediately yielded.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591317,
                "title": "4-liner-lets-go-commented",
                "content": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n```\\n\\nThe code we provided is a JavaScript generator function that performs an inorder traversal on a nested array (`arr`) and yields each element in the traversal sequence. Let\\'s break down the code and explain it with an example:\\n\\nThe `for` loop iterates over each element in the `arr` array. \\n\\n- If the current element `arr[i]` is an array itself (checked using `Array.isArray()`), it recursively calls the `inorderTraversal` function with the nested array `arr[i]` as the argument, using the `yield*` syntax. This means that the generator will yield all the values generated by the recursive call.\\n- If the current element `arr[i]` is not an array, it means it is a leaf node in the tree structure, so it is directly yielded using the `yield` keyword.\\n\\nHere\\'s an example to illustrate how the code works:\\n\\n```javascript\\nconst arr = [1, [2, 3, [4, 5]], 6, [7, 8]];\\n\\nconst generator = inorderTraversal(arr);\\n\\nfor (const value of generator) {\\n  console.log(value);\\n}\\n```\\n\\nThe nested array `arr` contains several levels of nesting. The inorder traversal will yield the elements in the order they would be visited in an inorder traversal of the nested structure. The expected output of the example above would be:\\n\\n```\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n```\\n\\nThe generator first yields the elements from the left subtree, then the root, and finally the elements from the right subtree, following the order: left subtree -> root -> right subtree.",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n```\n```javascript\\nconst arr = [1, [2, 3, [4, 5]], 6, [7, 8]];\\n\\nconst generator = inorderTraversal(arr);\\n\\nfor (const value of generator) {\\n  console.log(value);\\n}\\n```\n```\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591518,
                "title": "java-script-solution-for-nested-array-generator-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use recursion to perform an inorder traversal on the multi-dimensional array. The approach is to define a helper function called traverse that recursively traverses the array and yields integers encountered in the inorder traversal order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The inorderTraversal function takes the input multi-dimensional array arr and returns a generator object.\\n1. The traverse function is a recursive helper function that takes a node as input.\\n1. If the node is an array, the function iterates over each subarray using a for...of loop.\\n1. For each subarray, the traverse function recursively calls itself with the subarray as the argument.\\n1. If the node is not an array (i.e., it\\'s an integer), the function yields the integer using the yield keyword.\\n1. The yield* traverse(arr) statement in the inorderTraversal function initializes the generator and starts the traversal by calling the traverse function with the input array arr.\\n1. Each time the generator\\'s next() method is called, it progresses through the traversal and returns the next yielded value.\\n1. The generator can be used to retrieve integers from the multi-dimensional array in the order of an inorder traversal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(N), where N is the total number of integers in the multi-dimensional array. This is because the solution needs to visit each integer exactly once to yield it.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(D), where D is the maximum nesting depth of the multi-dimensional array. This is because the recursion depth is equal to the nesting depth, and each recursive call consumes stack space.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591734,
                "title": "easy-solution-beat-100-approx",
                "content": "![image.png](https://assets.leetcode.com/users/images/899c7053-f2fb-4131-920f-7e112233d0f9_1685772426.0217776.png)\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    const inorderArray = [];\\n    const solve = (arr) => {\\n      for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i])) solve(arr[i]);\\n        else inorderArray.push(arr[i]);\\n      }\\n    }\\n    solve(arr);\\n    for(let i=0;i<inorderArray.length;i++){\\n      yield inorderArray[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    const inorderArray = [];\\n    const solve = (arr) => {\\n      for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i])) solve(arr[i]);\\n        else inorderArray.push(arr[i]);\\n      }\\n    }\\n    solve(arr);\\n    for(let i=0;i<inorderArray.length;i++){\\n      yield inorderArray[i];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3559657,
                "title": "simple-solution-using-a-stack",
                "content": "# Approach\\nUses a stack to keep track of which elements to visit next.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n  if (arr.length === 0) {\\n    return null\\n  }\\n\\n  const stack = [arr]\\n  while (stack.length > 0) {\\n    const current = stack.pop()\\n    if (Array.isArray(current)) {\\n      for (let i = current.length - 1; i >= 0; i--) {\\n        stack.push(current[i])\\n      }\\n    } else {\\n      yield current\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n  if (arr.length === 0) {\\n    return null\\n  }\\n\\n  const stack = [arr]\\n  while (stack.length > 0) {\\n    const current = stack.pop()\\n    if (Array.isArray(current)) {\\n      for (let i = current.length - 1; i >= 0; i--) {\\n        stack.push(current[i])\\n      }\\n    } else {\\n      yield current\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924305,
                "title": "1-line-typescript-solution",
                "content": "# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(\\n  arr: MultidimensionalArray\\n): Generator<number, void, unknown> {\\n  for (const x of arr) Array.isArray(x) ? yield* inorderTraversal(x) : yield x;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(\\n  arr: MultidimensionalArray\\n): Generator<number, void, unknown> {\\n  for (const x of arr) Array.isArray(x) ? yield* inorderTraversal(x) : yield x;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533497,
                "title": "simplest-and-easiest-solution-in-javascript-wow-0-0-you-must-watch-solution",
                "content": "# Please upvote if you liked :)\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let array = arr.flat(Infinity)\\n    array.reverse()\\n    while(array.length) {\\n        yield array.pop()\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let array = arr.flat(Infinity)\\n    array.reverse()\\n    while(array.length) {\\n        yield array.pop()\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462325,
                "title": "javascript-simplest-solution",
                "content": "\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097005,
                "title": "new-flattened-version-of-the-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using the delegation (yield*), we can make the main generator function in charge of yielding the sub generator function. If an item in the array is another array, the sub generator function will delegate the\\xA0yielding process of\\xA0another sub generator function that contains our sub array, automating the yielding process.\\n# Complexity\\n- Time complexity: 153ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 74.09MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    function* Generator(interior){\\n        for(let i = 0;i < interior.length;i++){\\n            if(Array.isArray(interior[i])){\\n                yield* Generator(interior[i]);\\n            }else{\\n                yield interior[i];\\n            };\\n        }\\n    }\\n    yield* Generator(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2                                                                                   \\n * gen.next().value; // 3 */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    function* Generator(interior){\\n        for(let i = 0;i < interior.length;i++){\\n            if(Array.isArray(interior[i])){\\n                yield* Generator(interior[i]);\\n            }else{\\n                yield interior[i];\\n            };\\n        }\\n    }\\n    yield* Generator(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2                                                                                   \\n * gen.next().value; // 3 */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062068,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978369,
                "title": "recursive-generator-explained-145ms-74-71mb-beats-87-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOff the name of the problem and from a quick glance you can easily tell that this calls for recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Loop through the multidimensional array\\n    - If the current item is an array yield the generator with the current array as the argument\\n    - Else the current item is a number, yield the number  \\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray)\\n        } else {\\n            yield arr[i] as number\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray)\\n        } else {\\n            yield arr[i] as number\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958842,
                "title": "javascript-simple-approach-yield-operator-beats-95-run-time",
                "content": "\\n# Code\\n```\\n\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity)\\n\\n    var i = 0\\n\\n    let n = arr.length\\n\\n    for(i; i < n; i++){\\n        yield arr[i]\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity)\\n\\n    var i = 0\\n\\n    let n = arr.length\\n\\n    for(i; i < n; i++){\\n        yield arr[i]\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932680,
                "title": "typescript-recursive-solution",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr)\\n        if (Array.isArray(item)) yield* inorderTraversal(item as MultidimensionalArray)\\n        else yield item\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr)\\n        if (Array.isArray(item)) yield* inorderTraversal(item as MultidimensionalArray)\\n        else yield item\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3928992,
                "title": "using-built-in-flat-iterative-and-recursive-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Using Flat\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\\n\\n# Using Iterative\\n```\\n/**\\n* @param {Array} arr\\n*\\n* @return {Generator}\\n*/\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n\\n    while(stack.length) {\\n      let item = stack.pop()\\n\\n      if(typeof item == \\'number\\') {\\n        yield item\\n        continue;\\n      }\\n\\n      for(let i = item.length - 1; i >= 0; i--) {\\n        stack.push(item[i])\\n      }\\n    }\\n}\\n```\\n\\n# Using Recursive\\n\\n```\\n/**\\n* @param {Array} arr\\n* @return {Generator}\\n* /\\nvar inorderTraversal = function*(arr) {   \\n    for(let i = 0; i < arr.length; ++i) {\\n        if(typeof arr[i] == \\'number\\') yield arr[i]\\n        else {\\n           yield* inorderTraversal(arr[i])\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\n```\\n/**\\n* @param {Array} arr\\n*\\n* @return {Generator}\\n*/\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n\\n    while(stack.length) {\\n      let item = stack.pop()\\n\\n      if(typeof item == \\'number\\') {\\n        yield item\\n        continue;\\n      }\\n\\n      for(let i = item.length - 1; i >= 0; i--) {\\n        stack.push(item[i])\\n      }\\n    }\\n}\\n```\n```\\n/**\\n* @param {Array} arr\\n* @return {Generator}\\n* /\\nvar inorderTraversal = function*(arr) {   \\n    for(let i = 0; i < arr.length; ++i) {\\n        if(typeof arr[i] == \\'number\\') yield arr[i]\\n        else {\\n           yield* inorderTraversal(arr[i])\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915612,
                "title": "simple-js-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar inorderTraversal = function*(arr) {\\n    const q = arr.reverse()\\n\\n    while (q.length) {\\n        const curr = q.pop()\\n        if (typeof curr === \\'number\\') yield curr\\n        else q.push(...curr.reverse())\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    const q = arr.reverse()\\n\\n    while (q.length) {\\n        const curr = q.pop()\\n        if (typeof curr === \\'number\\') yield curr\\n        else q.push(...curr.reverse())\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909471,
                "title": "javascript-solution-beats-96-31-flat-approach",
                "content": "```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let flatArray = arr.flat(Infinity);\\n    for (let i = 0; i < flatArray.length; i++) {\\n        yield flatArray[i];\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let flatArray = arr.flat(Infinity);\\n    for (let i = 0; i < flatArray.length; i++) {\\n        yield flatArray[i];\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895707,
                "title": "yield-array-flat",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) We transfer the nested array into a flattened array\\n2) We iterate and yield the current index each time\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flattenedArr = arr.flat(Infinity) ;\\n    let i = 0 ;\\n    while(i < flattenedArr.length) yield flattenedArr[i++] ;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flattenedArr = arr.flat(Infinity) ;\\n    let i = 0 ;\\n    while(i < flattenedArr.length) yield flattenedArr[i++] ;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814962,
                "title": "the-js-way-flat-and-then-yield",
                "content": "# Complexity\\n- Time complexity: O(n), where n is the number of 2d arrays\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is size of flatArr\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flatArr = helper(arr);\\n\\n    let i = 0;\\n\\n    while(i < flatArr.length) {\\n        yield flatArr[i];\\n        i++;\\n    }\\n\\n    function helper(arr) {\\n        const newArr = [];\\n\\n        for(let i=0; i<arr.length; i++) {\\n            if(Array.isArray(arr[i])) {\\n                newArr.push(...helper(arr[i]));\\n            } else {\\n                newArr.push(arr[i]);\\n            }\\n        }\\n\\n        return newArr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flatArr = helper(arr);\\n\\n    let i = 0;\\n\\n    while(i < flatArr.length) {\\n        yield flatArr[i];\\n        i++;\\n    }\\n\\n    function helper(arr) {\\n        const newArr = [];\\n\\n        for(let i=0; i<arr.length; i++) {\\n            if(Array.isArray(arr[i])) {\\n                newArr.push(...helper(arr[i]));\\n            } else {\\n                newArr.push(arr[i]);\\n            }\\n        }\\n\\n        return newArr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799621,
                "title": "iterative-approach",
                "content": "# Intuition\\nTraverse the array using iterators\\n\\n# Approach\\nI used an iterative approach using a stack: \\n\\n- Keep iterating until done with each level of the stack\\n- Add array iterator to the stack when encountering a nested array\\n- Yield any values encountered\\n\\n# Complexity\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nconst inorderTraversal = function *(arr) {\\n    if (!arr.length) return;\\n\\n    const stack = [arr[Symbol.iterator]()];\\n    while (stack.length) {\\n        const cur = stack[stack.length-1].next();\\n        if (cur.done) {\\n            stack.pop();\\n            if (cur.value === undefined) continue;\\n        }\\n\\n        if (Array.isArray(cur.value)) {\\n            stack.push(cur.value[Symbol.iterator]());\\n        } else {\\n            yield cur.value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nconst inorderTraversal = function *(arr) {\\n    if (!arr.length) return;\\n\\n    const stack = [arr[Symbol.iterator]()];\\n    while (stack.length) {\\n        const cur = stack[stack.length-1].next();\\n        if (cur.done) {\\n            stack.pop();\\n            if (cur.value === undefined) continue;\\n        }\\n\\n        if (Array.isArray(cur.value)) {\\n            stack.push(cur.value[Symbol.iterator]());\\n        } else {\\n            yield cur.value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791275,
                "title": "fast-and-simple-beats-85",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n\\n    for ( const number of arr ) {\\n        yield number;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n\\n    for ( const number of arr ) {\\n        yield number;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737762,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const el of arr){\\n        if(Array.isArray(el)){\\n            yield *inorderTraversal(el); //delegate generator\\n        }else{\\n            yield el;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const el of arr){\\n        if(Array.isArray(el)){\\n            yield *inorderTraversal(el); //delegate generator\\n        }else{\\n            yield el;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737628,
                "title": "easy-javascript-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function*(arr) {\\n    let flatArray =  arr.flat(Infinity);\\n   for(ele of flatArray){\\n     yield ele;\\n   }\\n   \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function*(arr) {\\n    let flatArray =  arr.flat(Infinity);\\n   for(ele of flatArray){\\n     yield ele;\\n   }\\n   \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714405,
                "title": "simple-easy-one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray.flat() to flatten the nested array. maxNestingDepth <= Math.pow(10, 5)\\nThe flatten array is an iterable object.\\nThe yield* expression iterates over the operand and yields each value returned by it.\\n![\\u6355\\u83B7.JPG](https://assets.leetcode.com/users/images/f67e6d95-0935-4d13-8227-33b7b5e35666_1688412203.5342648.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Math.pow(10, 5))\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Math.pow(10, 5))\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3709610,
                "title": "generators-are-functions-that-can-be-exited-and-later-re-entered",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr=arr.flat(Infinity);\\n    while(arr.length){\\n        yield arr.shift();\\n        inorderTraversal(arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr=arr.flat(Infinity);\\n    while(arr.length){\\n        yield arr.shift();\\n        inorderTraversal(arr);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671001,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(arr.length === 0) return arr;\\n\\n    function* rec(arr) {\\n        for(var i = 0; i < arr.length; i++){\\n            if(Array.isArray(arr[i])) {\\n                yield * rec(arr[i]);\\n            }\\n            if(typeof arr[i] === \\'number\\' && Number.isInteger(arr[i])) {\\n                yield arr[i];\\n            }\\n        };\\n    }\\n    yield * rec(arr)\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(arr.length === 0) return arr;\\n\\n    function* rec(arr) {\\n        for(var i = 0; i < arr.length; i++){\\n            if(Array.isArray(arr[i])) {\\n                yield * rec(arr[i]);\\n            }\\n            if(typeof arr[i] === \\'number\\' && Number.isInteger(arr[i])) {\\n                yield arr[i];\\n            }\\n        };\\n    }\\n    yield * rec(arr)\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665110,
                "title": "easy-recursive-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i =0; i<arr.length; i++ ){\\n        if(Array.isArray(arr[i])){\\n             yield *inorderTraversal(arr[i]);\\n        }\\n        else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i =0; i<arr.length; i++ ){\\n        if(Array.isArray(arr[i])){\\n             yield *inorderTraversal(arr[i]);\\n        }\\n        else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3649791,
                "title": "1-liner-flat-hack",
                "content": "# Approach\\nJust use flat method to unpack all inner arrays, iterate it, enjoy it\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const el of arr.flat(Infinity)) yield el\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const el of arr.flat(Infinity)) yield el\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609994,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595963,
                "title": "traverse-it-recursively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we have an array such that some of elements are arrays too - we use recursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a loop to interate through array\\n2. check current element\\n    - if it is non-array element - yield it\\n    - otherwise, invoke itself with this element\\n    - keep invoking `next` until it is `.done`\\n    - before that `yield` each `value`\\n    \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (arr.length === 0) { return; }\\n    for (let key in arr) {\\n      if (Array.isArray(arr[key])) {\\n        const innerGen = inorderTraversal(arr[key]);\\n        let task;\\n        do {\\n          if (task) {\\n            yield task.value;\\n          }\\n          task = innerGen.next();\\n        } while (!task.done)\\n      } else {\\n        yield arr[key];\\n      }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (arr.length === 0) { return; }\\n    for (let key in arr) {\\n      if (Array.isArray(arr[key])) {\\n        const innerGen = inorderTraversal(arr[key]);\\n        let task;\\n        do {\\n          if (task) {\\n            yield task.value;\\n          }\\n          task = innerGen.next();\\n        } while (!task.done)\\n      } else {\\n        yield arr[key];\\n      }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595284,
                "title": "simple-inorder-yield",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594575,
                "title": "day-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item; // Yield integers encountered\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item; // Yield integers encountered\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594490,
                "title": "easy-beginner-friendly-day-30",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594429,
                "title": "javascript-faster-than-65-recursion",
                "content": "# Intuition\\nUse recursion.\\n\\n# Approach\\nUse recursion if the typeof arr is not a number. Otherwise return arr.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is a total number of integer items in arr.\\n\\n- Space complexity:\\n$$O(n)$$, where n is a total number of integer items in arr.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (typeof arr == \\'number\\'){\\n        yield arr;\\n    }\\n    else\\n    {\\n        for (let i = 0; i < arr.length; i++){\\n            yield * inorderTraversal(arr[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (typeof arr == \\'number\\'){\\n        yield arr;\\n    }\\n    else\\n    {\\n        for (let i = 0; i < arr.length; i++){\\n            yield * inorderTraversal(arr[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594067,
                "title": "typescript-recursion-solution",
                "content": "# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0, n = arr.length; i < n; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n        } else yield arr[i] as number;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0, n = arr.length; i < n; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n        } else yield arr[i] as number;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594035,
                "title": "my-js-solution-stepping-through-each-element-runtime-beats-96-27-memory-beats-99-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI step through each element without modifying the original arr parameter. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep through each element in the array until a child array is found. Then step through that array, and repeat. \\nI dont save the index of where I left of in the parent and instead use .indexOf the partent to find the childs index value and continue from there.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!arr.length){\\n        return [];\\n    }\\n\\n    let refScope = [arr];\\n    let refIndex = 0;\\n\\n    while(refScope.length){\\n        let ref = refScope[refScope.length - 1];\\n\\n        //if we\\'re finished with the current array remove it\\n        if(refIndex >= ref.length){\\n            //set index to the last spot of previous scope first.\\n            if(refScope.length >= 2){\\n                refIndex = refScope[refScope.length - 2].indexOf(ref) + 1;\\n            }\\n            refScope.pop();\\n            continue;\\n        }\\n\\n        let next = ref[refIndex];\\n\\n        //if the next is an array reset index and continue to start traversing the next array\\n        if(Array.isArray(next)){\\n            refScope.push(next);\\n            refIndex = 0;\\n            continue;\\n        }\\n\\n        //otherwise yield the next index\\n        refIndex++;\\n        yield next;\\n\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!arr.length){\\n        return [];\\n    }\\n\\n    let refScope = [arr];\\n    let refIndex = 0;\\n\\n    while(refScope.length){\\n        let ref = refScope[refScope.length - 1];\\n\\n        //if we\\'re finished with the current array remove it\\n        if(refIndex >= ref.length){\\n            //set index to the last spot of previous scope first.\\n            if(refScope.length >= 2){\\n                refIndex = refScope[refScope.length - 2].indexOf(ref) + 1;\\n            }\\n            refScope.pop();\\n            continue;\\n        }\\n\\n        let next = ref[refIndex];\\n\\n        //if the next is an array reset index and continue to start traversing the next array\\n        if(Array.isArray(next)){\\n            refScope.push(next);\\n            refIndex = 0;\\n            continue;\\n        }\\n\\n        //otherwise yield the next index\\n        refIndex++;\\n        yield next;\\n\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593779,
                "title": "java-script-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593733,
                "title": "extended-solution-for-better-understanding",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n\\n    // recursive function\\n    const deepExtract = function*(v) {\\n\\n        // if v is object type, starting to iterate over it and yielding \\n        // deepExtract instances to dig down to the integer value we\\'re searching\\n        if (typeof v === \\'object\\') {\\n            for (let i = 0; i < v.length; i++) {\\n                // return nested generator here\\n                yield * deepExtract(v[i]);\\n            }\\n        }\\n\\n        // if number value found, just yield it\\n        if (typeof v === \\'number\\') {\\n            yield v\\n        }\\n    }\\n\\n    \\n    for (let item of deepExtract(arr)) {\\n        yield item\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n\\n    // recursive function\\n    const deepExtract = function*(v) {\\n\\n        // if v is object type, starting to iterate over it and yielding \\n        // deepExtract instances to dig down to the integer value we\\'re searching\\n        if (typeof v === \\'object\\') {\\n            for (let i = 0; i < v.length; i++) {\\n                // return nested generator here\\n                yield * deepExtract(v[i]);\\n            }\\n        }\\n\\n        // if number value found, just yield it\\n        if (typeof v === \\'number\\') {\\n            yield v\\n        }\\n    }\\n\\n    \\n    for (let item of deepExtract(arr)) {\\n        yield item\\n    }\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3593631,
                "title": "simple-solution-eliminates-the-need-for-recursive-function-calls-and-avoid-unnecessary-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [...arr];\\n    while (stack.length > 0){\\n        const current = stack.shift();\\n\\n        if(Array.isArray(current)){\\n            stack.unshift(...current);\\n        }else if(Number.isInteger(current)){\\n            yield current;\\n        }\\n    } \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [...arr];\\n    while (stack.length > 0){\\n        const current = stack.shift();\\n\\n        if(Array.isArray(current)){\\n            stack.unshift(...current);\\n        }else if(Number.isInteger(current)){\\n            yield current;\\n        }\\n    } \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593557,
                "title": "simple-linear-solution-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem involves implementing an `inorderTraversal` generator function that takes an array as input and yields its elements in an `inorder traversal` order. The function should traverse the array, including nested arrays, and yield each encountered element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a generator function `inorderTraversal` that takes an array `arr` as its parameter.\\n2. Initialize a stack variable with an initial value of `[arr]`. The stack will be used to keep track of the elements to be processed.\\n3. Enter a while loop that continues until the stack is empty. This loop will be the core of the generator.\\n4. Inside the loop, retrieve the top element from the stack. This element represents the current item to be processed.\\n5. Check if `poped element` is not an array. If it is not an array, yield `poped element` using the `yield` keyword and continue to the next iteration of the loop.\\n6. If `element` is an array, iterate over its elements in reverse order using a for loop.\\n7. Inside the loop, push each element to the stack. This ensures that nested arrays are processed in the desired order.\\n8. Once the while loop finishes, the generator function will stop yielding values.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    let stack: MultidimensionalArray = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\n``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    let stack: MultidimensionalArray = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593552,
                "title": "simple-solution-easy-to-understand-o-n-time-o-d-space",
                "content": "# Complexity\\n- Time complexity: **O(n)** - where **n** is the total number of elements in the input array\\n- Space complexity: **O(d)** - where **d** is the maximum depth of the recursive calls\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593470,
                "title": "day-30-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; ++i) {\\n    Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i];\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; ++i) {\\n    Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i];\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593093,
                "title": "easy-javascript-solution",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length;i++){\\n        if(Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length;i++){\\n        if(Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593051,
                "title": "chatgpt-code-snippet",
                "content": "**Intuition:**\\nThe problem asks us to traverse a multi-dimensional array and yield integers in the same order as the inorder traversal. To solve this, we can use a generator function and perform a recursive inorder traversal of the array. \\n\\n**Approach:**\\n1. Define the generator function `inorderTraversal` that takes an array `arr` as the input parameter.\\n2. Iterate over each element `element` in the array `arr` using a `for...of` loop.\\n3. Check if the `element` is an array using the `Array.isArray()` method.\\n    - If it is an array, recursively call the `inorderTraversal` function with `element` as the argument using the `yield*` syntax. This allows us to yield integers in the same order as the inorder traversal of nested arrays.\\n    - If it is not an array (i.e., it\\'s an integer), yield the `element` using the `yield` keyword.\\n4. The generator function will yield integers in the same order as the inorder traversal of the input array.\\n\\n**Complexity Analysis:**\\nThe time complexity of the solution is O(N), where N is the total number of elements in the multi-dimensional array. We need to visit each element once during the inorder traversal.\\n\\nThe space complexity is O(D), where D is the maximum nesting depth of the array. This is the space required for the recursive call stack.\\n\\n**Code:**\\nHere is the complete code implementation:\\n\\n```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (let element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n```\\n\\n**Example Usage:**\\nHere is an example usage of the `inorderTraversal` function:\\n\\n```javascript\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // 1\\nconsole.log(gen.next().value); // 2\\nconsole.log(gen.next().value); // 3\\n```\\n\\nOutput:\\n```\\n1\\n2\\n3\\n```\\n\\nThe generator object correctly yields the integers in the same order as the inorder traversal of the input array.\\n\\nThis solution provides an efficient and concise way to traverse a multi-dimensional array and yield integers in the desired order using a generator function.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (let element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n```\n```javascript\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // 1\\nconsole.log(gen.next().value); // 2\\nconsole.log(gen.next().value); // 3\\n```\n```\\n1\\n2\\n3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592985,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe easy way\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      for (let i = 0; i < arr.length; i++) {\\n    const element = arr[i];\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element); // Recursively traverse nested arrays\\n    } else {\\n      yield element; // Yield integers\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      for (let i = 0; i < arr.length; i++) {\\n    const element = arr[i];\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element); // Recursively traverse nested arrays\\n    } else {\\n      yield element; // Yield integers\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592853,
                "title": "simple-recursive-stack-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            let gen = inorderTraversal(arr[i]);\\n            yield* gen;\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            let gen = inorderTraversal(arr[i]);\\n            yield* gen;\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592795,
                "title": "nested-generator-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should not flatten array, so let\\'s recursively call the function instead\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe would yield integer value, otherwise we would call recursively our function and yield it as an generator\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for(const num of arr) {\\n    if (Array.isArray(num)) {\\n      yield* inorderTraversal(num);\\n    } else {\\n      yield num;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for(const num of arr) {\\n    if (Array.isArray(num)) {\\n      yield* inorderTraversal(num);\\n    } else {\\n      yield num;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592683,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 135 ms, faster than 95.58% of JavaScript online submissions for Nested Array Generator.\\n# Memory Usage: 60.5 MB, less than 96.75% of JavaScript online submissions for Nested Array Generator.\\n\\tvar inorderTraversal = function*(arr) {\\n\\n\\t\\tconst stack = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tcurrent_array = stack.pop();\\n\\n\\t\\t\\tif(Array.isArray(current_array) == false){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 122 ms, faster than 98.19% of TypeScript online submissions for Nested Array Generator.\\n# Memory Usage: 62.6 MB, less than 94.88% of TypeScript online submissions for Nested Array Generator.\\n\\ttype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\tfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n\\t\\tconst stack : MultidimensionalArray[] = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tconst current_array = stack.pop();\\n\\n\\t\\t\\tif(!Array.isArray(current_array)){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index] as MultidimensionalArray);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Stack"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 135 ms, faster than 95.58% of JavaScript online submissions for Nested Array Generator.\\n# Memory Usage: 60.5 MB, less than 96.75% of JavaScript online submissions for Nested Array Generator.\\n\\tvar inorderTraversal = function*(arr) {\\n\\n\\t\\tconst stack = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tcurrent_array = stack.pop();\\n\\n\\t\\t\\tif(Array.isArray(current_array) == false){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 122 ms, faster than 98.19% of TypeScript online submissions for Nested Array Generator.\\n# Memory Usage: 62.6 MB, less than 94.88% of TypeScript online submissions for Nested Array Generator.\\n\\ttype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\tfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n\\t\\tconst stack : MultidimensionalArray[] = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tconst current_array = stack.pop();\\n\\n\\t\\t\\tif(!Array.isArray(current_array)){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index] as MultidimensionalArray);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3592629,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\\n``` javascript []\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\n``` javascript []\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592609,
                "title": "easy-approach-flat-javascript",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592583,
                "title": "nested-generator-function-or-using-flat-array-method",
                "content": "# Using Nested generator Function\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let i = 0;\\n  while (i < arr.length) {\\n    if (typeof arr[i] === \\'object\\') {\\n      yield* inorderTraversal((arr[i] as MultidimensionalArray))\\n    } else {\\n      yield arr[i] as number\\n    }\\n    i++\\n  }\\n\\n};\\n```\\n\\n\\n# Using flat array method\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const newArr:number[] = arr.flat(Infinity);\\n    let i=0;\\n    while(i<newArr.length){\\n        yield newArr[i++]\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let i = 0;\\n  while (i < arr.length) {\\n    if (typeof arr[i] === \\'object\\') {\\n      yield* inorderTraversal((arr[i] as MultidimensionalArray))\\n    } else {\\n      yield arr[i] as number\\n    }\\n    i++\\n  }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592554,
                "title": "easy-js-solution-runtime-beats-90-memory-beats-70",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    const maxNestingDepth = 100000;\\n    const flatArr = arr.flat(maxNestingDepth);\\n\\n    for (const element of flatArr) {\\n        yield element;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    const maxNestingDepth = 100000;\\n    const flatArr = arr.flat(maxNestingDepth);\\n\\n    for (const element of flatArr) {\\n        yield element;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592511,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/9e6c248f-0ca1-47b4-ac1a-627f16cbf19e_1685786482.2844036.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592431,
                "title": "using-typeof-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem description gives all the hints itself: If it\\'s an array, recursively break it down, otherwise yield the item \\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr){\\n        if (typeof item == \"number\"){\\n            yield item;\\n        }\\n        else {\\n            yield* inorderTraversal(item);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr){\\n        if (typeof item == \"number\"){\\n            yield item;\\n        }\\n        else {\\n            yield* inorderTraversal(item);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592381,
                "title": "typescript-solution",
                "content": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number> {\\n    if (!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for (let element of arr) {\\n        yield* inorderTraversal(element as MultidimensionalArray)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number> {\\n    if (!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for (let element of arr) {\\n        yield* inorderTraversal(element as MultidimensionalArray)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592380,
                "title": "one-liner-with-explanation",
                "content": "# Intuition\\nWe can use the concept of recursion to yield the values in deeper levels. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe iterate over the array, and for each value, if the value is an Array, we yield it\\'s value using the `yeild*` syntax. The `*` here makes it yeild values from a generator. This same kind of task can be achieved less abstactly without using the `yield*` syntax.\\n\\nAn approach of doing the same without `yeild*` syntax is as below.\\n\\n```js\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr){\\n        if(val instanceof Array){\\n            const gen = inorderTraversal(val);\\n            let nxt = gen.next()\\n            while(!nxt.done){\\n                yield nxt.value\\n                nxt = gen.next()\\n            }\\n        }\\n        else yield val;\\n    }\\n};\\n```\\n\\nThis works similar to how `yeild*` would work.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n\\n> One Liner Solution\\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr) (val instanceof Array) ? yield* inorderTraversal(val) : yield val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr){\\n        if(val instanceof Array){\\n            const gen = inorderTraversal(val);\\n            let nxt = gen.next()\\n            while(!nxt.done){\\n                yield nxt.value\\n                nxt = gen.next()\\n            }\\n        }\\n        else yield val;\\n    }\\n};\\n```\n```\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr) (val instanceof Array) ? yield* inorderTraversal(val) : yield val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592378,
                "title": "yieid-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let ele of arr) {\\n        if(Array.isArray(ele)) {\\n            yield* inorderTraversal(ele);\\n        } else {\\n            yield ele;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let ele of arr) {\\n        if(Array.isArray(ele)) {\\n            yield* inorderTraversal(ele);\\n        } else {\\n            yield ele;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592350,
                "title": "typescript-2-liner-runtime-70-memory-60",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf it is not an array, use the `yield` keyword to yield the value, if it is use the `yield*` to yield a new generator function.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, since function stack is created everytime it calls a new function\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const v of arr) {\\n        if (Array.isArray(v)) yield* inorderTraversal(v);\\n        else yield v;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```TypeScript\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const v of arr) {\\n        if (Array.isArray(v)) yield* inorderTraversal(v);\\n        else yield v;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592332,
                "title": "day30-simplest-easy-js-beginner-solution",
                "content": "# Intuition\\n\\n**Inorder** :\\n```\\n The inorder traversal means we will travel in the form of\\n        left node   -> node  -> right node\\n\\nhere left node will contain the nested array elements.\\nnode : is the current array element\\nright node : is the element after the  current array element\\nor the elements situated in right of the current element in array,\\n\\n```\\n\\n\\n**Generator Function** :\\n```\\nThe generator function returns a value when an instnce of function is \\ncalled with .next();\\n\\nThe generator function is denoted by *(astrix)  after \\nthe function name\\n\\n        function* CallFunc(){\\n            const val = 10\\n            yield val;\\n        }\\n\\n\\nThe generator function will return a value when it is called \\n\\n        const gen = CallFunc() ;\\n\\n        console.log(gen.next().value)\\n \\nthis will return a value of the gen which is the instant of the \\ngenerator function . \\n```\\n# Approach\\nThe appraoch for the question is simple .\\n- we will traverse the array and for each element we will check \\nis the element we are on is an instance of array or not\\n```\\nfor(const node of arr){\\n        ...function definition \\n}\\n```\\n- if this is the instance of array we will be calling inorder function recursively for that element\\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n}\\n```\\n\\n- else we will yield the current element.\\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n         else yield node\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ n is the no of Elements of array , and we will travel them only once.\\n\\n- Space complexity:\\n $$O(d)$$ d is the depth of nested array , for max d recursive calls will be made .\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    for(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n        else yield node\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n The inorder traversal means we will travel in the form of\\n        left node   -> node  -> right node\\n\\nhere left node will contain the nested array elements.\\nnode : is the current array element\\nright node : is the element after the  current array element\\nor the elements situated in right of the current element in array,\\n\\n```\n```\\nThe generator function returns a value when an instnce of function is \\ncalled with .next();\\n\\nThe generator function is denoted by *(astrix)  after \\nthe function name\\n\\n        function* CallFunc(){\\n            const val = 10\\n            yield val;\\n        }\\n\\n\\nThe generator function will return a value when it is called \\n\\n        const gen = CallFunc() ;\\n\\n        console.log(gen.next().value)\\n \\nthis will return a value of the gen which is the instant of the \\ngenerator function . \\n```\n```\\nfor(const node of arr){\\n        ...function definition \\n}\\n```\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n}\\n```\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n         else yield node\\n}\\n```\n```\\nvar inorderTraversal = function*(arr) {\\n    for(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n        else yield node\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592312,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Generator:**\\n- It is created using generator functions, which are declared using `function*` or `function *`.\\n- It\\'s an object which can produce a sequence of values and can be iterated over like an array, also.\\n- In precise terms, it\\'s an object which implements the iterator and the iterable protocols.\\n- As it is a iterator, we can perform following operations:\\n\\n```\\nconst generator = ... // A generator\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\n```\\n\\n**yield:**\\n- In a generator function, the values that are going to be returned when the *next function* is called on it, we use the `yield` keyword.\\n\\n**yield\\\\*:**\\n- Used to yield the values of an other generator, inside our generator. \\n- Like in case of fibonacci sequence using recursion:\\n```\\nfunction* fibonacciGenerator(x = 0, y = 1) {\\n  yield x;   \\n  yield* fibonacciGenerator(y, y + x);\\n}\\n```\\n\\n\\n# Code\\n``` javaScript []\\nvar inorderTraversal = function*(arr) {\\n\\n    for(let i = 0; i < arr.length; ++i){\\n        if(Array.isArray(arr[i]))\\n            yield* inorderTraversal(arr[i]);\\n        else\\n            yield arr[i];\\n    }\\n    \\n};\\n```\\n***\\uD83D\\uDC47\\uD83C\\uDFFC Do Share your Opinion, by voting.***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst generator = ... // A generator\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\n```\n```\\nfunction* fibonacciGenerator(x = 0, y = 1) {\\n  yield x;   \\n  yield* fibonacciGenerator(y, y + x);\\n}\\n```\n``` javaScript []\\nvar inorderTraversal = function*(arr) {\\n\\n    for(let i = 0; i < arr.length; ++i){\\n        if(Array.isArray(arr[i]))\\n            yield* inorderTraversal(arr[i]);\\n        else\\n            yield arr[i];\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592291,
                "title": "self-explanatory-easy-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for ( const a of arr){\\n        if(Array.isArray(a)) yield* inorderTraversal(a);\\n        else yield a;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for ( const a of arr){\\n        if(Array.isArray(a)) yield* inorderTraversal(a);\\n        else yield a;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592290,
                "title": "simple-one-line-code",
                "content": "```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592175,
                "title": "beginner-friendly-js-solution",
                "content": "> **DISCLAIMER: ** I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nNeed to flatten the array first \\uD83E\\uDD14\\uD83D\\uDE00\\n\\n# Approach\\nCreate a utility function which will take the input array and returns\\nthe flatten array. Once the Array is flattened we can now then loop through it and yield each value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/6ffe09d8-8f50-4272-bf93-dbfabe643c6b_1685779356.3141398.png)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\n// Function to flaten the input array\\nfunction flattenArray(arr){\\nlet finalArray = [];\\nfor(let i=0; i <=arr.length-1; i++){\\n  if(Array.isArray(arr[i])){\\n    finalArray.push(...flattenArray(arr[i]))\\n  }else{\\n    finalArray.push(arr[i])\\n  }\\n}\\nreturn finalArray;\\n}\\n\\nvar inorderTraversal = function*(arr) {\\n\\n  flatArray = flattenArray(arr);\\n  for(let i= 0; i <= flatArray.length-1; i++){\\n       yield flatArray[i];\\n  }\\n \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\n// Function to flaten the input array\\nfunction flattenArray(arr){\\nlet finalArray = [];\\nfor(let i=0; i <=arr.length-1; i++){\\n  if(Array.isArray(arr[i])){\\n    finalArray.push(...flattenArray(arr[i]))\\n  }else{\\n    finalArray.push(arr[i])\\n  }\\n}\\nreturn finalArray;\\n}\\n\\nvar inorderTraversal = function*(arr) {\\n\\n  flatArray = flattenArray(arr);\\n  for(let i= 0; i <= flatArray.length-1; i++){\\n       yield flatArray[i];\\n  }\\n \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592088,
                "title": "easy-solution-o-n",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const e of arr){\\n        if(Array.isArray(e)) yield* inorderTraversal(e);\\n        else yield e;\\n    };\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const e of arr){\\n        if(Array.isArray(e)) yield* inorderTraversal(e);\\n        else yield e;\\n    };\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592069,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592013,
                "title": "day-30-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591960,
                "title": "js-easy-solution-day-30",
                "content": "var inorderTraversal = function*(arr) {\\n    for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  } \\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var inorderTraversal = function*(arr) {\\n    for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  } \\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3591926,
                "title": "js-recrusion-time-190ms-72-space-74mb-49",
                "content": "# Approach\\nWe recursively traverse the nested arrays and use `yield*` to delegate the generator. When we reach a leaf node, we then properly yield.\\n\\n# Complexity\\n- Time complexity:\\nO(n) *, where n is the flattened length of the array*\\n\\n- Space complexity:\\nO(d) *, where d is the maximum depth of the array*\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // recrusively traverse array\\n    if(Array.isArray(arr)) {\\n        for (let i = 0; i < arr.length; i++) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n    }\\n    // yield if leaf node reached\\n    else yield arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // recrusively traverse array\\n    if(Array.isArray(arr)) {\\n        for (let i = 0; i < arr.length; i++) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n    }\\n    // yield if leaf node reached\\n    else yield arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591880,
                "title": "day-30-easy-solution-in-js",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        else yield arr[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        else yield arr[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591830,
                "title": "best-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n    for(let i= 0;i <arr.length;i++){\\n       yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n    for(let i= 0;i <arr.length;i++){\\n       yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591767,
                "title": "easy-solution-2649-nested-array-generator-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }\\n        else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }\\n        else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591752,
                "title": "true-generator-without-array-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arrays) {\\n    for (const arr of arrays) {\\n        if (typeof arr !== \\'object\\')\\n            yield arr;\\n        else {\\n            const flatterArr = inorderTraversal(arr);\\n            for (const val of flatterArr)\\n                yield val;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arrays) {\\n    for (const arr of arrays) {\\n        if (typeof arr !== \\'object\\')\\n            yield arr;\\n        else {\\n            const flatterArr = inorderTraversal(arr);\\n            for (const val of flatterArr)\\n                yield val;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591639,
                "title": "nested-array-generator-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe inorderTraversal function uses a generator (function*) to yield integers in the same order as an inorder traversal of the multi-dimensional array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const n of arr) {\\n        if (Array.isArray(n)) {\\n            yield* inorderTraversal(n);\\n        } else {\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const n of arr) {\\n        if (Array.isArray(n)) {\\n            yield* inorderTraversal(n);\\n        } else {\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591547,
                "title": "simple-single-line-solution-using-flat-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFlat Method\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nthe time complexity of the flat() method is O(N), where N is the total number of elements in the array. Since the generator function yields each element of the flattened array once, the overall time complexity of the function is also O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the flat() method is also O(N), since it creates a new flattened array. The generator function does not create any new data structures, so the overall space complexity is also O(N).\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591528,
                "title": "easy-solution-using-recursive-generators",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let elem of arr) {\\n        if(elem instanceof Array) yield * inorderTraversal(elem);\\n        else yield elem;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let elem of arr) {\\n        if(elem instanceof Array) yield * inorderTraversal(elem);\\n        else yield elem;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591507,
                "title": "javascript-two-liner-begineer-friendly-with-explanation",
                "content": "# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity); // Make flat array\\n    for(x of arr) yield x; // Return each element\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity); // Make flat array\\n    for(x of arr) yield x; // Return each element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591454,
                "title": "simple-explanation-for-beginners-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, let\\'s think about how we would traverse the multi-dimensional array and yield the integers in the same order as an inorder traversal. We can start by using a generator function, which allows us to iterate over the array and process its elements one by one. As we iterate through the array, we\\'ll need to handle two cases: encountering an integer or encountering another sub-array.\\n\\nIf we encounter an integer, we can simply yield it right away. However, if we encounter a sub-array, we\\'ll need to go deeper and recursively apply the same process to that sub-array. This ensures that we explore all levels of the multi-dimensional array and yield integers in the desired order. By using this recursive approach, we can effectively perform an inorder traversal and yield the integers as we encounter them.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a generator function, let\\'s call it inorderTraversal, that takes the multi-dimensional array as input.\\n2. In the generator function, iterate over the elements of the array using a loop.\\n3. For each element encountered: \\n    * If the element is an integer, yield it using the yield keyword.\\n    * If the element is a sub-array, recursively call the inorderTraversal function on that sub-array.\\n4. By using recursion, we can traverse the multi-dimensional array and yield the integers in the same order as an inorder traversal.\\n5. The generator function will continue to yield integers until all elements have been processed.\\n6. Finally, we can create an instance of the generator function with the input array and use the next() method to retrieve the next yielded integer in the inorder traversal.\\n\\nThis approach allows us to traverse the multi-dimensional array in a depth-first manner, ensuring that integers are yielded in the desired order.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    The time complexity of the solution is O(N).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    The space complexity is O(M).\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr \\n * @return {Generator} \\n */\\nvar inorderTraversal = function*(arr) {\\n  // Iterate over each item in the array\\n  for (const item of arr) {\\n    // Check if the item is an array\\n    if (Array.isArray(item)) {\\n      // If it is an array, recursively call the inorderTraversal function on the sub-array\\n      yield* inorderTraversal(item);\\n    } \\n    else {\\n      // If it is an integer, yield the integer\\n      yield item;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * console.log(gen.next().value); // 1\\n * console.log(gen.next().value); // 2\\n * console.log(gen.next().value); // 3\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr \\n * @return {Generator} \\n */\\nvar inorderTraversal = function*(arr) {\\n  // Iterate over each item in the array\\n  for (const item of arr) {\\n    // Check if the item is an array\\n    if (Array.isArray(item)) {\\n      // If it is an array, recursively call the inorderTraversal function on the sub-array\\n      yield* inorderTraversal(item);\\n    } \\n    else {\\n      // If it is an integer, yield the integer\\n      yield item;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * console.log(gen.next().value); // 1\\n * console.log(gen.next().value); // 2\\n * console.log(gen.next().value); // 3\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591446,
                "title": "typescript-easy-to-understand-beats-98-in-space-complexity",
                "content": "# Intuition\\n1. I would like to try the non-recursive solution.\\n2. A stack is needed for the current state.\\n3. Try to handle the array one layer by one layer\\n4. If we see an array, put the current one to the stack\\n\\n# Approach\\n1. Prepare stack and use the input `arr` as the `currentArr`.\\n2. The finding target is: the first item is a number not an array.\\n3. If the first item is array:\\n   1. Put the  `currentArr` into the stack and use the `first` as the `currentArr`.\\n4. Check if we already run out of all items in the `currentArr`. If yes, we need to pop an non-empty array from the stack.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const stack: MultidimensionalArray[] = [];\\n    let currentArr = arr;\\n    while (currentArr.length > 0) {\\n        // take out the first item\\n        const first = currentArr.shift();\\n        // check the type of first item\\n        if (!Array.isArray(first)) {\\n            yield first as number;\\n        } else {\\n            // we need to push the current array to the stack and use the first item as the current array.\\n            stack.push(currentArr);\\n            currentArr = first;\\n        }\\n        // pop the array if we have arrays in the stack.\\n        while (stack.length > 0 && currentArr.length === 0) {\\n            currentArr = stack.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\n![Screen Shot 2023-06-03 at 12.20.46 PM.png](https://assets.leetcode.com/users/images/26e05922-b4be-4e4d-b004-37db9f363a47_1685766403.7755122.png)\\n\\n",
                "solutionTags": [
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const stack: MultidimensionalArray[] = [];\\n    let currentArr = arr;\\n    while (currentArr.length > 0) {\\n        // take out the first item\\n        const first = currentArr.shift();\\n        // check the type of first item\\n        if (!Array.isArray(first)) {\\n            yield first as number;\\n        } else {\\n            // we need to push the current array to the stack and use the first item as the current array.\\n            stack.push(currentArr);\\n            currentArr = first;\\n        }\\n        // pop the array if we have arrays in the stack.\\n        while (stack.length > 0 && currentArr.length === 0) {\\n            currentArr = stack.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591415,
                "title": "easy-solution-one-line-code-85-beats",
                "content": "# Intuition\\nIt\\'s important to note that the flat() method used in the approach has a time complexity of O(n), where n is the total number of elements in the array. So, if the input array is deeply nested, the overall time complexity could be affected by the flat() operation.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach you provided is a generator function called inorderTraversal, which aims to traverse an array in an inorder manner. It uses the yield keyword to generate each element of the array during iteration.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr.flat(Infinity)) yield i;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr.flat(Infinity)) yield i;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591413,
                "title": "javascript-easy-to-understand-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const o of arr) {\\n        if (Array.isArray(o)) {\\n            yield* inorderTraversal(o)\\n        } else {\\n            yield o\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const o of arr) {\\n        if (Array.isArray(o)) {\\n            yield* inorderTraversal(o)\\n        } else {\\n            yield o\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591411,
                "title": "js-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n        if (Array.isArray(item)) yield* inorderTraversal(item);\\n        else yield item;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n        if (Array.isArray(item)) yield* inorderTraversal(item);\\n        else yield item;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591405,
                "title": "day-30-30-days-of-lc-javascript-challenge-let-s-discuss",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\nThis code defines a function called inorderTraversal that takes an array (arr) as input and returns a generator object.\\n\\nA generator is a special type of function in JavaScript that allows you to define an iterative algorithm by pausing and resuming execution at specific points. Each time the generator\\'s yield keyword is encountered, it returns a value and pauses execution until the next iteration.\\n\\nThe inorderTraversal function uses a recursive approach to perform an inorder traversal of a nested array. In inorder traversal, the elements of a binary tree (in this case, represented by the nested array) are visited in the order of left subtree, root, and right subtree.\\n\\n**Here\\'s a step-by-step explanation of how the code works:**\\n\\n1. The inorderTraversal function is defined with a single parameter (arr), which is the input array.\\n\\n2. Inside the function, a for loop is used to iterate over each element of the arr array.\\n\\n3. Within the loop, an if statement checks if the current element (arr[i]) is an array using the Array.isArray function. If it is an array, it means it represents a subtree, so the yield* keyword is used to delegate the traversal of that subtree to another recursive call of the inorderTraversal function. This allows the function to handle nested arrays and traverse them in an inorder manner.\\n\\n4. If the current element is not an array (i.e., it is a leaf node), the else block is executed. In this case, the yield keyword is used to return the value of the leaf node.\\n\\n5. After the loop finishes, the function execution is complete, and the generator object is returned.\\n\\nTo use the **inorderTraversal** function, you can create an instance of the generator by calling it with an array argument. The returned generator object can then be used to iterate over the values of the array in an inorder traversal.\\n\\nIn the example code at the bottom, the inorderTraversal function is called with the array [1, [2, 3]], and the returned generator object is stored in the variable gen.\\n\\nTo access the values returned by the generator, you can use the next() method on the generator object. Each call to gen.next().value will return the next value in the inorder traversal sequence. In this case, the values returned will be 1, 2, and 3, respectively, as specified in the comments.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591394,
                "title": "recursive-inorder-traversal-generator-for-multi-dimensional-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to perform an inorder traversal on a multi-dimensional array and yield the integers encountered in the same order. We can approach this problem recursively by iterating over the elements of the array. If an element is an array, I recursively call the `inorderTraversal` function on it. If an element is an integer, I yield it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define the `inorderTraversal` function that takes an array as input and returns a generator object.\\n2. Iterate over each element of the array using a for loop.\\n3. If the current element is an array, recursively cakk the `inorderTraversal` function on it using the yield* syntax.\\n4. If the current element is an integer, yield it using the yield keyword.\\n5. Test the function by creating an array and initializing the generator object. Use the `next()` method on the generator to retrieve the next yielded value.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the total number of integers in the multi-dimensional array. I need to iterate over each element of the array to yield the integers.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m), where m is the maximum nesting depth of the multi-dimensional array. The recursive function calls and generator object require additional space proportional to the nesting depth of the array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591365,
                "title": "nested-array-generator-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr - The input array.\\n * @return {Generator} - A generator for inorder traversal of the array.\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      yield* inorderTraversal(arr[i]); // Recursively yield elements of nested arrays\\n    } else {\\n      yield arr[i]; // Yield individual elements\\n    }\\n  }\\n};\\n\\n// Example usage:\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // Output: 1\\nconsole.log(gen.next().value); // Output: 2\\nconsole.log(gen.next().value); // Output: 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr - The input array.\\n * @return {Generator} - A generator for inorder traversal of the array.\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      yield* inorderTraversal(arr[i]); // Recursively yield elements of nested arrays\\n    } else {\\n      yield arr[i]; // Yield individual elements\\n    }\\n  }\\n};\\n\\n// Example usage:\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // Output: 1\\nconsole.log(gen.next().value); // Output: 2\\nconsole.log(gen.next().value); // Output: 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591308,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction func(arr){\\n    let newArr = [];\\n    let i = 0;\\n    while(i<arr.length){\\n        if(Array.isArray(arr[i])){\\n            newArr.push(...func(arr[i]));\\n        }\\n        else{\\n            newArr.push(arr[i]);\\n        }\\n        i++;\\n    }\\n    return newArr;\\n} \\nvar inorderTraversal = function*(arr) {\\n    newArr = func(arr);\\n    // console.log(newArr);\\n    let i = 0;\\n    while(i<newArr.length){\\n        yield newArr[i];\\n        i++;\\n    }\\n};\\n/*\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n*/\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction func(arr){\\n    let newArr = [];\\n    let i = 0;\\n    while(i<arr.length){\\n        if(Array.isArray(arr[i])){\\n            newArr.push(...func(arr[i]));\\n        }\\n        else{\\n            newArr.push(arr[i]);\\n        }\\n        i++;\\n    }\\n    return newArr;\\n} \\nvar inorderTraversal = function*(arr) {\\n    newArr = func(arr);\\n    // console.log(newArr);\\n    let i = 0;\\n    while(i<newArr.length){\\n        yield newArr[i];\\n        i++;\\n    }\\n};\\n/*\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n*/\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591301,
                "title": "easy-solution-with-flattened-array",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // .flat(Infinity) will flatten an array of any depth\\n    // .reverse() allows us to use pop() to get the next value instead of .unshift() for a performance boost\\n    const flatArray = arr.flat(Infinity).reverse();\\n\\n    // As long as flatArray has values, we can keep yielding results\\n    while(flatArray.length) {\\n        yield flatArray.pop();\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // .flat(Infinity) will flatten an array of any depth\\n    // .reverse() allows us to use pop() to get the next value instead of .unshift() for a performance boost\\n    const flatArray = arr.flat(Infinity).reverse();\\n\\n    // As long as flatArray has values, we can keep yielding results\\n    while(flatArray.length) {\\n        yield flatArray.pop();\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591282,
                "title": "typescript-solution-using-recursive-generator-call",
                "content": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (let i = 0 ; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const gen = inorderTraversal(arr[i] as MultidimensionalArray);\\n      while (true) {\\n        const next = gen.next();\\n        if (next.done) break;\\n        yield next!.value as number;\\n      }\\n    }\\n    else yield arr[i] as number;\\n  }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (let i = 0 ; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const gen = inorderTraversal(arr[i] as MultidimensionalArray);\\n      while (true) {\\n        const next = gen.next();\\n        if (next.done) break;\\n        yield next!.value as number;\\n      }\\n    }\\n    else yield arr[i] as number;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591266,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }\\n        else{\\n            yield element;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }\\n        else{\\n            yield element;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591182,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(Array.isArray(arr)){\\n        for(const x of arr){\\n            yield* inorderTraversal(x);\\n        }\\n    }\\n    else{\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(Array.isArray(arr)){\\n        for(const x of arr){\\n            yield* inorderTraversal(x);\\n        }\\n    }\\n    else{\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591171,
                "title": "javascript-stack-but-different",
                "content": "# Intuition\\nWhen we finish processing a sub-array, we need to know which array to return to (the parent array), and the index where the sub-array was found. With that we can continue processing the parent.\\n\\nIf we use an object we can store the index and the array. Since the array property will just be a reference/pointer to the array we can avoid any copying of the data.\\n\\nSub-arrays can be nested so we need to store the parent information in a Last In First Out (LIFO) data structure, like a stack.\\n\\n# Approach\\n- Create an object that represents the array we are currently processing and which index we are on. \\n- Use a standard array for our stack.\\n- Continue processing as long as we are not at the end of the current array, or if we are but there is another array waiting to be popped off the stack.\\n- If we are at the end of the current array, pop the stack to return to the parent array.\\n- If the current element is an array, push the current array on to the stack and then set the new current array to be this sub-array element.\\n- If the current element is not an array just yield it.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let curArr = {array: arr, index: 0};\\n    let stack = [];\\n\\n    while (curArr.index < curArr.array.length || stack.length > 0){\\n        if (curArr.index === curArr.array.length) {\\n            curArr = stack.pop();\\n            curArr.index++;\\n            continue;            \\n        }\\n        if (Array.isArray(curArr.array[curArr.index])){\\n            stack.push(curArr);\\n            curArr = {array: curArr.array[curArr.index], index: 0};\\n        }\\n        else {\\n            yield curArr.array[curArr.index];\\n            curArr.index++;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let curArr = {array: arr, index: 0};\\n    let stack = [];\\n\\n    while (curArr.index < curArr.array.length || stack.length > 0){\\n        if (curArr.index === curArr.array.length) {\\n            curArr = stack.pop();\\n            curArr.index++;\\n            continue;            \\n        }\\n        if (Array.isArray(curArr.array[curArr.index])){\\n            stack.push(curArr);\\n            curArr = {array: curArr.array[curArr.index], index: 0};\\n        }\\n        else {\\n            yield curArr.array[curArr.index];\\n            curArr.index++;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591148,
                "title": "easy-approach-flatten-then-loop",
                "content": "# Intuition\\n- Flatten the array first, then loop through the new flatten array\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nconst flattenArr = (arr) => {\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++) {\\n        if(Array.isArray(arr[i])) {\\n            res = [...res, ...flattenArr(arr[i])]\\n        }\\n        else res.push(arr[i])\\n    }\\n    return res\\n}\\n    \\nvar inorderTraversal = function*(arr) {\\n    const newArr = flattenArr(arr)\\n    for(let i = 0; i < newArr.length; i++) {\\n        yield(newArr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nconst flattenArr = (arr) => {\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++) {\\n        if(Array.isArray(arr[i])) {\\n            res = [...res, ...flattenArr(arr[i])]\\n        }\\n        else res.push(arr[i])\\n    }\\n    return res\\n}\\n    \\nvar inorderTraversal = function*(arr) {\\n    const newArr = flattenArr(arr)\\n    for(let i = 0; i < newArr.length; i++) {\\n        yield(newArr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591122,
                "title": "javascript-and-typescript-with-explanation",
                "content": "\\n- The code provided defines a type MultidimensionalArray as an array that can contain either numbers or nested arrays of numbers. The inorderTraversal function is a generator function that takes a MultidimensionalArray as input and yields its elements in an inorder traversal.\\n- The function takes an array arr of type **MultidimensionalArray** as input.\\n- The array arr is flattened using the $$flat$$ method with **Infinity** depth. This converts any nested arrays into a single-dimensional array.\\n- A variable n is initialized to 0, which will be used as an index to iterate over the elements of the flattened array.\\n- The generator function enters a while loop that continues as long as **temp[n] or temp[n] == 0** is truthy. This allows the function to handle elements that are explicitly set to 0.\\n- Within each iteration of the loop, the current element **temp[n]** is yielded using the $$yield$$ keyword.\\n- The index **n** is incremented to move to the next element in the array.\\n- The loop continues until there are no more elements in the array, at which point the generator function terminates.\\n\\n`typescript`\\n```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\n---\\n- The $$inorderTraversal$$ function takes an array $$arr$$ as input.\\n- Inside the function, a **for...of** loop is used to iterate over each element of the arr array.\\n- For each element, it checks if it is an array using the **Array.isArray** function.\\n- If the element is an array, it recursively calls the $$inorderTraversal$$ function passing the nested array as the argument, using the $$yield*$$ syntax to yield the values from the recursive generator.\\n- If the element is not an array, it is a leaf node, and the element itself is yielded using the $$yield$$ keyword.\\n- The generator function continues iterating over the elements of the **arr** array, yielding values in an inorder traversal.\\n- When there are no more elements to traverse, the generator function terminates.\\n\\n`Javascript`\\n```javascript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\n```javascript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591095,
                "title": "javascript-yeild",
                "content": "The yield* expression is used to delegate to another generator or iterable object.\\nThe yield* expression iterates over the operand and yields each value returned by it.\\nyield* is a way to yield all values from another generator (or any iterable) in the middle of your generator. \\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++){\\n        if (Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        }else{\\n            yield arr[i]\\n        }\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The yield* expression is used to delegate to another generator or iterable object.\\nThe yield* expression iterates over the operand and yields each value returned by it.\\nyield* is a way to yield all values from another generator (or any iterable) in the middle of your generator. \\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++){\\n        if (Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        }else{\\n            yield arr[i]\\n        }\\n    }\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3591085,
                "title": "stack-approach",
                "content": "In-order traversal is a method used to traverse or visit each node in a binary tree or, in this case, a multi-dimensional array, in a left to right order.\\n\\nFor a multi-dimensional array, in-order traversal can be understood as visiting each element of the array in a left-to-right manner\\n\\nThe in-order traversal of the multi-dimensional array means visiting each element of the array, including both integers and sub-arrays, from left to right and top to bottom, yielding any encountered integers and applying the in-order traversal to any encountered sub-arrays.\\n\\n### Iterative approach\\n\\nUse a `stack` to keep track of the elements of the multi-dimensional array that we need to process. We start by pushing the root array onto the stack.\\n\\nDuring each iteration of the **`while`** loop, we pop an element from the stack. \\n\\n- If the popped element is an integer, we yield it.\\n- If it is an array, we iterate over its elements in reverse order and push them onto the stack. This ensures that we process the elements in the same order as an `inorder` traversal.\\n\\nThe loop continues until the stack is empty, yielding integers in the desired order.\\n\\n### Time Complexity: O(n + m)\\n\\n### Space Complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while(stack.length) {\\n        const current = stack.pop()\\n        if(!Array.isArray(current)){\\n            yield current\\n        }else{\\n            for(let i = current.length - 1; i >= 0; i--) stack.push(current[i])\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while(stack.length) {\\n        const current = stack.pop()\\n        if(!Array.isArray(current)){\\n            yield current\\n        }else{\\n            for(let i = current.length - 1; i >= 0; i--) stack.push(current[i])\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591084,
                "title": "2649-nested-array-generator-level-up-your-js-skills-day-30-with-2-different-approach",
                "content": "# **Approach 1: Recursive Solution**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe nested arrays can be processed and their elements retrieved by employing a recursive generator.\\n# Algorithm\\n- Non-array elements are treated as integers, and the generator function yields them to the caller.\\n- The yield statement in the generator function allows pausing its execution and providing the yielded value to the caller.\\n- Resuming the generator function from where it left off continues the loop and further traverses the array.\\n- When encountering a nested array, a for loop iterates over its elements using the index ```i```.\\n- To handle the nested array condition, the generator function recursively invokes ```yield* inorderTraversal(arr[i])```.\\n- The recursive call ensures that the nested array is also traversed in an inorder manner.\\n- Using ```yield*``` delegates to another Generator (recursive call) and returns the value when it is closed.\\n- The generator yields integers in the order they are encountered during the traversal.\\n\\n# Implementation:\\n\\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)){\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0;i<arr.length; i++)\\n        yield* inorderTraversal(arr[i]);\\n};\\n```\\n```TypeScript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\\n\\n---\\n\\n# Complexity Analysis:\\n\\n**Time complexity:** O($$N$$), where $$N$$ is the total number of elements in the array.\\n\\n**Space complexity:** O($$D$$), where $$D$$ is the depth of the recursion call.\\n\\n\\n---\\n---\\n\\n# **Approach 2: Using Flat Method**\\n\\n# **Intuition:**\\n\\nHave you ever wondered why it is possible to use ```yield*``` with an array? Let\\'s take a moment to ponder the mechanics behind ```yield*``` and ```arrays (iterables)``` that allow them to seamlessly work together. If you haven\\'t given it much thought, let\\'s explore this concept further.\\n\\n- ```Yield*``` works with arrays because arrays in JavaScript are iterable objects.\\n- Iterables implement the iterable protocol, which involves having a method called ```Symbol.iterator()``` that returns an iterator object.\\n- The iterator object is responsible for sequentially producing the values of the iterable.\\n- When a generator uses ```yield*``` with an array, it delegates the iteration control to the array\\'s iterator.\\n- The generator pauses its execution and yields values generated by iterating over the array\\'s iterator.\\n- After the array has been fully iterated, the generator resumes execution.\\n- This mechanism establishes a standardized approach for iterating over different iterable objects.\\n- It enables generators to handle various types of iterables, including arrays, without requiring explicit handling for each type.\\n\\n# **Algorithm:**\\nWe can use a built-in function ```flat()``` to get flat array with param ```Infinity``` to flatten all levels.\\n\\n# Implementation:\\n\\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n```\\n```TypeScript []\\n\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  yield* (arr.flat(Infinity) as unknown as Generator<number, void, unknown>);\\n}\\n```\\n\\n---\\n\\n# **Complexity Analysis:**\\n**Time complexity:** The time complexity of the ```flat()``` method is O($$N$$), where $$N$$ is the total number of elements in the array. Since the generator function yields each element of the flattened array once, the overall time complexity of the function is also O($$N$$).\\n\\n**Space complexity:** The space complexity of the ```flat()``` method is also O($$N$$), since it creates a new flattened array. The generator function does not create any new data structures, so the overall space complexity is also O($$N$$).\\n\\n---\\n```\\n\\n\\nPlease Upvote if u like the solution\\uD83D\\uDC4D!!!\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```i```\n```yield* inorderTraversal(arr[i])```\n```yield*```\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)){\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0;i<arr.length; i++)\\n        yield* inorderTraversal(arr[i]);\\n};\\n```\n```TypeScript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\n```yield*```\n```yield*```\n```arrays (iterables)```\n```Yield*```\n```Symbol.iterator()```\n```yield*```\n```flat()```\n```Infinity```\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n```\n```TypeScript []\\n\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  yield* (arr.flat(Infinity) as unknown as Generator<number, void, unknown>);\\n}\\n```\n```flat()```\n```flat()```\n```\\n\\n\\nPlease Upvote if u like the solution\\uD83D\\uDC4D!!!\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591051,
                "title": "js-easy-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!(arr instanceof Array)) {\\n        yield arr\\n        return\\n    }\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!(arr instanceof Array)) {\\n        yield arr\\n        return\\n    }\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591039,
                "title": "nested-array-generator",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function* (arr) {\\n  // checking if arr is an array\\n  if (Array.isArray(arr)) {\\n    // iterateing over each element \\n    for (let i = 0; i < arr.length; i++) {\\n      // recursively yield elements from sub-array\\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    // base case\\n    yield arr;\\n  }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function* (arr) {\\n  // checking if arr is an array\\n  if (Array.isArray(arr)) {\\n    // iterateing over each element \\n    for (let i = 0; i < arr.length; i++) {\\n      // recursively yield elements from sub-array\\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    // base case\\n    yield arr;\\n  }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591008,
                "title": "day-30-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586598,
                "title": "solution-using-recursion",
                "content": "# Intuition\\nCheck if the parameter \\'arr\\' is an array. If it is an array, iterate over the array and call the function inorderTraversal recursively by passing the current array element.\\n\\nIf it is not an array, simple return arr.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n    } else {\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n    } else {\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585052,
                "title": "simple-easy-2-lines-full-simple-explanation",
                "content": "# Approach\\n- In order to return values in subarrays, we need to recursively call the ```inorderTraversal``` function. We can\\'t just yield the result of the recursive call on a generator function as one would usually return the result of a non-generator recursive call. We need to be able to yield in the recursive call as one would in the main call.\\n- This can be solved with ```yield*```, which essentially allows us to call on a generator function, and yield each result as one would want to do. In this case, it means yielding each time we reach the next value.\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (val of arr) {\\n        // if val is array, make recursive call. Else, yield val\\n        if (Array.isArray(val)) yield* inorderTraversal(val)\\n        else yield val;\\n    }\\n};\\n```\\n\\n# Some JavaScript stuff: yield\\nIf you don\\'t know what the ```yield``` keyword does in JavaScript, this section might help.\\n\\nGenerator functions (indicated by the ```*``` in ```function*()```) is a function that allows you to iterate throughout code in a function to return different values by calling the same function. While this can be done with regular functions, the conveinent thing with generator functions is they allow you to use the keyword ```yield```, which allows you to stop in the middle of the code and return a value, then when you come back to the function with another call, you pick up where you left off. We can do this using the ```.next().value``` method call, which generator functions automatically have.\\n\\n\\u2014\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```inorderTraversal```\n```yield*```\n```\\nvar inorderTraversal = function*(arr) {\\n    for (val of arr) {\\n        // if val is array, make recursive call. Else, yield val\\n        if (Array.isArray(val)) yield* inorderTraversal(val)\\n        else yield val;\\n    }\\n};\\n```\n```yield```\n```*```\n```function*()```\n```yield```\n```.next().value```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567768,
                "title": "a-simple-dfs-solution",
                "content": "# Intuition\\nSimple Solution with Of DFS.\\n\\n# Complexity\\n- Time complexity:\\n<!-- $$O(arr.flat().length)$$ -->\\n\\n- Space complexity:\\n<!-- $$O(deepth)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    var stk = [], i = 0, curr = arr, len = arr.length;\\n    while (stk.length || i < len) {\\n        while (stk.length && i === len) {\\n            var preLv = stk.pop();\\n            curr = preLv.arr;\\n            len = curr.length;\\n            i = preLv.nxt;\\n        }\\n        if(i===len) return;        \\n        var c = curr[i];\\n        if (c instanceof Array) {\\n            stk.push({arr: curr, nxt: ++i});\\n            curr = c;\\n            len = c.length;\\n            i = 0;\\n        } else {\\n            yield c;\\n            i++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    var stk = [], i = 0, curr = arr, len = arr.length;\\n    while (stk.length || i < len) {\\n        while (stk.length && i === len) {\\n            var preLv = stk.pop();\\n            curr = preLv.arr;\\n            len = curr.length;\\n            i = preLv.nxt;\\n        }\\n        if(i===len) return;        \\n        var c = curr[i];\\n        if (c instanceof Array) {\\n            stk.push({arr: curr, nxt: ++i});\\n            curr = c;\\n            len = c.length;\\n            i = 0;\\n        } else {\\n            yield c;\\n            i++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548928,
                "title": "nested-array-generator-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if (Array.isArray(i)) yield *inorderTraversal(i)\\n        else yield i\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if (Array.isArray(i)) yield *inorderTraversal(i)\\n        else yield i\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546707,
                "title": "javascript-easy-solution-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n    let newArr = [], len = arr.length;\\n    for(let i = len-1; i >= 0; i--) {\\n        newArr.push(arr[i]);\\n    }\\n    while(len) {\\n        yield newArr.pop();\\n        len--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n    let newArr = [], len = arr.length;\\n    for(let i = len-1; i >= 0; i--) {\\n        newArr.push(arr[i]);\\n    }\\n    while(len) {\\n        yield newArr.pop();\\n        len--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536816,
                "title": "stack-solution",
                "content": "**Time complexity:**\\n*~O(n)\\nn - arr.flat().length*\\n\\n**Space complexity:**\\n*O(n)\\nn - arr.flat().length*\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while (stack.length > 0) {\\n        const curr = stack.pop();\\n\\n        if (Array.isArray(curr)) {\\n            for (let i = curr.length - 1; i >= 0; i--) {\\n                stack.push(curr[i])\\n            }\\n        } else {\\n            yield curr;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while (stack.length > 0) {\\n        const curr = stack.pop();\\n\\n        if (Array.isArray(curr)) {\\n            for (let i = curr.length - 1; i >= 0; i--) {\\n                stack.push(curr[i])\\n            }\\n        } else {\\n            yield curr;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530675,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let temp:number[] = arr.flat(Infinity)\\n  let i:number = 0;\\n   while(temp[i] || temp[i] == 0 ){\\n   yield temp[i];\\n   i++;\\n  \\n  }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let temp:number[] = arr.flat(Infinity)\\n  let i:number = 0;\\n   while(temp[i] || temp[i] == 0 ){\\n   yield temp[i];\\n   i++;\\n  \\n  }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526609,
                "title": "recursive-generator-with-yield",
                "content": "# Intuition\\nIn this case, the solution involves performing an inorder traversal on the multi-dimensional array, which means visiting the elements in the array in a specific order.\\n\\n# Approach\\nThe provided code implements a generator function called inorderTraversal that performs the inorder traversal on the multi-dimensional array. Here\\'s a step-by-step explanation of how the code works:\\n1. The function receives the multi-dimensional array as input: arr.\\n\\n2. The arr.entries() method is used to obtain an iterator over the entries of the array. Each entry is a key-value pair, where the key is the index of the element and the value is the element itself.\\n\\n3. The nextElementItx variable is assigned the result of calling arrItx.next(). This retrieves the next element from the iterator.\\n\\n4. A while loop is used to iterate over the elements of the array until there are no more elements to process.\\n\\n5. Inside the loop, the code checks if the current element is an array using Array.isArray(). If it is an array, it means we need to perform an inorder traversal on it. In this case, the yield* syntax is used to delegate the traversal of the sub-array to the same generator function (inorderTraversal), allowing for recursion. This ensures that all the elements within the sub-array are processed in the correct order.\\n\\n6. If the current element is not an array, it means it is an integer. In this case, the code uses the yield keyword to yield the integer value.\\n\\n7. Finally, the nextElementItx variable is updated by calling arrItx.next() to retrieve the next element from the iterator.\\n\\n8. The loop continues until there are no more elements to process, at which point the generator function finishes.\\n\\n# Complexity\\nThe time complexity of this solution depends on the number of elements in the multi-dimensional array. If we denote the total number of elements as n and the maximum depth of nesting as m, the time complexity can be expressed as O(m * log(n)). This is because each level of nesting requires a recursive call, and the depth of recursion is at most m. Additionally, the log(n) factor accounts for the traversal of each element in the array. The space complexity is O(n) because the generator function yields the elements one by one without storing all of them in memory at once.\\n\\nOverall, the provided code effectively performs an inorder traversal on a multi-dimensional array and yields the integers in the same order.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let arrItx = arr.entries();\\n    let nextElementItx = arrItx.next();\\n    while (nextElementItx.value){\\n        if (Array.isArray(nextElementItx.value[1])) {\\n            yield* inorderTraversal(nextElementItx.value[1]);\\n        } else {\\n          yield nextElementItx.value[1];\\n        }\\n      nextElementItx = arrItx.next();\\n    }    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let arrItx = arr.entries();\\n    let nextElementItx = arrItx.next();\\n    while (nextElementItx.value){\\n        if (Array.isArray(nextElementItx.value[1])) {\\n            yield* inorderTraversal(nextElementItx.value[1]);\\n        } else {\\n          yield nextElementItx.value[1];\\n        }\\n      nextElementItx = arrItx.next();\\n    }    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519915,
                "title": "antarnab-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519538,
                "title": "2-lines-solution-flat-method-typescript",
                "content": "\\n# Approach\\nwe use **flat** method to flatten the multidimentional array into a single dim array.\\n\\n\\n# Code\\n```\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n let x = arr.flat(Infinity);\\n for(let element of x) yield element;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n let x = arr.flat(Infinity);\\n for(let element of x) yield element;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516736,
                "title": "stack-no-recursion",
                "content": "# Intuition\\nNo recursion, just stack\\n\\n# Approach\\nWe store in stack current array and index\\nIf we find subArray we add one level to stack\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let st = [{\\n        pos: 0,\\n        arr: arr,\\n    }];\\n\\n    while (true) {\\n        if (st.length == 0) {\\n            return;\\n        };\\n        if (st.at(-1).pos >= st.at(-1).arr.length ) {\\n            st.pop();\\n            continue;\\n        }\\n        if (st.at(-1).arr[st.at(-1).pos] instanceof Array) {\\n            st.push({\\n                pos: 0,\\n                arr: st.at(-1).arr[st.at(-1).pos],\\n            });\\n            st.at(-2).pos++;\\n        } else {\\n            yield st.at(-1).arr[st.at(-1).pos];\\n            st.at(-1).pos++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let st = [{\\n        pos: 0,\\n        arr: arr,\\n    }];\\n\\n    while (true) {\\n        if (st.length == 0) {\\n            return;\\n        };\\n        if (st.at(-1).pos >= st.at(-1).arr.length ) {\\n            st.pop();\\n            continue;\\n        }\\n        if (st.at(-1).arr[st.at(-1).pos] instanceof Array) {\\n            st.push({\\n                pos: 0,\\n                arr: st.at(-1).arr[st.at(-1).pos],\\n            });\\n            st.at(-2).pos++;\\n        } else {\\n            yield st.at(-1).arr[st.at(-1).pos];\\n            st.at(-1).pos++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503693,
                "title": "ts-recursive-solution",
                "content": "# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nconst isArray = (item: unknown): item is MultidimensionalArray => Array.isArray(item);\\nconst isNumber = (item: unknown): item is number => typeof item === \\'number\\';\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (isArray(item)) yield* inorderTraversal(item);\\n    if (isNumber(item)) yield item;\\n  }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nconst isArray = (item: unknown): item is MultidimensionalArray => Array.isArray(item);\\nconst isNumber = (item: unknown): item is number => typeof item === \\'number\\';\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (isArray(item)) yield* inorderTraversal(item);\\n    if (isNumber(item)) yield item;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499169,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let temp = arr.flat(Infinity);\\n    for(let i=0;i<temp.length;i++){\\n        yield temp[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let temp = arr.flat(Infinity);\\n    for(let i=0;i<temp.length;i++){\\n        yield temp[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497217,
                "title": "clean-solution-with-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack=[arr]\\n    while(stack.length){\\n        let item=stack.pop()\\n        if(Array.isArray(item)){\\n            item.reverse()\\n            stack.push(...item)\\n        }\\n        else{\\n            yield item;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack=[arr]\\n    while(stack.length){\\n        let item=stack.pop()\\n        if(Array.isArray(item)){\\n            item.reverse()\\n            stack.push(...item)\\n        }\\n        else{\\n            yield item;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496741,
                "title": "no-yield-treat-input-array-as-a-stack",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr.reverse();\\n    while (arr.length > 0) {\\n        while ((Array.isArray(arr[-1]) && (arr[-1].length === 0))) {\\n            arr.pop();\\n        }\\n        top = arr.pop();\\n        if (!Array.isArray(top)) {\\n            yield top;\\n        }\\n        else {\\n            top.reverse()\\n            arr.push(...top);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr.reverse();\\n    while (arr.length > 0) {\\n        while ((Array.isArray(arr[-1]) && (arr[-1].length === 0))) {\\n            arr.pop();\\n        }\\n        top = arr.pop();\\n        if (!Array.isArray(top)) {\\n            yield top;\\n        }\\n        else {\\n            top.reverse()\\n            arr.push(...top);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486204,
                "title": "done-the-hard-way-without-yield",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length; i++){\\n        if(Array.isArray(arr[i])){\\n            let gen = inorderTraversal(arr[i]);\\n            let tobeCalled = true;\\n            while(tobeCalled){\\n                let nextgen = gen.next();\\n                if(nextgen && !nextgen.done)\\n                yield nextgen.value;\\n                else{\\n                    tobeCalled = false;\\n                }\\n            }\\n        }else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length; i++){\\n        if(Array.isArray(arr[i])){\\n            let gen = inorderTraversal(arr[i]);\\n            let tobeCalled = true;\\n            while(tobeCalled){\\n                let nextgen = gen.next();\\n                if(nextgen && !nextgen.done)\\n                yield nextgen.value;\\n                else{\\n                    tobeCalled = false;\\n                }\\n            }\\n        }else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486155,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486131,
                "title": "simplest-solution-using-arr-flat-infinity-function",
                "content": "# Approach\\nFlatten the array to Infinity levels using ```arr.flat(Infinity)```\\n\\nThen keep traversing and keep doing yield of each value\\n\\n\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    const arr1=arr.flat(Infinity);\\n    for(let i=0;i<arr1.length;i++){\\n        yield arr1[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```arr.flat(Infinity)```\n```\\nvar inorderTraversal = function*(arr) {\\n    const arr1=arr.flat(Infinity);\\n    for(let i=0;i<arr1.length;i++){\\n        yield arr1[i];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485732,
                "title": "typescript-recursion",
                "content": "# Intuition\\nTo solve this problem, we can use a generator function that performs a recursive traversal of the input multidimensional array. This will allow us to yield each integer encountered during the traversal in the same order as an inorder traversal.\\n\\n# Approach\\n1. Create a generator function called `inorderTraversal` that takes a multidimensional array as input.\\n2. Iterate through the elements of the input array.\\n3. If the current element is an array, call `inorderTraversal` recursively on the array and use the `yield*` keyword to yield the results of the recursive call.\\n4. If the current element is a number, yield it.\\n\\nBy following this approach, we ensure that the generator function yields integers in the order they are encountered during an inorder traversal of the input multidimensional array.\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the total number of elements in the flattened input array. This is because we visit each element exactly once during the traversal.\\n- Space complexity: $$O(d)$$, where $$d$$ is the maximum depth of the nested input array. This is because the maximum depth of the recursion determines the maximum amount of space required on the call stack.\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483591,
                "title": "inordertraversal-generator-using-for-loop-with-yield-keyoword",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n// recursivly doing the function why because our value is 6 first time running [[6]] and second time [6] third time 6 after that return the value through the yield keyword... \\n// [ [ [ 6 ] ]\\n// [ [ 6 ] ]\\n// [ 6 ]\\n// 6 \\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    yield arr;\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n// recursivly doing the function why because our value is 6 first time running [[6]] and second time [6] third time 6 after that return the value through the yield keyword... \\n// [ [ [ 6 ] ]\\n// [ [ 6 ] ]\\n// [ 6 ]\\n// 6 \\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    yield arr;\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483090,
                "title": "easy-solution-to-understand-for-beginners",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i+=1) {\\n        if(Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n        else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i+=1) {\\n        if(Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n        else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470733,
                "title": "1-liner",
                "content": "```\\nvar inorderTraversal = function* f(a)\\n{\\n    for(x of a) Array.isArray(x) ? yield* f(x) : yield x\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar inorderTraversal = function* f(a)\\n{\\n    for(x of a) Array.isArray(x) ? yield* f(x) : yield x\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469105,
                "title": "easy-js-solution-beats-95-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let ans=[];\\n     let traverse=(arr)=>{\\n          for(let i=0;i<arr.length;i++){\\n          if(Array.isArray(arr[i])){\\n            traverse(arr[i]);\\n          }\\n          else{\\n              ans.push(arr[i]);\\n          }\\n      }\\n     }\\n     traverse(arr)\\n     yield* ans;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let ans=[];\\n     let traverse=(arr)=>{\\n          for(let i=0;i<arr.length;i++){\\n          if(Array.isArray(arr[i])){\\n            traverse(arr[i]);\\n          }\\n          else{\\n              ans.push(arr[i]);\\n          }\\n      }\\n     }\\n     traverse(arr)\\n     yield* ans;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468355,
                "title": "built-in-recursive-iterative",
                "content": "# Built-in\\n\\nO(n) time\\n0(n) memory\\n\\n```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\\n\\n# Recursive\\n\\nO(n) time\\nO(m) memory (max level of recursion)\\n\\n```js\\nvar inorderTraversal = function*(_arr) {\\n    for (const arr of _arr) {\\n        if (Array.isArray(arr)) {\\n            yield* inorderTraversal(arr);\\n        } else {\\n            yield arr;\\n        }\\n    }\\n};\\n```\\n\\n# Iterative\\n\\nO(n) time\\nO(m) memory (max level of recursion)\\n\\n```js\\nvar inorderTraversal = function*(arr) {\\n    const stack = [[arr, 0]];\\n    while (stack.length) {\\n        let [arr, i] = stack.pop();\\n        for (; i < arr.length; i++) {\\n            if (Array.isArray(arr[i])) {\\n                stack.push([arr, i + 1], [arr[i], 0]);\\n                break;\\n            }\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\n```js\\nvar inorderTraversal = function*(_arr) {\\n    for (const arr of _arr) {\\n        if (Array.isArray(arr)) {\\n            yield* inorderTraversal(arr);\\n        } else {\\n            yield arr;\\n        }\\n    }\\n};\\n```\n```js\\nvar inorderTraversal = function*(arr) {\\n    const stack = [[arr, 0]];\\n    while (stack.length) {\\n        let [arr, i] = stack.pop();\\n        for (; i < arr.length; i++) {\\n            if (Array.isArray(arr[i])) {\\n                stack.push([arr, i + 1], [arr[i], 0]);\\n                break;\\n            }\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465964,
                "title": "js-solution-without-flat-function",
                "content": "# Code\\n```\\n\\nfunction oneDimensionalArray(arr,answer){\\n    for (let element of arr){\\n        if (Array.isArray(element)){\\n            oneDimensionalArray(element,answer);\\n        }else {\\n            answer.push(element);\\n        }\\n    }\\n};\\n\\nvar inorderTraversal = function*(arr) {\\n    let answer = [];\\n    oneDimensionalArray(arr,answer);\\n\\n    while (answer.length !== 0){\\n        yield answer.shift();\\n    }\\n\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\n\\nfunction oneDimensionalArray(arr,answer){\\n    for (let element of arr){\\n        if (Array.isArray(element)){\\n            oneDimensionalArray(element,answer);\\n        }else {\\n            answer.push(element);\\n        }\\n    }\\n};\\n\\nvar inorderTraversal = function*(arr) {\\n    let answer = [];\\n    oneDimensionalArray(arr,answer);\\n\\n    while (answer.length !== 0){\\n        yield answer.shift();\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3463204,
                "title": "clean-and-easy-to-understand-recursive-solution-with-yield",
                "content": "# Intuition\\n\\nWhat if I recursively traverse it as the usual nested array, but with generator syntax?\\n\\n# Approach\\n\\nThe `yield*` expression iterates over the operand and yields each value it returns. Here it\\'s the same generator function, which we call if the next element is an array.\\n\\nReference: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (const el of arr) {\\n    if (Array.isArray(el)) {\\n      yield* inorderTraversal(el);\\n    } else {\\n      yield el;\\n    }\\n  }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "# Intuition\\n\\nWhat if I recursively traverse it as the usual nested array, but with generator syntax?\\n\\n# Approach\\n\\nThe `yield*` expression iterates over the operand and yields each value it returns. Here it\\'s the same generator function, which we call if the next element is an array.\\n\\nReference: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (const el of arr) {\\n    if (Array.isArray(el)) {\\n      yield* inorderTraversal(el);\\n    } else {\\n      yield el;\\n    }\\n  }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3460727,
                "title": "accepted-javascript",
                "content": "```\\nvar inorderTraversal = function*(arr) {\\n\\n    if (!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n\\n        let gen = inorderTraversal(arr[i]);\\n        var val = gen.next().value;\\n\\n        while (val != null) {\\n            yield val;\\n            val = gen.next().value;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n\\n    if (!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n\\n        let gen = inorderTraversal(arr[i]);\\n        var val = gen.next().value;\\n\\n        while (val != null) {\\n            yield val;\\n            val = gen.next().value;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458593,
                "title": "the-simplest-for-javascript-typescript-extremely-short-and-elegant",
                "content": "# Approach\\nThe proposed solution is to use a generator function that flattens the nested array in an in-order manner. The function receives a multidimensional array as input, and then uses the `flat()` method to flatten the array in an in-order manner. The `flat()` method is called with the argument `Infinity`, which means that all nested arrays are recursively flattened. Finally, the generator function yields each element of the flattened array using the `yield*` statement.\\n\\n# Complexity\\n- Time complexity: `O(n)`, where `n` is the total number of elements in the nested array. The time complexity of the `flat()` method is `O(n)`, where `n` is the total number of elements in the array. Since the generator function yields each element of the flattened array once, the overall time complexity of the function is also `O(n)`.\\n\\n- Space complexity: `O(n)`, where `n` is the total number of elements in the nested array. The space complexity of the `flat()` method is also `O(n)`, since it creates a new flattened array. The generator function does not create any new data structures, so the overall space complexity is also `O(n)`.\\n\\n# Code\\n```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```\\n```javascript []\\nfunction* inorderTraversal(arr) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```\n```javascript []\\nfunction* inorderTraversal(arr) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455397,
                "title": "ts-recursive-approach-80-time-217ms-50-space-74-2mb",
                "content": "Classical recursive data structure problem that we will solve with a recursive parsing - the only novel bit would be to `yield` instead of `return`ing the result.\\n\\nWe will loop through each element `el` in `arr` and:\\n* if it is of type `number`, we will simply `yield` `el`;\\n* alternatively, we will:\\n    * declare `gen` as a new generator calling recursively `inorderTraversal` with `el`;\\n    * declare `tmp` as the result of `gen.next()`;\\n    * loop `while` we are not done (ie: `!tmp.done`) and:\\n        * `yield` `tmp.value` (cast with the `Number` constructor to make TS happy);\\n        * update `tmp` to be `gen.next()`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(d)$$ (with `d` being the depth of the recursive stack)\\n\\n# Code\\n```ts\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const el of arr) {\\n        // base case: el is a number\\n        if (typeof(el) === \"number\") yield el;\\n        // general case: we go one level deeper\\n        else {\\n            const gen = inorderTraversal(el);\\n            let tmp = gen.next();\\n            while (!tmp.done) {\\n                yield Number(tmp.value);\\n                tmp = gen.next();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```ts\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const el of arr) {\\n        // base case: el is a number\\n        if (typeof(el) === \"number\") yield el;\\n        // general case: we go one level deeper\\n        else {\\n            const gen = inorderTraversal(el);\\n            let tmp = gen.next();\\n            while (!tmp.done) {\\n                yield Number(tmp.value);\\n                tmp = gen.next();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455005,
                "title": "simple-recursive-solution-4-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let el of arr){\\n        if(Array.isArray(el)){\\n            yield* inorderTraversal(el);\\n        }\\n        else yield el;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let el of arr){\\n        if(Array.isArray(el)){\\n            yield* inorderTraversal(el);\\n        }\\n        else yield el;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454009,
                "title": "easy-typescript-solution",
                "content": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction flatten(arr:MultidimensionalArray){\\n    const list:number[]=[]\\n    arr.forEach(item=>{\\n        if(typeof item ==\"number\") list.push(item)\\n        else list.push(...flatten(item))\\n    })\\n    return list\\n}\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const list=flatten(arr);\\n    for(let i=0;i<list.length;i++){\\n        yield list[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction flatten(arr:MultidimensionalArray){\\n    const list:number[]=[]\\n    arr.forEach(item=>{\\n        if(typeof item ==\"number\") list.push(item)\\n        else list.push(...flatten(item))\\n    })\\n    return list\\n}\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const list=flatten(arr);\\n    for(let i=0;i<list.length;i++){\\n        yield list[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 3453883,
                "title": "55-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet flat = (arr) => {\\n    let flatArr = [];\\n    arr.forEach(i => {\\n        if(Array.isArray(i)) flatArr.push(...flat(i))\\n        else flatArr.push(i);\\n    })\\n    return flatArr;\\n}\\n\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if(Array.isArray(i)) {\\n            let sub = flat(i);\\n            while(sub.length > 0) {\\n                yield sub.shift();\\n            }\\n        } else yield i;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet flat = (arr) => {\\n    let flatArr = [];\\n    arr.forEach(i => {\\n        if(Array.isArray(i)) flatArr.push(...flat(i))\\n        else flatArr.push(i);\\n    })\\n    return flatArr;\\n}\\n\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if(Array.isArray(i)) {\\n            let sub = flat(i);\\n            while(sub.length > 0) {\\n                yield sub.shift();\\n            }\\n        } else yield i;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452424,
                "title": "javascript-simplest-solution",
                "content": "\\n# Code\\n```\\nvar inorderTraversal = function* (arr) {\\n    if (Number.isInteger(arr)) {\\n        yield arr;\\n    } else {\\n        for (const i in arr) yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function* (arr) {\\n    if (Number.isInteger(arr)) {\\n        yield arr;\\n    } else {\\n        for (const i in arr) yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449797,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0;i<arr.length;i++)\\n        Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i]\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0;i<arr.length;i++)\\n        Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i]\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449788,
                "title": "javascript-2-solutions-recursive-generator-and-flat",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use function `flat` to get flat array with param `Infinity` to flatten all levels. Then just `yield` all nums in a loop.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const nums = arr.flat(Infinity);\\n\\n    for (let num of nums) {\\n        yield num;\\n    }\\n};\\n```\\n\\nSecond approach is to use recursive generator, this solution really slower (almost twice) than the first one. And demands more memory.\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let num of arr) {\\n        if (Array.isArray(num)) {\\n            yield* inorderTraversal(num)\\n        } else {\\n            yield num;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const nums = arr.flat(Infinity);\\n\\n    for (let num of nums) {\\n        yield num;\\n    }\\n};\\n```\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let num of arr) {\\n        if (Array.isArray(num)) {\\n            yield* inorderTraversal(num)\\n        } else {\\n            yield num;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449325,
                "title": "simple-non-recursive-one-loop-approach",
                "content": "Currently outperforms 100% of other solutions on time and memory\\n\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    if (!arr.length) return;\\n\\n    for (let i = 0, q: MultidimensionalArray = []; q.length || i < arr.length;) {\\n        let el = q.length ? q.shift() : arr[i++];\\n        if (Array.isArray(el)) q.unshift(...el);\\n        else yield el!;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    if (!arr.length) return;\\n\\n    for (let i = 0, q: MultidimensionalArray = []; q.length || i < arr.length;) {\\n        let el = q.length ? q.shift() : arr[i++];\\n        if (Array.isArray(el)) q.unshift(...el);\\n        else yield el!;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446310,
                "title": "javascript-stack-based-approach",
                "content": "This solution uses a stack to track the current state of the iterator.\\n \\nInitially, and when an `Array` is encoutered, it is pushed onto the top of the stack along with an index indicating the current element in the `Array`\\n \\nThe next element is determined by looking at the\\xA0`Array` on top of the stack. If the corresponding index is less than the length of the `Array`, then use the element at the specified index and increment. Otherwise, pop the top of the stack off.\\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [{arr, idx: 0}];\\n    while (stack.length) {\\n        const top = stack[stack.length - 1];\\n        if (top.idx < top.arr.length) {\\n            const elem = top.arr[top.idx++];\\n            if (Array.isArray(elem)) {\\n                stack.push({arr:elem, idx: 0});\\n            }\\n            else {\\n                yield elem;\\n            }\\n        }\\n        else {\\n            stack.pop();\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [{arr, idx: 0}];\\n    while (stack.length) {\\n        const top = stack[stack.length - 1];\\n        if (top.idx < top.arr.length) {\\n            const elem = top.arr[top.idx++];\\n            if (Array.isArray(elem)) {\\n                stack.push({arr:elem, idx: 0});\\n            }\\n            else {\\n                yield elem;\\n            }\\n        }\\n        else {\\n            stack.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1915282,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            },
            {
                "id": 1915122,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            },
            {
                "id": 1915071,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            },
            {
                "id": 1914869,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            }
        ]
    },
    {
        "title": "Make Array Empty",
        "question_content": "<p>You are given an integer array <code>nums</code> containing <strong>distinct</strong> numbers, and you can perform the following operations <strong>until the array is empty</strong>:</p>\n\n<ul>\n\t<li>If the first element has the <strong>smallest</strong> value, remove it</li>\n\t<li>Otherwise, put the first element at the <strong>end</strong> of the array.</li>\n</ul>\n\n<p>Return <em>an integer denoting the number of operations it takes to make </em><code>nums</code><em> empty.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,-1]\n<strong>Output:</strong> 5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, -1, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[-1, 3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4,3]\n<strong>Output:</strong> 5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 3\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9&nbsp;</sup>&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>All values in <code>nums</code> are <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3466800,
                "title": "java-c-python-easy-sort-solution",
                "content": "# **Intuition**\\nThere `n` elements at first,\\nso there will take at least `n` operations.\\nAnd it take `n` operations rotate all elements once.\\n<br>\\n\\n# **Explanation**\\nInitialize `res` as `n` at first,\\nand we record every elements position, `pos[A[i]] = i`.\\n\\nThen we iterate all element from small to big in `A`,\\nif the position decrease,\\nthis mean we will rotate all remining element to the begin,\\nand this bring us back to out begining intuition above,\\nwe will increase `res` by the number of remaining elements.\\n<br>\\n\\n\\n# **Example**\\n\\n`A = [7,8,9]`\\nthis `A` takes 3 operation.\\n\\nNow we insert `4,5,6` in A,\\nno matter what position but keep their order\\nMaybe `A = [4,5,7,8,9,6]`\\nNow it take one round to remove 4,5,6 then 7,8,9\\nso it needs `6 + 3 = 9` operations\\n\\nNow we insert `1,2,3` in A,\\nno matter what position but keep their order\\nso it needs `9 + 6 + 3 = 18` operations\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        long n = A.length, res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos.put(A[i], i);\\n        Arrays.sort(A);\\n        for (int i = 1; i < n; ++i)\\n            if (pos.get(A[i]) < pos.get(A[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> pos;\\n        long long n = A.size(), res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (pos[A[i]] < pos[A[i - 1]])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        pos = {a: i for i, a in enumerate(A)}\\n        res = n = len(A)\\n        A.sort()\\n        for i in range(1, n):\\n            if pos[A[i]] < pos[A[i - 1]]:\\n                res += n - i\\n        return res\\n```\\n<br>\\n\\n\\n# **Solution II: Not sort input**\\nSuggested by @sgallivan,\\nbetter not to sort directly on the input.\\n\\nTime `O(nlogn)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**C++**\\nby @sgallivan\\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long n = A.size(), res = n;\\n        vector<int> pos(n);\\n        iota(begin(pos), end(pos), 0);\\n        sort(begin(pos), end(pos), [&](int a, int b) {return A[a] < A[b];});\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        long n = A.length, res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos.put(A[i], i);\\n        Arrays.sort(A);\\n        for (int i = 1; i < n; ++i)\\n            if (pos.get(A[i]) < pos.get(A[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n```\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> pos;\\n        long long n = A.size(), res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (pos[A[i]] < pos[A[i - 1]])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        pos = {a: i for i, a in enumerate(A)}\\n        res = n = len(A)\\n        A.sort()\\n        for i in range(1, n):\\n            if pos[A[i]] < pos[A[i - 1]]:\\n                res += n - i\\n        return res\\n```\n```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long n = A.size(), res = n;\\n        vector<int> pos(n);\\n        iota(begin(pos), end(pos), 0);\\n        sort(begin(pos), end(pos), [&](int a, int b) {return A[a] < A[b];});\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466731,
                "title": "just-sort-without-any-other-tricky-data-structures",
                "content": "# Intuition\\nIf we just find the smallest, 2nd smallest\\u2026until the m-th smallest number and they are just from left to right, then after n operations (n - m movings and m deletions) all the other (n - m) numbers go back to the \\u201Ccorrect\\u201D/original positions. We just have a shorter array to restart.\\n\\n# Approach\\nSort by index and process all the numbers from left to right and then restart.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) because of sorting.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ind(n);\\n        for (int i = 0; i < n; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int x, const int y) {\\n            return nums[x] < nums[y];\\n        });\\n        int m = n;\\n        long long r = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (ind[i] < ind[i - 1]) {\\n                r += m;\\n                m = n - i;\\n            }\\n        }\\n        r += m;\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ind(n);\\n        for (int i = 0; i < n; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int x, const int y) {\\n            return nums[x] < nums[y];\\n        });\\n        int m = n;\\n        long long r = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (ind[i] < ind[i - 1]) {\\n                r += m;\\n                m = n - i;\\n            }\\n        }\\n        r += m;\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466620,
                "title": "count-rotations-vs-bit",
                "content": "We sort the indexes of the numbers. \\n\\nFor example, for `[8, 6, 11, 1, 2, 3, 7]`, the sorted indexes will be `[3, 4, 5, 1, 6, 0, 2]`.\\n\\nI solved this problem using BIT (second solution below), but there is another approach (first solution) with tricky intuition but simpler implementation.\\n\\n## Count Rotations\\nThe implementation is simple but the intuition is not. I only found a good explanation in the solution by [mkyang](https://leetcode.com/mkyang/).\\n\\n1. For the test case `[10, 20, 30, 40, 50]`, we need five operations.\\n2. For `[50, 40, 30, 20, 10]`, we need to first rotate 4 elements to reach the smallest number `10`.\\n\\t- So we need 5 operations to remove the smallest element, 4 - for the second smallest one, and so on;\\n\\t- Total 5 + 10 operations.\\n3. For `[10, 30, 50, 20, 40]`, we need:\\n\\t- 2 rotations to reach 20, 1 rotations 30, 1 rotation to reach 40.\\n\\t- Total 5 + 4 operations.\\n\\n- The sorted index array `ids` for the last case is `[0, 3, 1, 4, 2]`.\\n\\t- We see that `ids[1] > ids[2]`, and it means that we needed to rotate `3` elements (`30, 50, 40`) to reach/remove `20`, and go back to `30`.\\n\\t- As `ids[3] > ids[4]`, we need `1` rotation (`50`) to reach/remove `40` and go back to `50`.\\n\\n**C++**\\n```cpp\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        res += ids[i - 1] < ids[i] ? 0 : sz - i;\\n    return res + sz;\\n}\\n```\\n\\n## BIT\\n\\nWe start from index zero, and go to the first smallest number. In our example, the position is 3, and it takes 4 operations to remove that number.\\n\\nGoing from index `cur` to index `id` takes:\\n- `id - cur + 1` operations, or \\n- `id + sz - cur` if the current index is larger.\\n\\nHowever, we need to reduce the number operations for elements we already removed. \\n\\nFor that, we can use a mutating prefix sum data structure, like BIT.\\n\\n**C++**\\n```cpp        \\nconstexpr int static n = 100001;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, cur = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int id : ids) {\\n        if (cur <= id)\\n            res += 1 + (id - prefix_sum(id)) - (cur - prefix_sum(cur - 1));\\n        else\\n            res += (sz - prefix_sum(sz)) + (id - prefix_sum(id)) - (cur - prefix_sum(cur));\\n        add(id, 1);\\n        cur = id;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        res += ids[i - 1] < ids[i] ? 0 : sz - i;\\n    return res + sz;\\n}\\n```\n```cpp        \\nconstexpr int static n = 100001;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, cur = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int id : ids) {\\n        if (cur <= id)\\n            res += 1 + (id - prefix_sum(id)) - (cur - prefix_sum(cur - 1));\\n        else\\n            res += (sz - prefix_sum(sz)) + (id - prefix_sum(id)) - (cur - prefix_sum(cur));\\n        add(id, 1);\\n        cur = id;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469773,
                "title": "day-395-easy-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nIntuition:\\n\\nThink backwards: simulate in reverse direction. When you remove the last remaining element, how will it affect? When you will have 2 elements left, how will it affect and so on\\u2026\\n\\nThe relative position of an element to the next element which will be removed will determine the number of operations required to remove that element.\\n\\nApproach:\\n\\nStore the index and element in an array and then sort the array. This will tell us if after doing some operation what will be the relative position of that given element to the next element which will be removed.\\n\\nUse a HashMap to store the index of each element in the input array.\\n\\nIterate over the sorted array in reverse order, starting from the second last element.\\n\\nFor each element, check if its index in the original array is greater than the index of the next element to be removed. If it is, then the element will move to the end of the array after the next element is removed, and we need to perform n - i operations to remove it, where n is the length of the input array. Otherwise, we only need to perform 1 operation to remove the element.\\n\\nAdd the number of operations required to remove the current element to the answer.\\n\\nReturn the answer.\\n\\nThe time complexity of this approach is O(n log n), where n is the length of the input array, due to the sorting operation.\\n\\n\\n# Code\\n```java []\\npublic long countOperationsToEmptyArray(int[] nums) {\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    int n=nums.length;\\n    for(int i=0;i<n;i++)map.put(nums[i],i);\\n    Arrays.sort(nums);\\n    long ans=1;\\n    for(int i=n-2;i>=0;i--){\\n        ans += (map.get(nums[i])>map.get(nums[i+1]))?n-i:1;\\n    }return ans;\\n}\\n```\\n```python []\\ndef countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    map = {nums[i]: i for i in range(n)}\\n    nums.sort()\\n    ans = 1\\n    for i in range(n - 2, -1, -1):\\n        ans += (map[nums[i]] > map[nums[i+1]]) * (n - i) + (map[nums[i]] <= map[nums[i+1]])\\n    return ans\\n```\\n```c++ []\\n long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            map[nums[i]] = i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        long ans = 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            ans += (map[nums[i]] > map[nums[i+1]]) ? n - i : 1;\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: o(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```java []\\npublic long countOperationsToEmptyArray(int[] nums) {\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    int n=nums.length;\\n    for(int i=0;i<n;i++)map.put(nums[i],i);\\n    Arrays.sort(nums);\\n    long ans=1;\\n    for(int i=n-2;i>=0;i--){\\n        ans += (map.get(nums[i])>map.get(nums[i+1]))?n-i:1;\\n    }return ans;\\n}\\n```\n```python []\\ndef countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    map = {nums[i]: i for i in range(n)}\\n    nums.sort()\\n    ans = 1\\n    for i in range(n - 2, -1, -1):\\n        ans += (map[nums[i]] > map[nums[i+1]]) * (n - i) + (map[nums[i]] <= map[nums[i+1]])\\n    return ans\\n```\n```c++ []\\n long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            map[nums[i]] = i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        long ans = 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            ans += (map[nums[i]] > map[nums[i+1]]) ? n - i : 1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466873,
                "title": "c-python-easy-code-for-understanding",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n- The most important thing is to calculate for each $a_i$, the deleted turn of $a_i$ is called $turn(i)$.\\n- Obviously, all elements which $>a_i$ will be deleted after $i$, so they will never make contribution to $turn(i)$. And all elements which $<a_i$ will be deleted before or in the same turn of $i$.\\n- So simulate the process, easily find that $turn(i)$ must satisfy two constraints:\\n    - **For all the left smaller elements** $j$, $turn(i) >= turn(j)$.\\n    - **For all the right smaller elements** $k$, $turn(i) > turn(k)$.\\n- So the result of $a_i$ is:\\n        $turn(i) = \\\\max{ \\\\{\\\\max\\\\limits_{j=0}^i {turn(j)}, \\\\max\\\\limits_{k=i+1}^{n-1} {turn(k)} + 1 \\\\}}, a_j < a_i, a_k < a_i$\\n- Easily traversing the array from small to large, using segment tree to maintain the range maximum, we can solve the problem in $O(n \\\\log n)$ time. \\n-   But in this problem we can find a good property:\\n    **From previous one to the next in sorted array, $turn$ is either unchanged or increased by one.**\\n- What\\'s more? \\n    **Assuming that the current maximum turn is $t$, $turn(i) = t + 1$ only when there is a $t$ on the right side of $a_i$, otherwise $turn(i) = t$.**\\n- So maintain the current $t$ and max index of $t$. If the current index is greater than the largest index that appeared before, then inherit $t$; otherwise update to $t+1$. And update the current largest index at the same time.\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log{n})$\\n- Space complexity: $O(n)$\\n\\n# Code\\n``` Python3 []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n, res, turn = len(nums), 1, 1\\n        idx = sorted(range(n), key=lambda x: nums[x])\\n        for i in range(1, n):\\n            turn += idx[i] < idx[i-1]\\n            res += turn\\n        return res\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size(), res = 1, turn = 1;\\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](int x, int y) -> bool {\\n            return nums[x] < nums[y];\\n        });\\n        for (int i = 1; i < n; ++i) {\\n            turn += idx[i] < idx[i-1];\\n            res += turn;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Sort"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n, res, turn = len(nums), 1, 1\\n        idx = sorted(range(n), key=lambda x: nums[x])\\n        for i in range(1, n):\\n            turn += idx[i] < idx[i-1]\\n            res += turn\\n        return res\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size(), res = 1, turn = 1;\\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](int x, int y) -> bool {\\n            return nums[x] < nums[y];\\n        });\\n        for (int i = 1; i < n; ++i) {\\n            turn += idx[i] < idx[i-1];\\n            res += turn;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469719,
                "title": "fully-explained-in-easy-way-must-check",
                "content": "# Intuition\\nThis question needs a good level of observation . Just think what is asked in problem  ! You have to delete the smallest element and shift the rest of the elements. Just check that how much operation is needed to delete the smallest element. It will be the current index of smallest element + 1 . Now check the next smallest if it was present before this index then You Need to do N operations at any cost to delete this element .\\n\\nfor this first sort the array like this \\nsmallest element - index\\n2nd smallest element - index\\n.\\n.\\n.\\n.\\nlargest element -index \\n\\nuse this array to check wether the 2nd smallest element is coming before the smallest element or after the smallest element and perform accordingly .\\n\\nif before then we need n operations \\nelse we can delete them together so increment d\\ntry to Dry run this !! else you\\'ll not get it \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op =0;\\n        map<int,int>mp;\\n       for(int i = 0 ; i < nums.size() ; ++i){\\n           mp[nums[i]] = i ;\\n       }\\n        vector<int>v;\\n        for(auto x:mp){\\n          \\n            v.push_back(x.second);\\n        }\\n    \\n        int last=  v[0];\\n        long long d = 1; //items to be deleted now \\n        long long n = nums.size(); //size of current array \\n        if(v.size()==1) return op+1;\\n        for(int i = 1; i<v.size(); ++i){\\n            if(v[i]<last){\\n                op+=n ; //if index of the next smallest  element < last smallest element then we need to perform n operations to delete this \\n                n-=d; \\n                d=1;\\n                last= v[i];\\n                if(i==v.size()-1) op++;\\n            }\\n            else{\\n                \\n                d++;\\n                last=v[i];\\n                 if(i==v.size()-1) op+=n ;\\n            }\\n        }\\n        return op ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op =0;\\n        map<int,int>mp;\\n       for(int i = 0 ; i < nums.size() ; ++i){\\n           mp[nums[i]] = i ;\\n       }\\n        vector<int>v;\\n        for(auto x:mp){\\n          \\n            v.push_back(x.second);\\n        }\\n    \\n        int last=  v[0];\\n        long long d = 1; //items to be deleted now \\n        long long n = nums.size(); //size of current array \\n        if(v.size()==1) return op+1;\\n        for(int i = 1; i<v.size(); ++i){\\n            if(v[i]<last){\\n                op+=n ; //if index of the next smallest  element < last smallest element then we need to perform n operations to delete this \\n                n-=d; \\n                d=1;\\n                last= v[i];\\n                if(i==v.size()-1) op++;\\n            }\\n            else{\\n                \\n                d++;\\n                last=v[i];\\n                 if(i==v.size()-1) op+=n ;\\n            }\\n        }\\n        return op ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466953,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n log n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums){\\n        Map<Integer, Integer> nm = new HashMap<>();\\n        int n=nums.length,val=0;\\n        long ans=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            nm.put(nums[i],i);\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nm.get(nums[i])<val)\\n            {\\n                ans+=n-i;\\n            }\\n            val=nm.get(nums[i]);\\n        }   \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums){\\n        Map<Integer, Integer> nm = new HashMap<>();\\n        int n=nums.length,val=0;\\n        long ans=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            nm.put(nums[i],i);\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nm.get(nums[i])<val)\\n            {\\n                ans+=n-i;\\n            }\\n            val=nm.get(nums[i]);\\n        }   \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467389,
                "title": "python3-sortedlist-natural-approach",
                "content": "We can transform the problem into taking from a circular `positions` array of [0, 1, ..., N-1].  For example with A = [3, 4, -1], we take these values in sorted order (-1, 4, 3), so we want to take from positions [2, 0, 1].\\n\\nLet\\'s keep a `SortedList` of these positions.  When we transition from position `a` to position `b`, we need `(positions.index(b) - positions.index(a)) % len(positions)` rotation operations.  We use `i` and `j` to keep track of these `position.index`\\'es.\\n\\nWe also need to do `N` deletion operations, so `ans += N` at the end.\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        N = len(A)\\n        locs = {v: i for i, v in enumerate(A)}\\n        positions = SortedList(range(N))\\n\\n        ans = i = 0\\n        for x in sorted(A):\\n            r = locs[x]\\n            j = positions.index(r)\\n            ans += (j - i) % len(positions)\\n            positions.pop(j)\\n            i = j\\n        return ans + N\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        N = len(A)\\n        locs = {v: i for i, v in enumerate(A)}\\n        positions = SortedList(range(N))\\n\\n        ans = i = 0\\n        for x in sorted(A):\\n            r = locs[x]\\n            j = positions.index(r)\\n            ans += (j - i) % len(positions)\\n            positions.pop(j)\\n            i = j\\n        return ans + N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470229,
                "title": "concise-o-nlogn-solution-with-example-and-explanation-to-be-removed-at-which-round",
                "content": "**Motivation**\\nFirstly, I start solving this problem by *simulating the steps* and using a BIT-like approach. This approach will count how many moves before remove the next target element. You may find similar approaches in other posts. \\n\\nHere, I want to share another approach. i prefer to use the following description of the problem,\\n***Scan the array from left to right round after round (perhaps several rounds). An element is visited but not be deleted unless it is the smallest of all elements remained. Continue such process until nothing left.*** The core idea here is **to count how many rounds an element is visited before ultimately deleted from the array (i.e. at which round be deleted)** Actually, this approach will become so clear as long as you go step by step with the example below.\\n\\n*#update on Aprial 30 23:30 UTC+8, 2023*\\nJust read the approach of @votrubac https://leetcode.com/problems/make-array-empty/discuss/3466620/Count-Rotations-vs.-BIT\\nI think the idea are similar. Here, our approach is to check at which round the element is to be removed. In another way, we can count at each round how many elements are visited but not removed. I will show the calculation in the following example.\\n\\n**Example**\\nWe use an example: [4,2,3,1,5] to demonstrate the process of removing. Please keep in mind about which round an element is removed. Starting from Round K=0, we mean that this array has been scanned from the left end to the right end K time. \\n```\\nNotation:\\n$/current: index of the last element be removed\\n^/target : index of the element to be removed\\n\\nStep0:\\nInit current=-1, round {of scanning}=0\\n\\nStep1: current=-1, target=3, \"1\" to be removed\\n    Since target>current, we continue this round\\n    [4, 2, 3, 1, 5]\\n  $   ---->   ^\\n    Before removed, \"1\" has been visited for 0 times. (round=0)\\nStep2: current=3, target=1, \"2\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, 2, 3, -, 5]  \\n        ^ <---$    \\n    Before removed, \"2\" has been visited for 1 times. (round=1)\\nStep3: current=1, target=2, \"3\" to be removed\\n    Since target>current, we continue this round\\n    [4, -, 3, -, 5]\\n        $->^\\n    Before removed, \"3\" has been visited for 1 times. (round=1)\\nStep4: current=2, target=0, \"4\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, -, -, -, 5]   \\n     ^ <-- $          \\n    Before removed, \"4\" has been visited for 2 times. (round=2)\\nStep5: current=0, target=4, \"5\" to be removed\\n    Since target>current, we continue this round\\n    [-, -, -, -, 5]\\n     $   ---->   ^\\n    Before removed, \"5\" has been visited for 2 times. (round=2)\\n\\nConclusion: \\n------------------------------------------------------------\\nLet us  have some statistic here. V=visit, D=Delete\\n            [4,      2,      3,      1,      5]           \\nRound 0:     V       V       V       D       V   | 4 visit, 1 delete\\nRound 1:     V       D       D       -       V   | 2 visit, 2 delete\\nRound 2:     D       -       -       -       D   | 0 visit, 2 delete\\n------------------------------------------------------------\\n         R2/2V   R1/1V   R1/1V   R0/0V   R2/2V   | 6 visit, 5 delete\\n\\nVisited before removed:\\n    Column by column:  totally 2 +1 +1+0+2=6 times\\n    Row by row:        totaly 4+2=6 times\\nDeleted:   5 elements need 5 steps.\\nThe answer is 5+6\\n\\n#update on Aprial 30 23:30 UTC+8, 2023\\nOur approach do the calculation column by column. And, it is also valid to do the calculation row by row.\\n```\\n\\n**Algorithm**\\nI think you have got the idea. N elements need N steps to be removed. If an element is removed at round K, it was visited for K times additionally. We just need to identify this K.\\n\\n```\\n0. Initialize ROUND=0 and ANS=n\\n1. Scan the element from small to big (with sorting or something similar)\\n\\t1.1. Suppose the index of the last element is A and the index of the current element is B, increase ROUND by1 in case A>B\\n\\t2.2. ANS+=ROUND;\\n2. Return ANS.\\n\\nDone.\\n```\\n\\n**Complexity & Performance**\\n```\\nRuntime: 146 ms, faster than 100.00% of C++ online submissions for Make Array Empty.\\nMemory Usage: 68.4 MB, less than 100.00% of C++ online submissions for Make Array Empty.\\n\\nTime Complexity: O(N*LogN) [for sorting or something similar]\\n```\\n**Code**\\n```\\n#column calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1, round=0; j<n; ) {\\n            round+=num[j++].second<num[i++].second;\\n            ans+=round;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n#row calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1; j<n;) {\\n            if(num[j++].second<num[i++].second) // start a new round, all remain elements are visited once more\\n                ans+=n-i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nNotation:\\n$/current: index of the last element be removed\\n^/target : index of the element to be removed\\n\\nStep0:\\nInit current=-1, round {of scanning}=0\\n\\nStep1: current=-1, target=3, \"1\" to be removed\\n    Since target>current, we continue this round\\n    [4, 2, 3, 1, 5]\\n  $   ---->   ^\\n    Before removed, \"1\" has been visited for 0 times. (round=0)\\nStep2: current=3, target=1, \"2\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, 2, 3, -, 5]  \\n        ^ <---$    \\n    Before removed, \"2\" has been visited for 1 times. (round=1)\\nStep3: current=1, target=2, \"3\" to be removed\\n    Since target>current, we continue this round\\n    [4, -, 3, -, 5]\\n        $->^\\n    Before removed, \"3\" has been visited for 1 times. (round=1)\\nStep4: current=2, target=0, \"4\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, -, -, -, 5]   \\n     ^ <-- $          \\n    Before removed, \"4\" has been visited for 2 times. (round=2)\\nStep5: current=0, target=4, \"5\" to be removed\\n    Since target>current, we continue this round\\n    [-, -, -, -, 5]\\n     $   ---->   ^\\n    Before removed, \"5\" has been visited for 2 times. (round=2)\\n\\nConclusion: \\n------------------------------------------------------------\\nLet us  have some statistic here. V=visit, D=Delete\\n            [4,      2,      3,      1,      5]           \\nRound 0:     V       V       V       D       V   | 4 visit, 1 delete\\nRound 1:     V       D       D       -       V   | 2 visit, 2 delete\\nRound 2:     D       -       -       -       D   | 0 visit, 2 delete\\n------------------------------------------------------------\\n         R2/2V   R1/1V   R1/1V   R0/0V   R2/2V   | 6 visit, 5 delete\\n\\nVisited before removed:\\n    Column by column:  totally 2 +1 +1+0+2=6 times\\n    Row by row:        totaly 4+2=6 times\\nDeleted:   5 elements need 5 steps.\\nThe answer is 5+6\\n\\n#update on Aprial 30 23:30 UTC+8, 2023\\nOur approach do the calculation column by column. And, it is also valid to do the calculation row by row.\\n```\n```\\n0. Initialize ROUND=0 and ANS=n\\n1. Scan the element from small to big (with sorting or something similar)\\n\\t1.1. Suppose the index of the last element is A and the index of the current element is B, increase ROUND by1 in case A>B\\n\\t2.2. ANS+=ROUND;\\n2. Return ANS.\\n\\nDone.\\n```\n```\\nRuntime: 146 ms, faster than 100.00% of C++ online submissions for Make Array Empty.\\nMemory Usage: 68.4 MB, less than 100.00% of C++ online submissions for Make Array Empty.\\n\\nTime Complexity: O(N*LogN) [for sorting or something similar]\\n```\n```\\n#column calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1, round=0; j<n; ) {\\n            round+=num[j++].second<num[i++].second;\\n            ans+=round;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n#row calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1; j<n;) {\\n            if(num[j++].second<num[i++].second) // start a new round, all remain elements are visited once more\\n                ans+=n-i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466677,
                "title": "c-fenwick-tree-with-explanation",
                "content": "Here all the elements are distinct,thus answer is equal to n(size of array) plus the number of values greater than the bigger value between any pair of adjacent values in sorted array.\\nBasically, if array is {1,5,6,2} the sorted array is {1,2,5,6} \\nNow, initially ans=4 (length of array,i.e. the step where we remove this element)\\nFirst pair of adjacent values in sorted arry is {1,2}, so ans=4+2(since there are two values 5 and 6 greater than value 2 present between these values).\\nNext pair is {2,5} ,ans=6+0 (no value greater than 5 between 2 and 5)\\nLast pair is {5,6} ans=6+0.\\nthus ans=6.\\n**NOTE**: We need count of values between smaller and greater ,not the other way around.\\n**NOTE** We only need greater values since smaller values have been removed in previous operations.\\n```\\nclass Solution {\\npublic:\\n    const int maxi=1e5+2;\\n    int sum(int v,vector<int> &BIT){\\n        int sum=0,i=v;\\n        for(;i>0;i-=i&(-i))\\n            sum+=BIT[i];\\n        return sum;\\n    }\\n    \\n    void update(int v,vector<int> &BIT){\\n        for(int i=v+1;i<maxi;i+=i&(-i))\\n            ++BIT[i];\\n    }\\n    \\nlong long countOperationsToEmptyArray(vector<int>& arr) {\\n        long long ans=arr.size();\\n        int n=arr.size();\\n    vector<int> aux(n);\\n    for(int i=0;i<n;i++) aux[i]=arr[i];\\n        sort(aux.begin(),aux.end());\\n        map<int,int>mp,pos;\\n    for(int i=0;i<n;i++) mp[aux[i]]=i+1;\\n    for(int i=0;i<n;i++) {\\n        pos[mp[arr[i]]]=i;\\n        arr[i]=mp[arr[i]];\\n        \\n                         }\\n    vector<int> BIT(maxi,0);\\n    vector<int>cnt(n,0);\\n    for(int i=0;i<n;i++){\\n        int x=sum(arr[i],BIT);\\n        cnt[i]=i-x;\\n        update(arr[i],BIT);\\n    }\\n    ans=ans+(pos[1])*1ll;\\n    for(int i=1;i<n;i++){\\n        int x=pos[i],y=pos[i+1];\\n        if(x>y){\\n            int tot=n+1-i;\\n            tot=tot-(cnt[x]-cnt[y]+1);\\n            ans=ans+tot*1ll;\\n        }\\n        else{\\n            ans=ans+(cnt[y]-cnt[x])*1ll;\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int maxi=1e5+2;\\n    int sum(int v,vector<int> &BIT){\\n        int sum=0,i=v;\\n        for(;i>0;i-=i&(-i))\\n            sum+=BIT[i];\\n        return sum;\\n    }\\n    \\n    void update(int v,vector<int> &BIT){\\n        for(int i=v+1;i<maxi;i+=i&(-i))\\n            ++BIT[i];\\n    }\\n    \\nlong long countOperationsToEmptyArray(vector<int>& arr) {\\n        long long ans=arr.size();\\n        int n=arr.size();\\n    vector<int> aux(n);\\n    for(int i=0;i<n;i++) aux[i]=arr[i];\\n        sort(aux.begin(),aux.end());\\n        map<int,int>mp,pos;\\n    for(int i=0;i<n;i++) mp[aux[i]]=i+1;\\n    for(int i=0;i<n;i++) {\\n        pos[mp[arr[i]]]=i;\\n        arr[i]=mp[arr[i]];\\n        \\n                         }\\n    vector<int> BIT(maxi,0);\\n    vector<int>cnt(n,0);\\n    for(int i=0;i<n;i++){\\n        int x=sum(arr[i],BIT);\\n        cnt[i]=i-x;\\n        update(arr[i],BIT);\\n    }\\n    ans=ans+(pos[1])*1ll;\\n    for(int i=1;i<n;i++){\\n        int x=pos[i],y=pos[i+1];\\n        if(x>y){\\n            int tot=n+1-i;\\n            tot=tot-(cnt[x]-cnt[y]+1);\\n            ans=ans+tot*1ll;\\n        }\\n        else{\\n            ans=ans+(cnt[y]-cnt[x])*1ll;\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466961,
                "title": "c-100-faster-most-optimized-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514715,
                "title": "greedy-solution-sorting-an-observation",
                "content": "# Intuition\\nTake the case when the array is sorted in descending order:\\n```\\nnums=[5,4,3,2,1]\\n```\\n1 is removed after performing = **5 operations**\\n```\\n1-> [4,3,2,1,5]\\n2-> [3,2,1,5,4]\\n3-> [2,1,5,4,3]\\n4-> [1,5,4,3,2]\\n5-> [5,4,3,2]\\n```\\n# The observation is, isn\\'t the number of steps required to remove 1 equal to the length of the array\\nFor the array: $$[5,4,3,2]$$, the steps required to remove 2 are= \\n4\\n=or current length of this array $$[5,4,3,2]$$\\n=or length of original array - numbers removed so far $$[1]$$\\n\\nThis is how the $$n-m$$ approach is used. \\nIf the array is sorted, you only need $$n$$ steps.\\nOr you first remove the numbers that are in sorted order, for ex:\\n```\\nnums1=[1,4,2,7,3,9,10]\\n```\\n\\nFor this array, perform this operation= **Place the element at the first index at the last index.**\\nAfter **2** such operations, $$nums1$$ will look like:\\n```\\n[2,7,3,9,10,1,4]\\n```\\nAfter $$nums1.length$$ steps, the array will look like the original nums1 array. The relation of this step with the steps in our question is, if the element you are sending at the last index is the minimum number in the array, you remove it, or you still perform one operation, you just don\\'t count it in the end. \\n\\nOr performing the steps mentioned in the question(removing min at first index), after nums1.length steps, nums1 will look like:\\n```\\nnums1=[4,7,9,10]\\n[1,2,3] were present in sorted order, and were removed in the nums1.length operations\\n```\\n$$m$$ is nothing but the number of elements removed.\\nIf you were to perform the operations on $$[4,7,9,10]$$, you would need 4 steps until you were back to the original configuration. Fortunately, this trimmed nums1 is sorted, and our answer is:\\n```\\nN [First rotation]+ (N - m) [Second Rotation]\\n```\\nThe value of m will keep on incrementing in the case of a reverse sorted array. Or:\\n```\\nN +   N-1  +  N-2   + N-3 ...  +1\\n```\\n\\n\\n# Approach\\nInspired from - [cpcs\\'  solution](https://leetcode.com/problems/make-array-empty/solutions/3466731/just-sort-without-any-other-tricky-data-structures/?orderBy=most_votes) \\n\\nBuild array, $$nums$$ such that:\\n```\\nint[][] nums = new int[num.length][2];\\n// for array= [4,3]\\n// [4,0], [3,1]\\n// We will sort nums so that wehave a track of the original index \\n\\nfor(int i=0;i<num.length;i++){\\n    nums[i][0]=num[i];\\n    nums[i][1]=i;\\n    }\\nArrays.sort(nums,(a,b)->a[0]-b[0]);\\n//Sorting the array, second column will have a track of original index\\n```\\nThe loop:\\n```\\nfor(int i=0;i<nums.length;i++){\\n\\n    if(i>0 && nums[i][1]<nums[i-1][1]){\\n//Whenever this happens, you need to do n-m steps to start at the original array again\\n        ans+=nums.length-m;\\n        m=i;\\n//quick way to update m is by setting it to the current index instead of counting\\n    }      \\n}\\n```\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n log n)$$ for sorting\\n\\n\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] num) {\\n        int[][] nums = new int[num.length][2];\\n        for(int i=0;i<num.length;i++){\\n            nums[i][0]=num[i];\\n            nums[i][1]=i;\\n        }\\n        Arrays.sort(nums,(a,b)->a[0]-b[0]);\\n        long ans=0;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n\\n            if(i>0 && nums[i][1]<nums[i-1][1]){\\n                ans+=nums.length-m;\\n                m=i;\\n            }      \\n        }\\n        ans+=nums.length-m;\\n        return ans; \\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = [[nums[i], i] for i in range(len(nums))]\\n        nums.sort()\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i][1] < nums[i-1][1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long countOperationsToEmptyArray(vector<int>& num) {\\n        vector<vector<int>> nums(num.size(), vector<int>(2));\\n        for(int i=0;i<num.size();i++){\\n            nums[i][0] = num[i];\\n            nums[i][1] = i;\\n        }\\n        sort(nums.begin(), nums.end(), [](vector<int>& a, vector<int>& b){return a[0] < b[0];});\\n        long ans = 0;\\n        int m = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i > 0 && nums[i][1] < nums[i-1][1]){\\n                ans += nums.size() - m;\\n                m = i;\\n            }\\n        }\\n        ans += nums.size() - m;\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nnums=[5,4,3,2,1]\\n```\n```\\n1-> [4,3,2,1,5]\\n2-> [3,2,1,5,4]\\n3-> [2,1,5,4,3]\\n4-> [1,5,4,3,2]\\n5-> [5,4,3,2]\\n```\n```\\nnums1=[1,4,2,7,3,9,10]\\n```\n```\\n[2,7,3,9,10,1,4]\\n```\n```\\nnums1=[4,7,9,10]\\n[1,2,3] were present in sorted order, and were removed in the nums1.length operations\\n```\n```\\nN [First rotation]+ (N - m) [Second Rotation]\\n```\n```\\nN +   N-1  +  N-2   + N-3 ...  +1\\n```\n```\\nint[][] nums = new int[num.length][2];\\n// for array= [4,3]\\n// [4,0], [3,1]\\n// We will sort nums so that wehave a track of the original index \\n\\nfor(int i=0;i<num.length;i++){\\n    nums[i][0]=num[i];\\n    nums[i][1]=i;\\n    }\\nArrays.sort(nums,(a,b)->a[0]-b[0]);\\n//Sorting the array, second column will have a track of original index\\n```\n```\\nfor(int i=0;i<nums.length;i++){\\n\\n    if(i>0 && nums[i][1]<nums[i-1][1]){\\n//Whenever this happens, you need to do n-m steps to start at the original array again\\n        ans+=nums.length-m;\\n        m=i;\\n//quick way to update m is by setting it to the current index instead of counting\\n    }      \\n}\\n```\n```Java []\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] num) {\\n        int[][] nums = new int[num.length][2];\\n        for(int i=0;i<num.length;i++){\\n            nums[i][0]=num[i];\\n            nums[i][1]=i;\\n        }\\n        Arrays.sort(nums,(a,b)->a[0]-b[0]);\\n        long ans=0;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n\\n            if(i>0 && nums[i][1]<nums[i-1][1]){\\n                ans+=nums.length-m;\\n                m=i;\\n            }      \\n        }\\n        ans+=nums.length-m;\\n        return ans; \\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = [[nums[i], i] for i in range(len(nums))]\\n        nums.sort()\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i][1] < nums[i-1][1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long countOperationsToEmptyArray(vector<int>& num) {\\n        vector<vector<int>> nums(num.size(), vector<int>(2));\\n        for(int i=0;i<num.size();i++){\\n            nums[i][0] = num[i];\\n            nums[i][1] = i;\\n        }\\n        sort(nums.begin(), nums.end(), [](vector<int>& a, vector<int>& b){return a[0] < b[0];});\\n        long ans = 0;\\n        int m = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i > 0 && nums[i][1] < nums[i-1][1]){\\n                ans += nums.size() - m;\\n                m = i;\\n            }\\n        }\\n        ans += nums.size() - m;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505772,
                "title": "easy-optimized-solution-using-maximum-popular-programming-languages",
                "content": "```\\nPlease Up-Vote If This Helps You !!!\\n```\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n log n)\\n\\nThe code first initializes an empty object `(map)` and assigns the length of nums to n and 0 to p. This takes constant time and space complexity `O(1)`.\\n\\nThe for loop starting from line 7 iterates over each element in nums, assigning the index of the element to the corresponding key in the map object. This takes `O(n)` time and `O(n)` space.\\n\\nThe code then sorts the nums array in ascending order using the built-in sort method. This takes `O(n log n)` time complexity.\\n\\nThe second for loop starting from line 10 iterates over each element in the sorted nums array. It first checks if the index of the current element in the map object is less than the previously encountered index p. If so, it adds the remaining unsorted elements to the answer variable. This operation takes `O(1)` time.\\n\\nOverall, the time complexity of the code is dominated by the sort method, which takes `O(n log n)` time complexity. Therefore, the overall time complexity of the code is `O(n log n)`.\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\nThe space complexity is `O(n)` because of the map object which stores the index of each element of nums, which can take up to n elements. The rest of the variables used in the code take constant space, so they do not add to the space complexity.\\n# Code\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map = {};\\n    var n = nums.length,p=0;\\n    var ans = n;\\n    for(let i = 0; i < n; i++){\\n        map[nums[i]] = i;\\n    }\\n    \\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i < n; p = map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans += n-i;\\n        }\\n    }\\n    return ans\\n};\\n```\\n```python []\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```\\n```C []\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n```\\n```Go []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```\\n```C# []\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n```\\n\\n\\n```C++ []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n```Kotlin []\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```\\n```Swift []\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```\\n```scala []\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```\\n```rust []\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n```java []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nPlease Up-Vote If This Helps You !!!\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map = {};\\n    var n = nums.length,p=0;\\n    var ans = n;\\n    for(let i = 0; i < n; i++){\\n        map[nums[i]] = i;\\n    }\\n    \\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i < n; p = map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans += n-i;\\n        }\\n    }\\n    return ans\\n};\\n```\n```python []\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```\n```C []\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n```\n```Go []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```\n```C# []\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n```\n```C++ []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```Kotlin []\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```\n```Swift []\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```\n```scala []\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```\n```rust []\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467161,
                "title": "tle-accepted-easy-approach-with-explaination",
                "content": "# Complexity\\n- Time complexity:\\nO(N log(N)) for sorting array\\n\\n- Space complexity:\\nO(N) for storing elements in hashmap\\n\\n# Code\\n```\\n//gives Time-Limit Exceeded TLE\\nclass Solution {\\npublic long countOperationsToEmptyArray(int[] nums) {\\n        //storing elements in ascending order\\n         PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\\n         for(int i=0;i<nums.length;i++){\\n             pq.offer(nums[i]);\\n         }\\n        \\n        // storing elements in queue\\n         Queue<Integer> q=new LinkedList<>();\\n         for(int i=0;i<nums.length;i++){\\n             q.offer(nums[i]);\\n         }\\n         long operation=0;\\n        //until queue is empty\\n         while(!q.isEmpty()){\\n            //if top element of pq matches with q, then pop it\\n             if(pq.peek()==q.peek()){\\n                 pq.poll();\\n                 q.poll();\\n             }\\n            //else pop it from q and add it to last of q\\n             else{\\n                 int num=q.poll();\\n                 q.offer(num);\\n             }\\n            //increase operation by 1\\n             operation++;\\n         }\\n         return operation;\\n      }\\n}\\n```\\n```\\n//accepted solution\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        //storing position of original elements\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        //sorting array in ascending order\\n        Arrays.sort(nums);\\n        long ans=nums.length;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n            int original_pos=map.get(nums[i]);\\n            //if original position of current element is less,\\n            //that means operations have been performed\\n             if(original_pos<m){\\n                ans+=(nums.length-i);\\n            }\\n            m=map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//gives Time-Limit Exceeded TLE\\nclass Solution {\\npublic long countOperationsToEmptyArray(int[] nums) {\\n        //storing elements in ascending order\\n         PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\\n         for(int i=0;i<nums.length;i++){\\n             pq.offer(nums[i]);\\n         }\\n        \\n        // storing elements in queue\\n         Queue<Integer> q=new LinkedList<>();\\n         for(int i=0;i<nums.length;i++){\\n             q.offer(nums[i]);\\n         }\\n         long operation=0;\\n        //until queue is empty\\n         while(!q.isEmpty()){\\n            //if top element of pq matches with q, then pop it\\n             if(pq.peek()==q.peek()){\\n                 pq.poll();\\n                 q.poll();\\n             }\\n            //else pop it from q and add it to last of q\\n             else{\\n                 int num=q.poll();\\n                 q.offer(num);\\n             }\\n            //increase operation by 1\\n             operation++;\\n         }\\n         return operation;\\n      }\\n}\\n```\n```\\n//accepted solution\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        //storing position of original elements\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        //sorting array in ascending order\\n        Arrays.sort(nums);\\n        long ans=nums.length;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n            int original_pos=map.get(nums[i]);\\n            //if original position of current element is less,\\n            //that means operations have been performed\\n             if(original_pos<m){\\n                ans+=(nums.length-i);\\n            }\\n            m=map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466684,
                "title": "subtract-overcount-when-wrapping-around",
                "content": "# Intuition\\nIntuition:\\nIf the problem is simplied such that the smallest number, instead of being removed, is only marked, then the solution is simply to do index sort and then suming up differences (index[i + 1] - index[i] + 1, when index[i + 1] > index[i]. or index[i + 1] + len(nums) - index[i] + 1 when index[i] > index[i + 1])\\n\\nThe additional condition that we remove the the smallest remaining number doesn\\'t change the process that much. The key difference being, when calculating index differences, we have to discount the removed indexes (index[i + 1] - index[i] + 1 - num_removed_indexes[index[i]:index[i + 1]], when index[i + 1] > index[i] )\\n\\nThe naive way of tracking all removed indexes in a boolean array would result in o(n) look up and times out as there are o(n) removes, totalling to o(n^2) complexity.\\n\\nThe key insight is that between each \\'wrapping around\\', if we calculate moves as if numbers are marked instead of removed, the overcount is always the number of indexs we removed already in previous loop. Therefore, we never have to actually deal with removed indexes until \\'wrapping around\\', during which we can easily track and query number of removed indexes in o(1). \\n\\n![IMG-0172.jpg](https://assets.leetcode.com/users/images/0ca944bf-ef4d-46e4-bf1b-4032e0253c2f_1682784289.5164747.jpeg)\\n\\nEdit: forgot about the sorting in complexity lol. o(nlgn)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sorted_index = [i[0] for i in sorted(enumerate(nums), key=lambda x:x[1])]\\n        s = 0\\n        curr = 0\\n        curr_loop_subtract = 0\\n        looped_subtract = 0\\n        for ind in sorted_index:\\n            if curr <= ind:\\n                s += ind - curr + 1\\n                curr = ind + 1\\n                curr_loop_subtract += 1\\n            else:#wrap around\\n                s += ind + (len(nums) - curr) + 1\\n                curr = ind + 1\\n                s -= looped_subtract\\n                looped_subtract += curr_loop_subtract \\n                curr_loop_subtract = 1\\n        s -= (curr - curr_loop_subtract) \\n        return s\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sorted_index = [i[0] for i in sorted(enumerate(nums), key=lambda x:x[1])]\\n        s = 0\\n        curr = 0\\n        curr_loop_subtract = 0\\n        looped_subtract = 0\\n        for ind in sorted_index:\\n            if curr <= ind:\\n                s += ind - curr + 1\\n                curr = ind + 1\\n                curr_loop_subtract += 1\\n            else:#wrap around\\n                s += ind + (len(nums) - curr) + 1\\n                curr = ind + 1\\n                s -= looped_subtract\\n                looped_subtract += curr_loop_subtract \\n                curr_loop_subtract = 1\\n        s -= (curr - curr_loop_subtract) \\n        return s\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466631,
                "title": "python-heap-fenwick-tree-o-nlogn",
                "content": "# Code\\n```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        tree = [0]*(n+1)\\n        \\n        def update(tree, i, delta):\\n            while i <= n:\\n                tree[i] += delta\\n                i += i&-i\\n        \\n        def query(tree, i):\\n            res = 0\\n            while i > 0:\\n                res += tree[i]\\n                i -= i&-i\\n            return res\\n        \\n        for i in range(n):\\n            update(tree, i+1, 1)\\n        \\n        heap = [(num, i) for i, num in enumerate(nums)]\\n        heapify(heap)\\n        i = 0\\n        res = 0\\n        while heap:\\n            v, j = heappop(heap)\\n            if j+1 > i:\\n                res +=  query(tree, j+1) - query(tree, i) \\n            else:\\n                res += query(tree, n) - query(tree, i) + query(tree, j+1)\\n            update(tree, j+1, -1)\\n            i = j + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        tree = [0]*(n+1)\\n        \\n        def update(tree, i, delta):\\n            while i <= n:\\n                tree[i] += delta\\n                i += i&-i\\n        \\n        def query(tree, i):\\n            res = 0\\n            while i > 0:\\n                res += tree[i]\\n                i -= i&-i\\n            return res\\n        \\n        for i in range(n):\\n            update(tree, i+1, 1)\\n        \\n        heap = [(num, i) for i, num in enumerate(nums)]\\n        heapify(heap)\\n        i = 0\\n        res = 0\\n        while heap:\\n            v, j = heappop(heap)\\n            if j+1 > i:\\n                res +=  query(tree, j+1) - query(tree, i) \\n            else:\\n                res += query(tree, n) - query(tree, i) + query(tree, j+1)\\n            update(tree, j+1, -1)\\n            i = j + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473659,
                "title": "using-segment-tree-to-count-operations-in-java",
                "content": "```\\nclass Solution {\\n    int[] seg;\\n    void build(int index,int start,int end){\\n        if(start==end){\\n            seg[index] = 1;\\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        build(2*index,start,mid);\\n        build(2*index+1,mid+1,end);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    int query(int index,int start,int end,int left,int right){\\n        if(left>right) return 0;\\n        if(right<start || left>end) return 0;\\n        if(left<=start && end<=right) return seg[index];\\n        int mid = (start+end)/2;\\n        int l = query(index*2,start,mid,left,right);\\n        int r = query(index*2+1,mid+1,end,left,right);\\n        return l+r;\\n    }\\n    void update(int index,int start,int end,int pos){\\n        if(pos<start || pos>end) return;\\n        if(pos==start && pos==end){\\n            seg[index] = 0; \\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        update(index*2,start,mid,pos);\\n        update(index*2+1,mid+1,end,pos);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        int[][] numsI = new int[n][2];\\n        for(int i=0; i<nums.length; i++){\\n            numsI[i][0] = nums[i];\\n            numsI[i][1] = i;\\n        }\\n        Arrays.sort(numsI,(a,b)->(a[0]-b[0]));\\n        seg = new int[4*n];\\n        build(1,0,n-1);\\n        int prev = -1;\\n        int index = 0;\\n        long ans = 0;\\n        while(index<n-1){\\n            int curIndex = numsI[index][1];\\n            if(curIndex>prev){\\n                int present = query(1,0,n-1,prev+1,curIndex-1);\\n                ans+=(present+1);\\n            }else{\\n                int present = query(1,0,n-1,prev+1,n-1);\\n                present+=query(1,0,n-1,0,curIndex-1);\\n                ans+=(present+1);\\n            }\\n            index++;\\n            update(1,0,n-1,curIndex);\\n            prev = curIndex;\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[] seg;\\n    void build(int index,int start,int end){\\n        if(start==end){\\n            seg[index] = 1;\\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        build(2*index,start,mid);\\n        build(2*index+1,mid+1,end);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    int query(int index,int start,int end,int left,int right){\\n        if(left>right) return 0;\\n        if(right<start || left>end) return 0;\\n        if(left<=start && end<=right) return seg[index];\\n        int mid = (start+end)/2;\\n        int l = query(index*2,start,mid,left,right);\\n        int r = query(index*2+1,mid+1,end,left,right);\\n        return l+r;\\n    }\\n    void update(int index,int start,int end,int pos){\\n        if(pos<start || pos>end) return;\\n        if(pos==start && pos==end){\\n            seg[index] = 0; \\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        update(index*2,start,mid,pos);\\n        update(index*2+1,mid+1,end,pos);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        int[][] numsI = new int[n][2];\\n        for(int i=0; i<nums.length; i++){\\n            numsI[i][0] = nums[i];\\n            numsI[i][1] = i;\\n        }\\n        Arrays.sort(numsI,(a,b)->(a[0]-b[0]));\\n        seg = new int[4*n];\\n        build(1,0,n-1);\\n        int prev = -1;\\n        int index = 0;\\n        long ans = 0;\\n        while(index<n-1){\\n            int curIndex = numsI[index][1];\\n            if(curIndex>prev){\\n                int present = query(1,0,n-1,prev+1,curIndex-1);\\n                ans+=(present+1);\\n            }else{\\n                int present = query(1,0,n-1,prev+1,n-1);\\n                present+=query(1,0,n-1,0,curIndex-1);\\n                ans+=(present+1);\\n            }\\n            index++;\\n            update(1,0,n-1,curIndex);\\n            prev = curIndex;\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467476,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Sorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> pos;\\n        for(int i = 0; i < n; i++) pos[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long ans = n;\\n        for(int i = 1; i < n; i++) {\\n            if(pos[nums[i]] < pos[nums[i - 1]]) ans += n - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> pos;\\n        for(int i = 0; i < n; i++) pos[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long ans = n;\\n        for(int i = 1; i < n; i++) {\\n            if(pos[nums[i]] < pos[nums[i - 1]]) ans += n - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467230,
                "title": "kotlin-o-nlogn-using-sorting",
                "content": "# Approach\\nCreate new array sortNums where `sortnums[i][0]` is each element from `nums` and `sortnums[i][1]` is its index in the original `nums`. We then sort `sortNums` by element.\\n\\nWe initialize `res` to `nums.size`, because it will take at least `nums.size` operations to delete all elements, if `nums` would have been sorted in order.\\n\\nThen traverse from 1 to last index in `sortNums`:\\n\\nIf the index (corresponding to the original sorting in `nums`) of previous is higher than current (e.g sortNums[i - 1][1] > sortNums[i][1]), then it will take `n.size - i` operations for that num to get deleted, so we add those operations to `res`.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466976,
                "title": "priority-queue-deque-brute-but-tle",
                "content": "1. We push all elemnt in priority queue to get min \\n2. We insert all element in deque for easy O(1) push_front and push_back (since we need to return count)\\n3. if first elm is min we pop from priority queue and don\\'t touch deque \\n4. else we pop from front and push it back in deque\\n5. Rest code is self explanatory ......\\n\\n```\\nlong long countOperationsToEmptyArray(vector<int>& nums) {\\n        deque<int> dq(nums.begin(), nums.end());\\n        priority_queue<int,vector<int>,greater<int> >pq(nums.begin(), nums.end());\\n        long long ans = 0;\\n        \\n        while(!dq.empty()){\\n            \\n            if(dq.front() == pq.top()){\\n                pq.pop();\\n                dq.pop_front();\\n            }\\n            else{\\n                int elem = dq.front();\\n                dq.pop_front();\\n                dq.push_back(elem);\\n            }\\n            ans++;\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long countOperationsToEmptyArray(vector<int>& nums) {\\n        deque<int> dq(nums.begin(), nums.end());\\n        priority_queue<int,vector<int>,greater<int> >pq(nums.begin(), nums.end());\\n        long long ans = 0;\\n        \\n        while(!dq.empty()){\\n            \\n            if(dq.front() == pq.top()){\\n                pq.pop();\\n                dq.pop_front();\\n            }\\n            else{\\n                int elem = dq.front();\\n                dq.pop_front();\\n                dq.push_back(elem);\\n            }\\n            ans++;\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466945,
                "title": "very-easy-and-concise-solution-with-only-sort-python",
                "content": "# Intuition\\nThe main idea was to understand how many times number will be moved to the end of list.\\nObservations:\\n1) minimun number will never be putted to the end\\n2) the next smallest element will be putted to the end only if it\\'s located before minimun\\n3) same with the thrid element - if it is located after scecond smallest it will be moved to the end only if second will be. \\nIf it is located before second smallest it will be putted to the end one more time\\n\\n# Approach\\nSo to solve the problem we just need to understand relative positions of adjusted elements of the sorted list.\\nSo we sort list by values + save their original indexes. Than we compare indexes of elements and take into account that the number of move for the following elemt equals:\\n- same number as the previous (if it\\'s located after this element)\\n- same number + 1 (if it\\'s located before elemnt)\\n- first element cnt = 0\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_ind = []\\n        for i, num in enumerate(nums):\\n            num_ind.append((num, i))\\n        \\n        num_ind.sort()\\n        \\n        count = len(num_ind)\\n        cur_cnt = 0\\n        for i in range(1, len(num_ind)):\\n            if num_ind[i][1] < num_ind[i-1][1]:\\n                cur_cnt += 1\\n            count += cur_cnt\\n        \\n        return count\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_ind = []\\n        for i, num in enumerate(nums):\\n            num_ind.append((num, i))\\n        \\n        num_ind.sort()\\n        \\n        count = len(num_ind)\\n        cur_cnt = 0\\n        for i in range(1, len(num_ind)):\\n            if num_ind[i][1] < num_ind[i-1][1]:\\n                cur_cnt += 1\\n            count += cur_cnt\\n        \\n        return count\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490150,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Performing the simulation results in TLE due to O(N<sup>2</sup>) runtime, thus for AC, we use a binary indexed tree (BIT) to accumulate the total `t` non-minimum values we \"rotate\" (dequeue from front + enqueue to back) from the input array `A` in order to dequeue each next minimum value from the front, ie. we use a map `m` to store each value\\'s index `i` and keep track of the `last` index `i` to determine if we need to wrap-around:\\n\\n* **Case 1: \\uD83D\\uDEAB wrap-around from `last` \\uD83D\\uDC49 `i`**\\n    * example: `A = [ \\uD83D\\uDEAB, \\uD83D\\uDEAB, \\uD83D\\uDEAB, last, \\u2705, \\u2705, \\u2705, i, \\uD83D\\uDEAB, \\uD83D\\uDEAB, \\uD83D\\uDEAB ]`\\n\\t* this use case is trivial, we simply accumulate the count of values between `last` non-inclusive to `i` non-inclusive\\n* **Case 2: \\u2705 wrap-around from `last` \\uD83D\\uDC49 `i`**\\n\\t* example: `A = [ \\u2705, \\u2705, \\u2705, i, \\uD83D\\uDEAB, \\uD83D\\uDEAB, \\uD83D\\uDEAB last, \\u2705, \\u2705, \\u2705 ]`\\n\\t* we accumulate the count of values between `last` non-inclusive to `N` non-inclusive *plus* the count of values between `0` inclusive to `i` non-inclusive\\n\\nWe return `N + t`, ie. each of the `N` values is dequeued once (each as a \"next minimum\" in ascending order) *plus* the total `t` \"rotations\"\\n\\n---\\n\\n*Kotlin*\\n```\\nclass BIT(A: IntArray) {\\n    var A: IntArray\\n    var S: LongArray\\n    var N: Int\\n    var prev = { i: Int -> i - (i and i.inv() + 1) }\\n    var next = { i: Int -> i + (i and i.inv() + 1) }\\n    init {\\n        this.A = A\\n        N = A.size\\n        S = LongArray(N + 1) { 0L }\\n        for (i in 0 until N) {\\n            var k = i + 1\\n            while (k <= N) {\\n                S[k] += A[i].toLong(); k = next(k)\\n            }\\n        }\\n    }\\n    fun update(i: Int, x: Int) {\\n        var diff = x - A[i]; A[i] = x\\n        var k = i + 1\\n        while (k <= N) {\\n            S[k] += diff.toLong(); k = next(k)\\n        }\\n    }\\n    fun query(i: Int): Long { return if (0 < i) S[i] + query(prev(i)) else 0L }\\n    var sum = { i: Int, j: Int -> query(j) - query(i) }  // [i..j), ie. from i inclusive to j non-inclusive\\n}\\nclass Solution {\\n    fun countOperationsToEmptyArray(A: IntArray): Long {\\n        var (N, t) = Pair(A.size, 0L)\\n        var (last, m) = Pair(-1, mutableMapOf<Int, Int>())\\n        for (i in 0 until N)\\n            m[A[i]] = i\\n        var bit = BIT(IntArray(N){ 1 })\\n        for (x in A.sorted()) {\\n            var i = m[x]!!\\n            if (last < i)\\n                t += bit.sum(last + 1, i)                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i\\n        }\\n        return N + t\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass BIT {\\n    constructor(A) {\\n        this.A = [...A];\\n        this.N = this.A.length;\\n        this.S = Array(this.N + 1).fill(0);\\n        for (let i = 0; i < this.N; ++i)\\n            for (let k = i + 1; k <= this.N; k = this.next(k))\\n                this.S[k] += this.A[i];\\n    }\\n    update = (i, x) => {\\n        let diff = x - this.A[i]; this.A[i] = x;\\n        for (let k = i + 1; k <= this.N; k = this.next(k))\\n            this.S[k] += diff;\\n    }\\n    sum = (i, j) => this.query(j) - this.query(i);  // [i..j) ie. from i inclusive to j non-inclusive\\n    query = i => i ? this.S[i] + this.query(this.prev(i)) : 0;\\n    prev = i => i - (i & ~i + 1);\\n    next = i => i + (i & ~i + 1);\\n}\\nlet countOperationsToEmptyArray = (A, last = -1, t = 0) => {\\n    let N = A.length;\\n    let bit = new BIT(Array(N).fill(1));\\n    let m = new Map(A.map((x, i) => [x, i]));\\n    for (let x of A.sort((a, b) => a - b)) {\\n        let i = m.get(x);\\n        if (last < i)\\n            t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n        else\\n            t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n        bit.update(i, 0), last = i;\\n    }\\n    return N + t;\\n};\\n```\\n\\n*Python3*\\n```\\nclass BIT:\\n    def __init__(self, A: List[int]):\\n        self.N = len(A)\\n        self.A, self.S = A[:], [0] * (self.N + 1)\\n        for i in range(self.N):\\n            k = i + 1\\n            while k <= self.N:\\n                self.S[k] += self.A[i]\\n                k = self.next(k)\\n\\n    def update(self, i: int, x: int) -> None:\\n        diff, self.A[i] = x - self.A[i], x\\n        k = i + 1\\n        while k <= self.N:\\n            self.S[k] += diff\\n            k = self.next(k)\\n\\n    sum = lambda self, i, j: self.query(j) - self.query(i)  # [i..j) ie. from i inclusive to j non-inclusive\\n    query = lambda self, i: self.S[i] + self.query(self.prev(i)) if i else 0\\n    prev = lambda self, i: i - (i & -i)\\n    next = lambda self, i: i + (i & -i)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int], last = -1, t = 0) -> int:\\n        N = len(A)\\n        bit = BIT([1] * N)\\n        m = {x: i for i, x in enumerate(A)}\\n        for x in sorted(A):\\n            i = m[x]\\n            if last < i:\\n                t += bit.sum(last + 1, i)                  # case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else:\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  # case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i            \\n        return N + t\\n```\\n\\n*C++*\\n```\\nusing LL = long long;\\nusing VI = vector<int>;\\nusing VL = vector<LL>;\\nclass BIT {\\n    VI A; VL S; size_t N;\\n    int prev(int i) { return i - (i & -i); }\\n    int next(int i) { return i + (i & -i); }\\n    LL query(int i) { return i ? S[i] + query(prev(i)) : 0; }\\npublic:\\n    BIT(VI&& A) : A{ A }, S{ VL(A.size() + 1) }, N{ A.size() } {\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ i + 1 }; k <= N; k = next(k))\\n                S[k] += A[i];\\n    }\\n    void update(int i, int x) {\\n        auto diff = x - A[i]; A[i] = x;\\n        for (auto k{ i + 1 }; k <= N; k = next(k))\\n            S[k] += diff;\\n    }\\n    LL sum(int i, int j) { return query(j) - query(i); }  // [i..j) ie. from i inclusive to j non-inclusive\\n};\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    LL countOperationsToEmptyArray(VI& A, Map m = {}, int last = -1, LL t = 0) {\\n        auto N = A.size();\\n        BIT bit(VI(N, 1));\\n        for (auto i{ 0 }; i < N; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (auto x: A) {\\n            auto i = m[x];\\n            if (last < i)\\n                t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0), last = i;\\n        }\\n        return N + t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BIT(A: IntArray) {\\n    var A: IntArray\\n    var S: LongArray\\n    var N: Int\\n    var prev = { i: Int -> i - (i and i.inv() + 1) }\\n    var next = { i: Int -> i + (i and i.inv() + 1) }\\n    init {\\n        this.A = A\\n        N = A.size\\n        S = LongArray(N + 1) { 0L }\\n        for (i in 0 until N) {\\n            var k = i + 1\\n            while (k <= N) {\\n                S[k] += A[i].toLong(); k = next(k)\\n            }\\n        }\\n    }\\n    fun update(i: Int, x: Int) {\\n        var diff = x - A[i]; A[i] = x\\n        var k = i + 1\\n        while (k <= N) {\\n            S[k] += diff.toLong(); k = next(k)\\n        }\\n    }\\n    fun query(i: Int): Long { return if (0 < i) S[i] + query(prev(i)) else 0L }\\n    var sum = { i: Int, j: Int -> query(j) - query(i) }  // [i..j), ie. from i inclusive to j non-inclusive\\n}\\nclass Solution {\\n    fun countOperationsToEmptyArray(A: IntArray): Long {\\n        var (N, t) = Pair(A.size, 0L)\\n        var (last, m) = Pair(-1, mutableMapOf<Int, Int>())\\n        for (i in 0 until N)\\n            m[A[i]] = i\\n        var bit = BIT(IntArray(N){ 1 })\\n        for (x in A.sorted()) {\\n            var i = m[x]!!\\n            if (last < i)\\n                t += bit.sum(last + 1, i)                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i\\n        }\\n        return N + t\\n    }\\n}\\n```\n```\\nclass BIT {\\n    constructor(A) {\\n        this.A = [...A];\\n        this.N = this.A.length;\\n        this.S = Array(this.N + 1).fill(0);\\n        for (let i = 0; i < this.N; ++i)\\n            for (let k = i + 1; k <= this.N; k = this.next(k))\\n                this.S[k] += this.A[i];\\n    }\\n    update = (i, x) => {\\n        let diff = x - this.A[i]; this.A[i] = x;\\n        for (let k = i + 1; k <= this.N; k = this.next(k))\\n            this.S[k] += diff;\\n    }\\n    sum = (i, j) => this.query(j) - this.query(i);  // [i..j) ie. from i inclusive to j non-inclusive\\n    query = i => i ? this.S[i] + this.query(this.prev(i)) : 0;\\n    prev = i => i - (i & ~i + 1);\\n    next = i => i + (i & ~i + 1);\\n}\\nlet countOperationsToEmptyArray = (A, last = -1, t = 0) => {\\n    let N = A.length;\\n    let bit = new BIT(Array(N).fill(1));\\n    let m = new Map(A.map((x, i) => [x, i]));\\n    for (let x of A.sort((a, b) => a - b)) {\\n        let i = m.get(x);\\n        if (last < i)\\n            t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n        else\\n            t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n        bit.update(i, 0), last = i;\\n    }\\n    return N + t;\\n};\\n```\n```\\nclass BIT:\\n    def __init__(self, A: List[int]):\\n        self.N = len(A)\\n        self.A, self.S = A[:], [0] * (self.N + 1)\\n        for i in range(self.N):\\n            k = i + 1\\n            while k <= self.N:\\n                self.S[k] += self.A[i]\\n                k = self.next(k)\\n\\n    def update(self, i: int, x: int) -> None:\\n        diff, self.A[i] = x - self.A[i], x\\n        k = i + 1\\n        while k <= self.N:\\n            self.S[k] += diff\\n            k = self.next(k)\\n\\n    sum = lambda self, i, j: self.query(j) - self.query(i)  # [i..j) ie. from i inclusive to j non-inclusive\\n    query = lambda self, i: self.S[i] + self.query(self.prev(i)) if i else 0\\n    prev = lambda self, i: i - (i & -i)\\n    next = lambda self, i: i + (i & -i)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int], last = -1, t = 0) -> int:\\n        N = len(A)\\n        bit = BIT([1] * N)\\n        m = {x: i for i, x in enumerate(A)}\\n        for x in sorted(A):\\n            i = m[x]\\n            if last < i:\\n                t += bit.sum(last + 1, i)                  # case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else:\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  # case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i            \\n        return N + t\\n```\n```\\nusing LL = long long;\\nusing VI = vector<int>;\\nusing VL = vector<LL>;\\nclass BIT {\\n    VI A; VL S; size_t N;\\n    int prev(int i) { return i - (i & -i); }\\n    int next(int i) { return i + (i & -i); }\\n    LL query(int i) { return i ? S[i] + query(prev(i)) : 0; }\\npublic:\\n    BIT(VI&& A) : A{ A }, S{ VL(A.size() + 1) }, N{ A.size() } {\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ i + 1 }; k <= N; k = next(k))\\n                S[k] += A[i];\\n    }\\n    void update(int i, int x) {\\n        auto diff = x - A[i]; A[i] = x;\\n        for (auto k{ i + 1 }; k <= N; k = next(k))\\n            S[k] += diff;\\n    }\\n    LL sum(int i, int j) { return query(j) - query(i); }  // [i..j) ie. from i inclusive to j non-inclusive\\n};\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    LL countOperationsToEmptyArray(VI& A, Map m = {}, int last = -1, LL t = 0) {\\n        auto N = A.size();\\n        BIT bit(VI(N, 1));\\n        for (auto i{ 0 }; i < N; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (auto x: A) {\\n            auto i = m[x];\\n            if (last < i)\\n                t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0), last = i;\\n        }\\n        return N + t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468984,
                "title": "using-map-and-sorting-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int>m;\\n        int n=A.size();\\n        long long ans=n;\\n        for (int i = 0; i < n; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (m[A[i]] < m[A[i - 1]])\\n                ans += n - i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int>m;\\n        int n=A.size();\\n        long long ans=n;\\n        for (int i = 0; i < n; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (m[A[i]] < m[A[i - 1]])\\n                ans += n - i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467830,
                "title": "swift-analyze-indexed-sort",
                "content": "**Analyze Indexed Sort (accepted answer)**\\n```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467350,
                "title": "beats-100-simple-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        q=[]\\n        for i,j in enumerate(nums):\\n            q.append([j,i])\\n        q.sort()\\n        n=len(nums)\\n        ans=n\\n        for i in range(1,len(nums)):\\n            if(q[i][1]<q[i-1][1]):\\n                ans+=(n-i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        q=[]\\n        for i,j in enumerate(nums):\\n            q.append([j,i])\\n        q.sort()\\n        n=len(nums)\\n        ans=n\\n        for i in range(1,len(nums)):\\n            if(q[i][1]<q[i-1][1]):\\n                ans+=(n-i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467030,
                "title": "100-simple-sort-o-nlogn-using-only-if-statements",
                "content": "# Approach\\nSort in ascending order of the element values. Then, for each pair in the sorted vector, I keep track of two variables: \"sum\" and \"cnt\". I initialize \"sum\" to the size of the input array and \"cnt\" to 1.\\n\\nI then check whether the current element\\'s index is greater than the previous element\\'s index. If it is, I increment \"cnt\" to count another element whose value is equal to its index. If not, I add the number of remaining elements in the array to \"sum\" (which is equal to the total size of the array minus \"cnt\"), and increment \"cnt\" to count this element.\\n\\nFinally, \"sum\" contains the number of operations needed to empty the array, which is returned by the code. Overall, this implementation is more optimized than the original one as it avoids using a priority queue, which has a higher overhead than a simple vector.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    typedef long long ll;    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int nn = nums.size();\\n        ll n = (ll)nn;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums[i],i});\\n        }\\n        sort(vec.begin(),vec.end());\\n        ll sum = n;\\n        ll cnt = 1LL;\\n        for(int i=1;i<nn;i++){\\n            if(vec[i].second > vec[i-1].second){\\n                cnt++;                \\n            }\\n            else{\\n                sum += (ll)(n-cnt);\\n                cnt++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    typedef long long ll;    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int nn = nums.size();\\n        ll n = (ll)nn;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums[i],i});\\n        }\\n        sort(vec.begin(),vec.end());\\n        ll sum = n;\\n        ll cnt = 1LL;\\n        for(int i=1;i<nn;i++){\\n            if(vec[i].second > vec[i-1].second){\\n                cnt++;                \\n            }\\n            else{\\n                sum += (ll)(n-cnt);\\n                cnt++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467007,
                "title": "c-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*log(n))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> x(n);\\n        for (int i=0;i<n;i++) {\\n            x[i]=i;\\n        }\\n        sort(x.begin(), x.end(),[&](int a,int b) {\\n            return nums[a]<nums[b];\\n        });\\n        int m=n,l=0;\\n        long long ans=0;\\n        for (int i=1;i<n;i++) {\\n            if(x[i]<x[i-1]){\\n                ans+=m;\\n                m-=i-l;\\n                l=i; \\n            }\\n        }\\n        return ans+m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> x(n);\\n        for (int i=0;i<n;i++) {\\n            x[i]=i;\\n        }\\n        sort(x.begin(), x.end(),[&](int a,int b) {\\n            return nums[a]<nums[b];\\n        });\\n        int m=n,l=0;\\n        long long ans=0;\\n        for (int i=1;i<n;i++) {\\n            if(x[i]<x[i-1]){\\n                ans+=m;\\n                m-=i-l;\\n                l=i; \\n            }\\n        }\\n        return ans+m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466958,
                "title": "c-intution-o-n-logn-easy-to-understand-segment-tree",
                "content": "Intution :- Don\\'t rotate the array just keep track of previous smaller element\\'s index\\nand current smaller element index (using map) and find remaining elements between them. For which we can use segment tree.\\n\\nThere are two cases :-\\n1.When previous elements index(a) is smaller than current element\\'s index(b)-\\n  find remaining element between a and b ( query from index a to b)\\n2.else :-\\n   find remaining element between 0 to b and a to nums.size() and add them.\\n   \\n Note:- Find elements in exclusive manner \\n\\nTC-O(n*logn)\\nSC-O(4*n)\\n\\n```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> st;\\n\\n    void build(int i, int l, int h)\\n    {\\n        if (l == h)\\n        {\\n            st[i] = 1;\\n            return;\\n        }\\n        int md = (l + h) / 2;\\n        build(2 * i + 1, l, md);\\n        build(2 * i + 2, md + 1, h);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n    int query(int i, int l, int h, int rl, int rh)\\n    {\\n        if (rl > rh)\\n            return 0;\\n        if (l >= rl && h <= rh)\\n            return st[i];\\n        if (l > rh || h < rl)\\n            return 0;\\n        int md = (l + h) / 2;\\n        return query(2 * i + 1, l, md, rl, rh) + query(2 * i + 2, md + 1, h, rl, rh);\\n    }\\n    void update(int i, int l, int h, int id)\\n    {\\n\\n        if (id == l && id == h)\\n        {\\n            st[i] = 0;\\n            return;\\n        }\\n        int m = (l + h) / 2;\\n        if (id <= m)\\n            update(2 * i + 1, l, m, id);\\n        else\\n            update(2 * i + 2, m + 1, h, id);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n\\n    long long countOperationsToEmptyArray(vector<int> &nums)\\n    {\\n        map<int, int> mp;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]] = i;\\n        int c = -1;\\n        int n = nums.size();\\n        auto it = mp.begin();\\n        long long ans = 0;\\n        st.resize(4 * nums.size());\\n        build(0, 0, nums.size() - 1);\\n        while (n > 1 && it != mp.end())\\n        {\\n\\n            if (it->second >= c)\\n            {\\n                int x = query(0, 0, nums.size() - 1, c + 1, it->second - 1);\\n                ans += x + 1;\\n            }\\n\\n            else\\n            {\\n                // ans+=(n+1)-c+it->second+1;\\n                int x = query(0, 0, nums.size() - 1, 0, it->second - 1);\\n                int y = query(0, 0, nums.size() - 1, c + 1, nums.size() - 1);\\n                ans += x + y + 1;\\n            }\\n            update(0, 0, nums.size() - 1, it->second);\\n            c = it->second;\\n            n--;\\n            it++;\\n           \\n        }\\n    \\n        return ans + 1;\\n    }\\n};\\n\\n```\\n\\nIf you like it then please upvote!",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> st;\\n\\n    void build(int i, int l, int h)\\n    {\\n        if (l == h)\\n        {\\n            st[i] = 1;\\n            return;\\n        }\\n        int md = (l + h) / 2;\\n        build(2 * i + 1, l, md);\\n        build(2 * i + 2, md + 1, h);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n    int query(int i, int l, int h, int rl, int rh)\\n    {\\n        if (rl > rh)\\n            return 0;\\n        if (l >= rl && h <= rh)\\n            return st[i];\\n        if (l > rh || h < rl)\\n            return 0;\\n        int md = (l + h) / 2;\\n        return query(2 * i + 1, l, md, rl, rh) + query(2 * i + 2, md + 1, h, rl, rh);\\n    }\\n    void update(int i, int l, int h, int id)\\n    {\\n\\n        if (id == l && id == h)\\n        {\\n            st[i] = 0;\\n            return;\\n        }\\n        int m = (l + h) / 2;\\n        if (id <= m)\\n            update(2 * i + 1, l, m, id);\\n        else\\n            update(2 * i + 2, m + 1, h, id);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n\\n    long long countOperationsToEmptyArray(vector<int> &nums)\\n    {\\n        map<int, int> mp;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]] = i;\\n        int c = -1;\\n        int n = nums.size();\\n        auto it = mp.begin();\\n        long long ans = 0;\\n        st.resize(4 * nums.size());\\n        build(0, 0, nums.size() - 1);\\n        while (n > 1 && it != mp.end())\\n        {\\n\\n            if (it->second >= c)\\n            {\\n                int x = query(0, 0, nums.size() - 1, c + 1, it->second - 1);\\n                ans += x + 1;\\n            }\\n\\n            else\\n            {\\n                // ans+=(n+1)-c+it->second+1;\\n                int x = query(0, 0, nums.size() - 1, 0, it->second - 1);\\n                int y = query(0, 0, nums.size() - 1, c + 1, nums.size() - 1);\\n                ans += x + y + 1;\\n            }\\n            update(0, 0, nums.size() - 1, it->second);\\n            c = it->second;\\n            n--;\\n            it++;\\n           \\n        }\\n    \\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466827,
                "title": "easy-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfirst we have to store all element index position ,that\\'s why we make vector of pair int ,int.\\nafter that we sort , so that all element are arrange ascending order. atleast one element , so cnt start with 1.\\nj=2 because i start with less 2 index.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512113,
                "title": "javascript-segment-tree",
                "content": "**Solution: Segment Tree**\\n\\nWe can think of it as a circular array.\\nThe order of the numbers will always stay the same in a circular sense. \\nThis means the distance between numbers will always stay the same except for when numbers are removed (even then the order stays the same).\\nBased on this understanding, instead of simulating moving the actual element around, we can count the number of moves by the differences in the sorted indexes.\\nThe distance between two numbers `(a, b)` will always be the same, with the two possible orders:\\n*   If `a` is in front of `b`: Distance is `b - a`\\n*   If `b` is in front of `a`: Distance is `(n-1 - b) + (a)`\\n\\nSort nums and map each `nums[i]` to the index in the sorted array.\\nFill the segment tree with `1`\\'s initially.\\nGo through each sorted `nums[i]` and get the distance difference with the previous index.\\n*   If `index > previousIndex`, count the sum in range `(previous index + 1, index)`.\\n*   If `index < previousIndex`, count the sum in range `(previous index + 1, n - 1)` + sum in range `(0, index)`\\n\\nAfter each `nums[i]`, update the element in the segment tree to be `0` to indicate removal.\\n\\nTime Complexity: `O(n log(n))` 399ms\\nSpace Complexity: `O(n)` 95.3MB\\n```\\nvar countOperationsToEmptyArray = function(nums) {\\n  let n = nums.length, segTree = new SegmentTree(Array(n).fill(1));\\n  nums = nums.map((num, index) => [num, index]).sort((a, b) => a[0] - b[0]);\\n  let prevIndex = -1, ans = 0;\\n  for (let [_num, index] of nums) {\\n    if (index >= prevIndex) {\\n      ans += segTree.sumRange(prevIndex + 1, index);\\n    } else {\\n      ans += segTree.sumRange(prevIndex + 1, n - 1) + segTree.sumRange(0, index);\\n    }\\n    segTree.update(index);\\n    prevIndex = index;\\n  }\\n  return ans;\\n};\\n\\nclass SegmentTree {\\n  constructor(arr) {\\n    let n = arr.length;\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n    this.build(arr);\\n  }\\n  build(arr) {\\n    let n = this.size;\\n    for (let i = n; i < n * 2; i++) {\\n      this.segTree[i] = arr[i - n]; // populate leaf values\\n    }\\n    for (let i = n - 1; i > 0; i--) {\\n      this.segTree[i] = this.segTree[i * 2] + this.segTree[i * 2 + 1]; // sum\\n    }\\n  }\\n  update(index) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] = 0;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  sumRange(left, right) {\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar countOperationsToEmptyArray = function(nums) {\\n  let n = nums.length, segTree = new SegmentTree(Array(n).fill(1));\\n  nums = nums.map((num, index) => [num, index]).sort((a, b) => a[0] - b[0]);\\n  let prevIndex = -1, ans = 0;\\n  for (let [_num, index] of nums) {\\n    if (index >= prevIndex) {\\n      ans += segTree.sumRange(prevIndex + 1, index);\\n    } else {\\n      ans += segTree.sumRange(prevIndex + 1, n - 1) + segTree.sumRange(0, index);\\n    }\\n    segTree.update(index);\\n    prevIndex = index;\\n  }\\n  return ans;\\n};\\n\\nclass SegmentTree {\\n  constructor(arr) {\\n    let n = arr.length;\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n    this.build(arr);\\n  }\\n  build(arr) {\\n    let n = this.size;\\n    for (let i = n; i < n * 2; i++) {\\n      this.segTree[i] = arr[i - n]; // populate leaf values\\n    }\\n    for (let i = n - 1; i > 0; i--) {\\n      this.segTree[i] = this.segTree[i * 2] + this.segTree[i * 2 + 1]; // sum\\n    }\\n  }\\n  update(index) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] = 0;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  sumRange(left, right) {\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474910,
                "title": "idiomatic-kotlin-with-comments-o-nlog-n-bonus-java-streams",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$ required to sort `nums`.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Kotlin Code\\n```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray) =\\n        nums.size + // Number of remove operations we need to perform anyway\\n            nums.withIndex() // Map to pairs index:value\\n                .sortedBy { it.value } // Sort ascending by value\\n                .map { it.index } // Keep indices, drop values\\n                .windowed(size=2) // Slide window of size 2 and step 1\\n                .withIndex() // Map to pairs index:window\\n                // Ignore windows where lower element stands before \\n                // next bigger element.\\n                .filter { it.value[0] > it.value[1] }\\n                // Add number of shifts required to reach next element\\n                .map { nums.size - it.index - 1L }\\n                .sum() // Sum all shifts\\n}\\n\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int[] indices = IntStream.range(0, nums.length)\\n                .mapToObj(i -> new int[]{i, nums[i]})\\n                .sorted(Comparator.comparingInt(a -> a[1]))\\n                .mapToInt(a -> a[0])\\n                .toArray();\\n\\n        return nums.length + IntStream.range(1, indices.length)\\n                .filter(i -> indices[i - 1] > indices[i])\\n                .mapToLong(i -> nums.length - i)\\n                .sum();    \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Sort",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray) =\\n        nums.size + // Number of remove operations we need to perform anyway\\n            nums.withIndex() // Map to pairs index:value\\n                .sortedBy { it.value } // Sort ascending by value\\n                .map { it.index } // Keep indices, drop values\\n                .windowed(size=2) // Slide window of size 2 and step 1\\n                .withIndex() // Map to pairs index:window\\n                // Ignore windows where lower element stands before \\n                // next bigger element.\\n                .filter { it.value[0] > it.value[1] }\\n                // Add number of shifts required to reach next element\\n                .map { nums.size - it.index - 1L }\\n                .sum() // Sum all shifts\\n}\\n\\n```\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int[] indices = IntStream.range(0, nums.length)\\n                .mapToObj(i -> new int[]{i, nums[i]})\\n                .sorted(Comparator.comparingInt(a -> a[1]))\\n                .mapToInt(a -> a[0])\\n                .toArray();\\n\\n        return nums.length + IntStream.range(1, indices.length)\\n                .filter(i -> indices[i - 1] > indices[i])\\n                .mapToLong(i -> nums.length - i)\\n                .sum();    \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469261,
                "title": "ruby-o-nlogn-sort-one-pass",
                "content": "# Intuition\\nPerforming `nums.size` operations will retain the array order with some values removed. Counting the number of such cycles and the number of values removed will provide the answer.\\n \\n**Observations:**\\n1. Actual nums value doesn\\'t matter till the order of the elements is the same. `[3, 4, -1]` and `[3, 54, 0]` both will need 5 operations.\\n2. When performing the operation on the `k` smallest element in the array it will be removed only if `1..(k-1)` smallest elements are removed from the array. Since this rule is applied to all elements, it\\'s enough to know if `k-1` smallest element is already removed.\\n3. `k-1` and `k` smallest elements will be removed in the single cycle run if and only if the first one has a lower index in the array.\\n\\n# Approach\\n1. Convert array elements to their relative indexes in the sorted array\\n2. Pass through the array, memorizing if the previous element(in sorted order) has been already chosen for the cycle.\\n3. Count the number of cycles and number of elements\\n\\n# Example\\nLet\\'s check `[12, 42, 61, 58, 27, 33]`\\n1. Converting to the sorted indexes: `[1, 4, 6, 5, 2, 3]`\\n2. Passing using the code below will result in `[1, 4, 6, 4, 1, 1]`. Counting occurrences returns `{ 1 => 3, 4 => 2, 6 => 1 }`\\n3. First cycle will remove elements `12, 27, 33` and will take 6 operations. Second will remove `42, 58` in 3 operations. Last operation will remove 61 and make array empty. Total `6 + 3 + 1 = 10` operations. \\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef count_operations_to_empty_array(nums)\\n    pos_map = nums.sort.map.with_index { [_1, _2 + 1] }.to_h # Using 1-indexed positions so I don\\'t have to deal with negative index later\\n    nums_pos = nums.map { pos_map[_1] }\\n        \\n    mem = Array.new(nums.size + 1, nil)\\n    nums_pos.each do |pos|\\n        mem[pos] = mem[pos - 1] || pos\\n    end\\n    mem.shift\\n    \\n    res = 0\\n\\n    s = nums.size\\n    mem.tally.values.each do |val|\\n        res += s\\n        s -= val\\n    end\\n    \\n    res\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Sort"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef count_operations_to_empty_array(nums)\\n    pos_map = nums.sort.map.with_index { [_1, _2 + 1] }.to_h # Using 1-indexed positions so I don\\'t have to deal with negative index later\\n    nums_pos = nums.map { pos_map[_1] }\\n        \\n    mem = Array.new(nums.size + 1, nil)\\n    nums_pos.each do |pos|\\n        mem[pos] = mem[pos - 1] || pos\\n    end\\n    mem.shift\\n    \\n    res = 0\\n\\n    s = nums.size\\n    mem.tally.values.each do |val|\\n        res += s\\n        s -= val\\n    end\\n    \\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3467574,
                "title": "c-sort-then-count-out-of-order",
                "content": "1. sort indices according to indexed values\\n2. iterate sorted indices, \\n    - if in natural order, e.g. 0,1,2,3: just remove\\n    - otherwise, e.g 4,2: count and accumulate out of order\\n    - for each iterated index, current count is steps it needs to rotate.\\n3. finally add array size to the final steps, as we need to remove each once\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices(nums.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&nums](auto i, auto j) { return nums[i] < nums[j]; });\\n        long long steps = 0;\\n        for(int i = 0, j = 1, dec = 0; j < indices.size(); ++i, ++j) {\\n            if(indices[j] < indices[i])\\n                ++dec;\\n            steps += dec;\\n        }\\n        return steps + nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices(nums.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&nums](auto i, auto j) { return nums[i] < nums[j]; });\\n        long long steps = 0;\\n        for(int i = 0, j = 1, dec = 0; j < indices.size(); ++i, ++j) {\\n            if(indices[j] < indices[i])\\n                ++dec;\\n            steps += dec;\\n        }\\n        return steps + nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467540,
                "title": "fenwick-tree-o-nlogn-c",
                "content": "# Approach\\nThis is a Fenwick Tree based where I used Fenwick Tree to count the number of elements to be sent at the back of the array if i am currently at `c` and want to remove index `nxt[i]`, `nxt[i]` represents the index of ith smallest element in the array.\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define fi first\\n#define se second\\n#define pb push_back\\n#define ppb pop_back\\n#define all(a) a.begin(),a.end()\\nusing ll = long long;\\nusing vi = vector<int>;\\nusing vl = vector<ll>;\\nusing vb = vector<bool>;\\nusing pii = pair<int,int>;\\nusing pll = pair<ll,ll>;\\nconst int MOD = 1e9 + 7;\\nconst int iinf = 1e9;\\nll mod_a(ll a,ll b){a%=MOD;b%=MOD;return((a+b)%MOD);}\\nll mod_m(ll a,ll b){a%=MOD;b%=MOD;return((a*b)%MOD);}\\nll pow_m(ll a,ll b){a%=MOD;b%=(MOD-1);ll r = 1;\\nwhile(b){if(b&1){r=mod_m(r,a);}a=mod_m(a,a);b/=2;}return r;}\\nll mod_i(ll a){return pow_m(a,MOD-2);}\\nll mod_d(ll a,ll b){return mod_m(a,mod_i(b));}\\nll mod_s(ll a,ll b){a%=MOD;b%=MOD;return((((a-b)%MOD)+MOD)%MOD);}\\n\\nstruct Ftree{\\n    vl t; int n;\\n    Ftree(int _n) : n(_n + 1){\\n        t.assign(n, 0);\\n    }\\n    void U(int i,ll v){\\n        for(i++;i<n;i+=(i&-i))\\n            t[i] += v;\\n    }\\n    ll q(int i){\\n        int r = 0;\\n        for(i++;i>0;i-=(i&-i))r += t[i];\\n        return r;\\n    }\\n    ll Q(int l,int r){\\n        if(l>r)return 0;\\n        return q(r) - q(l-1);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size(), c = 0;\\n        vector<vi> S; vi nxI(n);\\n        for(int i=0;i<n;i++)S.pb({nums[i], i});\\n        sort(all(S));\\n        for(int i=0;i<n;i++)nxI[i] = S[i][1];\\n        Ftree Ft(n);\\n        for(int i=0;i<n;i++)Ft.U(i, 1);\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(nxI[i]>=c){\\n                ans += Ft.Q(c, nxI[i]);\\n            }else{\\n                ans += Ft.Q(c, n-1);\\n                ans += Ft.Q(0, nxI[i]);\\n            }\\n            c = nxI[i];\\n            Ft.U(nxI[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n#define fi first\\n#define se second\\n#define pb push_back\\n#define ppb pop_back\\n#define all(a) a.begin(),a.end()\\nusing ll = long long;\\nusing vi = vector<int>;\\nusing vl = vector<ll>;\\nusing vb = vector<bool>;\\nusing pii = pair<int,int>;\\nusing pll = pair<ll,ll>;\\nconst int MOD = 1e9 + 7;\\nconst int iinf = 1e9;\\nll mod_a(ll a,ll b){a%=MOD;b%=MOD;return((a+b)%MOD);}\\nll mod_m(ll a,ll b){a%=MOD;b%=MOD;return((a*b)%MOD);}\\nll pow_m(ll a,ll b){a%=MOD;b%=(MOD-1);ll r = 1;\\nwhile(b){if(b&1){r=mod_m(r,a);}a=mod_m(a,a);b/=2;}return r;}\\nll mod_i(ll a){return pow_m(a,MOD-2);}\\nll mod_d(ll a,ll b){return mod_m(a,mod_i(b));}\\nll mod_s(ll a,ll b){a%=MOD;b%=MOD;return((((a-b)%MOD)+MOD)%MOD);}\\n\\nstruct Ftree{\\n    vl t; int n;\\n    Ftree(int _n) : n(_n + 1){\\n        t.assign(n, 0);\\n    }\\n    void U(int i,ll v){\\n        for(i++;i<n;i+=(i&-i))\\n            t[i] += v;\\n    }\\n    ll q(int i){\\n        int r = 0;\\n        for(i++;i>0;i-=(i&-i))r += t[i];\\n        return r;\\n    }\\n    ll Q(int l,int r){\\n        if(l>r)return 0;\\n        return q(r) - q(l-1);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size(), c = 0;\\n        vector<vi> S; vi nxI(n);\\n        for(int i=0;i<n;i++)S.pb({nums[i], i});\\n        sort(all(S));\\n        for(int i=0;i<n;i++)nxI[i] = S[i][1];\\n        Ftree Ft(n);\\n        for(int i=0;i<n;i++)Ft.U(i, 1);\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(nxI[i]>=c){\\n                ans += Ft.Q(c, nxI[i]);\\n            }else{\\n                ans += Ft.Q(c, n-1);\\n                ans += Ft.Q(0, nxI[i]);\\n            }\\n            c = nxI[i];\\n            Ft.U(nxI[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467430,
                "title": "bitch-ez-bit-sol",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums) -> int:\\n        mp=defaultdict(int)\\n        for id,i in enumerate(nums):\\n            mp[i]=id\\n        n=len(nums)\\n        bt=BIT(n)\\n        for i in range(n):\\n            bt.update(i,1)\\n        last=-1\\n        ans=0\\n        for i in sorted(nums):\\n            li=0\\n            bt.update(mp[i],-1)\\n            if last==-1:\\n                ans+=bt.sum(mp[i])+1\\n                last=mp[i]\\n            elif last<mp[i]:\\n                ans+=bt.sum(mp[i])-bt.sum(last)+1\\n                last=mp[i]\\n            elif last>mp[i]:\\n                li=bt.sum(n-1)-bt.sum(last)\\n                ans+=bt.sum(mp[i])+li+1\\n                last=mp[i]\\n                \\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums) -> int:\\n        mp=defaultdict(int)\\n        for id,i in enumerate(nums):\\n            mp[i]=id\\n        n=len(nums)\\n        bt=BIT(n)\\n        for i in range(n):\\n            bt.update(i,1)\\n        last=-1\\n        ans=0\\n        for i in sorted(nums):\\n            li=0\\n            bt.update(mp[i],-1)\\n            if last==-1:\\n                ans+=bt.sum(mp[i])+1\\n                last=mp[i]\\n            elif last<mp[i]:\\n                ans+=bt.sum(mp[i])-bt.sum(last)+1\\n                last=mp[i]\\n            elif last>mp[i]:\\n                li=bt.sum(n-1)-bt.sum(last)\\n                ans+=bt.sum(mp[i])+li+1\\n                last=mp[i]\\n                \\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467335,
                "title": "python-explanation-modulo-arithmetics-plus-binary-indexed-tree",
                "content": "# Intuition\\nYou cannot simply simulate the process with a deque, because at each step you could traverse the whole array (~n steps) and there would be `n` steps for each removal leading to $$O(n^2)$$\\n\\n# Approach\\nThe idea is to sort the numbers, while keeping their indices. Then visit each number in the increasing order and smartly calculate how many steps would be there **without actually doing these steps**\\n\\n# Without accounting for removal:\\nSo at the beginning we start at position `curPos = 0` and we need to reach the index `pos` of the smallest number. Easy, just subtract `pos - 0`. Likewise, if we start at any other position `curPos` we just take `pos - curPos` as the distance to travel. If we run off the array `nums` we just do it modulo `n` arithmetics: `steps = (n + pos - curPos) % n`.\\n\\n# Accounting for removed elements in the array:\\nThis is all true as long as we didn\\'t remove any numbers from the array. But we do! At every step we remove exactly one number. So to know how many `nums` indices have been removed we can keep a prefix array `prefSum[i]` which keeps the number of removed indices at `x` such `x<=i`, and do the usual trick with prefixSum: take the difference. \\nSo if we want do know how many indices were removed between `x` and `y` we do `prefSum[x] - prefSum[y]`.\\n\\n**The problem here is that we want to dynamically update `prefArray`. A structure to do it is Binary Indexed (or Fennwick) Tree.**\\nBelow I included a `BIT` class which implements BIT tree.\\n\\nWhen `pos >=curPos` we skip `bit.prefSum(pos) - bit.prefSum(curPos-1)` removed indices.\\n\\nWhat to do when we run off the array (i.e. `curPos > pos`)? We have to compute how many indices there were removed from `curPos` to the end of the array\\nThis is: `bit.prefSum(n-1) - bit.prefSum(curPos-1)`\\nAnd how many indices have been removed from the beginning of the array to `pos`.\\nThis is `bit.prefSum(pos)`\\n\\nSo from the number of `steps` if there were no removed indices we have to subtract the numbers mentioned above.\\n\\nThe last thing is to count the actual removal of the number, which is a simple `+1` which I added when initializing `steps` and a call to `BIT.insert`\\n\\nAfter we removed the number we automatically advance to the next position `curPos = (pos+1) % n`\\n\\n# Please upvote if you like this solution!\\n\\n\\n# Code\\n```\\n# A class defining Binary Indexed Tree:\\nclass BIT:\\n    def __init__(self, maxN):\\n        self.maxN = maxN\\n        self.bit = [0] * (maxN + 1)\\n    def prefSum(self, n):\\n        \\'\\'\\' return prefix sum; allowed n=-1 for no prefix\\'\\'\\'\\n        ret = 0\\n        n += 1\\n        while n > 0:\\n            ret += self.bit[n]\\n            n -= n & (-n)\\n        return ret\\n    def insert(self, v, delta):\\n        v += 1\\n        while v <= self.maxN:\\n            self.bit[v] += delta\\n            v += v & (-v)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums):\\n        n = len(nums)\\n        bit = BIT(n)\\n        nums = [(num, i) for i, num in enumerate(nums)]\\n        nums.sort()\\n        curPos = 0\\n        ret = 0\\n        for _, pos in nums:\\n            steps = 1+(n + pos - curPos) % n\\n            if pos >= curPos:\\n                steps -= (bit.prefSum(pos) - bit.prefSum(curPos-1))\\n            else:\\n                steps -= (bit.prefSum(n-1) - bit.prefSum(curPos-1))\\n                steps -= bit.prefSum(pos)\\n            ret += steps\\n            bit.insert(pos, 1)\\n            curPos = (pos+1) % n\\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# A class defining Binary Indexed Tree:\\nclass BIT:\\n    def __init__(self, maxN):\\n        self.maxN = maxN\\n        self.bit = [0] * (maxN + 1)\\n    def prefSum(self, n):\\n        \\'\\'\\' return prefix sum; allowed n=-1 for no prefix\\'\\'\\'\\n        ret = 0\\n        n += 1\\n        while n > 0:\\n            ret += self.bit[n]\\n            n -= n & (-n)\\n        return ret\\n    def insert(self, v, delta):\\n        v += 1\\n        while v <= self.maxN:\\n            self.bit[v] += delta\\n            v += v & (-v)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums):\\n        n = len(nums)\\n        bit = BIT(n)\\n        nums = [(num, i) for i, num in enumerate(nums)]\\n        nums.sort()\\n        curPos = 0\\n        ret = 0\\n        for _, pos in nums:\\n            steps = 1+(n + pos - curPos) % n\\n            if pos >= curPos:\\n                steps -= (bit.prefSum(pos) - bit.prefSum(curPos-1))\\n            else:\\n                steps -= (bit.prefSum(n-1) - bit.prefSum(curPos-1))\\n                steps -= bit.prefSum(pos)\\n            ret += steps\\n            bit.insert(pos, 1)\\n            curPos = (pos+1) % n\\n        return ret\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467306,
                "title": "easy-with-explaination-in-java",
                "content": "# Intuition\\nThe intuition behind the algorithm is that, initially, there are n elements in the array, and at least n operations are required to transform the array to a non-decreasing order. To perform a rotation, n operations are required to move all the elements once.\\n\\nTo implement the algorithm, we first set the result variable to n, which represents the minimum number of operations required to make the array non-decreasing. We then record the positions of all the elements in the array using a dictionary, where pos[A[i]] = i.\\n\\nNext, we iterate through the array from smallest to largest element. If the position of an element decreases compared to the previous element, we know that we need to rotate the remaining elements to the beginning of the array. This brings us back to the original intuition that we need n operations to rotate all the elements once. In this case, we increment the result variable by the number of remaining elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] a) {\\n        HashMap<Integer, Integer> pos = new HashMap<>();\\n        long n = a.length, res = n;\\n        for (int i = 0; i < n; i++)\\n            pos.put(a[i], i);\\n        Arrays.sort(a);\\n        for (int i = 1; i < n; i++)\\n            if (pos.get(a[i]) < pos.get(a[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] a) {\\n        HashMap<Integer, Integer> pos = new HashMap<>();\\n        long n = a.length, res = n;\\n        for (int i = 0; i < n; i++)\\n            pos.put(a[i], i);\\n        Arrays.sort(a);\\n        for (int i = 1; i < n; i++)\\n            if (pos.get(a[i]) < pos.get(a[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467198,
                "title": "sort-with-indices-with-explanation",
                "content": "# Intuition\\nTry to modify the problem statement, and think of operations required to remove some strict increasing subsequence (including smallest)\\n\\n\\n\\n# Approach\\nWe need to calculate the strictly increasing subsequence including the smallest element, to remove those many elements we will require n operations.\\n \\n3  | 4  | [-1]\\n\\nhere the subsequence is of size 1, it will take n (i.e. 3) operations to remove that subsequence,\\n\\nnew array will be,\\n\\n[3  | 4 ]\\n\\nwhich itself is the longest strictly increasing array including the smallest element to remove them we need n (i.e. 2) operations\\n\\n\\nwe can easily get the subsequences with sorted array including the account of indices\\n\\n-1  |  3  |  4       ---->  sorted elements\\n0    |  1  |  2    ----->indices\\n\\nwe need to calculate the continues subarray that is increasing in both conditions. We can take some pointers to achieve the same\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<pair<int,int>> arr(n);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i] = {nums[i], i};\\n        }\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long answer=0;\\n        \\n        // adding last element to run the else condition below to execute after traversing is over\\n        arr.push_back({INT_MIN, 0});    \\n        \\n        //prev is the pointer and nn is take the count of current array size\\n        long long prev=0, nn=n;\\n        \\n        for(int i=1;i<=n;i++){\\n            \\n            if(arr[i-1].first <= arr[i].first && arr[i-1].second <= arr[i].second){\\n                //continue;    \\n            }else{\\n                \\n                long long items = i - prev;\\n                \\n                answer+= nn;\\n                \\n                nn -= items;\\n                prev = i;\\n            }   \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<pair<int,int>> arr(n);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i] = {nums[i], i};\\n        }\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long answer=0;\\n        \\n        // adding last element to run the else condition below to execute after traversing is over\\n        arr.push_back({INT_MIN, 0});    \\n        \\n        //prev is the pointer and nn is take the count of current array size\\n        long long prev=0, nn=n;\\n        \\n        for(int i=1;i<=n;i++){\\n            \\n            if(arr[i-1].first <= arr[i].first && arr[i-1].second <= arr[i].second){\\n                //continue;    \\n            }else{\\n                \\n                long long items = i - prev;\\n                \\n                answer+= nn;\\n                \\n                nn -= items;\\n                prev = i;\\n            }   \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467063,
                "title": "easy-c-ordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing ordered set to find out number of operations needed to get to next smallest element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        int n = nums.size();\\n        long long int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({nums[i],i});           \\n        }\\n        int prev = pq.top().second;\\n        ans+=pq.top().second+1;\\n        pq.pop();\\n        \\n        ordered_set os;\\n        \\n        os.insert(prev);\\n        \\n        while(pq.size()){\\n            //cout<<ans<<endl;\\n            if(pq.top().second<prev){\\n                os.insert(pq.top().second);\\n                int tilas = os.size() - os.order_of_key(prev)-1;\\n                int tilnum = os.order_of_key (pq.top().second);//cout<<tilas<<\" \"<<tilnum<<\" \";\\n                int thisan = tilas+tilnum;\\n                ans+= (pq.top().second+1+(n-prev-1))- thisan;\\n                prev = pq.top().second;\\n                pq.pop();\\n            }else{\\n                os.insert(pq.top().second);\\n                ans+= pq.top().second-prev-( os.order_of_key(pq.top().second) - os.order_of_key(prev)-1);\\n                prev = pq.top().second;\\n                pq.pop();\\n            }\\n            \\n        }\\n        // cout<<ans<<endl<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        int n = nums.size();\\n        long long int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({nums[i],i});           \\n        }\\n        int prev = pq.top().second;\\n        ans+=pq.top().second+1;\\n        pq.pop();\\n        \\n        ordered_set os;\\n        \\n        os.insert(prev);\\n        \\n        while(pq.size()){\\n            //cout<<ans<<endl;\\n            if(pq.top().second<prev){\\n                os.insert(pq.top().second);\\n                int tilas = os.size() - os.order_of_key(prev)-1;\\n                int tilnum = os.order_of_key (pq.top().second);//cout<<tilas<<\" \"<<tilnum<<\" \";\\n                int thisan = tilas+tilnum;\\n                ans+= (pq.top().second+1+(n-prev-1))- thisan;\\n                prev = pq.top().second;\\n                pq.pop();\\n            }else{\\n                os.insert(pq.top().second);\\n                ans+= pq.top().second-prev-( os.order_of_key(pq.top().second) - os.order_of_key(prev)-1);\\n                prev = pq.top().second;\\n                pq.pop();\\n            }\\n            \\n        }\\n        // cout<<ans<<endl<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3466993,
                "title": "easiest-c-solution-o-nlogn",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**sorting**\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long ans = 1, n = A.size(),j = 2;\\n        vector <pair <int,int>> v;\\n        for(int i = 0; i < n; i++)   v.push_back({A[i], i});\\n        sort(v.begin(), v.end());\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(v[i].second > v[i + 1].second)   ans += j;\\n            else   ans += 1;\\n            j += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long ans = 1, n = A.size(),j = 2;\\n        vector <pair <int,int>> v;\\n        for(int i = 0; i < n; i++)   v.push_back({A[i], i});\\n        sort(v.begin(), v.end());\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(v[i].second > v[i + 1].second)   ans += j;\\n            else   ans += 1;\\n            j += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466639,
                "title": "python3-sortedlist-o-nlogn-clean-concise",
                "content": "# Intuition\\nThink of the array `nums` as a circular array. Then each operation is essentially finding the number of (remaining) elements from the previously deleted element to the next deleted element, in a circular fashion.\\n\\n# Approach\\nWe use a SortedList `sl` or a min-heap to keep track of the current smallest element in the remaining array. We use another SortedList `sl_idx` to keep track of the remaining indices in sorted order. Each time, we count the number of indices between `[start, end]` (inclusive) in the remaining `sl_idx`, and add it to `ans`. Given we are putting elements in a circular fashion, there could be two possibilities where `start <= end` or `start > end`. For the case of `start > end`, we can count the number of indices between `[0, start]` (inclusive) and `[end, n - 1]` (inclusive).\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        else:\\n            return self.count(sl, n, start, n - 1) + self.count(sl, n, 0, end)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        else:\\n            return self.count(sl, n, start, n - 1) + self.count(sl, n, 0, end)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045231,
                "title": "swift-solution-inline-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTried with O(n) but with very large number the test case time limit increased, added the solution though. \\n\\nSecond approach was using dict (accepted) to get the information if the elements are in sorted order of increasing if not we need to increase the iterations to that many times as we have numbers left.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n* logn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        // to make array empty, min operation it will take is nums.count\\n        var result = nums.count \\n        let k = nums.count\\n        var i = 0 \\n        var dict: [Int: Int] = [:]\\n        while i < k {\\n            dict[nums[i]] = i\\n\\n            i += 1\\n        }\\n\\n\\n        var sortedList = nums.sorted { $0 < $1 }\\n\\n        var j = 1\\n        while j < k {\\n\\n            let next = sortedList[j]\\n            let prev = sortedList[j - 1]\\n\\n            // if we have next element index smaller than previous (decreasing order), means we have to rotate rest of element again\\n            if dict[next]! < dict[prev]! {\\n                result += k - j\\n            }\\n            j += 1\\n        }\\n\\n        return result\\n    }\\n}\\n\\n/*\\nO(n) // time limit exceed with very huge input after 500 test case\\nfunc countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var result = 0 \\n        var nums = nums\\n\\n        var queue = nums.sorted { $0 < $1 }\\n        while !nums.isEmpty {\\n            \\n            if nums[0] == queue[0] {\\n                nums.removeFirst()\\n                queue.removeFirst()\\n            } else {\\n                let element = nums.removeFirst()\\n                nums.append(element)\\n            }\\n            result += 1\\n        }\\n\\n        return result\\n    }\\n*/\\n\\n\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        // to make array empty, min operation it will take is nums.count\\n        var result = nums.count \\n        let k = nums.count\\n        var i = 0 \\n        var dict: [Int: Int] = [:]\\n        while i < k {\\n            dict[nums[i]] = i\\n\\n            i += 1\\n        }\\n\\n\\n        var sortedList = nums.sorted { $0 < $1 }\\n\\n        var j = 1\\n        while j < k {\\n\\n            let next = sortedList[j]\\n            let prev = sortedList[j - 1]\\n\\n            // if we have next element index smaller than previous (decreasing order), means we have to rotate rest of element again\\n            if dict[next]! < dict[prev]! {\\n                result += k - j\\n            }\\n            j += 1\\n        }\\n\\n        return result\\n    }\\n}\\n\\n/*\\nO(n) // time limit exceed with very huge input after 500 test case\\nfunc countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var result = 0 \\n        var nums = nums\\n\\n        var queue = nums.sorted { $0 < $1 }\\n        while !nums.isEmpty {\\n            \\n            if nums[0] == queue[0] {\\n                nums.removeFirst()\\n                queue.removeFirst()\\n            } else {\\n                let element = nums.removeFirst()\\n                nums.append(element)\\n            }\\n            result += 1\\n        }\\n\\n        return result\\n    }\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042035,
                "title": "short-python-with-example-to-illustrate",
                "content": "# Intuition\\nThe idea comes from the following link.\\n[https://leetcode.com/problems/make-array-empty/solutions/3466731/just-sort-without-any-other-tricky-data-structures/?orderBy=most_votes]()\\n\\nA quick example to get the idea. \\n\\nArray a=[3,1,2,4].\\nNow get the sorted arrary\\'s indices (i-th smallest entry\\'s position in original array): b=[1,2,0,3]\\n\\nIterate over this array b, and pause whenever we find a b[i]<b[i-1].\\nSince when there are b[i]<b[i-1], it means we need to wrap around the list to remove the smallest element.\\n\\nDuring each pause, (in our mind) repeating moving the first element to the end of list until it goes back to the original state. During this action, we are able to remove the smallest entry before this pause. E.g. 3,1,2,4 -> 1,2,4,3 -> 2,4,3,1 -> 4,3,1,2 -> 3,1,2,4. \\n\\n**Rmk1**: Note that though we kept 1,2 for illustration, we can remove 1, 2 during this loop and it doesn\\'t change the number of operations needed which is N, the length of array.\\n**Rmk2**: why pause after a whole iteration, why not pause at 4 in this example? **Because it\\'s easy to count.** And we need at least one iteration to remove all entries in the list even in the best case, so there won\\'t be any redundant operations.\\n\\nAfter this pause, the number of element remaining in the list is N-m where m is the number removed already. E.g. [3,4].\\n\\nThen we continue, until next pausing to compute the operations we need. In this example, there is no more pause needed. Instead, we can directly empty the list. E.g. So just adding N-m to the answer.\\n\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log n)$ because of sorting.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$, if using nums to store then $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = sorted(range(len(nums)), key=lambda x: nums[x])\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] < nums[i-1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = sorted(range(len(nums)), key=lambda x: nums[x])\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] < nums[i-1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035077,
                "title": "python-easy-dp-once-you-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmy attempt to explain using DP\\nwe accumulate 1 rotations if idx is less than previous in sorted idx\\nby starting from the smallest idx we build up the cases from 1 element\\n\\nthe rest from size 2 onwards is handled in for loop \\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # heapify nums,idx\\n        # curr i to next idx\\n        t=len(nums)\\n        ind = sorted(range(t), key=lambda i:nums[i])\\n        print(ind)\\n        # bottom up dp visualization, \\n        # current frame at 1, before that accumulate 1\\n        m = 1 # drop next, how much to rotate, add moves to res\\n        res = 1 # removed first, now at second, looking back\\n        for i in range(1, t):\\n            # looking back from item 1 to n-1\\n            # prev index is more, had to rotate\\n            if ind[i] < ind[i-1]: # rotated\\n                m += 1 # accumulate 1 more rotation\\n            res += m\\n        return res\\n```\\n```\\n\\n# 1 2 3 4 5\\n# 0 1 2 3 4 \\n\\n# 5 4 3 2 1\\n# 4 3 2 1 0\\n\\n# 1 3 2 4\\n# 0 2 1 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # heapify nums,idx\\n        # curr i to next idx\\n        t=len(nums)\\n        ind = sorted(range(t), key=lambda i:nums[i])\\n        print(ind)\\n        # bottom up dp visualization, \\n        # current frame at 1, before that accumulate 1\\n        m = 1 # drop next, how much to rotate, add moves to res\\n        res = 1 # removed first, now at second, looking back\\n        for i in range(1, t):\\n            # looking back from item 1 to n-1\\n            # prev index is more, had to rotate\\n            if ind[i] < ind[i-1]: # rotated\\n                m += 1 # accumulate 1 more rotation\\n            res += m\\n        return res\\n```\n```\\n\\n# 1 2 3 4 5\\n# 0 1 2 3 4 \\n\\n# 5 4 3 2 1\\n# 4 3 2 1 0\\n\\n# 1 3 2 4\\n# 0 2 1 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020116,
                "title": "prefix-count-binary-indexed-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT\\n{\\n    public: \\n    vector<int> BITtree;\\n    int n;\\n    \\n    BIT(int n)\\n    {\\n        BITtree = vector<int>(n+1,0);\\n        this->n = n;\\n    }\\n    \\n    void add(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] += 1;\\n            index += index & (-index);\\n        }\\n    }\\n\\n    void update(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] -= 1;\\n            index += index & (-index);\\n        }\\n    }\\n    \\n    int get(int index)\\n    {\\n        int sum = 0;\\n\\n        index = index + 1;\\n\\n        while (index>0)\\n        {\\n            sum += BITtree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    #define pi pair<int,int>\\n    long long countOperationsToEmptyArray(vector<int>& nums)\\n    {\\n        long long ans = 0;\\n        \\n        int n = nums.size();\\n        \\n        BIT bit(n);\\n        for(int i=0;i<n;i++) bit.add(i);\\n     \\n        vector<pi> hash;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            hash.push_back({nums[i],i});\\n        }\\n        \\n        sort(hash.begin(),hash.end());\\n        \\n        int curr = 0;\\n        \\n        for(auto i : hash)\\n        {\\n            int idx = i.second;\\n            \\n            if(curr<=idx)\\n            {\\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n                \\n              \\n                ans += (bit.get(idx)-bit.get(curr) + to_add);\\n            }\\n            else\\n            {\\n            \\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n\\n                ans += bit.get(n-1) - bit.get(curr) + to_add;\\n                \\n              \\n                ans += bit.get(idx);\\n            }\\n                \\n         \\n            bit.update(idx);\\n        \\n            curr = idx;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BIT\\n{\\n    public: \\n    vector<int> BITtree;\\n    int n;\\n    \\n    BIT(int n)\\n    {\\n        BITtree = vector<int>(n+1,0);\\n        this->n = n;\\n    }\\n    \\n    void add(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] += 1;\\n            index += index & (-index);\\n        }\\n    }\\n\\n    void update(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] -= 1;\\n            index += index & (-index);\\n        }\\n    }\\n    \\n    int get(int index)\\n    {\\n        int sum = 0;\\n\\n        index = index + 1;\\n\\n        while (index>0)\\n        {\\n            sum += BITtree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    #define pi pair<int,int>\\n    long long countOperationsToEmptyArray(vector<int>& nums)\\n    {\\n        long long ans = 0;\\n        \\n        int n = nums.size();\\n        \\n        BIT bit(n);\\n        for(int i=0;i<n;i++) bit.add(i);\\n     \\n        vector<pi> hash;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            hash.push_back({nums[i],i});\\n        }\\n        \\n        sort(hash.begin(),hash.end());\\n        \\n        int curr = 0;\\n        \\n        for(auto i : hash)\\n        {\\n            int idx = i.second;\\n            \\n            if(curr<=idx)\\n            {\\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n                \\n              \\n                ans += (bit.get(idx)-bit.get(curr) + to_add);\\n            }\\n            else\\n            {\\n            \\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n\\n                ans += bit.get(n-1) - bit.get(curr) + to_add;\\n                \\n              \\n                ans += bit.get(idx);\\n            }\\n                \\n         \\n            bit.update(idx);\\n        \\n            curr = idx;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011919,
                "title": "if-you-still-find-it-confusing-check-out-this",
                "content": "# Intuition\\nI think the most upvoted solution is genius. if you find it confusing, I can help explain further.\\n\\ntaking [4,3,1,2,6,5] as example, if we put it into a sorted map<value, index>, it would be \\n\\n{1: 2}\\n{2: 3}\\n{3: 1}\\n{4: 0}\\n{5: 5}\\n{6: 4}\\n\\nIf we only need to remove the first batch [1,2], it should only take 4 steps, which is basically (index of value 2) + 1, that should be easy to understand.\\n\\n[3,1,2,6,5,4]\\n[1,2,6,5,4,3]\\n[2,6,5,4,3]\\n[6,5,4,3]\\n\\nNow why does the solution keep saying it take one round to remove an increasing batch, I guess this is the confusing part. This is because once you remove [1,2] in the original array, the values after [1,2] which is [6,5] with bigger index can NOT be the next one to remove, otherwise the first batch won\\'t be [1,2]. But now they are rotated in the front of array, so they still need to be rotated to the tail, in which case the array was actually restored to the original order. It takes 2 more steps.\\n\\n[5,4,3,6]\\n[4,3,6,5]\\n\\nThis is called one round, which essentially equals the size of the array = 6.\\n\\nRound 2 removes [3] which takes the size of array steps = 4, array becomes\\n\\n[4,6,5]\\n\\nRound 3 removes [4,5] which takes the size of array steps = 3, array becomes\\n\\n[6]\\n\\nRound 4 removes [6] which takes the size of array steps = 1, array becomes\\n\\n[]\\n\\nTotal steps = 6 + 4 + 3 + 1 = 14\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        long steps = 0, prevRemovedIndex = -1;\\n        while (map.size() > 0) {\\n            int size = map.size();\\n            while (map.size() > 0 && map.get(map.firstKey()) > prevRemovedIndex) {\\n                int smallest = map.firstKey();\\n                int index = map.get(smallest);\\n                map.remove(smallest);\\n                prevRemovedIndex = index;\\n            }\\n\\n            steps += size;\\n            prevRemovedIndex = -1;\\n        }\\n\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        long steps = 0, prevRemovedIndex = -1;\\n        while (map.size() > 0) {\\n            int size = map.size();\\n            while (map.size() > 0 && map.get(map.firstKey()) > prevRemovedIndex) {\\n                int smallest = map.firstKey();\\n                int index = map.get(smallest);\\n                map.remove(smallest);\\n                prevRemovedIndex = index;\\n            }\\n\\n            steps += size;\\n            prevRemovedIndex = -1;\\n        }\\n\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977485,
                "title": "greedy-approach-for-counting-operations-to-empty-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou seem to be trying to solve the problem by sorting the indices of the input array based on the values at those indices. Then, you iterate through the sorted indices and count the number of operations needed to empty the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Create a list num_indices containing indices from 0 to len(nums) - 1.\\n2) Sort num_indices based on the corresponding values in the nums array using a custom sorting key.\\n3) Initialize count as the length of the nums array and operations as 0.\\n4) Iterate through num_indices starting from index 1. Compare the current index with the previous index in the sorted order.\\n    - If the current index is smaller than the previous index, increment operations.\\n    - Add the current value of operations to count in each iteration.\\n5) Finally, return the count as the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe overall time complexity is dominated by the sorting step and is O(n log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe overall space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_indices = list(range(len(nums))) \\n\\n        num_indices.sort(key=lambda i: nums[i])\\n        \\n        count = len(nums)\\n        operations = 0\\n        \\n        for i in range(1, len(num_indices)):\\n            if num_indices[i] < num_indices[i - 1]:\\n                operations += 1\\n            count += operations\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_indices = list(range(len(nums))) \\n\\n        num_indices.sort(key=lambda i: nums[i])\\n        \\n        count = len(nums)\\n        operations = 0\\n        \\n        for i in range(1, len(num_indices)):\\n            if num_indices[i] < num_indices[i - 1]:\\n                operations += 1\\n            count += operations\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976817,
                "title": "count-query-using-balenced-binary-search-tree",
                "content": "# Intuition\\nUse balanced Red-Black-Tree to count how many nodes lie in given range. The number is made-empty from the array, while it is also deleted from the binary tree.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    \\n    const indexValueSorted = nums.map((val, index) => [index, val]);\\n    indexValueSorted.sort((a, b) => b[1] - a[1]);\\n\\n    const linkedList = nums.map((val, index) => new Element(index, val));\\n    linkedList[linkedList.length - 1].right = linkedList[0];\\n    for (let i = 0; i < linkedList.length; i++) {\\n        const nextI = (i + 1) % linkedList.length;\\n        linkedList[i].right = linkedList[nextI];\\n        linkedList[i].left = linkedList[(i - 1 + linkedList.length) % linkedList.length];\\n    }\\n\\n    let currentMin = indexValueSorted.pop();\\n    let operations = currentMin[0] - 0 + 1;\\n    let currentIndex = linkedList[currentMin[0]].right.index;\\n    deleteElement(linkedList, currentMin[0]);\\n    let root = new Element(currentMin[0], currentMin[1]);\\n    const tree = new RbTree();\\n    tree.insert(currentMin[0], currentMin[1]);\\n\\n    while (indexValueSorted.length > 0) {\\n        const [indexMin, valMin] = indexValueSorted.pop();\\n        if (currentIndex <= indexMin) {\\n            const countRemoved = countOfRemovedElements(tree.root, currentIndex, indexMin);\\n            operations += indexMin - currentIndex + 1 - countRemoved;\\n        } else {\\n            const countRemoved = countOfRemovedElements(tree.root, 0, indexMin) +\\n                countOfRemovedElements(tree.root, currentIndex, nums.length - 1);\\n            operations += indexMin + 1 + nums.length - currentIndex - countRemoved;\\n        }\\n        tree.insert(indexMin, valMin);\\n        // next index\\n        currentIndex = linkedList[indexMin].right.index;\\n        deleteElement(linkedList, indexMin);\\n    }\\n    return operations;\\n};\\n\\nclass Element {\\n    constructor(index, value) {\\n        this.index = index;\\n        this.value = value;\\n        this.left = null;\\n        this.right = null;\\n        this.leftCount = 0;\\n        this.rightCount = 0;\\n    }\\n}\\n\\nvar deleteElement = function(eleList, index) {\\n    const ele = eleList[index];\\n    if (ele.left == null || ele.right == null) {\\n        return ele;\\n    }\\n\\n    const leftEle = ele.left;\\n    const rightEle = ele.right;\\n    leftEle.right = rightEle;\\n    rightEle.left = leftEle;\\n    ele.left = ele.right = null;\\n    return rightEle;\\n};\\n\\nvar countOfRemovedElements = function(root, start, end) {\\n    if (isNilNode(root)) {\\n        return 0;\\n    }\\n    const ge = countOfGreatOrEqual(root, start);\\n    const ge1 = countOfGreatOrEqual(root, end + 1);\\n    return ge - ge1;\\n};\\n\\n/**\\n * \\n * @param {Node} root \\n * @param {Number} index \\n * @returns \\n */\\nvar countOfGreatOrEqual = function(root, index) {\\n    if (root == null || isNilNode(root)) {\\n        return 0;\\n    }\\n\\n    if (root.key >= index) {\\n        return countOfGreatOrEqual(root.left, index) + 1 + root.rightCount;\\n    } else {\\n        return countOfGreatOrEqual(root.right, index);\\n    }\\n};\\n\\n/**\\n * constructor\\n * Node of the red black tree\\n * 1.Every node is either red or black\\n * 2.Root and leaves are all black\\n * 3.Every red node has black parent\\n * 4.All simple paths from a node x to a descendant leaves of x has same black nodes\\n */\\nclass RbTree {\\n    constructor() {\\n      this.root = null;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *\\n    * param Node node Node.\\n    * return Node a copy of original node\\n    */\\n    clone(node) {\\n      return new Node(node.key, node.value, node.left, node.right, node.color, node.parent);\\n    }\\n  \\n  /**\\n   * find value by node key\\n   */\\n    find(input) {\\n      const key = toNumber(input);\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else {\\n          return node.value;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    leftMostChild(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    findNode(key) {\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else if (key === node.key) {\\n          return node;\\n        } else {\\n          return null;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    update(key, value) {\\n      const node = this.findNode(key);\\n      node.value = value;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   ====>   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateRight(node) {\\n      const y = node.left;\\n  \\n      if (isNilNode(y.right)) {\\n        node.left = createLeafNode(node);\\n        node.leftCount = 0;\\n      } else {\\n        node.left = y.right;\\n        node.leftCount = y.rightCount;\\n      }\\n  \\n      if (!isNilNode(y.right)) {\\n        y.right.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.right) {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.rightCount + y.leftCount + 1;\\n        } else {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.rightCount + y.leftCount + 1;\\n        }\\n      }\\n      y.right = node;\\n      y.rightCount = node.rightCount + node.leftCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   <====   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateLeft(node) {\\n      const y = node.right;\\n  \\n      // console.log(y.left)\\n      if (isNilNode(y.left)) {\\n        node.right = createLeafNode(node);\\n        node.rightCount = 0;\\n      } else {\\n        node.right = y.left;\\n        node.rightCount = y.leftCount;\\n      }\\n  \\n      if (!isNilNode(y.left)) {\\n        y.left.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.left) {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.leftCount + y.rightCount + 1;\\n        } else {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.leftCount + y.rightCount + 1;\\n        }\\n      }\\n      y.left = node;\\n      y.leftCount = node.leftCount + node.rightCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * param Node node Node.\\n    * Make the color of newly inserted nodes as RED and then perform standard BST insertion\\n    * If x is root, change color of node as BLACK (Black height +1).\\n    */\\n    insert(key, value) {\\n      let y = null;\\n      let x = this.root;\\n      const z = createNode(key, value);\\n      if (this.root == null) {\\n        this.root = z;\\n        z.color = nodeColor.BLACK;\\n        z.parent = null;\\n      } else {\\n        while (!isNilNode(x)) {\\n          y = x;\\n          if (z.key < x.key) {\\n            x = x.left;\\n          } else {\\n            x = x.right;\\n          }\\n        }\\n        z.parent = y;\\n        // current node parent is root\\n        if (z.key < y.key) {\\n          y.left = z;\\n          y.leftCount = z.leftCount + z.rightCount + 1;\\n        } else {\\n          y.right = z;\\n          y.rightCount = z.leftCount + z.rightCount + 1;\\n        }\\n\\n        // update y\\'s parent count\\n        let p = y.parent;\\n        let c = y;\\n        while (!isNilNode(p)) {\\n            if (c === p.left) {\\n                p.leftCount++;\\n            } else {\\n                p.rightCount++;\\n            }\\n            c = p;\\n            p = p.parent;\\n        }\\n        // y.right is now z\\n        z.left = createLeafNode(z);\\n        z.right = createLeafNode(z);\\n        z.leftCount = z.rightCount = 0;\\n        z.color = nodeColor.RED;\\n        this.fixTree(z);\\n      }\\n    }\\n  \\n  /**\\n  * A method to fix RB TREE\\n  * when uncle is RED\\n  * Change color of parent and uncle as BLACK.\\n  * Color of grand parent as RED.\\n  * Change node = node\\u2019s grandparent, repeat steps 2 and 3 for new x.\\n  * ---------------------------------------------------------------\\n  * when uncle is BLACK\\n  * left_left_case\\n  * left_right_case\\n  * right_right_case\\n  * right_left_case\\n  */\\n  \\n    fixTree(node) {\\n      while (node.parent != null && node.parent.color === nodeColor.RED) {\\n        let uncle = null;\\n        if (node.parent === node.parent.parent.left) {\\n          uncle = node.parent.parent.right;\\n  \\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.right) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateLeft(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateRight(node.parent.parent);\\n        } else {\\n          uncle = node.parent.parent.left;\\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.left) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateRight(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateLeft(node.parent.parent);\\n        }\\n      }\\n      this.root.color = nodeColor.BLACK;\\n    }\\n  \\n    /**\\n    * return the height of a tree\\n    */\\n    findHeight(node) {\\n      if (node == null) {\\n        return -1;\\n      }\\n      const leftLen = this.findHeight(node.left);\\n      const rightLen = this.findHeight(node.right);\\n  \\n      if (leftLen > rightLen) {\\n        return leftLen + 1;\\n      }\\n      return rightLen + 1;\\n    }\\n  \\n    /**\\n    * print out current tree\\n    */\\n    print() {\\n      const height = this.findHeight(this.root) + 1;\\n      this.printHelper(this.root, \\'__\\', height);\\n    }\\n  \\n    printHelper(node, indent, height) {\\n      // tree height\\n      let treeHeight = height;\\n  \\n      if (node == null) {\\n        return;\\n      }\\n      if (node === this.root) {\\n        console.log(`${node.key} color: ${node.color}`);\\n      }\\n      if (node.left != null) {\\n        const parentInfo = `( parent node ${node.left.parent.key})`;\\n        console.log(`${indent}${node.left.key} color: ${node.left.color} ${parentInfo}`);\\n      }\\n      if (node.right != null) {\\n        const parentInfo = `( parent node ${node.right.parent.key})`;\\n        console.log(`${indent}${node.right.key} color: ${node.right.color} ${parentInfo}`);\\n      }\\n      treeHeight -= 1;\\n      this.printHelper(node.left, indent + indent, treeHeight);\\n      this.printHelper(node.right, indent + indent, treeHeight);\\n    }\\n  \\n    /**\\n    * remove all nodes inside the tree\\n    */\\n    emptyTree() {\\n      this.root = null;\\n    }\\n  \\n    /**\\n    * return the min node of a given tree\\n    */\\n    min(node) {\\n      if (node == null || node === undefined) {\\n        return {};\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    minNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    maxNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.right)) {\\n        node = node.right;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    transplant(u, v) {\\n      if (u.parent == null) {\\n        this.root = v;\\n      } else if (u === u.parent.left) {\\n        u.parent.left = v;\\n        u.parent.leftCount = v.leftCount + v.rightCount + 1;\\n      } else {\\n        u.parent.right = v;\\n        u.parent.rightCount = v.leftCount + v.rightCount + 1;\\n      }\\n      v.parent = u.parent;\\n    }\\n  \\n  /**\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    remove(key) {\\n      const z = this.findNode(key);\\n      if (z == null) {\\n        return;\\n      }\\n      let x;\\n      let y = z;\\n      let y_original_color = y.color;\\n      if (isNilNode(z.left)) {\\n        x = z.right;\\n        this.transplant(z, z.right);\\n      } else if (isNilNode(z.right)) {\\n        x = z.left;\\n        this.transplant(z, z.left);\\n      } else {\\n        y = this.min(z.right);\\n        y_original_color = y.color;\\n        x = y.right;\\n        if (y.parent === z) {\\n          x.parent = y;\\n        } else {\\n          this.transplant(y, y.right);\\n          y.right = z.right;\\n          y.rightCount = z.rightCount;\\n          y.right.parent = y;\\n        }\\n        this.transplant(z, y);\\n        y.left = z.left;\\n        y.leftCount = z.leftCount;\\n        y.left.parent = y;\\n        y.color = z.color;\\n      }\\n      if (y_original_color === nodeColor.BLACK) {\\n        this.removeFix(x);\\n      }\\n    }\\n  \\n  /**\\n   * a method to fix remove key\\n   */\\n    removeFix(node) {\\n      while (node !== this.root && node.color === nodeColor.BLACK) {\\n        if (node === node.parent.left) {\\n          let w = node.parent.right;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateLeft(node.parent);\\n            w = node.parent.right;\\n          }\\n          if (w.left.color === nodeColor.BLACK && w.right.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n            continue;\\n          } else if (w.right.color === nodeColor.BLACK) {\\n            w.left.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            w = node.parent.right;\\n          }\\n          if (w.right.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.right.color = nodeColor.BLACK;\\n            this.rotateLeft(node.parent);\\n            node = this.root;\\n          }\\n        } else {\\n          let w = node.parent.left;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateRight(node.parent);\\n            w = node.parent.left;\\n          }\\n          if (w.right.color === nodeColor.BLACK && w.left.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n          } else if (w.left.color === nodeColor.BLACK) {\\n            w.right.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            this.rotateLeft(w);\\n            w = node.parent.left;\\n          }\\n          if (w.left.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.left.color = nodeColor.BLACK;\\n            this.rotateRight(node.parent);\\n            node = this.root;\\n          }\\n        }\\n      }\\n      node.color = nodeColor.BLACK;\\n    }\\n  \\n    inOrderSucc(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      // when a right child exist\\n      if (!isNilNode(node.right)) {\\n        return this.leftMostChild(node.right).getValue();\\n  \\n      // Where no right child exists\\n      } else { // eslint-disable-line\\n        let curr = node;\\n        let p = node.parent;\\n        // if this node is not its parent\\'s left child\\n        while (p != null && p.left !== curr) {\\n          curr = p;\\n          p = p.parent;\\n        }\\n        // when there is no successor\\n        if (p == null) {\\n          return null;\\n        }\\n        return p.getValue();\\n      }\\n    }\\n  \\n    toSortedArray() {\\n      const sortedArray = [];\\n      this.inOrder(this.root, sortedArray);\\n      return sortedArray;\\n    }\\n  \\n    toArrayPreOrder() {\\n      const preOrderArray = [];\\n      this.preOrder(this.root, preOrderArray);\\n      return preOrderArray;\\n    }\\n  \\n    toArrayPostOrder() {\\n      const postOrderArray = [];\\n      this.postOrder(this.root, postOrderArray);\\n      return postOrderArray;\\n    }\\n  \\n    inOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.inOrder(node.left, array);\\n      array.push(node.getValue());\\n      this.inOrder(node.right, array);\\n    }\\n  \\n    preOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      array.push(node.getValue());\\n      this.preOrder(node.left, array);\\n      this.preOrder(node.right, array);\\n    }\\n  \\n    postOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.postOrder(node.left, array);\\n      this.postOrder(node.right, array);\\n      array.push(node.getValue());\\n    }\\n  \\n    createIterator() {\\n      return new iterator(this.root);\\n    }\\n  \\n  }\\n\\n  const nodeColor = {\\n    RED : 0,\\n    BLACK : 1\\n  }\\n\\n  function createLeafNode(parent) {\\n    let node = new Node(null, null);\\n    node.color = nodeColor.BLACK;\\n    node.parent = parent;\\n    return node;\\n  }\\n\\n  function createNode(key, value) {\\n    let node = new Node(key, value);\\n  \\n    //left leaf has color black. left, right to be nul\\n    let leftLeaf = new Node(null, null);\\n    leftLeaf.color = nodeColor.BLACK;\\n    leftLeaf.left = null;\\n    leftLeaf.right = null;\\n    leftLeaf.parent = node;\\n  \\n    //right leaf has color black. left, right to be nul\\n    let rightLeaf = new Node(null, null);\\n    rightLeaf.color = nodeColor.BLACK;\\n    rightLeaf.left = null;\\n    rightLeaf.right = null;\\n    rightLeaf.parent = node;\\n  \\n    //map leaves\\n    node.left = leftLeaf;\\n    node.right = rightLeaf;\\n    return node;\\n  }\\n  function toNumber(key) {\\n\\n    const offset = 96;\\n    //if key is not a number\\n    if (isNaN(key) && typeof key === \"string\") {\\n      const keyToLower = key.toLowerCase();\\n      if (keyToLower.length > 1) {\\n        let number = \\'\\';\\n        //converting each letter to a number\\n        for (let ch of keyToLower) {\\n          number += ch.charCodeAt(0) - offset + \\'\\';\\n        }\\n        return parseInt(number);\\n      }\\n      return keyToLower.charCodeAt(0) - offset;\\n    }\\n    return key;\\n  }\\n  function isNilNode(node) {\\n    return node == null || (node.key == null && node.value == null\\n           && node.color === nodeColor.BLACK\\n           && node.left == null && node.right == null);\\n  }\\n  class iterator {\\n    constructor(root) {\\n      this.stack = [];\\n      this.curr = root;\\n    }\\n  \\n     hasNext() {\\n       return !isNilNode(this.curr) || this.stack.length > 0;\\n     }\\n  \\n     next() {\\n       while (!isNilNode(this.curr)) {\\n         this.stack.push(this.curr);\\n         this.curr = this.curr.left;\\n       }\\n       this.curr = this.stack.pop();\\n       const node = this.curr;\\n       this.curr = this.curr.right;\\n       return node.getValue();\\n     }\\n  }\\n  class Node {\\n    constructor(key, value) {\\n      this.key = toNumber(key);\\n      this.value = value;\\n      this.left = null;\\n      this.right = null;\\n      this.color = null;\\n      this.parent = null;\\n      this.leftCount = 0;\\n      this.rightCount = 0;\\n    }\\n  \\n    /**\\n    * return Boolean\\n    */\\n    isRed() {\\n      return this.color === nodeColor.RED\\n    }\\n  \\n    getValue() {\\n      return {\\n        key: this.key,\\n        value: this.value,\\n      }\\n    }\\n  }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    \\n    const indexValueSorted = nums.map((val, index) => [index, val]);\\n    indexValueSorted.sort((a, b) => b[1] - a[1]);\\n\\n    const linkedList = nums.map((val, index) => new Element(index, val));\\n    linkedList[linkedList.length - 1].right = linkedList[0];\\n    for (let i = 0; i < linkedList.length; i++) {\\n        const nextI = (i + 1) % linkedList.length;\\n        linkedList[i].right = linkedList[nextI];\\n        linkedList[i].left = linkedList[(i - 1 + linkedList.length) % linkedList.length];\\n    }\\n\\n    let currentMin = indexValueSorted.pop();\\n    let operations = currentMin[0] - 0 + 1;\\n    let currentIndex = linkedList[currentMin[0]].right.index;\\n    deleteElement(linkedList, currentMin[0]);\\n    let root = new Element(currentMin[0], currentMin[1]);\\n    const tree = new RbTree();\\n    tree.insert(currentMin[0], currentMin[1]);\\n\\n    while (indexValueSorted.length > 0) {\\n        const [indexMin, valMin] = indexValueSorted.pop();\\n        if (currentIndex <= indexMin) {\\n            const countRemoved = countOfRemovedElements(tree.root, currentIndex, indexMin);\\n            operations += indexMin - currentIndex + 1 - countRemoved;\\n        } else {\\n            const countRemoved = countOfRemovedElements(tree.root, 0, indexMin) +\\n                countOfRemovedElements(tree.root, currentIndex, nums.length - 1);\\n            operations += indexMin + 1 + nums.length - currentIndex - countRemoved;\\n        }\\n        tree.insert(indexMin, valMin);\\n        // next index\\n        currentIndex = linkedList[indexMin].right.index;\\n        deleteElement(linkedList, indexMin);\\n    }\\n    return operations;\\n};\\n\\nclass Element {\\n    constructor(index, value) {\\n        this.index = index;\\n        this.value = value;\\n        this.left = null;\\n        this.right = null;\\n        this.leftCount = 0;\\n        this.rightCount = 0;\\n    }\\n}\\n\\nvar deleteElement = function(eleList, index) {\\n    const ele = eleList[index];\\n    if (ele.left == null || ele.right == null) {\\n        return ele;\\n    }\\n\\n    const leftEle = ele.left;\\n    const rightEle = ele.right;\\n    leftEle.right = rightEle;\\n    rightEle.left = leftEle;\\n    ele.left = ele.right = null;\\n    return rightEle;\\n};\\n\\nvar countOfRemovedElements = function(root, start, end) {\\n    if (isNilNode(root)) {\\n        return 0;\\n    }\\n    const ge = countOfGreatOrEqual(root, start);\\n    const ge1 = countOfGreatOrEqual(root, end + 1);\\n    return ge - ge1;\\n};\\n\\n/**\\n * \\n * @param {Node} root \\n * @param {Number} index \\n * @returns \\n */\\nvar countOfGreatOrEqual = function(root, index) {\\n    if (root == null || isNilNode(root)) {\\n        return 0;\\n    }\\n\\n    if (root.key >= index) {\\n        return countOfGreatOrEqual(root.left, index) + 1 + root.rightCount;\\n    } else {\\n        return countOfGreatOrEqual(root.right, index);\\n    }\\n};\\n\\n/**\\n * constructor\\n * Node of the red black tree\\n * 1.Every node is either red or black\\n * 2.Root and leaves are all black\\n * 3.Every red node has black parent\\n * 4.All simple paths from a node x to a descendant leaves of x has same black nodes\\n */\\nclass RbTree {\\n    constructor() {\\n      this.root = null;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *\\n    * param Node node Node.\\n    * return Node a copy of original node\\n    */\\n    clone(node) {\\n      return new Node(node.key, node.value, node.left, node.right, node.color, node.parent);\\n    }\\n  \\n  /**\\n   * find value by node key\\n   */\\n    find(input) {\\n      const key = toNumber(input);\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else {\\n          return node.value;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    leftMostChild(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    findNode(key) {\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else if (key === node.key) {\\n          return node;\\n        } else {\\n          return null;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    update(key, value) {\\n      const node = this.findNode(key);\\n      node.value = value;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   ====>   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateRight(node) {\\n      const y = node.left;\\n  \\n      if (isNilNode(y.right)) {\\n        node.left = createLeafNode(node);\\n        node.leftCount = 0;\\n      } else {\\n        node.left = y.right;\\n        node.leftCount = y.rightCount;\\n      }\\n  \\n      if (!isNilNode(y.right)) {\\n        y.right.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.right) {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.rightCount + y.leftCount + 1;\\n        } else {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.rightCount + y.leftCount + 1;\\n        }\\n      }\\n      y.right = node;\\n      y.rightCount = node.rightCount + node.leftCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   <====   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateLeft(node) {\\n      const y = node.right;\\n  \\n      // console.log(y.left)\\n      if (isNilNode(y.left)) {\\n        node.right = createLeafNode(node);\\n        node.rightCount = 0;\\n      } else {\\n        node.right = y.left;\\n        node.rightCount = y.leftCount;\\n      }\\n  \\n      if (!isNilNode(y.left)) {\\n        y.left.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.left) {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.leftCount + y.rightCount + 1;\\n        } else {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.leftCount + y.rightCount + 1;\\n        }\\n      }\\n      y.left = node;\\n      y.leftCount = node.leftCount + node.rightCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * param Node node Node.\\n    * Make the color of newly inserted nodes as RED and then perform standard BST insertion\\n    * If x is root, change color of node as BLACK (Black height +1).\\n    */\\n    insert(key, value) {\\n      let y = null;\\n      let x = this.root;\\n      const z = createNode(key, value);\\n      if (this.root == null) {\\n        this.root = z;\\n        z.color = nodeColor.BLACK;\\n        z.parent = null;\\n      } else {\\n        while (!isNilNode(x)) {\\n          y = x;\\n          if (z.key < x.key) {\\n            x = x.left;\\n          } else {\\n            x = x.right;\\n          }\\n        }\\n        z.parent = y;\\n        // current node parent is root\\n        if (z.key < y.key) {\\n          y.left = z;\\n          y.leftCount = z.leftCount + z.rightCount + 1;\\n        } else {\\n          y.right = z;\\n          y.rightCount = z.leftCount + z.rightCount + 1;\\n        }\\n\\n        // update y\\'s parent count\\n        let p = y.parent;\\n        let c = y;\\n        while (!isNilNode(p)) {\\n            if (c === p.left) {\\n                p.leftCount++;\\n            } else {\\n                p.rightCount++;\\n            }\\n            c = p;\\n            p = p.parent;\\n        }\\n        // y.right is now z\\n        z.left = createLeafNode(z);\\n        z.right = createLeafNode(z);\\n        z.leftCount = z.rightCount = 0;\\n        z.color = nodeColor.RED;\\n        this.fixTree(z);\\n      }\\n    }\\n  \\n  /**\\n  * A method to fix RB TREE\\n  * when uncle is RED\\n  * Change color of parent and uncle as BLACK.\\n  * Color of grand parent as RED.\\n  * Change node = node\\u2019s grandparent, repeat steps 2 and 3 for new x.\\n  * ---------------------------------------------------------------\\n  * when uncle is BLACK\\n  * left_left_case\\n  * left_right_case\\n  * right_right_case\\n  * right_left_case\\n  */\\n  \\n    fixTree(node) {\\n      while (node.parent != null && node.parent.color === nodeColor.RED) {\\n        let uncle = null;\\n        if (node.parent === node.parent.parent.left) {\\n          uncle = node.parent.parent.right;\\n  \\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.right) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateLeft(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateRight(node.parent.parent);\\n        } else {\\n          uncle = node.parent.parent.left;\\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.left) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateRight(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateLeft(node.parent.parent);\\n        }\\n      }\\n      this.root.color = nodeColor.BLACK;\\n    }\\n  \\n    /**\\n    * return the height of a tree\\n    */\\n    findHeight(node) {\\n      if (node == null) {\\n        return -1;\\n      }\\n      const leftLen = this.findHeight(node.left);\\n      const rightLen = this.findHeight(node.right);\\n  \\n      if (leftLen > rightLen) {\\n        return leftLen + 1;\\n      }\\n      return rightLen + 1;\\n    }\\n  \\n    /**\\n    * print out current tree\\n    */\\n    print() {\\n      const height = this.findHeight(this.root) + 1;\\n      this.printHelper(this.root, \\'__\\', height);\\n    }\\n  \\n    printHelper(node, indent, height) {\\n      // tree height\\n      let treeHeight = height;\\n  \\n      if (node == null) {\\n        return;\\n      }\\n      if (node === this.root) {\\n        console.log(`${node.key} color: ${node.color}`);\\n      }\\n      if (node.left != null) {\\n        const parentInfo = `( parent node ${node.left.parent.key})`;\\n        console.log(`${indent}${node.left.key} color: ${node.left.color} ${parentInfo}`);\\n      }\\n      if (node.right != null) {\\n        const parentInfo = `( parent node ${node.right.parent.key})`;\\n        console.log(`${indent}${node.right.key} color: ${node.right.color} ${parentInfo}`);\\n      }\\n      treeHeight -= 1;\\n      this.printHelper(node.left, indent + indent, treeHeight);\\n      this.printHelper(node.right, indent + indent, treeHeight);\\n    }\\n  \\n    /**\\n    * remove all nodes inside the tree\\n    */\\n    emptyTree() {\\n      this.root = null;\\n    }\\n  \\n    /**\\n    * return the min node of a given tree\\n    */\\n    min(node) {\\n      if (node == null || node === undefined) {\\n        return {};\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    minNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    maxNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.right)) {\\n        node = node.right;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    transplant(u, v) {\\n      if (u.parent == null) {\\n        this.root = v;\\n      } else if (u === u.parent.left) {\\n        u.parent.left = v;\\n        u.parent.leftCount = v.leftCount + v.rightCount + 1;\\n      } else {\\n        u.parent.right = v;\\n        u.parent.rightCount = v.leftCount + v.rightCount + 1;\\n      }\\n      v.parent = u.parent;\\n    }\\n  \\n  /**\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    remove(key) {\\n      const z = this.findNode(key);\\n      if (z == null) {\\n        return;\\n      }\\n      let x;\\n      let y = z;\\n      let y_original_color = y.color;\\n      if (isNilNode(z.left)) {\\n        x = z.right;\\n        this.transplant(z, z.right);\\n      } else if (isNilNode(z.right)) {\\n        x = z.left;\\n        this.transplant(z, z.left);\\n      } else {\\n        y = this.min(z.right);\\n        y_original_color = y.color;\\n        x = y.right;\\n        if (y.parent === z) {\\n          x.parent = y;\\n        } else {\\n          this.transplant(y, y.right);\\n          y.right = z.right;\\n          y.rightCount = z.rightCount;\\n          y.right.parent = y;\\n        }\\n        this.transplant(z, y);\\n        y.left = z.left;\\n        y.leftCount = z.leftCount;\\n        y.left.parent = y;\\n        y.color = z.color;\\n      }\\n      if (y_original_color === nodeColor.BLACK) {\\n        this.removeFix(x);\\n      }\\n    }\\n  \\n  /**\\n   * a method to fix remove key\\n   */\\n    removeFix(node) {\\n      while (node !== this.root && node.color === nodeColor.BLACK) {\\n        if (node === node.parent.left) {\\n          let w = node.parent.right;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateLeft(node.parent);\\n            w = node.parent.right;\\n          }\\n          if (w.left.color === nodeColor.BLACK && w.right.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n            continue;\\n          } else if (w.right.color === nodeColor.BLACK) {\\n            w.left.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            w = node.parent.right;\\n          }\\n          if (w.right.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.right.color = nodeColor.BLACK;\\n            this.rotateLeft(node.parent);\\n            node = this.root;\\n          }\\n        } else {\\n          let w = node.parent.left;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateRight(node.parent);\\n            w = node.parent.left;\\n          }\\n          if (w.right.color === nodeColor.BLACK && w.left.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n          } else if (w.left.color === nodeColor.BLACK) {\\n            w.right.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            this.rotateLeft(w);\\n            w = node.parent.left;\\n          }\\n          if (w.left.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.left.color = nodeColor.BLACK;\\n            this.rotateRight(node.parent);\\n            node = this.root;\\n          }\\n        }\\n      }\\n      node.color = nodeColor.BLACK;\\n    }\\n  \\n    inOrderSucc(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      // when a right child exist\\n      if (!isNilNode(node.right)) {\\n        return this.leftMostChild(node.right).getValue();\\n  \\n      // Where no right child exists\\n      } else { // eslint-disable-line\\n        let curr = node;\\n        let p = node.parent;\\n        // if this node is not its parent\\'s left child\\n        while (p != null && p.left !== curr) {\\n          curr = p;\\n          p = p.parent;\\n        }\\n        // when there is no successor\\n        if (p == null) {\\n          return null;\\n        }\\n        return p.getValue();\\n      }\\n    }\\n  \\n    toSortedArray() {\\n      const sortedArray = [];\\n      this.inOrder(this.root, sortedArray);\\n      return sortedArray;\\n    }\\n  \\n    toArrayPreOrder() {\\n      const preOrderArray = [];\\n      this.preOrder(this.root, preOrderArray);\\n      return preOrderArray;\\n    }\\n  \\n    toArrayPostOrder() {\\n      const postOrderArray = [];\\n      this.postOrder(this.root, postOrderArray);\\n      return postOrderArray;\\n    }\\n  \\n    inOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.inOrder(node.left, array);\\n      array.push(node.getValue());\\n      this.inOrder(node.right, array);\\n    }\\n  \\n    preOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      array.push(node.getValue());\\n      this.preOrder(node.left, array);\\n      this.preOrder(node.right, array);\\n    }\\n  \\n    postOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.postOrder(node.left, array);\\n      this.postOrder(node.right, array);\\n      array.push(node.getValue());\\n    }\\n  \\n    createIterator() {\\n      return new iterator(this.root);\\n    }\\n  \\n  }\\n\\n  const nodeColor = {\\n    RED : 0,\\n    BLACK : 1\\n  }\\n\\n  function createLeafNode(parent) {\\n    let node = new Node(null, null);\\n    node.color = nodeColor.BLACK;\\n    node.parent = parent;\\n    return node;\\n  }\\n\\n  function createNode(key, value) {\\n    let node = new Node(key, value);\\n  \\n    //left leaf has color black. left, right to be nul\\n    let leftLeaf = new Node(null, null);\\n    leftLeaf.color = nodeColor.BLACK;\\n    leftLeaf.left = null;\\n    leftLeaf.right = null;\\n    leftLeaf.parent = node;\\n  \\n    //right leaf has color black. left, right to be nul\\n    let rightLeaf = new Node(null, null);\\n    rightLeaf.color = nodeColor.BLACK;\\n    rightLeaf.left = null;\\n    rightLeaf.right = null;\\n    rightLeaf.parent = node;\\n  \\n    //map leaves\\n    node.left = leftLeaf;\\n    node.right = rightLeaf;\\n    return node;\\n  }\\n  function toNumber(key) {\\n\\n    const offset = 96;\\n    //if key is not a number\\n    if (isNaN(key) && typeof key === \"string\") {\\n      const keyToLower = key.toLowerCase();\\n      if (keyToLower.length > 1) {\\n        let number = \\'\\';\\n        //converting each letter to a number\\n        for (let ch of keyToLower) {\\n          number += ch.charCodeAt(0) - offset + \\'\\';\\n        }\\n        return parseInt(number);\\n      }\\n      return keyToLower.charCodeAt(0) - offset;\\n    }\\n    return key;\\n  }\\n  function isNilNode(node) {\\n    return node == null || (node.key == null && node.value == null\\n           && node.color === nodeColor.BLACK\\n           && node.left == null && node.right == null);\\n  }\\n  class iterator {\\n    constructor(root) {\\n      this.stack = [];\\n      this.curr = root;\\n    }\\n  \\n     hasNext() {\\n       return !isNilNode(this.curr) || this.stack.length > 0;\\n     }\\n  \\n     next() {\\n       while (!isNilNode(this.curr)) {\\n         this.stack.push(this.curr);\\n         this.curr = this.curr.left;\\n       }\\n       this.curr = this.stack.pop();\\n       const node = this.curr;\\n       this.curr = this.curr.right;\\n       return node.getValue();\\n     }\\n  }\\n  class Node {\\n    constructor(key, value) {\\n      this.key = toNumber(key);\\n      this.value = value;\\n      this.left = null;\\n      this.right = null;\\n      this.color = null;\\n      this.parent = null;\\n      this.leftCount = 0;\\n      this.rightCount = 0;\\n    }\\n  \\n    /**\\n    * return Boolean\\n    */\\n    isRed() {\\n      return this.color === nodeColor.RED\\n    }\\n  \\n    getValue() {\\n      return {\\n        key: this.key,\\n        value: this.value,\\n      }\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908291,
                "title": "c-math-iq",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; ++i) mp[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long res = 0LL;\\n        for(int i = 1; i < n; ++i) if(mp[nums[i]] < mp[nums[i - 1]]) res += (n - i);\\n        return res + n;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; ++i) mp[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long res = 0LL;\\n        for(int i = 1; i < n; ++i) if(mp[nums[i]] < mp[nums[i - 1]]) res += (n - i);\\n        return res + n;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904844,
                "title": "c-segment-tree",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$(O(n))$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class SegTree {\\n        int n;\\n        vector<int> vals;\\n        int set(int i, int ind, int l ,int sz, int v) {\\n            if(ind < l || ind >= l + sz) {\\n                return vals[i];\\n            }\\n            if(sz == 1) {\\n                return vals[i] = v;\\n            }\\n            return vals[i] = set(i + i + 1, ind, l, sz /2, v) + set(i + i + 2, ind, l + sz / 2, sz - sz/2, v);\\n        }\\n\\n        int getSums(int i, int st, int sz, int l ,int lsz) {\\n            if(l >= st + sz || st >= l + lsz || sz == 0 || lsz == 0) {\\n                return 0;\\n            }\\n            if(l <= st && l + lsz >= st + sz) {\\n                return vals[i];\\n            }\\n\\n            return getSums(i + i + 1, st, sz / 2, l , lsz) + getSums(i + i + 2, st + sz /2, sz - sz /2, l, lsz);\\n\\n        }\\n\\n        public:\\n        SegTree(int n): n(n), vals(vector<int>(n * 4, 0)) {}\\n        int set(int ind, int val) {\\n            return set(0,ind,0,n,val);\\n        }\\n\\n        int getSums(int l, int sz) {\\n            return getSums(0, 0, n, l, sz);\\n        } \\n     };\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices;\\n        for(int i=0;i<nums.size();i++) {\\n            indices.push_back(i);\\n        }\\n        sort(indices.begin(), indices.end(), [&nums]( const int& lhs, const int& rhs ){return nums[lhs] < nums[rhs];});\\n        SegTree segTree(indices.size());\\n        int cur = 0;\\n        long long cost = 0;\\n        for(int i=0;i<indices.size();i++) {\\n            if(indices[i] < cur) {\\n                // reset to start\\n                cost+= (indices.size() - cur) - segTree.getSums(cur, indices.size() - cur);\\n                cur = 0;\\n            }\\n            cost += (indices[i] - cur) - segTree.getSums(cur, indices[i] - cur);\\n            cost++;\\n            cur = indices[i] + 1;\\n            segTree.set(indices[i], 1);\\n        }\\n        return cost;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class SegTree {\\n        int n;\\n        vector<int> vals;\\n        int set(int i, int ind, int l ,int sz, int v) {\\n            if(ind < l || ind >= l + sz) {\\n                return vals[i];\\n            }\\n            if(sz == 1) {\\n                return vals[i] = v;\\n            }\\n            return vals[i] = set(i + i + 1, ind, l, sz /2, v) + set(i + i + 2, ind, l + sz / 2, sz - sz/2, v);\\n        }\\n\\n        int getSums(int i, int st, int sz, int l ,int lsz) {\\n            if(l >= st + sz || st >= l + lsz || sz == 0 || lsz == 0) {\\n                return 0;\\n            }\\n            if(l <= st && l + lsz >= st + sz) {\\n                return vals[i];\\n            }\\n\\n            return getSums(i + i + 1, st, sz / 2, l , lsz) + getSums(i + i + 2, st + sz /2, sz - sz /2, l, lsz);\\n\\n        }\\n\\n        public:\\n        SegTree(int n): n(n), vals(vector<int>(n * 4, 0)) {}\\n        int set(int ind, int val) {\\n            return set(0,ind,0,n,val);\\n        }\\n\\n        int getSums(int l, int sz) {\\n            return getSums(0, 0, n, l, sz);\\n        } \\n     };\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices;\\n        for(int i=0;i<nums.size();i++) {\\n            indices.push_back(i);\\n        }\\n        sort(indices.begin(), indices.end(), [&nums]( const int& lhs, const int& rhs ){return nums[lhs] < nums[rhs];});\\n        SegTree segTree(indices.size());\\n        int cur = 0;\\n        long long cost = 0;\\n        for(int i=0;i<indices.size();i++) {\\n            if(indices[i] < cur) {\\n                // reset to start\\n                cost+= (indices.size() - cur) - segTree.getSums(cur, indices.size() - cur);\\n                cur = 0;\\n            }\\n            cost += (indices[i] - cur) - segTree.getSums(cur, indices[i] - cur);\\n            cost++;\\n            cur = indices[i] + 1;\\n            segTree.set(indices[i], 1);\\n        }\\n        return cost;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899291,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(vector<int>& nums) {\\n    const int n = nums.size();\\n    long long ans = n;\\n    unordered_map<int, int> numToIndex;\\n\\n    for (int i = 0; i < n; ++i)\\n      numToIndex[nums[i]] = i;\\n\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 1; i < n; ++i)\\n      // On i-th step we\\'ve already removed i - 1 smallest nums and can ignore\\n      // them. If an element nums[i] has smaller index in origin array than\\n      // nums[i - 1], we should rotate whole left array n - i times to set\\n      // nums[i] element on the 1st position.\\n      if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])\\n        ans += n - i;\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(vector<int>& nums) {\\n    const int n = nums.size();\\n    long long ans = n;\\n    unordered_map<int, int> numToIndex;\\n\\n    for (int i = 0; i < n; ++i)\\n      numToIndex[nums[i]] = i;\\n\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 1; i < n; ++i)\\n      // On i-th step we\\'ve already removed i - 1 smallest nums and can ignore\\n      // them. If an element nums[i] has smaller index in origin array than\\n      // nums[i - 1], we should rotate whole left array n - i times to set\\n      // nums[i] element on the 1st position.\\n      if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])\\n        ans += n - i;\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818032,
                "title": "sorted-list-nothing-fancy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_with_inds = [(nums[i],i) for i in range(len(nums))]\\n        nums_with_inds.sort()\\n        a = SortedList([nums_with_inds[0][1]])\\n        total_len = nums_with_inds[0][1]+1\\n        for i in range(len(nums_with_inds)-1):\\n            start_ind = nums_with_inds[i][1]\\n            end_ind = nums_with_inds[i+1][1]\\n            if end_ind>start_ind:\\n                total_len += end_ind-start_ind\\n                removed_len = a.bisect_left(end_ind)-a.bisect_left(start_ind+1)\\n                total_len -= removed_len\\n            else:\\n                total_len += (len(nums_with_inds)-start_ind)+end_ind\\n                non_removed_len = a.bisect_right(start_ind) - a.bisect_left(end_ind)\\n                total_len -= len(a)-non_removed_len\\n            a.add(nums_with_inds[i+1][1])\\n\\n        return total_len    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_with_inds = [(nums[i],i) for i in range(len(nums))]\\n        nums_with_inds.sort()\\n        a = SortedList([nums_with_inds[0][1]])\\n        total_len = nums_with_inds[0][1]+1\\n        for i in range(len(nums_with_inds)-1):\\n            start_ind = nums_with_inds[i][1]\\n            end_ind = nums_with_inds[i+1][1]\\n            if end_ind>start_ind:\\n                total_len += end_ind-start_ind\\n                removed_len = a.bisect_left(end_ind)-a.bisect_left(start_ind+1)\\n                total_len -= removed_len\\n            else:\\n                total_len += (len(nums_with_inds)-start_ind)+end_ind\\n                non_removed_len = a.bisect_right(start_ind) - a.bisect_left(end_ind)\\n                total_len -= len(a)-non_removed_len\\n            a.add(nums_with_inds[i+1][1])\\n\\n        return total_len    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809671,
                "title": "easy-priority-queue-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // min heap of {nums[i],i}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i = 0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        int len = nums.size();\\n        int ind = -1;\\n        while(!pq.empty()){\\n            int mini = pq.top().first;\\n            int ind = pq.top().second;\\n            pq.pop();\\n            ans+=len;\\n            len--;\\n            while(!pq.empty() && pq.top().second>ind){\\n                if(pq.top().second>ind){\\n                    ind = pq.top().second;\\n                    pq.pop();\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // min heap of {nums[i],i}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i = 0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        int len = nums.size();\\n        int ind = -1;\\n        while(!pq.empty()){\\n            int mini = pq.top().first;\\n            int ind = pq.top().second;\\n            pq.pop();\\n            ans+=len;\\n            len--;\\n            while(!pq.empty() && pq.top().second>ind){\\n                if(pq.top().second>ind){\\n                    ind = pq.top().second;\\n                    pq.pop();\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649160,
                "title": "use-array-instead-of-hashmap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n=nums.length;\\n        Integer[] arr=new Integer[n];\\n        for(int i=0;i<n;i++)arr[i]=i;\\n\\n        Arrays.sort(arr,(i,j)->nums[i]-nums[j]);\\n        long ans=n;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<arr[i-1])ans+=n-i;\\n        }\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n=nums.length;\\n        Integer[] arr=new Integer[n];\\n        for(int i=0;i<n;i++)arr[i]=i;\\n\\n        Arrays.sort(arr,(i,j)->nums[i]-nums[j]);\\n        long ans=n;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<arr[i-1])ans+=n-i;\\n        }\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644346,
                "title": "c-steps-counting-simple-and-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nthere will be n fixed steps for deleting each element ,now we look on arrangement ,store the index and then sort the array. Now look at the element ,suppose we need to delete arr[i] there arises two conditions if the index of element arr[i] is smaller than index of arr[i-1] then the element need to round the complete array(left after deleting previous elements) i elements already deleted so n-i steps needed to come for deletion.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        map<int,int>index;\\n        int n=nums.size();\\n\\n        //storing index of every element\\n        for(int i=0;i<n;i++){\\n            index[nums[i]]=i;\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n\\n        //deleting steps (necessory steps)\\n        long long ans=n;\\n\\n        for(int i=1;i<n;i++){\\n\\n            if(index[nums[i]]<index[nums[i-1]]){\\n                ans+=(n-i);  //counts of steps needed after deletion of previous elements\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        map<int,int>index;\\n        int n=nums.size();\\n\\n        //storing index of every element\\n        for(int i=0;i<n;i++){\\n            index[nums[i]]=i;\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n\\n        //deleting steps (necessory steps)\\n        long long ans=n;\\n\\n        for(int i=1;i<n;i++){\\n\\n            if(index[nums[i]]<index[nums[i-1]]){\\n                ans+=(n-i);  //counts of steps needed after deletion of previous elements\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569494,
                "title": "fully-commented-greedy-approach-with-a-bit-explanation",
                "content": "-> We will eliminate elements in ascending order\\n-> Whenever we will recive a number which have a lower index than the previous element it indicate that we have to do iteration again from starting index after removing the previous smaller values.\\n-> Hence in this iteration had to iterate on n(current size) values.\\n-> Then update the n(current size) as we have removed the smaller values.\\n-> Now just keep updating res accordingly.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // Unordered Map for storing the orignal indexes of nums\\'s values.\\n        unordered_map<int, int> record;\\n        int n = nums.size();\\n        // Setting the values of nums to i the indexs respectively.\\n        for(int i = 0; i < n; i++) record[nums[i]] = i;\\n        // sorting to eleminate the number in orderwise fashion.\\n        sort(nums.begin(), nums.end());\\n        // res contain the out result.\\n        // miss contain the number of element present at current moment.\\n        // Size is curr size after eliminating the previous elements.\\n        // Prev is the previous index at which the smaller element was found.\\n        long long res = 0, miss = 0,size = n, prev = -1;\\n        for(int i = 0; i < n; i++){\\n        // If our previous index is greater than current index we will add the size to our result.\\n        // As we have to do size time iteration and again come to index 0 so we update our result and size.\\n            if(prev > record[nums[i]]){\\n                res = res + size;\\n                size = n - miss;\\n            }\\n        // We\\'ll update the prev regularly and increment miss as deleted values.\\n            prev = record[nums[i]];\\n            miss++;\\n        }\\n        return res + size;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // Unordered Map for storing the orignal indexes of nums\\'s values.\\n        unordered_map<int, int> record;\\n        int n = nums.size();\\n        // Setting the values of nums to i the indexs respectively.\\n        for(int i = 0; i < n; i++) record[nums[i]] = i;\\n        // sorting to eleminate the number in orderwise fashion.\\n        sort(nums.begin(), nums.end());\\n        // res contain the out result.\\n        // miss contain the number of element present at current moment.\\n        // Size is curr size after eliminating the previous elements.\\n        // Prev is the previous index at which the smaller element was found.\\n        long long res = 0, miss = 0,size = n, prev = -1;\\n        for(int i = 0; i < n; i++){\\n        // If our previous index is greater than current index we will add the size to our result.\\n        // As we have to do size time iteration and again come to index 0 so we update our result and size.\\n            if(prev > record[nums[i]]){\\n                res = res + size;\\n                size = n - miss;\\n            }\\n        // We\\'ll update the prev regularly and increment miss as deleted values.\\n            prev = record[nums[i]];\\n            miss++;\\n        }\\n        return res + size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552720,
                "title": "solution-in-python-sorted-plus-fenwick-tree",
                "content": "# Intuition\\nActually described operations can be represented as movinmg through the array as it were cycled. We move through the array and stop at the minimum element with excluding it. So finally we exclude all elements and the array will be empty.\\n\\n# Approach\\n1. Transform the array into pairs of values and indices and sort it.\\n2. After that it\\'s enough to traverse the sorted array once and compute the number of operations as the distance between the minimum element and the previous minimum element.\\n\\nIf idx[i] < idx[i - 1] it means we have to start a new loop and the distance will be len(nums) - (idx[i - 1] - idx[i]). Otherwise we just go to the next minimum element i.e. idx[i] - idx[i - 1].\\n\\nThere is an additional difficulty. We have to skip already removed elements. So for each idx[i] and idx[i-1] we have to know how many elements were removed between them. Fenwick tree is the most optimized structure for that.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass FenwickTree:\\n  def __init__(self, capacity):\\n    self.fwt = [0] * capacity\\n    self.capacity = len(self.fwt)\\n\\n  def query(self, idx):\\n    result = 0\\n    while idx > 0:\\n      result += self.fwt[idx]\\n      idx -= idx & -idx\\n    \\n    return result\\n\\n  def update(self, idx, val):\\n    while idx < self.capacity:\\n      self.fwt[idx] += val\\n      idx += idx & -idx\\n\\nclass Solution(object):\\n  def countOperationsToEmptyArray(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    result = 0\\n    sorted_nums = sorted([(num, idx) for idx, num in enumerate(nums)])\\n    fwt = FenwickTree(len(nums) + 1)\\n    curr_idx = -1\\n    for _, idx in sorted_nums:\\n      left_r = fwt.query(min(curr_idx + 1, idx + 1))\\n      right_r = fwt.query(max(curr_idx + 1, idx + 1))\\n      if curr_idx < idx:\\n        removed = right_r - left_r\\n        result += idx - curr_idx\\n      else:\\n        removed = fwt.query(len(nums)) - right_r + left_r\\n        result += len(nums) - (curr_idx - idx)\\n      curr_idx = idx\\n      result -= removed\\n      fwt.update(idx + 1, 1)\\n    return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FenwickTree:\\n  def __init__(self, capacity):\\n    self.fwt = [0] * capacity\\n    self.capacity = len(self.fwt)\\n\\n  def query(self, idx):\\n    result = 0\\n    while idx > 0:\\n      result += self.fwt[idx]\\n      idx -= idx & -idx\\n    \\n    return result\\n\\n  def update(self, idx, val):\\n    while idx < self.capacity:\\n      self.fwt[idx] += val\\n      idx += idx & -idx\\n\\nclass Solution(object):\\n  def countOperationsToEmptyArray(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    result = 0\\n    sorted_nums = sorted([(num, idx) for idx, num in enumerate(nums)])\\n    fwt = FenwickTree(len(nums) + 1)\\n    curr_idx = -1\\n    for _, idx in sorted_nums:\\n      left_r = fwt.query(min(curr_idx + 1, idx + 1))\\n      right_r = fwt.query(max(curr_idx + 1, idx + 1))\\n      if curr_idx < idx:\\n        removed = right_r - left_r\\n        result += idx - curr_idx\\n      else:\\n        removed = fwt.query(len(nums)) - right_r + left_r\\n        result += len(nums) - (curr_idx - idx)\\n      curr_idx = idx\\n      result -= removed\\n      fwt.update(idx + 1, 1)\\n    return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549723,
                "title": "best-code-execute-faster-than-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<pair<int,int>> a;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back({nums[i],i});\\n        }\\n        long long ans=n;\\n        sort(a.begin(),a.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            int k=a[i].second;\\n            if(k<a[i-1].second)\\n            {\\n                ans+=n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Binary Indexed Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<pair<int,int>> a;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back({nums[i],i});\\n        }\\n        long long ans=n;\\n        sort(a.begin(),a.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            int k=a[i].second;\\n            if(k<a[i-1].second)\\n            {\\n                ans+=n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544418,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> Integer.compare(nums[a],nums[b]));\\n        int n = nums.length;\\n        for (int i=0;i<n;i++) pq.offer(i);\\n        int cur = pq.poll();\\n        long ans= n;\\n  \\n        while (!pq.isEmpty()){\\n            n--;\\n            int nextIndex =  pq.poll();\\n            if (nextIndex<cur) ans += n;\\n            cur = nextIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> Integer.compare(nums[a],nums[b]));\\n        int n = nums.length;\\n        for (int i=0;i<n;i++) pq.offer(i);\\n        int cur = pq.poll();\\n        long ans= n;\\n  \\n        while (!pq.isEmpty()){\\n            n--;\\n            int nextIndex =  pq.poll();\\n            if (nextIndex<cur) ans += n;\\n            cur = nextIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534144,
                "title": "no-explicit-sort-usage-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        std::map<int, int> idx{};\\n        for(int i = 0; i < nums.size(); i++)\\n          idx[nums[i]] = i;\\n\\n        long long res{};\\n        auto elems{ nums.size() };\\n        auto last_idx{ nums.size() }; // bigger then max idx->val\\n        \\n        for(const auto& [k,v] : idx) // iterate over std::map gives key-sorted sequence\\n        { \\n          if(last_idx > v) res += elems; \\n          \\n          last_idx = v;\\n          --elems;  \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        std::map<int, int> idx{};\\n        for(int i = 0; i < nums.size(); i++)\\n          idx[nums[i]] = i;\\n\\n        long long res{};\\n        auto elems{ nums.size() };\\n        auto last_idx{ nums.size() }; // bigger then max idx->val\\n        \\n        for(const auto& [k,v] : idx) // iterate over std::map gives key-sorted sequence\\n        { \\n          if(last_idx > v) res += elems; \\n          \\n          last_idx = v;\\n          --elems;  \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517635,
                "title": "c-segment-tree-and-ordered-map",
                "content": "```\\nclass Solution {\\n    void updateIndex(int index,int sz,vector<int>& st){\\n        st[sz+index]++;\\n        index = sz+index;\\n        for (int i=index;i>1;i>>=1){\\n            st[i>>1] = st[i] + st[i^1];\\n        }\\n    }\\n    int query(int l,int r,int sz,vector<int>& st){\\n        int res = 0;\\n      \\n        // loop to find the sum in the range\\n        for (l += sz, r += sz; l < r; l >>= 1, r >>= 1)\\n        {\\n            if (l&1) \\n                res += st[l++];\\n\\n            if (r&1) \\n                res += st[--r];\\n        }\\n        return res;\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        map<int,int> dp;\\n        for(int i=0;i<nums.size();i++){\\n            dp[nums[i]]=i;\\n        }\\n        \\n        vector<int> m {-1};\\n        long long ans =0;\\n        int pi=-1;\\n        int sz = nums.size();\\n        int lb=0;\\n        vector<int> st (2*sz,0);\\n        for(auto const& [key, val] : dp){\\n            if (val>pi){\\n                lb = query(pi+1,val,sz,st);\\n                ans += val-pi-(lb);\\n            }\\n            else{\\n                lb = query(pi+1,sz,sz,st);\\n                ans += sz-1-pi-(lb);\\n                lb = query(0,val,sz,st);\\n                ans += val+1 - (lb);\\n            }\\n            pi = val;\\n            updateIndex(val,sz,st);\\n            //cout << \"ans:\" << ans << \" key:\" <<key << \" val:\" << val << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void updateIndex(int index,int sz,vector<int>& st){\\n        st[sz+index]++;\\n        index = sz+index;\\n        for (int i=index;i>1;i>>=1){\\n            st[i>>1] = st[i] + st[i^1];\\n        }\\n    }\\n    int query(int l,int r,int sz,vector<int>& st){\\n        int res = 0;\\n      \\n        // loop to find the sum in the range\\n        for (l += sz, r += sz; l < r; l >>= 1, r >>= 1)\\n        {\\n            if (l&1) \\n                res += st[l++];\\n\\n            if (r&1) \\n                res += st[--r];\\n        }\\n        return res;\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        map<int,int> dp;\\n        for(int i=0;i<nums.size();i++){\\n            dp[nums[i]]=i;\\n        }\\n        \\n        vector<int> m {-1};\\n        long long ans =0;\\n        int pi=-1;\\n        int sz = nums.size();\\n        int lb=0;\\n        vector<int> st (2*sz,0);\\n        for(auto const& [key, val] : dp){\\n            if (val>pi){\\n                lb = query(pi+1,val,sz,st);\\n                ans += val-pi-(lb);\\n            }\\n            else{\\n                lb = query(pi+1,sz,sz,st);\\n                ans += sz-1-pi-(lb);\\n                lb = query(0,val,sz,st);\\n                ans += val+1 - (lb);\\n            }\\n            pi = val;\\n            updateIndex(val,sz,st);\\n            //cout << \"ans:\" << ans << \" key:\" <<key << \" val:\" << val << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3515271,
                "title": "c-solution-using-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int size;\\n    vector<int> tree;\\n    void add(int pos) {\\n        tree[size + pos - 1] = 1;\\n        for (int i = (size + pos - 2) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        if (size > 1) {\\n            tree[0] = tree[1] + tree[2];\\n        }\\n    }\\n    int getSum(int root, int l, int r, int left, int right) {\\n        if (right < l || left > r) return 0;\\n        if (left >= l && right <= r) return tree[root];\\n        int mid = (left + right) / 2;\\n        return getSum(2 * root + 1, l, r, left, mid) + getSum(2 * root + 2, l, r, mid + 1, right);\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> in(n);\\n        iota(in.begin(), in.end(), 0);\\n        sort(in.begin(), in.end(), [&] (int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        size = 1;\\n        while (size < n) {\\n            size *= 2;\\n        }\\n        tree = vector<int> (2 * size - 1);\\n        int cur = 0;\\n        long long sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int pos = in[i];\\n            if (cur <= pos) {\\n                int sum = getSum(0, cur, pos, 0, size - 1);\\n                int diff = pos - cur - sum;\\n                sol += diff + 1;\\n            } else {\\n                int sum = getSum(0, cur, n - 1, 0, size - 1);\\n                sum += getSum(0, 0, pos, 0, size - 1);\\n                int diff = n - (cur - pos) - sum;\\n                sol += diff + 1;\\n            }\\n            add(pos);\\n            cur = (pos + 1) % n;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int size;\\n    vector<int> tree;\\n    void add(int pos) {\\n        tree[size + pos - 1] = 1;\\n        for (int i = (size + pos - 2) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        if (size > 1) {\\n            tree[0] = tree[1] + tree[2];\\n        }\\n    }\\n    int getSum(int root, int l, int r, int left, int right) {\\n        if (right < l || left > r) return 0;\\n        if (left >= l && right <= r) return tree[root];\\n        int mid = (left + right) / 2;\\n        return getSum(2 * root + 1, l, r, left, mid) + getSum(2 * root + 2, l, r, mid + 1, right);\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> in(n);\\n        iota(in.begin(), in.end(), 0);\\n        sort(in.begin(), in.end(), [&] (int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        size = 1;\\n        while (size < n) {\\n            size *= 2;\\n        }\\n        tree = vector<int> (2 * size - 1);\\n        int cur = 0;\\n        long long sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int pos = in[i];\\n            if (cur <= pos) {\\n                int sum = getSum(0, cur, pos, 0, size - 1);\\n                int diff = pos - cur - sum;\\n                sol += diff + 1;\\n            } else {\\n                int sum = getSum(0, cur, n - 1, 0, size - 1);\\n                sum += getSum(0, 0, pos, 0, size - 1);\\n                int diff = n - (cur - pos) - sum;\\n                sol += diff + 1;\\n            }\\n            add(pos);\\n            cur = (pos + 1) % n;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514029,
                "title": "javascript-segmenttree-range-sum-query-fenwick-bit-two-solutions",
                "content": "segmentTree range Sum Query: 484ms\\n```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] + a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        return query(0, r + 1) - query(0, l);\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, st = new SegmentTreeRSQ(n + 3), res = n, pre = 0, f = Array(n + 1).fill(0);\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - st.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - st.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (st.rangeSum(0, n) - st.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        st.update(idx, ++f[idx]);\\n    })\\n    return res;\\n};\\n```\\n\\nfenwick: 386ms\\n```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, fen = new Fenwick(n + 3), res = n, pre = 0;\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - fen.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - fen.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (fen.rangeSum(0, n) - fen.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        fen.update(idx, 1);\\n    })\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] + a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        return query(0, r + 1) - query(0, l);\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, st = new SegmentTreeRSQ(n + 3), res = n, pre = 0, f = Array(n + 1).fill(0);\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - st.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - st.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (st.rangeSum(0, n) - st.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        st.update(idx, ++f[idx]);\\n    })\\n    return res;\\n};\\n```\n```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, fen = new Fenwick(n + 3), res = n, pre = 0;\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - fen.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - fen.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (fen.rangeSum(0, n) - fen.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        fen.update(idx, 1);\\n    })\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505447,
                "title": "image-explanation-intuition-c-short-and-crisp-code",
                "content": "# Image Explanation\\n\\n![Screenshot 2023-05-09 at 21.07.31.png](https://assets.leetcode.com/users/images/23c9ea64-8920-4031-83f5-840b7097c570_1683647657.873008.png)\\n\\n\\n![Screenshot 2023-05-09 at 21.07.49.png](https://assets.leetcode.com/users/images/cf9dffee-6b38-4811-a868-9602e5ec78cb_1683647669.3865345.png)\\n\\n![Screenshot 2023-05-09 at 21.08.03.png](https://assets.leetcode.com/users/images/19c636fe-4822-4209-8570-a6ed91e93cf4_1683647712.5779226.png)\\n\\n![Screenshot 2023-05-09 at 21.10.41.png](https://assets.leetcode.com/users/images/8142fe0d-2646-406f-961e-4896b47dd6d2_1683647730.8425517.png)\\n\\n![Screenshot 2023-05-09 at 21.25.14.png](https://assets.leetcode.com/users/images/d569af1c-c477-431c-a95e-f0d5233f66ed_1683647779.9984515.png)\\n\\n![Screenshot 2023-05-09 at 21.44.20.png](https://assets.leetcode.com/users/images/72580a1f-10be-4be5-95ed-079ec19c47cd_1683648710.4338896.png)\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ind(n, 0);\\n        iota(ind.begin(), ind.end(), 0);\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {return nums[a] < nums[b];});\\n\\n        long long res = 0;\\n        for(int i = 1; i < n; i++){\\n            if(ind[i] < ind[i - 1]){\\n                long long shift1 = ind[i - 1] - (i - 1);\\n                long long shift2 = (n - i) - shift1;\\n\\n                res += shift1 + shift2;\\n            }\\n        }\\n        return res + n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ind(n, 0);\\n        iota(ind.begin(), ind.end(), 0);\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {return nums[a] < nums[b];});\\n\\n        long long res = 0;\\n        for(int i = 1; i < n; i++){\\n            if(ind[i] < ind[i - 1]){\\n                long long shift1 = ind[i - 1] - (i - 1);\\n                long long shift2 = (n - i) - shift1;\\n\\n                res += shift1 + shift2;\\n            }\\n        }\\n        return res + n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497072,
                "title": "python-sort-greedy-o-n-log-n-explained",
                "content": "1. Consider the example, `[2,0,1,4,3]`. Let\\'s start by counting directly:\\n\\t1-1. In first round, we go through 2, 0, 1, 4, 3.\\n\\t1-2. In second round, 2, 4, 3.\\n\\t1-3. In third round, 4.\\n\\t1-4. The answer of this example is `5+3+1 = 9`.\\n2. In first round, `2` appeares before `1`, so we can\\'t remove `2` in first round. \\nIn second round, we go through the remaining 3 numbers, and since `4` appeares before `3`, we can\\'t remove `4` in second round.\\nIn third round, go through the only remaining number.\\n3. The action \"count\" described above is equivalent to the operations we can perform. \\nWhen we count a number `n`, that means we rotate the remaining array to the one with `n` being the first element.\\n4. We sort `nums` and keep the original indices. Let `l` be the length of `nums`.\\nIf the index of `n_i` is smaller than the index of `n_i-1`, we\\'ll need another round with `l-i` numbers remaining, so we add `l-i` to `ans`.\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        arr = sorted([(n, idx) for idx, n in enumerate(nums)])\\n        ans = l\\n        for i in range(1, l):\\n            if arr[i][1] < arr[i-1][1]:\\n                ans += l - i\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Consider the example, `[2,0,1,4,3]`. Let\\'s start by counting directly:\\n\\t1-1. In first round, we go through 2, 0, 1, 4, 3.\\n\\t1-2. In second round, 2, 4, 3.\\n\\t1-3. In third round, 4.\\n\\t1-4. The answer of this example is `5+3+1 = 9`.\\n2. In first round, `2` appeares before `1`, so we can\\'t remove `2` in first round. \\nIn second round, we go through the remaining 3 numbers, and since `4` appeares before `3`, we can\\'t remove `4` in second round.\\nIn third round, go through the only remaining number.\\n3. The action \"count\" described above is equivalent to the operations we can perform. \\nWhen we count a number `n`, that means we rotate the remaining array to the one with `n` being the first element.\\n4. We sort `nums` and keep the original indices. Let `l` be the length of `nums`.\\nIf the index of `n_i` is smaller than the index of `n_i-1`, we\\'ll need another round with `l-i` numbers remaining, so we add `l-i` to `ans`.\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        arr = sorted([(n, idx) for idx, n in enumerate(nums)])\\n        ans = l\\n        for i in range(1, l):\\n            if arr[i][1] < arr[i-1][1]:\\n                ans += l - i\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3490725,
                "title": "c-solution-using-the-c-programming-language-not-c",
                "content": "\\n\\n# Code\\n```\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3485515,
                "title": "why-n-i",
                "content": "# Why are everyone so smart\\nGoing through many solutions and comments similar to the one below - I still didn\\'t get why the hack it works. I tried a few examples myself and want to share my thoughts.\\nIf anyone happens to have link to the proof of why it works - please share, I\\'d love to check it out.\\n\\n## My understanding\\n* I interpret the initialization `res = sz` as in we must pop all elements in the array at some point so the result is init with n/sz.\\n    * so we just need to count the # of rotations needed after this.\\n\\n## why `res += sz-i` ?\\n* the part that I am most confused is why does the sorted index `i` have to do with result?\\n* TL;DR \\n    - I interpret `sz - i` as the # of rotations to rotate all elements represented in [i, n) in the sorted array to the right of smaller elements.\\n\\nHere is an example. To not confuse my tiny brain with too much numbers, I use letters to represent the input.\\n\\n### Example\\ndef ghi abc\\n012 345 678 - original indices\\n\\nJust by inspecting, we know we need to shift `defghi` to the right then everything becomes sorted and can be popped one after anohter, so it take 6(shifting) + 9(popping) = 15 operations.\\n\\nAfter sorting:\\nabc def ghi\\n678 012 345\\n012 345 678 - the `i` in the sorted index array.\\n\\nwe can see `ids[3]=0 < ids[2]=8` is the only case that hits the `ids[i] < ids[i - 1]` check, and it is the only one that contributes to res by `sz-i` which is (9 - 3 = 6), so total is 6 (rotating) + 9(popping) = 15.\\n\\nIn other words, once we see a `ids[i] < ids[i - 1]`, it means we need shift [i,n) in the original array by some operations so that everything smaller than what i represent are to the left. \\nSince the array is sorted, everything with index >=i are larger elements, and we need to shift them to the right of the smaller elements.\\nHow many operations are needed to shift them? - the size of [i, n), which is `n-i`. \\n\\n# Code - Copied from [votrubac](https://leetcode.com/votrubac/)\\'s [solution](https://leetcode.com/problems/make-array-empty/solutions/3466620/count-rotations-vs-bit/)\\n```\\nclass Solution {\\npublic:\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        if (ids[i] < ids[i - 1]) {\\n            res += sz - i;\\n        }\\n    return res + sz;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        if (ids[i] < ids[i - 1]) {\\n            res += sz - i;\\n        }\\n    return res + sz;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484322,
                "title": "scala-zip-zip-zip-sumlong",
                "content": "# Code\\n```\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3476316,
                "title": "lazy-rotation",
                "content": "# Intuition\\n\\nCost of delete:\\nWe ignore the cost of rotation. When deleting a nums[i], we \"+1\" to the \"cost of delete\" to all numbers before nums[i], so that later when deleting any of nums[0]~nums[i-1] we will see +1 to the cost deleting it. This way, the cost of rotation is delayed and distributed to individual numbers at delete time, we only need to care about how many times each number is rotated.\\n\\nPending rotation:\\nIf we delete nums[i], we don\\'t immediately rotate it, but making nums[0]~nums[i] a pending rotation state. \"Pending rotation state\" will only last one round and will be resolved immediately in the next round.\\nWe can later prove that:\\n1. There is always only one \"pending rotation\" part, \\n2. The \"pending rotation\" part will always stay in the head, not middle.\\n3. No matter how we rotate the array, the array will always turn back to its original nums[0]~nums[n] order, with a \"pending rotation\" head.\\n\\nLet\\'s start:\\n1. Delete nums[i]. nums[0]~nums[i-1] becomes \"pending rotation\", don\\'t actually rotate it yet.\\n2. Delete nums[j], \\n**If j>i**:\\nThis is same as directly deleting nums[j] without deleting nums[i]. Just cancel the previous pending state of rotating nums[0]~nums[i-1]. The new array is unchanged, still nums[0]~nums[n-1] same as orignal array, new pending rotation numbers become nums[0]~nums[j-1].\\n    **Cost of delete:** unchanged\\n\\n    **If j<i**:\\n    1. Resolve previous pending state by rotating nums[0]~nums[i-1] to the end, array becomes nums[i+1]~nums[n-1]+nums[0]~nums[i-1]\\n    2. Rotate nums[i+1]~nums[n-1] to the end, array becomes: nums[0]~nums[n-1], we are back to original nums[0]~nums[n-1] again.\\n    3. Lazy rotate nums[0]~nums[j] by setting as pending rotation.\\n    4. Step #2 and #3 combined is same as rotating all numbers before nums[j], which is the required rotation when deleting nums[j].\\n\\n    **Cost of delete:** every single number in the whole array is rotated, +1 to \"cost of delete\" to all numbers. The lazy pending part actually requires +2 to the \"cost of delete\", but we don\\'t consider it because the lazy part will be considered in the next step. \\n\\nDelete numbers from small to big, when deleting, add \"cost of delete\" that belongs to the deleted number to the final result.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        res,cost_of_delete,prev_i = 0,1,-1\\n        for v,i in sorted([[v,i] for i,v in enumerate(nums)]):\\n            if i<prev_i: cost_of_delete += 1\\n            res += cost_of_delete\\n            prev_i = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        res,cost_of_delete,prev_i = 0,1,-1\\n        for v,i in sorted([[v,i] for i,v in enumerate(nums)]):\\n            if i<prev_i: cost_of_delete += 1\\n            res += cost_of_delete\\n            prev_i = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475902,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        Arrays.sort(nums);\\n        long res = nums.length;\\n        for(int i = 1; i < nums.length; i++){\\n            if(map.get(nums[i]) < map.get(nums[i - 1]))\\n                res += nums.length - i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        Arrays.sort(nums);\\n        long res = nums.length;\\n        for(int i = 1; i < nums.length; i++){\\n            if(map.get(nums[i]) < map.get(nums[i - 1]))\\n                res += nums.length - i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475088,
                "title": "easy-to-understand-fenwick-tree-solution",
                "content": "# Intuition\\nIf there are some numbers before smallest num they should be rotated to the end before smallest can be removed + one operation to actually delete element.\\n\\n# Approach\\nWe remove numbers from smallest to largest using sorted arr. For each num in sorted arr: we also track prev & cur indexes in original input array.\\n\\n**With prev & cur there is can be two cases**:\\n**prev <= cur**: We do range(prev, cur) coz: we don\\'t want to count num of els before prev, we did it before when calculated num of ops for prev\\n\\n**prev > cur**: We do range(prev, n) coz: if cur before prev, then to rm prev we\\'d rotate cur to end of arr(num of els in end[after p]: n-p);\\nWe do range(0, cur) coz: those els wb rotated to end before cur cb removed\\n\\nAfter smallest element removed we update(-1) BIT counts of all larger indexes.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n\\n        // Fenwick tree(BIT): idx & in brackets - count how many els < cur el\\n        //       0\\n        //   /   |   \\\\\\n        // 1(1) 2(2)  4(4)\\n        //      |\\n        //     3(1)\\n        //\\n        // 0 1 2 3 4\\n        //\\n        // 3,2,1,5,6\\n        // 0,1,2,3,4 We work with pos of input arr, sorted arr just tells us which pos to rm 1st(e.g. 1) rm pos 2, 2) pos 1, etc)\\n        // Idea:\\n        // BIT used to quickly find ranges between indexes, and updated counts of els in O(logN) time.\\n        // Initially it keeps counts for all els, for same lengths wb same counts eg: 54321 or 31245 -> 12345(count num of els smaller than i-th el(incl))\\n        //\\n        // Explaining conditions:\\n        // prev <= cur: We do range(prev, cur) coz: we don\\'t want to count num of els before prev, we did it before when calculated num of ops for prev\\n        //              123->23\\n        // E.g. case: 312 -> 0 1 2  -> 0 1 2(we already rotated 3 to rm 1, don\\'t need to count it again to rm 2)\\n        //              1 2 3     1 1 2\\n        //\\n        // prev > cur: We do range(prev, n) coz: if cur before prev, then to rm prev we\\'d rotate cur to end of arr(num of els in end[after p]: n-p);\\n        //             We do range(0, cur) coz: those els wb rotated to end before cur cb removed\\n        // Input 32156 -> 15632->5632        ->2563->563  -> 356->56      56->6        6 -> []\\n        //                    c     rm: i=2       c p        c p          p     c            p c\\n        // E.g. case: 32156 -> 0 1 2 3 4(indexes) -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> Done!\\n        //        counts: 1 2 3 4 5 val=1       1 2 2 3 4    1 1 1 2 3    0 0 0 1 2    0 0 0 0 1\\n        //        2 els before i=2,val=1,   r(2,4) 2 els     r(1,4)=2     r(0,3)=0     r(3,4)=0\\n        //        ops += 2                 + r(0,1) 1 el    + r(0,0)=0\\n        //                                 ops += 3\\n        public long countOperationsToEmptyArray(int[] nums) {\\n            int n = nums.length;\\n            var originalPos = new HashMap<Integer, Integer>(); // num-origPos map\\n            var tree = new FenwickTree(n);\\n\\n            for (int i = 0; i < n; i++) originalPos.put(nums[i], i); // has orig idx\\n            Arrays.sort(nums);\\n            for (int i = 0; i < n; i++) tree.update(i, 1); // counts for input arr\\n\\n            int prev = 0; // we use 0 prev, so for 1st iter tree.countSmaller(-1)=0 which gives correct answer\\n            long operations = 0;\\n            for (int num : nums) {\\n                int cur = originalPos.get(num);\\n\\n                if (cur >= prev) operations += tree.range(prev, cur); // -1 to don\\'t count cur el\\n                else operations += tree.range(prev, n) + tree.range(0, cur);\\n\\n                tree.update(cur, -1); // remove element from BIT\\n                prev = cur;\\n                operations++; // remove element\\n            }\\n\\n            return operations;\\n        }\\n\\n        private static class FenwickTree {\\n            private final int[] tree;\\n\\n            FenwickTree(int n) {\\n                tree = new int[n + 1];\\n            }\\n\\n            void update(int i, int val) { // incr index i by x\\n                i++; // BIT has +1 offset\\n                while(i < tree.length) {\\n                    tree[i] += val;\\n                    i += lsb(i);\\n                }\\n            }\\n\\n            private int lsb(int i) {\\n                return i & -i;\\n            }\\n\\n            int countSmaller(int i) { // count num of smaller elements than i(inclusive)\\n                i++; // BIT has +1 offset\\n                int count = 0;\\n\\n                while(i > 0) {\\n                    count += tree[i];\\n                    i -= lsb(i);\\n                }\\n\\n                return count;\\n            }\\n\\n            int range(int fromIdx, int toIdx) { // count num of els in range (from, to)\\n                return countSmaller(toIdx - 1) - countSmaller(fromIdx - 1);\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n        // Fenwick tree(BIT): idx & in brackets - count how many els < cur el\\n        //       0\\n        //   /   |   \\\\\\n        // 1(1) 2(2)  4(4)\\n        //      |\\n        //     3(1)\\n        //\\n        // 0 1 2 3 4\\n        //\\n        // 3,2,1,5,6\\n        // 0,1,2,3,4 We work with pos of input arr, sorted arr just tells us which pos to rm 1st(e.g. 1) rm pos 2, 2) pos 1, etc)\\n        // Idea:\\n        // BIT used to quickly find ranges between indexes, and updated counts of els in O(logN) time.\\n        // Initially it keeps counts for all els, for same lengths wb same counts eg: 54321 or 31245 -> 12345(count num of els smaller than i-th el(incl))\\n        //\\n        // Explaining conditions:\\n        // prev <= cur: We do range(prev, cur) coz: we don\\'t want to count num of els before prev, we did it before when calculated num of ops for prev\\n        //              123->23\\n        // E.g. case: 312 -> 0 1 2  -> 0 1 2(we already rotated 3 to rm 1, don\\'t need to count it again to rm 2)\\n        //              1 2 3     1 1 2\\n        //\\n        // prev > cur: We do range(prev, n) coz: if cur before prev, then to rm prev we\\'d rotate cur to end of arr(num of els in end[after p]: n-p);\\n        //             We do range(0, cur) coz: those els wb rotated to end before cur cb removed\\n        // Input 32156 -> 15632->5632        ->2563->563  -> 356->56      56->6        6 -> []\\n        //                    c     rm: i=2       c p        c p          p     c            p c\\n        // E.g. case: 32156 -> 0 1 2 3 4(indexes) -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> Done!\\n        //        counts: 1 2 3 4 5 val=1       1 2 2 3 4    1 1 1 2 3    0 0 0 1 2    0 0 0 0 1\\n        //        2 els before i=2,val=1,   r(2,4) 2 els     r(1,4)=2     r(0,3)=0     r(3,4)=0\\n        //        ops += 2                 + r(0,1) 1 el    + r(0,0)=0\\n        //                                 ops += 3\\n        public long countOperationsToEmptyArray(int[] nums) {\\n            int n = nums.length;\\n            var originalPos = new HashMap<Integer, Integer>(); // num-origPos map\\n            var tree = new FenwickTree(n);\\n\\n            for (int i = 0; i < n; i++) originalPos.put(nums[i], i); // has orig idx\\n            Arrays.sort(nums);\\n            for (int i = 0; i < n; i++) tree.update(i, 1); // counts for input arr\\n\\n            int prev = 0; // we use 0 prev, so for 1st iter tree.countSmaller(-1)=0 which gives correct answer\\n            long operations = 0;\\n            for (int num : nums) {\\n                int cur = originalPos.get(num);\\n\\n                if (cur >= prev) operations += tree.range(prev, cur); // -1 to don\\'t count cur el\\n                else operations += tree.range(prev, n) + tree.range(0, cur);\\n\\n                tree.update(cur, -1); // remove element from BIT\\n                prev = cur;\\n                operations++; // remove element\\n            }\\n\\n            return operations;\\n        }\\n\\n        private static class FenwickTree {\\n            private final int[] tree;\\n\\n            FenwickTree(int n) {\\n                tree = new int[n + 1];\\n            }\\n\\n            void update(int i, int val) { // incr index i by x\\n                i++; // BIT has +1 offset\\n                while(i < tree.length) {\\n                    tree[i] += val;\\n                    i += lsb(i);\\n                }\\n            }\\n\\n            private int lsb(int i) {\\n                return i & -i;\\n            }\\n\\n            int countSmaller(int i) { // count num of smaller elements than i(inclusive)\\n                i++; // BIT has +1 offset\\n                int count = 0;\\n\\n                while(i > 0) {\\n                    count += tree[i];\\n                    i -= lsb(i);\\n                }\\n\\n                return count;\\n            }\\n\\n            int range(int fromIdx, int toIdx) { // count num of els in range (from, to)\\n                return countSmaller(toIdx - 1) - countSmaller(fromIdx - 1);\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474270,
                "title": "o-n-log-n-short-solution-with-sorting-beating-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe brute-force solution with simulation can be as slow as $$O(N^2)$$ for the worst case. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of simulation, my solution analyzes the sequence from left to right and finds all the 1-step increasing subsequences. For the input [3, 4, 1, 2, 7, 6], all the 1-step increasing subsequences are [3, 4, 6], [1, 2], and [7]. The smallest subsequence [1, 2] will be done in the first turn, so the cost is only 2. Next, the second smallest subseuquence [3, 4, 6] will be done in the second turn, so the cost is 3 + 3. Finally, the cost of the largest subsequence [7] is 2+1. The resultant total cost is 2+6+3 = 11.\\n\\nTo perform this solution, the input should be mapped to continouos numbers from 1 to n. So the first two lines are used to create the numbers. \\n\\n# Complexity\\n- Time complexity: $$O(N log N)$$ for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_order = {v: k for k, v in enumerate(sorted(nums))}\\n        nums = [num_order[k] for k in nums]\\n\\n        groups = {}\\n        sizes = {}\\n        for v in nums:\\n            if v - 1 in groups:\\n                groups[v] = groups[v-1]\\n                sizes[groups[v]] += 1\\n            else:\\n                groups[v] = v\\n                sizes[v] = 1\\n        turn = 1\\n        ans = 0\\n        for k, v in sorted([(k, v) for k, v in sizes.items()]):\\n            ans += turn * v \\n            turn += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_order = {v: k for k, v in enumerate(sorted(nums))}\\n        nums = [num_order[k] for k in nums]\\n\\n        groups = {}\\n        sizes = {}\\n        for v in nums:\\n            if v - 1 in groups:\\n                groups[v] = groups[v-1]\\n                sizes[groups[v]] += 1\\n            else:\\n                groups[v] = v\\n                sizes[v] = 1\\n        turn = 1\\n        ans = 0\\n        for k, v in sorted([(k, v) for k, v in sizes.items()]):\\n            ans += turn * v \\n            turn += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474136,
                "title": "make-array-empty-using-dsu-disjoint-set-union",
                "content": "# Intuition\\nThe intution might seem lengthy but give it a read you might find it useful.\\n\\nSolved this using the Disjoint Set Union(DSU) even though simpler method can also be used.\\nA number can either be removed or pushed back to the end, both take only 1 operation.\\nLet n be the current size of the array.\\nIf we apply the operation n times, an element will either be removed or pushed back.\\n\\nEx: nums -> 4,5,0,2,1  n -> 5\\nAfter applying 5 operations: nums -> 4,5,2\\nThis shows that after applying 5 operations the smallest element will be removed and the element that comes just after it in the sorted order.\\nNow the size of array is reduced, n -> 3\\nAfter applying 3 more operations: nums -> 4,5\\nNow the size of array is reduced again, n -> 2\\nAfter applying two more operations: nums -> {empty array}\\nSo the total no. of operations required are 5+3+2 = 10\\n\\nModifying the array and traversing it again and again will cause TLE.\\nSo we can groups the elements while traversing the array in one go.\\nFirst if we come across an element, we check if the element that comes just before the current element in the sorted array has appeared or not. If the previous element has appeared we group them togther otherwise if the previous element has not appeared we create a new group for the current group.\\nFor the above example the grouping will be something like this : [0,1] [2] [4,5].\\nNow we add the current size of the array to our answer and remove the group which contains the smallest element and reduce the size of the array be the size of that group. We do this until all the groups are removed and after this we get our final answer.\\n\\nThe grouping might seem very redundant and time consuming but it can be easily done using Disjoint Set Union properties.\\nSince all the element are distinct we can map the element in sorted order like 0,1,2..and so on to make it easier to implement the DSU.\\nWe only need to determine the group in which the element belong and DSU takes care of the grouping and the size of the group.\\n\\n**I haven\\'t explained it in the best possible way but upvote it if you understood my implementation or comment if you have any doubt.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:All DSU operations and sorting parallely take O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass DisjointSet\\n{\\npublic:\\n    vector<int> parent;\\n    vector<int> size;\\n//size n+1 is taken in case of 1 based indexing is used.\\n    DisjointSet(int n){\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            parent[i]=i;\\n        }\\n    }\\n    \\n//This finds the ultimate parent of a node and also does path compression.\\n    int ulParent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=ulParent(parent[node]);\\n    }\\n    \\n//This performs union by size of node u and v.\\n    void unionBySize(int u, int v){\\n        int ulp_u = ulParent(u);\\n        int ulp_v = ulParent(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(size[ulp_u] < size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        unordered_map<int,int> m, m2;\\n        DisjointSet ds(n);\\n        vector<int> v;\\n        \\n        for(auto it : nums)v.push_back(it);\\n\\n        sort(v.begin(),v.end());\\n\\n        for(int i=0;i<n;i++){\\n            m[v[i]] = i;\\n        }\\n\\n        for(auto it : nums){\\n            int x = m[it];\\n            if(m2.find(x-1) != m2.end()){\\n                ds.unionBySize(x-1, x);\\n            }\\n            m2[x] = 1;\\n        }\\n\\n        long long num = n;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i] == i){\\n                ans += num;\\n                num -= ds.size[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet\\n{\\npublic:\\n    vector<int> parent;\\n    vector<int> size;\\n//size n+1 is taken in case of 1 based indexing is used.\\n    DisjointSet(int n){\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            parent[i]=i;\\n        }\\n    }\\n    \\n//This finds the ultimate parent of a node and also does path compression.\\n    int ulParent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=ulParent(parent[node]);\\n    }\\n    \\n//This performs union by size of node u and v.\\n    void unionBySize(int u, int v){\\n        int ulp_u = ulParent(u);\\n        int ulp_v = ulParent(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(size[ulp_u] < size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        unordered_map<int,int> m, m2;\\n        DisjointSet ds(n);\\n        vector<int> v;\\n        \\n        for(auto it : nums)v.push_back(it);\\n\\n        sort(v.begin(),v.end());\\n\\n        for(int i=0;i<n;i++){\\n            m[v[i]] = i;\\n        }\\n\\n        for(auto it : nums){\\n            int x = m[it];\\n            if(m2.find(x-1) != m2.end()){\\n                ds.unionBySize(x-1, x);\\n            }\\n            m2[x] = 1;\\n        }\\n\\n        long long num = n;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i] == i){\\n                ans += num;\\n                num -= ds.size[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472552,
                "title": "solution-using-map-and-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> ans;\\n        long long n = A.size(), res = n;\\n        for(int i = 0; i < n; ++i)\\n            ans[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for(int i = 1; i < n; ++i)\\n        {\\n            if (ans[A[i]] < ans[A[i - 1]])\\n                res += n - i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> ans;\\n        long long n = A.size(), res = n;\\n        for(int i = 0; i < n; ++i)\\n            ans[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for(int i = 1; i < n; ++i)\\n        {\\n            if (ans[A[i]] < ans[A[i - 1]])\\n                res += n - i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472450,
                "title": "c-segment-tree",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static int maxn=1e5+10;\\n    ll seg[maxn<<2];\\n    void init_seg(int cur,int l,int r)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=1;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        init_seg(cur<<1,l,mid);\\n        init_seg(cur<<1|1,mid,r);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    int query(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(ql>=r||qr<=l)return 0;\\n        int mid=(l+r)>>1;\\n        return query(cur<<1,l,mid,ql,qr)+query(cur<<1|1,mid,r,ql,qr);\\n    }\\n    void update(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=0;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(target<mid)update(cur<<1,l,mid,target);\\n        else update(cur<<1|1,mid,r,target);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        init_seg(1,0,n);\\n        vector<pair<int,int>>seq(n);\\n        for(int i=0;i<n;i++)seq[i]={nums[i],i};\\n        sort(seq.begin(),seq.end());\\n        ll res=0;\\n        int cur_idx=0;\\n        for(auto &x:seq)\\n        {\\n            int nxt_idx=x.second;\\n            if(cur_idx<nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,nxt_idx);\\n                res+=query(1,0,n,cur_idx,nxt_idx);\\n            }else if(cur_idx>nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,n);\\n                int t2=query(1,0,n,0,nxt_idx);\\n                res+=query(1,0,n,cur_idx,n)+query(1,0,n,0,nxt_idx);\\n            }\\n            update(1,0,n,nxt_idx);\\n            cur_idx=(nxt_idx+1)%n;\\n            res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static int maxn=1e5+10;\\n    ll seg[maxn<<2];\\n    void init_seg(int cur,int l,int r)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=1;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        init_seg(cur<<1,l,mid);\\n        init_seg(cur<<1|1,mid,r);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    int query(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(ql>=r||qr<=l)return 0;\\n        int mid=(l+r)>>1;\\n        return query(cur<<1,l,mid,ql,qr)+query(cur<<1|1,mid,r,ql,qr);\\n    }\\n    void update(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=0;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(target<mid)update(cur<<1,l,mid,target);\\n        else update(cur<<1|1,mid,r,target);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        init_seg(1,0,n);\\n        vector<pair<int,int>>seq(n);\\n        for(int i=0;i<n;i++)seq[i]={nums[i],i};\\n        sort(seq.begin(),seq.end());\\n        ll res=0;\\n        int cur_idx=0;\\n        for(auto &x:seq)\\n        {\\n            int nxt_idx=x.second;\\n            if(cur_idx<nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,nxt_idx);\\n                res+=query(1,0,n,cur_idx,nxt_idx);\\n            }else if(cur_idx>nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,n);\\n                int t2=query(1,0,n,0,nxt_idx);\\n                res+=query(1,0,n,cur_idx,n)+query(1,0,n,0,nxt_idx);\\n            }\\n            update(1,0,n,nxt_idx);\\n            cur_idx=(nxt_idx+1)%n;\\n            res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472323,
                "title": "simple-easy-to-understand-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere **n** elements at first,\\nso there will take at least **n** operations.\\nAnd it take **n** operations rotate all elements once.\\n\\n\\n# Complexity\\n- Time complexity: O(n(log(n)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans=n;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=i;\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<n;i++){\\n            if(mp[nums[i]]<mp[nums[i-1]]){\\n                ans+= n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans=n;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=i;\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<n;i++){\\n            if(mp[nums[i]]<mp[nums[i-1]]){\\n                ans+= n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471087,
                "title": "java-solution-using-segment-tree",
                "content": "\\n# Time complexity:\\n   **O(nlogn)**\\n\\n# Space Complexity\\n   **O(n)**\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int[] segTree;\\n    \\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        segTree = new int[4*n];\\n        int[] greater = new int[n];\\n        \\n        int[] ind = getRelativeValuesAndIndex(nums);\\n                \\n        for(int i=0; i<n; i++){\\n            // Number of elements to the left of nums[i]\\n           // that is greater than nums[i]\\n            greater[i] = sum(nums[i],n,0,0,n);\\n            update(nums[i],0,0,n);\\n        }\\n        \\n        long count = greater[ind[0]];\\n        \\n        for(int i=1; i< n; i++){\\n            if(ind[i] > ind[i-1]){\\n                count+= greater[ind[i]] - greater[ind[i-1]];\\n            }else{\\n                count+= greater[ind[i]];\\n                int totGreaterEle = n-i;\\n                totGreaterEle-=greater[ind[i-1]];\\n                count+= totGreaterEle;\\n            }\\n        }\\n        \\n        return count+n;\\n    }\\n    \\n    private int[] getRelativeValuesAndIndex(int[] nums){\\n        List<Integer> temp = new ArrayList();\\n        for(int i=0; i< nums.length; i++){\\n            temp.add(i);\\n        }\\n        \\n        Collections.sort(temp, (i,j) -> nums[i] - nums[j]);\\n        \\n        for(int i=0; i< nums.length; i++){\\n            nums[temp.get(i)] = i;\\n        }\\n        \\n        \\n        return temp.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    \\n    \\n    private void update(int value, int pos, int low, int high){\\n        if(high < value || low > value)\\n            return;\\n        \\n        segTree[pos]++;\\n        if(low == high){\\n            return;\\n        }\\n        \\n        int mid = (low+high)/2;\\n        \\n        update(value, 2*pos+1, low,mid);\\n        update(value, 2*pos+2, mid+1, high);\\n        \\n    }\\n    \\n    private int sum(int l, int h, int pos, int low, int high){\\n        if(low > h || high < l)\\n            return 0;\\n        \\n        if(l <=low && high <= h)\\n            return segTree[pos];\\n        \\n        \\n        int mid = (low+high)/2;\\n        return sum(l,h, 2*pos+1, low,mid) + sum(l,h, 2*pos+2, mid+1, high);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] segTree;\\n    \\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        segTree = new int[4*n];\\n        int[] greater = new int[n];\\n        \\n        int[] ind = getRelativeValuesAndIndex(nums);\\n                \\n        for(int i=0; i<n; i++){\\n            // Number of elements to the left of nums[i]\\n           // that is greater than nums[i]\\n            greater[i] = sum(nums[i],n,0,0,n);\\n            update(nums[i],0,0,n);\\n        }\\n        \\n        long count = greater[ind[0]];\\n        \\n        for(int i=1; i< n; i++){\\n            if(ind[i] > ind[i-1]){\\n                count+= greater[ind[i]] - greater[ind[i-1]];\\n            }else{\\n                count+= greater[ind[i]];\\n                int totGreaterEle = n-i;\\n                totGreaterEle-=greater[ind[i-1]];\\n                count+= totGreaterEle;\\n            }\\n        }\\n        \\n        return count+n;\\n    }\\n    \\n    private int[] getRelativeValuesAndIndex(int[] nums){\\n        List<Integer> temp = new ArrayList();\\n        for(int i=0; i< nums.length; i++){\\n            temp.add(i);\\n        }\\n        \\n        Collections.sort(temp, (i,j) -> nums[i] - nums[j]);\\n        \\n        for(int i=0; i< nums.length; i++){\\n            nums[temp.get(i)] = i;\\n        }\\n        \\n        \\n        return temp.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    \\n    \\n    private void update(int value, int pos, int low, int high){\\n        if(high < value || low > value)\\n            return;\\n        \\n        segTree[pos]++;\\n        if(low == high){\\n            return;\\n        }\\n        \\n        int mid = (low+high)/2;\\n        \\n        update(value, 2*pos+1, low,mid);\\n        update(value, 2*pos+2, mid+1, high);\\n        \\n    }\\n    \\n    private int sum(int l, int h, int pos, int low, int high){\\n        if(low > h || high < l)\\n            return 0;\\n        \\n        if(l <=low && high <= h)\\n            return segTree[pos];\\n        \\n        \\n        int mid = (low+high)/2;\\n        return sum(l,h, 2*pos+1, low,mid) + sum(l,h, 2*pos+2, mid+1, high);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470964,
                "title": "c-queue",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n\\n    public long CountOperationsToEmptyArray(int[] A) {\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n        int n = A.Length, p = 0;\\n        long res = n;\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            d[A[i]] = i;\\n        }\\n\\n        Array.Sort(A);\\n\\n        for (int i = 0; i < n; p = d[A[i++]]) \\n        {\\n            if (d[A[i]] < p) \\n            {\\n                res += n - i;\\n            }\\n        }\\n        return res;\\n    }\\n\\n}\\n```\\n\\n# Nice Looking queue approach. Times out for last 4 test cases\\n\\n```\\npublic class Solution {\\n    public long CountOperationsToEmptyArray(int[] nums) \\n    {\\n        Queue<int> q = new Queue<int>(nums);\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 0;\\n        int minVal = nums[0];\\n        int currIndex = 0;\\n        \\n        \\n        \\n        while(currIndex < nums.Length)\\n        {\\n            int currentVal = q.Dequeue();\\n\\n            if(currentVal == minVal)\\n            {      \\n                currIndex++;\\n                if(currIndex < nums.Length)\\n                {\\n                    minVal = nums[currIndex]; \\n                }\\n                              \\n            }\\n            else\\n            {\\n                q.Enqueue(currentVal);\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public long CountOperationsToEmptyArray(int[] A) {\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n        int n = A.Length, p = 0;\\n        long res = n;\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            d[A[i]] = i;\\n        }\\n\\n        Array.Sort(A);\\n\\n        for (int i = 0; i < n; p = d[A[i++]]) \\n        {\\n            if (d[A[i]] < p) \\n            {\\n                res += n - i;\\n            }\\n        }\\n        return res;\\n    }\\n\\n}\\n```\n```\\npublic class Solution {\\n    public long CountOperationsToEmptyArray(int[] nums) \\n    {\\n        Queue<int> q = new Queue<int>(nums);\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 0;\\n        int minVal = nums[0];\\n        int currIndex = 0;\\n        \\n        \\n        \\n        while(currIndex < nums.Length)\\n        {\\n            int currentVal = q.Dequeue();\\n\\n            if(currentVal == minVal)\\n            {      \\n                currIndex++;\\n                if(currIndex < nums.Length)\\n                {\\n                    minVal = nums[currIndex]; \\n                }\\n                              \\n            }\\n            else\\n            {\\n                q.Enqueue(currentVal);\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470464,
                "title": "count-of-smaller-elements-on-either-side-python",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        arr=[(c,i) for i,c in enumerate(nums)]\\n        arr.sort()\\n        left,right=[0]*n,[0]*n\\n        l,r=SortedList(),SortedList()\\n        for i in range(n):\\n            idx=l.bisect_right(nums[i])\\n            left[i]=idx\\n            l.add(nums[i])\\n            j=n-i-1\\n            idx=r.bisect_right(nums[j])\\n            right[j]=idx\\n            r.add(nums[j])\\n        c,last=arr[0]\\n        ans=n+last\\n        for c,i in arr[1:]:\\n            if i>last:\\n                ans+=i-last-1-(right[last]-right[i])\\n            else:\\n                ans+=n-1-last+i-(right[last]+left[i])\\n            last=i\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        arr=[(c,i) for i,c in enumerate(nums)]\\n        arr.sort()\\n        left,right=[0]*n,[0]*n\\n        l,r=SortedList(),SortedList()\\n        for i in range(n):\\n            idx=l.bisect_right(nums[i])\\n            left[i]=idx\\n            l.add(nums[i])\\n            j=n-i-1\\n            idx=r.bisect_right(nums[j])\\n            right[j]=idx\\n            r.add(nums[j])\\n        c,last=arr[0]\\n        ans=n+last\\n        for c,i in arr[1:]:\\n            if i>last:\\n                ans+=i-last-1-(right[last]-right[i])\\n            else:\\n                ans+=n-1-last+i-(right[last]+left[i])\\n            last=i\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470322,
                "title": "c-fenwic-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll find(vector<ll>& fen,int v,int n){\\n        ll x=0;\\n        // v--;\\n        while(v<=n){\\n            x+=fen[v];\\n            v+=v&(-v);\\n        }\\n        return x;\\n    }\\n    void insert(vector<ll> &fen,int v){\\n        while(v>0){\\n            fen[v]++;\\n            v-=(v&(-v));\\n        }\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         vector<pair<int,int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n       vector<int> a(n);\\n        vector<int> index(n+1);\\n        for(int i=0;i<n;i++){\\n            a[v[i].second]=i+1;\\n            index[i+1]=v[i].second;\\n        }\\n        \\n        vector<ll> fen1(n+10),fen2(n+10);\\n        vector<ll> left(n),right(n);\\n        \\n        for(int i=0;i<n;i++){\\n            left[i]=find(fen1,a[i],n);\\n            insert(fen1,a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=find(fen2,a[i],n);\\n            insert(fen2,a[i]);\\n        }\\n        \\n        ll ans=0;\\n        \\n        int idx=index[1];\\n        int i=1;\\n        ans+=left[idx];\\n        int pre=idx;\\n        i++;\\n        while(i<=n){\\n             idx=index[i];\\n            \\n         if(pre>idx){\\n             ll l=left[idx];\\n             ll r=right[pre];\\n             // cout<<l+r;\\n             ans+=l+r;\\n         }else{\\n             ll l=left[pre];\\n             ll r=right[idx];\\n             // cout<<l+r;\\n             ans+=n-i-(l+r);\\n         }\\n            pre=idx;\\n           \\n            i++;\\n        }\\n        // for(auto k:right)cout<<k<<\" \";\\n        return ans+n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll find(vector<ll>& fen,int v,int n){\\n        ll x=0;\\n        // v--;\\n        while(v<=n){\\n            x+=fen[v];\\n            v+=v&(-v);\\n        }\\n        return x;\\n    }\\n    void insert(vector<ll> &fen,int v){\\n        while(v>0){\\n            fen[v]++;\\n            v-=(v&(-v));\\n        }\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         vector<pair<int,int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n       vector<int> a(n);\\n        vector<int> index(n+1);\\n        for(int i=0;i<n;i++){\\n            a[v[i].second]=i+1;\\n            index[i+1]=v[i].second;\\n        }\\n        \\n        vector<ll> fen1(n+10),fen2(n+10);\\n        vector<ll> left(n),right(n);\\n        \\n        for(int i=0;i<n;i++){\\n            left[i]=find(fen1,a[i],n);\\n            insert(fen1,a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=find(fen2,a[i],n);\\n            insert(fen2,a[i]);\\n        }\\n        \\n        ll ans=0;\\n        \\n        int idx=index[1];\\n        int i=1;\\n        ans+=left[idx];\\n        int pre=idx;\\n        i++;\\n        while(i<=n){\\n             idx=index[i];\\n            \\n         if(pre>idx){\\n             ll l=left[idx];\\n             ll r=right[pre];\\n             // cout<<l+r;\\n             ans+=l+r;\\n         }else{\\n             ll l=left[pre];\\n             ll r=right[idx];\\n             // cout<<l+r;\\n             ans+=n-i-(l+r);\\n         }\\n            pre=idx;\\n           \\n            i++;\\n        }\\n        // for(auto k:right)cout<<k<<\" \";\\n        return ans+n;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3469430,
                "title": "beginner-friendly-code-c",
                "content": "example:\\nPrerequiste :\\n1.Alteast n moves will be required for removing every element(for eg if the array is sorted)\\n2. To rotate every element once we will be having**n** moves.\\n\\t\\t\\t\\t\\t\\n####   array : 4 7 8 5 9 6\\n count = 6\\n###   step 1 : Make vector of Value and Index\\n   array : 4 7 8 5 9 6 \\n   Index: 0 1 2 3 4 5 \\n###    Step 2: Sort the vector pair on the value\\n\\narray : 4 5 6 7 8 9\\nindex: 0 3 5 1 2 4 \\n\\n### Step 3 : Check if i+1 is smaller than the i index\\n count=count + (n-i) \\n reason begin for (n-i) is : if the index of next element get smaller than current element then we have to rotate the whole array from that position to the end. \\n\\n\\t\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n    long count=0;\\n        int n=nums.size();\\n        vector<pair<int,int>>ans;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            ans.push_back({nums[j],j});\\n        }\\n        sort(ans.begin(),ans.end());\\n        count=nums.size();\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i-1].second>ans[i].second)\\n                count=count+(n-i);\\n        }\\n   return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n    long count=0;\\n        int n=nums.size();\\n        vector<pair<int,int>>ans;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            ans.push_back({nums[j],j});\\n        }\\n        sort(ans.begin(),ans.end());\\n        count=nums.size();\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i-1].second>ans[i].second)\\n                count=count+(n-i);\\n        }\\n   return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469412,
                "title": "python-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        for i in range(n):\\n            nums[i]=[nums[i],i]\\n        nums.sort(key=lambda x:x[0])\\n        count=0\\n        ans=n\\n        prev=0\\n        for i in range(1,n):\\n            if nums[i-1][1]>nums[i][1]:\\n                count+=1\\n            ans+=count\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        for i in range(n):\\n            nums[i]=[nums[i],i]\\n        nums.sort(key=lambda x:x[0])\\n        count=0\\n        ans=n\\n        prev=0\\n        for i in range(1,n):\\n            if nums[i-1][1]>nums[i][1]:\\n                count+=1\\n            ans+=count\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469345,
                "title": "100-faster-python",
                "content": "\\n# Intuition\\nimagine array to be circular and  iter through original index of sorted elements and keep track of steps traveled, in the end subtract number of times you crossed an element of each element.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        dic={nums[i]:i for i in range(len(nums))}\\n        nums.sort()\\n        dist=1\\n        prv=0\\n        arr=[0 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            ind=dic[nums[i]]\\n            temp=ind-prv\\n            if temp<0:\\n                dist+=len(nums)+temp\\n            else:\\n                dist+=temp\\n            arr[i]=dist\\n            prv=ind\\n        # print(arr,dist)    \\n        count=0    \\n        for i in arr:\\n            count+=(dist-i)//len(nums)\\n        return dist -count    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        dic={nums[i]:i for i in range(len(nums))}\\n        nums.sort()\\n        dist=1\\n        prv=0\\n        arr=[0 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            ind=dic[nums[i]]\\n            temp=ind-prv\\n            if temp<0:\\n                dist+=len(nums)+temp\\n            else:\\n                dist+=temp\\n            arr[i]=dist\\n            prv=ind\\n        # print(arr,dist)    \\n        count=0    \\n        for i in arr:\\n            count+=(dist-i)//len(nums)\\n        return dist -count    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469300,
                "title": "c-fenwickbtree-based-sln-o-n-logn-clean-code",
                "content": "\\n```\\n    class FenwickTree {\\n    public:\\n        FenwickTree(int n): v(n) {}\\n        \\n        int sum (int r) {\\n\\t        int result = 0;\\n\\t        for (; r >= 0; r = (r & (r+1)) - 1) {\\n                result += v[r];\\n            }   \\n\\t        return result;\\n        }\\n        \\n        void inc (int i, int delta) {\\n\\t        for (; i < size(v); i = (i | (i+1))) {\\n\\t\\t        v[i] += delta;\\n            }\\n        }\\n\\n        int sum (int l, int r) {\\n            if (l > r) return 0;\\n\\t        return sum (r) - sum (l-1);\\n        }\\n    private:\\n        vector<int> v;\\n    };\\n\\n\\nclass Solution {\\npublic:\\n    using ll = long long;    \\n    ll countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = size(nums);\\n        unordered_map<ll, ll> m;\\n        for (int i = 0; i < n; ++i) {\\n            m[nums[i]] = i;\\n        }\\n        sort(begin(nums), end(nums));\\n        FenwickTree ft(n);\\n        ft.inc(m[nums.front()], 1);\\n        ll ans = m[nums.front()];\\n        for (int i = 1; i < n; ++i) {\\n            int diff = 0;\\n            if (m[nums[i]] > m[nums[i - 1]]) {\\n                diff = m[nums[i]] - m[nums[i - 1]] - ft.sum(m[nums[i - 1]] + 1, m[nums[i]] - 1);\\n            } else {\\n                diff = n - m[nums[i - 1]] + m[nums[i]] - ft.sum(m[nums[i - 1]] + 1, n - 1) - ft.sum(0, m[nums[i]] - 1);\\n            }\\n            ft.inc(m[nums[i]], 1);\\n            ans += diff - 1;\\n        }\\n        return ans + size(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    class FenwickTree {\\n    public:\\n        FenwickTree(int n): v(n) {}\\n        \\n        int sum (int r) {\\n\\t        int result = 0;\\n\\t        for (; r >= 0; r = (r & (r+1)) - 1) {\\n                result += v[r];\\n            }   \\n\\t        return result;\\n        }\\n        \\n        void inc (int i, int delta) {\\n\\t        for (; i < size(v); i = (i | (i+1))) {\\n\\t\\t        v[i] += delta;\\n            }\\n        }\\n\\n        int sum (int l, int r) {\\n            if (l > r) return 0;\\n\\t        return sum (r) - sum (l-1);\\n        }\\n    private:\\n        vector<int> v;\\n    };\\n\\n\\nclass Solution {\\npublic:\\n    using ll = long long;    \\n    ll countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = size(nums);\\n        unordered_map<ll, ll> m;\\n        for (int i = 0; i < n; ++i) {\\n            m[nums[i]] = i;\\n        }\\n        sort(begin(nums), end(nums));\\n        FenwickTree ft(n);\\n        ft.inc(m[nums.front()], 1);\\n        ll ans = m[nums.front()];\\n        for (int i = 1; i < n; ++i) {\\n            int diff = 0;\\n            if (m[nums[i]] > m[nums[i - 1]]) {\\n                diff = m[nums[i]] - m[nums[i - 1]] - ft.sum(m[nums[i - 1]] + 1, m[nums[i]] - 1);\\n            } else {\\n                diff = n - m[nums[i - 1]] + m[nums[i]] - ft.sum(m[nums[i - 1]] + 1, n - 1) - ft.sum(0, m[nums[i]] - 1);\\n            }\\n            ft.inc(m[nums[i]], 1);\\n            ans += diff - 1;\\n        }\\n        return ans + size(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468822,
                "title": "simple-c-solution-using-map-o-n-logn",
                "content": "# Intuition\\nThe problem is asking to find the number of operations required to make the given array empty. In each operation, the maximum element in the array needs to be removed, and the sum of its value and the minimum value of the remaining array needs to be added to the answer. The approach is to sort the given array and then keep track of the number of elements greater than the current maximum element at any time.\\n\\nExample:\\nInput vector: [8, 1, 2, 4, 6, 3, 7, 5]\\n\\nSorted vector: [1, 2, 3, 4, 5, 6, 7, 8]\\nIf we go from left to right we see,\\n1, 2, 3 (3 elements) are in their expected order according to the sorted array\\nThen we have,\\n4, 5 (2 elements)\\n6, 7 (2 elements)\\n8 (1 element)\\n\\nSo here we can get the total count of operations as:\\n**count = (3 * 1) + (2 * 2) + (2 * 3) + (1 * 4)**\\nsums of (element counts * i), where i goes on incrementing.\\n\\n# Approach\\nThe approach is to use a map to keep track of the index of each element of the array. Then, we can use two pointers, p and q, to iterate over the map. We can start with p and q both pointing to the beginning of the map. We can then move p to the next element and check if its index is greater than the index of the element pointed to by q. If it is, we increment a counter n, which keeps track of the number of elements greater than the current maximum. If it is not, we add the product of n and i to the answer, where i is the number of operations performed so far, and reset n to 1. Finally, we add the product of n and i to the answer outside the loop, since there will be no more elements left in the map.\\n\\nExample:\\nInput vector: [8, 1, 2, 4, 6, 3, 7, 5]\\n\\nordered map mp: [1:1, 2:2, 3:5, 4:3, 5:7, 6:4, 7:6, 8:0]\\n\\nNow in the while loop we go on traversing in the map check the values of every key and performing if else conditions accordingly,\\n\\nas we can see in the map the values of first three keys are in increasing order count is incremented by 3 * 1 -> count=3\\nthen values of the keys 4 and 5 (i.e. 3 and 7) are in increasing order so count = count + (2 * 2) -> count = 7\\nsimilarly for keys 6, 7 -> count = count + (2 * 3) -> count = 13\\nand finally for key 8 -> count = count + (1 * 4) -> count = 17\\n\\nHence 17 is returned.\\n\\n# Complexity\\n- Time complexity: **O(n*log n)** due to sorting of the array.\\n\\n- Space complexity: **O(n)** due to the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]] = i;\\n        auto p = mp.begin(), q = mp.begin();\\n        int n = 1, i = 1;\\n        p++;\\n        while(p != mp.end())\\n            if(p++ -> second > q++ -> second) n++;\\n            else{\\n                count += (n*i++);\\n                n=1;\\n            }\\n        return count + (n*i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]] = i;\\n        auto p = mp.begin(), q = mp.begin();\\n        int n = 1, i = 1;\\n        p++;\\n        while(p != mp.end())\\n            if(p++ -> second > q++ -> second) n++;\\n            else{\\n                count += (n*i++);\\n                n=1;\\n            }\\n        return count + (n*i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468628,
                "title": "segment-tree-solution",
                "content": "Not sure why I am not seeing more segTree solutions in discussion. This was my solution during the contest:\\n\\nLet n = length of nums array.\\nLet say you pass the array, i.e. move from current index to next and mark removed elements instead of actually removing it.\\n**what alternate can you see for pushing back?:**\\npushing back can be alternatively seen as passing the array circularly more than once. For ex, let say in term of original operations you have pushed back a current element instead of removing it. Then it can be seen alternatively as skipping the marking of the element right now, but it can be marked when we circularly come back again to this element in next pass. (circularly means you go to first index after the last).\\nSo, if we find the original index in the sorted order of nums, let say {i1, i2, i3, ... in}\\nand you start from current index k = 0;\\nthen for marking first removed element you have to go from k to i1, mark i1, and k becomes i1 + 1\\nthen from k to i2, mark i2, and k becomes i2 + 1,\\nthen from k to i3, mark i3, and k becomes i3 + 1\\n...so on...\\ntill from k to in and mark in.\\nnow while traveling from index k to ia if ia >= k then you will get to ia in this pass only otherwise you will comeback again to ia in next pass to mark it.\\nso, **case 1:\\nia >= k :**\\nthen number of operations done by you to mark ia =\\n(number of push back operations) + (number of marking operations = 1)\\n= ((number of nodes alive(not marked) from k to ia) - 1) + 1\\n= **(number of nodes alive(not marked) from k to ia)**\\nas you need to push back only the not remove (i.e. not marked) elements while travelling.\\n\\n**case2:\\nia < k:**\\nthen number of operations done by you to mark ia =\\n(number of push back operations) + (number of marking operations = 1)\\n= ((number of nodes alive(not marked) from k to n - 1) +  (number of nodes alive(not marked) from 0 to ia) - 1) + 1\\n= **(number of nodes alive(not marked) from k to n - 1) +  (number of nodes alive(not marked) from 0 to ia) - 1)**\\n\\nnow to find number of alive nodes between index i to index j efficently, you can **maintain a segment tree**, and whenever you mark index k, you just reduce the number of alive nodes by 1 from the appropriate leaf node corresponding to k in the tree and work your way up to root.\\n(In the code below I am marking in segment tree itself by making the value at appropriate leaf node 0(from 1) and reducing progressively to its ancestors till I reach the root)\\n\\n```\\nclass Solution {\\n    int find(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j < i) return 0;\\n        if(segTree[c][0] == i && segTree[c][1] == j){\\n            return segTree[c][2];\\n        }\\n        else{\\n            int l = find(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n            int r = find(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n            return l + r;\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long ans = 0;\\n        vector<pair<int, int> > ord;\\n        for(int i = 0; i < nums.size(); i++){\\n            ord.push_back({nums[i], i});\\n        }\\n        int n = nums.size();\\n        sort(ord.begin(), ord.end());\\n        int k = 0;\\n        \\n        int t = 1;\\n        while(t < n){\\n            t *= 2;\\n        }\\n        int s = t - 1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < n; i++){\\n            segTree[s + i] = {i, i, 1};\\n        }\\n        for(int i = n; i <= s; i++){\\n            segTree[i + s] = {i, i, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2]};\\n        }\\n        int x, y;\\n        for(int i = 0; i < n; i++){\\n            x = ord[i].second;\\n            if(x < k){\\n                y = find(segTree, k, n - 1, 0) + find(segTree, 0, x, 0);\\n            }\\n            else{\\n                y = find(segTree, k, x, 0);\\n            }\\n            t = s + x;\\n            while(t > 0){\\n                segTree[t][2]--;\\n                t = (t - 1)/2;\\n            }\\n            segTree[t][2]--;\\n            ans += y;\\n            k = (x + 1)%n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int find(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j < i) return 0;\\n        if(segTree[c][0] == i && segTree[c][1] == j){\\n            return segTree[c][2];\\n        }\\n        else{\\n            int l = find(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n            int r = find(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n            return l + r;\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long ans = 0;\\n        vector<pair<int, int> > ord;\\n        for(int i = 0; i < nums.size(); i++){\\n            ord.push_back({nums[i], i});\\n        }\\n        int n = nums.size();\\n        sort(ord.begin(), ord.end());\\n        int k = 0;\\n        \\n        int t = 1;\\n        while(t < n){\\n            t *= 2;\\n        }\\n        int s = t - 1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < n; i++){\\n            segTree[s + i] = {i, i, 1};\\n        }\\n        for(int i = n; i <= s; i++){\\n            segTree[i + s] = {i, i, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2]};\\n        }\\n        int x, y;\\n        for(int i = 0; i < n; i++){\\n            x = ord[i].second;\\n            if(x < k){\\n                y = find(segTree, k, n - 1, 0) + find(segTree, 0, x, 0);\\n            }\\n            else{\\n                y = find(segTree, k, x, 0);\\n            }\\n            t = s + x;\\n            while(t > 0){\\n                segTree[t][2]--;\\n                t = (t - 1)/2;\\n            }\\n            segTree[t][2]--;\\n            ans += y;\\n            k = (x + 1)%n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468098,
                "title": "o-n-log-n-solution-in-cpp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        long long n = nums.size(), ans = n;\\n        for (int i = 0; i < n; ++i)\\n            mp[nums[i]] = i;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < n; ++i)\\n            if (mp[nums[i]] < mp[nums[i - 1]])\\n                ans += n - i;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        long long n = nums.size(), ans = n;\\n        for (int i = 0; i < n; ++i)\\n            mp[nums[i]] = i;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < n; ++i)\\n            if (mp[nums[i]] < mp[nums[i - 1]])\\n                ans += n - i;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467975,
                "title": "my-solutions",
                "content": "**1. Use the Fenwick Tree**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(const int i) {\\n      int ret = 0;\\n      for (int index = i; index > 0; index -= (index & -index)) {\\n        ret += tree_[index - 1];\\n      }\\n      return ret;\\n    }\\n    \\n    void update(const int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      for (int index = i; index <= n; index += (index & -index)) {\\n        tree_[index - 1] += delta;\\n      }\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    long long ret = 0;\\n    FenwickTree fenwick_tree(n);\\n    for (int previous = -1, current = -1, i = 0; i < n; previous = current, ++i) {\\n      current = indices[i];\\n      if (current > previous) {\\n        ret += current - previous - (fenwick_tree.read(current + 1) - fenwick_tree.read(previous + 1));\\n      } else {\\n        // current < previous\\n        ret += n + current - previous - (fenwick_tree.read(current + 1) + (fenwick_tree.read(n) - fenwick_tree.read(previous + 1)));\\n      }\\n      fenwick_tree.update(current + 1, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Sort and calculate the cost introducted by every disorder**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    /**\\n     * all operations include `n` erasing operations and some (zero or more) moving operations\\n     * initially, `n` erasing operations are needed.\\n     */\\n    long long ret = n;\\n    for (int i = 1; i < n; ++i) {\\n      if (indices[i] < indices[i - 1]) {\\n        /**\\n         * the disorder introduced by `indices[i] < indices[i - 1]` will cost extra `n - i` moving operations\\n         */\\n        ret += n - i;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(const int i) {\\n      int ret = 0;\\n      for (int index = i; index > 0; index -= (index & -index)) {\\n        ret += tree_[index - 1];\\n      }\\n      return ret;\\n    }\\n    \\n    void update(const int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      for (int index = i; index <= n; index += (index & -index)) {\\n        tree_[index - 1] += delta;\\n      }\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    long long ret = 0;\\n    FenwickTree fenwick_tree(n);\\n    for (int previous = -1, current = -1, i = 0; i < n; previous = current, ++i) {\\n      current = indices[i];\\n      if (current > previous) {\\n        ret += current - previous - (fenwick_tree.read(current + 1) - fenwick_tree.read(previous + 1));\\n      } else {\\n        // current < previous\\n        ret += n + current - previous - (fenwick_tree.read(current + 1) + (fenwick_tree.read(n) - fenwick_tree.read(previous + 1)));\\n      }\\n      fenwick_tree.update(current + 1, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    /**\\n     * all operations include `n` erasing operations and some (zero or more) moving operations\\n     * initially, `n` erasing operations are needed.\\n     */\\n    long long ret = n;\\n    for (int i = 1; i < n; ++i) {\\n      if (indices[i] < indices[i - 1]) {\\n        /**\\n         * the disorder introduced by `indices[i] < indices[i - 1]` will cost extra `n - i` moving operations\\n         */\\n        ret += n - i;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467954,
                "title": "segment-tree-solution-c-self-explanatory-code",
                "content": "```\\nclass Node {\\n  public:\\n    int maxs;\\n    Node* left;\\n    Node* right;\\n    Node(int data) {\\n        this->maxs = data;\\n        left = NULL;\\n        right = NULL;\\n    }\\n     Node() {\\n        left = NULL;\\n        right = NULL;\\n    }\\n    \\n};\\nclass SegmentTree {\\npublic:\\n    Node* buildSegmentTree(vector<int>& nums, int i, int j) {\\n        if(i == j) {\\n            Node* nn = new Node(nums[i]);\\n            return nn;\\n        }\\n        \\n        int mid = (i+j)/2;\\n        \\n        Node* left = buildSegmentTree(nums,i,mid);\\n        Node* right = buildSegmentTree(nums,mid+1,j);\\n        Node* root = new Node();\\n        root->maxs = left->maxs+right->maxs;\\n        root->left = left;\\n        root->right = right;\\n        return root;   \\n    }\\n    int totalNumbers(Node* Tree, int i, int j, int a, int b) {\\n        if(i>j || a > b) {\\n            return 0;\\n        }\\n        if(Tree == NULL) {\\n            return 0;\\n        }\\n        if(i>b || j<a) {\\n            return 0;\\n        }\\n        \\n        if(a>=i && b<=j) {\\n            return Tree->maxs;    \\n        }\\n       \\n        int mid = (a+b)/2;\\n        int bb = totalNumbers(Tree->left,i,j,a,mid);\\n        int cc = totalNumbers(Tree->right,i,j,mid+1,b);\\n        return bb+cc;\\n    }\\n    Node* update(Node* Tree,int a, int b, int index) {\\n        if(a == b) {\\n            Tree->maxs = 0;\\n            return Tree;\\n        }\\n            \\n            int mid = (a+b)/2;\\n            if(index<=mid) {\\n                Tree->left = update(Tree->left,a,mid,index);\\n            }\\n        else {\\n            Tree->right = update(Tree->right,mid+1,b,index);\\n        }\\n        Tree->maxs = Tree->left->maxs + Tree->right->maxs;\\n        return Tree;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& kk) {\\n        vector<int> tt(kk.size(), 1);\\n       SegmentTree *ss = new SegmentTree();\\n        Node* root = ss->buildSegmentTree(tt,0,kk.size()-1);\\n        unordered_map<int,int> numberIndex;\\n      \\n        for(int i = 0;i<kk.size(); i++) {\\n            numberIndex[kk[i]] = i;\\n        }\\n          sort(kk.begin(), kk.end());\\n        long long int ans = 0;\\n        \\n        for(int i = 0;i<=kk.size()-1;i++) {\\n            if(i == 0) {\\n                ans += numberIndex[kk[i]] + 1; \\n            }\\n            else {\\n                int prevNumberIndex = numberIndex[kk[i-1]];\\n                int currNumberIndex = numberIndex[kk[i]];\\n                int elementBwThem = 0;\\n                int elementSmallerThanPrevNumbBwThem = 0;\\n                if(currNumberIndex < prevNumberIndex) {\\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,0,currNumberIndex-1,0,kk.size()-1) + \\n                       ss->totalNumbers(root,prevNumberIndex+1 ,kk.size()-1,0,kk.size()-1) ;\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                }\\n                else {\\n                 \\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,prevNumberIndex+1,currNumberIndex-1,0,kk.size()-1);\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                    \\n                }\\n            }\\n            root = ss->update(root,0,kk.size()-1,numberIndex[kk[i]]);\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n  public:\\n    int maxs;\\n    Node* left;\\n    Node* right;\\n    Node(int data) {\\n        this->maxs = data;\\n        left = NULL;\\n        right = NULL;\\n    }\\n     Node() {\\n        left = NULL;\\n        right = NULL;\\n    }\\n    \\n};\\nclass SegmentTree {\\npublic:\\n    Node* buildSegmentTree(vector<int>& nums, int i, int j) {\\n        if(i == j) {\\n            Node* nn = new Node(nums[i]);\\n            return nn;\\n        }\\n        \\n        int mid = (i+j)/2;\\n        \\n        Node* left = buildSegmentTree(nums,i,mid);\\n        Node* right = buildSegmentTree(nums,mid+1,j);\\n        Node* root = new Node();\\n        root->maxs = left->maxs+right->maxs;\\n        root->left = left;\\n        root->right = right;\\n        return root;   \\n    }\\n    int totalNumbers(Node* Tree, int i, int j, int a, int b) {\\n        if(i>j || a > b) {\\n            return 0;\\n        }\\n        if(Tree == NULL) {\\n            return 0;\\n        }\\n        if(i>b || j<a) {\\n            return 0;\\n        }\\n        \\n        if(a>=i && b<=j) {\\n            return Tree->maxs;    \\n        }\\n       \\n        int mid = (a+b)/2;\\n        int bb = totalNumbers(Tree->left,i,j,a,mid);\\n        int cc = totalNumbers(Tree->right,i,j,mid+1,b);\\n        return bb+cc;\\n    }\\n    Node* update(Node* Tree,int a, int b, int index) {\\n        if(a == b) {\\n            Tree->maxs = 0;\\n            return Tree;\\n        }\\n            \\n            int mid = (a+b)/2;\\n            if(index<=mid) {\\n                Tree->left = update(Tree->left,a,mid,index);\\n            }\\n        else {\\n            Tree->right = update(Tree->right,mid+1,b,index);\\n        }\\n        Tree->maxs = Tree->left->maxs + Tree->right->maxs;\\n        return Tree;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& kk) {\\n        vector<int> tt(kk.size(), 1);\\n       SegmentTree *ss = new SegmentTree();\\n        Node* root = ss->buildSegmentTree(tt,0,kk.size()-1);\\n        unordered_map<int,int> numberIndex;\\n      \\n        for(int i = 0;i<kk.size(); i++) {\\n            numberIndex[kk[i]] = i;\\n        }\\n          sort(kk.begin(), kk.end());\\n        long long int ans = 0;\\n        \\n        for(int i = 0;i<=kk.size()-1;i++) {\\n            if(i == 0) {\\n                ans += numberIndex[kk[i]] + 1; \\n            }\\n            else {\\n                int prevNumberIndex = numberIndex[kk[i-1]];\\n                int currNumberIndex = numberIndex[kk[i]];\\n                int elementBwThem = 0;\\n                int elementSmallerThanPrevNumbBwThem = 0;\\n                if(currNumberIndex < prevNumberIndex) {\\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,0,currNumberIndex-1,0,kk.size()-1) + \\n                       ss->totalNumbers(root,prevNumberIndex+1 ,kk.size()-1,0,kk.size()-1) ;\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                }\\n                else {\\n                 \\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,prevNumberIndex+1,currNumberIndex-1,0,kk.size()-1);\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                    \\n                }\\n            }\\n            root = ss->update(root,0,kk.size()-1,numberIndex[kk[i]]);\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467898,
                "title": "fast-compact-2-definitions-3-statements-modern-c-solution",
                "content": "Suppose nums = [3, 4, 1, 5, 0 2]. We can now form an infinite sequence 3 4 1 5 0 2 3 4 1 5 0 2 3 4 1 5 0 2 3 4 1 5 0 2 3 4 1 5 0 2 ... by repeatingly appending nums.\\n\\nLet T be short-hand for countOperationsToEmptyArray. Since the two smallest numbers of nums (0 and 1) are out of order one has to proceed to the second block of the sequence after having elimiated 0. \\n\\nHence T([3, 4, 1, 5, 0, 2]) = block-length + T([3, 4, 1, 5, 2]). Whereas T([3, 4, 0, 5, 1, 2]) = 1 + T([3, 4, 5, 1, 2]).\\n\\nHence if we calculate the ordering of nums, getting [4, 2, 5, 0, 1, 3], the smallest entry is in position 4, then next smallest entry in position 2, etc, we can use the recurrence relation for T directly.\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tlong long countOperationsToEmptyArray(std::vector<int>& nums)\\n\\t{\\n\\t\\tauto const n = std::size(nums);\\n\\n\\t\\tauto ordering = std::vector<int>(n);\\n\\t\\tstd::iota(std::begin(ordering), std::end(ordering), 0);\\n\\n\\t\\tstd::sort(std::begin(ordering), std::end(ordering),\\n\\t\\t\\t[&nums](auto const i, auto const j) { return nums[i] < nums[j]; });\\n\\n        // k is the block length\\n        // tail, head are consecutive elements in the ordering\\n\\t\\treturn std::transform_reduce(std::next(std::cbegin(ordering)), std::cend(ordering), std::cbegin(ordering), 1ULL,\\n\\t\\t\\tstd::plus<>(),\\n\\t\\t\\t[k = n + 1](auto head, auto tail) mutable\\n\\t\\t\\t{\\n\\t\\t\\t\\t--k;\\n\\t\\t\\t\\treturn head < tail ? k : 1ULL;\\n\\t\\t\\t});\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tlong long countOperationsToEmptyArray(std::vector<int>& nums)\\n\\t{\\n\\t\\tauto const n = std::size(nums);\\n\\n\\t\\tauto ordering = std::vector<int>(n);\\n\\t\\tstd::iota(std::begin(ordering), std::end(ordering), 0);\\n\\n\\t\\tstd::sort(std::begin(ordering), std::end(ordering),\\n\\t\\t\\t[&nums](auto const i, auto const j) { return nums[i] < nums[j]; });\\n\\n        // k is the block length\\n        // tail, head are consecutive elements in the ordering\\n\\t\\treturn std::transform_reduce(std::next(std::cbegin(ordering)), std::cend(ordering), std::cbegin(ordering), 1ULL,\\n\\t\\t\\tstd::plus<>(),\\n\\t\\t\\t[k = n + 1](auto head, auto tail) mutable\\n\\t\\t\\t{\\n\\t\\t\\t\\t--k;\\n\\t\\t\\t\\treturn head < tail ? k : 1ULL;\\n\\t\\t\\t});\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467820,
                "title": "python-short-simple-solution-sortedlist-reversed-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sl = SortedList()\\n        nums = list(enumerate(nums))\\n        nums.sort(key=lambda x: x[1], reverse=True)\\n        \\n        sl.add(nums[0])\\n        total = 1\\n        for i in range(1, len(nums)):\\n            sl.add(nums[i])\\n            total += (sl.bisect_left(nums[i-1]) - sl.bisect_left(nums[i]))%len(sl)\\n        total += nums[-1][0]\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sl = SortedList()\\n        nums = list(enumerate(nums))\\n        nums.sort(key=lambda x: x[1], reverse=True)\\n        \\n        sl.add(nums[0])\\n        total = 1\\n        for i in range(1, len(nums)):\\n            sl.add(nums[i])\\n            total += (sl.bisect_left(nums[i-1]) - sl.bisect_left(nums[i]))%len(sl)\\n        total += nums[-1][0]\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467797,
                "title": "python-numpy-bruteforce",
                "content": "Numpy allows bruteforce solution to pass time limit.\\ncredit to @ankushbhrdwj\\n\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_arr = np.array(nums)\\n        operations = len(nums)\\n        while len(nums_arr):\\n            min_loc = np.argmin(nums_arr)\\n            if min_loc:\\n                operations += min_loc\\n                nums_arr = np.concatenate((nums_arr[min_loc + 1:], nums_arr[:min_loc]))\\n            else:\\n                nums_arr = nums_arr[1:]\\n            \\n        return operations\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_arr = np.array(nums)\\n        operations = len(nums)\\n        while len(nums_arr):\\n            min_loc = np.argmin(nums_arr)\\n            if min_loc:\\n                operations += min_loc\\n                nums_arr = np.concatenate((nums_arr[min_loc + 1:], nums_arr[:min_loc]))\\n            else:\\n                nums_arr = nums_arr[1:]\\n            \\n        return operations\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467743,
                "title": "brute-force-optimized-solution-using-map-cpp",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n\\n## Brute Force Approach\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n  \\n        long long cnt = 0;\\n        \\n        deque<int> dq(nums.begin(), nums.end());\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        \\n        while(!dq.empty()){\\n            if(nums[i] == dq.front()){\\n                dq.pop_front();\\n                i++;\\n            }\\n            else\\n            {\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n## Optimized Approach\\n```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n\\n    unordered_map<int,int> map;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            map[nums[i]] = i;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        long ans=nums.size();\\n        int curr =0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int og_pos = map[nums[i]];\\n\\n             if(og_pos < curr){\\n                ans+=(nums.size()-i);\\n            }\\n            curr=map[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n  \\n        long long cnt = 0;\\n        \\n        deque<int> dq(nums.begin(), nums.end());\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        \\n        while(!dq.empty()){\\n            if(nums[i] == dq.front()){\\n                dq.pop_front();\\n                i++;\\n            }\\n            else\\n            {\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n\\n    unordered_map<int,int> map;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            map[nums[i]] = i;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        long ans=nums.size();\\n        int curr =0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int og_pos = map[nums[i]];\\n\\n             if(og_pos < curr){\\n                ans+=(nums.size()-i);\\n            }\\n            curr=map[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467580,
                "title": "c-tle-accepted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// TLE\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        vector<int> v = nums;\\n        sort(v.begin(), v.end());\\n        queue<long long> d, q1, q2;\\n        for(auto i:nums)\\n            q1.push(i);\\n        for(auto i:v)\\n            d.push(i);\\n            // cout<<i<<\" \";\\n        while(!q1.empty() || !q2.empty()){\\n            while(!q1.empty()){\\n                if(q1.front()==d.front()){\\n                    q1.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q2.push(q1.front());\\n                    q1.pop();\\n                    count++;\\n                }     \\n            }\\n            \\n            while(!q2.empty()){\\n                if(q2.front()==d.front()){\\n                    q2.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q1.push(q2.front());\\n                    q2.pop();\\n                    count++;\\n                }     \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// Accepted sollution \\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long count = n;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]=i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i++){\\n            if(m[nums[i]]<m[nums[i-1]]){\\n                count = count + n - i;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// TLE\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        vector<int> v = nums;\\n        sort(v.begin(), v.end());\\n        queue<long long> d, q1, q2;\\n        for(auto i:nums)\\n            q1.push(i);\\n        for(auto i:v)\\n            d.push(i);\\n            // cout<<i<<\" \";\\n        while(!q1.empty() || !q2.empty()){\\n            while(!q1.empty()){\\n                if(q1.front()==d.front()){\\n                    q1.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q2.push(q1.front());\\n                    q1.pop();\\n                    count++;\\n                }     \\n            }\\n            \\n            while(!q2.empty()){\\n                if(q2.front()==d.front()){\\n                    q2.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q1.push(q2.front());\\n                    q2.pop();\\n                    count++;\\n                }     \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// Accepted sollution \\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long count = n;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]=i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i++){\\n            if(m[nums[i]]<m[nums[i-1]]){\\n                count = count + n - i;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467539,
                "title": "python-sortedlist-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a hard one. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the numbers and process each going from small to large. \\nFor current number, only consider the relative position to the last smaller number in the original array.  \\n\\nSee code comments for details.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        arr = [(c,i) for i,c in enumerate(nums)]\\n        sl = SortedList()\\n        b0 = [0]*n # b0[i]: # of elements > nums[i] in nums[0:i-1]\\n        s0 = [0]*n # s0[i]: # of elements < nums[i] in nums[0:i-1]\\n        sl.add(nums[0])\\n        for i in range(1, n):\\n            s0[i] = sl.bisect_left(nums[i])\\n            b0[i] = len(sl) - s0[i]\\n            sl.add(nums[i])\\n        b1 = [0]*n # b1[i]: # of elements > nums[i] in nums[i+1:]\\n        sl = SortedList()\\n        sl.add(nums[-1])\\n        for i in range(n-2, -1, -1):\\n            b1[i] = len(sl) - sl.bisect_left(nums[i])\\n            sl.add(nums[i])\\n        arr.append((-inf, -1))\\n        arr.sort()\\n        ans = 0\\n        for i in range(1, n+1):\\n            _, cur = arr[i]            \\n            last = arr[i-1][1]\\n            if cur > last:\\n                if arr[i-1][1] == -1: # this is for the min of nums\\n                    ans += cur - last # the # of ops is just moves to the left end plus 1 (remove op)\\n                else: # for all others if the last pos is to the left, find the # of elements < nums[idx] \\n                      # b.w. the last pos and idx (= s0[cur]-s0[last]-1); this is the # of elemnts \\n                      # already removed, so not counting any more  \\n                      # the # of ops is just moves to the left end (idx-arr[i-1][1]-1) minus\\n                      # the # of elements already removed (from above) plus 1 (remove op)\\n                    ans += (cur-last-1) - (s0[cur]-s0[last]-1) + 1\\n            else:# if the last pos is on the right, we need to find the # of elements > nums[idx]\\n                 # who are to the left of cur and to the right of the last pos  \\n                 # the # of ops in this case is just moves to pass all those bigger elements \\n                 # plus 1 (remove op)\\n                ans += b0[cur] + b1[last] + 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        arr = [(c,i) for i,c in enumerate(nums)]\\n        sl = SortedList()\\n        b0 = [0]*n # b0[i]: # of elements > nums[i] in nums[0:i-1]\\n        s0 = [0]*n # s0[i]: # of elements < nums[i] in nums[0:i-1]\\n        sl.add(nums[0])\\n        for i in range(1, n):\\n            s0[i] = sl.bisect_left(nums[i])\\n            b0[i] = len(sl) - s0[i]\\n            sl.add(nums[i])\\n        b1 = [0]*n # b1[i]: # of elements > nums[i] in nums[i+1:]\\n        sl = SortedList()\\n        sl.add(nums[-1])\\n        for i in range(n-2, -1, -1):\\n            b1[i] = len(sl) - sl.bisect_left(nums[i])\\n            sl.add(nums[i])\\n        arr.append((-inf, -1))\\n        arr.sort()\\n        ans = 0\\n        for i in range(1, n+1):\\n            _, cur = arr[i]            \\n            last = arr[i-1][1]\\n            if cur > last:\\n                if arr[i-1][1] == -1: # this is for the min of nums\\n                    ans += cur - last # the # of ops is just moves to the left end plus 1 (remove op)\\n                else: # for all others if the last pos is to the left, find the # of elements < nums[idx] \\n                      # b.w. the last pos and idx (= s0[cur]-s0[last]-1); this is the # of elemnts \\n                      # already removed, so not counting any more  \\n                      # the # of ops is just moves to the left end (idx-arr[i-1][1]-1) minus\\n                      # the # of elements already removed (from above) plus 1 (remove op)\\n                    ans += (cur-last-1) - (s0[cur]-s0[last]-1) + 1\\n            else:# if the last pos is on the right, we need to find the # of elements > nums[idx]\\n                 # who are to the left of cur and to the right of the last pos  \\n                 # the # of ops in this case is just moves to pass all those bigger elements \\n                 # plus 1 (remove op)\\n                ans += b0[cur] + b1[last] + 1\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3467470,
                "title": "solved-using-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\ntypedef long long   int   ll;\\n\\nclass Solution {\\npublic:\\n    \\n//        // 4  2 1 3 5\\n//    +3\\n\\n//    3 5 4 2\\n\\n//    +4\\n\\n\\n//    3 5 4 \\n   vector<ll> hehe;\\n\\n    ll query(int node, int i, int j, int l, int r)\\n    {\\n        if (r < i || l > j)\\n        {\\n            return 0;\\n        }\\n        if (l <= i && j <= r)\\n        {\\n            return hehe[node];\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return  query(2 * node, i, mid, l, r)+query(2 * node + 1, mid + 1, j, l, r);\\n    }\\n    ll update(int node, int i, int j, int l)\\n    {\\n        if (l < i || l > j)\\n        {\\n            return hehe[node];\\n        }\\n        if (i == j)\\n        {\\n            hehe[node] = 1;\\n            return 1;\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return hehe[node] = update(2 * node, i, mid, l)+update(2 * node + 1, mid + 1, j, l);\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n        \\n      unordered_map<int,int> m;\\n        \\n        for(int i=0;i<a.size();i++){\\n             m[a[i]]=i;\\n        }\\n        \\n        int n=a.size();\\n        \\n        hehe.resize(4*n,0);\\n        \\n        \\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long ans=m[a[0]]+1;\\n         \\n        long long prev=a[0];\\n        \\n        int i=1;\\n        int rem=a.size()-1;\\n        \\n        update(1,0,n-1,m[a[0]]);        \\n        \\n        while(i<n){\\n            if(m[a[i-1]]<m[a[i]]){\\n                 ans+=m[a[i]]-m[a[i-1]]-query(1,0,n-1,m[a[i-1]]+1,m[a[i]]-1);\\n                 update(1,0,n-1,m[a[i]]); \\n            }\\n            else{\\n                 ans+=n-m[a[i-1]]+m[a[i]]-(query(1,0,n-1,m[a[i-1]]+1,n-1)+query(1,0,n-1,0,m[a[i]]));\\n                 update(1,0,n-1,m[a[i]]);\\n            }\\n            i++;\\n        }\\n  \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef long long   int   ll;\\n\\nclass Solution {\\npublic:\\n    \\n//        // 4  2 1 3 5\\n//    +3\\n\\n//    3 5 4 2\\n\\n//    +4\\n\\n\\n//    3 5 4 \\n   vector<ll> hehe;\\n\\n    ll query(int node, int i, int j, int l, int r)\\n    {\\n        if (r < i || l > j)\\n        {\\n            return 0;\\n        }\\n        if (l <= i && j <= r)\\n        {\\n            return hehe[node];\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return  query(2 * node, i, mid, l, r)+query(2 * node + 1, mid + 1, j, l, r);\\n    }\\n    ll update(int node, int i, int j, int l)\\n    {\\n        if (l < i || l > j)\\n        {\\n            return hehe[node];\\n        }\\n        if (i == j)\\n        {\\n            hehe[node] = 1;\\n            return 1;\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return hehe[node] = update(2 * node, i, mid, l)+update(2 * node + 1, mid + 1, j, l);\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n        \\n      unordered_map<int,int> m;\\n        \\n        for(int i=0;i<a.size();i++){\\n             m[a[i]]=i;\\n        }\\n        \\n        int n=a.size();\\n        \\n        hehe.resize(4*n,0);\\n        \\n        \\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long ans=m[a[0]]+1;\\n         \\n        long long prev=a[0];\\n        \\n        int i=1;\\n        int rem=a.size()-1;\\n        \\n        update(1,0,n-1,m[a[0]]);        \\n        \\n        while(i<n){\\n            if(m[a[i-1]]<m[a[i]]){\\n                 ans+=m[a[i]]-m[a[i-1]]-query(1,0,n-1,m[a[i-1]]+1,m[a[i]]-1);\\n                 update(1,0,n-1,m[a[i]]); \\n            }\\n            else{\\n                 ans+=n-m[a[i-1]]+m[a[i]]-(query(1,0,n-1,m[a[i-1]]+1,n-1)+query(1,0,n-1,0,m[a[i]]));\\n                 update(1,0,n-1,m[a[i]]);\\n            }\\n            i++;\\n        }\\n  \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467342,
                "title": "segment-tree-good-qs",
                "content": "```\\nclass Solution {\\npublic:\\n    struct seg\\n{\\n    vector<int> v;\\n    vector<int> tree;\\n    vector<int> lazy;\\n    seg(vector<int>&arr)\\n    {\\n        v = arr;\\n        vector<int> dummy1(4 * v.size());\\n        vector<int> dummy2(4 * v.size());\\n        tree = dummy1;\\n        lazy = dummy2;\\n    }\\n    void build(int node,int start,int end){\\n        if(start==end){\\n            tree[node]=v[start];\\n        }\\n        else{\\n            int mid = (start+end)/2;\\n            build(node*2,start,mid);\\n            build(node*2+1,mid+1,end);\\n            tree[node] = tree[node*2] + tree[node*2+1];\\n        }\\n    }\\n    void propogate(int node, int start, int end)\\n    {\\n        if (start == end)\\n        {\\n            tree[node] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n        else\\n        {\\n            tree[node] += ((end - start + 1) * lazy[node]);\\n            lazy[2 * node] += lazy[node];\\n            lazy[2 * node + 1] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n    }\\n    void update(int node, int start, int end, int l, int r, int x)\\n    {\\n        propogate(node, start, end);\\n        if (start > r || end < l)\\n        {\\n            return;\\n        }\\n        if (start == end)\\n        {\\n            tree[node] += x;\\n        }\\n        else if (l <= start && end <= r)\\n        {\\n            lazy[node] += x;\\n            propogate(node, start, end);\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            update(node * 2, start, mid, l, r, x);\\n            update(node * 2 + 1, mid + 1, end, l, r, x);\\n            tree[node] = tree[node * 2] + tree[node * 2 + 1];\\n        }\\n    }\\n    int query(int node, int start, int end, int l, int r)\\n    {\\n        if (start > r || end < l)\\n        {\\n            return 0;\\n        }\\n        propogate(node,start,end);\\n        if (start == end)\\n        {\\n            return tree[node];\\n        }\\n        else if (start >= l && end <= r)\\n        {\\n            return tree[node];\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            int left = query(node * 2, start, mid, l, r);\\n            int right = query(node * 2 + 1, mid + 1, end, l, r);\\n            return left + right;\\n        }\\n    }\\n};\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int ans=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n        vector<pair<int,int>>t;\\n        for(auto &i:m){\\n            t.push_back({i.first,i.second});\\n        }\\n        // for(auto &i:t){\\n        //     cout<<i.second<<\" \";\\n        // }\\n        // cout<<endl;\\n        int prev=t[0].second;\\n        ans+=(t[0].second);\\n        // cout<<ans<<\" \";\\n        vector<int>v(nums.size(),0);\\n        seg s=seg(v);\\n        int n=nums.size();\\n        s.update(1,0,n-1,prev,prev,1);\\n        for(int i=1;i<n;i++){\\n            int idx=t[i].second;\\n            // cout<<prev<<\" \"<<idx<<\" \";\\n            if(prev>idx){\\n                ans+=(n-prev-1);\\n                ans+=(idx);\\n                int one=s.query(1,0,n-1,0,idx-1);\\n                int two=s.query(1,0,n-1,prev+1,n-1);\\n                ans-=(one+two);\\n            }\\n            else{\\n                ans+=(idx-prev-1);\\n                int bich=s.query(1,0,n-1,prev+1,idx-1);\\n                // cout<<bich<<\" \";\\n                ans-=bich;\\n            }\\n            s.update(1,0,n-1,idx,idx,1);\\n            prev=idx;\\n            // cout<<ans<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct seg\\n{\\n    vector<int> v;\\n    vector<int> tree;\\n    vector<int> lazy;\\n    seg(vector<int>&arr)\\n    {\\n        v = arr;\\n        vector<int> dummy1(4 * v.size());\\n        vector<int> dummy2(4 * v.size());\\n        tree = dummy1;\\n        lazy = dummy2;\\n    }\\n    void build(int node,int start,int end){\\n        if(start==end){\\n            tree[node]=v[start];\\n        }\\n        else{\\n            int mid = (start+end)/2;\\n            build(node*2,start,mid);\\n            build(node*2+1,mid+1,end);\\n            tree[node] = tree[node*2] + tree[node*2+1];\\n        }\\n    }\\n    void propogate(int node, int start, int end)\\n    {\\n        if (start == end)\\n        {\\n            tree[node] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n        else\\n        {\\n            tree[node] += ((end - start + 1) * lazy[node]);\\n            lazy[2 * node] += lazy[node];\\n            lazy[2 * node + 1] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n    }\\n    void update(int node, int start, int end, int l, int r, int x)\\n    {\\n        propogate(node, start, end);\\n        if (start > r || end < l)\\n        {\\n            return;\\n        }\\n        if (start == end)\\n        {\\n            tree[node] += x;\\n        }\\n        else if (l <= start && end <= r)\\n        {\\n            lazy[node] += x;\\n            propogate(node, start, end);\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            update(node * 2, start, mid, l, r, x);\\n            update(node * 2 + 1, mid + 1, end, l, r, x);\\n            tree[node] = tree[node * 2] + tree[node * 2 + 1];\\n        }\\n    }\\n    int query(int node, int start, int end, int l, int r)\\n    {\\n        if (start > r || end < l)\\n        {\\n            return 0;\\n        }\\n        propogate(node,start,end);\\n        if (start == end)\\n        {\\n            return tree[node];\\n        }\\n        else if (start >= l && end <= r)\\n        {\\n            return tree[node];\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            int left = query(node * 2, start, mid, l, r);\\n            int right = query(node * 2 + 1, mid + 1, end, l, r);\\n            return left + right;\\n        }\\n    }\\n};\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int ans=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n        vector<pair<int,int>>t;\\n        for(auto &i:m){\\n            t.push_back({i.first,i.second});\\n        }\\n        // for(auto &i:t){\\n        //     cout<<i.second<<\" \";\\n        // }\\n        // cout<<endl;\\n        int prev=t[0].second;\\n        ans+=(t[0].second);\\n        // cout<<ans<<\" \";\\n        vector<int>v(nums.size(),0);\\n        seg s=seg(v);\\n        int n=nums.size();\\n        s.update(1,0,n-1,prev,prev,1);\\n        for(int i=1;i<n;i++){\\n            int idx=t[i].second;\\n            // cout<<prev<<\" \"<<idx<<\" \";\\n            if(prev>idx){\\n                ans+=(n-prev-1);\\n                ans+=(idx);\\n                int one=s.query(1,0,n-1,0,idx-1);\\n                int two=s.query(1,0,n-1,prev+1,n-1);\\n                ans-=(one+two);\\n            }\\n            else{\\n                ans+=(idx-prev-1);\\n                int bich=s.query(1,0,n-1,prev+1,idx-1);\\n                // cout<<bich<<\" \";\\n                ans-=bich;\\n            }\\n            s.update(1,0,n-1,idx,idx,1);\\n            prev=idx;\\n            // cout<<ans<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467249,
                "title": "how-it-can-work-simple-maths-time-o-n",
                "content": "# Explanation : \\nWe need to calculate the strictly increasing subsequence including the smallest element, to remove those many elements we will require n operations.\\n\\n3 | 4 | [-1]\\n\\nhere the subsequence is of size 1, it will take n (i.e. 3) operations to remove that subsequence,\\n\\nnew array will be,\\n\\n[3 | 4 ]\\n\\nwhich itself is the longest strictly increasing array including the smallest element to remove them we need n (i.e. 2) operations\\n\\nwe can easily get the subsequences with sorted array including the account of indices\\n\\n-1 | 3 | 4 ----> sorted elements\\n0 | 1 | 2 ----->indices\\n\\nwe need to calculate the continues subarray that is increasing in both conditions. We can take some pointers to achieve the same\\n\\n# Upvote if you like it \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long sum = nums.size(), count = 1;\\n        vector<pair<long long, long long>> ans;\\n        for(int i=0;i<nums.size();i++)\\n            ans.push_back({nums[i], i});\\n        sort(ans.begin(), ans.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(ans[i].second > ans[i-1].second)\\n                count++;                \\n            else{\\n                sum += nums.size()-count;\\n                count++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long sum = nums.size(), count = 1;\\n        vector<pair<long long, long long>> ans;\\n        for(int i=0;i<nums.size();i++)\\n            ans.push_back({nums[i], i});\\n        sort(ans.begin(), ans.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(ans[i].second > ans[i-1].second)\\n                count++;                \\n            else{\\n                sum += nums.size()-count;\\n                count++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467192,
                "title": "c-solution-with-segment-tree",
                "content": "# Intuition\\nSort and Segment Tree\\n\\n# Approach\\nFirst sort all the elements and remember the index. using that index we can use segment tree to find the total number to steps.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getMid(int s, int e) { return s + (e -s)/2; }\\n \\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\\n{\\n    if (qs <= ss && qe >= se)\\n        return st[si];\\n \\n    if (se < qs || ss > qe)\\n        return 0;\\n \\n    int mid = getMid(ss, se);\\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\\n        getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\\n}\\n\\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\\n{\\n   \\n    if (i < ss || i > se)\\n        return;\\n \\n    \\n    st[si] = st[si] + diff;\\n    if (se != ss)\\n    {\\n        int mid = getMid(ss, se);\\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\\n    }\\n}\\n\\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\\n{\\n    if (i < 0 || i > n-1)\\n    {\\n        cout<<\"Invalid Input\";\\n        return;\\n    }\\n \\n    int diff = new_val - arr[i];\\n \\n    arr[i] = new_val;\\n \\n    updateValueUtil(st, 0, n-1, i, diff, 0);\\n}\\n \\nint getSum(int *st, int n, int qs, int qe)\\n{\\n    if (qs < 0 || qe > n-1 || qs > qe)\\n    {\\n        cout<<\"Invalid Input\";\\n        return -1;\\n    }\\n \\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\\n}\\n \\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\\n{\\n\\n    if (ss == se)\\n    {\\n        st[si] = arr[ss];\\n        return arr[ss];\\n    }\\n \\n    int mid = getMid(ss, se);\\n    st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) +\\n            constructSTUtil(arr, mid+1, se, st, si*2+2);\\n    return st[si];\\n}\\n \\nint *constructST(int arr[], int n)\\n{\\n    int x = (int)(ceil(log2(n)));\\n \\n    int max_size = 2*(int)pow(2, x) - 1;\\n \\n    int *st = new int[max_size];\\n \\n    constructSTUtil(arr, 0, n-1, st, 0);\\n \\n    return st;\\n}\\n    bool static sortcol( const vector<int>& v1,\\n               const vector<int>& v2 ) {\\n    return v1[0] < v2[0];\\n}\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n      long long k = 0;\\n        int n = nums.size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            \\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(), v.end(), sortcol);\\n        \\n        int x[n];\\n        int y[n];\\n        for(int i=0;i<v.size();i++) {\\n            x[i] = v[i][1];\\n            y[i]=1;\\n            //cout<<v[i][1]<<endl;\\n        }\\n        int *st = constructST(y, n);\\n \\n    //updateValue(arr, st, n, 1, 10);\\n        //getSum(st, n, 1, 3)<<endl;\\n        int i=0;\\n        while(i<n){\\n            vector<int> d;\\n            while(i<n-1 && x[i+1]>x[i]){\\n                d.push_back(i++);\\n            }\\n            d.push_back(i);\\n            k+=getSum(st, n, 0, i);\\n            if(i<n-1){\\n                k+=getSum(st, n, i+1, n-1);\\n            }\\n            for(int j=0;j<d.size();j++) updateValue(y, st, n, d[j], 0);\\n            i++;\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getMid(int s, int e) { return s + (e -s)/2; }\\n \\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\\n{\\n    if (qs <= ss && qe >= se)\\n        return st[si];\\n \\n    if (se < qs || ss > qe)\\n        return 0;\\n \\n    int mid = getMid(ss, se);\\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\\n        getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\\n}\\n\\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\\n{\\n   \\n    if (i < ss || i > se)\\n        return;\\n \\n    \\n    st[si] = st[si] + diff;\\n    if (se != ss)\\n    {\\n        int mid = getMid(ss, se);\\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\\n    }\\n}\\n\\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\\n{\\n    if (i < 0 || i > n-1)\\n    {\\n        cout<<\"Invalid Input\";\\n        return;\\n    }\\n \\n    int diff = new_val - arr[i];\\n \\n    arr[i] = new_val;\\n \\n    updateValueUtil(st, 0, n-1, i, diff, 0);\\n}\\n \\nint getSum(int *st, int n, int qs, int qe)\\n{\\n    if (qs < 0 || qe > n-1 || qs > qe)\\n    {\\n        cout<<\"Invalid Input\";\\n        return -1;\\n    }\\n \\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\\n}\\n \\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\\n{\\n\\n    if (ss == se)\\n    {\\n        st[si] = arr[ss];\\n        return arr[ss];\\n    }\\n \\n    int mid = getMid(ss, se);\\n    st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) +\\n            constructSTUtil(arr, mid+1, se, st, si*2+2);\\n    return st[si];\\n}\\n \\nint *constructST(int arr[], int n)\\n{\\n    int x = (int)(ceil(log2(n)));\\n \\n    int max_size = 2*(int)pow(2, x) - 1;\\n \\n    int *st = new int[max_size];\\n \\n    constructSTUtil(arr, 0, n-1, st, 0);\\n \\n    return st;\\n}\\n    bool static sortcol( const vector<int>& v1,\\n               const vector<int>& v2 ) {\\n    return v1[0] < v2[0];\\n}\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n      long long k = 0;\\n        int n = nums.size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            \\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(), v.end(), sortcol);\\n        \\n        int x[n];\\n        int y[n];\\n        for(int i=0;i<v.size();i++) {\\n            x[i] = v[i][1];\\n            y[i]=1;\\n            //cout<<v[i][1]<<endl;\\n        }\\n        int *st = constructST(y, n);\\n \\n    //updateValue(arr, st, n, 1, 10);\\n        //getSum(st, n, 1, 3)<<endl;\\n        int i=0;\\n        while(i<n){\\n            vector<int> d;\\n            while(i<n-1 && x[i+1]>x[i]){\\n                d.push_back(i++);\\n            }\\n            d.push_back(i);\\n            k+=getSum(st, n, 0, i);\\n            if(i<n-1){\\n                k+=getSum(st, n, i+1, n-1);\\n            }\\n            for(int j=0;j<d.size();j++) updateValue(y, st, n, d[j], 0);\\n            i++;\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467168,
                "title": "best-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Node root = null;\\n\\t\\t\\tMap<Integer, Node> map = new TreeMap<>();\\n\\t\\t\\tfor(int v : nums){\\n\\t\\t\\t\\tNode node = new Node(v);\\n\\t\\t\\t\\tmap.put(v, node);\\n\\t\\t\\t\\troot = merge(root, node);\\n\\t\\t\\t}\\n\\t\\t\\tlong ans = nums.length;\\n\\t\\t\\tfor(int k : map.keySet()){\\n\\t\\t\\t\\tNode node = map.get(k);\\n\\t\\t\\t\\tint index = index(node);\\n\\t\\t\\t\\tans += index;\\n\\t\\t\\t\\tNode[] lm_r = split(root, index+1);\\n\\t\\t\\t\\tNode[] l_m = split(lm_r[0], index);\\n\\t\\t\\t\\troot = merge(lm_r[1], l_m[0]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic Random gen = new Random();\\n\\t\\tpublic final int mod = 998244353;\\n\\n\\t\\tpublic class Node\\n\\t\\t{\\n\\t\\t\\tpublic long priority;\\n\\t\\t\\tpublic Node L, R, P;\\n\\n\\t\\t\\tpublic long v; // value\\n\\t\\t\\tpublic long sum;\\n\\t\\t\\tpublic int size;\\n\\n\\t\\t\\tpublic Node(int v)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthis.v = v;\\n\\t\\t\\t\\tpriority = gen.nextLong();\\n\\t\\t\\t\\tupdate();\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void update()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize = size(L) + size(R) + 1;\\n\\t\\t\\t\\tsum = v + sum(L) + sum(R);\\n\\t\\t\\t\\t// TODO\\n\\t\\t\\t}\\n\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic String toString() {\\n\\t\\t\\t\\treturn \"Node{\" +\\n\\t\\t\\t\\t\\t\\t\"v=\" + v +\\n\\t\\t\\t\\t\\t\\t\", sum=\" + sum +\\n\\t\\t\\t\\t\\t\\t\", size=\" + size +\\n\\t\\t\\t\\t\\t\\t\\'}\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void propagate(Node x)\\n\\t\\t{\\n\\t\\t\\tfor(;x != null;x = x.P)x.update();\\n\\t\\t}\\n\\n\\t\\tpublic Node disconnect(Node a)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return null;\\n\\t\\t\\ta.L = a.R = a.P = null;\\n\\t\\t\\ta.update();\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int size(Node x){ return x == null ? 0 : x.size;}\\n\\t\\tpublic long sum(Node x){ return x == null ? 0 : x.sum;}\\n\\n\\t\\tpublic void setParent(Node a, Node par)\\n\\t\\t{\\n\\t\\t\\tif(a != null)a.P = par;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b, Node... c)\\n\\t\\t{\\n\\t\\t\\tNode x = merge(a, b);\\n\\t\\t\\tfor(Node n : c)x = merge(x, n);\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b)\\n\\t\\t{\\n\\t\\t\\tif(b == null)return a;\\n\\t\\t\\tif(a == null)return b;\\n\\t\\t\\tif(a.priority > b.priority){\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tsetParent(b, null);\\n\\t\\t\\t\\ta.R = merge(a.R, b);\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a, null);\\n\\t\\t\\t\\tsetParent(b.L, null);\\n\\t\\t\\t\\tb.L = merge(a, b.L);\\n\\t\\t\\t\\tsetParent(b.L, b);\\n\\t\\t\\t\\tb.update();\\n\\t\\t\\t\\treturn b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node[] split(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return new Node[]{null, null};\\n\\t\\t\\tif(x.L != null)x.L.P = null;\\n\\t\\t\\tNode[] sp = new Node[]{x.L, x};\\n\\t\\t\\tx.L = null;\\n\\t\\t\\tx.update();\\n\\t\\t\\twhile(x.P != null){\\n\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\tx.P = null;\\n\\t\\t\\t\\tif(x == p.L){\\n\\t\\t\\t\\t\\tp.L = sp[1];\\n\\t\\t\\t\\t\\tif(sp[1] != null)sp[1].P = p;\\n\\t\\t\\t\\t\\tsp[1] = p;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tp.R = sp[0];\\n\\t\\t\\t\\t\\tif(sp[0] != null)sp[0].P = p;\\n\\t\\t\\t\\t\\tsp[0] = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp.update();\\n\\t\\t\\t\\tx = p;\\n\\t\\t\\t}\\n\\t\\t\\treturn sp;\\n\\t\\t}\\n\\n\\t\\t// [0,K),[K,N)\\n\\t\\tpublic Node[] split(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return new Node[]{null, null};\\n\\t\\t\\tif(K <= size(a.L)){\\n\\t\\t\\t\\tsetParent(a.L, null);\\n\\t\\t\\t\\tNode[] s = split(a.L, K);\\n\\t\\t\\t\\ta.L = s[1];\\n\\t\\t\\t\\tsetParent(a.L, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[1] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tNode[] s = split(a.R, K- size(a.L)-1);\\n\\t\\t\\t\\ta.R = s[0];\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[0] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node insertb(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\tassert x != null;\\n\\t\\t\\tint ind = lowerBound(root, x.v);\\n\\t\\t\\treturn insert(root, ind, x);\\n\\t\\t}\\n\\n\\t\\tpublic Node insert(Node root, int K, Node x)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K <= size(root);\\n\\t\\t\\tassert size(x) == 1;\\n\\t\\t\\tNode[] sp = split(root, K);\\n\\t\\t\\treturn merge(sp[0], x, sp[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\treturn x == null ? root : delete(root, index(x));\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(root);\\n\\t\\t\\tNode[] lm_r = split(root, K+1);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], K);\\n\\t\\t\\treturn merge(l_m[0], lm_r[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node get(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(a);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(K < size(a.L)){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else if(K == size(a.L)){\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tK = K - size(a.L)-1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int index(Node a)\\n\\t\\t{\\n\\t\\t\\tassert a != null;\\n\\t\\t\\tint ind = size(a.L);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tNode par = a.P;\\n\\t\\t\\t\\tif(par != null && par.R == a){\\n\\t\\t\\t\\t\\tind += size(par.L) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta = par;\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\t\\t}\\n\\n\\t\\tpublic Node mergeTechnically(Node x, Node y)\\n\\t\\t{\\n\\t\\t\\tif(size(x) > size(y)){\\n\\t\\t\\t\\tNode d = x; x = y; y = d;\\n\\t\\t\\t}\\n\\t\\t\\t// |x|<=|y|\\n\\t\\t\\tfor(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\\n\\t\\t\\treturn y;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(Node a, long q)\\n\\t\\t{\\n\\t\\t\\tint lcount = 0;\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(a.v >= q){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlcount += size(a.L) + 1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn lcount;\\n\\t\\t}\\n\\n\\t\\tpublic Node next(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.R != null){\\n\\t\\t\\t\\tx = x.R;\\n\\t\\t\\t\\twhile(x.L != null)x = x.L;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.L == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node prev(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.L != null){\\n\\t\\t\\t\\tx = x.L;\\n\\t\\t\\t\\twhile(x.R != null)x = x.R;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.R == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node build(Node[] a){return build(a, 0, a.length);}\\n\\t\\tpublic Node build(Node[] a, int l, int r)\\n\\t\\t{\\n\\t\\t\\tif(l >= r)return null;\\n\\n\\t\\t\\tint h = l+r>>1;\\n\\t\\t\\tNode root = a[h];\\n\\n\\t\\t\\tNode L = build(a, l, h);\\n\\t\\t\\troot.L = L;\\n\\t\\t\\tif(L != null)L.P = root;\\n\\n\\t\\t\\tNode R = build(a, h+1, r);\\n\\t\\t\\troot.R = R;\\n\\t\\t\\tif(R != null)R.P = root;\\n\\n\\t\\t\\troot.update();\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\n\\t\\tpublic Node[] nodes(Node a) { return nodes(a, new Node[size(a)], 0, size(a)); }\\n\\t\\tpublic Node[] nodes(Node a, Node[] ns, int L, int R)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tnodes(a.L, ns, L, L+ size(a.L));\\n\\t\\t\\tns[L+ size(a.L)] = a;\\n\\t\\t\\tnodes(a.R, ns, R- size(a.R), R);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\t// faster than nodes but inconsistent\\n\\t\\tpublic Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.size], new int[]{0}); }\\n\\t\\tpublic Node[] nodesdfs(Node a, Node[] ns, int[] pos)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tns[pos[0]++] = a;\\n\\t\\t\\tnodesdfs(a.L, ns, pos);\\n\\t\\t\\tnodesdfs(a.R, ns, pos);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\tpublic String toString(Node a, String indent)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return \"\";\\n\\t\\t\\treturn toString(a.L, indent + \"  \") +\\n\\t\\t\\t\\t\\tindent + a + \"\\\\n\" +\\n\\t\\t\\t\\t\\ttoString(a.R, indent + \"  \");\\n\\t\\t}\\n\\n\\t\\tpublic Node operate(Node root, int l, int r, Consumer<Node> o)\\n\\t\\t{\\n\\t\\t\\tNode[] lm_r = split(root, r);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], l);\\n\\t\\t\\to.accept(l_m[1]);\\n\\t\\t\\tl_m[1].update();\\n\\t\\t\\treturn merge(l_m[0], l_m[1], lm_r[1]);\\n}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Node root = null;\\n\\t\\t\\tMap<Integer, Node> map = new TreeMap<>();\\n\\t\\t\\tfor(int v : nums){\\n\\t\\t\\t\\tNode node = new Node(v);\\n\\t\\t\\t\\tmap.put(v, node);\\n\\t\\t\\t\\troot = merge(root, node);\\n\\t\\t\\t}\\n\\t\\t\\tlong ans = nums.length;\\n\\t\\t\\tfor(int k : map.keySet()){\\n\\t\\t\\t\\tNode node = map.get(k);\\n\\t\\t\\t\\tint index = index(node);\\n\\t\\t\\t\\tans += index;\\n\\t\\t\\t\\tNode[] lm_r = split(root, index+1);\\n\\t\\t\\t\\tNode[] l_m = split(lm_r[0], index);\\n\\t\\t\\t\\troot = merge(lm_r[1], l_m[0]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic Random gen = new Random();\\n\\t\\tpublic final int mod = 998244353;\\n\\n\\t\\tpublic class Node\\n\\t\\t{\\n\\t\\t\\tpublic long priority;\\n\\t\\t\\tpublic Node L, R, P;\\n\\n\\t\\t\\tpublic long v; // value\\n\\t\\t\\tpublic long sum;\\n\\t\\t\\tpublic int size;\\n\\n\\t\\t\\tpublic Node(int v)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthis.v = v;\\n\\t\\t\\t\\tpriority = gen.nextLong();\\n\\t\\t\\t\\tupdate();\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void update()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize = size(L) + size(R) + 1;\\n\\t\\t\\t\\tsum = v + sum(L) + sum(R);\\n\\t\\t\\t\\t// TODO\\n\\t\\t\\t}\\n\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic String toString() {\\n\\t\\t\\t\\treturn \"Node{\" +\\n\\t\\t\\t\\t\\t\\t\"v=\" + v +\\n\\t\\t\\t\\t\\t\\t\", sum=\" + sum +\\n\\t\\t\\t\\t\\t\\t\", size=\" + size +\\n\\t\\t\\t\\t\\t\\t\\'}\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void propagate(Node x)\\n\\t\\t{\\n\\t\\t\\tfor(;x != null;x = x.P)x.update();\\n\\t\\t}\\n\\n\\t\\tpublic Node disconnect(Node a)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return null;\\n\\t\\t\\ta.L = a.R = a.P = null;\\n\\t\\t\\ta.update();\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int size(Node x){ return x == null ? 0 : x.size;}\\n\\t\\tpublic long sum(Node x){ return x == null ? 0 : x.sum;}\\n\\n\\t\\tpublic void setParent(Node a, Node par)\\n\\t\\t{\\n\\t\\t\\tif(a != null)a.P = par;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b, Node... c)\\n\\t\\t{\\n\\t\\t\\tNode x = merge(a, b);\\n\\t\\t\\tfor(Node n : c)x = merge(x, n);\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b)\\n\\t\\t{\\n\\t\\t\\tif(b == null)return a;\\n\\t\\t\\tif(a == null)return b;\\n\\t\\t\\tif(a.priority > b.priority){\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tsetParent(b, null);\\n\\t\\t\\t\\ta.R = merge(a.R, b);\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a, null);\\n\\t\\t\\t\\tsetParent(b.L, null);\\n\\t\\t\\t\\tb.L = merge(a, b.L);\\n\\t\\t\\t\\tsetParent(b.L, b);\\n\\t\\t\\t\\tb.update();\\n\\t\\t\\t\\treturn b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node[] split(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return new Node[]{null, null};\\n\\t\\t\\tif(x.L != null)x.L.P = null;\\n\\t\\t\\tNode[] sp = new Node[]{x.L, x};\\n\\t\\t\\tx.L = null;\\n\\t\\t\\tx.update();\\n\\t\\t\\twhile(x.P != null){\\n\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\tx.P = null;\\n\\t\\t\\t\\tif(x == p.L){\\n\\t\\t\\t\\t\\tp.L = sp[1];\\n\\t\\t\\t\\t\\tif(sp[1] != null)sp[1].P = p;\\n\\t\\t\\t\\t\\tsp[1] = p;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tp.R = sp[0];\\n\\t\\t\\t\\t\\tif(sp[0] != null)sp[0].P = p;\\n\\t\\t\\t\\t\\tsp[0] = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp.update();\\n\\t\\t\\t\\tx = p;\\n\\t\\t\\t}\\n\\t\\t\\treturn sp;\\n\\t\\t}\\n\\n\\t\\t// [0,K),[K,N)\\n\\t\\tpublic Node[] split(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return new Node[]{null, null};\\n\\t\\t\\tif(K <= size(a.L)){\\n\\t\\t\\t\\tsetParent(a.L, null);\\n\\t\\t\\t\\tNode[] s = split(a.L, K);\\n\\t\\t\\t\\ta.L = s[1];\\n\\t\\t\\t\\tsetParent(a.L, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[1] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tNode[] s = split(a.R, K- size(a.L)-1);\\n\\t\\t\\t\\ta.R = s[0];\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[0] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node insertb(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\tassert x != null;\\n\\t\\t\\tint ind = lowerBound(root, x.v);\\n\\t\\t\\treturn insert(root, ind, x);\\n\\t\\t}\\n\\n\\t\\tpublic Node insert(Node root, int K, Node x)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K <= size(root);\\n\\t\\t\\tassert size(x) == 1;\\n\\t\\t\\tNode[] sp = split(root, K);\\n\\t\\t\\treturn merge(sp[0], x, sp[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\treturn x == null ? root : delete(root, index(x));\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(root);\\n\\t\\t\\tNode[] lm_r = split(root, K+1);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], K);\\n\\t\\t\\treturn merge(l_m[0], lm_r[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node get(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(a);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(K < size(a.L)){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else if(K == size(a.L)){\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tK = K - size(a.L)-1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int index(Node a)\\n\\t\\t{\\n\\t\\t\\tassert a != null;\\n\\t\\t\\tint ind = size(a.L);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tNode par = a.P;\\n\\t\\t\\t\\tif(par != null && par.R == a){\\n\\t\\t\\t\\t\\tind += size(par.L) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta = par;\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\t\\t}\\n\\n\\t\\tpublic Node mergeTechnically(Node x, Node y)\\n\\t\\t{\\n\\t\\t\\tif(size(x) > size(y)){\\n\\t\\t\\t\\tNode d = x; x = y; y = d;\\n\\t\\t\\t}\\n\\t\\t\\t// |x|<=|y|\\n\\t\\t\\tfor(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\\n\\t\\t\\treturn y;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(Node a, long q)\\n\\t\\t{\\n\\t\\t\\tint lcount = 0;\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(a.v >= q){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlcount += size(a.L) + 1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn lcount;\\n\\t\\t}\\n\\n\\t\\tpublic Node next(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.R != null){\\n\\t\\t\\t\\tx = x.R;\\n\\t\\t\\t\\twhile(x.L != null)x = x.L;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.L == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node prev(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.L != null){\\n\\t\\t\\t\\tx = x.L;\\n\\t\\t\\t\\twhile(x.R != null)x = x.R;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.R == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node build(Node[] a){return build(a, 0, a.length);}\\n\\t\\tpublic Node build(Node[] a, int l, int r)\\n\\t\\t{\\n\\t\\t\\tif(l >= r)return null;\\n\\n\\t\\t\\tint h = l+r>>1;\\n\\t\\t\\tNode root = a[h];\\n\\n\\t\\t\\tNode L = build(a, l, h);\\n\\t\\t\\troot.L = L;\\n\\t\\t\\tif(L != null)L.P = root;\\n\\n\\t\\t\\tNode R = build(a, h+1, r);\\n\\t\\t\\troot.R = R;\\n\\t\\t\\tif(R != null)R.P = root;\\n\\n\\t\\t\\troot.update();\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\n\\t\\tpublic Node[] nodes(Node a) { return nodes(a, new Node[size(a)], 0, size(a)); }\\n\\t\\tpublic Node[] nodes(Node a, Node[] ns, int L, int R)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tnodes(a.L, ns, L, L+ size(a.L));\\n\\t\\t\\tns[L+ size(a.L)] = a;\\n\\t\\t\\tnodes(a.R, ns, R- size(a.R), R);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\t// faster than nodes but inconsistent\\n\\t\\tpublic Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.size], new int[]{0}); }\\n\\t\\tpublic Node[] nodesdfs(Node a, Node[] ns, int[] pos)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tns[pos[0]++] = a;\\n\\t\\t\\tnodesdfs(a.L, ns, pos);\\n\\t\\t\\tnodesdfs(a.R, ns, pos);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\tpublic String toString(Node a, String indent)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return \"\";\\n\\t\\t\\treturn toString(a.L, indent + \"  \") +\\n\\t\\t\\t\\t\\tindent + a + \"\\\\n\" +\\n\\t\\t\\t\\t\\ttoString(a.R, indent + \"  \");\\n\\t\\t}\\n\\n\\t\\tpublic Node operate(Node root, int l, int r, Consumer<Node> o)\\n\\t\\t{\\n\\t\\t\\tNode[] lm_r = split(root, r);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], l);\\n\\t\\t\\to.accept(l_m[1]);\\n\\t\\t\\tl_m[1].update();\\n\\t\\t\\treturn merge(l_m[0], l_m[1], lm_r[1]);\\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467129,
                "title": "c-sorting-fenwick-tree",
                "content": "# Code\\n```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i, int val) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i] += val;\\n            i = i + (i & -i);\\n        }\\n    }\\n    void build(vector<int> &BIT, int n) {\\n        for(int i = 0; i < n; i++) {\\n            update(BIT, i, 1);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1); \\n        build(BIT, n);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0], -1);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += query(BIT, index[i]) - query(BIT, index[i - 1]);\\n            } else {\\n                ans += query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]);\\n            }\\n            update(BIT, index[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i, int val) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i] += val;\\n            i = i + (i & -i);\\n        }\\n    }\\n    void build(vector<int> &BIT, int n) {\\n        for(int i = 0; i < n; i++) {\\n            update(BIT, i, 1);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1); \\n        build(BIT, n);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0], -1);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += query(BIT, index[i]) - query(BIT, index[i - 1]);\\n            } else {\\n                ans += query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]);\\n            }\\n            update(BIT, index[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467113,
                "title": "o-n-log-n-sorting-with-hashmap-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(mut nums: Vec<i32>) -> i64 {\\n        let mut map = HashMap::new();\\n        let n = nums.len() as i64;\\n        let mut ans = n;\\n        \\n        for (i, &num) in nums.iter().enumerate() {\\n            map.insert(num, i);\\n        }\\n        \\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if map[&nums[i]] < map[&nums[i - 1]] { \\n                ans += n - i as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(mut nums: Vec<i32>) -> i64 {\\n        let mut map = HashMap::new();\\n        let n = nums.len() as i64;\\n        let mut ans = n;\\n        \\n        for (i, &num) in nums.iter().enumerate() {\\n            map.insert(num, i);\\n        }\\n        \\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if map[&nums[i]] < map[&nums[i - 1]] { \\n                ans += n - i as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467109,
                "title": "golang-sorting-o-nlogn",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n*logn)$$ - Sorting the slice\\n\\n- Space complexity: $$O(n)$$ \\n\\n\\n# Code\\n```\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467095,
                "title": "disjoint-set-o-nlogn-tc-beats-90-4-in-time-and-77-in-space",
                "content": "# Intuition\\nDisjoint set AND union\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjointSet{\\n    public:\\n        vector<long long int>set;\\n    \\n    disjointSet(int n){\\n        set.resize(n,-1);\\n    }\\n    \\n    int find(long long int i ){\\n        if(set[i] < 0)\\n            return i;\\n        return set[i] = find(set[i]);\\n    }\\n    \\n    void setUnion(int i , int j){\\n        int p1 = find(i), p2 = find(j);\\n        \\n        if(set[p1] < set[p2]){\\n            set[p1] += set[p2];\\n            set[p2] = p1;\\n        }else{\\n            set[p2] += set[p1];\\n            set[p1] = p2;\\n        }\\n    }\\n    \\n    long long int getRes(){\\n        long long int res = 0,si = set.size();\\n        for(int i = 0;i<set.size();i++){\\n            if(set[i] < 0){\\n                res += si;\\n                si += set[i];\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int res = 0;\\n        int n = nums.size();\\n        priority_queue<pair<int,int> ,vector<pair<int,int>> , greater<pair<int,int>>>pq;\\n        vector<int>rank(n);\\n        for(int i = 0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        int i = 0;\\n        while(!pq.empty()){\\n            rank[pq.top().second] = i;\\n            pq.pop();\\n            i++;\\n        }\\n        \\n        vector<int>vis(n,0);\\n        disjointSet ds(n);\\n        for(int i = 0;i<n;i++){\\n            vis[rank[i]]++;\\n            if(rank[i] != 0 && vis[rank[i] - 1]){\\n                ds.setUnion(rank[i] , rank[i] - 1);\\n            }\\n        }\\n        \\n        res = ds.getRes();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjointSet{\\n    public:\\n        vector<long long int>set;\\n    \\n    disjointSet(int n){\\n        set.resize(n,-1);\\n    }\\n    \\n    int find(long long int i ){\\n        if(set[i] < 0)\\n            return i;\\n        return set[i] = find(set[i]);\\n    }\\n    \\n    void setUnion(int i , int j){\\n        int p1 = find(i), p2 = find(j);\\n        \\n        if(set[p1] < set[p2]){\\n            set[p1] += set[p2];\\n            set[p2] = p1;\\n        }else{\\n            set[p2] += set[p1];\\n            set[p1] = p2;\\n        }\\n    }\\n    \\n    long long int getRes(){\\n        long long int res = 0,si = set.size();\\n        for(int i = 0;i<set.size();i++){\\n            if(set[i] < 0){\\n                res += si;\\n                si += set[i];\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int res = 0;\\n        int n = nums.size();\\n        priority_queue<pair<int,int> ,vector<pair<int,int>> , greater<pair<int,int>>>pq;\\n        vector<int>rank(n);\\n        for(int i = 0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        int i = 0;\\n        while(!pq.empty()){\\n            rank[pq.top().second] = i;\\n            pq.pop();\\n            i++;\\n        }\\n        \\n        vector<int>vis(n,0);\\n        disjointSet ds(n);\\n        for(int i = 0;i<n;i++){\\n            vis[rank[i]]++;\\n            if(rank[i] != 0 && vis[rank[i] - 1]){\\n                ds.setUnion(rank[i] , rank[i] - 1);\\n            }\\n        }\\n        \\n        res = ds.getRes();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467052,
                "title": "go-python-o-n-log-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    pos :=  make(map[int]int)\\n    for i,item := range(nums){\\n        pos[item] = i\\n    }\\n    answer := 0\\n    n := len(nums)\\n    idx := -math.MaxInt\\n    sort.Ints(nums)\\n    for k,a := range(nums){\\n        if pos[a] < idx{\\n            answer += n - k\\n        }\\n        idx = pos[a]\\n        answer++\\n    }\\n    return int64(answer)\\n}\\n```\\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {item: i for i,item in enumerate(nums)}\\n        answer = 0\\n        n = len(nums)\\n        idx = float(\"-inf\")\\n        nums.sort()\\n        for k,a in enumerate(nums):\\n            if pos[a] < idx:\\n                answer += n - k\\n            idx = pos[a]\\n            anwer+=1\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Array",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```golang []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    pos :=  make(map[int]int)\\n    for i,item := range(nums){\\n        pos[item] = i\\n    }\\n    answer := 0\\n    n := len(nums)\\n    idx := -math.MaxInt\\n    sort.Ints(nums)\\n    for k,a := range(nums){\\n        if pos[a] < idx{\\n            answer += n - k\\n        }\\n        idx = pos[a]\\n        answer++\\n    }\\n    return int64(answer)\\n}\\n```\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {item: i for i,item in enumerate(nums)}\\n        answer = 0\\n        n = len(nums)\\n        idx = float(\"-inf\")\\n        nums.sort()\\n        for k,a in enumerate(nums):\\n            if pos[a] < idx:\\n                answer += n - k\\n            idx = pos[a]\\n            anwer+=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467032,
                "title": "fenwick-tree-priorityqueue-java",
                "content": "The problem asks us to find the smallest value, and rotate all other values before it to the end of the array, and then take the smallest value out. We just keep doing it until we remove all values. At the beginning at each step, we would be at the position of the previously smallest value, and we want to rotate to the currently smallest value. In other words, if we have a_i, a_i+1, ... , a_j, a_j+1, .... at the currently step, and a_j is the smallest value in the remaining array, the element we removed before this step would be just before a_i. Now we need to rotate all elements before a_j to the end of the array.\\n\\nIf we sort the indices of the array by their values, or equivalently use a Priority Queue (Min Heap), we can iteratively go through the smallest values. Now we just need to find out how many rotations we need for each step. It is easy to see it\\'s just the number of elements left between the previously smallest element and the currently smallest element. (We have to account for two cases, since last could be before or after the current mininum) An efficient approach is to use a Fenwick Tree (Binary Indexed Tree) to keep track of which elements have been removed and how many elements remain before two indices.\\n\\n* In my implementation, the array uses 0-based index while BIT uses 1-based index. As a result, the arguments passed into BIT\\'s methods are all incremented by 1.\\n\\n```\\nclass Solution {\\n\\n    private static class BIT {\\n        private int[] arr;\\n\\n        public BIT(int n) {\\n            arr = new int[n+1];\\n            Arrays.fill(arr, 0);\\n        }\\n\\n        public BIT(int[] a) {\\n            arr = new int[a.length + 1];\\n            for (int i = 0; i < a.length; i++) {\\n                int idx = i+1;\\n                arr[idx] += a[i];\\n                int iidx = idx + lsb(idx);\\n                if (iidx < arr.length) {\\n                    arr[iidx] += arr[idx];\\n                }\\n            }\\n        }\\n\\n        public int preSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += arr[i];\\n                i = i - lsb(i);\\n            }\\n\\n            return sum;\\n\\n        }\\n\\n        public void add(int i, int v) {\\n            while (i < arr.length) {\\n                arr[i] += v;\\n                i = i + lsb(i);\\n            }\\n        }\\n\\n        private int lsb(int n) {\\n            return n & -n;\\n        }\\n    }\\n\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        BIT bit = new BIT(n);\\n        long total = 0;\\n        \\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((a, b) -> a.get(0) - b.get(0));\\n        for (int i = 0; i < n; i++) {\\n            pq.add(List.of(nums[i], i));\\n        }\\n        for (int i = 0; i < n; i++) {\\n            bit.add(i+1, 1);\\n        }\\n        \\n        int lastIdx = -1;\\n        while (pq.size() > 0) {\\n            List<Integer> nu = pq.poll();\\n            int idx = nu.get(1);\\n            if (lastIdx < idx) {\\n                total += bit.preSum(idx+1) - 1 - bit.preSum(lastIdx + 1);\\n            } else {\\n                total += bit.preSum(n) - bit.preSum(lastIdx+1) + bit.preSum(idx+1) - 1;\\n            }\\n            //System.out.println(total);\\n            bit.add(idx+1, -1);\\n            lastIdx = idx;\\n        }\\n        \\n        return total + n;\\n    }\\n}\\n```\\nTime Complexity: O(n * log(n)) Priority Queue takes O(n * log (n)) and Fenwick tree takes O(log(n)) to update points and query ranges for each step.\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static class BIT {\\n        private int[] arr;\\n\\n        public BIT(int n) {\\n            arr = new int[n+1];\\n            Arrays.fill(arr, 0);\\n        }\\n\\n        public BIT(int[] a) {\\n            arr = new int[a.length + 1];\\n            for (int i = 0; i < a.length; i++) {\\n                int idx = i+1;\\n                arr[idx] += a[i];\\n                int iidx = idx + lsb(idx);\\n                if (iidx < arr.length) {\\n                    arr[iidx] += arr[idx];\\n                }\\n            }\\n        }\\n\\n        public int preSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += arr[i];\\n                i = i - lsb(i);\\n            }\\n\\n            return sum;\\n\\n        }\\n\\n        public void add(int i, int v) {\\n            while (i < arr.length) {\\n                arr[i] += v;\\n                i = i + lsb(i);\\n            }\\n        }\\n\\n        private int lsb(int n) {\\n            return n & -n;\\n        }\\n    }\\n\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        BIT bit = new BIT(n);\\n        long total = 0;\\n        \\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((a, b) -> a.get(0) - b.get(0));\\n        for (int i = 0; i < n; i++) {\\n            pq.add(List.of(nums[i], i));\\n        }\\n        for (int i = 0; i < n; i++) {\\n            bit.add(i+1, 1);\\n        }\\n        \\n        int lastIdx = -1;\\n        while (pq.size() > 0) {\\n            List<Integer> nu = pq.poll();\\n            int idx = nu.get(1);\\n            if (lastIdx < idx) {\\n                total += bit.preSum(idx+1) - 1 - bit.preSum(lastIdx + 1);\\n            } else {\\n                total += bit.preSum(n) - bit.preSum(lastIdx+1) + bit.preSum(idx+1) - 1;\\n            }\\n            //System.out.println(total);\\n            bit.add(idx+1, -1);\\n            lastIdx = idx;\\n        }\\n        \\n        return total + n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467018,
                "title": "easy-sorting-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        arr = sorted([(e,i) for i, e in enumerate(nums)])\\n        ans = c = p = 0\\n        for e, i in arr:\\n            if i<p:\\n                c += 1 \\n            ans += c\\n            p = i\\n        return ans+len(nums)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        arr = sorted([(e,i) for i, e in enumerate(nums)])\\n        ans = c = p = 0\\n        for e, i in arr:\\n            if i<p:\\n                c += 1 \\n            ans += c\\n            p = i\\n        return ans+len(nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467008,
                "title": "best-c-solution-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        map<int, int> mp;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            mp[nums[i]] = i;\\n        }\\n        \\n        int lastInd = -1, len = n, removed = 0, cnt = 0;\\n        long long ans = 0;\\n        for(auto &[num, ind] : mp) {\\n            if(ind < lastInd) {\\n                ans += len-removed;\\n                removed += cnt;\\n                cnt = 0;\\n            }\\n            lastInd = ind;\\n            cnt++;\\n        }\\n        ans += len-removed;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        map<int, int> mp;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            mp[nums[i]] = i;\\n        }\\n        \\n        int lastInd = -1, len = n, removed = 0, cnt = 0;\\n        long long ans = 0;\\n        for(auto &[num, ind] : mp) {\\n            if(ind < lastInd) {\\n                ans += len-removed;\\n                removed += cnt;\\n                cnt = 0;\\n            }\\n            lastInd = ind;\\n            cnt++;\\n        }\\n        ans += len-removed;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466994,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466975,
                "title": "brute-force-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of adding numbers at the end, we just erase each smallest number, in increasing value and position order. Sorting (position, value) pairs by value only has to be done once.\\n\\nWe keep the numbers in a list sorted by position; each erasure or lookup takes logarithmic time.\\n\\nAfter reaching the end of the list, we go back to the beginning. This simulates adding the skipped numbers to the end of the list.\\n\\nThis solution uses the SortedList class from the sortedcontainers module.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        from sortedcontainers import SortedList as slist\\n        lst0=slist(enumerate(nums), key=lambda x:x[0])\\n        lst1=list(enumerate(nums))\\n        lst1.sort(key=lambda x:x[1])\\n        \\n        ans=0\\n        ct=0\\n        while ct<l:\\n            old_pos=-1\\n            it_lst=[]\\n            while ct<l:\\n                it=lst1[ct]\\n                pos=lst0.index(it)\\n                if pos>=old_pos:\\n                    ans+=pos-old_pos\\n                    old_pos=pos\\n                    it_lst.append(it)\\n                    ct+=1\\n                else:\\n                    ans+=len(lst0)-old_pos-1\\n                    break\\n            for it in it_lst:\\n                lst0.discard(it)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        from sortedcontainers import SortedList as slist\\n        lst0=slist(enumerate(nums), key=lambda x:x[0])\\n        lst1=list(enumerate(nums))\\n        lst1.sort(key=lambda x:x[1])\\n        \\n        ans=0\\n        ct=0\\n        while ct<l:\\n            old_pos=-1\\n            it_lst=[]\\n            while ct<l:\\n                it=lst1[ct]\\n                pos=lst0.index(it)\\n                if pos>=old_pos:\\n                    ans+=pos-old_pos\\n                    old_pos=pos\\n                    it_lst.append(it)\\n                    ct+=1\\n                else:\\n                    ans+=len(lst0)-old_pos-1\\n                    break\\n            for it in it_lst:\\n                lst0.discard(it)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466970,
                "title": "c-simple-solution-with-sort",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        typedef pair<int, int> pii;\\n        int n = nums.size();\\n        vector<pii> sorted(n);\\n        for (int i = 0; i < n; i++) {\\n            sorted[i] = {nums[i], i};\\n        }\\n        sort(sorted.begin(), sorted.end());\\n        int count = 0, cursize = n;\\n        long long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            count++;\\n            if (i == n - 1 || sorted[i+1].second < sorted[i].second) {\\n                res += cursize;\\n                cursize -= count;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        typedef pair<int, int> pii;\\n        int n = nums.size();\\n        vector<pii> sorted(n);\\n        for (int i = 0; i < n; i++) {\\n            sorted[i] = {nums[i], i};\\n        }\\n        sort(sorted.begin(), sorted.end());\\n        int count = 0, cursize = n;\\n        long long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            count++;\\n            if (i == n - 1 || sorted[i+1].second < sorted[i].second) {\\n                res += cursize;\\n                cursize -= count;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466954,
                "title": "easy-solution-in-js",
                "content": "All credit goes to Lee .\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map={};\\n    var n=nums.length,p=0;\\n    var ans=n;\\n    for(let i=0;i<n;i++){\\n        map[nums[i]]=i;\\n    }\\n    nums.sort((a,b)=>a-b);\\n    for(let i=0;i<n;p=map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans+=n-i;\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map={};\\n    var n=nums.length,p=0;\\n    var ans=n;\\n    for(let i=0;i<n;i++){\\n        map[nums[i]]=i;\\n    }\\n    nums.sort((a,b)=>a-b);\\n    for(let i=0;i<n;p=map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans+=n-i;\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466927,
                "title": "worst-question-ever",
                "content": "\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        \\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        \\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        \\n        else:\\n            left_count = self.count(sl, n, start, n - 1)\\n            right_count = self.count(sl, n, 0, end)\\n            return left_count + right_count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        \\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        \\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        \\n        else:\\n            left_count = self.count(sl, n, start, n - 1)\\n            right_count = self.count(sl, n, 0, end)\\n            return left_count + right_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466909,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {num: i + 1 for i,num in enumerate(nums)}\\n        n = len(nums)\\n        ans=n\\n        i = 0\\n        for k,num in enumerate(sorted(nums)):\\n            if pos[num] < i:\\n                ans += n - k\\n            i = pos[num]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {num: i + 1 for i,num in enumerate(nums)}\\n        n = len(nums)\\n        ans=n\\n        i = 0\\n        for k,num in enumerate(sorted(nums)):\\n            if pos[num] < i:\\n                ans += n - k\\n            i = pos[num]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466826,
                "title": "compress-the-array-and-traverse-it-loop-by-loop-python-o-nlogn-no-segment-tree",
                "content": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        compress = {}\\n        for i, n in enumerate(sorted(nums)):\\n            compress[n] = i + 1\\n        for i in range(len(nums)):\\n            nums[i] = compress[nums[i]]\\n        position = {}\\n        for i, n in enumerate(nums):\\n            position[n] = i\\n        \\n        res = 0\\n        current_loop_size = len(nums)\\n        cur_num = cur_loop_count = 1\\n        cur_idx = position[cur_num]\\n        while cur_num < len(nums):\\n            nex = position[cur_num + 1]\\n            if nex < cur_idx:\\n                res += current_loop_size\\n                current_loop_size -= cur_loop_count\\n                cur_loop_count = 0\\n            cur_idx = nex\\n            cur_num = nums[nex]\\n            cur_loop_count += 1\\n        return res + cur_loop_count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        compress = {}\\n        for i, n in enumerate(sorted(nums)):\\n            compress[n] = i + 1\\n        for i in range(len(nums)):\\n            nums[i] = compress[nums[i]]\\n        position = {}\\n        for i, n in enumerate(nums):\\n            position[n] = i\\n        \\n        res = 0\\n        current_loop_size = len(nums)\\n        cur_num = cur_loop_count = 1\\n        cur_idx = position[cur_num]\\n        while cur_num < len(nums):\\n            nex = position[cur_num + 1]\\n            if nex < cur_idx:\\n                res += current_loop_size\\n                current_loop_size -= cur_loop_count\\n                cur_loop_count = 0\\n            cur_idx = nex\\n            cur_num = nums[nex]\\n            cur_loop_count += 1\\n        return res + cur_loop_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466808,
                "title": "c-sorting-fenwick-tree",
                "content": "# Code\\n```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i]++;\\n            i = i + (i & -i);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0]);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += (index[i] - index[i - 1]) - (query(BIT, index[i]) - query(BIT, index[i - 1]));\\n            } else {\\n                ans += (n - index[i - 1] + index[i]) - (query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]));\\n            }\\n            update(BIT, index[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i]++;\\n            i = i + (i & -i);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0]);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += (index[i] - index[i - 1]) - (query(BIT, index[i]) - query(BIT, index[i - 1]));\\n            } else {\\n                ans += (n - index[i - 1] + index[i]) - (query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]));\\n            }\\n            update(BIT, index[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466789,
                "title": "python-3-segment-tree",
                "content": "The list is circular, each next mininum needs to be rotated to the front. Number of operation needed depends on whether the next minimum is sitting to the left or right of the current minimum in the original nums. However, elements in between the two may have been removed, therefore need a counting structure to keep track of how many elements have been removed between any two indices. Hereinafter I used segment tree.\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # track original indices to determine count of ratations\\n        dc = {v: i for i, v in enumerate(nums)} \\n        arr = sorted(nums)\\n            \\n        tree = [0] * (2 * n)\\n        \\n        def update(index):\\n            index += n\\n            while index:\\n                tree[index] += 1\\n                index //= 2\\n\\n        def sumRange(left, right):\\n            left += n\\n            right += n\\n            ans = 0\\n            while left <= right:\\n                if left & 1:\\n                    ans += tree[left]\\n                    left += 1\\n                if not right & 1:\\n                    ans += tree[right]\\n                    right -= 1\\n                left //= 2\\n                right //= 2\\n            return ans\\n        \\n        idx = dc[arr[0]]\\n        ans = dc[arr[0]] + 1\\n        update(idx)\\n        for i in range(1, n - 1):\\n            j = dc[arr[i]]\\n            if j > idx:\\n                # next is to the right, directly roate to the right\\n                ans += j - idx - sumRange(idx + 1, j)\\n            else:\\n                # next is to the left, rotate across the end\\n                ans += (j + 1 - sumRange(0, j)) + (n - idx - 1 - sumRange(idx + 1, n - 1))\\n            idx = j\\n            update(j)\\n        return ans + (1 if n > 1 else 0) # 1 extra for the last element if n > 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # track original indices to determine count of ratations\\n        dc = {v: i for i, v in enumerate(nums)} \\n        arr = sorted(nums)\\n            \\n        tree = [0] * (2 * n)\\n        \\n        def update(index):\\n            index += n\\n            while index:\\n                tree[index] += 1\\n                index //= 2\\n\\n        def sumRange(left, right):\\n            left += n\\n            right += n\\n            ans = 0\\n            while left <= right:\\n                if left & 1:\\n                    ans += tree[left]\\n                    left += 1\\n                if not right & 1:\\n                    ans += tree[right]\\n                    right -= 1\\n                left //= 2\\n                right //= 2\\n            return ans\\n        \\n        idx = dc[arr[0]]\\n        ans = dc[arr[0]] + 1\\n        update(idx)\\n        for i in range(1, n - 1):\\n            j = dc[arr[i]]\\n            if j > idx:\\n                # next is to the right, directly roate to the right\\n                ans += j - idx - sumRange(idx + 1, j)\\n            else:\\n                # next is to the left, rotate across the end\\n                ans += (j + 1 - sumRange(0, j)) + (n - idx - 1 - sumRange(idx + 1, n - 1))\\n            idx = j\\n            update(j)\\n        return ans + (1 if n > 1 else 0) # 1 extra for the last element if n > 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466788,
                "title": "o-n-python3-solution-using-list-of-wrap-counts",
                "content": "# Intuition\\nSince N = 1E5, this requires an $$O(N * Log(N))$$ solution or better; however, it is not clear how to avoid the brute-force $$O(N^2)$$ traversals. We will first write a slow solution, then try to find a pattern or formula, then proceed with an $$O(N * Log(N))$$ solution.\\n\\n# Approach\\nSince only the relative ordering is needed, simplify the problem by producing `idxs`, the index of the ith smallest element. Then we use the formula `n + sum(wrapCounts)` observed in `countOperationsToEmptyArraySlow`, to write our $$O(N)$$ solution.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(N * Log(N))$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    \"\"\"Notes\\n    * N = 1E5, so N Log N probably needed.\\n      * Ugh. The natural way is O(N^2). Need examples:\\n        * Find relative positions of numbers from small to large. Then the math is tricky.\\n        * Write slow method, then find pattern.\\n    \"\"\"\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # return self.countOperationsToEmptyArraySlow(nums)\\n        return self.countOperationsToEmptyArrayFast(nums)\\n    \\n    def countOperationsToEmptyArrayFast(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # Produces indices of numbers from small to large.\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        idxs = []\\n        for num, idx in numIdxs:\\n            idxs.append(idx)\\n            \\n        # Find the wrapCount of each num.\\n        prevPos = -1\\n        wrapCounts = []\\n        wrapCount = 0\\n        for i in range(n):\\n            pos = idxs[i]               \\n            if prevPos > pos:\\n                wrapCount += 1\\n            wrapCounts.append(wrapCount)\\n            prevPos = pos\\n        sumWrapCounts = sum(wrapCounts)\\n        \\n        # This formula uses evidence gathered from countOperationsToEmptyArraySlow.\\n        return n + sumWrapCounts\\n        \\n    def countOperationsToEmptyArraySlow(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        nums = [None] * n\\n        idxs = [None] * n\\n        for i, (num, idx) in enumerate(numIdxs):\\n            nums[idx] = i\\n            idxs[i] = idx\\n        numOps = 0\\n        prevPos = -1\\n        wrapCounts = []\\n        wraps = 0\\n        for i in range(n):\\n            pos = idxs[i]\\n            cursor = prevPos\\n            while cursor != pos:\\n                cursor = (cursor + 1) % n\\n                if nums[cursor] >= i:\\n                    numOps += 1\\n            if prevPos > pos:\\n                wraps += 1\\n            wrapCounts.append(wraps)\\n            prevPos = pos\\n        print(f\\'nums={nums}, idxs={idxs}, n={n}, wrapCounts={wrapCounts}, numOps={numOps}\\')\\n        return numOps        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"Notes\\n    * N = 1E5, so N Log N probably needed.\\n      * Ugh. The natural way is O(N^2). Need examples:\\n        * Find relative positions of numbers from small to large. Then the math is tricky.\\n        * Write slow method, then find pattern.\\n    \"\"\"\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # return self.countOperationsToEmptyArraySlow(nums)\\n        return self.countOperationsToEmptyArrayFast(nums)\\n    \\n    def countOperationsToEmptyArrayFast(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # Produces indices of numbers from small to large.\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        idxs = []\\n        for num, idx in numIdxs:\\n            idxs.append(idx)\\n            \\n        # Find the wrapCount of each num.\\n        prevPos = -1\\n        wrapCounts = []\\n        wrapCount = 0\\n        for i in range(n):\\n            pos = idxs[i]               \\n            if prevPos > pos:\\n                wrapCount += 1\\n            wrapCounts.append(wrapCount)\\n            prevPos = pos\\n        sumWrapCounts = sum(wrapCounts)\\n        \\n        # This formula uses evidence gathered from countOperationsToEmptyArraySlow.\\n        return n + sumWrapCounts\\n        \\n    def countOperationsToEmptyArraySlow(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        nums = [None] * n\\n        idxs = [None] * n\\n        for i, (num, idx) in enumerate(numIdxs):\\n            nums[idx] = i\\n            idxs[i] = idx\\n        numOps = 0\\n        prevPos = -1\\n        wrapCounts = []\\n        wraps = 0\\n        for i in range(n):\\n            pos = idxs[i]\\n            cursor = prevPos\\n            while cursor != pos:\\n                cursor = (cursor + 1) % n\\n                if nums[cursor] >= i:\\n                    numOps += 1\\n            if prevPos > pos:\\n                wraps += 1\\n            wrapCounts.append(wraps)\\n            prevPos = pos\\n        print(f\\'nums={nums}, idxs={idxs}, n={n}, wrapCounts={wrapCounts}, numOps={numOps}\\')\\n        return numOps        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466749,
                "title": "fenwick-tree-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#include \"ext/pb_ds/assoc_container.hpp\"\\n#include \"ext/pb_ds/tree_policy.hpp\"\\nusing namespace __gnu_pbds;\\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\n#define str string\\n#define ll long long\\n#define ld long double\\n#define ar array\\n\\n#define vt vector\\n#define pb push_back\\n#define fi first\\n#define se second\\n#define all(c) (c).begin(), (c).end()\\n#define len(x) (int)(x).size()\\n#define elif else if\\n#define def function\\n\\n#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))\\n#define F_OR1(e) F_OR(i, 0, e, 1)\\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\\n#define GET5(a, b, c, d, e, ...) e\\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\\n#define each(x, a) for (auto& x: a)\\n\\nclass Solution {\\npublic:\\n    template<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n         int n = len(a);\\n   \\n    vt<int> st(n, 1);\\n    vt<pair<int, int>> b;\\n    rep(i, n) b.pb({a[i], i});\\n    sort(all(b));\\n    range_add_range_sum_query_solver rmq(st);\\n    ll ret = n, cur = 0;\\n    rep(i, n){\\n        auto [a, idx] = b[i];\\n        rmq.update(idx, idx+1, -1);\\n        if (idx < cur){\\n            ret += rmq.query(cur, n);\\n            ret += rmq.query(0, idx);\\n        }\\n        elif(cur == idx) {int ajay = 1;}\\n        else{\\n            ret += rmq.query(cur, idx);\\n        }\\n        cur = (idx + 1)%n;\\n    }\\n    return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#include \"ext/pb_ds/assoc_container.hpp\"\\n#include \"ext/pb_ds/tree_policy.hpp\"\\nusing namespace __gnu_pbds;\\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\n#define str string\\n#define ll long long\\n#define ld long double\\n#define ar array\\n\\n#define vt vector\\n#define pb push_back\\n#define fi first\\n#define se second\\n#define all(c) (c).begin(), (c).end()\\n#define len(x) (int)(x).size()\\n#define elif else if\\n#define def function\\n\\n#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))\\n#define F_OR1(e) F_OR(i, 0, e, 1)\\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\\n#define GET5(a, b, c, d, e, ...) e\\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\\n#define each(x, a) for (auto& x: a)\\n\\nclass Solution {\\npublic:\\n    template<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n         int n = len(a);\\n   \\n    vt<int> st(n, 1);\\n    vt<pair<int, int>> b;\\n    rep(i, n) b.pb({a[i], i});\\n    sort(all(b));\\n    range_add_range_sum_query_solver rmq(st);\\n    ll ret = n, cur = 0;\\n    rep(i, n){\\n        auto [a, idx] = b[i];\\n        rmq.update(idx, idx+1, -1);\\n        if (idx < cur){\\n            ret += rmq.query(cur, n);\\n            ret += rmq.query(0, idx);\\n        }\\n        elif(cur == idx) {int ajay = 1;}\\n        else{\\n            ret += rmq.query(cur, idx);\\n        }\\n        cur = (idx + 1)%n;\\n    }\\n    return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3466707,
                "title": "rust-solution",
                "content": "\\n# Code\\n```\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1879059,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1888401,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1878174,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1876996,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1928944,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1880102,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1879331,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 2007525,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1998398,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1972916,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1879059,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1888401,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1878174,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1876996,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1928944,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1880102,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1879331,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 2007525,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1998398,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1972916,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            }
        ]
    },
    {
        "title": "Split a Circular Linked List",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1927372,
                "content": [
                    {
                        "username": "mvivirito",
                        "content": "Can we assume all val are unique? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Moves in a Grid",
        "question_content": "<p>You are given a <strong>0-indexed</strong> <code>m x n</code> matrix <code>grid</code> consisting of <strong>positive</strong> integers.</p>\n\n<p>You can start at <strong>any</strong> cell in the first column of the matrix, and traverse the grid in the following way:</p>\n\n<ul>\n\t<li>From a cell <code>(row, col)</code>, you can move to any of the cells: <code>(row - 1, col + 1)</code>, <code>(row, col + 1)</code> and <code>(row + 1, col + 1)</code> such that the value of the cell you move to, should be <strong>strictly</strong> bigger than the value of the current cell.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> number of <strong>moves</strong> that you can perform.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png\" style=\"width: 201px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can start at the cell (0, 0) and make the following moves:\n- (0, 0) -&gt; (0, 1).\n- (0, 1) -&gt; (1, 2).\n- (1, 2) -&gt; (2, 3).\nIt can be shown that it is the maximum number of moves that can be made.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png\" />\n<strong>Input:</strong> grid = [[3,2,4],[2,1,9],[1,1,7]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Starting from any cell in the first column we cannot perform any moves.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3521869,
                "title": "c-java-python3-top-down-dp",
                "content": "\\n# Intuition\\nGiven the constraints we can try a dynamic programming approach if each state is O(1). \\n\\n# Approach\\n* From each cell we will try to move to (i + 1, j + 1) or (i, j + 1) or (i - 1, j + 1) if the values at these cells is greater than the current cell\\n* We will try starting from all the cells in the first column `(i, 0)` where i is in `[0, m)`\\n* Cache each state to avoid redundant calculations\\n\\n# Complexity\\n- Time complexity: O(mn)\\n\\n- Space complexity: O(mn)\\n\\n# Code\\n**Python3**:\\n```\\ndef maxMoves(self, grid: List[List[int]]) -> int:\\n    m, n, dirs = len(grid), len(grid[0]), [(0, 1), (1, 1), (-1, 1)]\\n    @cache\\n    def dp(i, j):\\n        ans = 0\\n        for x, y in dirs:\\n            ni, nj = i + x, j + y\\n            if 0 <= ni < m and nj < n and grid[i][j] < grid[ni][nj]:\\n                ans = max(ans, 1 + dp(ni, nj))\\n        return ans\\n    return max(dp(i, 0) for i in range(m))\\n```\\n\\n**C++**:\\n```\\nint maxMoves(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<pair<int, int>> dirs = {{0, 1}, {1, 1}, {-1, 1}};\\n    vector<vector<int>> cache(m, vector<int>(n, -1));\\n\\n    function<int(int, int)> dp = [&](int i, int j) {\\n        if (cache[i][j] != -1) return cache[i][j];\\n        int ans = 0;\\n        for (auto [x, y] : dirs) {\\n            int ni = i + x, nj = j + y;\\n            if (ni >= 0 && ni < m && nj < n && grid[i][j] < grid[ni][nj])\\n                ans = max(ans, 1 + dp(ni, nj));\\n        }\\n        return cache[i][j] = ans;\\n    };\\n    int res = 0;\\n    for (int i = 0; i < m; i++)\\n        res = max(res, dp(i, 0));\\n    return res;\\n}\\n```\\n\\n**Java**:\\n```\\nclass Solution {\\n    int dirs[][] = {{0, 1}, {1, 1}, {-1, 1}}, m, n, cache[][];\\n    public int maxMoves(int[][] grid) {\\n        m = grid.length; n = grid[0].length; cache = new int[m][n];\\n        Arrays.stream(cache).forEach(row -> Arrays.fill(row, -1));\\n\\n        int res = 0;\\n        for (int i = 0; i < m; i++)\\n            res = Math.max(res, dp(grid, i, 0));\\n        return res;\\n    }\\n    \\n    private int dp(int[][] grid, int i, int j) {\\n        if (cache[i][j] != -1) return cache[i][j];\\n        int ans = 0;\\n        for (int[] dir : dirs) {\\n            int ni = i + dir[0], nj = j + dir[1];\\n            if (ni >= 0 && ni < m && nj < n && grid[i][j] < grid[ni][nj])\\n                ans = Math.max(ans, 1 + dp(grid, ni, nj));\\n        }\\n        return cache[i][j] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef maxMoves(self, grid: List[List[int]]) -> int:\\n    m, n, dirs = len(grid), len(grid[0]), [(0, 1), (1, 1), (-1, 1)]\\n    @cache\\n    def dp(i, j):\\n        ans = 0\\n        for x, y in dirs:\\n            ni, nj = i + x, j + y\\n            if 0 <= ni < m and nj < n and grid[i][j] < grid[ni][nj]:\\n                ans = max(ans, 1 + dp(ni, nj))\\n        return ans\\n    return max(dp(i, 0) for i in range(m))\\n```\n```\\nint maxMoves(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<pair<int, int>> dirs = {{0, 1}, {1, 1}, {-1, 1}};\\n    vector<vector<int>> cache(m, vector<int>(n, -1));\\n\\n    function<int(int, int)> dp = [&](int i, int j) {\\n        if (cache[i][j] != -1) return cache[i][j];\\n        int ans = 0;\\n        for (auto [x, y] : dirs) {\\n            int ni = i + x, nj = j + y;\\n            if (ni >= 0 && ni < m && nj < n && grid[i][j] < grid[ni][nj])\\n                ans = max(ans, 1 + dp(ni, nj));\\n        }\\n        return cache[i][j] = ans;\\n    };\\n    int res = 0;\\n    for (int i = 0; i < m; i++)\\n        res = max(res, dp(i, 0));\\n    return res;\\n}\\n```\n```\\nclass Solution {\\n    int dirs[][] = {{0, 1}, {1, 1}, {-1, 1}}, m, n, cache[][];\\n    public int maxMoves(int[][] grid) {\\n        m = grid.length; n = grid[0].length; cache = new int[m][n];\\n        Arrays.stream(cache).forEach(row -> Arrays.fill(row, -1));\\n\\n        int res = 0;\\n        for (int i = 0; i < m; i++)\\n            res = Math.max(res, dp(grid, i, 0));\\n        return res;\\n    }\\n    \\n    private int dp(int[][] grid, int i, int j) {\\n        if (cache[i][j] != -1) return cache[i][j];\\n        int ans = 0;\\n        for (int[] dir : dirs) {\\n            int ni = i + dir[0], nj = j + dir[1];\\n            if (ni >= 0 && ni < m && nj < n && grid[i][j] < grid[ni][nj])\\n                ans = Math.max(ans, 1 + dp(grid, ni, nj));\\n        }\\n        return cache[i][j] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521919,
                "title": "explained-both-dp-dfs-approach-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution</b>\\n\\n# Approach \\n1. Take one extra space of the size of the grid and initialise all to 0.\\n2. Then keep checking from the last second column the next three possible node\\n   and take the max of them with 1 added to them.\\n3. Repeat above for all other nodes and keep traking for max value when the column is 0.\\n    \\n# Code\\n\\nApproach - 1: DP with simple iteration\\n```\\nint maxMoves(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    vector<vector<int>> dp(grid.size(), vector<int> (grid[0].size(), 0));\\n    for(int c = grid[0].size()-2; c >= 0; --c){\\n        for(int r = 0; r < grid.size(); ++r ){\\n            if(r - 1 >= 0 && grid[r][c] < grid[r-1][c+1])  { \\n                dp[r][c] = max(dp[r][c], 1 + dp[r-1][c+1]); \\n            }\\n            if( grid[r][c] < grid[r][c+1]) { \\n                dp[r][c] = max(dp[r][c], 1 + dp[r][c+1]); \\n            }\\n            if(r + 1 < grid.size() && grid[r][c] < grid[r+1][c+1]) { \\n                dp[r][c] = max(dp[r][c], 1 + dp[r+1][c+1]); \\n            }\\n            if(c == 0) { ans = max(ans, dp[r][c]);  }\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\nApproach - 2: DFS solution \\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c, int prev){\\n        if(r < 0 || r == grid.size() || c == grid[0].size() || prev >= grid[r][c] ) return 0;\\n        prev = grid[r][c];\\n        grid[r][c] = INT_MAX;\\n        int res = dfs(grid, r-1, c+1, prev);\\n        res = max(res, dfs(grid, r, c+1, prev ));\\n        res = max(res, dfs(grid, r+1, c+1, prev));\\n        return res + 1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); ++i) ans = max(ans, dfs(grid, i, 0, 0));\\n        return ans-1;\\n    }\\n};\\n```\\n\\n\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint maxMoves(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    vector<vector<int>> dp(grid.size(), vector<int> (grid[0].size(), 0));\\n    for(int c = grid[0].size()-2; c >= 0; --c){\\n        for(int r = 0; r < grid.size(); ++r ){\\n            if(r - 1 >= 0 && grid[r][c] < grid[r-1][c+1])  { \\n                dp[r][c] = max(dp[r][c], 1 + dp[r-1][c+1]); \\n            }\\n            if( grid[r][c] < grid[r][c+1]) { \\n                dp[r][c] = max(dp[r][c], 1 + dp[r][c+1]); \\n            }\\n            if(r + 1 < grid.size() && grid[r][c] < grid[r+1][c+1]) { \\n                dp[r][c] = max(dp[r][c], 1 + dp[r+1][c+1]); \\n            }\\n            if(c == 0) { ans = max(ans, dp[r][c]);  }\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c, int prev){\\n        if(r < 0 || r == grid.size() || c == grid[0].size() || prev >= grid[r][c] ) return 0;\\n        prev = grid[r][c];\\n        grid[r][c] = INT_MAX;\\n        int res = dfs(grid, r-1, c+1, prev);\\n        res = max(res, dfs(grid, r, c+1, prev ));\\n        res = max(res, dfs(grid, r+1, c+1, prev));\\n        return res + 1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); ++i) ans = max(ans, dfs(grid, i, 0, 0));\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522745,
                "title": "java-easy-bfs-without-dp",
                "content": "**Simple BFS Technique**\\n```\\nclass Pair{\\n    int x;\\n    int y;\\n    int steps;\\n    Pair(int x,int y,int steps){\\n        this.x=x;\\n        this.y=y;\\n        this.steps=steps;\\n    }\\n}\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int max=0;\\n        for(int i=0;i<grid.length;i++){\\n            int cnt=bfs(grid,i);\\n            max=Math.max(max,cnt);\\n        }\\n        return max;\\n    }\\n    public int bfs(int[][] grid,int row){\\n        Queue<Pair> qu=new LinkedList<>();\\n        qu.add(new Pair(row,0,0));\\n        boolean[][] vis=new boolean[grid.length][grid[0].length];\\n        vis[row][0]=true;\\n        int steps=0;\\n        while(!qu.isEmpty()){\\n            Pair p=qu.poll();\\n            int x=p.x;\\n            int y=p.y;\\n            steps=p.steps;\\n            int diri[]={-1,0,1};\\n            int dirj[]={1,1,1};\\n            for(int i=0;i<3;i++){\\n                int curri=x+diri[i];\\n                int currj=y+dirj[i];\\n                if(curri>=0 && curri<grid.length && currj>=0 && currj<grid[0].length && !vis[curri][currj] && grid[curri][currj]>grid[x][y]){\\n                    qu.add(new Pair(curri,currj,steps+1));\\n                    vis[curri][currj]=true;\\n                }\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/129511c2-6ae3-44de-b557-03c631a73683_1684046372.291239.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair{\\n    int x;\\n    int y;\\n    int steps;\\n    Pair(int x,int y,int steps){\\n        this.x=x;\\n        this.y=y;\\n        this.steps=steps;\\n    }\\n}\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int max=0;\\n        for(int i=0;i<grid.length;i++){\\n            int cnt=bfs(grid,i);\\n            max=Math.max(max,cnt);\\n        }\\n        return max;\\n    }\\n    public int bfs(int[][] grid,int row){\\n        Queue<Pair> qu=new LinkedList<>();\\n        qu.add(new Pair(row,0,0));\\n        boolean[][] vis=new boolean[grid.length][grid[0].length];\\n        vis[row][0]=true;\\n        int steps=0;\\n        while(!qu.isEmpty()){\\n            Pair p=qu.poll();\\n            int x=p.x;\\n            int y=p.y;\\n            steps=p.steps;\\n            int diri[]={-1,0,1};\\n            int dirj[]={1,1,1};\\n            for(int i=0;i<3;i++){\\n                int curri=x+diri[i];\\n                int currj=y+dirj[i];\\n                if(curri>=0 && curri<grid.length && currj>=0 && currj<grid[0].length && !vis[curri][currj] && grid[curri][currj]>grid[x][y]){\\n                    qu.add(new Pair(curri,currj,steps+1));\\n                    vis[curri][currj]=true;\\n                }\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521939,
                "title": "cpp-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int dfs(vector<vector<int>> &v,int i,int j,int prev) {\\n        if(i < 0 || i >= v.size() || j >= v[0].size() || v[i][j] <= prev) return -1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = max({1 + dfs(v,i - 1,j + 1,v[i][j]),1 + dfs(v,i,j + 1,v[i][j]), 1 + dfs(v,i + 1,j + 1,v[i][j])});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int j = 0; j < grid.size(); j += 1) {\\n            ans = max(ans,dfs(grid,j,0,-1));\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int dfs(vector<vector<int>> &v,int i,int j,int prev) {\\n        if(i < 0 || i >= v.size() || j >= v[0].size() || v[i][j] <= prev) return -1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = max({1 + dfs(v,i - 1,j + 1,v[i][j]),1 + dfs(v,i,j + 1,v[i][j]), 1 + dfs(v,i + 1,j + 1,v[i][j])});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int j = 0; j < grid.size(); j += 1) {\\n            ans = max(ans,dfs(grid,j,0,-1));\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521894,
                "title": "c-dfs-without-dp-easy",
                "content": "```\\nclass Solution {\\n    int dfs(int n, int m, vector<vector<int>>& grid, int i, int j, int prev) {\\n        if(i < 0 or j < 0 or i >= n or j >= m or grid[i][j] <= prev)return 0;\\n        \\n        int val = grid[i][j];\\n        grid[i][j] = 0;\\n        \\n        int ans = max({dfs(n,m,grid,i-1,j+1,val), dfs(n,m,grid,i,j+1,val),dfs(n,m,grid,i+1,j+1,val)}) + 1;\\n        \\n        return ans;\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = size(grid), m = size(grid[0]), res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            res = max(res,dfs(n,m,grid,i,0,-1e6));\\n        }\\n        \\n        return res - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int n, int m, vector<vector<int>>& grid, int i, int j, int prev) {\\n        if(i < 0 or j < 0 or i >= n or j >= m or grid[i][j] <= prev)return 0;\\n        \\n        int val = grid[i][j];\\n        grid[i][j] = 0;\\n        \\n        int ans = max({dfs(n,m,grid,i-1,j+1,val), dfs(n,m,grid,i,j+1,val),dfs(n,m,grid,i+1,j+1,val)}) + 1;\\n        \\n        return ans;\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = size(grid), m = size(grid[0]), res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            res = max(res,dfs(n,m,grid,i,0,-1e6));\\n        }\\n        \\n        return res - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521891,
                "title": "multiple-approaches-bfs-dp-memo-explained-explore-all-possibility-and-take-max",
                "content": "**IMPORTANT**\\nYou can watch the biggest sliding window series on entire internet and backtracking just using single template by clicking my profile icon and checking my youtube channel link from the bio. ( I bet you can solve any sliding window question on leetcode after watching the series do share you thoughts on the same.)\\nThankyou and happy leetcoding.\\n\\nFor below solution if there is doubt let me know.\\n\\n**NOTE:** It is very general question that is asked very often just remember one thing that if you have many options to go just think dp (recursion will give TLE , you have to memoise it) that you can explore all the paths and whatever is asked just return with that like here maximum so return max(op1,op2,...) and with BFS also you can do same just push all the possible (row,col) index to queue so that you will process it of this and always update maximum value.\\n\\n**Approach 1: BFS**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n         int m = grid.size();\\n    int n = grid[0].size();\\n    int mx = 0;\\n\\n    vector<vector<int>> dp(m,vector<int>(n, 0));  // for storing moves at each (row,col) if calculated so that no need to calculate again\\n    queue<pair<int, int>> q;\\n\\n    // Start BFS from cells in the first column\\n    for (int i = 0; i < m; i++) {\\n        q.push(make_pair(i, 0));         \\n        dp[i][0] = 1;\\n    }\\n\\n    // Perform BFS\\n    while (!q.empty()) {\\n        int row = q.front().first;\\n        int col = q.front().second;\\n        q.pop();\\n\\n        int moves = dp[row][col];  // if we have already calculated number of moves at this (row,col)\\n        mx = max(mx, moves);\\n\\n        // Check the three possible moves whichever moves is generated maximum is our answer\\n        for (int i = -1; i <= 1; i++) {\\n            int newRow = row + i;       // will generate row-1,row,row+1 (all three possibility)\\n            int newCol = col + 1;       // given in question  for all case its col+1\\n\\n            if (newRow >= 0 && newRow < m && newCol < n && grid[newRow][newCol] > grid[row][col] && dp[newRow][newCol] < moves + 1) {\\n                dp[newRow][newCol] = moves + 1;   // increase the count of moves\\n                q.push({newRow,newCol});          // push this new points in queue may it generate maximum moves \\n            }\\n        }\\n    }\\n\\n    return mx-1;\\n}\\n\\n};\\n```\\n\\n**Approach 2: DP (memo)**\\n\\n* Ask yourself a question that how many options are there to move from first column of each cell\\n* 3 Right, so just explore all these path by taking maximum as moves by adding 1 to each options\\n* Just make sure that before calling these option check its bound that is it feasible to call.\\n* All done you have got the answer.\\n\\n```\\n  int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n       \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int op1 = 0, op2 = 0, op3 = 0;\\n        if(i>=1 and j<m-1 and grid[i][j] < grid[i - 1][j + 1]) op1 = 1 + dfs(i - 1, j + 1, n, m, grid, dp);\\n        if(j<m-1 and grid[i][j] < grid[i][j + 1]) op2 = 1 + dfs(i, j + 1, n, m, grid, dp);\\n        if(i<n-1 and j<m-1 and grid[i][j] < grid[i + 1][j + 1]) op3 = 1 + dfs(i + 1, j + 1, n, m, grid, dp);\\n    \\n        return dp[i][j] = max({op1, op2, op3});\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        \\n        for(int j=0; j<n; j++) {  // because given that we can start to any cell in first column\\n            ans = max(ans, dfs(j, 0, n, m, grid, dp)); // so take max of all those cell from 1st column\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n         int m = grid.size();\\n    int n = grid[0].size();\\n    int mx = 0;\\n\\n    vector<vector<int>> dp(m,vector<int>(n, 0));  // for storing moves at each (row,col) if calculated so that no need to calculate again\\n    queue<pair<int, int>> q;\\n\\n    // Start BFS from cells in the first column\\n    for (int i = 0; i < m; i++) {\\n        q.push(make_pair(i, 0));         \\n        dp[i][0] = 1;\\n    }\\n\\n    // Perform BFS\\n    while (!q.empty()) {\\n        int row = q.front().first;\\n        int col = q.front().second;\\n        q.pop();\\n\\n        int moves = dp[row][col];  // if we have already calculated number of moves at this (row,col)\\n        mx = max(mx, moves);\\n\\n        // Check the three possible moves whichever moves is generated maximum is our answer\\n        for (int i = -1; i <= 1; i++) {\\n            int newRow = row + i;       // will generate row-1,row,row+1 (all three possibility)\\n            int newCol = col + 1;       // given in question  for all case its col+1\\n\\n            if (newRow >= 0 && newRow < m && newCol < n && grid[newRow][newCol] > grid[row][col] && dp[newRow][newCol] < moves + 1) {\\n                dp[newRow][newCol] = moves + 1;   // increase the count of moves\\n                q.push({newRow,newCol});          // push this new points in queue may it generate maximum moves \\n            }\\n        }\\n    }\\n\\n    return mx-1;\\n}\\n\\n};\\n```\n```\\n  int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n       \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int op1 = 0, op2 = 0, op3 = 0;\\n        if(i>=1 and j<m-1 and grid[i][j] < grid[i - 1][j + 1]) op1 = 1 + dfs(i - 1, j + 1, n, m, grid, dp);\\n        if(j<m-1 and grid[i][j] < grid[i][j + 1]) op2 = 1 + dfs(i, j + 1, n, m, grid, dp);\\n        if(i<n-1 and j<m-1 and grid[i][j] < grid[i + 1][j + 1]) op3 = 1 + dfs(i + 1, j + 1, n, m, grid, dp);\\n    \\n        return dp[i][j] = max({op1, op2, op3});\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        \\n        for(int j=0; j<n; j++) {  // because given that we can start to any cell in first column\\n            ans = max(ans, dfs(j, 0, n, m, grid, dp)); // so take max of all those cell from 1st column\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521875,
                "title": "just-bfs",
                "content": "# Intuition\\nJust BFS\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n\\nO(n * m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        vector<vector<bool>> mark(2, vector<bool>(m));\\n        mark[0] = vector<bool>(m, true);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            const int now = last ^ 1;\\n            mark[now] = vector<bool>(m);\\n            bool can = false;\\n            for (int j = 0; j < m; ++j) {\\n                mark[now][j] = (mark[last][j] && grid[j][i] > grid[j][i - 1]) \\n                    || (j && mark[last][j - 1] && grid[j][i] > grid[j - 1][i - 1])\\n                    || (j + 1 < m && mark[last][j + 1] && grid[j][i] > grid[j + 1][i - 1]);\\n                can = can || mark[now][j];\\n            }\\n            if (!can) {\\n                return i - 1;\\n            }\\n            last = now;\\n        }\\n        return n - 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        vector<vector<bool>> mark(2, vector<bool>(m));\\n        mark[0] = vector<bool>(m, true);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            const int now = last ^ 1;\\n            mark[now] = vector<bool>(m);\\n            bool can = false;\\n            for (int j = 0; j < m; ++j) {\\n                mark[now][j] = (mark[last][j] && grid[j][i] > grid[j][i - 1]) \\n                    || (j && mark[last][j - 1] && grid[j][i] > grid[j - 1][i - 1])\\n                    || (j + 1 < m && mark[last][j + 1] && grid[j][i] > grid[j + 1][i - 1]);\\n                can = can || mark[now][j];\\n            }\\n            if (!can) {\\n                return i - 1;\\n            }\\n            last = now;\\n        }\\n        return n - 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522762,
                "title": "simple-java-bottom-up-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor each of the cell, it will only be possible coming from 3 nearby cell in prev column.\\nThe steps of this cell is the max of prev 3 cell\\'s steps + 1;\\nPlease note, if none of the prev cell can be reachable, this cell is not reachable either.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M * N);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M * N);\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, res = 0;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (i - 1 >= 0 && grid[i - 1][j - 1] < grid[i][j]) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1]);\\n                if (grid[i][j - 1] < grid[i][j]) dp[i][j] = Math.max(dp[i][j],  dp[i][j - 1]);\\n                if (i + 1 < m && grid[i + 1][j - 1] < grid[i][j]) dp[i][j] = Math.max(dp[i][j],  dp[i + 1][j - 1]);\\n                if (dp[i][j] > 0) dp[i][j]++;\\n                res = Math.max(res, dp[i][j] - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, res = 0;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (i - 1 >= 0 && grid[i - 1][j - 1] < grid[i][j]) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1]);\\n                if (grid[i][j - 1] < grid[i][j]) dp[i][j] = Math.max(dp[i][j],  dp[i][j - 1]);\\n                if (i + 1 < m && grid[i + 1][j - 1] < grid[i][j]) dp[i][j] = Math.max(dp[i][j],  dp[i + 1][j - 1]);\\n                if (dp[i][j] > 0) dp[i][j]++;\\n                res = Math.max(res, dp[i][j] - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522614,
                "title": "dp-optimised-c-simple-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &m,int &n,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        if(i<0||j<0||i>=m||j>=n)return 0;\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int a=0,b=0,c=0;\\n        if(i-1>=0 && j+1<n&&grid[i-1][j+1]>grid[i][j]){\\n            a = solve(i-1,j+1,m,n,grid,dp);\\n        }\\n        if(i+1<m && j+1<n&&grid[i+1][j+1]>grid[i][j]){\\n            b = solve(i+1,j+1,m,n,grid,dp);\\n        }\\n        if(j+1<n&&grid[i][j+1]>grid[i][j]){\\n            c = solve(i,j+1,m,n,grid,dp);\\n        }\\n        return dp[i][j] = max({a,b,c})+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size(),i,j,ans=0;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n                if(dp[i][0]==-1){\\n                    ans = max(ans,solve(i,0,m,n,grid,dp));\\n                }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &m,int &n,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        if(i<0||j<0||i>=m||j>=n)return 0;\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int a=0,b=0,c=0;\\n        if(i-1>=0 && j+1<n&&grid[i-1][j+1]>grid[i][j]){\\n            a = solve(i-1,j+1,m,n,grid,dp);\\n        }\\n        if(i+1<m && j+1<n&&grid[i+1][j+1]>grid[i][j]){\\n            b = solve(i+1,j+1,m,n,grid,dp);\\n        }\\n        if(j+1<n&&grid[i][j+1]>grid[i][j]){\\n            c = solve(i,j+1,m,n,grid,dp);\\n        }\\n        return dp[i][j] = max({a,b,c})+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size(),i,j,ans=0;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n                if(dp[i][0]==-1){\\n                    ans = max(ans,solve(i,0,m,n,grid,dp));\\n                }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522137,
                "title": "python-3-simple-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\\n            res = 0 \\n            cur = grid[i][j]\\n            for x, y in [(-1, 1), (0, 1), (1, 1)]:\\n                if 0 <= i + x < m and 0 <= j + y < n and grid[i + x][j + y] > cur:\\n                    res = max(res, dp(i + x, j + y) + 1)\\n            return res\\n        ans = 0\\n        for i in range(m):\\n            ans = max(ans, dp(i, 0))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\\n            res = 0 \\n            cur = grid[i][j]\\n            for x, y in [(-1, 1), (0, 1), (1, 1)]:\\n                if 0 <= i + x < m and 0 <= j + y < n and grid[i + x][j + y] > cur:\\n                    res = max(res, dp(i + x, j + y) + 1)\\n            return res\\n        ans = 0\\n        for i in range(m):\\n            ans = max(ans, dp(i, 0))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522069,
                "title": "dp",
                "content": "We only need the previous state, so we can limit the size of our `dp` array to `2 * m`.\\n\\n**C++**\\n```cpp\\nint maxMoves(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> dp(2, vector<int>(m));\\n    for (int c = n - 2; c >= 0; --c)\\n        for (int r = 0; r < m; ++r) {\\n            int c0 = c % 2, c1 = (c + 1) % 2;\\n            dp[c0][r] = g[r][c + 1] > g[r][c] ? 1 + dp[c1][r] : 0;\\n            if (r > 0 && g[r - 1][c + 1] > g[r][c])\\n                dp[c0][r] = max(dp[c0][r], 1 + dp[c1][r - 1]);\\n            if (r + 1 < m && g[r + 1][c + 1] > g[r][c])\\n                dp[c0][r] = max(dp[c0][r], 1 + dp[c1][r + 1]);\\n        }\\n    return *max_element(begin(dp[0]), end(dp[0]));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maxMoves(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> dp(2, vector<int>(m));\\n    for (int c = n - 2; c >= 0; --c)\\n        for (int r = 0; r < m; ++r) {\\n            int c0 = c % 2, c1 = (c + 1) % 2;\\n            dp[c0][r] = g[r][c + 1] > g[r][c] ? 1 + dp[c1][r] : 0;\\n            if (r > 0 && g[r - 1][c + 1] > g[r][c])\\n                dp[c0][r] = max(dp[c0][r], 1 + dp[c1][r - 1]);\\n            if (r + 1 < m && g[r + 1][c + 1] > g[r][c])\\n                dp[c0][r] = max(dp[c0][r], 1 + dp[c1][r + 1]);\\n        }\\n    return *max_element(begin(dp[0]), end(dp[0]));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981123,
                "title": "simple-dp-recursion-memoization-easy-to-understand-for-beginners",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**So, approach will be, we will traverse column 0 by running loop from 0 to n and for every loop we will recursively call for (i+1, j+1), (i, j+1), (i-1, j+1) and at the end we will take maximum of all and return the ans.\\n\\nplease upvote if you liked it**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (i<0 || i==grid.size() || j==grid[0].size()) return 0;\\n\\n        if (dp[i][j]!=-1) return dp[i][j];\\n\\n        int a=0, b=0, c=0;\\n\\n        if (i+1<grid.size() && j+1<grid[0].size() && grid[i][j]<grid[i+1][j+1]) {\\n            a=1+f(i+1, j+1, grid, dp);\\n        } \\n        if (i<grid.size() && j+1<grid[0].size() && grid[i][j]<grid[i][j+1]) {\\n            b=1+f(i, j+1, grid, dp);\\n        }\\n        if (i-1>=0 && j+1<grid[0].size() && grid[i][j]<grid[i-1][j+1]) {\\n            c=1+f(i-1, j+1, grid, dp);\\n        }\\n\\n        return dp[i][j]=max({a, b, c});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n\\n        int ans=0;\\n\\n        for (int i=0; i<n; i++) {\\n            ans=max(ans, f(i, 0, grid, dp));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (i<0 || i==grid.size() || j==grid[0].size()) return 0;\\n\\n        if (dp[i][j]!=-1) return dp[i][j];\\n\\n        int a=0, b=0, c=0;\\n\\n        if (i+1<grid.size() && j+1<grid[0].size() && grid[i][j]<grid[i+1][j+1]) {\\n            a=1+f(i+1, j+1, grid, dp);\\n        } \\n        if (i<grid.size() && j+1<grid[0].size() && grid[i][j]<grid[i][j+1]) {\\n            b=1+f(i, j+1, grid, dp);\\n        }\\n        if (i-1>=0 && j+1<grid[0].size() && grid[i][j]<grid[i-1][j+1]) {\\n            c=1+f(i-1, j+1, grid, dp);\\n        }\\n\\n        return dp[i][j]=max({a, b, c});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n\\n        int ans=0;\\n\\n        for (int i=0; i<n; i++) {\\n            ans=max(ans, f(i, 0, grid, dp));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535902,
                "title": "python-3-11-lines-w-explanation-t-m-100-84",
                "content": "Here\\'s the plan:\\n1. We pad the top and bottom of the grid with rows of`inf` to avoid having to test whether we remain in the grid.\\n1. We start in the 2nd column (1-indexed) and look back to the 1st column and iterate by cell down the column. We repat this iteration left-to-right.\\n1. For each cell in the column, we check the`min`of three cells in the previous column that could move to that cell. If`min` is not greater than the  cell\\'s value, then that cell cannot be visited, and we change the cell\\'s value to`inf`.\\n1. When we either reach the last column of`grid` or we have a column in which every cell has value`inf`, we return the last visited column.\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        m, n  = len(grid)+2, len(grid[0])\\n        grid =[[inf]*n]+grid+[[inf]*n]\\n       \\n        for j in range(1,n):\\n            found = False\\n            for i in range(1, m-1):\\n\\n                if grid[i][j] <= min(grid[i-1][j-1],\\n                                     grid[i  ][j-1],\\n                                     grid[i+1][j-1]): grid[i][j] = inf\\n                \\n                else: found = True\\n       \\n            if not found: break\\n            \\n        else: return n-1\\n\\n        return j-1\\n```\\n[https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/952270062/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        m, n  = len(grid)+2, len(grid[0])\\n        grid =[[inf]*n]+grid+[[inf]*n]\\n       \\n        for j in range(1,n):\\n            found = False\\n            for i in range(1, m-1):\\n\\n                if grid[i][j] <= min(grid[i-1][j-1],\\n                                     grid[i  ][j-1],\\n                                     grid[i+1][j-1]): grid[i][j] = inf\\n                \\n                else: found = True\\n       \\n            if not found: break\\n            \\n        else: return n-1\\n\\n        return j-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535398,
                "title": "python-simple-and-clean-beats-79-75",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nThe problem asks us to find the maximum number of moves that can be performed in a grid by starting at any cell in the first column and moving to cells that have strictly bigger values than the current cell. Our first thought might be to try all possible starting cells and find the maximum number of moves for each one. However, this approach would be inefficient as it would require us to traverse the entire grid for each starting cell.\\n\\n# Approach\\nA more efficient approach would be to use `Depth First Search (DFS)` to traverse the grid and find the maximum number of moves for each starting cell. We can start at any cell in the `first column` and move to any of the cells: `(row - 1, col + 1), (row, col + 1) and (row + 1, col + 1)` such that the value of the cell we move to is `strictly bigger than the value of the current cell`. We can use a recursive function `dfs(i,j)` that takes as input the current cell `(i,j)` and returns the maximum number of moves that can be performed starting from this cell. We can use memoization to avoid recomputing the same subproblems multiple times.\\n\\nHere is an outline of our approach:\\n\\n1. Initialize `n`, `m`, and `dirs` with the dimensions of the grid and the possible directions of movement.\\n\\n1. Define a recursive function `dfs(i,j)` that takes as input the current cell `(i,j)` and returns the maximum number of moves that can be performed starting from this cell.\\n\\n1. Use a loop to iterate over all possible directions of movement.\\n\\n1. For each direction, compute the new cell (new_i,new_j) and check if it is within the bounds of the grid and if its value is strictly bigger than the value of the current cell.\\n\\n1. If these conditions are satisfied, update moves with the maximum value between its current value and `1+dfs(new_i,new_j)`.\\n\\n1. Return `moves`.\\n\\n1. Call `dfs(i,0)` for all cells in the first column and return their maximum value.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        n, m, dirs = len(grid), len(grid[0]), [(0,1),(1,1),(-1,1)]\\n        @cache\\n        def dfs(i,j):\\n            moves = 0\\n            for x,y in dirs:\\n                new_i, new_j = i+x, j+y\\n                if 0<=new_i<n and new_j<m and grid[i][j]<grid[new_i][new_j]:\\n                    moves = max(moves,1+dfs(new_i,new_j))\\n            return moves\\n        return max(dfs(i,0) for i in range(n))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        n, m, dirs = len(grid), len(grid[0]), [(0,1),(1,1),(-1,1)]\\n        @cache\\n        def dfs(i,j):\\n            moves = 0\\n            for x,y in dirs:\\n                new_i, new_j = i+x, j+y\\n                if 0<=new_i<n and new_j<m and grid[i][j]<grid[new_i][new_j]:\\n                    moves = max(moves,1+dfs(new_i,new_j))\\n            return moves\\n        return max(dfs(i,0) for i in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530137,
                "title": "easy-dfs-solution-c-self-explanatory",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int prev,vector<vector<int>>& grid)\\n    {\\n        if(i<0 || i==grid.size() || j==grid[0].size() || prev>=grid[i][j]) return 0;\\n        prev=grid[i][j];\\n        grid[i][j]=0;\\n        int res=max(max(dfs(i-1,j+1,prev,grid),dfs(i,j+1,prev,grid)),dfs(i+1,j+1,prev,grid));\\n        return res+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) ans=max(ans,dfs(i,0,0,grid));\\n        return ans-1;\\n    }\\n};\\n```\\n\\nPlease Upvote \\uD83E\\uDD7A\\uD83D\\uDE4F",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int prev,vector<vector<int>>& grid)\\n    {\\n        if(i<0 || i==grid.size() || j==grid[0].size() || prev>=grid[i][j]) return 0;\\n        prev=grid[i][j];\\n        grid[i][j]=0;\\n        int res=max(max(dfs(i-1,j+1,prev,grid),dfs(i,j+1,prev,grid)),dfs(i+1,j+1,prev,grid));\\n        return res+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) ans=max(ans,dfs(i,0,0,grid));\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528133,
                "title": "simple-dp-dfs-based-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int maxi = 0;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0 ; i<m ; i++) {\\n            int cnt = dfs(i,0,grid,dp);\\n            if(cnt > maxi) maxi = cnt;\\n            cnt = 0;\\n        }\\n        return maxi;\\n    }\\n    \\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int c1=0 , c2=0 , c3=0;\\n\\n        if(isValid(i-1,j+1,grid[i][j],grid)) c1 = 1 + dfs(i-1,j+1,grid,dp);\\n        if(isValid(i,j+1,grid[i][j],grid))   c2 = 1 + dfs(i,j+1,grid,dp);\\n        if(isValid(i+1,j+1,grid[i][j],grid)) c3 = 1 + dfs(i+1,j+1,grid,dp);\\n\\n        return dp[i][j]=max({c1,c2,c3});\\n    }\\n\\n    bool isValid(int i, int j, int curr, vector<vector<int>> &grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]<=curr) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int maxi = 0;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0 ; i<m ; i++) {\\n            int cnt = dfs(i,0,grid,dp);\\n            if(cnt > maxi) maxi = cnt;\\n            cnt = 0;\\n        }\\n        return maxi;\\n    }\\n    \\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int c1=0 , c2=0 , c3=0;\\n\\n        if(isValid(i-1,j+1,grid[i][j],grid)) c1 = 1 + dfs(i-1,j+1,grid,dp);\\n        if(isValid(i,j+1,grid[i][j],grid))   c2 = 1 + dfs(i,j+1,grid,dp);\\n        if(isValid(i+1,j+1,grid[i][j],grid)) c3 = 1 + dfs(i+1,j+1,grid,dp);\\n\\n        return dp[i][j]=max({c1,c2,c3});\\n    }\\n\\n    bool isValid(int i, int j, int curr, vector<vector<int>> &grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]<=curr) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522317,
                "title": "easy-dp-solution-in-c-using-2d-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     int solve(vector<vector<int>>& grid, int i, int j, int prev, vector<vector<int>> &dp) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (i < 0 || i >= n || j < 0 || j >= m) {\\n        return 0;\\n    }\\n    if (prev >= grid[i][j]) {\\n        return 0;\\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n    int op1 = solve(grid, i - 1, j + 1, grid[i][j], dp);\\n    int op2 = solve(grid, i, j + 1, grid[i][j], dp);\\n    int op3 = solve(grid, i + 1, j + 1, grid[i][j], dp);\\n\\n    return dp[i][j] = 1 + max({op1, op2, op3});\\n}\\n\\nint maxMoves(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    vector<vector<int>> dp(n , vector<int>(m , -1));\\n    for (int i = 0; i < n; i++) {\\n        int temp = solve(grid, i, 0, 0, dp);\\n        ans = max(ans, temp);\\n    }\\n\\n    return ans - 1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve(vector<vector<int>>& grid, int i, int j, int prev, vector<vector<int>> &dp) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (i < 0 || i >= n || j < 0 || j >= m) {\\n        return 0;\\n    }\\n    if (prev >= grid[i][j]) {\\n        return 0;\\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n    int op1 = solve(grid, i - 1, j + 1, grid[i][j], dp);\\n    int op2 = solve(grid, i, j + 1, grid[i][j], dp);\\n    int op3 = solve(grid, i + 1, j + 1, grid[i][j], dp);\\n\\n    return dp[i][j] = 1 + max({op1, op2, op3});\\n}\\n\\nint maxMoves(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    vector<vector<int>> dp(n , vector<int>(m , -1));\\n    for (int i = 0; i < n; i++) {\\n        int temp = solve(grid, i, 0, 0, dp);\\n        ans = max(ans, temp);\\n    }\\n\\n    return ans - 1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521970,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int a = 0, b = 0, c = 0;\\n        if(i - 1 >= 0 && j + 1 < m && grid[i][j] < grid[i - 1][j + 1]) a = 1 + dfs(i - 1, j + 1, n, m, grid, dp);\\n        if(j + 1 < m && grid[i][j] < grid[i][j + 1]) b = 1 + dfs(i, j + 1, n, m, grid, dp);\\n        if(i + 1 < n && j + 1 < m && grid[i][j] < grid[i + 1][j + 1]) c = 1 + dfs(i + 1, j + 1, n, m, grid, dp);\\n    \\n        return dp[i][j] = max({a, b, c});\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        \\n        for(int j=0; j<n; j++) {\\n            ans = max(ans, dfs(j, 0, n, m, grid, dp));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int a = 0, b = 0, c = 0;\\n        if(i - 1 >= 0 && j + 1 < m && grid[i][j] < grid[i - 1][j + 1]) a = 1 + dfs(i - 1, j + 1, n, m, grid, dp);\\n        if(j + 1 < m && grid[i][j] < grid[i][j + 1]) b = 1 + dfs(i, j + 1, n, m, grid, dp);\\n        if(i + 1 < n && j + 1 < m && grid[i][j] < grid[i + 1][j + 1]) c = 1 + dfs(i + 1, j + 1, n, m, grid, dp);\\n    \\n        return dp[i][j] = max({a, b, c});\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        \\n        for(int j=0; j<n; j++) {\\n            ans = max(ans, dfs(j, 0, n, m, grid, dp));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521866,
                "title": "java-dfs-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int[][] dp;\\n  int[] dirs = new int[] {-1, 0, 1};\\n  int m, n, max = 0;\\n  \\n  private int maxMoves(int[][] grid, int x, int y) {\\n    if (y == n-1) return 0;\\n    \\n    if (dp[x][y] != -1) return dp[x][y];\\n    \\n    dp[x][y] = 0;\\n    for (var dir : dirs) {\\n      var x2 = x + dir;\\n      if (x2 < 0 || x2 == m) continue;\\n      \\n      if (grid[x2][y+1] > grid[x][y])\\n        dp[x][y] = Math.max(dp[x][y], 1 + maxMoves(grid, x2, y+1));\\n    }\\n    return dp[x][y];\\n  }\\n  \\n  public int maxMoves(int[][] grid) {\\n    m = grid.length;\\n    n = grid[0].length;\\n    \\n    dp = new int[m][n];\\n    for (var row : dp)\\n      Arrays.fill(row, -1);\\n    \\n    for (var i=0; i<m; i++)\\n      max = Math.max(max, maxMoves(grid, i, 0));\\n  \\n    return max;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  int[][] dp;\\n  int[] dirs = new int[] {-1, 0, 1};\\n  int m, n, max = 0;\\n  \\n  private int maxMoves(int[][] grid, int x, int y) {\\n    if (y == n-1) return 0;\\n    \\n    if (dp[x][y] != -1) return dp[x][y];\\n    \\n    dp[x][y] = 0;\\n    for (var dir : dirs) {\\n      var x2 = x + dir;\\n      if (x2 < 0 || x2 == m) continue;\\n      \\n      if (grid[x2][y+1] > grid[x][y])\\n        dp[x][y] = Math.max(dp[x][y], 1 + maxMoves(grid, x2, y+1));\\n    }\\n    return dp[x][y];\\n  }\\n  \\n  public int maxMoves(int[][] grid) {\\n    m = grid.length;\\n    n = grid[0].length;\\n    \\n    dp = new int[m][n];\\n    for (var row : dp)\\n      Arrays.fill(row, -1);\\n    \\n    for (var i=0; i<m; i++)\\n      max = Math.max(max, maxMoves(grid, i, 0));\\n  \\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543363,
                "title": "java-recursion-memo-top-down-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[][] grid;\\n    Integer[][] dp;\\n    public int maxMoves(int[][] grid) {\\n        this.grid = grid;\\n        this.dp = new Integer[grid.length + 1][grid[0].length + 1];\\n        int max = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            max = Math.max(max, helper(i, 0, -1) - 1);\\n        }\\n        return max;\\n    }\\n    public int helper(int i, int j, int prev) {\\n        if(i == grid.length || i < 0 || j == grid[i].length || grid[i][j] <= prev) return 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        int left = 1 + helper(i, j + 1, grid[i][j]);\\n        int Ddown = 1 + helper(i + 1, j + 1, grid[i][j]);\\n        int Dup = 1 + helper(i - 1, j + 1, grid[i][j]);\\n        return dp[i][j] = Math.max(left, Math.max(Ddown, Dup));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    Integer[][] dp;\\n    public int maxMoves(int[][] grid) {\\n        this.grid = grid;\\n        this.dp = new Integer[grid.length + 1][grid[0].length + 1];\\n        int max = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            max = Math.max(max, helper(i, 0, -1) - 1);\\n        }\\n        return max;\\n    }\\n    public int helper(int i, int j, int prev) {\\n        if(i == grid.length || i < 0 || j == grid[i].length || grid[i][j] <= prev) return 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        int left = 1 + helper(i, j + 1, grid[i][j]);\\n        int Ddown = 1 + helper(i + 1, j + 1, grid[i][j]);\\n        int Dup = 1 + helper(i - 1, j + 1, grid[i][j]);\\n        return dp[i][j] = Math.max(left, Math.max(Ddown, Dup));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531415,
                "title": "easy-dynamic-programming-memoization",
                "content": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def helper(row,col) :\\n            \\n            if row < 0 or row >= m or col >= n:\\n                return 0\\n            \\n            if dp[row][col] != -1:\\n                return dp[row][col]\\n            \\n            directions = [(row - 1, col + 1), (row, col + 1), (row + 1, col + 1) ]\\n            \\n            max_moves = 0\\n            \\n            for x,y in directions :\\n                \\n                if x>=0 and x < m and (y < n) and grid[x][y] > grid[row][col] :\\n                    \\n                    if dp[x][y] != -1:\\n                        max_moves = max(max_moves , 1+dp[x][y])\\n                        \\n                    else :\\n                        max_moves = max(max_moves , 1+helper(x,y))\\n                        \\n            dp[row][col] = max_moves\\n            return dp[row][col]\\n        \\n        \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        ans = 0\\n        \\n        dp = [[-1 for i in range(n)]for j in range(m)]\\n\\n        dp[m-1][n-1] = 0\\n        \\n        for i in range(m):\\n            ans = max(ans , helper(i,0))\\n            \\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def helper(row,col) :\\n            \\n            if row < 0 or row >= m or col >= n:\\n                return 0\\n            \\n            if dp[row][col] != -1:\\n                return dp[row][col]\\n            \\n            directions = [(row - 1, col + 1), (row, col + 1), (row + 1, col + 1) ]\\n            \\n            max_moves = 0\\n            \\n            for x,y in directions :\\n                \\n                if x>=0 and x < m and (y < n) and grid[x][y] > grid[row][col] :\\n                    \\n                    if dp[x][y] != -1:\\n                        max_moves = max(max_moves , 1+dp[x][y])\\n                        \\n                    else :\\n                        max_moves = max(max_moves , 1+helper(x,y))\\n                        \\n            dp[row][col] = max_moves\\n            return dp[row][col]\\n        \\n        \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        ans = 0\\n        \\n        dp = [[-1 for i in range(n)]for j in range(m)]\\n\\n        dp[m-1][n-1] = 0\\n        \\n        for i in range(m):\\n            ans = max(ans , helper(i,0))\\n            \\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523089,
                "title": "easy-java-begineer-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans=0;\\n    public int maxMoves(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n            for(int i=0;i<m;i++){\\n                boolean visited[][]=new boolean[m][n];\\n                int max=0;\\n                max=count(i,0,grid,visited,m,n);\\n                ans=Math.max(ans,max);\\n            }\\n        return ans;\\n    }\\n    public int count(int row,int col,int grid[][],boolean visited[][],int m,int n){\\n        if(visited[row][col]==true)return 0;\\n        visited[row][col]=true;\\n        int op1=0;\\n        if(row-1>=0 && col+1<n){\\n            if(grid[row-1][col+1]>grid[row][col]){\\n                op1=1+count(row-1,col+1,grid,visited,m,n);\\n            }\\n        }\\n        int op2=0;\\n        if(row<m && col+1<n){\\n            if(grid[row][col+1]>grid[row][col]){\\n                op2=1+count(row,col+1,grid,visited,m,n);\\n            }\\n        }\\n        int op3=0;\\n        if(row+1<m && col+1<n){\\n            if(grid[row+1][col+1]>grid[row][col]){\\n                op3=1+count(row+1,col+1,grid,visited,m,n);\\n            }\\n        }\\n        return Math.max(op1,Math.max(op2,op3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int maxMoves(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n            for(int i=0;i<m;i++){\\n                boolean visited[][]=new boolean[m][n];\\n                int max=0;\\n                max=count(i,0,grid,visited,m,n);\\n                ans=Math.max(ans,max);\\n            }\\n        return ans;\\n    }\\n    public int count(int row,int col,int grid[][],boolean visited[][],int m,int n){\\n        if(visited[row][col]==true)return 0;\\n        visited[row][col]=true;\\n        int op1=0;\\n        if(row-1>=0 && col+1<n){\\n            if(grid[row-1][col+1]>grid[row][col]){\\n                op1=1+count(row-1,col+1,grid,visited,m,n);\\n            }\\n        }\\n        int op2=0;\\n        if(row<m && col+1<n){\\n            if(grid[row][col+1]>grid[row][col]){\\n                op2=1+count(row,col+1,grid,visited,m,n);\\n            }\\n        }\\n        int op3=0;\\n        if(row+1<m && col+1<n){\\n            if(grid[row+1][col+1]>grid[row][col]){\\n                op3=1+count(row+1,col+1,grid,visited,m,n);\\n            }\\n        }\\n        return Math.max(op1,Math.max(op2,op3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522450,
                "title": "c-bfs",
                "content": "# Approach\\n\\nPush the whole first column in queue.\\nThen explore as the problem tells to do.\\nDont bother to visit a place again even if it is visited from different point as the number of moves are still the same.\\n# Complexity\\n- Time complexity:\\n$O(mn)$\\n\\n- Space complexity:\\n$O(mn)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int c=0;c<m;c++){\\n            q.push({c,0});\\n        }\\n        int dir[] = {-1,0,1};\\n        vector<vector<int>> visited(m,vector<int>(n,false));\\n        int ans = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz-- > 0){\\n                int r = q.front().first;\\n                int c = q.front().second;\\n                q.pop();\\n                if(visited[r][c]) continue;\\n                visited[r][c] = true;\\n                for(int i=0;i<3;i++){\\n                    int R = r+dir[i];\\n                    if(R>=0 && R<m && c+1<n && grid[R][c+1]>grid[r][c]) q.push({R,c+1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int c=0;c<m;c++){\\n            q.push({c,0});\\n        }\\n        int dir[] = {-1,0,1};\\n        vector<vector<int>> visited(m,vector<int>(n,false));\\n        int ans = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz-- > 0){\\n                int r = q.front().first;\\n                int c = q.front().second;\\n                q.pop();\\n                if(visited[r][c]) continue;\\n                visited[r][c] = true;\\n                for(int i=0;i<3;i++){\\n                    int R = r+dir[i];\\n                    if(R>=0 && R<m && c+1<n && grid[R][c+1]>grid[r][c]) q.push({R,c+1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522318,
                "title": "c-best-solution-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vvi temp(n, vi(m, 0));\\n        for(int i=0; i<n; i++) temp[i][0] = 1;\\n        \\n        for(int i=1; i<m; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                if(grid[j][i] > grid[j][i-1] && temp[j][i-1])   temp[j][i] = 1;\\n                if(j-1 >=0 && grid[j][i] > grid[j-1][i-1] && temp[j-1][i-1])   temp[j][i] = 1;\\n                if(j+1<n && grid[j][i] > grid[j+1][i-1] && temp[j+1][i-1])   temp[j][i] = 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)  {\\n            int cnt = 0;\\n            for(int j=0; j<n; j++)  {\\n                if(temp[j][i] == 1) cnt++;\\n            }\\n            if(cnt == 0)    return i-1;\\n        }\\n        return m-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vvi temp(n, vi(m, 0));\\n        for(int i=0; i<n; i++) temp[i][0] = 1;\\n        \\n        for(int i=1; i<m; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                if(grid[j][i] > grid[j][i-1] && temp[j][i-1])   temp[j][i] = 1;\\n                if(j-1 >=0 && grid[j][i] > grid[j-1][i-1] && temp[j-1][i-1])   temp[j][i] = 1;\\n                if(j+1<n && grid[j][i] > grid[j+1][i-1] && temp[j+1][i-1])   temp[j][i] = 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)  {\\n            int cnt = 0;\\n            for(int j=0; j<n; j++)  {\\n                if(temp[j][i] == 1) cnt++;\\n            }\\n            if(cnt == 0)    return i-1;\\n        }\\n        return m-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522205,
                "title": "python-simple-dynamic-programming",
                "content": "# Intuition\\nlooking at this problem we can say that it can be solved using dynamic programming\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        dp={}\\n        def dfs(i,j):\\n            n=0\\n            n1=0\\n            n2=0\\n            if((i,j) in dp):return dp[(i,j)]\\n            if(i-1>=0 and j+1<len(grid[0]) and grid[i][j]<grid[i-1][j+1]):\\n                n=1+dfs(i-1,j+1)\\n            if(i>=0 and i<len(grid) and j+1<len(grid[0])):\\n                if(i+1<len(grid) and grid[i+1][j+1]>grid[i][j]):\\n                    n1=1+dfs(i+1,j+1)\\n                if(grid[i][j+1]>grid[i][j]):\\n                    n2=1+dfs(i,j+1)\\n            dp[(i,j)]=max(n,n1,n2)\\n            return dp[(i,j)]\\n        res=0\\n        for i in range(len(grid)):\\n            res=max(res,dfs(i,0))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        dp={}\\n        def dfs(i,j):\\n            n=0\\n            n1=0\\n            n2=0\\n            if((i,j) in dp):return dp[(i,j)]\\n            if(i-1>=0 and j+1<len(grid[0]) and grid[i][j]<grid[i-1][j+1]):\\n                n=1+dfs(i-1,j+1)\\n            if(i>=0 and i<len(grid) and j+1<len(grid[0])):\\n                if(i+1<len(grid) and grid[i+1][j+1]>grid[i][j]):\\n                    n1=1+dfs(i+1,j+1)\\n                if(grid[i][j+1]>grid[i][j]):\\n                    n2=1+dfs(i,j+1)\\n            dp[(i,j)]=max(n,n1,n2)\\n            return dp[(i,j)]\\n        res=0\\n        for i in range(len(grid)):\\n            res=max(res,dfs(i,0))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522198,
                "title": "c-solution-dp-recursion-memoization-dp",
                "content": "**C++:**\\n\\n**1). Recursion will give TLE :**\\n```\\nclass Solution {\\npublic:\\n    int helper(int n, int m, int row, int col, int val, vector<vector<int>>& grid) {\\n\\t\\n\\t\\t//base case\\n        if (col == m - 1) {\\n            return 0;\\n        }\\n        \\n        int rightupp = 0;\\n        int right = 0;\\n        int rightlow = 0;\\n\\t\\t\\n\\t\\t//condition check and recursion call with adding 1\\n        if (row - 1 >= 0 && col + 1 < m && val < grid[row-1][col+1]) {\\n            rightupp = 1 + helper(n, m, row-1, col+1, grid[row-1][col+1], grid);\\n        }\\n        if (row < n && col + 1 < m && val < grid[row][col+1]) {\\n            right = 1 + helper(n, m, row, col+1, grid[row][col+1], grid);\\n        }\\n        if (row + 1 < n && col + 1 < m && val < grid[row+1][col+1]) {\\n            rightlow = 1 + helper(n, m, row+1, col+1, grid[row+1][col+1], grid);\\n        }\\n        \\n\\t\\t//return answer\\n        return max(rightupp, max(right, rightlow));\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n\\t\\t\\n\\t\\t//checking for every starting position in first column\\n        for (int i = 0; i < n; i++) {\\n            maxi = max(maxi, helper(n, m, i, 0, grid[i][0], grid));\\n        }\\n\\t\\t\\n        return maxi;\\n    }\\n};\\n```\\n\\n**2). Memoization will give TLE :**\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(int n,int m,int row,int col,int val,vector<vector<int>>& grid,vector<vector<int>> &dp){        \\n        if(row<n && col==m-1){\\n            return 0;\\n        }     \\n\\t\\t\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        \\n        int rightupp=0;\\n        int right=0;\\n        int rightlow=0;\\n        if(row-1>=0 && col+1<m && val<grid[row-1][col+1]){\\n            rightupp=1+helper(n,m,row-1,col+1,grid[row-1][col+1],grid,dp);\\n        }\\n        if(row<n && col+1<m && val<grid[row][col+1]){\\n            right=1+helper(n,m,row,col+1,grid[row][col+1],grid,dp);\\n        }\\n        if(row+1<n && col+1<m && val<grid[row+1][col+1]){\\n            rightlow=1+helper(n,m,row+1,col+1,grid[row+1][col+1],grid,dp);\\n        }\\n\\t\\t\\n        return dp[row][col]=max(rightupp,max(right,rightlow));\\n        \\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n\\t\\t\\n\\t\\t//memoization vector \\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n\\t\\n        for(int i=0;i<n;i++){\\n           maxi=max(maxi, helper(n,m,i,0,grid[i][0],grid,dp));\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n**3). DP will get accepted :**\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][m-1] = 0;\\n        }\\n        \\n        for (int j = m-2; j >= 0; j--) {\\n            for (int i = 0; i < n; i++) {\\n                int rightupp = 0, right = 0, rightlow = 0;\\n                int val = grid[i][j];\\n                if (i-1 >= 0 && j+1 < m && val < grid[i-1][j+1]) {\\n                    rightupp = 1 + dp[i-1][j+1];\\n                }\\n                if (j+1 < m && val < grid[i][j+1]) {\\n                    right = 1 + dp[i][j+1];\\n                }\\n                if (i+1 < n && j+1 < m && val < grid[i+1][j+1]) {\\n                    rightlow = 1 + dp[i+1][j+1];\\n                }\\n                dp[i][j] = max(rightupp, max(right, rightlow));\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, dp[i][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int n, int m, int row, int col, int val, vector<vector<int>>& grid) {\\n\\t\\n\\t\\t//base case\\n        if (col == m - 1) {\\n            return 0;\\n        }\\n        \\n        int rightupp = 0;\\n        int right = 0;\\n        int rightlow = 0;\\n\\t\\t\\n\\t\\t//condition check and recursion call with adding 1\\n        if (row - 1 >= 0 && col + 1 < m && val < grid[row-1][col+1]) {\\n            rightupp = 1 + helper(n, m, row-1, col+1, grid[row-1][col+1], grid);\\n        }\\n        if (row < n && col + 1 < m && val < grid[row][col+1]) {\\n            right = 1 + helper(n, m, row, col+1, grid[row][col+1], grid);\\n        }\\n        if (row + 1 < n && col + 1 < m && val < grid[row+1][col+1]) {\\n            rightlow = 1 + helper(n, m, row+1, col+1, grid[row+1][col+1], grid);\\n        }\\n        \\n\\t\\t//return answer\\n        return max(rightupp, max(right, rightlow));\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n\\t\\t\\n\\t\\t//checking for every starting position in first column\\n        for (int i = 0; i < n; i++) {\\n            maxi = max(maxi, helper(n, m, i, 0, grid[i][0], grid));\\n        }\\n\\t\\t\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(int n,int m,int row,int col,int val,vector<vector<int>>& grid,vector<vector<int>> &dp){        \\n        if(row<n && col==m-1){\\n            return 0;\\n        }     \\n\\t\\t\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        \\n        int rightupp=0;\\n        int right=0;\\n        int rightlow=0;\\n        if(row-1>=0 && col+1<m && val<grid[row-1][col+1]){\\n            rightupp=1+helper(n,m,row-1,col+1,grid[row-1][col+1],grid,dp);\\n        }\\n        if(row<n && col+1<m && val<grid[row][col+1]){\\n            right=1+helper(n,m,row,col+1,grid[row][col+1],grid,dp);\\n        }\\n        if(row+1<n && col+1<m && val<grid[row+1][col+1]){\\n            rightlow=1+helper(n,m,row+1,col+1,grid[row+1][col+1],grid,dp);\\n        }\\n\\t\\t\\n        return dp[row][col]=max(rightupp,max(right,rightlow));\\n        \\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n\\t\\t\\n\\t\\t//memoization vector \\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n\\t\\n        for(int i=0;i<n;i++){\\n           maxi=max(maxi, helper(n,m,i,0,grid[i][0],grid,dp));\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][m-1] = 0;\\n        }\\n        \\n        for (int j = m-2; j >= 0; j--) {\\n            for (int i = 0; i < n; i++) {\\n                int rightupp = 0, right = 0, rightlow = 0;\\n                int val = grid[i][j];\\n                if (i-1 >= 0 && j+1 < m && val < grid[i-1][j+1]) {\\n                    rightupp = 1 + dp[i-1][j+1];\\n                }\\n                if (j+1 < m && val < grid[i][j+1]) {\\n                    right = 1 + dp[i][j+1];\\n                }\\n                if (i+1 < n && j+1 < m && val < grid[i+1][j+1]) {\\n                    rightlow = 1 + dp[i+1][j+1];\\n                }\\n                dp[i][j] = max(rightupp, max(right, rightlow));\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, dp[i][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522071,
                "title": "dfs-dp-easy-commented-code",
                "content": "### DO UPVOTE If you find it useful !\\n\\n\\n# Intuition\\nThe given code solves the problem of finding the maximum number of moves that can be performed in a grid. The grid is represented by a 2D matrix with positive integers. The goal is to start at any cell in the first column and traverse the grid, moving to cells where the value is strictly larger than the current cell.\\n\\n# Approach\\n- Initialize a vector row with the values {-1, 0, 1}. This vector represents the row offsets for the three possible moves in each step.\\n- Implement a depth-first search (DFS) function dfs that takes the grid, the current row and column, the value of the previous cell, and a DP table dp as input.\\n- Check if the result for the current cell is already calculated by looking it up in the DP table. If it is available, return the result.\\n- Initialize a variable maxi to 0 to keep track of the maximum number of moves.\\n- Iterate over the three possible moves (up, same row, down) and calculate the new row (nr) and column (nc) based on the move.\\nCheck if the move is valid by ensuring that the new row and column are within the grid boundaries.\\n- Check if the value of the new cell is strictly greater than the previous cell. If it is, calculate the number of moves from this new cell by recursively calling the dfs function with the new row, new column, and new cell value as arguments. Increment the result by 1 to account for the current move\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> row = {-1, 0, 1};\\n    \\n    // Depth-first search function to find the maximum number of moves\\n    int dfs(vector<vector<int>>& grid, int r, int c, int prev, vector<vector<int>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        // Check if the result for the current cell is already calculated\\n        if (dp[r][c] != -1) {\\n            return dp[r][c];\\n        }\\n        \\n        // Explore all possible moves from the current cell\\n        for (int i = 0; i < 3; i++) {\\n            int nr = r + row[i];\\n            int nc = c + 1;\\n            int val = 0;\\n            \\n            // Check if the move is valid and the value of the cell is strictly greater than the previous cell\\n            if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > prev) {\\n                val = 1 + dfs(grid, nr, nc, grid[nr][nc], dp);\\n                maxi = max(maxi, val);\\n            }\\n        }\\n        \\n        // Store the result for the current cell in the DP table\\n        return dp[r][c] = maxi;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        \\n        // Initialize the DP table with -1\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        \\n        // Iterate over each cell in the first column and find the maximum number of moves\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, dfs(grid, i, 0, grid[i][0], dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> row = {-1, 0, 1};\\n    \\n    // Depth-first search function to find the maximum number of moves\\n    int dfs(vector<vector<int>>& grid, int r, int c, int prev, vector<vector<int>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        // Check if the result for the current cell is already calculated\\n        if (dp[r][c] != -1) {\\n            return dp[r][c];\\n        }\\n        \\n        // Explore all possible moves from the current cell\\n        for (int i = 0; i < 3; i++) {\\n            int nr = r + row[i];\\n            int nc = c + 1;\\n            int val = 0;\\n            \\n            // Check if the move is valid and the value of the cell is strictly greater than the previous cell\\n            if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > prev) {\\n                val = 1 + dfs(grid, nr, nc, grid[nr][nc], dp);\\n                maxi = max(maxi, val);\\n            }\\n        }\\n        \\n        // Store the result for the current cell in the DP table\\n        return dp[r][c] = maxi;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        \\n        // Initialize the DP table with -1\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        \\n        // Iterate over each cell in the first column and find the maximum number of moves\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, dfs(grid, i, 0, grid[i][0], dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521907,
                "title": "dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int dp[][]=new int[grid.length][grid[0].length];\\n        int max=0;\\n        for(int i=1;i<grid[0].length;i++){\\n            for(int j=0;j<grid.length;j++){\\n                if(grid[j][i-1]<grid[j][i]){\\n                    if(i==1 || dp[j][i-1]>0)dp[j][i]=Math.max(dp[j][i],1+dp[j][i-1]);\\n                }\\n                \\n                if(j-1>=0 && grid[j-1][i-1]<grid[j][i]){\\n                     if(i==1 || dp[j-1][i-1]>0)dp[j][i]=Math.max(dp[j][i],1+dp[j-1][i-1]);\\n                }\\n                \\n                if(j+1<grid.length && grid[j+1][i-1]<grid[j][i]){\\n                    if(i==1 || dp[j+1][i-1]>0) dp[j][i]=Math.max(dp[j][i],1+dp[j+1][i-1]);\\n                }\\n                \\n                max=Math.max(max,dp[j][i]);\\n                //System.out.print(dp[j][i]+\" \");\\n            }\\n            //System.out.println();\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int dp[][]=new int[grid.length][grid[0].length];\\n        int max=0;\\n        for(int i=1;i<grid[0].length;i++){\\n            for(int j=0;j<grid.length;j++){\\n                if(grid[j][i-1]<grid[j][i]){\\n                    if(i==1 || dp[j][i-1]>0)dp[j][i]=Math.max(dp[j][i],1+dp[j][i-1]);\\n                }\\n                \\n                if(j-1>=0 && grid[j-1][i-1]<grid[j][i]){\\n                     if(i==1 || dp[j-1][i-1]>0)dp[j][i]=Math.max(dp[j][i],1+dp[j-1][i-1]);\\n                }\\n                \\n                if(j+1<grid.length && grid[j+1][i-1]<grid[j][i]){\\n                    if(i==1 || dp[j+1][i-1]>0) dp[j][i]=Math.max(dp[j][i],1+dp[j+1][i-1]);\\n                }\\n                \\n                max=Math.max(max,dp[j][i]);\\n                //System.out.print(dp[j][i]+\" \");\\n            }\\n            //System.out.println();\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771577,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nThere are 3 cases to deal with as mentioned in the question. We check whether the given cell\\'s value is less than the specified adjacent 3 cells value. If there is a true condition we calculate the maximum possible answer from that path.Later we calculate the answer for each cell of the first column of the given grid and thus find the maximum possible answer.\\n\\n# Approach\\nDynammic programming with memoization is used here. In order to avoid repetitive calculations, each time the condition `dp[i][j] != -1` is checked. This helps in optimization.We apply the given conditions and finally calculate the maximum possible answer. \\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// to ensure whether the given cell exists\\n    bool isValid(int i, int j, vector<vector<int>> &grid){\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n        return false;\\n        return true;\\n    }\\n// recursive function to calculate the maximum number of moves\\n    int solve(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n// base conditon\\n        if(!isValid(i,j,grid)) return 0;\\n// answer already calculated\\n        if(dp[i][j] != -1) return dp[i][j];\\n// for three possible paths\\n        int ans1 = 0,ans2 = 0,ans3 = 0;\\n        if(isValid(i-1,j+1,grid) && grid[i][j] < grid[i-1][j+1]){\\n// answer is already calculated\\n            if(dp[i-1][j+1] != -1)\\n        ans1 = 1+ dp[i-1][j+1];\\n        else\\n// call the  recursive function\\n        ans1 = 1+ solve(i-1,j+1,grid,dp);\\n        }\\n       if(isValid(i,j+1,grid) && grid[i][j] < grid[i][j+1]){\\n// answer is already calculated\\n            if(dp[i][j+1] != -1)\\n        ans2 = 1+ dp[i][j+1];\\n        else\\n// call the  recursive function\\n        ans2 = 1+ solve(i,j+1,grid,dp);\\n        }\\n        if(isValid(i+1,j+1,grid) && grid[i][j] < grid[i+1][j+1]){\\n// answer is already calculated\\n            if(dp[i+1][j+1] != -1)\\n        ans3 = 1+ dp[i+1][j+1];\\n        else\\n// call the  recursive function\\n        ans3 = 1+ solve(i+1,j+1,grid,dp);\\n        }\\n// return the maximum possible answer\\n        return dp[i][j] = max(ans1,max(ans2,ans3));\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n// store the dimensions of the grid\\n        int n = grid.size();\\n        int m = grid[0].size();\\n// memoization \\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n// to store maxmimum possible answer\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n// calculate and compare for each cell of the first column \\n            ans = max(ans,solve(i,0,grid,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// to ensure whether the given cell exists\\n    bool isValid(int i, int j, vector<vector<int>> &grid){\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n        return false;\\n        return true;\\n    }\\n// recursive function to calculate the maximum number of moves\\n    int solve(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n// base conditon\\n        if(!isValid(i,j,grid)) return 0;\\n// answer already calculated\\n        if(dp[i][j] != -1) return dp[i][j];\\n// for three possible paths\\n        int ans1 = 0,ans2 = 0,ans3 = 0;\\n        if(isValid(i-1,j+1,grid) && grid[i][j] < grid[i-1][j+1]){\\n// answer is already calculated\\n            if(dp[i-1][j+1] != -1)\\n        ans1 = 1+ dp[i-1][j+1];\\n        else\\n// call the  recursive function\\n        ans1 = 1+ solve(i-1,j+1,grid,dp);\\n        }\\n       if(isValid(i,j+1,grid) && grid[i][j] < grid[i][j+1]){\\n// answer is already calculated\\n            if(dp[i][j+1] != -1)\\n        ans2 = 1+ dp[i][j+1];\\n        else\\n// call the  recursive function\\n        ans2 = 1+ solve(i,j+1,grid,dp);\\n        }\\n        if(isValid(i+1,j+1,grid) && grid[i][j] < grid[i+1][j+1]){\\n// answer is already calculated\\n            if(dp[i+1][j+1] != -1)\\n        ans3 = 1+ dp[i+1][j+1];\\n        else\\n// call the  recursive function\\n        ans3 = 1+ solve(i+1,j+1,grid,dp);\\n        }\\n// return the maximum possible answer\\n        return dp[i][j] = max(ans1,max(ans2,ans3));\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n// store the dimensions of the grid\\n        int n = grid.size();\\n        int m = grid[0].size();\\n// memoization \\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n// to store maxmimum possible answer\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n// calculate and compare for each cell of the first column \\n            ans = max(ans,solve(i,0,grid,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595835,
                "title": "bfs-and-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>> &grid, int n, int m, vector<vector<int>> &dp)\\n{\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int up = 0;\\n    int forward = 0;\\n    int down = 0;\\n\\n    if (i - 1 >= 0 and j + 1 < m and grid[i - 1][j + 1] > grid[i][j])\\n        up = 1 + solve(i - 1, j + 1, grid, n, m, dp);\\n\\n    if (j + 1 < m and grid[i][j + 1] > grid[i][j])\\n        forward = 1 + solve(i, j + 1, grid, n, m, dp);\\n\\n    if (i + 1 < n and j + 1 < m and grid[i + 1][j + 1] > grid[i][j])\\n        down = 1 + solve(i + 1, j + 1, grid, n, m, dp);\\n\\n    return dp[i][j] = max({up, forward, down});\\n}\\n\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ans = max(ans, solve(i, 0, grid, n, m, dp));\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>> &grid, int n, int m, vector<vector<int>> &dp)\\n{\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int up = 0;\\n    int forward = 0;\\n    int down = 0;\\n\\n    if (i - 1 >= 0 and j + 1 < m and grid[i - 1][j + 1] > grid[i][j])\\n        up = 1 + solve(i - 1, j + 1, grid, n, m, dp);\\n\\n    if (j + 1 < m and grid[i][j + 1] > grid[i][j])\\n        forward = 1 + solve(i, j + 1, grid, n, m, dp);\\n\\n    if (i + 1 < n and j + 1 < m and grid[i + 1][j + 1] > grid[i][j])\\n        down = 1 + solve(i + 1, j + 1, grid, n, m, dp);\\n\\n    return dp[i][j] = max({up, forward, down});\\n}\\n\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ans = max(ans, solve(i, 0, grid, n, m, dp));\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538824,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        int ans = 0;\\n        \\n        for(int c = m-2;c >= 0;c--){\\n            \\n        for(int r = 0;r < n;r++){\\n            if(c+1 < m && grid[r][c+1] > grid[r][c]){\\n                dp[r][c] = max(dp[r][c],1+dp[r][c+1]);\\n                \\n            }\\n            if(r - 1 >= 0 && c + 1 < m && grid[r-1][c+1] > grid[r][c]){\\n                dp[r][c] = max(dp[r][c],1+dp[r-1][c+1]);\\n                \\n            }\\n            if(r + 1 < n && c + 1 < m && grid[r+1][c+1] > grid[r][c]){\\n                dp[r][c] = max(dp[r][c],1+dp[r+1][c+1]);\\n                \\n            }\\n            if(c == 0)\\n            ans = max(ans,dp[r][c]);\\n        }\\n            \\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        int ans = 0;\\n        \\n        for(int c = m-2;c >= 0;c--){\\n            \\n        for(int r = 0;r < n;r++){\\n            if(c+1 < m && grid[r][c+1] > grid[r][c]){\\n                dp[r][c] = max(dp[r][c],1+dp[r][c+1]);\\n                \\n            }\\n            if(r - 1 >= 0 && c + 1 < m && grid[r-1][c+1] > grid[r][c]){\\n                dp[r][c] = max(dp[r][c],1+dp[r-1][c+1]);\\n                \\n            }\\n            if(r + 1 < n && c + 1 < m && grid[r+1][c+1] > grid[r][c]){\\n                dp[r][c] = max(dp[r][c],1+dp[r+1][c+1]);\\n                \\n            }\\n            if(c == 0)\\n            ans = max(ans,dp[r][c]);\\n        }\\n            \\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526117,
                "title": "python-bfs-o-m-n",
                "content": "1. From left to right, for each column, save the row_indices of reachable cells in `dq`.\\n2. Row_indices of reachable cells in the next column are saved in `nxt`. If `nxt` is nonempty, we can move to the next column, hence add 1 to `moves`.\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque(range(m))\\n        moves = 0\\n        while dq and moves < n-1:\\n            nxt = set()\\n            for _ in range(len(dq)):\\n                idx = dq.popleft()\\n                val = grid[idx][moves]\\n                for i in range(max(0, idx-1), min(m, idx+2)):\\n                    if grid[i][moves+1] > val:\\n                        nxt.add(i)\\n            if len(nxt) > 0:\\n                moves += 1\\n            dq.extend(nxt)\\n        return moves\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. From left to right, for each column, save the row_indices of reachable cells in `dq`.\\n2. Row_indices of reachable cells in the next column are saved in `nxt`. If `nxt` is nonempty, we can move to the next column, hence add 1 to `moves`.\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque(range(m))\\n        moves = 0\\n        while dq and moves < n-1:\\n            nxt = set()\\n            for _ in range(len(dq)):\\n                idx = dq.popleft()\\n                val = grid[idx][moves]\\n                for i in range(max(0, idx-1), min(m, idx+2)):\\n                    if grid[i][moves+1] > val:\\n                        nxt.add(i)\\n            if len(nxt) > 0:\\n                moves += 1\\n            dq.extend(nxt)\\n        return moves\\n",
                "codeTag": "Java"
            },
            {
                "id": 3525514,
                "title": "beginner-friendly-solution-using-basic-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n\\n        for (int col = n - 2; col >= 0; col--) {\\n            for (int row = 0; row < m; row++) {\\n                int maxMoves = 0;\\n                for (int newRow = row - 1; newRow <= row + 1; newRow++) {\\n                    if (newRow >= 0 && newRow < m) {\\n                        if (grid[newRow][col + 1] > grid[row][col]) {\\n                            maxMoves = max(maxMoves, dp[newRow][col + 1]+1);\\n                        }\\n                    }\\n                }\\n                dp[row][col] = maxMoves ;\\n            }\\n        }\\n        \\n        int maxMoves = 0;\\n        for (int row = 0; row < m; row++) {\\n            maxMoves = max(maxMoves, dp[row][0]);\\n        }\\n\\n        return maxMoves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n\\n        for (int col = n - 2; col >= 0; col--) {\\n            for (int row = 0; row < m; row++) {\\n                int maxMoves = 0;\\n                for (int newRow = row - 1; newRow <= row + 1; newRow++) {\\n                    if (newRow >= 0 && newRow < m) {\\n                        if (grid[newRow][col + 1] > grid[row][col]) {\\n                            maxMoves = max(maxMoves, dp[newRow][col + 1]+1);\\n                        }\\n                    }\\n                }\\n                dp[row][col] = maxMoves ;\\n            }\\n        }\\n        \\n        int maxMoves = 0;\\n        for (int row = 0; row < m; row++) {\\n            maxMoves = max(maxMoves, dp[row][0]);\\n        }\\n\\n        return maxMoves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523200,
                "title": "javascript-2684-maximum-number-of-moves-in-a-grid",
                "content": "**Weekly contest 345 solutions**\\n- Q1 - https://leetcode.com/problems/find-the-losers-of-the-circular-game/solutions/3522269/javascript-2682-find-the-losers-of-the-circular-game/\\n- Q2 - https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3523188/javascript-2683-neighboring-bitwise-xor/?orderBy=most_votes\\n- Q3 - https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/solutions/3523200/javascript-2684-maximum-number-of-moves-in-a-grid/?orderBy=most_votes\\n- Q4 - https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3523225/javascript-2685-count-the-number-of-complete-components/?orderBy=most_votes\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst maxMoves = function (g) {\\n  const m = g.length\\n\\n  const q = []\\n  const C = 0\\n  for (let R = 0; R < m; R++) {\\n    q.push([R, C, 0])\\n  }\\n\\n  let max = 0\\n  const set = new Set()\\n  while (q.length) {\\n    const len = q.length\\n    for (let i = 0; i < len; i++) {\\n      const [R, C, mo] = q.shift()\\n      for (const [dx, dy] of [[-1, 1], [0, 1], [1, 1]]) {\\n        const nR = R + dx // new Row\\n        const nC = C + dy // new Col on right\\n        if (g[nR]?.[nC] > g[R][C]) {\\n          if (set.has(nR + \\',\\' + nC)) continue // Avoid TLE\\n          set.add(nR + \\',\\' + nC)\\n\\n          q.push([nR, nC, mo + 1])\\n          max = Math.max(max, mo + 1)\\n        }\\n      }\\n    }\\n  }\\n\\n  return max\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxMoves = function (g) {\\n  const m = g.length\\n\\n  const q = []\\n  const C = 0\\n  for (let R = 0; R < m; R++) {\\n    q.push([R, C, 0])\\n  }\\n\\n  let max = 0\\n  const set = new Set()\\n  while (q.length) {\\n    const len = q.length\\n    for (let i = 0; i < len; i++) {\\n      const [R, C, mo] = q.shift()\\n      for (const [dx, dy] of [[-1, 1], [0, 1], [1, 1]]) {\\n        const nR = R + dx // new Row\\n        const nC = C + dy // new Col on right\\n        if (g[nR]?.[nC] > g[R][C]) {\\n          if (set.has(nR + \\',\\' + nC)) continue // Avoid TLE\\n          set.add(nR + \\',\\' + nC)\\n\\n          q.push([nR, nC, mo + 1])\\n          max = Math.max(max, mo + 1)\\n        }\\n      }\\n    }\\n  }\\n\\n  return max\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523054,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> seen;\\n    int bfs(vector<vector<int>>& grid,pair<int,int> src)\\n    {\\n        int n = size(grid), m = size(grid[0]),ans = 0;\\n        queue<pair<pair<int,int>,pair<int,int>>> q;\\n        q.push({{grid[src.first][src.second],0},{src}});\\n        vector<pair<int,int>> moves{{-1,1},{0,1},{1,1}};\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vis[src.first][src.second] = true;\\n        seen[src.first][src.second] = 1;\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        while(!q.empty()){\\n            auto top = q.front();\\n            int val = top.first.first;\\n            int step = top.first.second;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n            q.pop();\\n            ans = max(ans,step);\\n            for(auto&move: moves){\\n                int i = x + move.first;\\n                int j = y + move.second;\\n                if(isvalid(i,j) && !vis[i][j] && seen[i][j] == 0 && grid[i][j] > val){\\n                    vis[i][j] = true;\\n                    q.push({{grid[i][j],step+1},{i,j}});\\n                    seen[i][j] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = size(grid), m = size(grid[0]), ans = 0;\\n        seen.resize(n,vector<int>(m,0));\\n        for(int i=0; i<n; ++i)\\n            ans = max(ans,bfs(grid,{i,0}));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> seen;\\n    int bfs(vector<vector<int>>& grid,pair<int,int> src)\\n    {\\n        int n = size(grid), m = size(grid[0]),ans = 0;\\n        queue<pair<pair<int,int>,pair<int,int>>> q;\\n        q.push({{grid[src.first][src.second],0},{src}});\\n        vector<pair<int,int>> moves{{-1,1},{0,1},{1,1}};\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vis[src.first][src.second] = true;\\n        seen[src.first][src.second] = 1;\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        while(!q.empty()){\\n            auto top = q.front();\\n            int val = top.first.first;\\n            int step = top.first.second;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n            q.pop();\\n            ans = max(ans,step);\\n            for(auto&move: moves){\\n                int i = x + move.first;\\n                int j = y + move.second;\\n                if(isvalid(i,j) && !vis[i][j] && seen[i][j] == 0 && grid[i][j] > val){\\n                    vis[i][j] = true;\\n                    q.push({{grid[i][j],step+1},{i,j}});\\n                    seen[i][j] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = size(grid), m = size(grid[0]), ans = 0;\\n        seen.resize(n,vector<int>(m,0));\\n        for(int i=0; i<n; ++i)\\n            ans = max(ans,bfs(grid,{i,0}));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523035,
                "title": "dfs-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j,vector<vector<int>>&grid,vector<vector<int>>&dp)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size() || i<0 || j<0)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int a1=0,a2=0,a3=0;\\n        if( i-1<grid.size() && j+1<grid[0].size() && i-1>=0 && j+1>=0 && grid[i-1][j+1]>grid[i][j])\\n        {\\n            a1= 1+dfs(i-1,j+1,grid,dp);\\n        }\\n        if( i<grid.size() && j+1<grid[0].size() && i>=0 && j+1>=0 && grid[i][j+1]>grid[i][j])\\n        {\\n            a2= 1+dfs(i,j+1,grid,dp);\\n        }\\n        if( i+1<grid.size() && j+1<grid[0].size() && i+1>=0 && j+1>=0 && grid[i+1][j+1]>grid[i][j])\\n        {\\n            a3= 1+dfs(i+1,j+1,grid,dp);\\n        }\\n        return dp[i][j] = max(a1,max(a2,a3));\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int maxi=INT_MIN;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<dp.size();j++) for(int k=0;k<dp[0].size();k++) dp[j][k]=-1;  //Resetting DP array to -1\\n            maxi=max(maxi,dfs(i,0,grid,dp));  // calling dfs \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j,vector<vector<int>>&grid,vector<vector<int>>&dp)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size() || i<0 || j<0)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int a1=0,a2=0,a3=0;\\n        if( i-1<grid.size() && j+1<grid[0].size() && i-1>=0 && j+1>=0 && grid[i-1][j+1]>grid[i][j])\\n        {\\n            a1= 1+dfs(i-1,j+1,grid,dp);\\n        }\\n        if( i<grid.size() && j+1<grid[0].size() && i>=0 && j+1>=0 && grid[i][j+1]>grid[i][j])\\n        {\\n            a2= 1+dfs(i,j+1,grid,dp);\\n        }\\n        if( i+1<grid.size() && j+1<grid[0].size() && i+1>=0 && j+1>=0 && grid[i+1][j+1]>grid[i][j])\\n        {\\n            a3= 1+dfs(i+1,j+1,grid,dp);\\n        }\\n        return dp[i][j] = max(a1,max(a2,a3));\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int maxi=INT_MIN;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<dp.size();j++) for(int k=0;k<dp[0].size();k++) dp[j][k]=-1;  //Resetting DP array to -1\\n            maxi=max(maxi,dfs(i,0,grid,dp));  // calling dfs \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522980,
                "title": "java-top-down-easy",
                "content": "\\t\\tint[][] moves = {{-1,+1},{0,+1},{+1,+1}};\\n\\t\\tpublic int maxMoves(int[][] grid) {\\n\\t\\t\\tint[][] dp = new int[grid.length][grid[0].length];\\n\\t\\t\\tfor(int i=0;i<dp.length;i++)\\n\\t\\t\\t\\tArrays.fill(dp[i],-1);\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i=0;i<grid.length;i++){\\n\\t\\t\\t   max=Math.max(max,dfs(grid,i,0,dp));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n\\t\\tint dfs(int[][] grid, int r, int c, int[][] dp){\\n\\t\\t\\t  int max=0;\\n\\t\\t\\tif(dp[r][c]!=-1)return dp[r][c];\\n\\t\\t\\tfor(int[] arr:moves){\\n\\t\\t\\t\\tint nextRow = r+arr[0], nextCol = c+arr[1];\\n\\t\\t\\t\\tif(nextRow>=0 && nextRow<grid.length && nextCol >=0 &&  nextCol<grid[0].length && grid[nextRow][nextCol]>grid[r][c]){\\n\\t\\t\\t\\t   int  count=1+dfs(grid,nextRow,nextCol,dp);\\n\\t\\t\\t\\t   max=Math.max(max,count);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[r][c]= max;\\n\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\t\\tint[][] moves = {{-1,+1},{0,+1},{+1,+1}};\\n\\t\\tpublic int maxMoves(int[][] grid) {\\n\\t\\t\\tint[][] dp = new int[grid.length][grid[0].length];\\n\\t\\t\\tfor(int i=0;i<dp.length;i++)\\n\\t\\t\\t\\tArrays.fill(dp[i],-1);\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i=0;i<grid.length;i++){\\n\\t\\t\\t   max=Math.max(max,dfs(grid,i,0,dp));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n\\t\\tint dfs(int[][] grid, int r, int c, int[][] dp){\\n\\t\\t\\t  int max=0;\\n\\t\\t\\tif(dp[r][c]!=-1)return dp[r][c];\\n\\t\\t\\tfor(int[] arr:moves){\\n\\t\\t\\t\\tint nextRow = r+arr[0], nextCol = c+arr[1];\\n\\t\\t\\t\\tif(nextRow>=0 && nextRow<grid.length && nextCol >=0 &&  nextCol<grid[0].length && grid[nextRow][nextCol]>grid[r][c]){\\n\\t\\t\\t\\t   int  count=1+dfs(grid,nextRow,nextCol,dp);\\n\\t\\t\\t\\t   max=Math.max(max,count);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[r][c]= max;\\n\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3522922,
                "title": "simple-bfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int maxMoves = Integer.MIN_VALUE;\\n        for(int i=0;i<grid.length;i++){\\n            maxMoves = Math.max(maxMoves, bfs(grid, i));\\n        }\\n        return maxMoves<0?0:maxMoves;\\n    }\\n    \\n    private int bfs(int[][] grid, int i){\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int count = 0;\\n        Queue<int[]> q= new LinkedList<>();\\n        q.offer(new int[]{i,0});\\n         visited[i][0]=true;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int j=1;j<=size;j++){\\n                int[] temp = q.poll();\\n                int x = temp[0], y = temp[1];\\n\\n                if(x-1>=0 && y+1<n && !visited[x-1][y+1] && grid[x-1][y+1]>grid[x][y]){\\n                    q.add(new int[]{x-1, y+1});\\n                    visited[x-1][y+1]=true;\\n                }\\n                if(y+1<n && !visited[x][y+1] && grid[x][y+1]>grid[x][y]){\\n                    q.add(new int[]{x, y+1});\\n                    visited[x][y+1]=true;\\n                }\\n                if(x+1<m && y+1<n && !visited[x+1][y+1] && grid[x+1][y+1]>grid[x][y]){\\n                    q.add(new int[]{x+1, y+1});\\n                    visited[x+1][y+1]=true;\\n                }\\n            }\\n            count++;\\n        }\\n        // System.out.println(count-1);\\n        return count-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int maxMoves = Integer.MIN_VALUE;\\n        for(int i=0;i<grid.length;i++){\\n            maxMoves = Math.max(maxMoves, bfs(grid, i));\\n        }\\n        return maxMoves<0?0:maxMoves;\\n    }\\n    \\n    private int bfs(int[][] grid, int i){\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int count = 0;\\n        Queue<int[]> q= new LinkedList<>();\\n        q.offer(new int[]{i,0});\\n         visited[i][0]=true;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int j=1;j<=size;j++){\\n                int[] temp = q.poll();\\n                int x = temp[0], y = temp[1];\\n\\n                if(x-1>=0 && y+1<n && !visited[x-1][y+1] && grid[x-1][y+1]>grid[x][y]){\\n                    q.add(new int[]{x-1, y+1});\\n                    visited[x-1][y+1]=true;\\n                }\\n                if(y+1<n && !visited[x][y+1] && grid[x][y+1]>grid[x][y]){\\n                    q.add(new int[]{x, y+1});\\n                    visited[x][y+1]=true;\\n                }\\n                if(x+1<m && y+1<n && !visited[x+1][y+1] && grid[x+1][y+1]>grid[x][y]){\\n                    q.add(new int[]{x+1, y+1});\\n                    visited[x+1][y+1]=true;\\n                }\\n            }\\n            count++;\\n        }\\n        // System.out.println(count-1);\\n        return count-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522877,
                "title": "dp-solution-java-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int memo[][];\\n    public int maxMoves(int[][] grid) {\\n        memo=new int[grid.length+1][grid[0].length+1];\\n        int max=0;\\n        for(int i=0;i<memo.length;i++)\\n        {\\n            for(int j=0;j<memo[0].length;j++)\\n                memo[i][j]=-1;\\n        }\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            max=Math.max(max,maxMove(i,0,grid));\\n        }\\n        return max;\\n    }\\n    public int maxMove(int i,int j,int a[][])\\n    {\\n        if(memo[i][j]==-1)\\n        {\\n            if(j==a[0].length-1)\\n            return 0;\\n        \\n            int x=0,y=0,z=0;\\n            if(i!=0&&a[i-1][j+1]>a[i][j])\\n                x = 1+maxMove(i-1,j+1,a);\\n\\n            if(a[i][j+1]>a[i][j])\\n                y = 1+maxMove(i,j+1,a);\\n\\n            if(i!=a.length-1&&a[i+1][j+1]>a[i][j])\\n                z = 1+maxMove(i+1,j+1,a);\\n\\n            memo[i][j] = Math.max(z,Math.max(x,y));    \\n        }\\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int memo[][];\\n    public int maxMoves(int[][] grid) {\\n        memo=new int[grid.length+1][grid[0].length+1];\\n        int max=0;\\n        for(int i=0;i<memo.length;i++)\\n        {\\n            for(int j=0;j<memo[0].length;j++)\\n                memo[i][j]=-1;\\n        }\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            max=Math.max(max,maxMove(i,0,grid));\\n        }\\n        return max;\\n    }\\n    public int maxMove(int i,int j,int a[][])\\n    {\\n        if(memo[i][j]==-1)\\n        {\\n            if(j==a[0].length-1)\\n            return 0;\\n        \\n            int x=0,y=0,z=0;\\n            if(i!=0&&a[i-1][j+1]>a[i][j])\\n                x = 1+maxMove(i-1,j+1,a);\\n\\n            if(a[i][j+1]>a[i][j])\\n                y = 1+maxMove(i,j+1,a);\\n\\n            if(i!=a.length-1&&a[i+1][j+1]>a[i][j])\\n                z = 1+maxMove(i+1,j+1,a);\\n\\n            memo[i][j] = Math.max(z,Math.max(x,y));    \\n        }\\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522596,
                "title": "memoized-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int a=0,b=0,c=0;\\n        if(i-1>=0 and j+1<m and grid[i][j]<grid[i-1][j+1]){\\n            a=1+solve(i-1,j+1,n,m,grid,dp);\\n        }\\n        if(j+1<m and grid[i][j]<grid[i][j+1]){\\n            b=1+solve(i,j+1,n,m,grid,dp);\\n        }\\n        if(i+1<n and j+1<m and grid[i][j]<grid[i+1][j+1]){\\n            c=1+solve(i+1,j+1,n,m,grid,dp);\\n        }\\n        return dp[i][j]=max({a,b,c});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,solve(i,0,n,m,grid,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int a=0,b=0,c=0;\\n        if(i-1>=0 and j+1<m and grid[i][j]<grid[i-1][j+1]){\\n            a=1+solve(i-1,j+1,n,m,grid,dp);\\n        }\\n        if(j+1<m and grid[i][j]<grid[i][j+1]){\\n            b=1+solve(i,j+1,n,m,grid,dp);\\n        }\\n        if(i+1<n and j+1<m and grid[i][j]<grid[i+1][j+1]){\\n            c=1+solve(i+1,j+1,n,m,grid,dp);\\n        }\\n        return dp[i][j]=max({a,b,c});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,solve(i,0,n,m,grid,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522539,
                "title": "easy-solution-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                int ele=grid[j][i];\\n                int c=i+1;\\n                int maxi=-1;\\n                int x=-1,y=-1;\\n                for(int k=-1;k<=1;k++)\\n                {\\n                    int r=j+k;\\n                    if(r>=0&&r<m&&j>=0&&grid[r][c]>ele)\\n                    {\\n                       if(vis[r][c]>maxi)\\n                       {\\n                           maxi=vis[r][c];\\n                           x=r;y=c;\\n                       }\\n                    }\\n                }\\n                if(x!=-1&&y!=-1&&maxi!=-1)\\n                vis[j][i]=1+vis[x][y];\\n                else\\n                vis[j][i]=0;\\n\\n            }\\n        }\\n       int ans=0;\\n       for(int i=0;i<m;i++)\\n       ans=max(ans,vis[i][0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                int ele=grid[j][i];\\n                int c=i+1;\\n                int maxi=-1;\\n                int x=-1,y=-1;\\n                for(int k=-1;k<=1;k++)\\n                {\\n                    int r=j+k;\\n                    if(r>=0&&r<m&&j>=0&&grid[r][c]>ele)\\n                    {\\n                       if(vis[r][c]>maxi)\\n                       {\\n                           maxi=vis[r][c];\\n                           x=r;y=c;\\n                       }\\n                    }\\n                }\\n                if(x!=-1&&y!=-1&&maxi!=-1)\\n                vis[j][i]=1+vis[x][y];\\n                else\\n                vis[j][i]=0;\\n\\n            }\\n        }\\n       int ans=0;\\n       for(int i=0;i<m;i++)\\n       ans=max(ans,vis[i][0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522453,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n+m)$$\\n\\n- Space complexity:$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans1=0;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        queue<pair<int, pair<int, int>>>q;\\n        for(int i=0; i<grid.size(); i++){\\n            q.push({0, {i, 0}});\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int x=q.front().second.first, y=q.front().second.second, cnt=q.front().first;\\n            q.pop();\\n            ans=max(ans, cnt);\\n            if(x>0 && y<grid[0].size()-1 && !v[x-1][y+1] && grid[x][y]<grid[x-1][y+1]){\\n                v[x-1][y+1]=1;\\n                q.push({cnt+1, {x-1, y+1}});\\n            }\\n            if(y<grid[0].size()-1 && !v[x][y+1] && grid[x][y]<grid[x][y+1]){\\n                v[x][y+1]=1;\\n                q.push({cnt+1, {x, y+1}});\\n            }\\n            if(x<grid.size()-1 && y<grid[0].size()-1 && !v[x+1][y+1] && grid[x][y]<grid[x+1][y+1]){\\n                v[x+1][y+1]=1;\\n                q.push({cnt+1, {x+1, y+1}});\\n            }\\n        }\\n        ans1=max(ans1, ans);\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans1=0;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        queue<pair<int, pair<int, int>>>q;\\n        for(int i=0; i<grid.size(); i++){\\n            q.push({0, {i, 0}});\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int x=q.front().second.first, y=q.front().second.second, cnt=q.front().first;\\n            q.pop();\\n            ans=max(ans, cnt);\\n            if(x>0 && y<grid[0].size()-1 && !v[x-1][y+1] && grid[x][y]<grid[x-1][y+1]){\\n                v[x-1][y+1]=1;\\n                q.push({cnt+1, {x-1, y+1}});\\n            }\\n            if(y<grid[0].size()-1 && !v[x][y+1] && grid[x][y]<grid[x][y+1]){\\n                v[x][y+1]=1;\\n                q.push({cnt+1, {x, y+1}});\\n            }\\n            if(x<grid.size()-1 && y<grid[0].size()-1 && !v[x+1][y+1] && grid[x][y]<grid[x+1][y+1]){\\n                v[x+1][y+1]=1;\\n                q.push({cnt+1, {x+1, y+1}});\\n            }\\n        }\\n        ans1=max(ans1, ans);\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522353,
                "title": "easy-c-solution-top-down-dp-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Call recursive function for all the possible starting cells from `(0,0)` to `(0,M-1)`.\\n- In recusive function check if it is possible to move to `g[i-1][j]` || `g[i][j+1]` || `g[i+1][j+1]` from the current cell `g[i][j]`. \\n- Call the recursive function for the possible cells and return the max value amongst them.\\n- Store the max value for every cell in dp matrix to avoid redundant calculations.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    int rec(int i, int j,  vector<vector<int>> &g, vector<vector<long long>> &dp)\\n    {\\n        int r = g.size();\\n        int c = g[0].size();\\n        // Return if value for a cell is already calculated\\n        if (dp[i][j] != -1) \\n            return dp[i][j];\\n\\n        long long a = 0, b = 0, cc = 0;\\n        if (i > 0 && j < c - 1 && g[i][j] < g[i - 1][j + 1])\\n            a = rec(i - 1, j + 1, g, dp) + 1;\\n        \\n        if (j < c - 1 && g[i][j] < g[i][j + 1])\\n            b = rec(i, j + 1, g, dp) + 1;\\n\\n        if (i < r - 1 && j < c - 1 && g[i][j] < g[i + 1][j + 1])\\n            cc = rec(i + 1, j + 1, g, dp) + 1;\\n\\n        // Return max value of all possible recursive calls\\n        return dp[i][j] = max({a, b, cc});\\n    }\\n\\npublic:\\n    int maxMoves(vector<vector<int>> &grid)\\n    {   \\n        int n = grid.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(grid[0].size()+1,-1));\\n        int ans = 0;\\n    // Calling recursive function for every cell in first column.\\n        for(int i=0;i< n;++i) \\n        {\\n            int x = rec(i, 0, grid, dp);\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    int rec(int i, int j,  vector<vector<int>> &g, vector<vector<long long>> &dp)\\n    {\\n        int r = g.size();\\n        int c = g[0].size();\\n        // Return if value for a cell is already calculated\\n        if (dp[i][j] != -1) \\n            return dp[i][j];\\n\\n        long long a = 0, b = 0, cc = 0;\\n        if (i > 0 && j < c - 1 && g[i][j] < g[i - 1][j + 1])\\n            a = rec(i - 1, j + 1, g, dp) + 1;\\n        \\n        if (j < c - 1 && g[i][j] < g[i][j + 1])\\n            b = rec(i, j + 1, g, dp) + 1;\\n\\n        if (i < r - 1 && j < c - 1 && g[i][j] < g[i + 1][j + 1])\\n            cc = rec(i + 1, j + 1, g, dp) + 1;\\n\\n        // Return max value of all possible recursive calls\\n        return dp[i][j] = max({a, b, cc});\\n    }\\n\\npublic:\\n    int maxMoves(vector<vector<int>> &grid)\\n    {   \\n        int n = grid.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(grid[0].size()+1,-1));\\n        int ans = 0;\\n    // Calling recursive function for every cell in first column.\\n        for(int i=0;i< n;++i) \\n        {\\n            int x = rec(i, 0, grid, dp);\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522307,
                "title": "java-solution-using-dp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the state in 2d dp Array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nxm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nxm)\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] g) {\\n        int[][] dp = new int[g.length][g[0].length];\\n        for(int i=0; i<g.length; i++)\\n            for(int j=0; j<g[0].length; j++)\\n                dp[i][j] = -1;\\n        for(int i=0; i<g.length; i++){\\n            dp[i][0] = find(g, i, 0, dp);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<g.length; i++){\\n            ans = Math.max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int find(int[][] g, int i, int j, int[][] dp){\\n        if(j==g[0].length-1)    return 0;\\n        if(dp[i][j] > 0)   return dp[i][j];\\n        dp[i][j] = 0;\\n        if(i>0 && j<g[0].length-1 && g[i][j]<g[i-1][j+1]){\\n            dp[i][j] = Math.max(dp[i][j], 1+find(g, i-1, j+1, dp));\\n        }\\n        if(j<g[0].length-1 && g[i][j]<g[i][j+1]){\\n            dp[i][j] = Math.max(dp[i][j], 1+find(g, i, j+1, dp));\\n        }\\n        if(i<g.length-1 && j<g[0].length-1 && g[i][j]<g[i+1][j+1]){\\n            dp[i][j] = Math.max(dp[i][j], 1+find(g, i+1, j+1, dp));\\n        }\\n        return dp[i][j] ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] g) {\\n        int[][] dp = new int[g.length][g[0].length];\\n        for(int i=0; i<g.length; i++)\\n            for(int j=0; j<g[0].length; j++)\\n                dp[i][j] = -1;\\n        for(int i=0; i<g.length; i++){\\n            dp[i][0] = find(g, i, 0, dp);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<g.length; i++){\\n            ans = Math.max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int find(int[][] g, int i, int j, int[][] dp){\\n        if(j==g[0].length-1)    return 0;\\n        if(dp[i][j] > 0)   return dp[i][j];\\n        dp[i][j] = 0;\\n        if(i>0 && j<g[0].length-1 && g[i][j]<g[i-1][j+1]){\\n            dp[i][j] = Math.max(dp[i][j], 1+find(g, i-1, j+1, dp));\\n        }\\n        if(j<g[0].length-1 && g[i][j]<g[i][j+1]){\\n            dp[i][j] = Math.max(dp[i][j], 1+find(g, i, j+1, dp));\\n        }\\n        if(i<g.length-1 && j<g[0].length-1 && g[i][j]<g[i+1][j+1]){\\n            dp[i][j] = Math.max(dp[i][j], 1+find(g, i+1, j+1, dp));\\n        }\\n        return dp[i][j] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522274,
                "title": "easy-cpp-solution-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1);\\n\\n- Space complexity:\\nO(m*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool issafe(int i ,int j ,int row ,int clm,vector<vector<int>>& grid,int prev){\\n\\n        if( i >= 0 && j >= 0 && i < row && j < clm && grid[i][j] > prev) return true;\\n        \\n        return false;\\n}\\n     int solve(vector<vector<int>>& grid,int i , int j , int row ,int clm,int prev, vector<vector<int>>&dp){\\n         if( i >= row || j >= clm ) return 0;\\n         \\n         int ans1  = 0, ans2 = 0,ans3 = 0; \\n        \\n         if(dp[i][j] != -1) return dp[i][j];\\n\\n         if(issafe(i-1,j+1,row,clm,grid,prev)) ans1 = 1 + solve(grid,i-1,j+1,row,clm,grid[i-1][j+1],dp);\\n         \\n         if(issafe(i,j+1,row,clm,grid,prev)) ans2 = 1 + solve(grid,i,j+1,row,clm,grid[i][j+1],dp);\\n         \\n         if(issafe(i+1,j+1,row,clm,grid,prev))  ans3 = 1 + solve(grid,i+1,j+1,row,clm,grid[i+1][j+1],dp);\\n         \\n         return dp[i][j] = max(ans1,max(ans2,ans3));\\n     }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int clm = grid[0].size();\\n\\n        vector<vector<int>>dp(row,vector<int>(clm,-1));\\n        \\n        for(int i = 0 ;i<clm;i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0 ; j<row;j++) maxi = max(solve(grid,j,i,row,clm,grid[j][i],dp),maxi);\\n            return maxi;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool issafe(int i ,int j ,int row ,int clm,vector<vector<int>>& grid,int prev){\\n\\n        if( i >= 0 && j >= 0 && i < row && j < clm && grid[i][j] > prev) return true;\\n        \\n        return false;\\n}\\n     int solve(vector<vector<int>>& grid,int i , int j , int row ,int clm,int prev, vector<vector<int>>&dp){\\n         if( i >= row || j >= clm ) return 0;\\n         \\n         int ans1  = 0, ans2 = 0,ans3 = 0; \\n        \\n         if(dp[i][j] != -1) return dp[i][j];\\n\\n         if(issafe(i-1,j+1,row,clm,grid,prev)) ans1 = 1 + solve(grid,i-1,j+1,row,clm,grid[i-1][j+1],dp);\\n         \\n         if(issafe(i,j+1,row,clm,grid,prev)) ans2 = 1 + solve(grid,i,j+1,row,clm,grid[i][j+1],dp);\\n         \\n         if(issafe(i+1,j+1,row,clm,grid,prev))  ans3 = 1 + solve(grid,i+1,j+1,row,clm,grid[i+1][j+1],dp);\\n         \\n         return dp[i][j] = max(ans1,max(ans2,ans3));\\n     }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int clm = grid[0].size();\\n\\n        vector<vector<int>>dp(row,vector<int>(clm,-1));\\n        \\n        for(int i = 0 ;i<clm;i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0 ; j<row;j++) maxi = max(solve(grid,j,i,row,clm,grid[j][i],dp),maxi);\\n            return maxi;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522243,
                "title": "bfs-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    \\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n\\n    }\\n}\\n\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int visit[][]=new int[n][m];\\n        \\n        int delRow[]={-1,0,1};\\n        int delCol[]={1,1,1};\\n        \\n        int ans[]={-1};\\n        int max=0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && j==0){\\n                    bfs(i,j,grid,visit,delRow,delCol,n,m,ans);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=-1;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int start,int end,int[][]grid,int [][]visit,int delRow[],int delCol[],int n,int m,int ans[]){\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(start,end));\\n        visit[start][end]=1;\\n        \\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int len=0;len<size;len++){\\n                    int row=q.peek().first;\\n                    int col=q.peek().second;\\n                    q.poll();\\n                            \\n                    for(int i=0;i<3;i++){\\n                        int nrow=row+delRow[i];\\n                        int ncol=col+delCol[i];\\n                    \\n                        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && visit[nrow][ncol]==0 && grid[nrow][ncol]>grid[row][col]){\\n                            \\n                            \\n                            q.add(new Pair(nrow,ncol));\\n                            visit[nrow][ncol]=1;\\n                        }\\n                    }\\n            }   \\n            ans[0]++;\\n            // System.out.println(ans[0]);\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    \\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n\\n    }\\n}\\n\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int visit[][]=new int[n][m];\\n        \\n        int delRow[]={-1,0,1};\\n        int delCol[]={1,1,1};\\n        \\n        int ans[]={-1};\\n        int max=0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && j==0){\\n                    bfs(i,j,grid,visit,delRow,delCol,n,m,ans);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=-1;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int start,int end,int[][]grid,int [][]visit,int delRow[],int delCol[],int n,int m,int ans[]){\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(start,end));\\n        visit[start][end]=1;\\n        \\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int len=0;len<size;len++){\\n                    int row=q.peek().first;\\n                    int col=q.peek().second;\\n                    q.poll();\\n                            \\n                    for(int i=0;i<3;i++){\\n                        int nrow=row+delRow[i];\\n                        int ncol=col+delCol[i];\\n                    \\n                        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && visit[nrow][ncol]==0 && grid[nrow][ncol]>grid[row][col]){\\n                            \\n                            \\n                            q.add(new Pair(nrow,ncol));\\n                            visit[nrow][ncol]=1;\\n                        }\\n                    }\\n            }   \\n            ans[0]++;\\n            // System.out.println(ans[0]);\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522215,
                "title": "java-easy-dp-explore-all-3-paths",
                "content": "Feel free to suggest any improvements, corrections\\uD83D\\uDC4D\\uD83C\\uDFFB\\nDo **UPVOTE**\\uD83D\\uDD3A\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n       int m =  grid.length, n = grid[0].length;\\n       int[][] dp = new int[m][n];\\n        \\n       for(int[] row : dp) Arrays.fill(row, -1);\\n        \\n       int ans = 0;\\n       for(int i=0;i<m;i++){\\n           ans = Math.max(ans, func(grid,i,0,dp));\\n           if(ans == grid[0].length - 1) return ans; //Since it\\'s the max\\'m value possible\\n        }\\n        return ans;\\n    }\\n    \\n    private int func(int[][] grid, int r, int c, int[][] dp){\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        int c1 = 0, c2 = 0, c3 = 0;\\n        \\n        if(valid(grid, r-1, c+1) && grid[r-1][c+1] > grid[r][c]) c1 = 1 + func(grid, r-1, c+1, dp);\\n        if(valid(grid, r, c+1) && grid[r][c+1] > grid[r][c]) c2 = 1 + func(grid, r, c+1, dp);\\n        if(valid(grid, r+1, c+1) && grid[r+1][c+1] > grid[r][c]) c3 = 1 + func(grid, r+1, c+1, dp);\\n        \\n        dp[r][c] = Math.max(c1,(Math.max(c2, c3))); //maximum of all 3 possib\\n        \\n        return dp[r][c];\\n    }\\n    \\n    private boolean valid(int[][] grid, int r, int c){\\n        return !(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n       int m =  grid.length, n = grid[0].length;\\n       int[][] dp = new int[m][n];\\n        \\n       for(int[] row : dp) Arrays.fill(row, -1);\\n        \\n       int ans = 0;\\n       for(int i=0;i<m;i++){\\n           ans = Math.max(ans, func(grid,i,0,dp));\\n           if(ans == grid[0].length - 1) return ans; //Since it\\'s the max\\'m value possible\\n        }\\n        return ans;\\n    }\\n    \\n    private int func(int[][] grid, int r, int c, int[][] dp){\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        int c1 = 0, c2 = 0, c3 = 0;\\n        \\n        if(valid(grid, r-1, c+1) && grid[r-1][c+1] > grid[r][c]) c1 = 1 + func(grid, r-1, c+1, dp);\\n        if(valid(grid, r, c+1) && grid[r][c+1] > grid[r][c]) c2 = 1 + func(grid, r, c+1, dp);\\n        if(valid(grid, r+1, c+1) && grid[r+1][c+1] > grid[r][c]) c3 = 1 + func(grid, r+1, c+1, dp);\\n        \\n        dp[r][c] = Math.max(c1,(Math.max(c2, c3))); //maximum of all 3 possib\\n        \\n        return dp[r][c];\\n    }\\n    \\n    private boolean valid(int[][] grid, int r, int c){\\n        return !(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522159,
                "title": "java-dp-recursive",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int ans = 0;\\n    Integer[][] dp;\\n    public int maxMoves(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        dp = new Integer[n + 1][m + 1];\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dfs(grid, i, 0, 0) - 1);\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(int[][] grid, int x, int y, int prev) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (x < 0 || x == n || y < 0 || y == m || grid[x][y] <= prev) {\\n            return 0;\\n        }\\n        \\n        if (dp[x][y] != null)\\n            return dp[x][y];\\n        \\n        int val = grid[x][y];\\n            \\n        int a  = 1  + dfs(grid, x - 1, y + 1,val);\\n        int b = 1 + dfs(grid, x + 1, y + 1,val);\\n        int c = 1 + dfs(grid, x, y + 1,val);\\n        \\n        return dp[x][y] = Math.max(a, Math.max(b, c));\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    Integer[][] dp;\\n    public int maxMoves(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        dp = new Integer[n + 1][m + 1];\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dfs(grid, i, 0, 0) - 1);\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(int[][] grid, int x, int y, int prev) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (x < 0 || x == n || y < 0 || y == m || grid[x][y] <= prev) {\\n            return 0;\\n        }\\n        \\n        if (dp[x][y] != null)\\n            return dp[x][y];\\n        \\n        int val = grid[x][y];\\n            \\n        int a  = 1  + dfs(grid, x - 1, y + 1,val);\\n        int b = 1 + dfs(grid, x + 1, y + 1,val);\\n        int c = 1 + dfs(grid, x, y + 1,val);\\n        \\n        return dp[x][y] = Math.max(a, Math.max(b, c));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522127,
                "title": "bfs-easy-c-graph-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolved By using BFS and Apply bfs on Every element of First column and Take max of them\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>&g,vector<vector<int>>&vis,int i,int j){\\n        int n=g.size();\\n        int m=g[0].size();\\n        int ans=0;\\n        vis[i][j]=1;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{i,j},0});\\n        int row[]={-1,0,+1};\\n        int col[]={+1,+1,+1};\\n        //int ans=0;\\n        while(!q.empty()){\\n            int a=q.front().first.first;\\n            int b=q.front().first.second;\\n            int rs=q.front().second;\\n            q.pop();\\n            ans=max(ans,rs);\\n            for(int i=0;i<3;i++){\\n                int r=a+row[i];\\n                int c=b+col[i];\\n                if(r>=0&&c>=0&&r<n&&c<m&&vis[r][c]==0&&g[r][c]>g[a][b]){\\n                    vis[r][c]=1;\\n                    q.push({{r,c},rs+1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,bfs(grid,vis,i,0));\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>&g,vector<vector<int>>&vis,int i,int j){\\n        int n=g.size();\\n        int m=g[0].size();\\n        int ans=0;\\n        vis[i][j]=1;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{i,j},0});\\n        int row[]={-1,0,+1};\\n        int col[]={+1,+1,+1};\\n        //int ans=0;\\n        while(!q.empty()){\\n            int a=q.front().first.first;\\n            int b=q.front().first.second;\\n            int rs=q.front().second;\\n            q.pop();\\n            ans=max(ans,rs);\\n            for(int i=0;i<3;i++){\\n                int r=a+row[i];\\n                int c=b+col[i];\\n                if(r>=0&&c>=0&&r<n&&c<m&&vis[r][c]==0&&g[r][c]>g[a][b]){\\n                    vis[r][c]=1;\\n                    q.push({{r,c},rs+1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,bfs(grid,vis,i,0));\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522124,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint s[1005][1005];\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<=m;++i) memset(s[i],-127/3,sizeof(s[i]));\\n        memset(s[0],0,sizeof(s[0]));\\n        int ans=0;\\n        for(int i=0;i<m;++i) {\\n            for(int j=0;j<n;++j) {\\n                ans=max(ans,s[i][j]);\\n                if(i+1==m) continue;\\n                for(int k=j-1;k<=j+1;++k) if(k>=0&&k<n&&grid[j][i]<grid[k][i+1])\\n                    s[i+1][k]=max(s[i+1][k],s[i][j]+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint s[1005][1005];\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<=m;++i) memset(s[i],-127/3,sizeof(s[i]));\\n        memset(s[0],0,sizeof(s[0]));\\n        int ans=0;\\n        for(int i=0;i<m;++i) {\\n            for(int j=0;j<n;++j) {\\n                ans=max(ans,s[i][j]);\\n                if(i+1==m) continue;\\n                for(int k=j-1;k<=j+1;++k) if(k>=0&&k<n&&grid[j][i]<grid[k][i+1])\\n                    s[i+1][k]=max(s[i+1][k],s[i][j]+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522114,
                "title": "c-bfs-easy-to-understand",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        int ans=0;\\n        int vis[n][m];\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++)vis[i][j]=0;\\n        }\\n        int dx[]= {-1,0,1};\\n            int mov=0;\\n            queue<pair<int,int>> q;\\n            for (int i=0; i<n; i++){q.push({i,0});vis[i][0]=1;}\\n            while (!q.empty()){\\n                int sz= q.size();\\n                for (int iii=0; iii<sz; iii++){\\n                    int x= q.front().first;\\n                    int y= q.front().second;\\n                    q.pop();\\n                    for (int k=0; k<3; k++){\\n                        int nr= x+dx[k];\\n                        int nc= y+1;\\n                        if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]>grid[x][y] && !vis[nr][nc]){\\n                            vis[nr][nc]=1;\\n                            q.push({nr,nc});\\n                        }\\n                    }    \\n                }\\n                mov++;\\n            }\\n            ans= max(ans,mov-1);\\n        //}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        int ans=0;\\n        int vis[n][m];\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++)vis[i][j]=0;\\n        }\\n        int dx[]= {-1,0,1};\\n            int mov=0;\\n            queue<pair<int,int>> q;\\n            for (int i=0; i<n; i++){q.push({i,0});vis[i][0]=1;}\\n            while (!q.empty()){\\n                int sz= q.size();\\n                for (int iii=0; iii<sz; iii++){\\n                    int x= q.front().first;\\n                    int y= q.front().second;\\n                    q.pop();\\n                    for (int k=0; k<3; k++){\\n                        int nr= x+dx[k];\\n                        int nc= y+1;\\n                        if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]>grid[x][y] && !vis[nr][nc]){\\n                            vis[nr][nc]=1;\\n                            q.push({nr,nc});\\n                        }\\n                    }    \\n                }\\n                mov++;\\n            }\\n            ans= max(ans,mov-1);\\n        //}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522103,
                "title": "bottom-up-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can initialize a DP array of size ( m X n ) with the first column as 1. \\nOne thing to realize is that at any column j if reachable then number of moves would be j. \\n\\nWith this we can start building up our dp array. I found it easier to conceptualize building this DP array by building a column first and proceeding to the next column. So we will iterate over column first then start iterating over rows. \\n\\n### Building the DP array\\nEverytime we visit a cell in the grid we look into three cells in the preceeding column and check if any of them are less than current value. We should also check if they are reachable. If that is true we will mark the dp cell as non-zero (or j). This DP cell could also be substituted with a boolean array which would indicate whether we can reach that cell by making valid moves.\\n\\nHopefully this approach is clear, let me know if there are any doubts.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            dp[i][0] = 1\\n        res = 0\\n        for j in range(1, n):\\n            for i in range(m):\\n                if i > 0 and grid[i - 1][j - 1] < grid[i][j] and dp[i - 1][j - 1]:\\n                    res = max(res, j)\\n                    dp[i][j] = j\\n                    continue\\n                if grid[i][j - 1] < grid[i][j] and dp[i][j - 1]:\\n                    res = max(res, j)\\n                    dp[i][j] = j\\n                    continue\\n                if i < m - 1 and grid[i + 1][j - 1] < grid[i][j] and dp[i + 1][j - 1]:\\n                    res = max(res, j)\\n                    dp[i][j] = j\\n                    continue\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            dp[i][0] = 1\\n        res = 0\\n        for j in range(1, n):\\n            for i in range(m):\\n                if i > 0 and grid[i - 1][j - 1] < grid[i][j] and dp[i - 1][j - 1]:\\n                    res = max(res, j)\\n                    dp[i][j] = j\\n                    continue\\n                if grid[i][j - 1] < grid[i][j] and dp[i][j - 1]:\\n                    res = max(res, j)\\n                    dp[i][j] = j\\n                    continue\\n                if i < m - 1 and grid[i + 1][j - 1] < grid[i][j] and dp[i + 1][j - 1]:\\n                    res = max(res, j)\\n                    dp[i][j] = j\\n                    continue\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521931,
                "title": "6433-maximum-number-of-moves-in-a-grid-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int[][] dp = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n        dp[i][n-1] = 1;\\n    }\\n    for (int j = n-2; j >= 0; j--) {\\n        for (int i = 0; i < m; i++) {\\n            int maxMoves = 0;\\n            for (int k = -1; k <= 1; k++) {\\n                int newRow = i + k;\\n                int newCol = j + 1;\\n                if (newRow >= 0 && newRow < m && newCol < n && grid[newRow][newCol] > grid[i][j]) {\\n                    maxMoves = Math.max(maxMoves, dp[newRow][newCol]);\\n                }\\n            }\\n            dp[i][j] = maxMoves + 1;\\n        }\\n    }\\n    int maxMoves = 0;\\n    for (int i = 0; i < m; i++) {\\n        maxMoves = Math.max(maxMoves, dp[i][0]);\\n    }\\n\\n    return maxMoves - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int[][] dp = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n        dp[i][n-1] = 1;\\n    }\\n    for (int j = n-2; j >= 0; j--) {\\n        for (int i = 0; i < m; i++) {\\n            int maxMoves = 0;\\n            for (int k = -1; k <= 1; k++) {\\n                int newRow = i + k;\\n                int newCol = j + 1;\\n                if (newRow >= 0 && newRow < m && newCol < n && grid[newRow][newCol] > grid[i][j]) {\\n                    maxMoves = Math.max(maxMoves, dp[newRow][newCol]);\\n                }\\n            }\\n            dp[i][j] = maxMoves + 1;\\n        }\\n    }\\n    int maxMoves = 0;\\n    for (int i = 0; i < m; i++) {\\n        maxMoves = Math.max(maxMoves, dp[i][0]);\\n    }\\n\\n    return maxMoves - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521895,
                "title": "c-easy-memo-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int row,int col,int preval,vector<vector<int>>& grid, vector<vector<int>>&dp)\\n            {\\n                int n = grid.size();\\n                int m = grid[0].size();\\n                if(row>=n or row<0 or col>=m or col<0 ) return 0;\\n                \\n                int curval= grid[row][col];\\n        \\n                if(curval<=preval)return 0;\\n                if(dp[row][col]!=0)return dp[row][col];\\n        \\n                int d1= dfs(row-1,col+1,curval,grid,dp);\\n                int d2= dfs(row,col+1,curval,grid,dp);\\n                int d3= dfs(row+1,col+1,curval,grid,dp);\\n        \\n               dp[row][col]= max(d1,max(d2,d3))+1;\\n        return dp[row][col];\\n            }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int max1=0;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i =0;i<grid.size();i++)\\n        { \\n            max1= max(max1,dfs(i,0,-1,grid,dp)-1);\\n            \\n        }\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int row,int col,int preval,vector<vector<int>>& grid, vector<vector<int>>&dp)\\n            {\\n                int n = grid.size();\\n                int m = grid[0].size();\\n                if(row>=n or row<0 or col>=m or col<0 ) return 0;\\n                \\n                int curval= grid[row][col];\\n        \\n                if(curval<=preval)return 0;\\n                if(dp[row][col]!=0)return dp[row][col];\\n        \\n                int d1= dfs(row-1,col+1,curval,grid,dp);\\n                int d2= dfs(row,col+1,curval,grid,dp);\\n                int d3= dfs(row+1,col+1,curval,grid,dp);\\n        \\n               dp[row][col]= max(d1,max(d2,d3))+1;\\n        return dp[row][col];\\n            }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int max1=0;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i =0;i<grid.size();i++)\\n        { \\n            max1= max(max1,dfs(i,0,-1,grid,dp)-1);\\n            \\n        }\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053439,
                "title": "dfs-memo",
                "content": "# Intuition\\nUsing cache to store previous compute\\n\\n# Approach\\nDFS + cache\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    private int row;\\n    private int col;\\n    private int[][] cache;\\n    private int[][] directions = {{-1,1},{0,1},{1,1}};\\n    private int[][] grid;\\n    public int maxMoves(int[][] grid) {\\n        // DFS + memo\\n        row = grid.length;\\n        col = grid[0].length;\\n        this.grid = grid;\\n        cache = new int[row][col];\\n        int res = 0;\\n        for(int r = 0;r<row;r++)\\n        {\\n            \\n            res = Math.max(res,dfs(r,0));\\n            \\n        }\\n        return res;\\n    }\\n\\n    private int dfs(int r, int c)\\n    {\\n        if(!inRange(r,c)) return 0;\\n        if(cache[r][c] > 0) return cache[r][c];\\n        int currRes = 0;\\n        for(int[] direction:directions)\\n        {\\n            int nextR = r+direction[0];\\n            int nextC = c+direction[1];\\n            if(inRange(nextR, nextC) && grid[nextR][nextC] > grid[r][c])\\n            {\\n                currRes = Math.max(currRes, 1+dfs(nextR, nextC));\\n            }\\n        }\\n        cache[r][c] = currRes;\\n        return currRes;\\n    }\\n\\n    private boolean inRange(int r, int c)\\n    {\\n        return r>=0 && r < row && c>=0 && c < col;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int row;\\n    private int col;\\n    private int[][] cache;\\n    private int[][] directions = {{-1,1},{0,1},{1,1}};\\n    private int[][] grid;\\n    public int maxMoves(int[][] grid) {\\n        // DFS + memo\\n        row = grid.length;\\n        col = grid[0].length;\\n        this.grid = grid;\\n        cache = new int[row][col];\\n        int res = 0;\\n        for(int r = 0;r<row;r++)\\n        {\\n            \\n            res = Math.max(res,dfs(r,0));\\n            \\n        }\\n        return res;\\n    }\\n\\n    private int dfs(int r, int c)\\n    {\\n        if(!inRange(r,c)) return 0;\\n        if(cache[r][c] > 0) return cache[r][c];\\n        int currRes = 0;\\n        for(int[] direction:directions)\\n        {\\n            int nextR = r+direction[0];\\n            int nextC = c+direction[1];\\n            if(inRange(nextR, nextC) && grid[nextR][nextC] > grid[r][c])\\n            {\\n                currRes = Math.max(currRes, 1+dfs(nextR, nextC));\\n            }\\n        }\\n        cache[r][c] = currRes;\\n        return currRes;\\n    }\\n\\n    private boolean inRange(int r, int c)\\n    {\\n        return r>=0 && r < row && c>=0 && c < col;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048298,
                "title": "simple-java-solution-back-tracking-dp-5-ms-faster-than-94",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to dfs traverse from each row and search for max number of valid moves.\\nUse dp to store number of valid moves from each cell.\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int max = 0;\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i++)\\n            Arrays.fill(dp[i],-1);\\n        for(int i = 0; i < grid.length; i++){\\n            max = Math.max(max,dfs(grid,dp,i,0,-1));\\n        }\\n        return max;\\n\\n    }\\n\\n    public int dfs(int[][] grid, int[][] dp, int row, int col, int prev){\\n        if(col == grid[0].length || row < 0 || row >= grid.length || grid[row][col] <= prev)\\n            return -1;\\n\\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int max = Math.max(\\n            dfs(grid,dp,row-1,col+1,grid[row][col]),\\n            Math.max(\\n                dfs(grid,dp,row,col+1,grid[row][col]),\\n                dfs(grid,dp,row+1,col+1,grid[row][col])\\n            )\\n        );\\n        return dp[row][col] = max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int max = 0;\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i++)\\n            Arrays.fill(dp[i],-1);\\n        for(int i = 0; i < grid.length; i++){\\n            max = Math.max(max,dfs(grid,dp,i,0,-1));\\n        }\\n        return max;\\n\\n    }\\n\\n    public int dfs(int[][] grid, int[][] dp, int row, int col, int prev){\\n        if(col == grid[0].length || row < 0 || row >= grid.length || grid[row][col] <= prev)\\n            return -1;\\n\\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int max = Math.max(\\n            dfs(grid,dp,row-1,col+1,grid[row][col]),\\n            Math.max(\\n                dfs(grid,dp,row,col+1,grid[row][col]),\\n                dfs(grid,dp,row+1,col+1,grid[row][col])\\n            )\\n        );\\n        return dp[row][col] = max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045269,
                "title": "easy-bfs-cpp",
                "content": "# Intuition\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N * M)\\n\\n- Space complexity: O(n * m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        \\n        int ans = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,pair<int,int>>> q; // pait<<moves,pair<row,col>>>\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n\\n        for( int i=0; i<m; i++){\\n\\n            q.push({0,{i,0}});\\n\\n            int dirx[] = {-1,0,1};\\n\\n            while(!q.empty()){\\n\\n                int moves = q.front().first;\\n                int row = q.front().second.first;\\n                int col = q.front().second.second;\\n                q.pop();\\n\\n                for( int r=-1; r<=1; r++){\\n                    if( row+r>=0 && row+r<m && col+1<n)\\n                        if( !vis[row+r][col+1] && grid[row+r][col+1] > grid[row][col] ){\\n                            vis[row+r][col+1] = 1;\\n                            q.push({moves+1,{row+r,col+1}});\\n                        }\\n                }\\n\\n                ans = max(ans,moves);\\n                \\n            }\\n        }\\n       \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        \\n        int ans = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,pair<int,int>>> q; // pait<<moves,pair<row,col>>>\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n\\n        for( int i=0; i<m; i++){\\n\\n            q.push({0,{i,0}});\\n\\n            int dirx[] = {-1,0,1};\\n\\n            while(!q.empty()){\\n\\n                int moves = q.front().first;\\n                int row = q.front().second.first;\\n                int col = q.front().second.second;\\n                q.pop();\\n\\n                for( int r=-1; r<=1; r++){\\n                    if( row+r>=0 && row+r<m && col+1<n)\\n                        if( !vis[row+r][col+1] && grid[row+r][col+1] > grid[row][col] ){\\n                            vis[row+r][col+1] = 1;\\n                            q.push({moves+1,{row+r,col+1}});\\n                        }\\n                }\\n\\n                ans = max(ans,moves);\\n                \\n            }\\n        }\\n       \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029128,
                "title": "c-beats-99-80-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,int x,int y,int n,int m){\\n        if(x < 0 || y < 0 || x >= n || y >= m)\\n            return 0;\\n        if(dp[x][y] != -1)\\n            return dp[x][y];\\n        if(x - 1 >= 0 && y + 1 < m && grid[x][y] < grid[x-1][y+1])\\n            dp[x][y] = solve(grid,x-1,y+1,n,m);\\n        if(y+1 < m && grid[x][y] < grid[x][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x,y+1,n,m));\\n        if(x + 1 < n && y + 1 < m && grid[x][y] < grid[x+1][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x+1,y+1,n,m));\\n        return dp[x][y]+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(),m = grid[0].size(),ans = 0;\\n        dp = vector<vector<int>>(n,vector<int>(m,-1));\\n        for(int i = 0;i < n;i++)\\n            ans = max(ans,solve(grid,i,0,n,m));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,int x,int y,int n,int m){\\n        if(x < 0 || y < 0 || x >= n || y >= m)\\n            return 0;\\n        if(dp[x][y] != -1)\\n            return dp[x][y];\\n        if(x - 1 >= 0 && y + 1 < m && grid[x][y] < grid[x-1][y+1])\\n            dp[x][y] = solve(grid,x-1,y+1,n,m);\\n        if(y+1 < m && grid[x][y] < grid[x][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x,y+1,n,m));\\n        if(x + 1 < n && y + 1 < m && grid[x][y] < grid[x+1][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x+1,y+1,n,m));\\n        return dp[x][y]+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(),m = grid[0].size(),ans = 0;\\n        dp = vector<vector<int>>(n,vector<int>(m,-1));\\n        for(int i = 0;i < n;i++)\\n            ans = max(ans,solve(grid,i,0,n,m));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029126,
                "title": "c-beats-99-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,int x,int y,int n,int m){\\n        if(x < 0 || y < 0 || x >= n || y >= m)\\n            return 0;\\n        if(dp[x][y] != -1)\\n            return dp[x][y];\\n        if(x - 1 >= 0 && y + 1 < m && grid[x][y] < grid[x-1][y+1])\\n            dp[x][y] = solve(grid,x-1,y+1,n,m);\\n        if(y+1 < m && grid[x][y] < grid[x][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x,y+1,n,m));\\n        if(x + 1 < n && y + 1 < m && grid[x][y] < grid[x+1][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x+1,y+1,n,m));\\n        return dp[x][y]+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(),m = grid[0].size(),ans = 0;\\n        dp = vector<vector<int>>(n,vector<int>(m,-1));\\n        for(int i = 0;i < n;i++)\\n            ans = max(ans,solve(grid,i,0,n,m));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,int x,int y,int n,int m){\\n        if(x < 0 || y < 0 || x >= n || y >= m)\\n            return 0;\\n        if(dp[x][y] != -1)\\n            return dp[x][y];\\n        if(x - 1 >= 0 && y + 1 < m && grid[x][y] < grid[x-1][y+1])\\n            dp[x][y] = solve(grid,x-1,y+1,n,m);\\n        if(y+1 < m && grid[x][y] < grid[x][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x,y+1,n,m));\\n        if(x + 1 < n && y + 1 < m && grid[x][y] < grid[x+1][y+1])\\n            dp[x][y] = max(dp[x][y],solve(grid,x+1,y+1,n,m));\\n        return dp[x][y]+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(),m = grid[0].size(),ans = 0;\\n        dp = vector<vector<int>>(n,vector<int>(m,-1));\\n        for(int i = 0;i < n;i++)\\n            ans = max(ans,solve(grid,i,0,n,m));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005466,
                "title": "simple-memoization-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,int pre,vector<vector<int>>&dp){\\n        if(i<0 || i>=n || j>=m || grid[i][j]<=pre){\\n            return -1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int a=solve(i-1,j+1,n,m,grid,grid[i][j],dp);\\n        int b=solve(i,j+1,n,m,grid,grid[i][j],dp);\\n        int c=solve(i+1,j+1,n,m,grid,grid[i][j],dp);\\n\\n        return dp[i][j]=1+max(max(a,b),c);\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,solve(i,0,n,m,grid,INT_MIN,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,int pre,vector<vector<int>>&dp){\\n        if(i<0 || i>=n || j>=m || grid[i][j]<=pre){\\n            return -1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int a=solve(i-1,j+1,n,m,grid,grid[i][j],dp);\\n        int b=solve(i,j+1,n,m,grid,grid[i][j],dp);\\n        int c=solve(i+1,j+1,n,m,grid,grid[i][j],dp);\\n\\n        return dp[i][j]=1+max(max(a,b),c);\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,solve(i,0,n,m,grid,INT_MIN,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002519,
                "title": "c-tabulation",
                "content": "Just normal DP problem \\n# Complexity\\n- Time complexity:\\nO(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n2*O(N) ~ O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        vector<int> prev(grid.size(), 0);\\n        int maxi = 0;\\n        for(int i=1;i<grid[0].size();i++) {\\n            vector<int> curr(grid.size(), 0);\\n            for(int j=0;j<grid.size();j++) {\\n                if(j>0 && grid[j][i] > grid[j-1][i-1] ) {\\n                    curr[j] = max(curr[j], prev[j-1]+1);\\n                }\\n                if(j<(grid.size()-1) && grid[j][i] > grid[j+1][i-1]) {\\n                    curr[j] = max(curr[j], prev[j+1]+1);\\n                }\\n                if(grid[j][i] > grid[j][i-1])\\n                    curr[j] = max(curr[j], prev[j] + 1);\\n                if(curr[j] == 0) {\\n                    curr[j] = INT_MIN;\\n                }\\n                maxi = max(curr[j], maxi);\\n            }\\n            prev = curr;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        vector<int> prev(grid.size(), 0);\\n        int maxi = 0;\\n        for(int i=1;i<grid[0].size();i++) {\\n            vector<int> curr(grid.size(), 0);\\n            for(int j=0;j<grid.size();j++) {\\n                if(j>0 && grid[j][i] > grid[j-1][i-1] ) {\\n                    curr[j] = max(curr[j], prev[j-1]+1);\\n                }\\n                if(j<(grid.size()-1) && grid[j][i] > grid[j+1][i-1]) {\\n                    curr[j] = max(curr[j], prev[j+1]+1);\\n                }\\n                if(grid[j][i] > grid[j][i-1])\\n                    curr[j] = max(curr[j], prev[j] + 1);\\n                if(curr[j] == 0) {\\n                    curr[j] = INT_MIN;\\n                }\\n                maxi = max(curr[j], maxi);\\n            }\\n            prev = curr;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998790,
                "title": "python-dp-solution",
                "content": "# Intuition\\nTypical Dynamic Programming Approach\\n\\n# Approach\\n\\nInitalize DP 2D array all 0\\'s -> DP[row][column] = maximum cnt ending at grid[row][column]\\n\\nIterating backwards, from the last column last row to 0 column first row, and check the values in reverse conditions.\\n\\nreturn max in dp[row][column] where column = 0\\n\\n# Complexity\\n- Time complexity:\\nO(mn) \\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        row = len(grid)\\n        col = len(grid[0])\\n\\n        dp = [[0 for _ in range(col)] for _ in range(row)]\\n\\n        res = 0\\n        for c in range(col-1,-1,-1):\\n\\n            for r in range(row-1,-1,-1):\\n                if r >= 1 and c < col-1 and grid[r][c] < grid[r-1][c+1]:\\n                    dp[r][c] = max(dp[r][c], 1+dp[r-1][c+1])\\n                \\n                if c < col-1 and grid[r][c] < grid[r][c+1]:\\n                    dp[r][c] = max(dp[r][c], 1+dp[r][c+1])\\n                \\n                if r < row-1 and c < col-1 and grid[r][c] < grid[r+1][c+1]:\\n                    dp[r][c] = max(dp[r][c], 1+dp[r+1][c+1])\\n            \\n                if c==0:\\n                    res = max(res, dp[r][0])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        row = len(grid)\\n        col = len(grid[0])\\n\\n        dp = [[0 for _ in range(col)] for _ in range(row)]\\n\\n        res = 0\\n        for c in range(col-1,-1,-1):\\n\\n            for r in range(row-1,-1,-1):\\n                if r >= 1 and c < col-1 and grid[r][c] < grid[r-1][c+1]:\\n                    dp[r][c] = max(dp[r][c], 1+dp[r-1][c+1])\\n                \\n                if c < col-1 and grid[r][c] < grid[r][c+1]:\\n                    dp[r][c] = max(dp[r][c], 1+dp[r][c+1])\\n                \\n                if r < row-1 and c < col-1 and grid[r][c] < grid[r+1][c+1]:\\n                    dp[r][c] = max(dp[r][c], 1+dp[r+1][c+1])\\n            \\n                if c==0:\\n                    res = max(res, dp[r][0])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984659,
                "title": "java-solution-using-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m=Integer.MIN_VALUE;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            m=Math.max(m,mov(i,0,grid,Integer.MIN_VALUE,vis));\\n        }    \\n        return m-1;\\n    }\\n    int mov(int i,int j,int g[][],int p,int vis[][]){\\n\\n        if(i<0 || j<0 || i>=g.length || j>=g[0].length || g[i][j]<=p || vis[i][j]==1){\\n            return 0;\\n        }\\n        vis[i][j]=1;\\n        int ur=1+mov(i-1,j+1,g,g[i][j],vis);\\n        int dr=1+mov(i+1,j+1,g,g[i][j],vis);\\n        int r=1+mov(i,j+1,g,g[i][j],vis);\\n        return Math.max(ur,Math.max(dr,r));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m=Integer.MIN_VALUE;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            m=Math.max(m,mov(i,0,grid,Integer.MIN_VALUE,vis));\\n        }    \\n        return m-1;\\n    }\\n    int mov(int i,int j,int g[][],int p,int vis[][]){\\n\\n        if(i<0 || j<0 || i>=g.length || j>=g[0].length || g[i][j]<=p || vis[i][j]==1){\\n            return 0;\\n        }\\n        vis[i][j]=1;\\n        int ur=1+mov(i-1,j+1,g,g[i][j],vis);\\n        int dr=1+mov(i+1,j+1,g,g[i][j],vis);\\n        int r=1+mov(i,j+1,g,g[i][j],vis);\\n        return Math.max(ur,Math.max(dr,r));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933219,
                "title": "java-dp-tabular-solution-using-2-arrays-each-of-size-m-time-complexity-o-n-m-spacecompelxity-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*m) where m=no. of rows\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        int dp[][]=new int[m][n];\\n        int ans=0;\\n        int dr[]={-1,0,1};\\n\\n        int prev[]=new int[m];\\n        int curr[]=new int[m];\\n\\n        \\n        for(int j=n-2;j>=0;j--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int k=0;k<3;k++)\\n                {\\n                    int row=i+dr[k];\\n                    if(row>=0 && row<m && grid[row][j+1]>grid[i][j])\\n                    {\\n                        // dp[i][j]=Math.max(dp[i][j],1+dp[row][j+1]);\\n                        curr[i]=Math.max(curr[i],1+prev[row]);\\n                    }\\n                }\\n                if(j==0)\\n                {\\n                    ans=Math.max(ans,curr[i]);\\n                }\\n            \\n            }\\n            for(int i=0;i<m;i++)\\n            {\\n                prev[i]=curr[i];\\n                curr[i]=0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        int dp[][]=new int[m][n];\\n        int ans=0;\\n        int dr[]={-1,0,1};\\n\\n        int prev[]=new int[m];\\n        int curr[]=new int[m];\\n\\n        \\n        for(int j=n-2;j>=0;j--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int k=0;k<3;k++)\\n                {\\n                    int row=i+dr[k];\\n                    if(row>=0 && row<m && grid[row][j+1]>grid[i][j])\\n                    {\\n                        // dp[i][j]=Math.max(dp[i][j],1+dp[row][j+1]);\\n                        curr[i]=Math.max(curr[i],1+prev[row]);\\n                    }\\n                }\\n                if(j==0)\\n                {\\n                    ans=Math.max(ans,curr[i]);\\n                }\\n            \\n            }\\n            for(int i=0;i<m;i++)\\n            {\\n                prev[i]=curr[i];\\n                curr[i]=0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929981,
                "title": "c-dfs-beats-90-88",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        vector<int>delrow={-1,0,1};\\n        vector<int>delcol={1,1,1};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          int count=solve(grid,i,0,n,m,delrow,delcol,INT_MIN);\\n          \\n          ans=max(ans,count-1);\\n        }\\n        return ans;\\n        \\n    }\\n    int solve(vector<vector<int>>&v,int i,int j,int n,int m,vector<int>&delrow,vector<int>&delcol,int p)\\n    {\\n        if(i<0||j<0||i>=n||j>=m||v[i][j]<=p)\\n        {\\n          return 0;\\n        }\\n        int value=v[i][j];\\n        v[i][j]=0;\\n        return max({solve(v,i-1,j+1,n,m,delrow,delcol,value),solve(v,i,j+1,n,m,delrow,delcol,value),solve(v,i+1,j+1,n,m,delrow,delcol,value)})+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        vector<int>delrow={-1,0,1};\\n        vector<int>delcol={1,1,1};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          int count=solve(grid,i,0,n,m,delrow,delcol,INT_MIN);\\n          \\n          ans=max(ans,count-1);\\n        }\\n        return ans;\\n        \\n    }\\n    int solve(vector<vector<int>>&v,int i,int j,int n,int m,vector<int>&delrow,vector<int>&delcol,int p)\\n    {\\n        if(i<0||j<0||i>=n||j>=m||v[i][j]<=p)\\n        {\\n          return 0;\\n        }\\n        int value=v[i][j];\\n        v[i][j]=0;\\n        return max({solve(v,i-1,j+1,n,m,delrow,delcol,value),solve(v,i,j+1,n,m,delrow,delcol,value),solve(v,i+1,j+1,n,m,delrow,delcol,value)})+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915548,
                "title": "easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        \\n        vector<vector<int>>v(m,vector<int>(n,0));\\n        int level=0;\\n        int ans=INT_MIN;\\n        vector<pair<int,int>>dirs={{-1,1},{0,1},{1,1}};\\n        queue<pair<int,pair<int,int>>>q;\\n        for(int i=0;i<m;i++){\\n            v[i][0]=1;\\n            q.push({1,{i,0}});\\n        }\\n            while(!q.empty()){\\n            // int level=0;\\n            auto x=q.front().second;\\n            auto cnt=q.front().first;\\n            q.pop();\\n            for(auto dir:dirs){\\n                int a=x.first+dir.first;\\n                int b=x.second+dir.second;\\n                // cout<<a<<\" \"<<b<<endl;\\n                if(a>=m || a<0 || b>=n|| b<0 )continue;\\n                else{\\n                    if(grid[a][b]<grid[x.first][x.second])continue;\\n                    if(v[a][b]==0 && grid[a][b]>grid[x.first][x.second]){\\n                        q.push({cnt+1,{a,b}});\\n                        v[a][b]=cnt+1;\\n                    }\\n                    else if(v[a][b]!=0 && grid[a][b]>grid[x.first][x.second]){\\n                        cout<<a<<\" \"<<b<<\" \"<<v[a][b]<<endl;\\n                    }\\n                }   \\n            }\\n            // cout<<cnt<<endl;\\n            ans=max(ans,cnt);\\n        }\\n        \\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        \\n        vector<vector<int>>v(m,vector<int>(n,0));\\n        int level=0;\\n        int ans=INT_MIN;\\n        vector<pair<int,int>>dirs={{-1,1},{0,1},{1,1}};\\n        queue<pair<int,pair<int,int>>>q;\\n        for(int i=0;i<m;i++){\\n            v[i][0]=1;\\n            q.push({1,{i,0}});\\n        }\\n            while(!q.empty()){\\n            // int level=0;\\n            auto x=q.front().second;\\n            auto cnt=q.front().first;\\n            q.pop();\\n            for(auto dir:dirs){\\n                int a=x.first+dir.first;\\n                int b=x.second+dir.second;\\n                // cout<<a<<\" \"<<b<<endl;\\n                if(a>=m || a<0 || b>=n|| b<0 )continue;\\n                else{\\n                    if(grid[a][b]<grid[x.first][x.second])continue;\\n                    if(v[a][b]==0 && grid[a][b]>grid[x.first][x.second]){\\n                        q.push({cnt+1,{a,b}});\\n                        v[a][b]=cnt+1;\\n                    }\\n                    else if(v[a][b]!=0 && grid[a][b]>grid[x.first][x.second]){\\n                        cout<<a<<\" \"<<b<<\" \"<<v[a][b]<<endl;\\n                    }\\n                }   \\n            }\\n            // cout<<cnt<<endl;\\n            ans=max(ans,cnt);\\n        }\\n        \\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3901086,
                "title": "c-clean-easy-code-dp-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:int f=0;\\n    int t(int i,int j,vector<vector<int>>& g,vector<vector<int>> &v,int p)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n        return 0;\\n        if(v[i][j]!=-1)\\n        return v[i][j];\\n        \\n        int a=0,b=0,c=0;\\n        if(i-1>=0 && j+1<g[0].size() && g[i-1][j+1]>p) \\n        a=1+t(i-1,j+1,g,v,g[i-1][j+1]);\\n        if(i>=0 && j+1<g[0].size() && g[i][j+1]>p) \\n        b=1+t(i,j+1,g,v,g[i][j+1]);\\n        if(i+1<g.size() && j+1<g[0].size() && g[i+1][j+1]>p) \\n        c=1+t(i+1,j+1,g,v,g[i+1][j+1]);\\n\\n        return v[i][j]=max(a,max(b,c));\\n    }\\n    int maxMoves(vector<vector<int>>& g) {\\n        int m=g.size();\\n        int n=g[0].size();\\n        vector<vector<int>> v(1+m,vector<int> (1+n,-1));\\n        for(int i=0;i<m;i++)\\n            f=max(f,t(i,0,g,v,g[i][0]));\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:int f=0;\\n    int t(int i,int j,vector<vector<int>>& g,vector<vector<int>> &v,int p)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n        return 0;\\n        if(v[i][j]!=-1)\\n        return v[i][j];\\n        \\n        int a=0,b=0,c=0;\\n        if(i-1>=0 && j+1<g[0].size() && g[i-1][j+1]>p) \\n        a=1+t(i-1,j+1,g,v,g[i-1][j+1]);\\n        if(i>=0 && j+1<g[0].size() && g[i][j+1]>p) \\n        b=1+t(i,j+1,g,v,g[i][j+1]);\\n        if(i+1<g.size() && j+1<g[0].size() && g[i+1][j+1]>p) \\n        c=1+t(i+1,j+1,g,v,g[i+1][j+1]);\\n\\n        return v[i][j]=max(a,max(b,c));\\n    }\\n    int maxMoves(vector<vector<int>>& g) {\\n        int m=g.size();\\n        int n=g[0].size();\\n        vector<vector<int>> v(1+m,vector<int> (1+n,-1));\\n        for(int i=0;i<m;i++)\\n            f=max(f,t(i,0,g,v,g[i][0]));\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899024,
                "title": "maximum-number-of-moves-in-a-grid-java",
                "content": "\\n# Complexity\\n- Time complexity: O(M * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M * N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int helper(int[][] grid, int i, int j, int m, int n, int[][] dp) {\\n        if (dp[i][j] != -1) return dp[i][j];\\n\\n        int down = 0, cent = 0, right = 0;\\n        if (i - 1 >= 0 && j + 1 < n && grid[i][j] < grid[i - 1][j + 1]) {\\n            right = 1 + helper(grid, i - 1, j + 1, m, n, dp);\\n        }\\n        if (j + 1 < n && grid[i][j] < grid[i][j + 1]) {\\n            down = 1 + helper(grid, i, j + 1, m, n, dp);\\n        }\\n        if (i + 1 < m && j + 1 < n && grid[i][j] < grid[i + 1][j + 1]) {\\n            cent = 1 + helper(grid, i + 1, j + 1, m, n, dp);\\n        }\\n        dp[i][j] = Math.max(right, Math.max(down, cent));\\n        return dp[i][j];\\n    }\\n\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n]; \\n        for (int[] rows : dp) {\\n            Arrays.fill(rows, -1);\\n        }\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            int res = helper(grid, i, 0, m, n, dp);\\n            max = Math.max(max, res);\\n        }\\n        return max; \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int helper(int[][] grid, int i, int j, int m, int n, int[][] dp) {\\n        if (dp[i][j] != -1) return dp[i][j];\\n\\n        int down = 0, cent = 0, right = 0;\\n        if (i - 1 >= 0 && j + 1 < n && grid[i][j] < grid[i - 1][j + 1]) {\\n            right = 1 + helper(grid, i - 1, j + 1, m, n, dp);\\n        }\\n        if (j + 1 < n && grid[i][j] < grid[i][j + 1]) {\\n            down = 1 + helper(grid, i, j + 1, m, n, dp);\\n        }\\n        if (i + 1 < m && j + 1 < n && grid[i][j] < grid[i + 1][j + 1]) {\\n            cent = 1 + helper(grid, i + 1, j + 1, m, n, dp);\\n        }\\n        dp[i][j] = Math.max(right, Math.max(down, cent));\\n        return dp[i][j];\\n    }\\n\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n]; \\n        for (int[] rows : dp) {\\n            Arrays.fill(rows, -1);\\n        }\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            int res = helper(grid, i, 0, m, n, dp);\\n            max = Math.max(max, res);\\n        }\\n        return max; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891018,
                "title": "c-dfs-memoization-faster-than-99-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int help(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp, int prev){\\n        \\n        if(i==grid.size() || i<0 || grid[i][j]<=prev){\\n            return INT_MIN;\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        if(j==grid[0].size()-1){\\n            return 0;\\n        }\\n\\n        int a = 1+ help(i, j+1, grid, dp, grid[i][j]);\\n        a = max(a, 1+help(i+1, j+1, grid, dp, grid[i][j]));\\n        a = max(a, 1+help(i-1, j+1, grid, dp, grid[i][j]));\\n\\n        if(a<0){\\n            return dp[i][j]=0;\\n        }\\n\\n        return dp[i][j]=a;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n\\n        int res = 0;\\n\\n        for(int i=0; i<n; i++){\\n            res = max(res, help(i, 0, grid, dp, INT_MIN));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int help(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp, int prev){\\n        \\n        if(i==grid.size() || i<0 || grid[i][j]<=prev){\\n            return INT_MIN;\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        if(j==grid[0].size()-1){\\n            return 0;\\n        }\\n\\n        int a = 1+ help(i, j+1, grid, dp, grid[i][j]);\\n        a = max(a, 1+help(i+1, j+1, grid, dp, grid[i][j]));\\n        a = max(a, 1+help(i-1, j+1, grid, dp, grid[i][j]));\\n\\n        if(a<0){\\n            return dp[i][j]=0;\\n        }\\n\\n        return dp[i][j]=a;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n\\n        int res = 0;\\n\\n        for(int i=0; i<n; i++){\\n            res = max(res, help(i, 0, grid, dp, INT_MIN));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887266,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] dp = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            ans = Math.max(ans,dfs(grid,i,0,0,dp));\\n        }\\n        return ans-1;\\n    }\\n    private int dfs(int [][] grid, int row, int col,int prev,int [][] dp){\\n        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length || prev>=grid[row][col]){\\n            return 0;\\n        }\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res = 0;\\n        res= Math.max(res,1+dfs(grid,row-1,col+1,grid[row][col],dp));\\n        res= Math.max(res,1+dfs(grid,row,col+1,grid[row][col],dp));\\n        res= Math.max(res,1+dfs(grid,row+1,col+1,grid[row][col],dp));\\n        dp[row][col] = res;\\n        return dp[row][col];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] dp = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            ans = Math.max(ans,dfs(grid,i,0,0,dp));\\n        }\\n        return ans-1;\\n    }\\n    private int dfs(int [][] grid, int row, int col,int prev,int [][] dp){\\n        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length || prev>=grid[row][col]){\\n            return 0;\\n        }\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res = 0;\\n        res= Math.max(res,1+dfs(grid,row-1,col+1,grid[row][col],dp));\\n        res= Math.max(res,1+dfs(grid,row,col+1,grid[row][col],dp));\\n        res= Math.max(res,1+dfs(grid,row+1,col+1,grid[row][col],dp));\\n        dp[row][col] = res;\\n        return dp[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880864,
                "title": "c-bottom-up-dp-commented-easy",
                "content": "# Approach\\nTop down DP.\\ndp[i][j]: max moves we can make starting from i, j and moveing forward.\\nFrom any cell in the 0th row, we can move either left or diagonally up.\\nFrom any cell in last row, we can move either left or diagonally down.\\nFrom any other \"middle\" cell, we can move left, diagonally up or diagonally down.\\n\\nUse this to form the dp reccurance.\\n\\n**UPVOTE IF THIS HELPED! :))**\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n\\n    int maxMoves(vector<vector<int>> &grid){\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // dp[i][j]: max moves we can make starting from i, j and moveing fwd\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n\\n        // initialize last column with 0\\n\\n        for(int j=m-2; j>=0; j--){\\n            for(int i=0; i<n; i++){\\n                // to fill dp[i][j]\\n                if(i == 0){\\n                    // 0th row has only 2 options\\n                    if(grid[i][j] < grid[i][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i][j+1]);\\n                    }\\n\\n                    if(grid[i][j] < grid[i+1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i+1][j+1]);\\n                    }\\n                }\\n                else if(i == n-1){\\n                    // last row has only 2 options\\n                    if(grid[i][j] < grid[i][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i][j+1]);\\n                    }\\n\\n                    if(grid[i][j] < grid[i-1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i-1][j+1]);\\n                    }\\n                }\\n                else{\\n                    // middle cells have 3 options\\n                    if(grid[i][j] < grid[i][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i][j+1]);\\n                    }\\n                    if(grid[i][j] < grid[i-1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i-1][j+1]);\\n                    }\\n                    if(grid[i][j] < grid[i+1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i+1][j+1]);\\n                    }\\n\\n                }\\n\\n            }\\n            \\n        }\\n\\n\\n        // find max value in 0th column\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            ans = max(ans, dp[i][0]);\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n\\n    int maxMoves(vector<vector<int>> &grid){\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // dp[i][j]: max moves we can make starting from i, j and moveing fwd\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n\\n        // initialize last column with 0\\n\\n        for(int j=m-2; j>=0; j--){\\n            for(int i=0; i<n; i++){\\n                // to fill dp[i][j]\\n                if(i == 0){\\n                    // 0th row has only 2 options\\n                    if(grid[i][j] < grid[i][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i][j+1]);\\n                    }\\n\\n                    if(grid[i][j] < grid[i+1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i+1][j+1]);\\n                    }\\n                }\\n                else if(i == n-1){\\n                    // last row has only 2 options\\n                    if(grid[i][j] < grid[i][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i][j+1]);\\n                    }\\n\\n                    if(grid[i][j] < grid[i-1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i-1][j+1]);\\n                    }\\n                }\\n                else{\\n                    // middle cells have 3 options\\n                    if(grid[i][j] < grid[i][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i][j+1]);\\n                    }\\n                    if(grid[i][j] < grid[i-1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i-1][j+1]);\\n                    }\\n                    if(grid[i][j] < grid[i+1][j+1]){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i+1][j+1]);\\n                    }\\n\\n                }\\n\\n            }\\n            \\n        }\\n\\n\\n        // find max value in 0th column\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            ans = max(ans, dp[i][0]);\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869743,
                "title": "readable-swift-solution-w-thought-process-o-m-n",
                "content": "# Code\\n```\\nclass Solution {\\n    // First Pass: there is going to be some sort of dynamic programming angle here...\\n    // I think we want to work out solutions going from the right most column\\n    // back to the leftmost column, and this way we can re-use the results\\n    // we have already computed\\n    func maxMoves(_ grid: [[Int]]) -> Int {\\n        let numCols = grid[0].count\\n        let numRows = grid.count\\n        var solutions: [[Int]] = Array(\\n            repeating: Array(repeating: 0, count: numCols), \\n            count: numRows)\\n        for col in stride(from:numCols-1, through:0, by:-1) {\\n            for row in (0..<numRows) {\\n                let value = grid[row][col]\\n                let moves = [\\n                    (row - 1, col + 1),\\n                    (row, col + 1),\\n                    (row + 1, col + 1)\\n                ]\\n\\n                for (mRow, mCol) in moves {\\n                    if mRow >= numRows || mCol >= numCols || mRow < 0 {\\n                        continue\\n                    }\\n\\n                    if value < grid[mRow][mCol] {\\n                        solutions[row][col] = max(solutions[mRow][mCol] + 1, solutions[row][col])\\n                    }\\n                }\\n            }\\n        }\\n\\n        return solutions.map({ $0.first! }).max()!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // First Pass: there is going to be some sort of dynamic programming angle here...\\n    // I think we want to work out solutions going from the right most column\\n    // back to the leftmost column, and this way we can re-use the results\\n    // we have already computed\\n    func maxMoves(_ grid: [[Int]]) -> Int {\\n        let numCols = grid[0].count\\n        let numRows = grid.count\\n        var solutions: [[Int]] = Array(\\n            repeating: Array(repeating: 0, count: numCols), \\n            count: numRows)\\n        for col in stride(from:numCols-1, through:0, by:-1) {\\n            for row in (0..<numRows) {\\n                let value = grid[row][col]\\n                let moves = [\\n                    (row - 1, col + 1),\\n                    (row, col + 1),\\n                    (row + 1, col + 1)\\n                ]\\n\\n                for (mRow, mCol) in moves {\\n                    if mRow >= numRows || mCol >= numCols || mRow < 0 {\\n                        continue\\n                    }\\n\\n                    if value < grid[mRow][mCol] {\\n                        solutions[row][col] = max(solutions[mRow][mCol] + 1, solutions[row][col])\\n                    }\\n                }\\n            }\\n        }\\n\\n        return solutions.map({ $0.first! }).max()!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863608,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int f(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\\n        if(j==m-1) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int st=0;\\n        int up=0;\\n        int down=0;\\n        if(j<m-1 && grid[i][j]<grid[i][j+1]) st=f(i,j+1,n,m,grid,dp);\\n        if(i-1>=0 && j<m-1 && grid[i][j]<grid[i-1][j+1]) up=f(i-1,j+1,n,m,grid,dp);\\n        if(i<n-1 && j<m-1 && grid[i][j]<grid[i+1][j+1]) down=f(i+1,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=max(st,max(up,down))+1;\\n\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,f(i,0,n,m,grid,dp));\\n        }\\n        return (maxi<0)?0:maxi-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int f(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\\n        if(j==m-1) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int st=0;\\n        int up=0;\\n        int down=0;\\n        if(j<m-1 && grid[i][j]<grid[i][j+1]) st=f(i,j+1,n,m,grid,dp);\\n        if(i-1>=0 && j<m-1 && grid[i][j]<grid[i-1][j+1]) up=f(i-1,j+1,n,m,grid,dp);\\n        if(i<n-1 && j<m-1 && grid[i][j]<grid[i+1][j+1]) down=f(i+1,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=max(st,max(up,down))+1;\\n\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,f(i,0,n,m,grid,dp));\\n        }\\n        return (maxi<0)?0:maxi-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858745,
                "title": "bfs-with-heap-approach-beats-99-runtime",
                "content": "# Approach\\nAdded optimization of using a min heap in BFS. We always pop off the furthest right column we\\'ve reached so far. \\n\\nThe idea is that we don\\'t need to find all possible paths, we only need to find a single path that gets across. If we make it all the way across the grid, we know that\\'s the max possible steps.\\n\\nThis is more efficient that DP or memoization solutions.\\n\\n# Code\\n```\\n# Leetcode 2684. Maximum Number of Moves in a Grid\\n# https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/\\n\\nfrom typing import List\\nfrom heapq import heappop, heappush, heapify\\n\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        # must move right a column on each step\\n        # Next value must be strictly larger\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        \\n        # Min heap to always look at further column we\\'ve reached so far\\n        # Heap stores in form (-c, r)\\n        h = [(0, i) for i in range(NR)]\\n        heapify(h)\\n        seen = set()\\n        \\n        maxc = 0 # Max column we\\'ve reached so far\\n        while h:\\n            c, r = heappop(h)\\n            c *= -1 # flip column back to positive\\n            if c == NC-1: # reached end - return early\\n                return c\\n            \\n            seen.add((r,c))\\n            maxc = max(maxc, c)\\n            for dr in (-1, 0, 1):\\n                nr = r + dr\\n                if 0 <= nr < NR and grid[r][c] < grid[nr][c+1] and (nr, c+1) not in seen:\\n                    heappush(h, (-c-1, nr))\\n            \\n        return maxc\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Leetcode 2684. Maximum Number of Moves in a Grid\\n# https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/\\n\\nfrom typing import List\\nfrom heapq import heappop, heappush, heapify\\n\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        # must move right a column on each step\\n        # Next value must be strictly larger\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        \\n        # Min heap to always look at further column we\\'ve reached so far\\n        # Heap stores in form (-c, r)\\n        h = [(0, i) for i in range(NR)]\\n        heapify(h)\\n        seen = set()\\n        \\n        maxc = 0 # Max column we\\'ve reached so far\\n        while h:\\n            c, r = heappop(h)\\n            c *= -1 # flip column back to positive\\n            if c == NC-1: # reached end - return early\\n                return c\\n            \\n            seen.add((r,c))\\n            maxc = max(maxc, c)\\n            for dr in (-1, 0, 1):\\n                nr = r + dr\\n                if 0 <= nr < NR and grid[r][c] < grid[nr][c+1] and (nr, c+1) not in seen:\\n                    heappush(h, (-c-1, nr))\\n            \\n        return maxc\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857033,
                "title": "java-dfs-memoization-commented-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar pattern: https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int ROW;\\n    int COL;\\n\\n    Integer[][] memo;\\n\\n    boolean isOutOfBounds(int row, int col){\\n        return row < 0 || row >= ROW || col < 0 || col >= COL;\\n    }\\n\\n    int helper(int[][] grid, int row, int col, int prevVal){\\n\\n        //return 0 as moves, if the curr row & col \\'isOutOfBounds\\'\\n        if(isOutOfBounds(row, col)) return 0;\\n\\n        //as we need to maintain a STRICTLY INCREASING paths as we move from a cell\\n        //from prev col to a new cell in the next col\\n        //now if the curr cell value grid[row][col] is smaller or equal to prev\\n        //cell value \\'prevVal\\' it is not making a STRICTLY INCREASING path\\n        //hence return 0 as moves\\n        if(prevVal >= grid[row][col]) return 0;\\n\\n        //memo[][] will store the moves count for the curr cell(row, col) that \\n        //tells from this curr cell, what is the longest STRICTLY INCREASING path\\n        //and how much is the moves in that path\\n        if(memo[row][col] != null) return memo[row][col];\\n\\n        int currMoves = 0;\\n\\n        //allowed movements we have from the curr cell(row, col)\\n        //TOP-RIGHT CELL (row - 1, col + 1)\\n        currMoves = Math.max(currMoves, 1 + helper(grid, row - 1, col + 1, grid[row][col]));\\n\\n        //RIGHT CELL (row, col + 1)\\n        currMoves = Math.max(currMoves, 1 + helper(grid, row, col + 1, grid[row][col]));\\n\\n        //BOTTOM-RIGHT CELL (row + 1, col + 1)\\n        currMoves = Math.max(currMoves, 1 + helper(grid, row + 1, col + 1, grid[row][col]));\\n        \\n        return memo[row][col] = currMoves;\\n    }\\n\\n    public int maxMoves(int[][] grid) {\\n        \\n        ROW = grid.length;\\n        COL = grid[0].length;\\n\\n        memo = new Integer[ROW][COL];\\n\\n        int maxMoves = 0;\\n\\n        for(int row = 0; row < ROW; row++){\\n            maxMoves = Math.max(maxMoves, helper(grid, row, 0, -1));\\n        }\\n\\n        //since we started from the col == 0, but moves calculations is actually\\n        //required from col == 0 + 1 so with above maxMoves we are also calculating\\n        //the moves for col == 0 hence do -1 to exclude that move \\n        return maxMoves - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ROW;\\n    int COL;\\n\\n    Integer[][] memo;\\n\\n    boolean isOutOfBounds(int row, int col){\\n        return row < 0 || row >= ROW || col < 0 || col >= COL;\\n    }\\n\\n    int helper(int[][] grid, int row, int col, int prevVal){\\n\\n        //return 0 as moves, if the curr row & col \\'isOutOfBounds\\'\\n        if(isOutOfBounds(row, col)) return 0;\\n\\n        //as we need to maintain a STRICTLY INCREASING paths as we move from a cell\\n        //from prev col to a new cell in the next col\\n        //now if the curr cell value grid[row][col] is smaller or equal to prev\\n        //cell value \\'prevVal\\' it is not making a STRICTLY INCREASING path\\n        //hence return 0 as moves\\n        if(prevVal >= grid[row][col]) return 0;\\n\\n        //memo[][] will store the moves count for the curr cell(row, col) that \\n        //tells from this curr cell, what is the longest STRICTLY INCREASING path\\n        //and how much is the moves in that path\\n        if(memo[row][col] != null) return memo[row][col];\\n\\n        int currMoves = 0;\\n\\n        //allowed movements we have from the curr cell(row, col)\\n        //TOP-RIGHT CELL (row - 1, col + 1)\\n        currMoves = Math.max(currMoves, 1 + helper(grid, row - 1, col + 1, grid[row][col]));\\n\\n        //RIGHT CELL (row, col + 1)\\n        currMoves = Math.max(currMoves, 1 + helper(grid, row, col + 1, grid[row][col]));\\n\\n        //BOTTOM-RIGHT CELL (row + 1, col + 1)\\n        currMoves = Math.max(currMoves, 1 + helper(grid, row + 1, col + 1, grid[row][col]));\\n        \\n        return memo[row][col] = currMoves;\\n    }\\n\\n    public int maxMoves(int[][] grid) {\\n        \\n        ROW = grid.length;\\n        COL = grid[0].length;\\n\\n        memo = new Integer[ROW][COL];\\n\\n        int maxMoves = 0;\\n\\n        for(int row = 0; row < ROW; row++){\\n            maxMoves = Math.max(maxMoves, helper(grid, row, 0, -1));\\n        }\\n\\n        //since we started from the col == 0, but moves calculations is actually\\n        //required from col == 0 + 1 so with above maxMoves we are also calculating\\n        //the moves for col == 0 hence do -1 to exclude that move \\n        return maxMoves - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854583,
                "title": "simple-dfs-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def solve(self,grid,i,j,prev,vis):\\n        if(i<0 or i>=len(grid) or j<0 or j>=len(grid[0]) or grid[i][j]<=prev or vis[i][j]==1):\\n            return 0\\n        vis[i][j]=1\\n        a=self.solve(grid,i-1,j+1,grid[i][j],vis)\\n        b=self.solve(grid,i,j+1,grid[i][j],vis)\\n        c=self.solve(grid,i+1,j+1,grid[i][j],vis)\\n        return 1+max(a,b,c)\\n\\n    def maxMoves(self, grid):\\n        ans=-sys.maxsize\\n        vis=[[0 for i in range(len(grid[0]))] for i in range(len(grid))]\\n        for i in range(len(grid)):\\n            ans=max(ans,self.solve(grid,i,0,-1,vis))\\n        return ans-1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def solve(self,grid,i,j,prev,vis):\\n        if(i<0 or i>=len(grid) or j<0 or j>=len(grid[0]) or grid[i][j]<=prev or vis[i][j]==1):\\n            return 0\\n        vis[i][j]=1\\n        a=self.solve(grid,i-1,j+1,grid[i][j],vis)\\n        b=self.solve(grid,i,j+1,grid[i][j],vis)\\n        c=self.solve(grid,i+1,j+1,grid[i][j],vis)\\n        return 1+max(a,b,c)\\n\\n    def maxMoves(self, grid):\\n        ans=-sys.maxsize\\n        vis=[[0 for i in range(len(grid[0]))] for i in range(len(grid))]\\n        for i in range(len(grid)):\\n            ans=max(ans,self.solve(grid,i,0,-1,vis))\\n        return ans-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837383,
                "title": "java-simple-solution-to-understand-pure-dfs-beats-98",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    private final int[][] dirs = new int[][]{{-1,1}, {0,1}, {1,1}};\\n    private int maxMoves = 0;\\n\\n    public int maxMoves(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean visited[][] = new boolean[n][m];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            dfs(grid, i, 0, visited,  0);\\n        }\\n\\n        return maxMoves;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, boolean[][] visited, int moves){\\n        \\n        visited[row][col] = true;\\n\\n        for(int[] dir: dirs){\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n\\n            if( newRow < 0 || newCol < 0 || newRow >= grid.length || newCol >= grid[0].length || grid[row][col] >= grid[newRow][newCol] || visited[newRow][newCol]\\n            ) continue;\\n\\n            dfs(grid, newRow, newCol, visited, moves+1);\\n        }\\n\\n        maxMoves = Math.max(moves, maxMoves);\\n\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(n*(n+m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    private final int[][] dirs = new int[][]{{-1,1}, {0,1}, {1,1}};\\n    private int maxMoves = 0;\\n\\n    public int maxMoves(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean visited[][] = new boolean[n][m];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            dfs(grid, i, 0, visited,  0);\\n        }\\n\\n        return maxMoves;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, boolean[][] visited, int moves){\\n        \\n        visited[row][col] = true;\\n\\n        for(int[] dir: dirs){\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n\\n            if( newRow < 0 || newCol < 0 || newRow >= grid.length || newCol >= grid[0].length || grid[row][col] >= grid[newRow][newCol] || visited[newRow][newCol]\\n            ) continue;\\n\\n            dfs(grid, newRow, newCol, visited, moves+1);\\n        }\\n\\n        maxMoves = Math.max(moves, maxMoves);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836025,
                "title": "using-dfs-and-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int prev,vector<vector<int>>& dp)\\n    {\\n       \\n         int a=0,b=0,c=0; \\n         if(dp[i][j]!=-1)\\n          return dp[i][j]; \\n         if(i-1>=0 && j+1<grid[0].size() && grid[i][j]<grid[i-1][j+1])\\n              a=1+solve(i-1,j+1,grid,grid[i][j],dp); \\n         if( j+1<grid[0].size() && grid[i][j]<grid[i][j+1])     \\n              b=1+solve(i,j+1,grid,grid[i][j],dp); \\n         if(i+1<grid.size() && j+1<grid[0].size()  && grid[i][j]<grid[i+1][j+1])     \\n              c=1+solve(i+1,j+1,grid,grid[i][j],dp); \\n         return dp[i][j]=max(a,max(b,c));\\n    }\\n    int maxMoves(vector<vector<int>>& grid)\\n    {\\n        int ans=0;\\n         vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int j=0;j<grid.size();j++)\\n        {\\n            cout<<grid[j][0];\\n           ans=max(ans,solve(j,0,grid,-1,dp));\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int prev,vector<vector<int>>& dp)\\n    {\\n       \\n         int a=0,b=0,c=0; \\n         if(dp[i][j]!=-1)\\n          return dp[i][j]; \\n         if(i-1>=0 && j+1<grid[0].size() && grid[i][j]<grid[i-1][j+1])\\n              a=1+solve(i-1,j+1,grid,grid[i][j],dp); \\n         if( j+1<grid[0].size() && grid[i][j]<grid[i][j+1])     \\n              b=1+solve(i,j+1,grid,grid[i][j],dp); \\n         if(i+1<grid.size() && j+1<grid[0].size()  && grid[i][j]<grid[i+1][j+1])     \\n              c=1+solve(i+1,j+1,grid,grid[i][j],dp); \\n         return dp[i][j]=max(a,max(b,c));\\n    }\\n    int maxMoves(vector<vector<int>>& grid)\\n    {\\n        int ans=0;\\n         vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int j=0;j<grid.size();j++)\\n        {\\n            cout<<grid[j][0];\\n           ans=max(ans,solve(j,0,grid,-1,dp));\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3836023,
                "title": "using-dfs-and-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int prev,vector<vector<int>>& dp)\\n    {\\n       \\n         int a=0,b=0,c=0; \\n         if(dp[i][j]!=-1)\\n          return dp[i][j]; \\n         if(i-1>=0 && j+1<grid[0].size() && grid[i][j]<grid[i-1][j+1])\\n              a=1+solve(i-1,j+1,grid,grid[i][j],dp); \\n         if( j+1<grid[0].size() && grid[i][j]<grid[i][j+1])     \\n              b=1+solve(i,j+1,grid,grid[i][j],dp); \\n         if(i+1<grid.size() && j+1<grid[0].size()  && grid[i][j]<grid[i+1][j+1])     \\n              c=1+solve(i+1,j+1,grid,grid[i][j],dp); \\n         return dp[i][j]=max(a,max(b,c));\\n    }\\n    int maxMoves(vector<vector<int>>& grid)\\n    {\\n        int ans=0;\\n         vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int j=0;j<grid.size();j++)\\n        {\\n            cout<<grid[j][0];\\n           ans=max(ans,solve(j,0,grid,-1,dp));\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int prev,vector<vector<int>>& dp)\\n    {\\n       \\n         int a=0,b=0,c=0; \\n         if(dp[i][j]!=-1)\\n          return dp[i][j]; \\n         if(i-1>=0 && j+1<grid[0].size() && grid[i][j]<grid[i-1][j+1])\\n              a=1+solve(i-1,j+1,grid,grid[i][j],dp); \\n         if( j+1<grid[0].size() && grid[i][j]<grid[i][j+1])     \\n              b=1+solve(i,j+1,grid,grid[i][j],dp); \\n         if(i+1<grid.size() && j+1<grid[0].size()  && grid[i][j]<grid[i+1][j+1])     \\n              c=1+solve(i+1,j+1,grid,grid[i][j],dp); \\n         return dp[i][j]=max(a,max(b,c));\\n    }\\n    int maxMoves(vector<vector<int>>& grid)\\n    {\\n        int ans=0;\\n         vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int j=0;j<grid.size();j++)\\n        {\\n            cout<<grid[j][0];\\n           ans=max(ans,solve(j,0,grid,-1,dp));\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3835150,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    O(m * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m * n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        int ans = 0;\\n\\n        for(int j = n - 1; j > 0; j--) {\\n            for(int i = m - 1; i >= 0; i--) {\\n                if(i + 1 < m && grid[i][j] > grid[i + 1][j - 1 ] && dp[i + 1][j - 1] < dp[i][j] + 1) {\\n                    dp[i + 1][j - 1 ] = dp[i][j] + 1;\\n                }\\n\\n                if( grid[i][j] > grid[i][j - 1] && dp[i ][j - 1] < dp[i][j] + 1) {\\n                    dp[i][j - 1 ] = dp[i][j] + 1;\\n                }\\n\\n                if( i - 1 >= 0 && grid[i][j] > grid[i - 1][j - 1] && dp[i - 1][j - 1] < dp[i][j] + 1) {\\n                    dp[i - 1][j - 1 ] = dp[i][j] + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++) {\\n            ans = max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        int ans = 0;\\n\\n        for(int j = n - 1; j > 0; j--) {\\n            for(int i = m - 1; i >= 0; i--) {\\n                if(i + 1 < m && grid[i][j] > grid[i + 1][j - 1 ] && dp[i + 1][j - 1] < dp[i][j] + 1) {\\n                    dp[i + 1][j - 1 ] = dp[i][j] + 1;\\n                }\\n\\n                if( grid[i][j] > grid[i][j - 1] && dp[i ][j - 1] < dp[i][j] + 1) {\\n                    dp[i][j - 1 ] = dp[i][j] + 1;\\n                }\\n\\n                if( i - 1 >= 0 && grid[i][j] > grid[i - 1][j - 1] && dp[i - 1][j - 1] < dp[i][j] + 1) {\\n                    dp[i - 1][j - 1 ] = dp[i][j] + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++) {\\n            ans = max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830071,
                "title": "golang-solution",
                "content": "# Code\\n```go\\nfunc maxMoves(grid [][]int) int {\\n\\tmove := make([][]int, len(grid))\\n\\tfor i := range move {\\n\\t\\tmove[i] = make([]int, len(grid[0]))\\n\\t}\\n\\tfor c := len(grid[0])-1; c >= 0; c-- {\\n\\t\\tfor r := len(grid)-1; r >= 0; r-- {\\n\\t\\t\\tif c + 1 >= len(grid[r]) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif grid[r][c] < grid[r][c+1] {\\n\\t\\t\\t\\tmove[r][c] = max(move[r][c], move[r][c+1]+1)\\n\\t\\t\\t}\\n\\t\\t\\tif r + 1 < len(grid) {\\n\\t\\t\\t\\tif grid[r][c] < grid[r+1][c+1] {\\n\\t\\t\\t\\t\\tmove[r][c] = max(move[r][c], move[r+1][c+1]+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif r - 1 >= 0 {\\n\\t\\t\\t\\tif grid[r][c] < grid[r-1][c+1] {\\n\\t\\t\\t\\t\\tmove[r][c] = max(move[r][c], move[r-1][c+1]+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tmaxMove := 0\\n\\tfor _, m := range move {\\n\\t\\tif m[0] > maxMove {\\n\\t\\t\\tmaxMove = m[0]\\n\\t\\t}\\n\\t}\\n\\treturn maxMove\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxMoves(grid [][]int) int {\\n\\tmove := make([][]int, len(grid))\\n\\tfor i := range move {\\n\\t\\tmove[i] = make([]int, len(grid[0]))\\n\\t}\\n\\tfor c := len(grid[0])-1; c >= 0; c-- {\\n\\t\\tfor r := len(grid)-1; r >= 0; r-- {\\n\\t\\t\\tif c + 1 >= len(grid[r]) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif grid[r][c] < grid[r][c+1] {\\n\\t\\t\\t\\tmove[r][c] = max(move[r][c], move[r][c+1]+1)\\n\\t\\t\\t}\\n\\t\\t\\tif r + 1 < len(grid) {\\n\\t\\t\\t\\tif grid[r][c] < grid[r+1][c+1] {\\n\\t\\t\\t\\t\\tmove[r][c] = max(move[r][c], move[r+1][c+1]+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif r - 1 >= 0 {\\n\\t\\t\\t\\tif grid[r][c] < grid[r-1][c+1] {\\n\\t\\t\\t\\t\\tmove[r][c] = max(move[r][c], move[r-1][c+1]+1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tmaxMove := 0\\n\\tfor _, m := range move {\\n\\t\\tif m[0] > maxMove {\\n\\t\\t\\tmaxMove = m[0]\\n\\t\\t}\\n\\t}\\n\\treturn maxMove\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820384,
                "title": "bottom-up-dp",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$ \\n\\n- Space complexity: $$O(m*n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    bool isValid(int i, int j, int m, int n)\\n    {\\n        return (i >= 0 && i < m && j >= 0 && j < n);\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = INT_MIN;\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        //start traversing column-wise\\n       for(int j=1; j<n; j++)      \\n        {\\n            for(int i=0; i<m; i++)\\n             {\\n               //explore all 3 directions from which we can come to [i,j] cell\\n                if(isValid(i-1,j-1,m,n) && grid[i][j] > grid[i-1][j-1] && (dp[i-1][j-1] != 0 || j-1 == 0))\\n                 dp[i][j] = max(dp[i][j],1+dp[i-1][j-1]);\\n\\n                if(isValid(i,j-1,m,n) && grid[i][j] > grid[i][j-1] && (dp[i][j-1] != 0 || j-1 == 0))\\n                 dp[i][j] = max(dp[i][j],1+dp[i][j-1]);\\n\\n                if(isValid(i+1,j-1,m,n) && grid[i][j] > grid[i+1][j-1] && (dp[i+1][j-1] != 0 || j-1 == 0))\\n                 dp[i][j] = max(dp[i][j],1+dp[i+1][j-1]);\\n\\n                ans = max(ans,dp[i][j]); //update the maximum moves made\\n             }\\n        }\\n    \\n     return ans; //return the maximum moves\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int i, int j, int m, int n)\\n    {\\n        return (i >= 0 && i < m && j >= 0 && j < n);\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = INT_MIN;\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        //start traversing column-wise\\n       for(int j=1; j<n; j++)      \\n        {\\n            for(int i=0; i<m; i++)\\n             {\\n               //explore all 3 directions from which we can come to [i,j] cell\\n                if(isValid(i-1,j-1,m,n) && grid[i][j] > grid[i-1][j-1] && (dp[i-1][j-1] != 0 || j-1 == 0))\\n                 dp[i][j] = max(dp[i][j],1+dp[i-1][j-1]);\\n\\n                if(isValid(i,j-1,m,n) && grid[i][j] > grid[i][j-1] && (dp[i][j-1] != 0 || j-1 == 0))\\n                 dp[i][j] = max(dp[i][j],1+dp[i][j-1]);\\n\\n                if(isValid(i+1,j-1,m,n) && grid[i][j] > grid[i+1][j-1] && (dp[i+1][j-1] != 0 || j-1 == 0))\\n                 dp[i][j] = max(dp[i][j],1+dp[i+1][j-1]);\\n\\n                ans = max(ans,dp[i][j]); //update the maximum moves made\\n             }\\n        }\\n    \\n     return ans; //return the maximum moves\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818613,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*m*log(n))$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn max_moves(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let m = grid[0].len();\\n\\n    let mut memo = vec![vec![0;m];n];\\n    let mut stack = (0..n).into_iter().collect::<Vec<_>>();\\n    for j in 0..m-1 {\\n      let mut set = HashSet::new();\\n      while let Some(i) = stack.pop() {\\n        let nv = memo[i][j] + 1;\\n        if 0 < i && grid[i][j] < grid[i-1][j+1] {\\n          memo[i-1][j+1] = memo[i-1][j+1].max(nv);\\n          set.insert(i-1);\\n        }\\n        if grid[i][j] < grid[i][j+1] {\\n          memo[i][j+1] = memo[i][j+1].max(nv);\\n          set.insert(i);\\n        }\\n        if i < n - 1 && grid[i][j] < grid[i+1][j+1] {\\n          memo[i+1][j+1] = memo[i+1][j+1].max(nv);\\n          set.insert(i+1);\\n        }\\n      }\\n      stack = set.into_iter().collect::<Vec<_>>();\\n    }\\n\\n    let mut result = 0;\\n    for i in 0..n {\\n      for j in 0..m {\\n        result = result.max(memo[i][j]);\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn max_moves(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let m = grid[0].len();\\n\\n    let mut memo = vec![vec![0;m];n];\\n    let mut stack = (0..n).into_iter().collect::<Vec<_>>();\\n    for j in 0..m-1 {\\n      let mut set = HashSet::new();\\n      while let Some(i) = stack.pop() {\\n        let nv = memo[i][j] + 1;\\n        if 0 < i && grid[i][j] < grid[i-1][j+1] {\\n          memo[i-1][j+1] = memo[i-1][j+1].max(nv);\\n          set.insert(i-1);\\n        }\\n        if grid[i][j] < grid[i][j+1] {\\n          memo[i][j+1] = memo[i][j+1].max(nv);\\n          set.insert(i);\\n        }\\n        if i < n - 1 && grid[i][j] < grid[i+1][j+1] {\\n          memo[i+1][j+1] = memo[i+1][j+1].max(nv);\\n          set.insert(i+1);\\n        }\\n      }\\n      stack = set.into_iter().collect::<Vec<_>>();\\n    }\\n\\n    let mut result = 0;\\n    for i in 0..n {\\n      for j in 0..m {\\n        result = result.max(memo[i][j]);\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799463,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>&dp, int i, int j, vector<vector<int>>&grid)\\n    {\\n       \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int res = 0;\\n        \\n        if(i-1 >= 0  && j+1 < grid[0].size() && grid[i-1][j+1] > grid[i][j])\\n        {\\n            res = max(res, 1 + solve(dp,i-1,j+1,grid));\\n        }\\n        if(j+1 < grid[0].size() && grid[i][j+1] > grid[i][j])\\n        {\\n            res = max(res, 1 + solve(dp,i,j+1,grid));\\n        }\\n        if(j+1 < grid[0].size() && i+1 < grid.size() && grid[i+1][j+1] > grid[i][j])\\n        {\\n            res = max(res, 1 + solve(dp,i+1,j+1,grid));\\n        }\\n        \\n        \\n        return dp[i][j] = res;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        int ans = 0;\\n        for(int i = 0; i < n ; i++)\\n        {\\n            ans = max(ans,solve(dp, i, 0 , grid));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>&dp, int i, int j, vector<vector<int>>&grid)\\n    {\\n       \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int res = 0;\\n        \\n        if(i-1 >= 0  && j+1 < grid[0].size() && grid[i-1][j+1] > grid[i][j])\\n        {\\n            res = max(res, 1 + solve(dp,i-1,j+1,grid));\\n        }\\n        if(j+1 < grid[0].size() && grid[i][j+1] > grid[i][j])\\n        {\\n            res = max(res, 1 + solve(dp,i,j+1,grid));\\n        }\\n        if(j+1 < grid[0].size() && i+1 < grid.size() && grid[i+1][j+1] > grid[i][j])\\n        {\\n            res = max(res, 1 + solve(dp,i+1,j+1,grid));\\n        }\\n        \\n        \\n        return dp[i][j] = res;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        int ans = 0;\\n        for(int i = 0; i < n ; i++)\\n        {\\n            ans = max(ans,solve(dp, i, 0 , grid));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786701,
                "title": "c-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int f(int row, int col, vector<vector<int>> &grid, int n, int m, vector<vector<int>> &dp){\\n        if(row<0 || row>=n || col>=m) return 0;\\n\\n        if(dp[row][col]!=-1) return dp[row][col];\\n\\n        int dgu = 0;\\n        int dgd = 0;\\n        int right = 0;\\n        if(row-1>=0 && col+1<m && grid[row-1][col+1]>grid[row][col]) dgu = 1+f(row-1, col+1, grid, n, m, dp);\\n        if(row+1<n && col+1<m && grid[row+1][col+1]>grid[row][col]) dgd = 1+f(row+1, col+1, grid, n, m, dp);\\n        if(col+1<m && grid[row][col+1]>grid[row][col]) right = 1+f(row, col+1, grid, n, m, dp);\\n\\n        return dp[row][col] = max(dgd, max(dgu, right));\\n \\n\\n        \\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        for(int i=0;i<n;i++){\\n            ans = max(ans, f(i, 0, grid, n, m, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int f(int row, int col, vector<vector<int>> &grid, int n, int m, vector<vector<int>> &dp){\\n        if(row<0 || row>=n || col>=m) return 0;\\n\\n        if(dp[row][col]!=-1) return dp[row][col];\\n\\n        int dgu = 0;\\n        int dgd = 0;\\n        int right = 0;\\n        if(row-1>=0 && col+1<m && grid[row-1][col+1]>grid[row][col]) dgu = 1+f(row-1, col+1, grid, n, m, dp);\\n        if(row+1<n && col+1<m && grid[row+1][col+1]>grid[row][col]) dgd = 1+f(row+1, col+1, grid, n, m, dp);\\n        if(col+1<m && grid[row][col+1]>grid[row][col]) right = 1+f(row, col+1, grid, n, m, dp);\\n\\n        return dp[row][col] = max(dgd, max(dgu, right));\\n \\n\\n        \\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        for(int i=0;i<n;i++){\\n            ans = max(ans, f(i, 0, grid, n, m, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781593,
                "title": "c-dp-solution",
                "content": "\\n# Code\\n```\\n\\nint f(int i,int j,vector<vector<int>>&grid,int n,int m,vector<vector<int>>&dp)\\n{\\n    int res = 0;\\n    if(dp[i][j] != -1)\\n        return dp[i][j];\\n    if(i > 0 && j < m - 1 && grid[i-1][j+1] > grid[i][j])\\n        res = max(res,f(i-1,j+1,grid,n,m,dp) + 1);\\n    if(j < m - 1 && grid[i][j+1] > grid[i][j])\\n        res = max(res,f(i,j+1,grid,n,m,dp)+1);\\n    if(i < n - 1 && j < m - 1 && grid[i+1][j+1] > grid[i][j])\\n        res = max(res,f(i+1,j+1,grid,n,m,dp)+1);\\n    return dp[i][j] = res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            res = max(res,f(i,0,grid,n,m,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nint f(int i,int j,vector<vector<int>>&grid,int n,int m,vector<vector<int>>&dp)\\n{\\n    int res = 0;\\n    if(dp[i][j] != -1)\\n        return dp[i][j];\\n    if(i > 0 && j < m - 1 && grid[i-1][j+1] > grid[i][j])\\n        res = max(res,f(i-1,j+1,grid,n,m,dp) + 1);\\n    if(j < m - 1 && grid[i][j+1] > grid[i][j])\\n        res = max(res,f(i,j+1,grid,n,m,dp)+1);\\n    if(i < n - 1 && j < m - 1 && grid[i+1][j+1] > grid[i][j])\\n        res = max(res,f(i+1,j+1,grid,n,m,dp)+1);\\n    return dp[i][j] = res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            res = max(res,f(i,0,grid,n,m,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774389,
                "title": "c-dp-no-additional-space-used-time-o-n-space-o-1",
                "content": "Simple DFS with memoization. \\n\\nWe can use the original matrix values to store the DP data since: \\n- Max value = 10^6 (1111 0100 0010 0100 0000) => 12 free bits\\n- Max moves = 1000 (0011 1110 1000)\\n\\n```\\nint MaxMoves(size_t r, size_t c, vector<vector<int>>& g)\\n{\\n    int maxMoves{ g[r][c] >> 20 };\\n    if (maxMoves)\\n        return maxMoves;\\n        \\n    const int val{ g[r][c] & 0xFFFFF };\\n    if (c + 1 < g[0].size())\\n    {            \\n        if (r >= 1 && val < (g[r - 1][c + 1] & 0xFFFFF))\\n            maxMoves = max(maxMoves, MaxMoves(r - 1, c + 1, g));\\n        if (val < (g[r][c + 1] & 0xFFFFF))\\n            maxMoves = max(maxMoves, MaxMoves(r, c + 1, g));\\n        if (r + 1 < g.size() && val < (g[r + 1][c + 1] & 0xFFFFF))\\n            maxMoves = max(maxMoves, MaxMoves(r + 1, c + 1, g));\\n    }\\n\\n    g[r][c] &= ((maxMoves + 1) << 20); // save moves to value\\n    return maxMoves + 1;\\n}\\n\\nint maxMoves(vector<vector<int>>& grid) \\n{\\n    int maxMoves{ 1 };\\n    for (size_t r{ 0 }; r < grid.size(); ++r)\\n        maxMoves = std::max(maxMoves, MaxMoves(r, 0, grid));\\n\\n    return maxMoves - 1;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint MaxMoves(size_t r, size_t c, vector<vector<int>>& g)\\n{\\n    int maxMoves{ g[r][c] >> 20 };\\n    if (maxMoves)\\n        return maxMoves;\\n        \\n    const int val{ g[r][c] & 0xFFFFF };\\n    if (c + 1 < g[0].size())\\n    {            \\n        if (r >= 1 && val < (g[r - 1][c + 1] & 0xFFFFF))\\n            maxMoves = max(maxMoves, MaxMoves(r - 1, c + 1, g));\\n        if (val < (g[r][c + 1] & 0xFFFFF))\\n            maxMoves = max(maxMoves, MaxMoves(r, c + 1, g));\\n        if (r + 1 < g.size() && val < (g[r + 1][c + 1] & 0xFFFFF))\\n            maxMoves = max(maxMoves, MaxMoves(r + 1, c + 1, g));\\n    }\\n\\n    g[r][c] &= ((maxMoves + 1) << 20); // save moves to value\\n    return maxMoves + 1;\\n}\\n\\nint maxMoves(vector<vector<int>>& grid) \\n{\\n    int maxMoves{ 1 };\\n    for (size_t r{ 0 }; r < grid.size(); ++r)\\n        maxMoves = std::max(maxMoves, MaxMoves(r, 0, grid));\\n\\n    return maxMoves - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753478,
                "title": "easy-memorisation-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>>& grid, int n, int m, int pi, int pj, vector<vector<int>>&dp)\\n    {\\n        if(row>=n || col>=m || row<0 || col<0)\\n            return 0;\\n        if(pi != -1 && pj != -1 && grid[row][col] <= grid[pi][pj])\\n            return 0;\\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        int d_up = solve(row-1, col+1, grid, n, m, row, col, dp);\\n        int s_row = solve(row, col+1, grid, n, m, row, col, dp);\\n        int d_down = solve(row+1, col+1, grid, n, m, row, col, dp);\\n        return dp[row][col] = max(d_up, max(s_row, d_down))+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = -1;\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, -1));\\n        for(int j=0;j<n;j++)\\n        {\\n            int cnt = solve(j, 0, grid, n, m, -1, -1, dp);\\n            ans = max(ans, cnt-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>>& grid, int n, int m, int pi, int pj, vector<vector<int>>&dp)\\n    {\\n        if(row>=n || col>=m || row<0 || col<0)\\n            return 0;\\n        if(pi != -1 && pj != -1 && grid[row][col] <= grid[pi][pj])\\n            return 0;\\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        int d_up = solve(row-1, col+1, grid, n, m, row, col, dp);\\n        int s_row = solve(row, col+1, grid, n, m, row, col, dp);\\n        int d_down = solve(row+1, col+1, grid, n, m, row, col, dp);\\n        return dp[row][col] = max(d_up, max(s_row, d_down))+1;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = -1;\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, -1));\\n        for(int j=0;j<n;j++)\\n        {\\n            int cnt = solve(j, 0, grid, n, m, -1, -1, dp);\\n            ans = max(ans, cnt-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752586,
                "title": "java-simple-dfs-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    Integer[][] dp;\\n    public int maxMoves(int[][] grid) {\\n        dp = new Integer[grid.length][grid[0].length];\\n        int max = 1;\\n        for (int i = 0; i < grid.length; i++) max = Math.max(max, helper(grid, i, 0, 0));\\n        return max - 1;\\n    }\\n    private int helper(int[][] grid, int i, int j, int prev) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] <= prev) return 0;\\n        if (dp[i][j] != null) return dp[i][j];\\n        int cur = grid[i][j];\\n        dp[i][j] = 1 + Math.max(\\n            helper(grid, i - 1, j + 1, cur), \\n            Math.max(helper(grid, i, j + 1, cur), helper(grid, i + 1, j + 1, cur)));\\n        return dp[i][j];\\n    }\\n}\\n```\\n# Complexity\\n- Time: $$O(n * m)$$ where n = row(grid) and m = col(grid)\\n- Space: $$O(n * m)$$ memoization table",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] dp;\\n    public int maxMoves(int[][] grid) {\\n        dp = new Integer[grid.length][grid[0].length];\\n        int max = 1;\\n        for (int i = 0; i < grid.length; i++) max = Math.max(max, helper(grid, i, 0, 0));\\n        return max - 1;\\n    }\\n    private int helper(int[][] grid, int i, int j, int prev) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] <= prev) return 0;\\n        if (dp[i][j] != null) return dp[i][j];\\n        int cur = grid[i][j];\\n        dp[i][j] = 1 + Math.max(\\n            helper(grid, i - 1, j + 1, cur), \\n            Math.max(helper(grid, i, j + 1, cur), helper(grid, i + 1, j + 1, cur)));\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750176,
                "title": "java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i = 0; i < m; i++){\\n            q.add(new int[]{i, 0});\\n            visited[i][0] = true;\\n        }\\n        int max = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            max++;\\n            while(size-- > 0){\\n                int[] t = q.poll();\\n                if(t[0]-1 >= 0 && t[1]+1 < n && grid[t[0]-1][t[1]+1] > grid[t[0]][t[1]] && !visited[t[0]-1][t[1]+1]){\\n                    q.add(new int[]{t[0]-1, t[1]+1});\\n                    visited[t[0]-1][t[1]+1] = true;\\n                }\\n                if(t[0] >= 0 && t[1]+1 < n && grid[t[0]][t[1]+1] > grid[t[0]][t[1]] && !visited[t[0]][t[1]+1]){\\n                    q.add(new int[]{t[0], t[1]+1});\\n                    visited[t[0]][t[1]+1] = true;\\n                }\\n                if(t[0]+1 < m && t[1]+1 < n && grid[t[0]+1][t[1]+1] > grid[t[0]][t[1]] && ! visited[t[0]+1][t[1]+1]){\\n                    q.add(new int[]{t[0]+1, t[1]+1});\\n                    visited[t[0]+1][t[1]+1] = true;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i = 0; i < m; i++){\\n            q.add(new int[]{i, 0});\\n            visited[i][0] = true;\\n        }\\n        int max = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            max++;\\n            while(size-- > 0){\\n                int[] t = q.poll();\\n                if(t[0]-1 >= 0 && t[1]+1 < n && grid[t[0]-1][t[1]+1] > grid[t[0]][t[1]] && !visited[t[0]-1][t[1]+1]){\\n                    q.add(new int[]{t[0]-1, t[1]+1});\\n                    visited[t[0]-1][t[1]+1] = true;\\n                }\\n                if(t[0] >= 0 && t[1]+1 < n && grid[t[0]][t[1]+1] > grid[t[0]][t[1]] && !visited[t[0]][t[1]+1]){\\n                    q.add(new int[]{t[0], t[1]+1});\\n                    visited[t[0]][t[1]+1] = true;\\n                }\\n                if(t[0]+1 < m && t[1]+1 < n && grid[t[0]+1][t[1]+1] > grid[t[0]][t[1]] && ! visited[t[0]+1][t[1]+1]){\\n                    q.add(new int[]{t[0]+1, t[1]+1});\\n                    visited[t[0]+1][t[1]+1] = true;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739386,
                "title": "python-simple-top-down-dp",
                "content": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dfs(y,x): return max( (1+dfs(y+dy,x+dx) \\\\\\n                                   for dy,dx in ((-1,1),(0,1),(1,1)) \\\\\\n                                   if y+dy >= 0 and y+dy < len(grid) and x+dx >=0 and x+dx < len(grid[0]) \\\\\\n                                   and grid[y+dy][x+dx] > grid[y][x] \\\\\\n                                   ), default=0)\\n        \\n        return max(dfs(y,0) for y in range(len(grid)))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dfs(y,x): return max( (1+dfs(y+dy,x+dx) \\\\\\n                                   for dy,dx in ((-1,1),(0,1),(1,1)) \\\\\\n                                   if y+dy >= 0 and y+dy < len(grid) and x+dx >=0 and x+dx < len(grid[0]) \\\\\\n                                   and grid[y+dy][x+dx] > grid[y][x] \\\\\\n                                   ), default=0)\\n        \\n        return max(dfs(y,0) for y in range(len(grid)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729448,
                "title": "tc-o-n-m-sc-o-n-m-c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\n    int calculateMaxMoves(int row, int col, int prev, int &n, int &m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if (row < 0 || col < 0 || row >= n || col >= m || grid[row][col] <= prev)\\n            return 0;\\n        \\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        \\n        int up = calculateMaxMoves(row - 1, col + 1, grid[row][col], n, m, grid, dp) + 1;\\n        int right = calculateMaxMoves(row, col + 1, grid[row][col], n, m, grid, dp) + 1;\\n        int down = calculateMaxMoves(row + 1, col + 1, grid[row][col], n, m, grid, dp) + 1;\\n        \\n        return dp[row][col] = max(up, max(right, down));\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0; \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        \\n        for (int row = 0; row < grid.size(); row++) {\\n            int cnt = calculateMaxMoves(row, 0, -1, n, m, grid, dp) - 1;\\n            ans = max(ans, cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int calculateMaxMoves(int row, int col, int prev, int &n, int &m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if (row < 0 || col < 0 || row >= n || col >= m || grid[row][col] <= prev)\\n            return 0;\\n        \\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        \\n        int up = calculateMaxMoves(row - 1, col + 1, grid[row][col], n, m, grid, dp) + 1;\\n        int right = calculateMaxMoves(row, col + 1, grid[row][col], n, m, grid, dp) + 1;\\n        int down = calculateMaxMoves(row + 1, col + 1, grid[row][col], n, m, grid, dp) + 1;\\n        \\n        return dp[row][col] = max(up, max(right, down));\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0; \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        \\n        for (int row = 0; row < grid.size(); row++) {\\n            int cnt = calculateMaxMoves(row, 0, -1, n, m, grid, dp) - 1;\\n            ans = max(ans, cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726847,
                "title": "easy-intutive-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int ans=0;\\n        int [][]dp=new int[grid.length][grid[0].length];\\n        for(int i=0;i<dp.length;i++) Arrays.fill(dp[i],-1);\\n        for(int i=0;i< grid.length;i++){\\n            ans=Math.max(ans,movin(i,0,grid,dp));\\n        }\\n        return  ans;\\n    }\\n    public int movin(int i,int j,int[][]grid,int [][]dp){\\n        if(i<0 ||j<0 ||i>=grid.length || j>=grid[0].length){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int rightup=0;\\n        int mid=0;\\n        int rightdown=0;\\n        if(i-1>=0 && j+1<grid[0].length && grid[i][j]<grid[i-1][j+1]){\\n            rightup=1+movin(i-1,j+1,grid,dp);\\n        }\\n        if(j+1<grid[0].length && grid[i][j]<grid[i][j+1]){\\n            mid=1+movin(i,j+1,grid,dp);\\n        }\\n        if(i+1<grid.length && j+1<grid[0].length &&grid[i][j]<grid[i+1][j+1]){\\n            rightdown=1+movin(i+1,j+1,grid,dp);\\n        }\\n        return dp[i][j]=Math.max(Math.max(mid,rightdown),rightup);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int ans=0;\\n        int [][]dp=new int[grid.length][grid[0].length];\\n        for(int i=0;i<dp.length;i++) Arrays.fill(dp[i],-1);\\n        for(int i=0;i< grid.length;i++){\\n            ans=Math.max(ans,movin(i,0,grid,dp));\\n        }\\n        return  ans;\\n    }\\n    public int movin(int i,int j,int[][]grid,int [][]dp){\\n        if(i<0 ||j<0 ||i>=grid.length || j>=grid[0].length){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int rightup=0;\\n        int mid=0;\\n        int rightdown=0;\\n        if(i-1>=0 && j+1<grid[0].length && grid[i][j]<grid[i-1][j+1]){\\n            rightup=1+movin(i-1,j+1,grid,dp);\\n        }\\n        if(j+1<grid[0].length && grid[i][j]<grid[i][j+1]){\\n            mid=1+movin(i,j+1,grid,dp);\\n        }\\n        if(i+1<grid.length && j+1<grid[0].length &&grid[i][j]<grid[i+1][j+1]){\\n            rightdown=1+movin(i+1,j+1,grid,dp);\\n        }\\n        return dp[i][j]=Math.max(Math.max(mid,rightdown),rightup);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723710,
                "title": "easy-dp-solution-bigenner-friendly-easy-to-understand",
                "content": "# Approach\\n1. Explore All 3 paths\\n2. Find max of all 3 paths and store it in a dp\\n\\n# Complexity\\n- Time complexity:O(N*(M+N))\\n\\n- Space complexity:O(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int n,int m, vector<vector<int>>& grid,vector<vector<int>>&dp){\\n        if(i<0 || i>=n || j>=m)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int path1 = 0,path2 = 0,path3 = 0;\\n        if(i > 0 and j < m-1 and grid[i][j] < grid[i-1][j+1]){\\n            path1 = 1+f(i-1,j+1,n,m,grid,dp);\\n        }\\n        if(j < m-1 and grid[i][j] < grid[i][j+1]){\\n            path2 = 1+f(i,j+1,n,m,grid,dp);\\n        }\\n        if(i < n-1 and j < m-1 and grid[i][j] < grid[i+1][j+1]){\\n            path3 = 1+f(i+1,j+1,n,m,grid,dp);\\n        }\\n        return dp[i][j] = max(path1,max(path2, path3));\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<n;i++){  \\n            int temp = f(i,0,n,m,grid,dp);\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*Hope it will help you*\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int n,int m, vector<vector<int>>& grid,vector<vector<int>>&dp){\\n        if(i<0 || i>=n || j>=m)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int path1 = 0,path2 = 0,path3 = 0;\\n        if(i > 0 and j < m-1 and grid[i][j] < grid[i-1][j+1]){\\n            path1 = 1+f(i-1,j+1,n,m,grid,dp);\\n        }\\n        if(j < m-1 and grid[i][j] < grid[i][j+1]){\\n            path2 = 1+f(i,j+1,n,m,grid,dp);\\n        }\\n        if(i < n-1 and j < m-1 and grid[i][j] < grid[i+1][j+1]){\\n            path3 = 1+f(i+1,j+1,n,m,grid,dp);\\n        }\\n        return dp[i][j] = max(path1,max(path2, path3));\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<n;i++){  \\n            int temp = f(i,0,n,m,grid,dp);\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706946,
                "title": "java-bottom-up-dp-t-o-mn-s-o-m",
                "content": "# Code\\n```\\nclass Solution {\\n    private final int[][] dirs = new int[][]{{-1, 1}, {0, 1}, {1, 1}};\\n\\n    public int maxMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int[] prev = new int[rows];\\n        int[] curr = new int[rows];\\n        for(int col = cols-2; col >= 0; --col) {\\n            for(int row = 0; row < rows; ++row) {\\n                curr[row] = 0;\\n                for(var dir : dirs) {\\n                    int nRow = row+dir[0];\\n                    int nCol = col+dir[1];\\n                    if(nRow < 0 || nRow == rows || grid[nRow][nCol] <= grid[row][col])\\n                        continue;\\n                    curr[row] = Math.max(curr[row], 1+prev[nRow]);\\n                }\\n            }\\n            int[] tmp = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        return Arrays.stream(prev).max().orElse(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private final int[][] dirs = new int[][]{{-1, 1}, {0, 1}, {1, 1}};\\n\\n    public int maxMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int[] prev = new int[rows];\\n        int[] curr = new int[rows];\\n        for(int col = cols-2; col >= 0; --col) {\\n            for(int row = 0; row < rows; ++row) {\\n                curr[row] = 0;\\n                for(var dir : dirs) {\\n                    int nRow = row+dir[0];\\n                    int nCol = col+dir[1];\\n                    if(nRow < 0 || nRow == rows || grid[nRow][nCol] <= grid[row][col])\\n                        continue;\\n                    curr[row] = Math.max(curr[row], 1+prev[nRow]);\\n                }\\n            }\\n            int[] tmp = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        return Arrays.stream(prev).max().orElse(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703558,
                "title": "easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nndp[j] memorize the maxMoves from grid[i][j] to the last column\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> dp(n,0);\\n        for(int i=m-2;i>=0;i--) {\\n            vector<int> ndp(n,0);\\n            for(int j=0;j<n;j++){\\n                ndp[j]=grid[j][i]<grid[j][i+1]?dp[j]+1:0;\\n                ndp[j]=max(j>0 and grid[j][i]<grid[j-1][i+1]?dp[j-1]+1:0,ndp[j]);\\n                ndp[j]=max(j+1<n and grid[j][i]<grid[j+1][i+1]?dp[j+1]+1:0,ndp[j]);\\n            }\\n            dp=ndp;\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> dp(n,0);\\n        for(int i=m-2;i>=0;i--) {\\n            vector<int> ndp(n,0);\\n            for(int j=0;j<n;j++){\\n                ndp[j]=grid[j][i]<grid[j][i+1]?dp[j]+1:0;\\n                ndp[j]=max(j>0 and grid[j][i]<grid[j-1][i+1]?dp[j-1]+1:0,ndp[j]);\\n                ndp[j]=max(j+1<n and grid[j][i]<grid[j+1][i+1]?dp[j+1]+1:0,ndp[j]);\\n            }\\n            dp=ndp;\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703518,
                "title": "dp-bottom-up",
                "content": "\\n# Approach\\nDP Bottom Up.\\n\\nWe can solve this problem by using a dynamic programming bottom-up approach. The main idea is to create a 2D \"solutions\" array with the same dimensions as the input grid. For each cell in the grid, we want to calculate the maximum number of moves we can make from that cell to the end, strictly moving to a cell with a larger value.\\n\\nWe start the calculations from the last column (since we know there are no possible moves from these cells, their solution value is 0) and move towards the first column.\\n\\nFor each cell, we consider all the possible moves (to the cell in the next column on the same row, to the cell in the next column on the row above, and to the cell in the next column on the row below) and find the maximum move we can make, if any. We ensure to only consider the cells which have a larger value than the current cell as per the problem constraints.\\n\\nFinally, we return the maximum value from the first column of the solutions array which represents the maximum moves we can make from the starting position in the grid.\\n\\nBy using this approach, we are efficiently reusing previously calculated solutions to smaller sub-problems to solve the current problem. This is a characteristic of the bottom-up dynamic programming approach.\\n\\n\\n# Complexity\\n- Time complexity: $$O(MN)$$, where N - number of values in the grid and M - number of derriving cells\\n\\n\\n- Space complexity:\\n$$O(N)$$, where N - number of values in the grid \\n\\n# Code\\n```\\nfunc maxMoves(grid [][]int) int {\\n    LEN_I := len(grid)\\n    if LEN_I == 0 {\\n        return -1\\n    }\\n\\n    LEN_J := len(grid[0])\\n    if LEN_J == 0 {\\n        return -1\\n    }\\n\\n    solutions := [][]int{}\\n    for i := 0; i < LEN_I; i++ {\\n        solutions = append(solutions, make([]int, LEN_J))\\n    }\\n\\n    for j := LEN_J - 2; j >= 0; j-- {\\n        for i := 0; i < LEN_I; i++ {\\n            best := -1\\n\\n            curVal := grid[i][j]\\n            if curVal < grid[i][j+1] {\\n                best = max(best, solutions[i][j+1])\\n            }\\n\\n            if i + 1 < LEN_I && curVal < grid[i+1][j+1]{\\n                best = max(best, solutions[i+1][j+1]) \\n            }\\n\\n            if i-1 >= 0 && curVal < grid[i-1][j+1] {\\n                best = max(best, solutions[i-1][j+1]) \\n            }\\n\\n            best++\\n\\n            solutions[i][j] = best\\n        }\\n    }\\n\\n    best := 0\\n    for _, v := range solutions {\\n        best = max(best, v[0])\\n    }\\n\\n    return best\\n}\\n\\nfunc max(v1, v2 int) int {\\n    if v1 > v2 {\\n        return v1\\n    }\\n\\n    return v2\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc maxMoves(grid [][]int) int {\\n    LEN_I := len(grid)\\n    if LEN_I == 0 {\\n        return -1\\n    }\\n\\n    LEN_J := len(grid[0])\\n    if LEN_J == 0 {\\n        return -1\\n    }\\n\\n    solutions := [][]int{}\\n    for i := 0; i < LEN_I; i++ {\\n        solutions = append(solutions, make([]int, LEN_J))\\n    }\\n\\n    for j := LEN_J - 2; j >= 0; j-- {\\n        for i := 0; i < LEN_I; i++ {\\n            best := -1\\n\\n            curVal := grid[i][j]\\n            if curVal < grid[i][j+1] {\\n                best = max(best, solutions[i][j+1])\\n            }\\n\\n            if i + 1 < LEN_I && curVal < grid[i+1][j+1]{\\n                best = max(best, solutions[i+1][j+1]) \\n            }\\n\\n            if i-1 >= 0 && curVal < grid[i-1][j+1] {\\n                best = max(best, solutions[i-1][j+1]) \\n            }\\n\\n            best++\\n\\n            solutions[i][j] = best\\n        }\\n    }\\n\\n    best := 0\\n    for _, v := range solutions {\\n        best = max(best, v[0])\\n    }\\n\\n    return best\\n}\\n\\nfunc max(v1, v2 int) int {\\n    if v1 > v2 {\\n        return v1\\n    }\\n\\n    return v2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694299,
                "title": "python-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        rowlen = len(grid)\\n        collen = len(grid[0])\\n        d = {}\\n\\n        def bt(row, col, lastElement):\\n            if row >= rowlen or col >= collen or row < 0 or col < 0 or  grid[row][col] <= lastElement or grid[row][col] == \\'#\\':\\n                return -1\\n            coordinates = [(-1, 1), (0, 1), (1, 1)]\\n            res = []\\n            tmp = grid[row][col]\\n            grid[row][col] = \\'#\\'\\n            for _r, _c in coordinates:\\n                if (_r + row, _c + col, tmp) in d:\\n                    res.append(1 + d[(_r + row, _c + col, tmp)])\\n                else:\\n                    res.append(1 + bt(_r + row, _c + col, tmp))\\n            grid[row][col] = tmp\\n            d[(row, col, lastElement)] = max(res)\\n            return d[(row, col, lastElement)]\\n        \\n        mx = []\\n        for i in range(rowlen):\\n            mx.append(bt(i,0,float(\\'-inf\\')))\\n\\n        return max(mx)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n        rowlen = len(grid)\\n        collen = len(grid[0])\\n        d = {}\\n\\n        def bt(row, col, lastElement):\\n            if row >= rowlen or col >= collen or row < 0 or col < 0 or  grid[row][col] <= lastElement or grid[row][col] == \\'#\\':\\n                return -1\\n            coordinates = [(-1, 1), (0, 1), (1, 1)]\\n            res = []\\n            tmp = grid[row][col]\\n            grid[row][col] = \\'#\\'\\n            for _r, _c in coordinates:\\n                if (_r + row, _c + col, tmp) in d:\\n                    res.append(1 + d[(_r + row, _c + col, tmp)])\\n                else:\\n                    res.append(1 + bt(_r + row, _c + col, tmp))\\n            grid[row][col] = tmp\\n            d[(row, col, lastElement)] = max(res)\\n            return d[(row, col, lastElement)]\\n        \\n        mx = []\\n        for i in range(rowlen):\\n            mx.append(bt(i,0,float(\\'-inf\\')))\\n\\n        return max(mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689068,
                "title": "bfs-solution-o-n-m",
                "content": "# Intuition\\nBFS based approach\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxMoves(grid: number[][]): number {\\n    const N = grid.length;\\n    const M = grid[0].length;\\n    const directions = [[-1, 1], [0, 1], [1, 1]];\\n    const check = (x, y) => x >= 0 && y >= 0 && x < N && y < M;\\n\\n    const visited = [...new Array(N)].map(_ => new Array(M).fill(0));\\n    const q = [];\\n    for (let i = 0; i < N; i++) {\\n        q.push([i, 0]);\\n        visited[i][0] = 1;\\n    }\\n\\n    let depth = 0;\\n    while (q.length) {\\n        let qLength = q.length;\\n        for (let i = 0; i < qLength; i++) {\\n            const [x, y] = q.shift();\\n            for (const [diffX, diffY] of directions) {\\n                const newX = diffX + x;\\n                const newY = diffY + y;\\n                if (!check(newX, newY) || visited[newX][newY]) {\\n                    continue;\\n                }\\n                if (grid[x][y] < grid[newX][newY]) {\\n                    visited[newX][newY] = 1;\\n                    q.push([newX, newY]);\\n                }\\n            }\\n        }\\n        depth++;\\n    }\\n\\n    return depth - 1;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction maxMoves(grid: number[][]): number {\\n    const N = grid.length;\\n    const M = grid[0].length;\\n    const directions = [[-1, 1], [0, 1], [1, 1]];\\n    const check = (x, y) => x >= 0 && y >= 0 && x < N && y < M;\\n\\n    const visited = [...new Array(N)].map(_ => new Array(M).fill(0));\\n    const q = [];\\n    for (let i = 0; i < N; i++) {\\n        q.push([i, 0]);\\n        visited[i][0] = 1;\\n    }\\n\\n    let depth = 0;\\n    while (q.length) {\\n        let qLength = q.length;\\n        for (let i = 0; i < qLength; i++) {\\n            const [x, y] = q.shift();\\n            for (const [diffX, diffY] of directions) {\\n                const newX = diffX + x;\\n                const newY = diffY + y;\\n                if (!check(newX, newY) || visited[newX][newY]) {\\n                    continue;\\n                }\\n                if (grid[x][y] < grid[newX][newY]) {\\n                    visited[newX][newY] = 1;\\n                    q.push([newX, newY]);\\n                }\\n            }\\n        }\\n        depth++;\\n    }\\n\\n    return depth - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685073,
                "title": "easy-c-solution-with-detailed-approach-explained",
                "content": "# Intuition\\nInitially I thought of BFS but when did that it gave TLE. That\\'s when I thought of DP.\\n\\n# Approach\\nAs for every index we have 3 possible paths so we will call these three ways in recursive calls. Also we need to store the parent (or the previous cell) from which we came as in question it is given that path should be strictly incresing. We put this condition as a base case.\\n\\nNow simple we have to call 3 recursive calls for 3 directions and return the max value out of those.\\nAnd we have to do this for every elements in first column.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, int n,  int m, int pi, int pj, vector<vector<int>> &dp){\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        if(pi!=-1 && pj!=-1 && grid[i][j]<=grid[pi][pj]) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int way1 = f(i-1,j+1,grid,n,m,i,j,dp);\\n        int way2 = f(i,j+1,grid,n,m,i,j,dp);\\n        int way3 = f(i+1,j+1,grid,n,m,i,j,dp);\\n        return dp[i][j]=max(way1, max(way2, way3))+1;\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=-1;\\n        vector<vector<int>> dp(n+1, vector<int>(m,-1));\\n        for(int i=0; i<n; i++){\\n            int cnt = f(i,0,grid,n,m,-1,-1,dp);\\n            ans=max(ans, cnt-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, int n,  int m, int pi, int pj, vector<vector<int>> &dp){\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        if(pi!=-1 && pj!=-1 && grid[i][j]<=grid[pi][pj]) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int way1 = f(i-1,j+1,grid,n,m,i,j,dp);\\n        int way2 = f(i,j+1,grid,n,m,i,j,dp);\\n        int way3 = f(i+1,j+1,grid,n,m,i,j,dp);\\n        return dp[i][j]=max(way1, max(way2, way3))+1;\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=-1;\\n        vector<vector<int>> dp(n+1, vector<int>(m,-1));\\n        for(int i=0; i<n; i++){\\n            int cnt = f(i,0,grid,n,m,-1,-1,dp);\\n            ans=max(ans, cnt-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683639,
                "title": "easy-recursion-memoization-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int fun(int[][] grid,int i,int j,int val,int[][] dp){\\n        \\n        if(i>=0 && i<grid.length && j<grid[0].length && grid[i][j]>val)\\n        {\\n            if(dp[i][j]!=-1)\\n              return dp[i][j];\\n            int a=fun(grid,i-1,j+1,grid[i][j],dp);\\n            int b=fun(grid,i,j+1,grid[i][j],dp);\\n            int c=fun(grid,i+1,j+1,grid[i][j],dp);\\n            int d= Math.max(a,b);\\n            return dp[i][j]=Math.max(d,c)+1;\\n            \\n        }\\n        return  0;\\n    }\\n    public int maxMoves(int[][] grid) {\\n       int dp[][]= new int[grid.length+1][grid[0].length+1];\\n        for(int i[]:dp)\\n            Arrays.fill(i,-1);\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            maxi=Math.max(maxi,fun(grid,i,0,0,dp));\\n        }\\n        return maxi-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int fun(int[][] grid,int i,int j,int val,int[][] dp){\\n        \\n        if(i>=0 && i<grid.length && j<grid[0].length && grid[i][j]>val)\\n        {\\n            if(dp[i][j]!=-1)\\n              return dp[i][j];\\n            int a=fun(grid,i-1,j+1,grid[i][j],dp);\\n            int b=fun(grid,i,j+1,grid[i][j],dp);\\n            int c=fun(grid,i+1,j+1,grid[i][j],dp);\\n            int d= Math.max(a,b);\\n            return dp[i][j]=Math.max(d,c)+1;\\n            \\n        }\\n        return  0;\\n    }\\n    public int maxMoves(int[][] grid) {\\n       int dp[][]= new int[grid.length+1][grid[0].length+1];\\n        for(int i[]:dp)\\n            Arrays.fill(i,-1);\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            maxi=Math.max(maxi,fun(grid,i,0,0,dp));\\n        }\\n        return maxi-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683270,
                "title": "dfs-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDynamic Programming\\n\\n# Complexity\\n- Time complexity: $O(m * n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $O(m * n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dir = new int[][]{{-1, 1}, {0, 1}, {1, 1}};\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        Integer[][] memo = new Integer[m][n];\\n        int ans = 0;\\n\\n        for (int i = 0; i < m; i++)\\n            ans = Math.max(ans, dfs(i, 0, grid, memo));\\n        \\n        return ans;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid, Integer[][] memo) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) return 0;\\n        if (memo[i][j] != null) return memo[i][j];\\n        \\n        int move = 0;\\n        for (int[] d : dir) {\\n            int x = i + d[0], y = j + d[1];\\n            if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[i][j] >= grid[x][y])\\n                continue;\\n\\n            move = Math.max(move, dfs(x, y, grid, memo) + 1);\\n        } \\n\\n        return memo[i][j] = move;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = new int[][]{{-1, 1}, {0, 1}, {1, 1}};\\n    public int maxMoves(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        Integer[][] memo = new Integer[m][n];\\n        int ans = 0;\\n\\n        for (int i = 0; i < m; i++)\\n            ans = Math.max(ans, dfs(i, 0, grid, memo));\\n        \\n        return ans;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid, Integer[][] memo) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) return 0;\\n        if (memo[i][j] != null) return memo[i][j];\\n        \\n        int move = 0;\\n        for (int[] d : dir) {\\n            int x = i + d[0], y = j + d[1];\\n            if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[i][j] >= grid[x][y])\\n                continue;\\n\\n            move = Math.max(move, dfs(x, y, grid, memo) + 1);\\n        } \\n\\n        return memo[i][j] = move;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676724,
                "title": "dynamic-programming-simple-explanation-t-c-o-n-m-s-c-o-m-n",
                "content": "# **UPVOTE IF YOU LIKE**\\n\\n# Intuition\\nHere we needed to check all possible combinations and find the maximum number of steps one can take according to the conditions given by them so I have used Dynamic Programming\\n\\n# Approach\\nIn my recursive function I am moving to the next cell only when the next cell\\'s value is strictly greater than the current cell\\'s value \\n\\nans sum1, sum2, sum3 are for three digfferent direction\\n                   sum1\\n                   /\\\\\\n                   -\\n                  -\\n     current_cell- - - - > sum2\\n                 -\\n                  -\\n                   -\\n                   \\\\/\\n                   sum3\\n\\nand the we can just do memorization at the places where we are reurning the calculateed value  \\n\\n# Complexity\\n- Time complexity:\\nO[n*n]\\n\\n- Space complexity:\\nO[m*n]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int find_max_steps(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp)\\n    {\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int col=grid[0].size(), row=grid.size();\\n\\n        int sum1=0, sum2=0, sum3=0;\\n\\n        if(i-1>=0 && j+1<col && grid[i-1][j+1]>grid[i][j])\\n        {\\n            sum1=1+find_max_steps(grid, i-1, j+1, dp);\\n        }\\n\\n        if(j+1<col && grid[i][j+1]>grid[i][j])\\n        {\\n            sum2=1+find_max_steps(grid, i, j+1, dp);\\n        }\\n\\n        if(i+1<row && j+1<col && grid[i+1][j+1]>grid[i][j])\\n        {\\n            sum3=1+find_max_steps(grid, i+1, j+1, dp);\\n        }\\n\\n        return dp[i][j]= max(sum1, max(sum2, sum3));\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dp(grid.size()+1, vector<int> (grid[0].size()+1, -1));\\n        int i, sub_ans, max_ans=0;\\n        for(i=0;i<grid.size();i++)\\n        {\\n            sub_ans=find_max_steps(grid, i, 0, dp);\\n            max_ans=max(max_ans, sub_ans);\\n        }\\n\\n        return max_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find_max_steps(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp)\\n    {\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int col=grid[0].size(), row=grid.size();\\n\\n        int sum1=0, sum2=0, sum3=0;\\n\\n        if(i-1>=0 && j+1<col && grid[i-1][j+1]>grid[i][j])\\n        {\\n            sum1=1+find_max_steps(grid, i-1, j+1, dp);\\n        }\\n\\n        if(j+1<col && grid[i][j+1]>grid[i][j])\\n        {\\n            sum2=1+find_max_steps(grid, i, j+1, dp);\\n        }\\n\\n        if(i+1<row && j+1<col && grid[i+1][j+1]>grid[i][j])\\n        {\\n            sum3=1+find_max_steps(grid, i+1, j+1, dp);\\n        }\\n\\n        return dp[i][j]= max(sum1, max(sum2, sum3));\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dp(grid.size()+1, vector<int> (grid[0].size()+1, -1));\\n        int i, sub_ans, max_ans=0;\\n        for(i=0;i<grid.size();i++)\\n        {\\n            sub_ans=find_max_steps(grid, i, 0, dp);\\n            max_ans=max(max_ans, sub_ans);\\n        }\\n\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676569,
                "title": "simple-bfs-in-matrix",
                "content": "# Intuition\\nWe need to get max move and we can move if condition that value at next move is greater than current value is satisfied. Just do a bfs traversal starting from each element of col 0.\\n# Approach\\nJust bfs concept applied on a matrix.\\nFirst push all the element of col 0 in the queue.\\nQueue contains pair of two pair which stores following.\\n{{move,current_matrix_value},{row,col}}\\n\\nnow do bfs . That is keep traversing adjacent element which is (row+1,row,row-1) with col+1 for each element in queue and keep removing element from queue. Simultaneously keep updating ans with max of (ans,move).Once queue is empty return ans.Or if u reach last col then return m-1 since no move beyond that is possible.\\n\\nVisited is used since no matter from which element we reached that element the move upto that element will be fixed and move beyond that element will be same . for example move for any element of col 2 will be 2(one from col 0 to 1 and another for col 1 to 2). So its of no use to push same element twice in the queue.\\n\\n# Complexity\\n- Time complexity:\\nO(V+E) // for bfs\\nV=(number of vertex) here each element is a vertex that is n*m\\nE=(number of edges) For each element 3 edges possible so 3*n*m\\n=> O(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        queue<pair<pair<int,int>,pair<int,int>>> q;\\n        // {{move,current_matrix_value},{row,col}}\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        // pushing all values of col 0 in the queue\\n        for(int i=0;i<n;i++)\\n        {\\n            q.push({{0,grid[i][0]},{i,0}});\\n        }\\n        int delrow[]={-1,0,1};\\n        int ans=0;\\n        while(!q.empty())            \\n        {\\n            int move=q.front().first.first;\\n            int val=q.front().first.second;\\n            int row=q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            // keep updating answer with the number of move\\n            ans=max(ans,move);\\n            // if the element is of last col no need to check further since that is the max amount of move possible\\n            if(col==m-1)\\n            {\\n                return m-1;\\n            }\\n            // check for all possible move in next col for row+1, row, row-1 using delrow and col+1\\n            for(int i=0;i<3;i++)\\n            {\\n                int nrow=row+delrow[i];//neighbour row\\n                int ncol=col+1;// neighbour col\\n                if(nrow>=0 and nrow<n and !visited[nrow][ncol] and grid[nrow][ncol] > val)\\n                {\\n                    visited[nrow][ncol]=true;\\n                    q.push({{(move+1),(grid[nrow][ncol])},{nrow,ncol}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        queue<pair<pair<int,int>,pair<int,int>>> q;\\n        // {{move,current_matrix_value},{row,col}}\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        // pushing all values of col 0 in the queue\\n        for(int i=0;i<n;i++)\\n        {\\n            q.push({{0,grid[i][0]},{i,0}});\\n        }\\n        int delrow[]={-1,0,1};\\n        int ans=0;\\n        while(!q.empty())            \\n        {\\n            int move=q.front().first.first;\\n            int val=q.front().first.second;\\n            int row=q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            // keep updating answer with the number of move\\n            ans=max(ans,move);\\n            // if the element is of last col no need to check further since that is the max amount of move possible\\n            if(col==m-1)\\n            {\\n                return m-1;\\n            }\\n            // check for all possible move in next col for row+1, row, row-1 using delrow and col+1\\n            for(int i=0;i<3;i++)\\n            {\\n                int nrow=row+delrow[i];//neighbour row\\n                int ncol=col+1;// neighbour col\\n                if(nrow>=0 and nrow<n and !visited[nrow][ncol] and grid[nrow][ncol] > val)\\n                {\\n                    visited[nrow][ncol]=true;\\n                    q.push({{(move+1),(grid[nrow][ncol])},{nrow,ncol}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673765,
                "title": "dfs-dp-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(m * n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(m * n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    int moves[][] = {{-1,1},{0,1},{1,1}};\\n    int dp[][];\\n    int helper(int grid[][],int x,int y){\\n        if(dp[x][y] != -1) return dp[x][y];\\n        int ans = 0;\\n        for(var m:moves){\\n            int n_x = x + m[0];\\n            int n_y = y + m[1];\\n            if(n_x < 0 || n_x >= grid.length || n_y < 0 || n_y >= grid[0].length || grid[n_x][n_y] <= grid[x][y]) continue;\\n            ans = Math.max(ans,1 + helper(grid,n_x,n_y));\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    public int maxMoves(int[][] grid) {\\n        dp = new int[grid.length][grid[0].length];\\n        for(var a:dp) Arrays.fill(a,-1);\\n        int ans = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            ans = Math.max(ans,helper(grid,i,0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    int moves[][] = {{-1,1},{0,1},{1,1}};\\n    int dp[][];\\n    int helper(int grid[][],int x,int y){\\n        if(dp[x][y] != -1) return dp[x][y];\\n        int ans = 0;\\n        for(var m:moves){\\n            int n_x = x + m[0];\\n            int n_y = y + m[1];\\n            if(n_x < 0 || n_x >= grid.length || n_y < 0 || n_y >= grid[0].length || grid[n_x][n_y] <= grid[x][y]) continue;\\n            ans = Math.max(ans,1 + helper(grid,n_x,n_y));\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    public int maxMoves(int[][] grid) {\\n        dp = new int[grid.length][grid[0].length];\\n        for(var a:dp) Arrays.fill(a,-1);\\n        int ans = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            ans = Math.max(ans,helper(grid,i,0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670495,
                "title": "c-clean-solution-easy-to-understand-dfs-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dir[3][2] = {{-1, 1}, {0, 1}, {1, 1}};\\n    \\n    vector<vector<int>> memo;\\n\\n    int findMax(vector<vector<int>>& grid, int i, int j) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n\\n        if(memo[i][j] != -1) return memo[i][j];\\n\\n        int ans = 0;\\n        for(auto d: dir) {\\n            int newI = i + d[0];\\n            int newJ = j + d[1];\\n            if(newI < grid.size() && newJ < grid[0].size()) {\\n                if(grid[newI][newJ] > grid[i][j]) {\\n                    ans = max(ans, 1 + findMax(grid, newI, newJ));\\n                }\\n            }\\n        }\\n\\n        return memo[i][j] = ans;\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        memo.resize(grid.size() + 1, vector<int>(grid[0].size() + 1, -1));\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++) {\\n            ans = max(ans, findMax(grid, i, 0));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[3][2] = {{-1, 1}, {0, 1}, {1, 1}};\\n    \\n    vector<vector<int>> memo;\\n\\n    int findMax(vector<vector<int>>& grid, int i, int j) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n\\n        if(memo[i][j] != -1) return memo[i][j];\\n\\n        int ans = 0;\\n        for(auto d: dir) {\\n            int newI = i + d[0];\\n            int newJ = j + d[1];\\n            if(newI < grid.size() && newJ < grid[0].size()) {\\n                if(grid[newI][newJ] > grid[i][j]) {\\n                    ans = max(ans, 1 + findMax(grid, newI, newJ));\\n                }\\n            }\\n        }\\n\\n        return memo[i][j] = ans;\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        memo.resize(grid.size() + 1, vector<int>(grid[0].size() + 1, -1));\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++) {\\n            ans = max(ans, findMax(grid, i, 0));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668862,
                "title": "python-concise-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def dfs(i,j):\\n            if (i,j) in memo: return memo[(i,j)]\\n            count = 0\\n            for dx, dy in [[-1,1],[0,1],[1,1]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and grid[x][y] > grid[i][j]:\\n                    count = max(count, 1 + dfs(x,y))\\n            memo[(i,j)] = count\\n            return count\\n        \\n        memo, m, n, ans = {}, len(grid), len(grid[0]), 0\\n        return max(dfs(i,0) for i in range(m))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def dfs(i,j):\\n            if (i,j) in memo: return memo[(i,j)]\\n            count = 0\\n            for dx, dy in [[-1,1],[0,1],[1,1]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and grid[x][y] > grid[i][j]:\\n                    count = max(count, 1 + dfs(x,y))\\n            memo[(i,j)] = count\\n            return count\\n        \\n        memo, m, n, ans = {}, len(grid), len(grid[0]), 0\\n        return max(dfs(i,0) for i in range(m))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668861,
                "title": "python-concise-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def dfs(i,j):\\n            if (i,j) in memo: return memo[(i,j)]\\n            count = 0\\n            for dx, dy in [[-1,1],[0,1],[1,1]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and grid[x][y] > grid[i][j]:\\n                    count = max(count, 1 + dfs(x,y))\\n            memo[(i,j)] = count\\n            return count\\n        \\n        memo, m, n, ans = {}, len(grid), len(grid[0]), 0\\n        return max(dfs(i,0) for i in range(m))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def dfs(i,j):\\n            if (i,j) in memo: return memo[(i,j)]\\n            count = 0\\n            for dx, dy in [[-1,1],[0,1],[1,1]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and grid[x][y] > grid[i][j]:\\n                    count = max(count, 1 + dfs(x,y))\\n            memo[(i,j)] = count\\n            return count\\n        \\n        memo, m, n, ans = {}, len(grid), len(grid[0]), 0\\n        return max(dfs(i,0) for i in range(m))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666899,
                "title": "dp-c-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        if(dp[i][j]!=-1){return dp[i][j];}\\n        vector<vector<int>> dir = {{-1,1},{1,1},{0,1}};\\n        int maxans=0;\\n        for(int k=0;k<3;k++){\\n            int ans = 0;\\n            int nx = i+dir[k][0];\\n            int ny = j+dir[k][1];\\n            if(nx>=0&&nx<grid.size()&&ny>=0&&ny<grid[0].size()&&grid[nx][ny]>grid[i][j]){\\n                ans=1+solve(grid,nx,ny);\\n            }\\n            maxans = max(ans,maxans);            \\n        }\\n        return dp[i][j]= maxans;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        dp.resize(grid.size(),vector<int>(grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            ans = max(ans,solve(grid,i,0));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        if(dp[i][j]!=-1){return dp[i][j];}\\n        vector<vector<int>> dir = {{-1,1},{1,1},{0,1}};\\n        int maxans=0;\\n        for(int k=0;k<3;k++){\\n            int ans = 0;\\n            int nx = i+dir[k][0];\\n            int ny = j+dir[k][1];\\n            if(nx>=0&&nx<grid.size()&&ny>=0&&ny<grid[0].size()&&grid[nx][ny]>grid[i][j]){\\n                ans=1+solve(grid,nx,ny);\\n            }\\n            maxans = max(ans,maxans);            \\n        }\\n        return dp[i][j]= maxans;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        dp.resize(grid.size(),vector<int>(grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            ans = max(ans,solve(grid,i,0));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666827,
                "title": "easy-solution-without-dp",
                "content": "# Intuition\\nThe problem aims to find the maximum number of moves that can be made in a grid while following certain rules. The rules for making moves are not explicitly mentioned in the code, but we can infer them based on the implementation.\\n\\n# Approach\\nThe given code aims to find the maximum number of moves that can be made in a grid. It uses a depth-first search (DFS) approach to explore all possible paths. Starting from each cell in the leftmost column, it recursively moves to adjacent cells in the right-up, right, and right-down directions, considering only cells with values greater than the previous value. The maximum number of moves obtained from each path is tracked, and the overall maximum is returned as the result.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        vector<vector<int>> vis(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            ans=max(ans,dfs(row,col,grid,i,0,INT_MIN,vis));\\n        }\\n        return ans-1;  \\n    }\\n\\n    int dfs(int row,int col,vector<vector<int>>& grid,int i,int j,int prev, vector<vector<int>> &vis){\\n        if(i<0 || j<0 || i>=row || j>=col || grid[i][j]<=prev) return 0;\\n        int val=grid[i][j];\\n        if(vis[i][j]==1) return 0;\\n        vis[i][j]=1;\\n        int res=max({dfs(row,col,grid,i-1,j+1,val,vis),dfs(row,col,grid,i,j+1,val,vis),dfs(row,col,grid,i+1,j+1,val,vis)})+1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        vector<vector<int>> vis(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            ans=max(ans,dfs(row,col,grid,i,0,INT_MIN,vis));\\n        }\\n        return ans-1;  \\n    }\\n\\n    int dfs(int row,int col,vector<vector<int>>& grid,int i,int j,int prev, vector<vector<int>> &vis){\\n        if(i<0 || j<0 || i>=row || j>=col || grid[i][j]<=prev) return 0;\\n        int val=grid[i][j];\\n        if(vis[i][j]==1) return 0;\\n        vis[i][j]=1;\\n        int res=max({dfs(row,col,grid,i-1,j+1,val,vis),dfs(row,col,grid,i,j+1,val,vis),dfs(row,col,grid,i+1,j+1,val,vis)})+1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663884,
                "title": "c-dp-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int dp[1001][1001];\\n    int solve(vector<vector<int>>& g,int i,int j,int pv){\\n        if(min(i,j)<0 || i>=m || j>=n || g[i][j]<=pv ) return -1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=1+max({solve(g,i-1,j+1,g[i][j]),solve(g,i,j+1,g[i][j]),solve(g,i+1,j+1,g[i][j])});\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& g) {\\n        m=size(g),n=size(g[0]);\\n        int mx=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;++i) mx=max(solve(g,i,0,-1),mx);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int dp[1001][1001];\\n    int solve(vector<vector<int>>& g,int i,int j,int pv){\\n        if(min(i,j)<0 || i>=m || j>=n || g[i][j]<=pv ) return -1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=1+max({solve(g,i-1,j+1,g[i][j]),solve(g,i,j+1,g[i][j]),solve(g,i+1,j+1,g[i][j])});\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& g) {\\n        m=size(g),n=size(g[0]);\\n        int mx=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;++i) mx=max(solve(g,i,0,-1),mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659474,
                "title": "c-beats-92-simplest-approach-using-memoization-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint dfs(int r,int c, vector<vector<int>>&dp,vector<vector<int>>&grid)\\n{\\n    if(dp[r][c]!=-1)\\n    return dp[r][c];\\n    int ans=0;\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(r-1>=0&&c+1<m&&r-1<n&&c+1>=0&&grid[r-1][c+1]>grid[r][c])\\n    {\\n        ans=max(ans,dfs(r-1,c+1,dp,grid));\\n    }\\n    if(r>=0&&c+1<m&&r<n&&c+1>=0&&grid[r][c+1]>grid[r][c])\\n    {\\n        ans=max(ans,dfs(r,c+1,dp,grid));\\n    }\\n    if(r+1>=0&&r+1<n&&c+1<m&&c+1>=0&&grid[r+1][c+1]>grid[r][c])\\n    {\\n        ans=max(ans,dfs(r+1,c+1,dp,grid));\\n    }\\n    return dp[r][c]=ans+1;\\n}\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,dfs(i,0,dp,grid));\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dfs(int r,int c, vector<vector<int>>&dp,vector<vector<int>>&grid)\\n{\\n    if(dp[r][c]!=-1)\\n    return dp[r][c];\\n    int ans=0;\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(r-1>=0&&c+1<m&&r-1<n&&c+1>=0&&grid[r-1][c+1]>grid[r][c])\\n    {\\n        ans=max(ans,dfs(r-1,c+1,dp,grid));\\n    }\\n    if(r>=0&&c+1<m&&r<n&&c+1>=0&&grid[r][c+1]>grid[r][c])\\n    {\\n        ans=max(ans,dfs(r,c+1,dp,grid));\\n    }\\n    if(r+1>=0&&r+1<n&&c+1<m&&c+1>=0&&grid[r+1][c+1]>grid[r][c])\\n    {\\n        ans=max(ans,dfs(r+1,c+1,dp,grid));\\n    }\\n    return dp[r][c]=ans+1;\\n}\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,dfs(i,0,dp,grid));\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657739,
                "title": "easy-to-understand-and-clean-c-solution-using-dfs-dp",
                "content": "# Intuition\\nPrerequisite: DP on grid\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m) + O(n)[Space required by the recursion tree] \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int compute(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(j == grid[0].size()-1)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int first = 0;\\n        if(i-1>=0 && grid[i][j] < grid[i-1][j+1])\\n            first = 1+compute(i-1, j+1, grid, dp);\\n\\n        int second = 0;\\n        if(grid[i][j] < grid[i][j+1])\\n            second = 1+compute(i, j+1, grid, dp);\\n\\n        int third = 0;\\n        if(i+1 < grid.size() && grid[i][j] < grid[i+1][j+1])\\n            third = 1+compute(i+1, j+1, grid, dp);\\n        \\n        int mx  = max(first, max(second, third));\\n        return dp[i][j] = mx; \\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>>dp(n, vector<int>(m,-1));\\n\\n        for(int i=0; i<n; i++)\\n            ans = max(ans, compute(i, 0, grid, dp));\\n        \\n        return ans;\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int compute(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(j == grid[0].size()-1)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int first = 0;\\n        if(i-1>=0 && grid[i][j] < grid[i-1][j+1])\\n            first = 1+compute(i-1, j+1, grid, dp);\\n\\n        int second = 0;\\n        if(grid[i][j] < grid[i][j+1])\\n            second = 1+compute(i, j+1, grid, dp);\\n\\n        int third = 0;\\n        if(i+1 < grid.size() && grid[i][j] < grid[i+1][j+1])\\n            third = 1+compute(i+1, j+1, grid, dp);\\n        \\n        int mx  = max(first, max(second, third));\\n        return dp[i][j] = mx; \\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>>dp(n, vector<int>(m,-1));\\n\\n        for(int i=0; i<n; i++)\\n            ans = max(ans, compute(i, 0, grid, dp));\\n        \\n        return ans;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652239,
                "title": "java-dfs-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Problem is same as Leetcode: 329 & Leetcode: 2328. We have to Perform a Recursive DFS from each cell in the 1st Column & cache our results at every point. We will have 3 Options to travel from our current cell, \\n`(x - 1, y + 1)`, `(x, y + 1)`, `(x + 1, y + 1)`. Store the retrieved Results in `dp[x][y]`\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] directions = {{-1,1},{0,1},{1,1}};\\n    int max = 0;\\n\\n    public int maxMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int[][] dp = new int[rows][cols];\\n\\n        for(int i = 0; i < rows; i++)\\n            Arrays.fill(dp[i], -1);\\n\\n        for(int i = 0; i < rows; i++)\\n            calculateMoves(i, 0, rows, cols, grid, dp, -1);\\n        \\n        return max;\\n    }\\n\\n    private int calculateMoves(int x, int y, int rows, int cols, int[][] grid, int[][] dp, int prev)\\n    {\\n        if(x < 0 || x == rows) return 0;\\n        if(y < 0 || y == cols) return 0;\\n        if(grid[x][y] <= prev) return 0;\\n\\n        if(dp[x][y] != -1) return dp[x][y];\\n\\n        for(int k = 0; k < 3; k++)\\n        {\\n            int nx = x + directions[k][0];\\n            int ny = y + directions[k][1];\\n\\n            int current = calculateMoves(nx, ny, rows, cols, grid, dp, grid[x][y]);\\n            dp[x][y] = Math.max(dp[x][y], current);\\n        }\\n\\n        max = Math.max(max, dp[x][y]);\\n        return dp[x][y] + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{-1,1},{0,1},{1,1}};\\n    int max = 0;\\n\\n    public int maxMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int[][] dp = new int[rows][cols];\\n\\n        for(int i = 0; i < rows; i++)\\n            Arrays.fill(dp[i], -1);\\n\\n        for(int i = 0; i < rows; i++)\\n            calculateMoves(i, 0, rows, cols, grid, dp, -1);\\n        \\n        return max;\\n    }\\n\\n    private int calculateMoves(int x, int y, int rows, int cols, int[][] grid, int[][] dp, int prev)\\n    {\\n        if(x < 0 || x == rows) return 0;\\n        if(y < 0 || y == cols) return 0;\\n        if(grid[x][y] <= prev) return 0;\\n\\n        if(dp[x][y] != -1) return dp[x][y];\\n\\n        for(int k = 0; k < 3; k++)\\n        {\\n            int nx = x + directions[k][0];\\n            int ny = y + directions[k][1];\\n\\n            int current = calculateMoves(nx, ny, rows, cols, grid, dp, grid[x][y]);\\n            dp[x][y] = Math.max(dp[x][y], current);\\n        }\\n\\n        max = Math.max(max, dp[x][y]);\\n        return dp[x][y] + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649369,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, int &m, int &n, vector<vector<int>> &grid, vector<vector<int>> &ans, vector<vector<bool>> &vis){\\n        if(vis[i][j] ) return ans[i][j];\\n        \\n        int m1=0, m2 =0, m3 =0;\\n        if(i-1 >=0 && j+1 < n && grid[i-1][j+1] > grid[i][j])\\n         m1 = 1 + dfs(i-1, j+1, m, n, grid, ans, vis);\\n        if(j+1 < n && grid[i][j+1] > grid[i][j])\\n         m2 = 1 + dfs(i, j+1, m,n, grid, ans, vis);\\n        if(i+1 < m && j+1 <n && grid[i+1][j+1] > grid[i][j])\\n         m3 = 1 + dfs(i+1, j+1, m, n, grid, ans, vis);\\n         \\n         vis[i][j] = true;\\n         ans[i][j] = max(m1, max(m2, m3));\\n\\n         return ans[i][j];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        vector<vector<bool>> vis(m, vector<bool>(n, false) );\\n        int res=0;\\n         for(int i=0; i<m; i++){\\n           res = max(res, dfs(i, 0, m, n, grid, ans, vis) );\\n          } \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, int &m, int &n, vector<vector<int>> &grid, vector<vector<int>> &ans, vector<vector<bool>> &vis){\\n        if(vis[i][j] ) return ans[i][j];\\n        \\n        int m1=0, m2 =0, m3 =0;\\n        if(i-1 >=0 && j+1 < n && grid[i-1][j+1] > grid[i][j])\\n         m1 = 1 + dfs(i-1, j+1, m, n, grid, ans, vis);\\n        if(j+1 < n && grid[i][j+1] > grid[i][j])\\n         m2 = 1 + dfs(i, j+1, m,n, grid, ans, vis);\\n        if(i+1 < m && j+1 <n && grid[i+1][j+1] > grid[i][j])\\n         m3 = 1 + dfs(i+1, j+1, m, n, grid, ans, vis);\\n         \\n         vis[i][j] = true;\\n         ans[i][j] = max(m1, max(m2, m3));\\n\\n         return ans[i][j];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        vector<vector<bool>> vis(m, vector<bool>(n, false) );\\n        int res=0;\\n         for(int i=0; i<m; i++){\\n           res = max(res, dfs(i, 0, m, n, grid, ans, vis) );\\n          } \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643565,
                "title": "python-easy-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n\\n        global nrows\\n\\n        global ncol\\n\\n        global mx\\n\\n        mx = float(\"-inf\")\\n\\n        nrows = len(grid)\\n\\n        ncol = len(grid[0])\\n\\n        global li\\n\\n        li = []\\n\\n        for i in range(nrows):\\n\\n            a = []\\n\\n            for j in range(ncol):\\n\\n                a.append(0)\\n\\n            li.append(a)\\n\\n\\n\\n        def trace(m,n):\\n\\n            global nrows\\n\\n            global ncol\\n\\n            global mx\\n\\n            global li\\n\\n            s = 0\\n\\n            up = 0\\n\\n            down = 0\\n\\n\\n            if(n < (ncol-1)):\\n\\n                if(grid[m][n+1]> grid[m][n]):\\n\\n                    if(li[m][n+1] != 0):\\n\\n                        s = 1 + li[m][n+1]\\n\\n                    else:\\n\\n                        s = 1 + trace(m,n+1)\\n\\n            if(n < (ncol-1) and m > 0):\\n\\n                if(grid[m-1][n+1]> grid[m][n]):\\n\\n                    if(li[m-1][n+1] != 0):\\n\\n                        up = 1 + li[m-1][n+1]\\n\\n                    else:\\n\\n                        up = 1 + trace(m-1,n+1)\\n\\n            if(n < (ncol-1) and m < (nrows-1)):\\n\\n                if(grid[m+1][n+1]> grid[m][n]):\\n\\n                    if(li[m+1][n+1] != 0):\\n\\n                        down = 1 + li[m+1][n+1]                    \\n\\n                    else:\\n\\n                        down = 1 + trace(m+1,n+1)            \\n\\n\\n            mxx = max(s,up,down)\\n\\n\\n\\n            li[m][n] = mxx\\n\\n            if(mxx>mx):\\n\\n                mx = mxx\\n\\n            return mxx\\n\\n\\n        for i in range(nrows):\\n\\n\\n            trace(i,0)\\n\\n\\n        return   mx      \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n\\n\\n        global nrows\\n\\n        global ncol\\n\\n        global mx\\n\\n        mx = float(\"-inf\")\\n\\n        nrows = len(grid)\\n\\n        ncol = len(grid[0])\\n\\n        global li\\n\\n        li = []\\n\\n        for i in range(nrows):\\n\\n            a = []\\n\\n            for j in range(ncol):\\n\\n                a.append(0)\\n\\n            li.append(a)\\n\\n\\n\\n        def trace(m,n):\\n\\n            global nrows\\n\\n            global ncol\\n\\n            global mx\\n\\n            global li\\n\\n            s = 0\\n\\n            up = 0\\n\\n            down = 0\\n\\n\\n            if(n < (ncol-1)):\\n\\n                if(grid[m][n+1]> grid[m][n]):\\n\\n                    if(li[m][n+1] != 0):\\n\\n                        s = 1 + li[m][n+1]\\n\\n                    else:\\n\\n                        s = 1 + trace(m,n+1)\\n\\n            if(n < (ncol-1) and m > 0):\\n\\n                if(grid[m-1][n+1]> grid[m][n]):\\n\\n                    if(li[m-1][n+1] != 0):\\n\\n                        up = 1 + li[m-1][n+1]\\n\\n                    else:\\n\\n                        up = 1 + trace(m-1,n+1)\\n\\n            if(n < (ncol-1) and m < (nrows-1)):\\n\\n                if(grid[m+1][n+1]> grid[m][n]):\\n\\n                    if(li[m+1][n+1] != 0):\\n\\n                        down = 1 + li[m+1][n+1]                    \\n\\n                    else:\\n\\n                        down = 1 + trace(m+1,n+1)            \\n\\n\\n            mxx = max(s,up,down)\\n\\n\\n\\n            li[m][n] = mxx\\n\\n            if(mxx>mx):\\n\\n                mx = mxx\\n\\n            return mxx\\n\\n\\n        for i in range(nrows):\\n\\n\\n            trace(i,0)\\n\\n\\n        return   mx      \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642981,
                "title": "c-memoisation-using-dp-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxMoves(vector<vector<int>>& gr,int prev,int row,int col,int max_row,int max_col,vector<vector<int>>& dp){\\n        if(row < 0 or row == max_row or col == max_col)return -1;\\n        \\n        if(gr[row][col] <= prev)return -1;\\n        \\n        if(dp[row][col] != -1)return dp[row][col];\\n        \\n        int first,second,third;\\n        \\n        first = 1 + findMaxMoves(gr,gr[row][col],row-1,col+1,max_row,max_col,dp);\\n        \\n        second = 1 + findMaxMoves(gr,gr[row][col],row,col+1,max_row,max_col,dp);\\n        \\n        third = 1 + findMaxMoves(gr,gr[row][col],row+1,col+1,max_row,max_col,dp);\\n        \\n        dp[row][col] = max(first, max(second,third));\\n        \\n        return dp[row][col];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int result = 0;\\n        for(int i=0;i<m;i++){\\n            result = max(result,findMaxMoves(grid,-1,i,0,m,n,dp));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxMoves(vector<vector<int>>& gr,int prev,int row,int col,int max_row,int max_col,vector<vector<int>>& dp){\\n        if(row < 0 or row == max_row or col == max_col)return -1;\\n        \\n        if(gr[row][col] <= prev)return -1;\\n        \\n        if(dp[row][col] != -1)return dp[row][col];\\n        \\n        int first,second,third;\\n        \\n        first = 1 + findMaxMoves(gr,gr[row][col],row-1,col+1,max_row,max_col,dp);\\n        \\n        second = 1 + findMaxMoves(gr,gr[row][col],row,col+1,max_row,max_col,dp);\\n        \\n        third = 1 + findMaxMoves(gr,gr[row][col],row+1,col+1,max_row,max_col,dp);\\n        \\n        dp[row][col] = max(first, max(second,third));\\n        \\n        return dp[row][col];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int result = 0;\\n        for(int i=0;i<m;i++){\\n            result = max(result,findMaxMoves(grid,-1,i,0,m,n,dp));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642670,
                "title": "c-dijkstra-based-solution-using-dist-matrix",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> dx={-1,0,1};\\n    vector<int> dy={1,1,1};\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m= grid.size();\\n        int n= grid[0].size();\\n        \\n        queue<pair<int,pair<int,int>>> q;\\n        \\n        int ans=0;\\n        vector<vector<int>> dist(m,vector<int>(n,INT_MIN));\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            if((i-1>=0 && grid[i-1][1]<=grid[i][0]) && grid[i][1]<=grid[i][0] && (i+1<m && grid[i+1][1]<=grid[i][0]))\\n                continue;\\n            \\n            else\\n            {\\n                q.push({0,{i,0}});\\n                dist[i][0]=0;\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto p= q.front();\\n            q.pop();\\n            \\n            int moves= p.first;\\n            int x= p.second.first;\\n            int y= p.second.second;\\n            \\n            for(int i=0;i<3;i++)\\n            {\\n                int newx= x+dx[i];\\n                int newy= y+dy[i];\\n                \\n                if(newx>=0 && newy>=0 && newx<m && newy<n && grid[newx][newy]>grid[x][y] && dist[newx][newy]<moves+1)\\n                {\\n                    dist[newx][newy]=moves+1;\\n                    q.push({moves+1,{newx,newy}});\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans= max(ans,dist[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> dx={-1,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 3636379,
                "title": "maximum-number-of-moves-in-a-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, mat: List[List[int]]) -> int:\\n        def rec(r,c,n,m):\\n            for u,v in [[-1,1],[0,1],[1,1]]:\\n                nr=r+u\\n                nc=c+v\\n                if nr>-1 and nc>-1 and nr<n and nc<m and mat[nr][nc]>mat[r][c] and dp[nr][nc]<dp[r][c]+1:\\n                    dp[nr][nc]=dp[r][c]+1\\n                    rec(nr,nc,n,m)       \\n        n=len(mat)\\n        m=len(mat[0])\\n        dp=[[1]*m for i in range(n)]\\n        for i in range(n):\\n            \\n                rec(i,0,n,m)\\n                # print(dp)\\n        maxi=1\\n        for i in dp:\\n            maxi=max(maxi,max(i))\\n        return maxi-1 \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, mat: List[List[int]]) -> int:\\n        def rec(r,c,n,m):\\n            for u,v in [[-1,1],[0,1],[1,1]]:\\n                nr=r+u\\n                nc=c+v\\n                if nr>-1 and nc>-1 and nr<n and nc<m and mat[nr][nc]>mat[r][c] and dp[nr][nc]<dp[r][c]+1:\\n                    dp[nr][nc]=dp[r][c]+1\\n                    rec(nr,nc,n,m)       \\n        n=len(mat)\\n        m=len(mat[0])\\n        dp=[[1]*m for i in range(n)]\\n        for i in range(n):\\n            \\n                rec(i,0,n,m)\\n                # print(dp)\\n        maxi=1\\n        for i in dp:\\n            maxi=max(maxi,max(i))\\n        return maxi-1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634516,
                "title": "dp-time-o-rows-cols-space-o-rows",
                "content": "class Solution(object):\\n    def maxMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        \\n        if COLS == 1:\\n            return 0\\n        \\n        dp = [0 for r in range(ROWS)]\\n        dp_prev = [0 for r in range(ROWS)]\\n        \\n        for c in range(COLS-2,-1,-1):\\n            for r in range(ROWS):\\n                dp[r] = 0\\n                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:\\n                    dp[r] = max(dp[r], dp_prev[r-1] + 1)\\n                    \\n                if r+1 < ROWS and grid[r][c] < grid[r+1][c+1]:\\n                    dp[r] = max(dp[r], dp_prev[r+1] + 1)\\n                    \\n                if grid[r][c] < grid[r][c+1]:\\n                    dp[r] = max(dp[r], dp_prev[r] + 1)\\n            \\n            dp_prev[:] = dp[:]\\n        \\n        return max(dp)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        \\n        if COLS == 1:\\n            return 0\\n        \\n        dp = [0 for r in range(ROWS)]\\n        dp_prev = [0 for r in range(ROWS)]\\n        \\n        for c in range(COLS-2,-1,-1):\\n            for r in range(ROWS):\\n                dp[r] = 0\\n                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:\\n                    dp[r] = max(dp[r], dp_prev[r-1] + 1)\\n                    \\n                if r+1 < ROWS and grid[r][c] < grid[r+1][c+1]:\\n                    dp[r] = max(dp[r], dp_prev[r+1] + 1)\\n                    \\n                if grid[r][c] < grid[r][c+1]:\\n                    dp[r] = max(dp[r], dp_prev[r] + 1)\\n            \\n            dp_prev[:] = dp[:]\\n        \\n        return max(dp)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3631102,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n        ans = 0\\n        dp = [0 for _ in range(n)]\\n        \\n        for j in range(1, m):\\n            new_dp = [float(\\'-inf\\') for _ in range(n)]\\n            for i in range(n):\\n                c1 = dp[i-1] +1 if (i>0 and grid[i-1][j-1] < grid[i][j]) else float(\\'-inf\\')\\n                c2 = dp[i] +1 if (grid[i][j-1] < grid[i][j]) else float(\\'-inf\\')\\n                c3 = dp[i+1] +1 if (i+1<n and grid[i+1][j-1] < grid[i][j]) else float(\\'-inf\\')\\n                new_dp[i] = max(c1,c2,c3)\\n                ans = max(ans, new_dp[i])\\n            dp = new_dp\\n                \\n        print(dp)\\n        return ans\\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n        ans = 0\\n        dp = [0 for _ in range(n)]\\n        \\n        for j in range(1, m):\\n            new_dp = [float(\\'-inf\\') for _ in range(n)]\\n            for i in range(n):\\n                c1 = dp[i-1] +1 if (i>0 and grid[i-1][j-1] < grid[i][j]) else float(\\'-inf\\')\\n                c2 = dp[i] +1 if (grid[i][j-1] < grid[i][j]) else float(\\'-inf\\')\\n                c3 = dp[i+1] +1 if (i+1<n and grid[i+1][j-1] < grid[i][j]) else float(\\'-inf\\')\\n                new_dp[i] = max(c1,c2,c3)\\n                ans = max(ans, new_dp[i])\\n            dp = new_dp\\n                \\n        print(dp)\\n        return ans\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629074,
                "title": "java-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njava DP\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int[][] dp = new int[rows][cols];\\n        for(int i=0;i<rows;i++) dp[i][0] = 1; // we can start from any grid at first column\\n        int max = 0;\\n        for(int col=1;col<cols;col++){\\n            for(int row=0;row<rows;row++){\\n                if(dp[row][col-1]>0 && grid[row][col-1]<grid[row][col]){ //checking with left grid, whether can we move from left grid to here\\n                        dp[row][col] = Math.max(dp[row][col], dp[row][col-1]+1);\\n                }\\n                if(row>0){\\n                    if(dp[row-1][col-1]>0 && grid[row-1][col-1]<grid[row][col]) //checking with left/top grid, whether can we move from left/top grid to here\\n                        dp[row][col] = Math.max(dp[row][col], dp[row-1][col-1]+1);\\n                }\\n                if(row<rows-1){\\n                    if(dp[row+1][col-1]>0 && grid[row+1][col-1]<grid[row][col])//checking with left/bottom grid, whether can we move from left/bottom grid to here\\n                        dp[row][col] = Math.max(dp[row][col], dp[row+1][col-1]+1);\\n                }\\n                max = Math.max(max,dp[row][col]);\\n            }\\n        }\\n        return max==0 ? max : max-1; \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int[][] dp = new int[rows][cols];\\n        for(int i=0;i<rows;i++) dp[i][0] = 1; // we can start from any grid at first column\\n        int max = 0;\\n        for(int col=1;col<cols;col++){\\n            for(int row=0;row<rows;row++){\\n                if(dp[row][col-1]>0 && grid[row][col-1]<grid[row][col]){ //checking with left grid, whether can we move from left grid to here\\n                        dp[row][col] = Math.max(dp[row][col], dp[row][col-1]+1);\\n                }\\n                if(row>0){\\n                    if(dp[row-1][col-1]>0 && grid[row-1][col-1]<grid[row][col]) //checking with left/top grid, whether can we move from left/top grid to here\\n                        dp[row][col] = Math.max(dp[row][col], dp[row-1][col-1]+1);\\n                }\\n                if(row<rows-1){\\n                    if(dp[row+1][col-1]>0 && grid[row+1][col-1]<grid[row][col])//checking with left/bottom grid, whether can we move from left/bottom grid to here\\n                        dp[row][col] = Math.max(dp[row][col], dp[row+1][col-1]+1);\\n                }\\n                max = Math.max(max,dp[row][col]);\\n            }\\n        }\\n        return max==0 ? max : max-1; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627032,
                "title": "dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n\\n        int m= grid.length;\\n        int n= grid[0].length;\\n        //in dp we store max number of moves that can be made to reach that cell\\n        int dp[][]= new int[grid.length][grid[0].length];\\n\\n        //initialize dp\\n        for(int j=0; j<grid.length; j++){\\n            Arrays.fill(dp[j], -1);\\n        }\\n        //initialize base case\\n        for(int i=0; i<m; i++)\\n            dp[i][0]=0;\\n\\n        int max=0; //we keep a running maximum\\n        for(int j=1; j<n; j++){\\n            for(int i=0; i<m; i++){\\n                //we can reach a position from 3 places\\n                //1.same row, 1 column behind\\n                if(dp[i][j-1]!=-1 && grid[i][j-1] < grid[i][j])\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j-1]+1);\\n                //2. one row behind and one column behind\\n                if(i!=0){\\n                    if(dp[i-1][j-1]!=-1 && grid[i-1][j-1] < grid[i][j])\\n                        dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1]+1);\\n                }\\n                //3. one row ahead, one column behind\\n                if(i!=m-1){\\n                    if(dp[i+1][j-1]!=-1 && grid[i+1][j-1] < grid[i][j])\\n                        dp[i][j] = Math.max(dp[i][j], dp[i+1][j-1]+1);\\n                }\\n                max= Math.max(dp[i][j], max);\\n            }\\n            \\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxMoves(int[][] grid) {\\n\\n        int m= grid.length;\\n        int n= grid[0].length;\\n        //in dp we store max number of moves that can be made to reach that cell\\n        int dp[][]= new int[grid.length][grid[0].length];\\n\\n        //initialize dp\\n        for(int j=0; j<grid.length; j++){\\n            Arrays.fill(dp[j], -1);\\n        }\\n        //initialize base case\\n        for(int i=0; i<m; i++)\\n            dp[i][0]=0;\\n\\n        int max=0; //we keep a running maximum\\n        for(int j=1; j<n; j++){\\n            for(int i=0; i<m; i++){\\n                //we can reach a position from 3 places\\n                //1.same row, 1 column behind\\n                if(dp[i][j-1]!=-1 && grid[i][j-1] < grid[i][j])\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j-1]+1);\\n                //2. one row behind and one column behind\\n                if(i!=0){\\n                    if(dp[i-1][j-1]!=-1 && grid[i-1][j-1] < grid[i][j])\\n                        dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1]+1);\\n                }\\n                //3. one row ahead, one column behind\\n                if(i!=m-1){\\n                    if(dp[i+1][j-1]!=-1 && grid[i+1][j-1] < grid[i][j])\\n                        dp[i][j] = Math.max(dp[i][j], dp[i+1][j-1]+1);\\n                }\\n                max= Math.max(dp[i][j], max);\\n            }\\n            \\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616685,
                "title": "simple-and-easy-solution-using-dfs-and-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isvalid(int row,int col,vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        return row>=0 && col>=0 && row<n && col<m;\\n    }\\n    int dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>> &mp){\\n        if(mp[row][col]!=-1) return mp[row][col];\\n\\n        int cnt = 0;\\n        vector<int> dx = {-1,0,1};\\n        for(auto dir: dx){\\n            int n_row = row+dir;\\n            int n_col = col+1;\\n            if(isvalid(n_row, n_col, grid) && grid[n_row][n_col]>grid[row][col])\\n                cnt =max(cnt, dfs(n_row, n_col, grid, mp));\\n        }\\n        return mp[row][col] = 1+cnt;\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> mp(n,vector<int>(m,-1));\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            mx = max(mx, dfs(i,0,grid,mp));\\n        }\\n        return mx-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isvalid(int row,int col,vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        return row>=0 && col>=0 && row<n && col<m;\\n    }\\n    int dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>> &mp){\\n        if(mp[row][col]!=-1) return mp[row][col];\\n\\n        int cnt = 0;\\n        vector<int> dx = {-1,0,1};\\n        for(auto dir: dx){\\n            int n_row = row+dir;\\n            int n_col = col+1;\\n            if(isvalid(n_row, n_col, grid) && grid[n_row][n_col]>grid[row][col])\\n                cnt =max(cnt, dfs(n_row, n_col, grid, mp));\\n        }\\n        return mp[row][col] = 1+cnt;\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> mp(n,vector<int>(m,-1));\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            mx = max(mx, dfs(i,0,grid,mp));\\n        }\\n        return mx-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616333,
                "title": "elixir-bottom-up-dynamic-programming",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec max_moves(grid :: [[integer]]) :: integer\\n  def max_moves(grid) do\\n    rows = length(grid)\\n    cols = length(hd(grid))\\n\\n    grid =\\n      for {row, i} <- Stream.with_index(grid),\\n          {val, j} <- Stream.with_index(row),\\n          into: %{},\\n          do: {{i, j}, val}\\n\\n    dp =\\n      for i <- 0..rows-1,\\n      into: %{},\\n      do: {{i, cols - 1}, 0}\\n\\n    dp =\\n      for j <- cols-2..0//-1,\\n          i <- 0..rows-1,\\n          reduce: dp do\\n        dp ->\\n          [\\n            {i - 1, j + 1},\\n            {i, j + 1},\\n            {i + 1, j + 1}\\n          ]\\n          |> Enum.filter(fn {ii, _} -> ii in 0..rows-1 end)\\n          |> Enum.filter(fn coord2 -> grid[coord2] > grid[{i, j}] end)\\n          |> Enum.map(&dp[&1])\\n          |> Enum.max(fn -> -1 end)\\n          |> Kernel.+(1)\\n          |> then(&Map.put(dp, {i, j}, &1))\\n      end\\n\\n    0..rows-1\\n    |> Enum.map(&dp[{&1, 0}])\\n    |> Enum.max()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir",
                    "Dynamic Programming"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_moves(grid :: [[integer]]) :: integer\\n  def max_moves(grid) do\\n    rows = length(grid)\\n    cols = length(hd(grid))\\n\\n    grid =\\n      for {row, i} <- Stream.with_index(grid),\\n          {val, j} <- Stream.with_index(row),\\n          into: %{},\\n          do: {{i, j}, val}\\n\\n    dp =\\n      for i <- 0..rows-1,\\n      into: %{},\\n      do: {{i, cols - 1}, 0}\\n\\n    dp =\\n      for j <- cols-2..0//-1,\\n          i <- 0..rows-1,\\n          reduce: dp do\\n        dp ->\\n          [\\n            {i - 1, j + 1},\\n            {i, j + 1},\\n            {i + 1, j + 1}\\n          ]\\n          |> Enum.filter(fn {ii, _} -> ii in 0..rows-1 end)\\n          |> Enum.filter(fn coord2 -> grid[coord2] > grid[{i, j}] end)\\n          |> Enum.map(&dp[&1])\\n          |> Enum.max(fn -> -1 end)\\n          |> Kernel.+(1)\\n          |> then(&Map.put(dp, {i, j}, &1))\\n      end\\n\\n    0..rows-1\\n    |> Enum.map(&dp[{&1, 0}])\\n    |> Enum.max()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3616234,
                "title": "elixir-memoization",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec max_moves(grid :: [[integer]]) :: integer\\n  def max_moves(grid) do\\n    rows_count = length(grid)\\n\\n    grid =\\n      for {row, i} <- Enum.with_index(grid),\\n          {val, j} <- Enum.with_index(row),\\n          into: %{},\\n          do: {{i, j}, val}\\n\\n    Task.async(fn ->\\n      for i <- 0..rows_count - 1, reduce: 0 do\\n        max -> max(max, solve(grid, {i, 0}))\\n      end\\n    end)\\n    |> Task.await()\\n  end\\n\\n  defp solve(grid, {i, j} = coord) do\\n    memoized(coord, fn ->\\n      val = grid[coord]\\n\\n      [\\n        {i - 1, j + 1},\\n        {i, j + 1},\\n        {i + 1, j + 1}\\n      ]\\n      |> Enum.filter(fn coord2 ->\\n        grid[coord2] && grid[coord2] > val\\n      end)\\n      |> Enum.map(fn coord2 ->\\n        solve(grid, coord2)\\n      end)\\n      |> Enum.max(fn -> -1 end)\\n      |> Kernel.+(1)\\n    end)\\n  end\\n\\n  defp memoized(key, fun) do\\n    with nil <- Process.get(key) do\\n      fun.() |> tap(&Process.put(key, &1))\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir",
                    "Memoization"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_moves(grid :: [[integer]]) :: integer\\n  def max_moves(grid) do\\n    rows_count = length(grid)\\n\\n    grid =\\n      for {row, i} <- Enum.with_index(grid),\\n          {val, j} <- Enum.with_index(row),\\n          into: %{},\\n          do: {{i, j}, val}\\n\\n    Task.async(fn ->\\n      for i <- 0..rows_count - 1, reduce: 0 do\\n        max -> max(max, solve(grid, {i, 0}))\\n      end\\n    end)\\n    |> Task.await()\\n  end\\n\\n  defp solve(grid, {i, j} = coord) do\\n    memoized(coord, fn ->\\n      val = grid[coord]\\n\\n      [\\n        {i - 1, j + 1},\\n        {i, j + 1},\\n        {i + 1, j + 1}\\n      ]\\n      |> Enum.filter(fn coord2 ->\\n        grid[coord2] && grid[coord2] > val\\n      end)\\n      |> Enum.map(fn coord2 ->\\n        solve(grid, coord2)\\n      end)\\n      |> Enum.max(fn -> -1 end)\\n      |> Kernel.+(1)\\n    end)\\n  end\\n\\n  defp memoized(key, fun) do\\n    with nil <- Process.get(key) do\\n      fun.() |> tap(&Process.put(key, &1))\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3616141,
                "title": "swift-solution-using-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   func maxMoves(_ grid: [[Int]]) -> Int {\\n    var row = grid.count\\n    var col = grid[0].count\\n    var ans = 0\\n    var dp = Array(repeating: Array(repeating: -1, count: col), count: row)\\n    for i in 0..<row{\\n        if dp[i][0] == -1{\\n            ans = max(ans,checkGreaterNUmber(i, 0, row, col, grid,&dp))\\n        }\\n    }\\n    return ans-1\\n}\\n\\nfunc checkGreaterNUmber(_ i: Int,_ j: Int,_ row:Int,_ col:Int,_ grid:[[Int]],_ dp: inout [[Int]]) -> Int {\\n    if i < 0 || i >= row || j < 0 || j >= col{\\n        return 0\\n    }\\n    if dp[i][j] != -1{\\n        return dp[i][j]\\n    }\\n    var a = 0,b=0,c=0\\n    if i-1 >= 0 && j+1 < col && grid[i-1][j+1] > grid[i][j]{\\n        a = checkGreaterNUmber(i-1, j+1, row, col, grid, &dp)\\n    }\\n    \\n    if i+1 < row && j+1 < col && grid[i+1][j+1] > grid[i][j]{\\n        b = checkGreaterNUmber(i+1, j+1, row, col, grid, &dp)\\n    }\\n    if  j+1 < col && grid[i][j+1] > grid[i][j]{\\n        c = checkGreaterNUmber(i, j+1, row, col, grid, &dp)\\n    }\\n    dp[i][j] = max(a,max(b,c)) + 1\\n    return dp[i][j]\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func maxMoves(_ grid: [[Int]]) -> Int {\\n    var row = grid.count\\n    var col = grid[0].count\\n    var ans = 0\\n    var dp = Array(repeating: Array(repeating: -1, count: col), count: row)\\n    for i in 0..<row{\\n        if dp[i][0] == -1{\\n            ans = max(ans,checkGreaterNUmber(i, 0, row, col, grid,&dp))\\n        }\\n    }\\n    return ans-1\\n}\\n\\nfunc checkGreaterNUmber(_ i: Int,_ j: Int,_ row:Int,_ col:Int,_ grid:[[Int]],_ dp: inout [[Int]]) -> Int {\\n    if i < 0 || i >= row || j < 0 || j >= col{\\n        return 0\\n    }\\n    if dp[i][j] != -1{\\n        return dp[i][j]\\n    }\\n    var a = 0,b=0,c=0\\n    if i-1 >= 0 && j+1 < col && grid[i-1][j+1] > grid[i][j]{\\n        a = checkGreaterNUmber(i-1, j+1, row, col, grid, &dp)\\n    }\\n    \\n    if i+1 < row && j+1 < col && grid[i+1][j+1] > grid[i][j]{\\n        b = checkGreaterNUmber(i+1, j+1, row, col, grid, &dp)\\n    }\\n    if  j+1 < col && grid[i][j+1] > grid[i][j]{\\n        c = checkGreaterNUmber(i, j+1, row, col, grid, &dp)\\n    }\\n    dp[i][j] = max(a,max(b,c)) + 1\\n    return dp[i][j]\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611890,
                "title": "c-easy-simple-solution-must-see-memoization",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int rstart, int rend, int cstart, int cend , int **ar){\\n        if(rstart>rend && cstart>cend) return 0;\\n\\n        int up = 0, right = 0,down = 0;\\n        if(ar[rstart][cstart]!= -1) return ar[rstart][cstart];\\n        if(cstart<cend){\\n            if(rstart > 0){\\n                if(grid[rstart-1][cstart+1] > grid[rstart][cstart]) up = helper(grid,rstart -1, rend, cstart+1,cend,ar) + 1;\\n            }\\n\\n            if(grid[rstart][cstart+1] > grid[rstart][cstart]) right = helper(grid,rstart,rend,cstart+1,cend,ar) + 1;\\n\\n            if(rstart<rend){\\n                if(grid[rstart+1][cstart+1] > grid[rstart][cstart]) down = helper(grid, rstart+1, rend, cstart+1, cend,ar) + 1;\\n            }\\n        }\\n\\n        ar[rstart][cstart] = max(up,max(right,down));\\n        return max(up, max(right,down));\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int maxsteps = 0;\\n\\n        int **ar = new int*[grid.size()] ;\\n        for(int i=0;i<grid.size();i++){\\n            ar[i] = new int[grid[0].size()];\\n            for(int j = 0;j<grid[0].size();j++) ar[i][j] = -1;\\n        }\\n\\n        for(int i=0;i<grid.size();i++){\\n            int steps = helper(grid,i,grid.size()-1,0,grid[0].size()-1,ar);\\n            cout<<steps<<endl;\\n            if(steps > maxsteps) maxsteps = steps;\\n        }\\n\\n        return maxsteps;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int rstart, int rend, int cstart, int cend , int **ar){\\n        if(rstart>rend && cstart>cend) return 0;\\n\\n        int up = 0, right = 0,down = 0;\\n        if(ar[rstart][cstart]!= -1) return ar[rstart][cstart];\\n        if(cstart<cend){\\n            if(rstart > 0){\\n                if(grid[rstart-1][cstart+1] > grid[rstart][cstart]) up = helper(grid,rstart -1, rend, cstart+1,cend,ar) + 1;\\n            }\\n\\n            if(grid[rstart][cstart+1] > grid[rstart][cstart]) right = helper(grid,rstart,rend,cstart+1,cend,ar) + 1;\\n\\n            if(rstart<rend){\\n                if(grid[rstart+1][cstart+1] > grid[rstart][cstart]) down = helper(grid, rstart+1, rend, cstart+1, cend,ar) + 1;\\n            }\\n        }\\n\\n        ar[rstart][cstart] = max(up,max(right,down));\\n        return max(up, max(right,down));\\n    }\\n\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int maxsteps = 0;\\n\\n        int **ar = new int*[grid.size()] ;\\n        for(int i=0;i<grid.size();i++){\\n            ar[i] = new int[grid[0].size()];\\n            for(int j = 0;j<grid[0].size();j++) ar[i][j] = -1;\\n        }\\n\\n        for(int i=0;i<grid.size();i++){\\n            int steps = helper(grid,i,grid.size()-1,0,grid[0].size()-1,ar);\\n            cout<<steps<<endl;\\n            if(steps > maxsteps) maxsteps = steps;\\n        }\\n\\n        return maxsteps;       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3603386,
                "title": "easy-c-recursion-memorization-please-up-vote-if-you-like-the-solution",
                "content": "# Intuition\\nHere Question states that we can start with any grid[i][0];\\nso it is clear that we have to call our function for every grid[i][0]; inside our main function\\n```\\n    int ans = 0;\\n        for(int i=0;i<row;i++)\\n        {\\n            int a = solve(i,0,grid,row,col,dp);\\n            ans = max(ans,a);\\n        }\\n```\\n\\n# Approach\\nso we will move up(i-1,j+1) , right(i,j+1) , diagonal(i+1,j+1)\\nand we will select the maximum among all the moves and return it. Base case will be if we encounter and i,j which is above the range we will return 0;\\n\\n```\\n int ans = 0;\\n        // Checking for right\\n        if(j+1<col && grid[i][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // checking for up\\n        if(i-1>=0 && j+1<col && grid[i-1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i-1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // Checking for diagonal\\n        if(i+1<row && j+1<col && grid[i+1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i+1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        return  = ans;\\n```\\n\\n# Complexity\\n- Time complexity:\\nWe are travelling approx every grid value if matrix is sorted i.e for every solve fun call we are travelling n*m times and inside main function we are travelling our first column then overall complexity will be O(n*m*n) where n = no.of row, m = no. of col.\\n\\n- Space complexity:\\nwe are using a dp of size (row+5)*(col+5) and there would be an recurrsion stack space so overall space complexity would be O(n*m)+O(n1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp)\\n    {\\n        // Base Case\\n        if(i<0 || i>=row || j>=col || j<0) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 0;\\n        // Checking for right\\n        if(j+1<col && grid[i][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // checking for up\\n        if(i-1>=0 && j+1<col && grid[i-1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i-1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // Checking for diagonal\\n        if(i+1<row && j+1<col && grid[i+1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i+1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        vector<vector<int>>dp(row+5,vector<int>(col+5,-1));\\n        for(int i=0;i<row;i++)\\n        {\\n            int a = solve(i,0,grid,row,col,dp);\\n            ans = max(ans,a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    int ans = 0;\\n        for(int i=0;i<row;i++)\\n        {\\n            int a = solve(i,0,grid,row,col,dp);\\n            ans = max(ans,a);\\n        }\\n```\n```\\n int ans = 0;\\n        // Checking for right\\n        if(j+1<col && grid[i][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // checking for up\\n        if(i-1>=0 && j+1<col && grid[i-1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i-1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // Checking for diagonal\\n        if(i+1<row && j+1<col && grid[i+1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i+1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        return  = ans;\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp)\\n    {\\n        // Base Case\\n        if(i<0 || i>=row || j>=col || j<0) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 0;\\n        // Checking for right\\n        if(j+1<col && grid[i][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // checking for up\\n        if(i-1>=0 && j+1<col && grid[i-1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i-1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        // Checking for diagonal\\n        if(i+1<row && j+1<col && grid[i+1][j+1]>grid[i][j])\\n        {\\n            int temp = 1+solve(i+1,j+1,grid,row,col,dp);\\n            ans = max(ans,temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        vector<vector<int>>dp(row+5,vector<int>(col+5,-1));\\n        for(int i=0;i<row;i++)\\n        {\\n            int a = solve(i,0,grid,row,col,dp);\\n            ans = max(ans,a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599929,
                "title": "dfs-and-dp-both-solutions",
                "content": "# DFS\\n```\\nclass Solution {\\nprivate:\\n    int ans = 0;\\n    void check(vector<vector<int>>& grid, int r, int c, int res){\\n        if(c==grid[0].size()-1){\\n            ans = max(ans, res);\\n            return;\\n        }\\n        if(grid[r][c]<grid[r][c+1]){\\n            check(grid, r, c+1, res+1);\\n            grid[r][c+1] = INT_MAX;\\n        }\\n        if(r-1>=0 && grid[r][c]<grid[r-1][c+1]){\\n            check(grid, r-1, c+1, res+1);\\n            grid[r-1][c+1] = INT_MAX;\\n        }\\n        if(r+1<grid.size() && grid[r][c]<grid[r+1][c+1]){\\n            check(grid, r+1, c+1, res+1);\\n            grid[r+1][c+1] = INT_MAX;\\n        }\\n        ans = max(ans, res);\\n        return;\\n    }\\n\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        for(int i=0;i<n;i++){\\n            if(grid[i][0]<grid[i][1]){\\n                check(grid, i, 1, 1);\\n                grid[i][1] = INT_MAX;\\n            }\\n            if(i-1>=0 && grid[i][0]<grid[i-1][1]){\\n                check(grid, i-1, 1, 1);\\n                grid[i-1][1] = INT_MAX;\\n            }\\n            if(i+1<n && grid[i][0]<grid[i+1][1]){\\n                check(grid, i+1, 1, 1);\\n                grid[i+1][1] = INT_MAX;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# DP\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int c = grid[0].size()-2; c>=0; c--){\\n            for(int r = 0;r < grid.size(); r++){\\n                if(r-1 >= 0 && grid[r][c] < grid[r-1][c+1]){\\n                    dp[r][c] = max(dp[r][c], 1 + dp[r-1][c+1]);\\n                }\\n                if(grid[r][c] < grid[r][c+1]){\\n                    dp[r][c] = max(dp[r][c], 1 + dp[r][c+1]);\\n                }\\n                if(r+1 < grid.size() && grid[r][c] < grid[r+1][c+1]){\\n                    dp[r][c] = max(dp[r][c], 1 + dp[r+1][c+1]);\\n                }\\n                if(c==0){\\n                    ans = max(ans, dp[r][c]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans = 0;\\n    void check(vector<vector<int>>& grid, int r, int c, int res){\\n        if(c==grid[0].size()-1){\\n            ans = max(ans, res);\\n            return;\\n        }\\n        if(grid[r][c]<grid[r][c+1]){\\n            check(grid, r, c+1, res+1);\\n            grid[r][c+1] = INT_MAX;\\n        }\\n        if(r-1>=0 && grid[r][c]<grid[r-1][c+1]){\\n            check(grid, r-1, c+1, res+1);\\n            grid[r-1][c+1] = INT_MAX;\\n        }\\n        if(r+1<grid.size() && grid[r][c]<grid[r+1][c+1]){\\n            check(grid, r+1, c+1, res+1);\\n            grid[r+1][c+1] = INT_MAX;\\n        }\\n        ans = max(ans, res);\\n        return;\\n    }\\n\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        for(int i=0;i<n;i++){\\n            if(grid[i][0]<grid[i][1]){\\n                check(grid, i, 1, 1);\\n                grid[i][1] = INT_MAX;\\n            }\\n            if(i-1>=0 && grid[i][0]<grid[i-1][1]){\\n                check(grid, i-1, 1, 1);\\n                grid[i-1][1] = INT_MAX;\\n            }\\n            if(i+1<n && grid[i][0]<grid[i+1][1]){\\n                check(grid, i+1, 1, 1);\\n                grid[i+1][1] = INT_MAX;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int c = grid[0].size()-2; c>=0; c--){\\n            for(int r = 0;r < grid.size(); r++){\\n                if(r-1 >= 0 && grid[r][c] < grid[r-1][c+1]){\\n                    dp[r][c] = max(dp[r][c], 1 + dp[r-1][c+1]);\\n                }\\n                if(grid[r][c] < grid[r][c+1]){\\n                    dp[r][c] = max(dp[r][c], 1 + dp[r][c+1]);\\n                }\\n                if(r+1 < grid.size() && grid[r][c] < grid[r+1][c+1]){\\n                    dp[r][c] = max(dp[r][c], 1 + dp[r+1][c+1]);\\n                }\\n                if(c==0){\\n                    ans = max(ans, dp[r][c]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598455,
                "title": "java-dfs-memoization-t-o-n-m-s-o-n-m",
                "content": "# Intuition\\nBrute force is easy but number of elements in the matrix is mostly likely too large to be accepted for an answer. \\n\\n# Approach\\nThe key is figuring the caching for the visited cell as that forward cell contains the maximum moves it can make.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] visited;\\n    public int maxMoves(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        this.visited = new int[n][m];\\n        Arrays.stream(this.visited).forEach(array -> Arrays.fill(array, Integer.MIN_VALUE));\\n\\n        int maximumNumberOfMoves = 0;\\n        for(int i = 0; i < n; i++) {\\n            maximumNumberOfMoves = Math.max(maximumNumberOfMoves, dfs(grid, i, 0, n, m));\\n        }\\n\\n        return maximumNumberOfMoves;\\n    }\\n\\n    private int dfs(int[][] grid, int row, int col, int n, int m) {\\n        \\n        if(this.visited[row][col] != Integer.MIN_VALUE)\\n            return this.visited[row][col];\\n\\n        int maxMoves = 0;\\n        \\n        if(row-1 >= 0 && col+1 < m && grid[row-1][col+1] > grid[row][col]) {\\n            maxMoves = dfs(grid, row-1, col+1, n, m)+1;\\n        }\\n\\n        if(col+1 < m && grid[row][col+1] > grid[row][col]) {\\n            maxMoves = Math.max(maxMoves, dfs(grid, row, col+1, n, m)+1);\\n        }\\n\\n        if(row+1 < n && col+1 < m && grid[row+1][col+1] > grid[row][col]) {\\n            maxMoves = Math.max(maxMoves, dfs(grid, row+1, col+1, n, m)+1);\\n        }\\n        \\n        this.visited[row][col] = maxMoves;\\n\\n        return maxMoves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] visited;\\n    public int maxMoves(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        this.visited = new int[n][m];\\n        Arrays.stream(this.visited).forEach(array -> Arrays.fill(array, Integer.MIN_VALUE));\\n\\n        int maximumNumberOfMoves = 0;\\n        for(int i = 0; i < n; i++) {\\n            maximumNumberOfMoves = Math.max(maximumNumberOfMoves, dfs(grid, i, 0, n, m));\\n        }\\n\\n        return maximumNumberOfMoves;\\n    }\\n\\n    private int dfs(int[][] grid, int row, int col, int n, int m) {\\n        \\n        if(this.visited[row][col] != Integer.MIN_VALUE)\\n            return this.visited[row][col];\\n\\n        int maxMoves = 0;\\n        \\n        if(row-1 >= 0 && col+1 < m && grid[row-1][col+1] > grid[row][col]) {\\n            maxMoves = dfs(grid, row-1, col+1, n, m)+1;\\n        }\\n\\n        if(col+1 < m && grid[row][col+1] > grid[row][col]) {\\n            maxMoves = Math.max(maxMoves, dfs(grid, row, col+1, n, m)+1);\\n        }\\n\\n        if(row+1 < n && col+1 < m && grid[row+1][col+1] > grid[row][col]) {\\n            maxMoves = Math.max(maxMoves, dfs(grid, row+1, col+1, n, m)+1);\\n        }\\n        \\n        this.visited[row][col] = maxMoves;\\n\\n        return maxMoves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594740,
                "title": "simple-bfs-learned-from-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is the first approach come to my mind and correct me if i am wrong about time and space complexity\\n\\n# Complexity\\n- Time complexity: O(nm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```class Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        vector<pair<int,int>> arr={{0,1},{-1,1},{1,1}}; // three paths we can take\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            queue<pair<int,int>> q;\\n            q.push({i,0});\\n            while(q.size())\\n            {\\n                auto node=q.front();\\n                q.pop();\\n                for(auto it: arr)\\n                {\\n                    int curl=node.first+it.first;\\n                    int curr=node.second+it.second;\\n                    if(curl>=0&&curr>=0&&curl<n&&curr<m&&!vis[curl][curr])\\n                    {\\n                        if(grid[node.first][node.second]<grid[curl][curr])\\n                        {\\n                            vis[curl][curr]=vis[node.first][node.second]+1;\\n                            ans=max(ans,vis[curl][curr]);\\n                            q.push({curl,curr});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```class Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        vector<pair<int,int>> arr={{0,1},{-1,1},{1,1}}; // three paths we can take\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            queue<pair<int,int>> q;\\n            q.push({i,0});\\n            while(q.size())\\n            {\\n                auto node=q.front();\\n                q.pop();\\n                for(auto it: arr)\\n                {\\n                    int curl=node.first+it.first;\\n                    int curr=node.second+it.second;\\n                    if(curl>=0&&curr>=0&&curl<n&&curr<m&&!vis[curl][curr])\\n                    {\\n                        if(grid[node.first][node.second]<grid[curl][curr])\\n                        {\\n                            vis[curl][curr]=vis[node.first][node.second]+1;\\n                            ans=max(ans,vis[curl][curr]);\\n                            q.push({curl,curr});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587902,
                "title": "c-memoization-self-explanatory-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(row < 0 || row >= grid.size() || col<0 || col>=grid[0].size()) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int first = (row>=1 && col<grid[0].size()-1) && (grid[row-1][col+1] > grid[row][col]) ? 1 + f(row-1,col+1,grid,dp) : 0;\\n        int second = (col<grid[0].size()-1) && (grid[row][col+1] > grid[row][col]) ?  1 + f(row,col+1,grid,dp) : 0;\\n        int third = (row<grid.size()-1 && col<grid[0].size()-1) && (grid[row+1][col+1] > grid[row][col]) ?  1 + f(row+1,col+1,grid,dp) : 0;\\n        return dp[row][col]=max({first,second,third});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        vector<vector<int>>dp (1001,vector<int>(1001,-1));\\n        for(int i=0;i<grid.size();i++){\\n            ans=max(f(i,0,grid,dp),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(row < 0 || row >= grid.size() || col<0 || col>=grid[0].size()) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int first = (row>=1 && col<grid[0].size()-1) && (grid[row-1][col+1] > grid[row][col]) ? 1 + f(row-1,col+1,grid,dp) : 0;\\n        int second = (col<grid[0].size()-1) && (grid[row][col+1] > grid[row][col]) ?  1 + f(row,col+1,grid,dp) : 0;\\n        int third = (row<grid.size()-1 && col<grid[0].size()-1) && (grid[row+1][col+1] > grid[row][col]) ?  1 + f(row+1,col+1,grid,dp) : 0;\\n        return dp[row][col]=max({first,second,third});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        vector<vector<int>>dp (1001,vector<int>(1001,-1));\\n        for(int i=0;i<grid.size();i++){\\n            ans=max(f(i,0,grid,dp),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586089,
                "title": "c-setless",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <map>\\n#include <array>\\n\\nclass Solution {\\nprivate:\\n    // map<array<int,2>, int> cache;\\n    vector<vector<int>> cache;\\n    const array<int,3> row_moves{-1,0,1};\\n    int max_len = 0;\\n    vector<vector<int>>* grid;\\n    int max_r;\\n    int max_c;\\n\\npublic:\\n    int explore(int curr_r, int curr_c, int curr_len) {\\n        const int next_c = curr_c + 1;\\n        int max_local_len = 0;\\n        if (next_c != max_c) {\\n            const int curr_val = (*grid)[curr_r][curr_c];\\n            for (const int r : row_moves) {\\n                const int next_r = curr_r + r;\\n                if (next_r<0 || next_r==max_r) continue;\\n                if (cache[next_r][next_c]>0) \\n                    max_local_len = cache[next_r][next_c];\\n                else {\\n                    const int next_val = (*grid)[next_r][next_c];\\n                    if (next_val > curr_val) {\\n                        max_local_len = std::max(max_local_len, explore(next_r, next_c, curr_len+1));\\n                    }\\n                }\\n            }\\n            max_len = std::max(max_len, curr_len + max_local_len);\\n            cache[curr_r][curr_c] = max_local_len+1;\\n        }\\n        return max_local_len+1;\\n     }\\n\\n\\n    int maxMoves(vector<vector<int>>& grid_) {\\n        cache = vector<vector<int>>(grid_.size(), vector<int>(grid_[0].size(), -1));\\n        this->grid = &grid_;\\n        max_r = grid->size();\\n        max_c = max_r ? grid->front().size() : 0;\\n        max_len = 0;\\n\\n        for (int r=0; r<max_r; r++) {\\n            explore(r, 0, 0);\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <map>\\n#include <array>\\n\\nclass Solution {\\nprivate:\\n    // map<array<int,2>, int> cache;\\n    vector<vector<int>> cache;\\n    const array<int,3> row_moves{-1,0,1};\\n    int max_len = 0;\\n    vector<vector<int>>* grid;\\n    int max_r;\\n    int max_c;\\n\\npublic:\\n    int explore(int curr_r, int curr_c, int curr_len) {\\n        const int next_c = curr_c + 1;\\n        int max_local_len = 0;\\n        if (next_c != max_c) {\\n            const int curr_val = (*grid)[curr_r][curr_c];\\n            for (const int r : row_moves) {\\n                const int next_r = curr_r + r;\\n                if (next_r<0 || next_r==max_r) continue;\\n                if (cache[next_r][next_c]>0) \\n                    max_local_len = cache[next_r][next_c];\\n                else {\\n                    const int next_val = (*grid)[next_r][next_c];\\n                    if (next_val > curr_val) {\\n                        max_local_len = std::max(max_local_len, explore(next_r, next_c, curr_len+1));\\n                    }\\n                }\\n            }\\n            max_len = std::max(max_len, curr_len + max_local_len);\\n            cache[curr_r][curr_c] = max_local_len+1;\\n        }\\n        return max_local_len+1;\\n     }\\n\\n\\n    int maxMoves(vector<vector<int>>& grid_) {\\n        cache = vector<vector<int>>(grid_.size(), vector<int>(grid_[0].size(), -1));\\n        this->grid = &grid_;\\n        max_r = grid->size();\\n        max_c = max_r ? grid->front().size() : 0;\\n        max_len = 0;\\n\\n        for (int r=0; r<max_r; r++) {\\n            explore(r, 0, 0);\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3582752,
                "title": "c-dfs-dynamic-programming",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ROW;\\n    int COL;\\n    vector<vector<int>>grid;\\n    vector<vector<int>>dp;\\n\\n    int helper(int row, int col ,int pre){\\n        if(row<0||row>=ROW||col>=COL)\\n            return 0;\\n        int val = grid[row][col];\\n        if(val<=pre)\\n            return 0;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        return dp[row][col]=1+max(helper(row-1,col+1,val),max(helper(row,col+1,val),helper(row+1,col+1,val)));\\n    }\\n\\n    int maxMoves(vector<vector<int>>& g) {\\n        int Max = 0;\\n        grid=g;\\n        ROW=grid.size();\\n        COL=grid[0].size();\\n        dp.resize(ROW,vector<int>(COL,-1));\\n        \\n        for(int i =0;i<ROW;i++)  {\\n            Max=max(Max,helper(i,0,0)-1);\\n        }\\n        return Max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ROW;\\n    int COL;\\n    vector<vector<int>>grid;\\n    vector<vector<int>>dp;\\n\\n    int helper(int row, int col ,int pre){\\n        if(row<0||row>=ROW||col>=COL)\\n            return 0;\\n        int val = grid[row][col];\\n        if(val<=pre)\\n            return 0;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        return dp[row][col]=1+max(helper(row-1,col+1,val),max(helper(row,col+1,val),helper(row+1,col+1,val)));\\n    }\\n\\n    int maxMoves(vector<vector<int>>& g) {\\n        int Max = 0;\\n        grid=g;\\n        ROW=grid.size();\\n        COL=grid[0].size();\\n        dp.resize(ROW,vector<int>(COL,-1));\\n        \\n        for(int i =0;i<ROW;i++)  {\\n            Max=max(Max,helper(i,0,0)-1);\\n        }\\n        return Max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574955,
                "title": "maximum-number-of-moves-in-a-grid",
                "content": "\\n# Code\\n```\\ndef is_safe(a,v,i,j,prv):\\n    \\n    if i<0 or j<0 or i>=len(a) or j>=len(a[0]) or v[i][j]==1 or a[i][j]<=prv:\\n        return False\\n    return True \\ndef rec(a,v,i,j,prv,dp):\\n    if i<0 or j<0 or i>=len(a) or j>=len(a[0]):\\n        return 0\\n    if (i,j) in dp:\\n        return dp[i,j]\\n    c1=0\\n    c2=0\\n    c3=0\\n    if is_safe(a,v,i-1,j+1,prv):\\n        v[i-1][j+1]=1\\n        c1=1+rec(a,v,i-1,j+1,a[i-1][j+1],dp)\\n        v[i-1][j+1]=-1\\n    if is_safe(a,v,i,j+1,prv):\\n        v[i][j+1]=1\\n        c2=1+rec(a,v,i,j+1,a[i][j+1],dp)\\n        v[i][j+1]=-1\\n    if is_safe(a,v,i+1,j+1,prv):\\n        v[i+1][j+1]=1\\n        c3=1+rec(a,v,i+1,j+1,a[i+1][j+1],dp)\\n        v[i+1][j+1]=-1\\n    ans=max(c1,max(c2,c3))\\n    dp[(i,j)]=ans\\n    return ans\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        v=[[-1 for i in range(len(grid[0]))] for j in range(len(grid))]\\n        mx=float(\"-inf\")\\n        d={}\\n        for i in range(len(grid)):\\n            mx=max(mx,rec(grid,v,i,0,grid[i][0],d))\\n        return(mx)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\ndef is_safe(a,v,i,j,prv):\\n    \\n    if i<0 or j<0 or i>=len(a) or j>=len(a[0]) or v[i][j]==1 or a[i][j]<=prv:\\n        return False\\n    return True \\ndef rec(a,v,i,j,prv,dp):\\n    if i<0 or j<0 or i>=len(a) or j>=len(a[0]):\\n        return 0\\n    if (i,j) in dp:\\n        return dp[i,j]\\n    c1=0\\n    c2=0\\n    c3=0\\n    if is_safe(a,v,i-1,j+1,prv):\\n        v[i-1][j+1]=1\\n        c1=1+rec(a,v,i-1,j+1,a[i-1][j+1],dp)\\n        v[i-1][j+1]=-1\\n    if is_safe(a,v,i,j+1,prv):\\n        v[i][j+1]=1\\n        c2=1+rec(a,v,i,j+1,a[i][j+1],dp)\\n        v[i][j+1]=-1\\n    if is_safe(a,v,i+1,j+1,prv):\\n        v[i+1][j+1]=1\\n        c3=1+rec(a,v,i+1,j+1,a[i+1][j+1],dp)\\n        v[i+1][j+1]=-1\\n    ans=max(c1,max(c2,c3))\\n    dp[(i,j)]=ans\\n    return ans\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        v=[[-1 for i in range(len(grid[0]))] for j in range(len(grid))]\\n        mx=float(\"-inf\")\\n        d={}\\n        for i in range(len(grid)):\\n            mx=max(mx,rec(grid,v,i,0,grid[i][0],d))\\n        return(mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574789,
                "title": "simple-dp-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n       \\n             int mx=0;\\n\\n             for(int j=m-2;j>=0;j--){\\n                 for(int i=0;i<n;i++){\\n\\n                     if(i>0 && grid[i][j]<grid[i-1][j+1]){\\n                         dp[i][j]=max(dp[i][j],1+dp[i-1][j+1]);\\n                     }\\n                     if(grid[i][j]<grid[i][j+1]){\\n                         dp[i][j]=max(dp[i][j],1+dp[i][j+1]);\\n                     }\\n                     if(i<n-1 && grid[i][j]<grid[i+1][j+1]){\\n                         dp[i][j]=max(dp[i][j],1+dp[i+1][j+1]);\\n\\n                     }\\n                     if(j==0){\\n                         mx=max(dp[i][0],mx);\\n                     }\\n                 }\\n             }\\n       \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n       \\n             int mx=0;\\n\\n             for(int j=m-2;j>=0;j--){\\n                 for(int i=0;i<n;i++){\\n\\n                     if(i>0 && grid[i][j]<grid[i-1][j+1]){\\n                         dp[i][j]=max(dp[i][j],1+dp[i-1][j+1]);\\n                     }\\n                     if(grid[i][j]<grid[i][j+1]){\\n                         dp[i][j]=max(dp[i][j],1+dp[i][j+1]);\\n                     }\\n                     if(i<n-1 && grid[i][j]<grid[i+1][j+1]){\\n                         dp[i][j]=max(dp[i][j],1+dp[i+1][j+1]);\\n\\n                     }\\n                     if(j==0){\\n                         mx=max(dp[i][0],mx);\\n                     }\\n                 }\\n             }\\n       \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572399,
                "title": "standard-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>> &grid , int row , int column , vector<vector<int>> &dp)\\n    {\\n        int count1 = 0 , count2 = 0 , count3 = 0;\\n        if(row >= grid.size() or row < 0 or column >= grid[0].size() or column < 0) return -1e9;\\n        if(dp[row][column]!=-1) return dp[row][column];\\n        if(row-1 >=0 and column+1 <= grid[0].size()-1 and grid[row-1][column+1] > grid[row][column])\\n        {\\n            count1 = count1 + 1 + solve(grid,row-1,column+1,dp);\\n        }\\n        if(column +1 <= grid[0].size()-1 and grid[row][column+1] > grid[row][column])\\n        {\\n            count2 = count2+1+solve(grid,row,column+1,dp);\\n        }\\n            if(row+1 <= grid.size()-1 and column+1 <= grid[0].size()-1 and grid[row+1][column+1] > grid[row][column])\\n        {\\n            count3 = count3+1+solve(grid,row+1,column+1,dp);\\n        }\\n        return dp[row][column] =  max({count1,count2,count3});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int maxe = INT_MIN;\\n        vector<vector<int>> dp(grid.size() , vector<int> (grid[0].size() , -1));\\n        for(int i = 0 ; i < grid.size() ; i++)\\n        {\\n            maxe = max(maxe , solve( grid,i,0,dp));\\n        }\\n        return maxe;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>> &grid , int row , int column , vector<vector<int>> &dp)\\n    {\\n        int count1 = 0 , count2 = 0 , count3 = 0;\\n        if(row >= grid.size() or row < 0 or column >= grid[0].size() or column < 0) return -1e9;\\n        if(dp[row][column]!=-1) return dp[row][column];\\n        if(row-1 >=0 and column+1 <= grid[0].size()-1 and grid[row-1][column+1] > grid[row][column])\\n        {\\n            count1 = count1 + 1 + solve(grid,row-1,column+1,dp);\\n        }\\n        if(column +1 <= grid[0].size()-1 and grid[row][column+1] > grid[row][column])\\n        {\\n            count2 = count2+1+solve(grid,row,column+1,dp);\\n        }\\n            if(row+1 <= grid.size()-1 and column+1 <= grid[0].size()-1 and grid[row+1][column+1] > grid[row][column])\\n        {\\n            count3 = count3+1+solve(grid,row+1,column+1,dp);\\n        }\\n        return dp[row][column] =  max({count1,count2,count3});\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int maxe = INT_MIN;\\n        vector<vector<int>> dp(grid.size() , vector<int> (grid[0].size() , -1));\\n        for(int i = 0 ; i < grid.size() ; i++)\\n        {\\n            maxe = max(maxe , solve( grid,i,0,dp));\\n        }\\n        return maxe;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570040,
                "title": "dp-solution-recursion-memoization-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public static Integer dp[][];\\n    public int maxMoves(int[][] grid) {\\n        dp = new Integer[grid.length+1][grid[0].length];\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<grid.length; i++){\\n            res = Math.max(res, memo(grid, i, 0));\\n        }\\n        return res;\\n    }\\n    public static int recur(int grid[][], int row, int col){\\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length){\\n            return 0;\\n        }\\n        int upD = 0;\\n        int doD = 0;\\n        int rit = 0;\\n        if((row - 1 >= 0 && col + 1 < grid[0].length) && grid[row][col] < grid[row-1][col+1]){\\n            upD = 1 + recur(grid, row-1, col+1);\\n        }\\n        if(col + 1 < grid[0].length && grid[row][col] < grid[row][col+1]){\\n            rit = 1 + recur(grid, row, col+1);\\n        }\\n        if((row+1 < grid.length && col+1 < grid[0].length) && grid[row][col] < grid[row+1][col+1]){\\n            doD = 1 + recur(grid, row+1, col+1);\\n        }\\n        return Math.max(rit, Math.max(doD, upD));\\n    }\\n    public static int memo(int grid[][], int row, int col){\\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length){\\n            return 0;\\n        }\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n        int upD = 0;\\n        int doD = 0;\\n        int rit = 0;\\n        if((row - 1 >= 0 && col + 1 < grid[0].length) && grid[row][col] < grid[row-1][col+1]){\\n            upD = 1 + memo(grid, row-1, col+1);\\n        }\\n        if(col + 1 < grid[0].length && grid[row][col] < grid[row][col+1]){\\n            rit = 1 + memo(grid, row, col+1);\\n        }\\n        if((row+1 < grid.length && col+1 < grid[0].length) && grid[row][col] < grid[row+1][col+1]){\\n            doD = 1 + memo(grid, row+1, col+1);\\n        }\\n        return dp[row][col] = Math.max(rit, Math.max(doD, upD));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static Integer dp[][];\\n    public int maxMoves(int[][] grid) {\\n        dp = new Integer[grid.length+1][grid[0].length];\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<grid.length; i++){\\n            res = Math.max(res, memo(grid, i, 0));\\n        }\\n        return res;\\n    }\\n    public static int recur(int grid[][], int row, int col){\\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length){\\n            return 0;\\n        }\\n        int upD = 0;\\n        int doD = 0;\\n        int rit = 0;\\n        if((row - 1 >= 0 && col + 1 < grid[0].length) && grid[row][col] < grid[row-1][col+1]){\\n            upD = 1 + recur(grid, row-1, col+1);\\n        }\\n        if(col + 1 < grid[0].length && grid[row][col] < grid[row][col+1]){\\n            rit = 1 + recur(grid, row, col+1);\\n        }\\n        if((row+1 < grid.length && col+1 < grid[0].length) && grid[row][col] < grid[row+1][col+1]){\\n            doD = 1 + recur(grid, row+1, col+1);\\n        }\\n        return Math.max(rit, Math.max(doD, upD));\\n    }\\n    public static int memo(int grid[][], int row, int col){\\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length){\\n            return 0;\\n        }\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n        int upD = 0;\\n        int doD = 0;\\n        int rit = 0;\\n        if((row - 1 >= 0 && col + 1 < grid[0].length) && grid[row][col] < grid[row-1][col+1]){\\n            upD = 1 + memo(grid, row-1, col+1);\\n        }\\n        if(col + 1 < grid[0].length && grid[row][col] < grid[row][col+1]){\\n            rit = 1 + memo(grid, row, col+1);\\n        }\\n        if((row+1 < grid.length && col+1 < grid[0].length) && grid[row][col] < grid[row+1][col+1]){\\n            doD = 1 + memo(grid, row+1, col+1);\\n        }\\n        return dp[row][col] = Math.max(rit, Math.max(doD, upD));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567872,
                "title": "python-dynamic-programming-bottom-up-solution",
                "content": "# Intuition\\nWe can do this with backtracking as at each cell in first row we have three options to move, but looking at the problem contraints it can give us TLE. Also while making backtracking tree for the problem we see overlapping subproblems like at a cell (1,1) we can reach from (0,0), (1,0) and (2,0) so we can use dynamic programming here.\\n\\n# Approach\\nAt each cell we need to find the max number of ways we can reach to that cell from the three preiously visited cell, but we need to keep in mind that were we able to reach the previous cell? and for that we can keep another data in tuple which shows that a cell was visited or not.\\n\\n# Complexity\\n- Time complexity:\\nSince we are having two nested for loop\\nTC : O(n*m)\\n\\n- Space complexity:\\nSince we have an additional dp array of sixe n*m\\nSC : O(n*m)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        max_moves = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        dp = [[(0, False)]*m for _ in range(n)]\\n        for j in range(m):\\n            for i in range(n):\\n                if j == 0:\\n                    dp[i][j] = (0, True)\\n                else:\\n                    flag = False\\n                    a,b,c = 0,0,0\\n                    if i != 0:\\n                        if grid[i][j] > grid[i-1][j-1]:\\n                            if dp[i-1][j-1][1]:\\n                                flag = True\\n                                a = dp[i-1][j-1][0]\\n                    if grid[i][j] > grid[i][j-1]:\\n                        if dp[i][j-1][1]:\\n                            flag = True\\n                            b = dp[i][j-1][0]\\n                    if i != n-1:\\n                        if grid[i][j] > grid[i+1][j-1]:\\n                            if dp[i+1][j-1][1]:\\n                                flag = True\\n                                c = dp[i+1][j-1][0]\\n                    if flag:\\n                        dp[i][j] = (max(a,b,c) + 1, True)\\n                    max_moves = max(max_moves, dp[i][j][0])\\n        return max_moves\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        max_moves = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        dp = [[(0, False)]*m for _ in range(n)]\\n        for j in range(m):\\n            for i in range(n):\\n                if j == 0:\\n                    dp[i][j] = (0, True)\\n                else:\\n                    flag = False\\n                    a,b,c = 0,0,0\\n                    if i != 0:\\n                        if grid[i][j] > grid[i-1][j-1]:\\n                            if dp[i-1][j-1][1]:\\n                                flag = True\\n                                a = dp[i-1][j-1][0]\\n                    if grid[i][j] > grid[i][j-1]:\\n                        if dp[i][j-1][1]:\\n                            flag = True\\n                            b = dp[i][j-1][0]\\n                    if i != n-1:\\n                        if grid[i][j] > grid[i+1][j-1]:\\n                            if dp[i+1][j-1][1]:\\n                                flag = True\\n                                c = dp[i+1][j-1][0]\\n                    if flag:\\n                        dp[i][j] = (max(a,b,c) + 1, True)\\n                    max_moves = max(max_moves, dp[i][j][0])\\n        return max_moves\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567274,
                "title": "clean-best-c-code-memoization",
                "content": "### LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    \\n    int DFS(int i,int j,vector<vector<int>>& grid,int m,int n,vector<vector<int>>& dp){\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int res1 = 0,res2 = 0,res3 = 0;\\n        if(isValid(i-1,j+1,m,n) && grid[i-1][j+1] > grid[i][j])\\n            res1 = 1 + DFS(i-1,j+1,grid,m,n,dp);\\n        if(isValid(i,j+1,m,n) && grid[i][j+1] > grid[i][j])\\n            res2 = 1 + DFS(i,j+1,grid,m,n,dp);\\n        if(isValid(i+1,j+1,m,n) && grid[i+1][j+1] > grid[i][j])\\n            res3 = 1 + DFS(i+1,j+1,grid,m,n,dp);\\n        return dp[i][j] = max(max(res1,res2),res3);\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),maxi = 0;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,-1));\\n        for(int i = 0 ; i<m ; i++)\\n            maxi = max(maxi,DFS(i,0,grid,m,n,dp));\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    \\n    int DFS(int i,int j,vector<vector<int>>& grid,int m,int n,vector<vector<int>>& dp){\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int res1 = 0,res2 = 0,res3 = 0;\\n        if(isValid(i-1,j+1,m,n) && grid[i-1][j+1] > grid[i][j])\\n            res1 = 1 + DFS(i-1,j+1,grid,m,n,dp);\\n        if(isValid(i,j+1,m,n) && grid[i][j+1] > grid[i][j])\\n            res2 = 1 + DFS(i,j+1,grid,m,n,dp);\\n        if(isValid(i+1,j+1,m,n) && grid[i+1][j+1] > grid[i][j])\\n            res3 = 1 + DFS(i+1,j+1,grid,m,n,dp);\\n        return dp[i][j] = max(max(res1,res2),res3);\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),maxi = 0;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,-1));\\n        for(int i = 0 ; i<m ; i++)\\n            maxi = max(maxi,DFS(i,0,grid,m,n,dp));\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564720,
                "title": "scala-bottom-up-dp",
                "content": "# Code\\n```\\nobject Solution {\\n\\n  def maxMoves(grid: Array[Array[Int]]): Int = {\\n    val dp = Array.fill(grid.length)(new Array[Int](grid(0).length))\\n    dp(0).indices.reverse.tail.foreach { j =>\\n      dp.indices.foreach { i =>\\n        def cond(rowIndex: Int) = grid.lift(rowIndex).exists(row => row(j + 1) > grid(i)(j))\\n        def updateMax(row: Int) = dp(i)(j) = math.max(dp(i)(j), dp(row)(j + 1) + 1)\\n        List(i - 1, i, i + 1).filter(cond).foreach(updateMax)\\n      }\\n    }\\n    dp.map(_.head).max\\n  }\\n}\\n```\\n\\nThanks to https://leetcode.com/user3116J/ for feedback on how to clarify the solution.",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n\\n  def maxMoves(grid: Array[Array[Int]]): Int = {\\n    val dp = Array.fill(grid.length)(new Array[Int](grid(0).length))\\n    dp(0).indices.reverse.tail.foreach { j =>\\n      dp.indices.foreach { i =>\\n        def cond(rowIndex: Int) = grid.lift(rowIndex).exists(row => row(j + 1) > grid(i)(j))\\n        def updateMax(row: Int) = dp(i)(j) = math.max(dp(i)(j), dp(row)(j + 1) + 1)\\n        List(i - 1, i, i + 1).filter(cond).foreach(updateMax)\\n      }\\n    }\\n    dp.map(_.head).max\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3563665,
                "title": "using-dfs-and-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dr[3] = {0,-1,1};\\n    int mx = 0;\\n    void dfs(vector<vector<int>>& grid,vector<vector<int>>& vis,int x, int y,int dis){\\n        mx = max(mx,dis);\\n        for(int i=0; i<3; i++){\\n            int nx = x + dr[i];\\n            int ny = y + 1;\\n            if(nx>=0 && nx<grid.size() && ny>=0 && ny<grid[0].size() && grid[nx][ny] > grid[x][y] && vis[nx][ny] < dis+1){\\n                vis[nx][ny] = dis+1;\\n                dfs(grid,vis,nx,ny,dis+1);\\n            }\\n        }\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0; i<m; i++){\\n            dfs(grid,vis,i,0,0);\\n        }\\n\\n\\n        // while(!q.empty()){\\n        //     auto it = q.front();\\n        //     q.pop();\\n        //     int x = it.second.first;\\n        //     int y = it.second.second;\\n        //     int dis = it.first;\\n        //     mx = max(dis,mx);\\n        //     for(int i=0; i<3; i++){\\n        //         int nx = x + dr[i];\\n        //         int ny = y + 1;\\n        //         if(nx>=0 && nx<m && ny<n && ny>=0 && grid[nx][ny] > grid[x][y] && dis+1 > vis[nx][ny]){\\n        //             q.push({dis+1,{nx,ny}});\\n        //             vis[nx][ny] = dis+1;\\n        //         }\\n        //     }\\n        // }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dr[3] = {0,-1,1};\\n    int mx = 0;\\n    void dfs(vector<vector<int>>& grid,vector<vector<int>>& vis,int x, int y,int dis){\\n        mx = max(mx,dis);\\n        for(int i=0; i<3; i++){\\n            int nx = x + dr[i];\\n            int ny = y + 1;\\n            if(nx>=0 && nx<grid.size() && ny>=0 && ny<grid[0].size() && grid[nx][ny] > grid[x][y] && vis[nx][ny] < dis+1){\\n                vis[nx][ny] = dis+1;\\n                dfs(grid,vis,nx,ny,dis+1);\\n            }\\n        }\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0; i<m; i++){\\n            dfs(grid,vis,i,0,0);\\n        }\\n\\n\\n        // while(!q.empty()){\\n        //     auto it = q.front();\\n        //     q.pop();\\n        //     int x = it.second.first;\\n        //     int y = it.second.second;\\n        //     int dis = it.first;\\n        //     mx = max(dis,mx);\\n        //     for(int i=0; i<3; i++){\\n        //         int nx = x + dr[i];\\n        //         int ny = y + 1;\\n        //         if(nx>=0 && nx<m && ny<n && ny>=0 && grid[nx][ny] > grid[x][y] && dis+1 > vis[nx][ny]){\\n        //             q.push({dis+1,{nx,ny}});\\n        //             vis[nx][ny] = dis+1;\\n        //         }\\n        //     }\\n        // }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563663,
                "title": "using-bfs-and-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        queue<pair<int,pair<int,int>>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int j=0; j<m; j++){\\n            q.push({0,{j,0}});\\n\\n        }\\n        int mx = 0;\\n        int dr[3] = {0,-1,1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            int dis = it.first;\\n            mx = max(dis,mx);\\n            for(int i=0; i<3; i++){\\n                int nx = x + dr[i];\\n                int ny = y + 1;\\n                if(nx>=0 && nx<m && ny<n && ny>=0 && grid[nx][ny] > grid[x][y] && dis+1 > vis[nx][ny]){\\n                    q.push({dis+1,{nx,ny}});\\n                    vis[nx][ny] = dis+1;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        queue<pair<int,pair<int,int>>> q;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int j=0; j<m; j++){\\n            q.push({0,{j,0}});\\n\\n        }\\n        int mx = 0;\\n        int dr[3] = {0,-1,1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            int dis = it.first;\\n            mx = max(dis,mx);\\n            for(int i=0; i<3; i++){\\n                int nx = x + dr[i];\\n                int ny = y + 1;\\n                if(nx>=0 && nx<m && ny<n && ny>=0 && grid[nx][ny] > grid[x][y] && dis+1 > vis[nx][ny]){\\n                    q.push({dis+1,{nx,ny}});\\n                    vis[nx][ny] = dis+1;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559193,
                "title": "java-easy-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxMoves(int[][] grid) {\\n    int y = grid.length, x = grid[0].length;\\n    int table[][] = new int[y+2][x];\\n    for(int j = 0; j != x; ++j) table[0][j] = table[y+1][j] = 1;\\n\\n    for( int j = 1, wave = 0, temp = 0; j != x; ++j, ++wave, temp = 0){\\n      for(int i = y; i != 0; --i )\\n        if((table[i-1][j-1] == 0 && grid[i-2][j-1] < grid[i-1][j]) ||\\n           (table[i  ][j-1] == 0 && grid[i-1][j-1] < grid[i-1][j]) ||\\n           (table[i+1][j-1] == 0 && grid[i  ][j-1] < grid[i-1][j]) ) ++temp;\\n        else table[i][j] = 1;\\n        if(temp == 0) return wave;\\n    }\\n\\n    return x-1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxMoves(int[][] grid) {\\n    int y = grid.length, x = grid[0].length;\\n    int table[][] = new int[y+2][x];\\n    for(int j = 0; j != x; ++j) table[0][j] = table[y+1][j] = 1;\\n\\n    for( int j = 1, wave = 0, temp = 0; j != x; ++j, ++wave, temp = 0){\\n      for(int i = y; i != 0; --i )\\n        if((table[i-1][j-1] == 0 && grid[i-2][j-1] < grid[i-1][j]) ||\\n           (table[i  ][j-1] == 0 && grid[i-1][j-1] < grid[i-1][j]) ||\\n           (table[i+1][j-1] == 0 && grid[i  ][j-1] < grid[i-1][j]) ) ++temp;\\n        else table[i][j] = 1;\\n        if(temp == 0) return wave;\\n    }\\n\\n    return x-1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556223,
                "title": "easy-and-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dfs(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n\\n    if(i<0 || j<0 || i>=grid.size()||j>=grid[0].size())return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l = 0;\\n    int r = 0;\\n    int k = 0;\\n\\n    if(i+1 < grid.size() and j+1 < grid[0].size() and grid[i+1][j+1]>grid[i][j]){\\n\\n        l = 1 + dfs(i+1,j+1,grid,dp);\\n  \\n    }\\n    if(i-1 >=0 and j+1 < grid[0].size() and grid[i-1][j+1]>grid[i][j]){\\n\\n        r = 1+dfs(i-1,j+1,grid,dp);\\n    }\\n    if(j+1 < grid[0].size() and grid[i][j+1]>grid[i][j]){\\n\\n        k =1 + dfs(i,j+1,grid,dp);\\n    }\\n\\n    return dp[i][j]=max(l,max(r,k));\\n\\n}\\n    int maxMoves(vector<vector<int>>& grid) {\\n\\n        int res = 0;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n\\n         for(int j = 0;j<grid.size();j++){\\n\\n\\n                int x = dfs(j,0,grid,dp);\\n                res = max(res,x);\\n            }\\n\\n            return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dfs(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n\\n    if(i<0 || j<0 || i>=grid.size()||j>=grid[0].size())return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l = 0;\\n    int r = 0;\\n    int k = 0;\\n\\n    if(i+1 < grid.size() and j+1 < grid[0].size() and grid[i+1][j+1]>grid[i][j]){\\n\\n        l = 1 + dfs(i+1,j+1,grid,dp);\\n  \\n    }\\n    if(i-1 >=0 and j+1 < grid[0].size() and grid[i-1][j+1]>grid[i][j]){\\n\\n        r = 1+dfs(i-1,j+1,grid,dp);\\n    }\\n    if(j+1 < grid[0].size() and grid[i][j+1]>grid[i][j]){\\n\\n        k =1 + dfs(i,j+1,grid,dp);\\n    }\\n\\n    return dp[i][j]=max(l,max(r,k));\\n\\n}\\n    int maxMoves(vector<vector<int>>& grid) {\\n\\n        int res = 0;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n\\n         for(int j = 0;j<grid.size();j++){\\n\\n\\n                int x = dfs(j,0,grid,dp);\\n                res = max(res,x);\\n            }\\n\\n            return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554912,
                "title": "dp-memoization-easy-to-understand-code",
                "content": "# Intuition\\nFirstly, read the code, and if any problem then do ask in the comment, and please upvote if you like it.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMemoization approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m) for dp array + O(n ) for recursion stack space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int fn(int i,int j, vector<vector<int>>& grid, vector<vector<int>>&dp){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        if(j==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up=0,right=0,down=0;\\n        if(i>0 && grid[i-1][j+1]>grid[i][j]) up=1+fn(i-1,j+1,grid,dp);\\n        if(grid[i][j+1]>grid[i][j]) right=1+ fn(i,j+1,grid,dp);\\n        if(i<(m-1) && grid[i+1][j+1]>grid[i][j]) down=1+fn(i+1,j+1,grid,dp);\\n        return dp[i][j]=max(up,max(right,down));\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int ans=0;\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++){\\n            ans=max(ans,fn(i,0,grid,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int fn(int i,int j, vector<vector<int>>& grid, vector<vector<int>>&dp){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        if(j==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up=0,right=0,down=0;\\n        if(i>0 && grid[i-1][j+1]>grid[i][j]) up=1+fn(i-1,j+1,grid,dp);\\n        if(grid[i][j+1]>grid[i][j]) right=1+ fn(i,j+1,grid,dp);\\n        if(i<(m-1) && grid[i+1][j+1]>grid[i][j]) down=1+fn(i+1,j+1,grid,dp);\\n        return dp[i][j]=max(up,max(right,down));\\n    }\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int ans=0;\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++){\\n            ans=max(ans,fn(i,0,grid,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551276,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n\\n        int m = grid.size() , n = grid[0].size();\\n\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n\\n        for(int i=0;i<m;i++){\\n            dp[i][0] = 0;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<m;i++){\\n\\n                if(i > 0 && grid[i][j] > grid[i-1][j-1]){\\n                      if(dp[i-1][j-1] != -1)dp[i][j] = max(dp[i][j],1 + dp[i-1][j-1]);\\n                }\\n\\n                if(grid[i][j] > grid[i][j-1]){\\n                      if(dp[i][j-1] != -1)dp[i][j] = max(dp[i][j],1 + dp[i][j-1]);\\n                }\\n\\n                if(i < m-1 && grid[i][j] > grid[i+1][j-1]){\\n                      if(dp[i+1][j-1] != -1)dp[i][j] = max(dp[i][j],1 + dp[i+1][j-1]);\\n                }\\n\\n                ans = max(ans,dp[i][j]);\\n            }\\n        }  \\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxMoves(vector<vector<int>>& grid) {\\n\\n        int m = grid.size() , n = grid[0].size();\\n\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n\\n        for(int i=0;i<m;i++){\\n            dp[i][0] = 0;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<m;i++){\\n\\n                if(i > 0 && grid[i][j] > grid[i-1][j-1]){\\n                      if(dp[i-1][j-1] != -1)dp[i][j] = max(dp[i][j],1 + dp[i-1][j-1]);\\n                }\\n\\n                if(grid[i][j] > grid[i][j-1]){\\n                      if(dp[i][j-1] != -1)dp[i][j] = max(dp[i][j],1 + dp[i][j-1]);\\n                }\\n\\n                if(i < m-1 && grid[i][j] > grid[i+1][j-1]){\\n                      if(dp[i+1][j-1] != -1)dp[i][j] = max(dp[i][j],1 + dp[i+1][j-1]);\\n                }\\n\\n                ans = max(ans,dp[i][j]);\\n            }\\n        }  \\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551180,
                "title": "c-solution-using-concept-of-dynamic-programming",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a DP map, which will store the pair of indices (i,j) and maximum number of moves that can be made from that pair. Now create a function moves which will calculate and store the maximum number of moves made from a particular index of 2d array grid. If the indices are already present in DP map, return it. Else calculate the moves (m1,m2,m3) made from that index and take the maximum of it and store it in DP map.\\n\\nIn the maxMoves function, run a loop through the first column, each time calculating moves made from that particular index of first column and if it is maximum than previous answer, update the answer variable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N) , where M is no. of rows and N is no. of columns\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>dp;\\n    int moves(vector<vector<int>>&grid,int i,int j)\\n    {\\n        if(dp.find({i,j})!=dp.end()) return dp[{i,j}];\\n        if(j==grid[0].size()-1)\\n            return 0;\\n        int m1=0,m2=0,m3=0;\\n        if(i-1>=0 && grid[i-1][j+1]>grid[i][j])\\n            m1=1+moves(grid,i-1,j+1);\\n        if(grid[i][j+1]>grid[i][j])\\n            m2=1+moves(grid,i,j+1);\\n        if(i+1<grid.size() && grid[i+1][j+1]>grid[i][j])\\n            m3=1+moves(grid,i+1,j+1);\\n        return dp[{i,j}]=max(m1,max(m2,m3));\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int i;\\n        for(i=0;i<m;i++)\\n        {\\n            ans=max(ans,moves(grid,i,0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>dp;\\n    int moves(vector<vector<int>>&grid,int i,int j)\\n    {\\n        if(dp.find({i,j})!=dp.end()) return dp[{i,j}];\\n        if(j==grid[0].size()-1)\\n            return 0;\\n        int m1=0,m2=0,m3=0;\\n        if(i-1>=0 && grid[i-1][j+1]>grid[i][j])\\n            m1=1+moves(grid,i-1,j+1);\\n        if(grid[i][j+1]>grid[i][j])\\n            m2=1+moves(grid,i,j+1);\\n        if(i+1<grid.size() && grid[i+1][j+1]>grid[i][j])\\n            m3=1+moves(grid,i+1,j+1);\\n        return dp[{i,j}]=max(m1,max(m2,m3));\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int i;\\n        for(i=0;i<m;i++)\\n        {\\n            ans=max(ans,moves(grid,i,0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550145,
                "title": "readable-c-bottom-up-dp-with-transition-from-non-optimized-space-to-optimized-space",
                "content": "<b> Bottom-Up Approach With Non-Optimized Space</b>\\n```\\n//RUNTIME: 382 - 397 MS\\n//TIME COMPLEXITY: O(n * m), where n is the number of rows in our parameter grid\\n// and m is the number of columns in our parameter grid\\n//SPACE COMPLEXITY:  O(n * m), where n is the number of rows in our parameter grid\\n// and m is the number of columns in our parameter grid\\n\\nclass Solution {\\npublic:\\n    bool isValid(const std::vector<std::vector<int>>& grid, const int& row, const int& col)\\n    {\\n        if(row >= 0 && row < grid.size() && col >= 0 && col < grid[row].size())\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        \\n\\n        //We an only go right, up and to the right, or down and\\n        // to the right. These movements are represented in our\\n        // vector transformations.\\n        std::vector<std::pair<int, int>> transformations = {{-1, 1}, {0, 1}, {1, 1}};\\n        std::vector<std::vector<int>> cache(grid.size(), std::vector<int>(grid[0].size(), 0));\\n        \\n        for(int col = grid[0].size() - 1; col >= 0; col--)\\n        {\\n            for(int row = 0; row < grid.size(); row++)\\n            {\\n                for(int i = 0; i < transformations.size(); i++)\\n                {\\n                    int modRow = row + transformations[i].first;\\n                    int modCol = col + transformations[i].second;\\n                    \\n                    if(isValid(grid, modRow, modCol) && grid[row][col] < grid[modRow][modCol])\\n                    {\\n                        cache[row][col] = std::max(1 + cache[modRow][modCol], cache[row][col]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int returnVal = 0;\\n        \\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            returnVal = std::max(cache[i].front(), returnVal);\\n        }\\n        \\n        return returnVal;\\n    }\\n};\\n```\\n<b> Bottom-Up Approach With Optimized Space </b>\\n```\\n//RUNTIME: 359 - 365 MS\\n//TIME COMPLEXITY: O(n * m), where n is the number of rows\\n// in our parameter grid and m is the number of columns in our\\n// parameter grid\\n//SPACE COMPLEXITY: O(n), where n is the number of rows in our\\n// parameter grid\\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(const std::vector<std::vector<int>>& grid, const int& row, const int& col)\\n    {\\n        if(row >= 0 && row < grid.size() && col >= 0 && col < grid[row].size())\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        \\n        //We only go right, up and to the right, or down and to the right. These\\n        // movements are represented in our vector transformations. But since each\\n        // of these movements includes moving to the right, we can just always move\\n        // to the right (add one to our column value) and instead apply the up, down,\\n        // or to the side transformation to our row value\\n        std::vector<int> transformations = { -1, 0, 1 };\\n        std::vector<int> cache(grid.size(), 0);\\n\\n        for (int col = grid[0].size() - 1; col >= 0; col--)\\n        {\\n            std::vector<int> nextCache(cache.size(), 0);\\n            for (int row = 0; row < grid.size(); row++)\\n            {\\n                for (int i = 0; i < transformations.size(); i++)\\n                {\\n                int modRow = row + transformations[i];\\n                //We will always be looking to the right since that\\'s the only\\n                // way we can move, so always add 1 to the column value when\\n                // looking for other valid moves\\n                int modCol = col + 1;\\n\\n                if (isValid(grid, modRow, modCol) && grid[row][col] < grid[modRow][modCol])\\n                {\\n                    nextCache[row] = std::max(1 + cache[modRow], nextCache[row]);\\n                }\\n                }\\n            }\\n            //After we\\'ve applied all of the transformations to our current index\\n            // and found the highest value, we\\'re safe to update our cache since\\n            // we won\\'t be replacing any values we need at this point.\\n            cache = std::move(nextCache);\\n        }\\n\\n        int returnVal = 0;\\n\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            returnVal = std::max(cache[i], returnVal);\\n        }\\n\\n        return returnVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//RUNTIME: 382 - 397 MS\\n//TIME COMPLEXITY: O(n * m), where n is the number of rows in our parameter grid\\n// and m is the number of columns in our parameter grid\\n//SPACE COMPLEXITY:  O(n * m), where n is the number of rows in our parameter grid\\n// and m is the number of columns in our parameter grid\\n\\nclass Solution {\\npublic:\\n    bool isValid(const std::vector<std::vector<int>>& grid, const int& row, const int& col)\\n    {\\n        if(row >= 0 && row < grid.size() && col >= 0 && col < grid[row].size())\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        \\n\\n        //We an only go right, up and to the right, or down and\\n        // to the right. These movements are represented in our\\n        // vector transformations.\\n        std::vector<std::pair<int, int>> transformations = {{-1, 1}, {0, 1}, {1, 1}};\\n        std::vector<std::vector<int>> cache(grid.size(), std::vector<int>(grid[0].size(), 0));\\n        \\n        for(int col = grid[0].size() - 1; col >= 0; col--)\\n        {\\n            for(int row = 0; row < grid.size(); row++)\\n            {\\n                for(int i = 0; i < transformations.size(); i++)\\n                {\\n                    int modRow = row + transformations[i].first;\\n                    int modCol = col + transformations[i].second;\\n                    \\n                    if(isValid(grid, modRow, modCol) && grid[row][col] < grid[modRow][modCol])\\n                    {\\n                        cache[row][col] = std::max(1 + cache[modRow][modCol], cache[row][col]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int returnVal = 0;\\n        \\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            returnVal = std::max(cache[i].front(), returnVal);\\n        }\\n        \\n        return returnVal;\\n    }\\n};\\n```\n```\\n//RUNTIME: 359 - 365 MS\\n//TIME COMPLEXITY: O(n * m), where n is the number of rows\\n// in our parameter grid and m is the number of columns in our\\n// parameter grid\\n//SPACE COMPLEXITY: O(n), where n is the number of rows in our\\n// parameter grid\\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(const std::vector<std::vector<int>>& grid, const int& row, const int& col)\\n    {\\n        if(row >= 0 && row < grid.size() && col >= 0 && col < grid[row].size())\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int maxMoves(vector<vector<int>>& grid) {\\n        \\n        //We only go right, up and to the right, or down and to the right. These\\n        // movements are represented in our vector transformations. But since each\\n        // of these movements includes moving to the right, we can just always move\\n        // to the right (add one to our column value) and instead apply the up, down,\\n        // or to the side transformation to our row value\\n        std::vector<int> transformations = { -1, 0, 1 };\\n        std::vector<int> cache(grid.size(), 0);\\n\\n        for (int col = grid[0].size() - 1; col >= 0; col--)\\n        {\\n            std::vector<int> nextCache(cache.size(), 0);\\n            for (int row = 0; row < grid.size(); row++)\\n            {\\n                for (int i = 0; i < transformations.size(); i++)\\n                {\\n                int modRow = row + transformations[i];\\n                //We will always be looking to the right since that\\'s the only\\n                // way we can move, so always add 1 to the column value when\\n                // looking for other valid moves\\n                int modCol = col + 1;\\n\\n                if (isValid(grid, modRow, modCol) && grid[row][col] < grid[modRow][modCol])\\n                {\\n                    nextCache[row] = std::max(1 + cache[modRow], nextCache[row]);\\n                }\\n                }\\n            }\\n            //After we\\'ve applied all of the transformations to our current index\\n            // and found the highest value, we\\'re safe to update our cache since\\n            // we won\\'t be replacing any values we need at this point.\\n            cache = std::move(nextCache);\\n        }\\n\\n        int returnVal = 0;\\n\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            returnVal = std::max(cache[i], returnVal);\\n        }\\n\\n        return returnVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1895977,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1959158,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1922785,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1896790,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1894745,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1894034,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1893380,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1893359,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            },
            {
                "id": 1893200,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Easy DFS problem"
                    },
                    {
                        "username": "user4079K",
                        "content": "When we start iterating from [0][0] to [m-1][n-1] , only transposal traversal works. \\nMeaning : \\nfor(int j=0;j<cols;j++)\\nfor(int i=0;i<rows;i++) \\nThe following does not work :\\nfor(int i=0;i<rows;i++) \\nfor(int j=0;j<cols;j++)\\n\\nThe test cases are there only for larger arrays. Can some one help me understand why is it this way?\\n"
                    },
                    {
                        "username": "archijham1",
                        "content": "Can someone explain what is wrong with this code? \\n\\n `int dfs(int i, int j, vector<vector<int>> &grid, int n, int m, int *row, int *col)\\n{\\n    int temp=grid[i][j];\\n    // grid[i][j] = 0;\\n    int maxi = 0;\\n    \\n    for (int k = 0; k < 3; k++)\\n    {\\n        int ro = i + row[k];\\n        int co = j + col[k];\\n        int l = 0;\\n        if (ro >= 0 && co >= 0 && ro < m && co < n)\\n        {\\n            if (grid[ro][co] > temp)\\n            {\\n                grid[ro][co]=0;\\n                l = 1 + dfs(ro, co, grid, n, m, row, col);\\n                maxi = max(maxi, l);\\n            }\\n        }\\n        \\n    }\\n    // grid[i][j]=temp;\\n    return maxi;\\n}\\nint maxMoves(vector<vector<int>> &grid)\\n{\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    int maxi = 0;\\n    int row[3] = {-1, 0, +1};\\n    int col[3] = {+1, +1, +1};\\n    for (int i = 0; i < m; i++)\\n    {\\n        int r=dfs(i,0,grid,n,m,row,col);\\n        maxi=max(maxi,r);\\n    }\\n    return maxi;\\n}`\\n\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "can anyone please explain me why i am getting this error \\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthanks in advance\\n"
                    },
                    {
                        "username": "vivektiw120303",
                        "content": "I think there is out of bound allocation, i.e. you have declared a dp of size 100, but you are using a location of dp[101].\\n\\nKindly, check."
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "Ok so I was using a 2d dp, traversing the rows, then traversing columns in the inner loop. It gave a wrong answer. But when I switched the inner and outer loops, i.e. traversed columns first, then traversed rows in the inner loop, it got accepted. Can anyone explain why this happens?"
                    },
                    {
                        "username": "kapulaanshdeep",
                        "content": "[@shriram_gugulothu](/shriram_gugulothu) Please tell me"
                    },
                    {
                        "username": "shriram_gugulothu",
                        "content": "Did any one helped you? I have the answer for you.\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why this one throws TLE\\n\\n\"\"\"\\n def maxMoves(self, grid):\\n        \\n        self.final=0\\n        visited=[]\\n        val=[(-1,1),(0,1),(1,1)]\\n        def dfs(i,j,visited,ans):\\n           visited.append((i,j))\\n            for x,y in val:\\n               if i+x>=0 and j+y>=0 and i+x<len(grid) and j+y<len(grid[0]) and (i+x,j+y) not in visited and grid[i][j]<grid[i+x][y+j]:\\n                    \\n                    self.final=max(self.final,ans+1)\\n                    #visited.append((i+x,j+y))\\n                    dfs(i+x,y+j,visited,ans+1)\\n            \\n            \\n        for a in range(len(grid)):\\n           \\n            dfs(a,0,visited,0)\\n        return self.final"
                    },
                    {
                        "username": "nelsonh15",
                        "content": "your \\'visited\\' should be a set. Searching takes O(n) runtime for a list, while it takes O(1) runtime to search in a set. "
                    },
                    {
                        "username": "aman1320",
                        "content": "I did 3/4 questions in contest and in this question i got stuck in memoization of DFS, still in pain :( "
                    },
                    {
                        "username": "HereComesTheMoon",
                        "content": "If you\\'re using Python, @functools.cache is your friend."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "class Solution\\n{\\npublic:\\n    bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n             down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n             diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan anyone tell the error?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@null_pointer19](/null_pointer19) Nah, I\\'ve checked the condition for previous number in all 3 if conditions,, and also updated the value in next recursive loop."
                    },
                    {
                        "username": "null_pointer19",
                        "content": "\\n    class Solution\\n    {\\n    public:\\n        bool safe(vector<vector<int>> &grid, int i, int j, int n, int m)\\n        {\\n            if (i >= 0 && i < n && j >= 0 && j < m)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    int solve(vector<vector<int>> &matrix, vector<vector<int>> &dp, int n, int m, int i, int j, int prev)\\n    {\\n\\n        if (!safe(matrix, i, j, n, m))\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        prev = matrix[i][j]; // you are missing this line ----- previous for next step is going to be current  element like mattrix[i][j];\\n\\n        int right = 0, down = 0, diagonal = 0;\\n        if (safe(matrix, i,j+1,n,m)&&matrix[i][j + 1] > prev)\\n        {\\n            right = 1 + solve(matrix, dp, n, m, i, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i-1,j+1,n,m)&&matrix[i - 1][j + 1] > prev)\\n        {\\n            down = 1+solve(matrix, dp, n, m, i - 1, j + 1, matrix[i][j]);\\n        }\\n        if (safe(matrix, i+1,j+1,n,m)&&matrix[i + 1][j + 1] > prev)\\n        {\\n            diagonal = 1+solve(matrix, dp, n, m, i + 1, j + 1, matrix[i][j]);\\n        }\\n\\n        dp[i][j] = max(right, max(down, diagonal));\\n        \\n        return dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int res = solve(grid, dp, n, m, i, 0, grid[i][0]);\\n            ans = max(res, ans);\\n        }\\n        return ans;\\n    }\\n    };"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Submission](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/submissions/949931860/)\nhow did it pass , i did not use memoization"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "since you used dfs and the concept of visited array, its stopping your code to repeatedly calculate the same value again"
                    }
                ]
            }
        ]
    },
    {
        "title": "Consecutive Transactions with Increasing Amounts",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1914642,
                "content": [
                    {
                        "username": "drnothing",
                        "content": "I cannot run my code in for this task without the screen going blank. It will not execute the code. Is this happening to anyone else?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Difference of Number of Distinct Values on Diagonals",
        "question_content": "<p>Given a <strong>0-indexed</strong> 2D <code>grid</code> of size <code>m x n</code>, you should find the matrix <code>answer</code> of size <code>m x n</code>.</p>\n\n<p>The value of each cell <code>(r, c)</code> of the matrix <code>answer</code> is calculated in the following way:</p>\n\n<ul>\n\t<li>Let <code>topLeft[r][c]</code> be the number of <strong>distinct</strong> values in the top-left diagonal of the cell <code>(r, c)</code> in the matrix <code>grid</code>.</li>\n\t<li>Let <code>bottomRight[r][c]</code> be the number of <strong>distinct</strong> values in the bottom-right diagonal of the cell <code>(r, c)</code> in the matrix <code>grid</code>.</li>\n</ul>\n\n<p>Then <code>answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|</code>.</p>\n\n<p>Return <em>the matrix</em> <code>answer</code>.</p>\n\n<p>A <strong>matrix diagonal</strong> is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix&#39;s end.</p>\n\n<p>A cell <code>(r<sub>1</sub>, c<sub>1</sub>)</code> belongs to the top-left diagonal of the cell <code>(r, c)</code>, if both belong to the same diagonal and <code>r<sub>1</sub> &lt; r</code>. Similarly is defined bottom-right diagonal.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/19/ex2.png\" style=\"width: 786px; height: 121px;\" />\n<pre>\n<strong>\nInput:</strong> grid = [[1,2,3],[3,1,5],[3,2,1]]\n<strong>Output:</strong> [[1,1,0],[1,0,1],[0,1,1]]\n<strong>Explanation:</strong> The 1<sup>st</sup> diagram denotes the initial grid.&nbsp;\nThe 2<sup>nd</sup> diagram denotes a grid for cell (0,0), where blue-colored cells are cells on its bottom-right diagonal.\nThe 3<sup>rd</sup> diagram denotes a grid for cell (1,2), where red-colored cells are cells on its top-left diagonal.\nThe 4<sup>th</sup> diagram denotes a grid for cell (1,1), where blue-colored cells are cells on its bottom-right diagonal and red-colored cells are cells on its top-left diagonal.\n- The cell (0,0) contains [1,1] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |1 - 0| = 1.\n- The cell (1,2) contains [] on its bottom-right diagonal and [2] on its top-left diagonal. The answer is |0 - 1| = 1.\n- The cell (1,1) contains [1] on its bottom-right diagonal and [1] on its top-left diagonal. The answer is |1 - 1| = 0.\nThe answers of other cells are similarly calculated.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1]]\n<strong>Output:</strong> [[0]]\n<strong>Explanation:</strong> - The cell (0,0) contains [] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |0 - 0| = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n, grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3570299,
                "title": "prefix-set-size-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach \\n\\nIterate towards i+1, j+1 for the lower digonal element and put them in a set. Similarly iterate i-1, j-1 for the upper left diagonal element and put then in another set.\\nTake absolute difference of the both the size of the sets as ans of each cell.\\n\\n# Code\\n```\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    vector<vector<int>> ans(grid.size(), vector<int>(grid[0].size(), 0));\\n    for(int i = 0; i < grid.size(); ++i){\\n        for(int j = 0; j < grid[0].size(); ++j){\\n            int x = i+1, y = j+1, p = i -1, q = j-1;\\n            unordered_set<int> bottomRight, topLeft;\\n            while( x  < grid.size() && y < grid[0].size()) bottomRight.insert(grid[x++][y++]);\\n            while( p  >= 0 && q >= 0) topLeft.insert(grid[p--][q--]);\\n            ans[i][j] = abs((int)bottomRight.size() - (int)topLeft.size());\\n        }\\n    }\\n    return ans;\\n}\\n```\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    vector<vector<int>> ans(grid.size(), vector<int>(grid[0].size(), 0));\\n    for(int i = 0; i < grid.size(); ++i){\\n        for(int j = 0; j < grid[0].size(); ++j){\\n            int x = i+1, y = j+1, p = i -1, q = j-1;\\n            unordered_set<int> bottomRight, topLeft;\\n            while( x  < grid.size() && y < grid[0].size()) bottomRight.insert(grid[x++][y++]);\\n            while( p  >= 0 && q >= 0) topLeft.insert(grid[p--][q--]);\\n            ans[i][j] = abs((int)bottomRight.size() - (int)topLeft.size());\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571235,
                "title": "o-m-n",
                "content": "Brute-force is accepted, but where\\'s the fun with that.\\n\\nHere, we process each diagonal, and roll `tl` and `br` hash sets to compute the entire diagonal in two swipes.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> res(m, vector<int>(n));\\n    auto populateDiag = [&](int i, int j) {\\n        unordered_set<int> tl, br;\\n        for (int d = 0; i + d < m && j + d < n; ++d) {\\n            res[i + d][j + d] = tl.size();\\n            tl.insert(g[i + d][j + d]);\\n        }\\n        for (int d = min(m - i, n - j) - 1; d >= 0; --d) {\\n            res[i + d][j + d] = abs(res[i + d][j + d] - (int)br.size());\\n            br.insert(g[i + d][j + d]);            \\n        }\\n    };\\n    for (int j = 0; j < n; ++j)\\n        populateDiag(0, j);\\n    for (int i = 1; i < m; ++i)\\n        populateDiag(i, 0);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> res(m, vector<int>(n));\\n    auto populateDiag = [&](int i, int j) {\\n        unordered_set<int> tl, br;\\n        for (int d = 0; i + d < m && j + d < n; ++d) {\\n            res[i + d][j + d] = tl.size();\\n            tl.insert(g[i + d][j + d]);\\n        }\\n        for (int d = min(m - i, n - j) - 1; d >= 0; --d) {\\n            res[i + d][j + d] = abs(res[i + d][j + d] - (int)br.size());\\n            br.insert(g[i + d][j + d]);            \\n        }\\n    };\\n    for (int j = 0; j < n; ++j)\\n        populateDiag(0, j);\\n    for (int i = 1; i < m; ++i)\\n        populateDiag(i, 0);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570204,
                "title": "image-explanation-c",
                "content": "**Important:** Hey guys, you may watch biggest sliding window playlist just using single template on my youtube channel with detailed explanation by clicking my profile icon and you will find my channel link in bio (this playlist has 20+ video covering many good leetcode sliding window problem of leetcode).\\nThankyou\\n\\n**Approach:** Just take abs value of total number of distinct element in diagonal at above a (r,c) and down diagonal of (r,c). Thanks [gaurav kumar](https://leetcode.com/gauravkumar59829/) for clearing problem statement.\\n\\n![image](https://assets.leetcode.com/users/images/29c240e5-448b-4af4-a037-9b7a6d0a762b_1685247966.1189716.png)\\n\\n\\n```\\n  vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int row = grid.size();\\n    int col= grid[0].size();\\n    \\n    vector<vector<int>> ans(row, vector<int>(col));\\n    \\n    for (int i = 0; i < row; i++) {\\n        for (int j = 0; j < col; j++) {\\n            unordered_set<int> left;\\n            unordered_set<int> right;\\n            \\n            int r = i - 1;\\n            int c = j - 1;\\n            while (r >= 0 && c >= 0) {   // checking top left diagonal\\n                left.insert(grid[r--][c--]);  // inserting in set to count distinct element\\n            }\\n            \\n            r = i + 1;\\n            c = j + 1;\\n            while (r < row && c < col) {        // checking bottom right diagonal \\n                right.insert(grid[r++][c++]);    // inserting in set to count distinct element\\n            }\\n            int topleftdiagonal_distinct=left.size();\\n            int rightBottomdiagonal_distinct=right.size();\\n            \\n            ans[i][j] = abs(topleftdiagonal_distinct-rightBottomdiagonal_distinct);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int row = grid.size();\\n    int col= grid[0].size();\\n    \\n    vector<vector<int>> ans(row, vector<int>(col));\\n    \\n    for (int i = 0; i < row; i++) {\\n        for (int j = 0; j < col; j++) {\\n            unordered_set<int> left;\\n            unordered_set<int> right;\\n            \\n            int r = i - 1;\\n            int c = j - 1;\\n            while (r >= 0 && c >= 0) {   // checking top left diagonal\\n                left.insert(grid[r--][c--]);  // inserting in set to count distinct element\\n            }\\n            \\n            r = i + 1;\\n            c = j + 1;\\n            while (r < row && c < col) {        // checking bottom right diagonal \\n                right.insert(grid[r++][c++]);    // inserting in set to count distinct element\\n            }\\n            int topleftdiagonal_distinct=left.size();\\n            int rightBottomdiagonal_distinct=right.size();\\n            \\n            ans[i][j] = abs(topleftdiagonal_distinct-rightBottomdiagonal_distinct);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572121,
                "title": "simplified-problem-statement",
                "content": "# Explanation\\nFor those who still are not able to comprehend the problem statement, these are my 2 cents about it.\\n\\nFirst `topLeft diagonal` and `bottomRight diagonal`, for an index `(r, c)`: \\n1. `topLeft diagonal` is going to be the diagonal starting from `(r-1, c-1)` till  `r >= 0 & c >= 0`.\\n2. `bottomRight diagonal` is going to be the diagonal starting from `(r+1, c+1)` till  `r <= (m-1) & c <= (n-1)`.\\n\\nNow, for each cell `(r, c)` of answer array, we want to calcaulate absolute difference of: \\n1. `topLeft[r][c]`, which is the count of distinct numbers in `topLeft` diagonal in `grid`, and\\n2. `bottomRight[r][c]`, which is the count of distinct numbers in `bottomRight` diagonal in `grid`.\\n\\nTo be certain, \\n`answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|`\\n\\nFor better understanding,\\n\\n![IMG_20230528_185309.jpg](https://assets.leetcode.com/users/images/6676431d-2a16-4329-80a1-0c8c8b0fba4b_1685280469.7489467.jpeg)\\n\\n\\n\\n\\n# Code\\nIncase, you need the code also. This is really brute-force approach.\\n\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        int[][] ans = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                //using set for determining distinct integers\\n\\n                Set<Integer> topLeft = new HashSet(); \\n\\n                //traversing topLeft diagonal, \\n                for(int r = i-1, c = j-1; r >= 0 && c >= 0; r--, c--){\\n                    topLeft.add(grid[r][c]);\\n                }\\n                \\n                Set<Integer> bottomRight = new HashSet();\\n\\n                // traversing bottomRight diagonal\\n                for(int r = i+1, c = j+1; r < m && c < n; r++, c++){\\n                    bottomRight.add(grid[r][c]);\\n                }\\n                \\n                ans[i][j] = Math.abs(bottomRight.size() - topLeft.size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**HOPE IT HELPS!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        int[][] ans = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                //using set for determining distinct integers\\n\\n                Set<Integer> topLeft = new HashSet(); \\n\\n                //traversing topLeft diagonal, \\n                for(int r = i-1, c = j-1; r >= 0 && c >= 0; r--, c--){\\n                    topLeft.add(grid[r][c]);\\n                }\\n                \\n                Set<Integer> bottomRight = new HashSet();\\n\\n                // traversing bottomRight diagonal\\n                for(int r = i+1, c = j+1; r < m && c < n; r++, c++){\\n                    bottomRight.add(grid[r][c]);\\n                }\\n                \\n                ans[i][j] = Math.abs(bottomRight.size() - topLeft.size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570396,
                "title": "easy-sol-with-explanation",
                "content": "# Intuition\\n\\n\\nTo achieve this, the code defines two functions: findtop and findbottom.\\n\\n1. findtop function counts the distinct values in the top-left diagonal of a cell by traversing upward and leftward from the cell, keeping track of the encountered values.\\n\\n2. findbottom function counts the distinct values in the bottom-right diagonal of a cell by traversing downward and rightward from the cell, keeping track of the encountered values.\\n\\nAssign this difference as the value for the corresponding cell in the answer grid.\\nIn the end, you need to return the answer grid with these calculated values.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRows, numCols;\\n\\n    int countDistinctTopLeft(int row, int col, vector<vector<int>>& grid) {\\n        set<int> distinctValues;\\n        row--; col--;\\n        while (row >= 0 && col >= 0) {\\n            distinctValues.insert(grid[row][col]);\\n            row--; col--;\\n        }\\n        return distinctValues.size();\\n    }\\n\\n    int countDistinctBottomRight(int row, int col, vector<vector<int>>& grid) {\\n        set<int> distinctValues;\\n        row++; col++;\\n        while (row < numRows && col < numCols) {\\n            distinctValues.insert(grid[row][col]);\\n            row++; col++;\\n        }\\n        return distinctValues.size();\\n    }\\n\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        numRows = grid.size();\\n        numCols = grid[0].size();\\n        vector<vector<int>> result(numRows, vector<int>(numCols, 0));\\n\\n        for (int row = 0; row < numRows; row++) {\\n            for (int col = 0; col < numCols; col++) {\\n                int distinctTopLeft = countDistinctTopLeft(row, col, grid);\\n                int distinctBottomRight = countDistinctBottomRight(row, col, grid);\\n                result[row][col] = abs(distinctTopLeft - distinctBottomRight);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRows, numCols;\\n\\n    int countDistinctTopLeft(int row, int col, vector<vector<int>>& grid) {\\n        set<int> distinctValues;\\n        row--; col--;\\n        while (row >= 0 && col >= 0) {\\n            distinctValues.insert(grid[row][col]);\\n            row--; col--;\\n        }\\n        return distinctValues.size();\\n    }\\n\\n    int countDistinctBottomRight(int row, int col, vector<vector<int>>& grid) {\\n        set<int> distinctValues;\\n        row++; col++;\\n        while (row < numRows && col < numCols) {\\n            distinctValues.insert(grid[row][col]);\\n            row++; col++;\\n        }\\n        return distinctValues.size();\\n    }\\n\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        numRows = grid.size();\\n        numCols = grid[0].size();\\n        vector<vector<int>> result(numRows, vector<int>(numCols, 0));\\n\\n        for (int row = 0; row < numRows; row++) {\\n            for (int col = 0; col < numCols; col++) {\\n                int distinctTopLeft = countDistinctTopLeft(row, col, grid);\\n                int distinctBottomRight = countDistinctBottomRight(row, col, grid);\\n                result[row][col] = abs(distinctTopLeft - distinctBottomRight);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570225,
                "title": "c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> ans(m, vector<int>(n));\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            unordered_set<int> set1;\\n            unordered_set<int> set2;\\n            \\n            int r = i - 1;\\n            int c = j - 1;\\n            while (r >= 0 && c >= 0) {\\n                set1.insert(grid[r--][c--]);\\n            }\\n            \\n            r = i + 1;\\n            c = j + 1;\\n            while (r < m && c < n) {\\n                set2.insert(grid[r++][c++]);\\n            }\\n            \\n            ans[i][j] = abs(static_cast<int>(set1.size() - set2.size()));\\n        }\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> ans(m, vector<int>(n));\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            unordered_set<int> set1;\\n            unordered_set<int> set2;\\n            \\n            int r = i - 1;\\n            int c = j - 1;\\n            while (r >= 0 && c >= 0) {\\n                set1.insert(grid[r--][c--]);\\n            }\\n            \\n            r = i + 1;\\n            c = j + 1;\\n            while (r < m && c < n) {\\n                set2.insert(grid[r++][c++]);\\n            }\\n            \\n            ans[i][j] = abs(static_cast<int>(set1.size() - set2.size()));\\n        }\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576482,
                "title": "python-3-8-lines-slices-w-comments-t-m-100-68",
                "content": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n\\n        d = defaultdict(list)                      \\n\\n        for i, j in product(range(len(grid)),        \\n                            range(len(grid[0]))):\\n            d[i-j].append((i,j))                        # <-- Construct dict of diagonals; i - j\\n                                                        #     remains constant on a \\'\\\\\\' diag. \\n        for diag in d:\\n            arr = [grid[i][j] for i,j in d[diag]]       # <-- Construct an arr of the elements\\n                                                        #     on the diagonal.\\n\\n            for idx, (i,j) in enumerate(d[diag]):       # <-- Overwrite each element in the diagonal.   \\n                grid[i][j] = abs(len(set(arr[:idx])) -  #     in the array with its score.\\n                                 len(set(arr[idx+1:])))\\n            \\n        return grid                                     # <-- Return the overwritten \\'grid\\' as the\\n                                                        #     \\'answer\\' matrix.\\n```\\n[https://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/submissions/1007182865/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*) in which *N* ~`len(grid)` and *M* ~`len(grid[0])`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n\\n        d = defaultdict(list)                      \\n\\n        for i, j in product(range(len(grid)),        \\n                            range(len(grid[0]))):\\n            d[i-j].append((i,j))                        # <-- Construct dict of diagonals; i - j\\n                                                        #     remains constant on a \\'\\\\\\' diag. \\n        for diag in d:\\n            arr = [grid[i][j] for i,j in d[diag]]       # <-- Construct an arr of the elements\\n                                                        #     on the diagonal.\\n\\n            for idx, (i,j) in enumerate(d[diag]):       # <-- Overwrite each element in the diagonal.   \\n                grid[i][j] = abs(len(set(arr[:idx])) -  #     in the array with its score.\\n                                 len(set(arr[idx+1:])))\\n            \\n        return grid                                     # <-- Return the overwritten \\'grid\\' as the\\n                                                        #     \\'answer\\' matrix.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570232,
                "title": "clean-simple-java-solution",
                "content": "``` java []\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] res = new int[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                res[i][j] = answer(grid, i, j);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int answer(int[][] grid, int r, int c){\\n        Set st1 = new HashSet(), st2 = new HashSet();\\n        int r1 = r, c1 = c, r2 = r, c2 = c;\\n        while(r1 > 0 && c1 > 0) \\n            st1.add(grid[--r1][--c1]);\\n        while(r2 < grid.length-1 && c2 < grid[0].length-1) \\n            st2.add(grid[++r2][++c2]);\\n        return Math.abs(st1.size()-st2.size());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] res = new int[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                res[i][j] = answer(grid, i, j);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int answer(int[][] grid, int r, int c){\\n        Set st1 = new HashSet(), st2 = new HashSet();\\n        int r1 = r, c1 = c, r2 = r, c2 = c;\\n        while(r1 > 0 && c1 > 0) \\n            st1.add(grid[--r1][--c1]);\\n        while(r2 < grid.length-1 && c2 < grid[0].length-1) \\n            st2.add(grid[++r2][++c2]);\\n        return Math.abs(st1.size()-st2.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570212,
                "title": "c-easy-set-version",
                "content": "# Approach\\nSimply calculate how many distinct elements are there in left and right diagnoal in a set and diffrence between them is our answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                unordered_set<int> l, r;\\n                // left diagonal\\n                int idx = i-1, jdx = j-1;\\n                while(idx >= 0 && jdx >= 0) { \\n                    l.insert(grid[idx][jdx]);\\n                    idx--, jdx--;\\n                }\\n                // right diagonal\\n                idx = i+1, jdx = j+1;\\n                while(idx < n && jdx < m) {\\n                    r.insert(grid[idx][jdx]);\\n                    idx++, jdx++;\\n                }\\n                \\n                ans[i][j] = abs((int)l.size() - (int)r.size());;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                unordered_set<int> l, r;\\n                // left diagonal\\n                int idx = i-1, jdx = j-1;\\n                while(idx >= 0 && jdx >= 0) { \\n                    l.insert(grid[idx][jdx]);\\n                    idx--, jdx--;\\n                }\\n                // right diagonal\\n                idx = i+1, jdx = j+1;\\n                while(idx < n && jdx < m) {\\n                    r.insert(grid[idx][jdx]);\\n                    idx++, jdx++;\\n                }\\n                \\n                ans[i][j] = abs((int)l.size() - (int)r.size());;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570686,
                "title": "easy-c-solution-by-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n     int m =grid.size(),n=grid[0].size();\\n     vector<vector<int>> ans(m, vector<int>(n, 0));\\n     for (int r = 0; r < m; r++) {\\n        for (int c = 0; c < n; c++) {\\n            unordered_set<int> tl, br;\\n\\t\\t\\t//for top left \\n            for (int i = r - 1, j = c - 1; i >= 0 && j >= 0; i--, j--) {\\n                tl.insert(grid[i][j]);\\n            }\\n\\t\\t\\t//for bottom right\\n            for (int i = r + 1, j = c + 1; i < m && j < n; i++, j++) {\\n                br.insert(grid[i][j]);\\n            }\\n            int x= tl.size() - br.size();\\n            ans[r][c] =abs(x);\\n        }\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n     int m =grid.size(),n=grid[0].size();\\n     vector<vector<int>> ans(m, vector<int>(n, 0));\\n     for (int r = 0; r < m; r++) {\\n        for (int c = 0; c < n; c++) {\\n            unordered_set<int> tl, br;\\n\\t\\t\\t//for top left \\n            for (int i = r - 1, j = c - 1; i >= 0 && j >= 0; i--, j--) {\\n                tl.insert(grid[i][j]);\\n            }\\n\\t\\t\\t//for bottom right\\n            for (int i = r + 1, j = c + 1; i < m && j < n; i++, j++) {\\n                br.insert(grid[i][j]);\\n            }\\n            int x= tl.size() - br.size();\\n            ans[r][c] =abs(x);\\n        }\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570417,
                "title": "c-map-solve-for-1st-row-col",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        int i,j,a,b,k;\\n        for(k = 0; k < n; k++){\\n            unordered_map<int,int> mp1,mp2;\\n            i = 0, j = k;\\n            while(j<n&&i<m){\\n                mp1[grid[i][j]]++;\\n                i++;j++;\\n            }\\n            i = 0, j = k;\\n            while(i<m&&j<n){\\n                mp1[grid[i][j]]--;\\n                if(mp1[grid[i][j]]==0){\\n                    mp1.erase(grid[i][j]);\\n                }\\n                a = mp1.size(),b = mp2.size();\\n                ans[i][j] = abs(a-b);\\n                mp2[grid[i][j]]++;\\n                i++;j++;\\n            }\\n        }\\n        for(k = 1; k < m; k++){\\n            unordered_map<int,int> mp1,mp2;\\n            j = 0, i = k;\\n            while(j<n&&i<m){\\n                mp1[grid[i][j]]++;\\n                i++;j++;\\n            }\\n            j = 0, i = k;\\n            while(i<m&&j<n){\\n                mp1[grid[i][j]]--;\\n                if(mp1[grid[i][j]]==0){\\n                    mp1.erase(grid[i][j]);\\n                }\\n                a = mp1.size(),b = mp2.size();\\n                ans[i][j] = abs(a-b);\\n                mp2[grid[i][j]]++;\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        int i,j,a,b,k;\\n        for(k = 0; k < n; k++){\\n            unordered_map<int,int> mp1,mp2;\\n            i = 0, j = k;\\n            while(j<n&&i<m){\\n                mp1[grid[i][j]]++;\\n                i++;j++;\\n            }\\n            i = 0, j = k;\\n            while(i<m&&j<n){\\n                mp1[grid[i][j]]--;\\n                if(mp1[grid[i][j]]==0){\\n                    mp1.erase(grid[i][j]);\\n                }\\n                a = mp1.size(),b = mp2.size();\\n                ans[i][j] = abs(a-b);\\n                mp2[grid[i][j]]++;\\n                i++;j++;\\n            }\\n        }\\n        for(k = 1; k < m; k++){\\n            unordered_map<int,int> mp1,mp2;\\n            j = 0, i = k;\\n            while(j<n&&i<m){\\n                mp1[grid[i][j]]++;\\n                i++;j++;\\n            }\\n            j = 0, i = k;\\n            while(i<m&&j<n){\\n                mp1[grid[i][j]]--;\\n                if(mp1[grid[i][j]]==0){\\n                    mp1.erase(grid[i][j]);\\n                }\\n                a = mp1.size(),b = mp2.size();\\n                ans[i][j] = abs(a-b);\\n                mp2[grid[i][j]]++;\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570348,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nInitialize an empty 2D vector ans to store the absolute differences between the sizes of two sets of distinct values.\\n\\nTraverse the grid in a nested loop, iterating over each element.\\n\\nFor each element, create two sets, a and b, to store the distinct values found in the diagonal upwards to the top-left corner and the diagonal downwards to the bottom-right corner, respectively.\\n\\nTraverse diagonally upwards from the current element to the top-left corner of the grid. For each step, check if the current indices are within the valid range, and if so, add the corresponding element to set a.\\n\\nTraverse diagonally downwards from the current element to the bottom-right corner of the grid. For each step, check if the current indices are within the valid range, and if so, add the corresponding element to set b.\\n\\nCalculate the absolute difference between the sizes of sets a and b and store the result in the corresponding position of the ans vector.\\n\\nRepeat steps 3-6 for all elements in the grid.\\n\\nReturn the resulting ans vector, which contains the absolute differences between the sizes of sets a and b for each element in the grid.\\n\\nFor example:\\n\\nAnalyzing the given problem statement, we observe that it involves finding the difference of distinct values while traversing diagonally in two directions within the grid.\\nWe can leverage sets to keep track of the distinct values encountered during the diagonal traversal.\\nBy calculating the absolute difference between the sizes of the two sets, we can determine the required values to be stored in the output grid.\\n\\n# Approach\\n\\n\\nThe approach focuses on traversing the grid diagonally to find the distinct values in two different directions. By calculating the absolute difference between the sizes of the two sets, the solution provides a measure of how different the distinct values are in those two directions for each element in the grid.\\n\\n# Complexity\\n\\nFor example:\\n\\n- Time complexity: The code traverses the grid in a nested loop, visiting each element once. Therefore, the time complexity is proportional to the number of elements in the grid, which is O(n * m), where n is the number of rows and m is the number of columns in the grid.\\n\\nWithin the nested loop, the code performs two additional loops to traverse the diagonal upwards and downwards. However, these loops are bounded by the maximum size of the grid, so they contribute at most O(n + m) time complexity to each iteration of the outer loop. Since the outer loop iterates n * m times, the overall time complexity remains O(n * m).\\n\\nCalculating the absolute difference between the sizes of sets a and b takes constant time and does not affect the overall time complexity.\\n\\nTherefore, the overall time complexity of the code is O(n * m).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> The code uses a 2D vector ans to store the absolute differences between the sizes of two sets. The size of this vector is the same as the grid, which is O(n * m) in terms of space complexity.\\n\\nAdditionally, the code creates two sets a and b for each element in the grid. The maximum size of these sets is bounded by the maximum diagonal length of the grid, which is min(n, m). Therefore, the space complexity of each set is O(min(n, m)).\\n\\nOverall, the additional space used by the sets a and b for each element in the grid is O(min(n, m)). The space complexity of the ans vector dominates, so the overall space complexity is O(n * m).\\n\\nIn summary, the time complexity of the code is O(n * m), and the space complexity is O(n * m).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        // Create a 2D vector to store the answer with the same size as the grid\\n        vector<vector<int>> ans(grid.size(), vector<int>(grid[0].size()));\\n        \\n        // Traverse the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                // Create two sets to store distinct values\\n                set<int> a, b;\\n                \\n                // Traverse diagonally upwards to the top-left corner\\n                for (int k = 1; i - k >= 0 && j - k >= 0; k++) {\\n                    a.insert(grid[i - k][j - k]);\\n                }\\n                \\n                // Traverse diagonally downwards to the bottom-right corner\\n                for (int k = 1; i + k < grid.size() && j + k < grid[0].size(); k++) {\\n                    b.insert(grid[i + k][j + k]);\\n                }\\n                \\n                // Calculate the absolute difference between the sizes of the two sets\\n                ans[i][j] = abs(static_cast<int>(a.size() - b.size()));\\n            }\\n        }\\n        \\n        // Return the answer\\n        return ans;\\n    }\\n};\\n\\n        \\n     \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        // Create a 2D vector to store the answer with the same size as the grid\\n        vector<vector<int>> ans(grid.size(), vector<int>(grid[0].size()));\\n        \\n        // Traverse the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                // Create two sets to store distinct values\\n                set<int> a, b;\\n                \\n                // Traverse diagonally upwards to the top-left corner\\n                for (int k = 1; i - k >= 0 && j - k >= 0; k++) {\\n                    a.insert(grid[i - k][j - k]);\\n                }\\n                \\n                // Traverse diagonally downwards to the bottom-right corner\\n                for (int k = 1; i + k < grid.size() && j + k < grid[0].size(); k++) {\\n                    b.insert(grid[i + k][j + k]);\\n                }\\n                \\n                // Calculate the absolute difference between the sizes of the two sets\\n                ans[i][j] = abs(static_cast<int>(a.size() - b.size()));\\n            }\\n        }\\n        \\n        // Return the answer\\n        return ans;\\n    }\\n};\\n\\n        \\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570311,
                "title": "simple-brute-force-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int x = i + 1, y = j + 1;\\n                set<int>st1;\\n                //=======================================================\\n                //consider {i, j} as top-left cell \\n                while(x < m && y < n) //keep going bottom right\\n                {\\n                    st1.insert(grid[x][y]);\\n                    x++;\\n                    y++;\\n                }\\n                //=========================================================\\n                //consider {i, j} as bottom right cell \\n                x = i - 1; y = j - 1;\\n                set<int>st2;\\n                while(x >= 0 && y >= 0) //keep going top left\\n                {\\n                    st2.insert(grid[x][y]);\\n                    x--;\\n                    y--;\\n                }\\n                //===================================================================\\n                int topLeft = st1.size(), bottomRight = st2.size();\\n                ans[i][j] = abs(topLeft - bottomRight);\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int x = i + 1, y = j + 1;\\n                set<int>st1;\\n                //=======================================================\\n                //consider {i, j} as top-left cell \\n                while(x < m && y < n) //keep going bottom right\\n                {\\n                    st1.insert(grid[x][y]);\\n                    x++;\\n                    y++;\\n                }\\n                //=========================================================\\n                //consider {i, j} as bottom right cell \\n                x = i - 1; y = j - 1;\\n                set<int>st2;\\n                while(x >= 0 && y >= 0) //keep going top left\\n                {\\n                    st2.insert(grid[x][y]);\\n                    x--;\\n                    y--;\\n                }\\n                //===================================================================\\n                int topLeft = st1.size(), bottomRight = st2.size();\\n                ans[i][j] = abs(topLeft - bottomRight);\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570765,
                "title": "easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem -->\\n\\n# Approach\\nThe code starts by initializing variables m and n to store the number of rows and columns in the input grid, respectively.\\n\\nIt creates a new 2D vector called answer with the same dimensions as the input grid. This vector will store the results of the calculations.\\n\\nTwo nested loops iterate over each element in the input grid. The outer loop iterates over the rows (indexed by i), and the inner loop iterates over the columns (indexed by j).\\n\\nInside the loops, the code sets up variables p, r, q, and s to define the boundaries of the top-left and bottom-right submatrices centered at the current element.\\n\\nTwo unordered sets, topLeft and bottomRight, are created to store the distinct values found in the top-left and bottom-right submatrices, respectively.\\n\\nA while loop is used to iterate over the elements in the submatrices. It starts from the current element and moves diagonally towards the top-left and bottom-right corners of the submatrices.\\n\\nIn each iteration of the while loop, the code checks if the current indices (p, r, q, s) are within the bounds of the input grid. If they are, the corresponding elements are inserted into the respective unordered sets.\\n\\nAfter iterating over the elements in the submatrices, the code calculates the difference in the count of distinct values between the top-left and bottom-right sets. This is done by subtracting the size of the bottomRight set from the size of the topLeft set.\\n\\nIf the calculated difference (a) is negative, it is converted to a positive value.\\n\\nFinally, the value of a is assigned to the corresponding element in the answer grid.\\n\\nOnce all elements in the input grid have been processed, the answer grid is returned as the result.\\n\\n# Complexity\\n- Time complexity:O(m *n *(m + n))\\n\\n- Space complexity:O(m*n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> answer(m,vector<int>(n));\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int p = i+1;\\n            int r=j+1;\\n            int q = i-1;\\n            int s=j-1;\\n            unordered_set<int> topLeft;\\n            unordered_set<int> bottomRight;\\n            while (p < m || q >= 0) {\\n                if(p<m and r<n)    topLeft.insert(grid[p][r]);\\n                if(q>=0 and s>=0)   bottomRight.insert(grid[q][s]);\\n                r++;\\n                p++;\\n                s--;\\n                q--;\\n            }\\n            int a=(topLeft.size() -bottomRight.size());\\n            if(a<0) a=-a;\\n            answer[i][j] =a;\\n        }\\n    }\\n    return answer;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> answer(m,vector<int>(n));\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int p = i+1;\\n            int r=j+1;\\n            int q = i-1;\\n            int s=j-1;\\n            unordered_set<int> topLeft;\\n            unordered_set<int> bottomRight;\\n            while (p < m || q >= 0) {\\n                if(p<m and r<n)    topLeft.insert(grid[p][r]);\\n                if(q>=0 and s>=0)   bottomRight.insert(grid[q][s]);\\n                r++;\\n                p++;\\n                s--;\\n                q--;\\n            }\\n            int a=(topLeft.size() -bottomRight.size());\\n            if(a<0) a=-a;\\n            answer[i][j] =a;\\n        }\\n    }\\n    return answer;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570294,
                "title": "just-check-incremental-and-decremental-row-column-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n      int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                int col=j+1, row=i+1, bottom_right=0, top_left=0;\\n                unordered_set<int>st;\\n               \\n                while(col < n and row < m) {\\n                    \\n                    st.insert(grid[row][col]);\\n                    col++;row++;\\n                }\\n                bottom_right=st.size();\\n                st.clear();\\n                col=j-1;  row=i-1;\\n                \\n                while(col >=0 and row >=0) {\\n                    \\n                    st.insert(grid[row][col]);\\n                    col--;row--;\\n                }\\n                top_left=st.size();\\n                st.clear();\\n                ans[i][j]=abs(top_left-bottom_right);\\n              \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n      int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                int col=j+1, row=i+1, bottom_right=0, top_left=0;\\n                unordered_set<int>st;\\n               \\n                while(col < n and row < m) {\\n                    \\n                    st.insert(grid[row][col]);\\n                    col++;row++;\\n                }\\n                bottom_right=st.size();\\n                st.clear();\\n                col=j-1;  row=i-1;\\n                \\n                while(col >=0 and row >=0) {\\n                    \\n                    st.insert(grid[row][col]);\\n                    col--;row--;\\n                }\\n                top_left=st.size();\\n                st.clear();\\n                ans[i][j]=abs(top_left-bottom_right);\\n              \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570241,
                "title": "simple-diagonal-traverse-solution-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] res = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int bR = countDistant(grid, i+1, j+1, 1);\\n                int tL = countDistant(grid, i-1, j-1, -1);\\n                // System.out.println(i+\",\"+j+\"  = \"+bR+\"  \"+tL);\\n                res[i][j] = Math.abs(bR - tL);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int countDistant(int[][] grid, int i, int j, int inc) {\\n        Set<Integer> set = new HashSet<>();\\n       for (; i < grid.length && i>=0 && j < grid[0].length && j>=0; i+=inc) {\\n            set.add(grid[i][j]);\\n           j+=inc;\\n        }\\n        // System.out.println(set);\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] res = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int bR = countDistant(grid, i+1, j+1, 1);\\n                int tL = countDistant(grid, i-1, j-1, -1);\\n                // System.out.println(i+\",\"+j+\"  = \"+bR+\"  \"+tL);\\n                res[i][j] = Math.abs(bR - tL);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int countDistant(int[][] grid, int i, int j, int inc) {\\n        Set<Integer> set = new HashSet<>();\\n       for (; i < grid.length && i>=0 && j < grid[0].length && j>=0; i+=inc) {\\n            set.add(grid[i][j]);\\n           j+=inc;\\n        }\\n        // System.out.println(set);\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849660,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n   \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def differenceOfDistinctValues(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        ar = []\\n        ro = len(grid)\\n        co = len(grid[0])\\n        for i in range(len(grid)):\\n            ls = []\\n            for j in range(len(grid[i])):\\n                le = set()\\n                re = set()\\n                x = i - 1\\n                y = j - 1\\n                while x >= 0 and y >= 0:\\n                    le.add(grid[x][y])\\n                    x -= 1\\n                    y -= 1\\n                x = i + 1\\n                y = j + 1\\n                while x < ro and y < co:\\n                    re.add(grid[x][y])\\n                    x += 1\\n                    y += 1\\n                ls.append(abs(len(le) - len(re)))\\n            ar.append(ls)  \\n\\n        return ar\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def differenceOfDistinctValues(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        ar = []\\n        ro = len(grid)\\n        co = len(grid[0])\\n        for i in range(len(grid)):\\n            ls = []\\n            for j in range(len(grid[i])):\\n                le = set()\\n                re = set()\\n                x = i - 1\\n                y = j - 1\\n                while x >= 0 and y >= 0:\\n                    le.add(grid[x][y])\\n                    x -= 1\\n                    y -= 1\\n                x = i + 1\\n                y = j + 1\\n                while x < ro and y < co:\\n                    re.add(grid[x][y])\\n                    x += 1\\n                    y += 1\\n                ls.append(abs(len(le) - len(re)))\\n            ar.append(ls)  \\n\\n        return ar\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666332,
                "title": "java-o-n-95-faster-using-2d-arrays-as-cache-and-hashset",
                "content": "# Intuition\\nCreated two 2D arrays **arrTopLeft** and **arrBotRight** and calculated unique numbers diagonally from left to right and from right to left respectively.\\n\\nIn the end, just saved the absolute difference of the same cells from **arrTopLeft** and **arrBotRight** into initial **grid** and returned it.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] arrTopLeft = new int[m][n], arrBotRight = new int[m][n];\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            int c = 0, r = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrTopLeft[r][c] = set.size();\\n                set.add(grid[r++][c++]);\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            int r = 0, c = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrTopLeft[r][c] = set.size();\\n                set.add(grid[r++][c++]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int r = m - 1, c = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrBotRight[r][c] = set.size();\\n                set.add(grid[r--][c--]);\\n            }\\n        }\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            int c = n - 1, r = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrBotRight[r][c] = set.size();\\n                set.add(grid[r--][c--]);\\n            }\\n        }\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                grid[r][c] = Math.abs(arrTopLeft[r][c] - arrBotRight[r][c]);\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] arrTopLeft = new int[m][n], arrBotRight = new int[m][n];\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            int c = 0, r = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrTopLeft[r][c] = set.size();\\n                set.add(grid[r++][c++]);\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            int r = 0, c = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrTopLeft[r][c] = set.size();\\n                set.add(grid[r++][c++]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int r = m - 1, c = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrBotRight[r][c] = set.size();\\n                set.add(grid[r--][c--]);\\n            }\\n        }\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            int c = n - 1, r = i;\\n            Set<Integer> set = new HashSet<>();\\n            while (cellExists(r, c, grid)) {\\n                arrBotRight[r][c] = set.size();\\n                set.add(grid[r--][c--]);\\n            }\\n        }\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                grid[r][c] = Math.abs(arrTopLeft[r][c] - arrBotRight[r][c]);\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582096,
                "title": "very-easy-simple-without-recursion-using-two-sets-100-acceptable",
                "content": "#### **Using Two Sets**\\n**set1** - stores the TopLeft diagonol result\\n**set2** - stores the BottomRight diagonol result\\n\\n**Constraints:**\\n* m == grid.length\\n* n == grid[i].length\\n* 1 <= m, n, grid[i][j] <= 50\\n\\n**Time Complexity :** O(n^3)\\n\\n```\\nclass Solution {\\npublic:\\n    void topLeft(vector<vector<int>>& grid, int i, int j, set<int>& set1) {\\n        while (i >= 0 && j >= 0) {\\n            set1.insert(grid[i][j]);\\n            i--; j--;\\n        }\\n    }\\n\\n    void bottomRight(vector<vector<int>>& grid, int i, int j, set<int>& set2, int m, int n) {\\n        while (i < m && j < n) {\\n            set2.insert(grid[i][j]);\\n            i++; j++;\\n        }\\n    }\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        set<int> set1;\\n        set<int> set2;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                topLeft(grid, i - 1, j - 1, set1);\\n                bottomRight(grid, i + 1, j + 1, set2, m, n);\\n                ans[i][j] = labs(set1.size() - set2.size());\\n                set1.clear();\\n                set2.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void topLeft(vector<vector<int>>& grid, int i, int j, set<int>& set1) {\\n        while (i >= 0 && j >= 0) {\\n            set1.insert(grid[i][j]);\\n            i--; j--;\\n        }\\n    }\\n\\n    void bottomRight(vector<vector<int>>& grid, int i, int j, set<int>& set2, int m, int n) {\\n        while (i < m && j < n) {\\n            set2.insert(grid[i][j]);\\n            i++; j++;\\n        }\\n    }\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        set<int> set1;\\n        set<int> set2;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                topLeft(grid, i - 1, j - 1, set1);\\n                bottomRight(grid, i + 1, j + 1, set2, m, n);\\n                ans[i][j] = labs(set1.size() - set2.size());\\n                set1.clear();\\n                set2.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578138,
                "title": "easy-solution-using-map-and-set",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nAll cells in a diagonal direction have the same difference between their row and column indices. By utilizing this property, the problem can be easily solved.\\n\\nFor example, the difference between the row and column coordinates of $$grid[i + 1][j + 1]$$ can be calculated as:\\n\\n$$(i + 1) - (j + 1) = i - j$$\\n\\nAnd this will be equal to the difference between the row and column coordinates of $$grid[i][j]$$.\\n\\nBy using this difference between the row and column coordinates as the key in a map, the problem can be easily solved.\\n\\n# Complexity\\n- Time complexity: $$O(N*M)$$\\n- Space complexity: $$O(N*M)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int N = int(grid.size());\\n        int M = int(grid[0].size());\\n\\n        vector<vector<int>> res(N, vector<int>(M));\\n\\n        // forward\\n        unordered_map<int,unordered_set<int>> diag;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < M; j++) {\\n                res[i][j] = int(diag[i - j].size());\\n                diag[i - j].insert(grid[i][j]);\\n            }\\n        }\\n\\n        // backward\\n        diag.clear();\\n        for (int i = N - 1; i >= 0; i--) {\\n            for (int j = M - 1; j >= 0; j--) {\\n                res[i][j] = abs(res[i][j] - int(diag[i - j].size()));\\n                diag[i - j].insert(grid[i][j]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int N = int(grid.size());\\n        int M = int(grid[0].size());\\n\\n        vector<vector<int>> res(N, vector<int>(M));\\n\\n        // forward\\n        unordered_map<int,unordered_set<int>> diag;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < M; j++) {\\n                res[i][j] = int(diag[i - j].size());\\n                diag[i - j].insert(grid[i][j]);\\n            }\\n        }\\n\\n        // backward\\n        diag.clear();\\n        for (int i = N - 1; i >= 0; i--) {\\n            for (int j = M - 1; j >= 0; j--) {\\n                res[i][j] = abs(res[i][j] - int(diag[i - j].size()));\\n                diag[i - j].insert(grid[i][j]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573300,
                "title": "java-two-pass-time-o-m-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI see a lot of brute force solutions in which the top-left and bottom-right values are recomputed every cell. This means that we do a lot of the same computations over and over again, drastically increasing the execution time.\\n\\nInstead we can realise that this problem is essentialy a presum (top-left) / postsum (bottom-right) question and by treating it as such we can significantly reduce the runtime.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse each diagonal and count the number of distinct elements, storing them as botRight. Then we can immediately traverse the diagonal again, and as we go we count the distinct elements as topLeft, while subtracting elements from botRight.\\n\\nIn the implementation below I\\'ve also chosen to store the return values in the input array for demonstration purposes, thus using $$O(1)$$ memory. This might obviously not be the ideal solution if you want to preserve the input array, so bear that in mind.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for(int i = m - 1; i >= 0; i--) {\\n            populateDiagonal(grid, i, 0);\\n        }\\n        for(int j = 1; j < n; j++) {\\n            populateDiagonal(grid, 0, j);\\n        }\\n        return grid;\\n    }\\n\\n    private void populateDiagonal(int[][] grid, int row, int col) {\\n        int m = grid.length, n = grid[0].length, botRight = 0, topLeft = 0;\\n        int[] botRightCount = new int[51], topLeftCount = new int[51];\\n        for(int i = row, j = col; i < m && j < n; i++, j++) {\\n            if(botRightCount[grid[i][j]]++ == 0) botRight++;\\n        }\\n        for(int i = row, j = col; i < m && j < n; i++, j++) {\\n            if(botRightCount[grid[i][j]]-- == 1) botRight--;\\n            int diff = Math.abs(topLeft - botRight);\\n            if(topLeftCount[grid[i][j]]++ == 0) topLeft++;\\n            grid[i][j] = diff;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for(int i = m - 1; i >= 0; i--) {\\n            populateDiagonal(grid, i, 0);\\n        }\\n        for(int j = 1; j < n; j++) {\\n            populateDiagonal(grid, 0, j);\\n        }\\n        return grid;\\n    }\\n\\n    private void populateDiagonal(int[][] grid, int row, int col) {\\n        int m = grid.length, n = grid[0].length, botRight = 0, topLeft = 0;\\n        int[] botRightCount = new int[51], topLeftCount = new int[51];\\n        for(int i = row, j = col; i < m && j < n; i++, j++) {\\n            if(botRightCount[grid[i][j]]++ == 0) botRight++;\\n        }\\n        for(int i = row, j = col; i < m && j < n; i++, j++) {\\n            if(botRightCount[grid[i][j]]-- == 1) botRight--;\\n            int diff = Math.abs(topLeft - botRight);\\n            if(topLeftCount[grid[i][j]]++ == 0) topLeft++;\\n            grid[i][j] = diff;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572974,
                "title": "python-iterate-over-diagonals-use-set-to-determine-unique-elements",
                "content": "This solution is very brute force, but it works.  This solution doesn\\'t have defined \"TopLeft\" and \"BottomRight\" functions but there\\'s subprocesses for each to iterate outward from a given cell and determine elements along the diagonal.\\n\\n# Approach\\nThis code uses nested ```for``` loops to iterate over every cell in grid.  For a given cell index of (row, column), construct a set (each) for the top left diagonal and the bottom right diagonal.  Using the starting (row, column):\\n\\\\- decrement both the row and column by 1, and if that cell is valid, add that to the top left set (TLset)\\n\\\\- increase both the row and column by 1, and if that cell is valid, add that to the bottom right set (BRset)\\n(Note that this solution uses generic code to determine whether a row index or column index is valid, technically you only need to check > 0 when decrementing for \"top left\" and <= num rows or <= num cols when increasing for \"bottom right\" but it was simple enough to write a comprehensive validity check and just use it for both.)\\n\\nFor a given cell in grid, once TLset and BRset are complete, use ```abs(len(TLset) - len(BRset))``` to calculate the difference in unique elements between each of those 2 sets.  Repeat this process for all cells.\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        ans = []\\n        for _ in range(m):\\n            ans.append([-1]*n)\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                TLset = set()\\n                TLR, TLC = r, c\\n\\n                while 0 <= TLR - 1 < m and 0 <= TLC - 1 < n:\\n                    TLR -= 1\\n                    TLC -= 1\\n                    TLset.add(grid[TLR][TLC])\\n\\n                BRset = set()\\n                BRR, BRC = r, c\\n                while 0 <= BRR + 1 < m and 0 <= BRC + 1 < n:\\n                    BRR += 1\\n                    BRC += 1\\n                    BRset.add(grid[BRR][BRC])\\n                \\n                ans[r][c] = abs(len(TLset) - len(BRset))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```for```\n```abs(len(TLset) - len(BRset))```\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        ans = []\\n        for _ in range(m):\\n            ans.append([-1]*n)\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                TLset = set()\\n                TLR, TLC = r, c\\n\\n                while 0 <= TLR - 1 < m and 0 <= TLC - 1 < n:\\n                    TLR -= 1\\n                    TLC -= 1\\n                    TLset.add(grid[TLR][TLC])\\n\\n                BRset = set()\\n                BRR, BRC = r, c\\n                while 0 <= BRR + 1 < m and 0 <= BRC + 1 < n:\\n                    BRR += 1\\n                    BRC += 1\\n                    BRset.add(grid[BRR][BRC])\\n                \\n                ans[r][c] = abs(len(TLset) - len(BRset))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571108,
                "title": "very-easy-java-solution-by-using-set",
                "content": "# Intuition\\nWe have to subtract distinct values of left side to the distinct values of right side of iteration of the each diagnals .\\nHere diagnals is top left to bottom right, like this ->  \\\\\\n                                                       \\\\  \\\\\\n                                                      \\\\ \\\\  \\\\\\n                                                       \\\\  \\\\  \\\\\\n\\n**Since Set contains only distinct values, so we will use Set**\\n\\n# Approach\\nFor each element we will be finding out its leftSet and rightSet in the diagnal. For eg->   \\n                         2   element of left set\\n                           4  (iterating element)\\n                            2  (right Set)\\n\\n\\n**In the above case our ans will be leftSet.size()-righSet.size() i.e 1-1=0**\\n\\n**In First Step:**\\ncalling function       \\nfor these elements:\\n                            ->  [2,4,6]\\n                            ->  [1,4,2]\\n                            ->  [5,7,2]\\n\\n\\n**In Second Step:**\\ncalling function       \\nfor these elements:\\n                             \\u2193 \\u2193  \\u2193\\n                             [2,4,6]\\n                             [1,4,2]\\n                             [5,7,2]\\n\\n# Complexity\\n- Time complexity:\\nFor each iteration we are making set, so it will take nlogn. And for iterating through each element, it will take nxn \\nso, overall T.C if there is nxn matrix will be-> $$O(n^3logn)$$\\n\\n# Code\\n```\\n class Solution {\\n    int ansGrid[][];\\n    public void differenceOfDistinctValuesUtil(int [][]grid,int n,int m,int row,int col)\\n    {\\n        Set<Integer>leftSet=new TreeSet<Integer>();\\n        while(row<n&&col<m)  // iterating for leftSet\\n        {\\n            Set<Integer>rightSet=new TreeSet<>();\\n            int x=row+1,y=col+1;\\n            while(x<n&&y<m)  // for every time while we will make rightSet\\n            {\\n                rightSet.add(grid[x][y]);\\n                x++;\\n                y++;\\n            }\\n            ansGrid[row][col]=Math.abs(rightSet.size()-leftSet.size());\\n\\n            leftSet.add(grid[row][col]);\\n            row++;\\n            col++;\\n        }\\n    }\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        ansGrid=new int[n][m];\\n        for(int i=0;i<n;i++)   // making diagnal through first element of each row\\n            differenceOfDistinctValuesUtil(grid,n,m,i,0);\\n        for(int j=1;j<m;j++)  // making diagnal through first element for each coloumn\\n            differenceOfDistinctValuesUtil(grid,n,m,0,j);\\n        return ansGrid;\\n    }\\n}\\n```\\n\\nPlease Upvote :)",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\n class Solution {\\n    int ansGrid[][];\\n    public void differenceOfDistinctValuesUtil(int [][]grid,int n,int m,int row,int col)\\n    {\\n        Set<Integer>leftSet=new TreeSet<Integer>();\\n        while(row<n&&col<m)  // iterating for leftSet\\n        {\\n            Set<Integer>rightSet=new TreeSet<>();\\n            int x=row+1,y=col+1;\\n            while(x<n&&y<m)  // for every time while we will make rightSet\\n            {\\n                rightSet.add(grid[x][y]);\\n                x++;\\n                y++;\\n            }\\n            ansGrid[row][col]=Math.abs(rightSet.size()-leftSet.size());\\n\\n            leftSet.add(grid[row][col]);\\n            row++;\\n            col++;\\n        }\\n    }\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        ansGrid=new int[n][m];\\n        for(int i=0;i<n;i++)   // making diagnal through first element of each row\\n            differenceOfDistinctValuesUtil(grid,n,m,i,0);\\n        for(int j=1;j<m;j++)  // making diagnal through first element for each coloumn\\n            differenceOfDistinctValuesUtil(grid,n,m,0,j);\\n        return ansGrid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570900,
                "title": "simple-brute-force-using-sets",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                s1, s2 = set(), set()\\n                x1, y1 = i+1, j+1\\n                while x1 < m and y1 < n:\\n                    s1.add(grid[x1][y1])\\n                    x1+=1\\n                    y1+=1\\n                x2, y2 = i-1, j-1\\n                while x2 >= 0 and y2 >= 0:\\n                    s2.add(grid[x2][y2])\\n                    x2-=1\\n                    y2-=1\\n                dp[i][j] = abs(len(s1)-len(s2))\\n        return dp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                s1, s2 = set(), set()\\n                x1, y1 = i+1, j+1\\n                while x1 < m and y1 < n:\\n                    s1.add(grid[x1][y1])\\n                    x1+=1\\n                    y1+=1\\n                x2, y2 = i-1, j-1\\n                while x2 >= 0 and y2 >= 0:\\n                    s2.add(grid[x2][y2])\\n                    x2-=1\\n                    y2-=1\\n                dp[i][j] = abs(len(s1)-len(s2))\\n        return dp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570873,
                "title": "easy-java-solution-with-comments-explained-beginners",
                "content": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n               int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] res=new int[m][n];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                res[i][j]=calculate(grid,i,j);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int calculate(int[][] arr,int i,int j){\\n        int r1=i;\\n        int r2=i;\\n        int c1=j;\\n        int c2=j;\\n        \\n        HashSet<Integer> hs1=new HashSet(); // to store distinct values of upper diagonal\\n        HashSet<Integer> hs2=new HashSet(); // to store distinct values of lower diagonal\\n        \\n        // to store distinct values of upper diagonal\\n        while(r1>0 && c1>0){\\n            hs1.add(arr[--r1][--c1]);\\n        }\\n        \\n        // to store distinct values of lower diagonal\\n        while(r2<arr.length-1 && c2<arr[0].length-1){\\n            hs2.add(arr[++r2][++c2]);\\n        }\\n        return Math.abs(hs1.size()-hs2.size());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n               int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] res=new int[m][n];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                res[i][j]=calculate(grid,i,j);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int calculate(int[][] arr,int i,int j){\\n        int r1=i;\\n        int r2=i;\\n        int c1=j;\\n        int c2=j;\\n        \\n        HashSet<Integer> hs1=new HashSet(); // to store distinct values of upper diagonal\\n        HashSet<Integer> hs2=new HashSet(); // to store distinct values of lower diagonal\\n        \\n        // to store distinct values of upper diagonal\\n        while(r1>0 && c1>0){\\n            hs1.add(arr[--r1][--c1]);\\n        }\\n        \\n        // to store distinct values of lower diagonal\\n        while(r2<arr.length-1 && c2<arr[0].length-1){\\n            hs2.add(arr[++r2][++c2]);\\n        }\\n        return Math.abs(hs1.size()-hs2.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570860,
                "title": "basic-approach-not-good-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n       int ans[][] = new int[grid.length][grid[0].length]; \\n       for(int i = 0 ; i<grid.length ; i++){\\n           for(int j =0 ; j<grid[0].length; j++){\\n               int temp1 = i;\\n               int temp2 = j;\\n               \\n               \\n               ArrayList<Integer> ans1 = new ArrayList<>();\\n               while(temp1>0 && temp2>0){\\n                   \\n                   \\n                 temp1--;\\n                 temp2--;\\n                 if(!ans1.contains(grid[temp1][temp2])){\\n                       ans1.add(grid[temp1][temp2]);    \\n                   }\\n                   \\n               }\\n               \\n               temp1 = i;\\n               temp2 = j;\\n               \\n               ArrayList<Integer> ans2 = new ArrayList<>();\\n               while(temp1<grid.length-1 && temp2<grid[0].length-1){\\n\\n                   \\n                  temp1++;\\n                  temp2++;\\n                  if(!ans2.contains(grid[temp1][temp2])){\\n                       ans2.add(grid[temp1][temp2]);\\n                   }\\n               }\\n               \\n               \\n               \\n               \\n               int a = ans1.size() - ans2.size();\\n               \\n               ans[i][j] = Math.abs(a);\\n               \\n               \\n               \\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n       int ans[][] = new int[grid.length][grid[0].length]; \\n       for(int i = 0 ; i<grid.length ; i++){\\n           for(int j =0 ; j<grid[0].length; j++){\\n               int temp1 = i;\\n               int temp2 = j;\\n               \\n               \\n               ArrayList<Integer> ans1 = new ArrayList<>();\\n               while(temp1>0 && temp2>0){\\n                   \\n                   \\n                 temp1--;\\n                 temp2--;\\n                 if(!ans1.contains(grid[temp1][temp2])){\\n                       ans1.add(grid[temp1][temp2]);    \\n                   }\\n                   \\n               }\\n               \\n               temp1 = i;\\n               temp2 = j;\\n               \\n               ArrayList<Integer> ans2 = new ArrayList<>();\\n               while(temp1<grid.length-1 && temp2<grid[0].length-1){\\n\\n                   \\n                  temp1++;\\n                  temp2++;\\n                  if(!ans2.contains(grid[temp1][temp2])){\\n                       ans2.add(grid[temp1][temp2]);\\n                   }\\n               }\\n               \\n               \\n               \\n               \\n               int a = ans1.size() - ans2.size();\\n               \\n               ans[i][j] = Math.abs(a);\\n               \\n               \\n               \\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570620,
                "title": "c-easy-beginner-freindly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code calculates the difference in the number of distinct values between the top-left diagonal direction and the bottom-right diagonal direction for each element in the grid. It counts the distinct values encountered in each direction separately and then subtracts the count to get the difference. The resulting grid represents these differences for each element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(rws * cls)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(rws * cls)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int rws = grid.size();\\n        int cls = grid[0].size();\\n        \\n        vector<vector<int>> res(rws,vector<int>(cls));\\n        \\n        for(int i=0; i<rws; i++)\\n        {\\n            for(int j=0; j<cls; j++)\\n            {\\n                int ROW = i-1,COL = j-1;\\n                unordered_map<int,int> mp1;\\n                \\n                while(ROW >= 0 && COL >= 0)\\n                {\\n                    mp1[grid[ROW][COL]]++;\\n                    ROW--;\\n                    COL--;\\n                }\\n                \\n                int RowRght=i+1,ColRght=j+1;\\n                unordered_map<int,int>mp2;\\n                \\n                while(RowRght<rws && ColRght<cls)\\n                {\\n                    mp2[grid[RowRght][ColRght]]++;\\n                    RowRght++;\\n                    ColRght++;\\n                }\\n            \\n                res[i][j]=abs((int)mp1.size() - (int)mp2.size());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int rws = grid.size();\\n        int cls = grid[0].size();\\n        \\n        vector<vector<int>> res(rws,vector<int>(cls));\\n        \\n        for(int i=0; i<rws; i++)\\n        {\\n            for(int j=0; j<cls; j++)\\n            {\\n                int ROW = i-1,COL = j-1;\\n                unordered_map<int,int> mp1;\\n                \\n                while(ROW >= 0 && COL >= 0)\\n                {\\n                    mp1[grid[ROW][COL]]++;\\n                    ROW--;\\n                    COL--;\\n                }\\n                \\n                int RowRght=i+1,ColRght=j+1;\\n                unordered_map<int,int>mp2;\\n                \\n                while(RowRght<rws && ColRght<cls)\\n                {\\n                    mp2[grid[RowRght][ColRght]]++;\\n                    RowRght++;\\n                    ColRght++;\\n                }\\n            \\n                res[i][j]=abs((int)mp1.size() - (int)mp2.size());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570452,
                "title": "c-verry-easy-solution-using-set",
                "content": "c++ Easy Solution using unordered_set\\n\\nHere\\'s a step-by-step explanation of how the code works:\\n\\n1. A 2D vector answer is initialized with dimensions m x n, and all elements are initialized to 0. This vector will store the results of the calculations.\\n\\n2. Two unordered sets, topLeft and bottomRight, are declared. These sets will be used to store distinct values in the top left and bottom right portions of each cell, respectively.\\n\\n3. Two nested loops iterate over each cell in the grid matrix using variables r and c. The outer loop iterates over the rows (r), and the inner loop iterates over the columns (c).\\n\\n4. Inside the nested loops, two more nested loops are used to iterate over the elements in the top left and bottom right portions of each cell.\\n\\n5. The first inner loop iterates from index 0 to r-1 (exclusive). It checks if the current indices are within the valid range and inserts the corresponding element from the grid matrix into the topLeft set.\\n\\n6. The second inner loop iterates from index r+1 to m-1 (inclusive). It checks if the current indices are within the valid range and inserts the corresponding element from the grid matrix into the bottomRight set.\\n\\n7. After the inner loops, the answer[r][c] element is calculated as the absolute difference between the sizes of the topLeft and bottomRight sets.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n, 0));\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                unordered_set<int> topLeft;\\n                unordered_set<int> bottomRight;\\n\\n                for (int i = 0; i < r; i++) {\\n                    if (i < m && c - r + i >= 0) {\\n                        topLeft.insert(grid[i][c - r + i]);\\n                    }\\n                }\\n\\n                for (int i = r + 1; i < m; i++) {\\n                    if (i < m && c + i - r < n) {\\n                        bottomRight.insert(grid[i][c + i - r]);\\n                    }\\n                }\\n\\n                answer[r][c] = abs(static_cast<int>(topLeft.size()) - static_cast<int>(bottomRight.size()));\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n, 0));\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                unordered_set<int> topLeft;\\n                unordered_set<int> bottomRight;\\n\\n                for (int i = 0; i < r; i++) {\\n                    if (i < m && c - r + i >= 0) {\\n                        topLeft.insert(grid[i][c - r + i]);\\n                    }\\n                }\\n\\n                for (int i = r + 1; i < m; i++) {\\n                    if (i < m && c + i - r < n) {\\n                        bottomRight.insert(grid[i][c + i - r]);\\n                    }\\n                }\\n\\n                answer[r][c] = abs(static_cast<int>(topLeft.size()) - static_cast<int>(bottomRight.size()));\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570447,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<grid[i][j];\\n            }\\n            cout<<endl;\\n        }\\n        for(int i=0;i<m;i++){\\n            vector<int> temp;\\n            ans.push_back(temp);\\n            for(int j=0;j<n;j++){\\n                cout<<i<<j<<endl;\\n                map<int,int> mp1,mp2;\\n                int p=i-1,q=j-1;\\n                while(p>=0 && q>=0){\\n                    mp1[grid[p][q]]++;p--;q--;\\n                }\\n                cout<<\"mp1size:\"<<mp1.size();\\n                p=i+1;q=j+1;\\n                while(p<m && q<n){\\n                   mp2[grid[p][q]]++;p++;q++;\\n                }\\n                cout<<\"mp2size:\"<<mp2.size()<<endl;\\n                if(mp1.size()>mp2.size()){ans[i].push_back(mp1.size()-mp2.size());cout<<mp1.size()-mp2.size()<<endl;}\\n                else{ans[i].push_back(mp2.size()-mp1.size());cout<<mp2.size()-mp1.size()<<endl;}\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<grid[i][j];\\n            }\\n            cout<<endl;\\n        }\\n        for(int i=0;i<m;i++){\\n            vector<int> temp;\\n            ans.push_back(temp);\\n            for(int j=0;j<n;j++){\\n                cout<<i<<j<<endl;\\n                map<int,int> mp1,mp2;\\n                int p=i-1,q=j-1;\\n                while(p>=0 && q>=0){\\n                    mp1[grid[p][q]]++;p--;q--;\\n                }\\n                cout<<\"mp1size:\"<<mp1.size();\\n                p=i+1;q=j+1;\\n                while(p<m && q<n){\\n                   mp2[grid[p][q]]++;p++;q++;\\n                }\\n                cout<<\"mp2size:\"<<mp2.size()<<endl;\\n                if(mp1.size()>mp2.size()){ans[i].push_back(mp1.size()-mp2.size());cout<<mp1.size()-mp2.size()<<endl;}\\n                else{ans[i].push_back(mp2.size()-mp1.size());cout<<mp2.size()-mp1.size()<<endl;}\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3570415,
                "title": "two-passes-python",
                "content": "All elements on the diagonal has the same value of `i - j`, so we can maintain dictionary of diagonal elements sets with keys calculated as `i - j`.\\n\\nIn the first pass we\\'ll iterate from top left cell, filling `answer` with `topLeft` values. In the second pass we\\'ll iterate from bottom right cell, subtracting from `answer` values of `bottomRight`.\\n\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        answer = [[0] * n for _ in range(m)]\\n        \\n        diagonals = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                answer[i][j] = len(diagonals[i - j])\\n                diagonals[i - j].add(grid[i][j])\\n\\n        diagonals.clear()\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                answer[i][j] = abs(answer[i][j] - len(diagonals[i - j]))\\n                diagonals[i - j].add(grid[i][j])\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        answer = [[0] * n for _ in range(m)]\\n        \\n        diagonals = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                answer[i][j] = len(diagonals[i - j])\\n                diagonals[i - j].add(grid[i][j])\\n\\n        diagonals.clear()\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                answer[i][j] = abs(answer[i][j] - len(diagonals[i - j]))\\n                diagonals[i - j].add(grid[i][j])\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570360,
                "title": "brute-force-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChecking for each index top element and bottom element. Then assigning the difference of sign of these sets.\\nSimple iterative approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m));\\n        for (int x = 0; x < n; x++) {\\n            for (int y = 0; y < m; y++) {\\n                set<int> top, bottom;\\n                int i = x+1, j = y+1;\\n                while (i < n && j < m) {\\n                    top.insert(grid[i][j]);\\n                    i++;\\n                    j++;\\n                }\\n                i = x-1;\\n                j = y-1;\\n                while (i >= 0 && j >= 0) {  // Corrected condition here\\n                    bottom.insert(grid[i][j]);\\n                    i--;\\n                    j--;\\n                }\\n                ans[x][y] = abs(int(top.size()) - int(bottom.size()));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m));\\n        for (int x = 0; x < n; x++) {\\n            for (int y = 0; y < m; y++) {\\n                set<int> top, bottom;\\n                int i = x+1, j = y+1;\\n                while (i < n && j < m) {\\n                    top.insert(grid[i][j]);\\n                    i++;\\n                    j++;\\n                }\\n                i = x-1;\\n                j = y-1;\\n                while (i >= 0 && j >= 0) {  // Corrected condition here\\n                    bottom.insert(grid[i][j]);\\n                    i--;\\n                    j--;\\n                }\\n                ans[x][y] = abs(int(top.size()) - int(bottom.size()));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570353,
                "title": "python3-simple",
                "content": "# Intuition\\nWe are iteratively making array `q` from each diagonal.\\nThen we create a new array `qAnsw` with the required numbers.\\nFinally we put these numbers back to the actual diagonal of `grid`.\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        R,C=len(grid),len(grid[0])\\n        for c in range(C):\\n            q,r,qAnsw=[],0,[]\\n            while c+r<C and r<R:\\n                q.append(grid[r][r+c])\\n                r+=1\\n            for i in range(len(q)):\\n                qAnsw.append(abs(len(set(q[:i])) - len(set(q[i+1:]))))\\n            r=0\\n            while c+r<C and r<R:\\n                grid[r][r+c]=qAnsw[r]\\n                r+=1\\n            \\n        for r in range(1,R):\\n            q,c,qAnsw=[],0,[]\\n            c=0\\n            while r+c<R and c<C:\\n                q.append(grid[r+c][c])\\n                c+=1\\n            for i in range(len(q)):\\n                qAnsw.append(abs(len(set(q[:i])) - len(set(q[i+1:]))))\\n            c=0\\n            while c+r<R and c<C:\\n                grid[r+c][c]=qAnsw[c]\\n                c+=1\\n        return grid      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        R,C=len(grid),len(grid[0])\\n        for c in range(C):\\n            q,r,qAnsw=[],0,[]\\n            while c+r<C and r<R:\\n                q.append(grid[r][r+c])\\n                r+=1\\n            for i in range(len(q)):\\n                qAnsw.append(abs(len(set(q[:i])) - len(set(q[i+1:]))))\\n            r=0\\n            while c+r<C and r<R:\\n                grid[r][r+c]=qAnsw[r]\\n                r+=1\\n            \\n        for r in range(1,R):\\n            q,c,qAnsw=[],0,[]\\n            c=0\\n            while r+c<R and c<C:\\n                q.append(grid[r+c][c])\\n                c+=1\\n            for i in range(len(q)):\\n                qAnsw.append(abs(len(set(q[:i])) - len(set(q[i+1:]))))\\n            c=0\\n            while c+r<R and c<C:\\n                grid[r+c][c]=qAnsw[c]\\n                c+=1\\n        return grid      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570349,
                "title": "easy-java-solution",
                "content": "- Time complexity: O(n*n)\\n\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n      \\n      int lenr=grid.length;\\n      int lenc=grid[0].length;\\n      int ans[][] =new int[lenr][lenc];\\n      for(int i=0;i<lenr;i++)\\n      {\\n          for(int j=0;j<lenc;j++)\\n          {\\n                ans[i][j]=calculate(grid,i,j);\\n          }\\n      }\\n      return ans;\\n    }\\n    public int calculate(int matric[][],int ii,int jj)\\n    {\\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        int u=ii-1;\\n        int v=jj-1;\\n        while(u>=0 && v>=0)\\n        {\\n            set1.add(matric[u--][v--]);\\n        }\\n        ii+=1;\\n        jj+=1;\\n        while(ii<matric.length && jj<matric[0].length)\\n        {\\n            set2.add(matric[ii++][jj++]);\\n        }\\n       return Math.abs(set1.size()-set2.size()); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n      \\n      int lenr=grid.length;\\n      int lenc=grid[0].length;\\n      int ans[][] =new int[lenr][lenc];\\n      for(int i=0;i<lenr;i++)\\n      {\\n          for(int j=0;j<lenc;j++)\\n          {\\n                ans[i][j]=calculate(grid,i,j);\\n          }\\n      }\\n      return ans;\\n    }\\n    public int calculate(int matric[][],int ii,int jj)\\n    {\\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        int u=ii-1;\\n        int v=jj-1;\\n        while(u>=0 && v>=0)\\n        {\\n            set1.add(matric[u--][v--]);\\n        }\\n        ii+=1;\\n        jj+=1;\\n        while(ii<matric.length && jj<matric[0].length)\\n        {\\n            set2.add(matric[ii++][jj++]);\\n        }\\n       return Math.abs(set1.size()-set2.size()); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570320,
                "title": "very-intuitive-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst two loops do downward traversal diagonally, the other two do upwards traversal diagonally while keeping track of distinct elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(max(m,n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& a) \\n    {\\n        int m =a.size(),n=a[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            unordered_set<int>h;\\n            for(int i=0,j=k;i<m && j<n;i++,j++)\\n            {\\n                ans[i][j]=h.size();\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        for(int k=1;k<m;k++)\\n        {\\n            unordered_set<int>h;\\n            for(int i=k,j=0;i<m && j<n;i++,j++)\\n            {\\n                ans[i][j]=h.size();\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            unordered_set<int>h;\\n            for(int i=m-1,j=k;i>=0 && j>=0;i--,j--)\\n            {\\n                ans[i][j]=min(ans[i][j]-h.size(),h.size()-ans[i][j]);\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        for(int k=m-2;k>=0;k--)\\n        {\\n            unordered_set<int>h;\\n            for(int i=k,j=n-1;i>=0 && j>=0;i--,j--)\\n            {\\n                ans[i][j]=min(ans[i][j]-h.size(),h.size()-ans[i][j]);\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& a) \\n    {\\n        int m =a.size(),n=a[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            unordered_set<int>h;\\n            for(int i=0,j=k;i<m && j<n;i++,j++)\\n            {\\n                ans[i][j]=h.size();\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        for(int k=1;k<m;k++)\\n        {\\n            unordered_set<int>h;\\n            for(int i=k,j=0;i<m && j<n;i++,j++)\\n            {\\n                ans[i][j]=h.size();\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            unordered_set<int>h;\\n            for(int i=m-1,j=k;i>=0 && j>=0;i--,j--)\\n            {\\n                ans[i][j]=min(ans[i][j]-h.size(),h.size()-ans[i][j]);\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        for(int k=m-2;k>=0;k--)\\n        {\\n            unordered_set<int>h;\\n            for(int i=k,j=n-1;i>=0 && j>=0;i--,j--)\\n            {\\n                ans[i][j]=min(ans[i][j]-h.size(),h.size()-ans[i][j]);\\n                h.insert(a[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570249,
                "title": "explained-c-easiest-approach",
                "content": "# Code\\n```\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n, 0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                set<int>A, B; //2 sets to store distinct diagonal elements\\n                int a=i-1, b=j-1; //Top-left index\\n                while(a>=0 && b>=0 && a<m && b<n)  \\n                {\\n                    A.insert(g[a][b]); \\n                    a--; //Move in top-left direction\\n                    b--;\\n                }\\n                a=i+1, b=j+1; //Bottom-right index\\n                while(a<m && b<n && a>=0 && b>=0)\\n                {\\n                    B.insert(g[a][b]);\\n                    a++; //Move in bottom-right direction\\n                    b++;\\n                }\\n                ans[i][j]=abs(static_cast<int>(A.size()) - static_cast<int>(B.size())); \\n                //If you do not want to use static_cast, simply use 2 integers to store their sizes and take difference\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n# \\u2B06\\uFE0F **PLEASE UPVOTE IF YOU UNDERSTOOD!** \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n, 0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                set<int>A, B; //2 sets to store distinct diagonal elements\\n                int a=i-1, b=j-1; //Top-left index\\n                while(a>=0 && b>=0 && a<m && b<n)  \\n                {\\n                    A.insert(g[a][b]); \\n                    a--; //Move in top-left direction\\n                    b--;\\n                }\\n                a=i+1, b=j+1; //Bottom-right index\\n                while(a<m && b<n && a>=0 && b>=0)\\n                {\\n                    B.insert(g[a][b]);\\n                    a++; //Move in bottom-right direction\\n                    b++;\\n                }\\n                ans[i][j]=abs(static_cast<int>(A.size()) - static_cast<int>(B.size())); \\n                //If you do not want to use static_cast, simply use 2 integers to store their sizes and take difference\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570201,
                "title": "set-c-direct-method-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<m;i++){\\n            vector<int>temp;\\n            for(int j=0;j<n;j++){\\n                set<int>s1,s2;\\n                for(int ri=i+1,rj=j+1;ri<m && rj<n;ri++,rj++){\\n                    s1.insert(grid[ri][rj]);\\n                }\\n                for(int li=i-1,lj=j-1;li>=0 && lj>=0;li--,lj--){\\n                    s2.insert(grid[li][lj]);\\n                }\\n                int val=s1.size()-s2.size();\\n                temp.push_back(val<0?-val:val);                                \\n            }\\n            ans.push_back(temp);\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<m;i++){\\n            vector<int>temp;\\n            for(int j=0;j<n;j++){\\n                set<int>s1,s2;\\n                for(int ri=i+1,rj=j+1;ri<m && rj<n;ri++,rj++){\\n                    s1.insert(grid[ri][rj]);\\n                }\\n                for(int li=i-1,lj=j-1;li>=0 && lj>=0;li--,lj--){\\n                    s2.insert(grid[li][lj]);\\n                }\\n                int val=s1.size()-s2.size();\\n                temp.push_back(val<0?-val:val);                                \\n            }\\n            ans.push_back(temp);\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570193,
                "title": "c-set-100-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int column=grid[0].size();\\n        // vector<vector<int>>ans;\\n        vector<vector<int>>ans(row,vector<int>(column,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<column;j++){\\n            set<int>left;\\n            set<int>right;\\n            int n=i+1;int m=j+1;\\n            while(n<row&&m<column)\\n                right.insert(grid[n++][m++]);\\n            n=i-1,m=j-1;\\n            while(n>=0&&m>=0)\\n                left.insert(grid[n--][m--]);\\n            int a=right.size();\\n            int b=left.size();\\n            ans[i][j]=abs(a-b);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int column=grid[0].size();\\n        // vector<vector<int>>ans;\\n        vector<vector<int>>ans(row,vector<int>(column,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<column;j++){\\n            set<int>left;\\n            set<int>right;\\n            int n=i+1;int m=j+1;\\n            while(n<row&&m<column)\\n                right.insert(grid[n++][m++]);\\n            n=i-1,m=j-1;\\n            while(n>=0&&m>=0)\\n                left.insert(grid[n--][m--]);\\n            int a=right.size();\\n            int b=left.size();\\n            ans[i][j]=abs(a-b);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098305,
                "title": "python-counting-across-diagonals",
                "content": "# Intuition\\nEach (main) diagonal for `(r, c)` is uniquely identified via `r - c`.\\nWe will keep counts for both `bottomRight` (`br`) and `topLeft` (`tl`) and update as we go.\\n\\n# Approach\\nWe iterate the grid fully once to get `br`, then for each `(r, c)` as we iterate we will keep removing count from `br`, calculate the `abs` between non-zero counts and add count to `tl`.\\n\\n# Complexity\\n\\n- Time complexity: $$O(m * n)$$\\n\\n- Space complexity: $$O(m + n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        tl, br = defaultdict(Counter), defaultdict(Counter)\\n        rs, cs = len(grid), len(grid[0])\\n        for r in range(rs):\\n            for c in range(cs):\\n                br[r - c][grid[r][c]] += 1\\n        res = [[0] * cs for _ in range(rs)]\\n        for r in range(rs):\\n            for c in range(cs):\\n                br[r - c][grid[r][c]] -= 1\\n                res[r][c] = abs(sum(v > 0 for v in tl[r - c].values()) - sum(v > 0 for v in br[r - c].values()))\\n                tl[r - c][grid[r][c]] += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        tl, br = defaultdict(Counter), defaultdict(Counter)\\n        rs, cs = len(grid), len(grid[0])\\n        for r in range(rs):\\n            for c in range(cs):\\n                br[r - c][grid[r][c]] += 1\\n        res = [[0] * cs for _ in range(rs)]\\n        for r in range(rs):\\n            for c in range(cs):\\n                br[r - c][grid[r][c]] -= 1\\n                res[r][c] = abs(sum(v > 0 for v in tl[r - c].values()) - sum(v > 0 for v in br[r - c].values()))\\n                tl[r - c][grid[r][c]] += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088447,
                "title": "easy-cpp-solution-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        int cnt1=0,cnt2=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                unordered_set<int> s1,s2;\\n                for(int x=i+1,y=j+1;x<m && y<n;x++,y++){\\n                    s1.insert(grid[x][y]);\\n                }\\n                cnt1=s1.size();\\n                for(int x=i-1,y=j-1;x>=0 && y>=0;x--,y--){\\n                    s2.insert(grid[x][y]);\\n                }\\n                cnt2=s2.size();\\n                ans[i][j]=abs(cnt2-cnt1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        int cnt1=0,cnt2=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                unordered_set<int> s1,s2;\\n                for(int x=i+1,y=j+1;x<m && y<n;x++,y++){\\n                    s1.insert(grid[x][y]);\\n                }\\n                cnt1=s1.size();\\n                for(int x=i-1,y=j-1;x>=0 && y>=0;x--,y--){\\n                    s2.insert(grid[x][y]);\\n                }\\n                cnt2=s2.size();\\n                ans[i][j]=abs(cnt2-cnt1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079836,
                "title": "straightforward-and-efficient-swift-solution",
                "content": "# Approach\\nFor each cell, collect two sets of unique values - topLeft and bottomRight. Sets\\' count difference is the resullting value for the given cell. Repeat within a nested cycle.\\n\\n# Code\\n```\\nclass Solution {\\n\\tfunc differenceOfDistinctValues(_ grid: [[Int]]) -> [[Int]] {\\n\\t\\tvar res = [[Int]]()\\n\\n\\t\\tfor i in 0..<grid.count {\\n\\t\\t\\tres.append([])\\n\\n\\t\\t\\tfor j in 0..<grid[i].count {\\n\\t\\t\\t\\tvar k = i, l = j\\n\\t\\t\\t\\tvar topLeftNums = Set<Int>(), bottomRightNums = Set<Int>()\\n\\n                // Collect unique top-left values\\n\\n\\t\\t\\t\\twhile k > 0 && l > 0 {\\n\\t\\t\\t\\t\\tk -= 1; l -= 1; topLeftNums.insert(grid[k][l])\\n                }\\n\\n\\t\\t\\t\\tk = i; l = j\\n\\n                // Collect unique bottom-right values\\n\\n\\t\\t\\t\\twhile k < (grid.count - 1) && l < (grid[k + 1].count - 1) {\\n\\t\\t\\t\\t\\tk += 1; l += 1; bottomRightNums.insert(grid[k][l])\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tres[i].append(abs(topLeftNums.count - bottomRightNums.count))\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc differenceOfDistinctValues(_ grid: [[Int]]) -> [[Int]] {\\n\\t\\tvar res = [[Int]]()\\n\\n\\t\\tfor i in 0..<grid.count {\\n\\t\\t\\tres.append([])\\n\\n\\t\\t\\tfor j in 0..<grid[i].count {\\n\\t\\t\\t\\tvar k = i, l = j\\n\\t\\t\\t\\tvar topLeftNums = Set<Int>(), bottomRightNums = Set<Int>()\\n\\n                // Collect unique top-left values\\n\\n\\t\\t\\t\\twhile k > 0 && l > 0 {\\n\\t\\t\\t\\t\\tk -= 1; l -= 1; topLeftNums.insert(grid[k][l])\\n                }\\n\\n\\t\\t\\t\\tk = i; l = j\\n\\n                // Collect unique bottom-right values\\n\\n\\t\\t\\t\\twhile k < (grid.count - 1) && l < (grid[k + 1].count - 1) {\\n\\t\\t\\t\\t\\tk += 1; l += 1; bottomRightNums.insert(grid[k][l])\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tres[i].append(abs(topLeftNums.count - bottomRightNums.count))\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069590,
                "title": "java-2-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n    private int n; \\n    private int m;  \\n    public int[][] differenceOfDistinctValues(int[][] a){ \\n        n = a.length; m = a[0].length;\\n        for (int j=0; j<m; j++) go(a,0,j); \\n        for (int i=1;i<n;i++)go(a,i,0); \\n        return a; \\n\\n    } \\n    public void go (int a [][], int i , int j ){ \\n          int x [] = new int[51]; int ii=i; int jj=j;\\n          int y [] = new int[51];  \\n          while(ii<n&&jj<m){ \\n               if(x[a[ii][jj]]++==0)x[0]++;  \\n               jj++; ii++; \\n          } \\n          while(i<n&&j<m){  \\n              int d = a[i][j];\\n              if(--x[d]==0)--x[0]; \\n              a[i][j]=Math.abs(x[0]-y[0]); \\n              if(y[d]++==0)y[0]++;\\n              i++; j++;\\n          }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n    private int n; \\n    private int m;  \\n    public int[][] differenceOfDistinctValues(int[][] a){ \\n        n = a.length; m = a[0].length;\\n        for (int j=0; j<m; j++) go(a,0,j); \\n        for (int i=1;i<n;i++)go(a,i,0); \\n        return a; \\n\\n    } \\n    public void go (int a [][], int i , int j ){ \\n          int x [] = new int[51]; int ii=i; int jj=j;\\n          int y [] = new int[51];  \\n          while(ii<n&&jj<m){ \\n               if(x[a[ii][jj]]++==0)x[0]++;  \\n               jj++; ii++; \\n          } \\n          while(i<n&&j<m){  \\n              int d = a[i][j];\\n              if(--x[d]==0)--x[0]; \\n              a[i][j]=Math.abs(x[0]-y[0]); \\n              if(y[d]++==0)y[0]++;\\n              i++; j++;\\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002619,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def differenceOfDistinctValues(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        topLeft = [[0] * n for i in range(m)]\\n        bottomRight = [[0] * n for i in range(m)]\\n        ans = [[0] * n for i in range(m)]\\n\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                topL = set()\\n                botR = set()\\n                l = i\\n                r = j\\n                while 0 <= l - 1 < m and 0 <= r - 1 < n: #check topL\\n                    l -= 1\\n                    r -= 1\\n                    topL.add(grid[l][r])\\n                topLeft[i][j] = len(topL)\\n                l = i\\n                r = j\\n                while 0 <= l + 1 < m and 0 <= r + 1 < n: #check botR\\n                    l += 1\\n                    r += 1\\n                    botR.add(grid[l][r])\\n                bottomRight[i][j] = len(botR)\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = abs(topLeft[i][j] - bottomRight[i][j])\\n\\n\\n\\n        return ans\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def differenceOfDistinctValues(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        topLeft = [[0] * n for i in range(m)]\\n        bottomRight = [[0] * n for i in range(m)]\\n        ans = [[0] * n for i in range(m)]\\n\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                topL = set()\\n                botR = set()\\n                l = i\\n                r = j\\n                while 0 <= l - 1 < m and 0 <= r - 1 < n: #check topL\\n                    l -= 1\\n                    r -= 1\\n                    topL.add(grid[l][r])\\n                topLeft[i][j] = len(topL)\\n                l = i\\n                r = j\\n                while 0 <= l + 1 < m and 0 <= r + 1 < n: #check botR\\n                    l += 1\\n                    r += 1\\n                    botR.add(grid[l][r])\\n                bottomRight[i][j] = len(botR)\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = abs(topLeft[i][j] - bottomRight[i][j])\\n\\n\\n\\n        return ans\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970196,
                "title": "c-simple-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int i=0;\\n        int j=0;\\n          vector<vector<int>> res;\\n        int m=grid[0].size(),n=grid.size();\\n           while(i<n)\\n            {\\n                 vector<int>v;\\n      \\n               while(j<m)\\n            {\\n              int r=i-1;\\n              int c=j-1;\\n              set<int>tpleft,bright;\\n              while(r>=0 and c>=0)\\n                {\\n                    tpleft.insert(grid[r][c]);\\n                    r--;\\n                    c--;\\n                }\\n                r=i+1,c=j+1;\\n                    while(r<n and c<m)\\n                {\\n                    bright.insert(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n                int d=abs((int)tpleft.size()-(int)bright.size());\\n                v.push_back(d);\\n              j++;\\n          } \\n          res.push_back(v);\\n          i++;\\n          j=0;\\n        }\\n          // for(auto it:v)\\n          //     cout<<it<<\" \";\\n          return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int i=0;\\n        int j=0;\\n          vector<vector<int>> res;\\n        int m=grid[0].size(),n=grid.size();\\n           while(i<n)\\n            {\\n                 vector<int>v;\\n      \\n               while(j<m)\\n            {\\n              int r=i-1;\\n              int c=j-1;\\n              set<int>tpleft,bright;\\n              while(r>=0 and c>=0)\\n                {\\n                    tpleft.insert(grid[r][c]);\\n                    r--;\\n                    c--;\\n                }\\n                r=i+1,c=j+1;\\n                    while(r<n and c<m)\\n                {\\n                    bright.insert(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n                int d=abs((int)tpleft.size()-(int)bright.size());\\n                v.push_back(d);\\n              j++;\\n          } \\n          res.push_back(v);\\n          i++;\\n          j=0;\\n        }\\n          // for(auto it:v)\\n          //     cout<<it<<\" \";\\n          return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3932759,
                "title": "prefix-python-o-m-n",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix for each diagnal line\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        def getDiff(nums):\\n            lSet = set()\\n            rSet = set()\\n            l = [0] * len(nums)\\n            r = [0] * len(nums)\\n            for i in range(1, len(nums)):\\n                lSet.add(nums[i-1])\\n                l[i] = len(lSet)\\n                \\n                j = len(nums) - 1 - i\\n                rSet.add(nums[j+1])\\n                r[j] = len(rSet)\\n            return [abs(l[i]-r[i]) for i in range(len(nums))]\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = [[0]*n for _ in range(m)]\\n        def extend(pos):\\n            nonlocal ans\\n            tmp = []\\n            x, y = pos[0], pos[1]\\n            while x < m and y < n:\\n                tmp.append(grid[x][y])\\n                x += 1\\n                y += 1\\n\\n            dif = getDiff(tmp)\\n            x, y = pos[0], pos[1]\\n            count = 0\\n            while x < m and y < n:\\n                ans[x][y] = dif[count]\\n                x += 1\\n                y += 1\\n                count += 1\\n        for j in range(n):\\n            extend([0,j])\\n        for i in range(1,m):\\n            extend([i,0])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        def getDiff(nums):\\n            lSet = set()\\n            rSet = set()\\n            l = [0] * len(nums)\\n            r = [0] * len(nums)\\n            for i in range(1, len(nums)):\\n                lSet.add(nums[i-1])\\n                l[i] = len(lSet)\\n                \\n                j = len(nums) - 1 - i\\n                rSet.add(nums[j+1])\\n                r[j] = len(rSet)\\n            return [abs(l[i]-r[i]) for i in range(len(nums))]\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = [[0]*n for _ in range(m)]\\n        def extend(pos):\\n            nonlocal ans\\n            tmp = []\\n            x, y = pos[0], pos[1]\\n            while x < m and y < n:\\n                tmp.append(grid[x][y])\\n                x += 1\\n                y += 1\\n\\n            dif = getDiff(tmp)\\n            x, y = pos[0], pos[1]\\n            count = 0\\n            while x < m and y < n:\\n                ans[x][y] = dif[count]\\n                x += 1\\n                y += 1\\n                count += 1\\n        for j in range(n):\\n            extend([0,j])\\n        for i in range(1,m):\\n            extend([i,0])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860825,
                "title": "js-iterative-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each diagonal, we compute a set of all the values that appear. Then, we loop over the diagonal, building the values we\\'ve seen so far. At each point, we store the difference of the size of those sets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to run for each diagonal, which means running once for each row and each column. The only tricky part is that we need to remove from the \\'suffix\\' set of numbers as we loop over a diagonal the second time. However, we can\\'t simply delete numbers we encounter from the set - because there might be more than one. So, we need to use a map, where the value is the number of occurrences.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(min(n,m))$$ - set to store the diagonal\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar differenceOfDistinctValues = function(grid) {\\n    for(let i = 0; i < grid.length; ++i) {\\n        computeDiag(grid, i, 0);\\n    }\\n    for(let i = 1; i < grid[0].length; ++i) {\\n        computeDiag(grid, 0, i);\\n    }\\n\\n    return grid;\\n};\\n\\nfunction computeDiag(grid, row, col) {\\n    let suffix = new Map();\\n\\n    let count = Math.min(grid.length-row, grid[0].length-col);\\n\\n    for(let i = 0; i < count; ++i) {\\n        let val = grid[row+i][col+i];\\n        suffix.set(val, (suffix.get(val)??0)+1);\\n    }\\n\\n    let prefix = new Set();\\n    for(let i = 0; i < count; ++i) {\\n        let val = grid[row+i][col+i];\\n        if(suffix.get(val) === 1) {\\n            suffix.delete(val);\\n        } else {\\n            suffix.set(val, suffix.get(val)-1);\\n        }\\n\\n        grid[row+i][col+i] = Math.abs(suffix.size - prefix.size);\\n\\n        prefix.add(val);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar differenceOfDistinctValues = function(grid) {\\n    for(let i = 0; i < grid.length; ++i) {\\n        computeDiag(grid, i, 0);\\n    }\\n    for(let i = 1; i < grid[0].length; ++i) {\\n        computeDiag(grid, 0, i);\\n    }\\n\\n    return grid;\\n};\\n\\nfunction computeDiag(grid, row, col) {\\n    let suffix = new Map();\\n\\n    let count = Math.min(grid.length-row, grid[0].length-col);\\n\\n    for(let i = 0; i < count; ++i) {\\n        let val = grid[row+i][col+i];\\n        suffix.set(val, (suffix.get(val)??0)+1);\\n    }\\n\\n    let prefix = new Set();\\n    for(let i = 0; i < count; ++i) {\\n        let val = grid[row+i][col+i];\\n        if(suffix.get(val) === 1) {\\n            suffix.delete(val);\\n        } else {\\n            suffix.set(val, suffix.get(val)-1);\\n        }\\n\\n        grid[row+i][col+i] = Math.abs(suffix.size - prefix.size);\\n\\n        prefix.add(val);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854126,
                "title": "golang-solution",
                "content": "# Code\\n```go\\nfunc differenceOfDistinctValues(grid [][]int) [][]int {\\n\\ttl, br := make([][]int, len(grid)), make([][]int, len(grid))\\n\\tfor i := range tl {\\n\\t\\ttl[i] =  make([]int, len(grid[0]))\\n\\t\\tbr[i] =  make([]int, len(grid[0]))\\n\\t}\\n\\tfor baseRow := len(grid)-1; baseRow >= 0; baseRow-- {\\n\\t\\thash := make(map[int]int)\\n\\t\\tfor col, row := 0, baseRow; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\ttl[row][col] = len(hash)\\n\\t\\t\\thash[grid[row][col]]++\\n\\t\\t}\\n\\t\\tfor col, row := 0, baseRow; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\thash[grid[row][col]]--\\n\\t\\t\\tif hash[grid[row][col]] == 0 {\\n\\t\\t\\t\\tdelete(hash, grid[row][col])\\n\\t\\t\\t}\\n\\t\\t\\tbr[row][col] = len(hash)\\n\\t\\t}\\n\\t}\\n\\tfor baseCol := 1; baseCol < len(grid[0]); baseCol++ {\\n\\t\\thash := make(map[int]int)\\n\\t\\tfor col, row := baseCol, 0; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\ttl[row][col] = len(hash)\\n\\t\\t\\thash[grid[row][col]]++\\n\\t\\t}\\n\\t\\tfor col, row := baseCol, 0; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\thash[grid[row][col]]--\\n\\t\\t\\tif hash[grid[row][col]] == 0 {\\n\\t\\t\\t\\tdelete(hash, grid[row][col])\\n\\t\\t\\t}\\n\\t\\t\\tbr[row][col] = len(hash)\\n\\t\\t}\\n\\t}\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[r] {\\n\\t\\t\\tgrid[r][c] = abs(tl[r][c] - br[r][c])\\n\\t\\t}\\n\\t}\\n\\treturn grid\\n}\\n\\nfunc abs(x int) int {\\n\\tif x >= 0 {\\n\\t\\treturn x\\n\\t}\\n\\treturn -x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc differenceOfDistinctValues(grid [][]int) [][]int {\\n\\ttl, br := make([][]int, len(grid)), make([][]int, len(grid))\\n\\tfor i := range tl {\\n\\t\\ttl[i] =  make([]int, len(grid[0]))\\n\\t\\tbr[i] =  make([]int, len(grid[0]))\\n\\t}\\n\\tfor baseRow := len(grid)-1; baseRow >= 0; baseRow-- {\\n\\t\\thash := make(map[int]int)\\n\\t\\tfor col, row := 0, baseRow; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\ttl[row][col] = len(hash)\\n\\t\\t\\thash[grid[row][col]]++\\n\\t\\t}\\n\\t\\tfor col, row := 0, baseRow; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\thash[grid[row][col]]--\\n\\t\\t\\tif hash[grid[row][col]] == 0 {\\n\\t\\t\\t\\tdelete(hash, grid[row][col])\\n\\t\\t\\t}\\n\\t\\t\\tbr[row][col] = len(hash)\\n\\t\\t}\\n\\t}\\n\\tfor baseCol := 1; baseCol < len(grid[0]); baseCol++ {\\n\\t\\thash := make(map[int]int)\\n\\t\\tfor col, row := baseCol, 0; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\ttl[row][col] = len(hash)\\n\\t\\t\\thash[grid[row][col]]++\\n\\t\\t}\\n\\t\\tfor col, row := baseCol, 0; col < len(grid[0]) && row < len(grid); col, row = col+1, row+1 {\\n\\t\\t\\thash[grid[row][col]]--\\n\\t\\t\\tif hash[grid[row][col]] == 0 {\\n\\t\\t\\t\\tdelete(hash, grid[row][col])\\n\\t\\t\\t}\\n\\t\\t\\tbr[row][col] = len(hash)\\n\\t\\t}\\n\\t}\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[r] {\\n\\t\\t\\tgrid[r][c] = abs(tl[r][c] - br[r][c])\\n\\t\\t}\\n\\t}\\n\\treturn grid\\n}\\n\\nfunc abs(x int) int {\\n\\tif x >= 0 {\\n\\t\\treturn x\\n\\t}\\n\\treturn -x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834955,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        vector<set<int>> topLeft(m + n - 1), bottomRight(m + n - 1);\\n        for(int i = m - 1; i >= 0; i--) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                temp[i][j] = bottomRight[i + n - j - 1].size();\\n                bottomRight[i + n - j - 1].insert(grid[i][j]);\\n            }\\n        }\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int val = topLeft[i + n - j - 1].size() - temp[i][j];\\n                ans[i][j] = abs(val);\\n                topLeft[i + n - j - 1].insert(grid[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        vector<set<int>> topLeft(m + n - 1), bottomRight(m + n - 1);\\n        for(int i = m - 1; i >= 0; i--) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                temp[i][j] = bottomRight[i + n - j - 1].size();\\n                bottomRight[i + n - j - 1].insert(grid[i][j]);\\n            }\\n        }\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int val = topLeft[i + n - j - 1].size() - temp[i][j];\\n                ans[i][j] = abs(val);\\n                topLeft[i + n - j - 1].insert(grid[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808675,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n             int n=grid.size();\\n             int m=grid[0].size();\\n             vector<vector<int>>ans(n,vector<int>(m,0));\\n             for(int i=0;i<n;i++)\\n             {\\n                 for(int j=0;j<m;j++)\\n                 {\\n                     unordered_set<int>d1;\\n                     unordered_set<int>d2;\\n                     int r=i+1;\\n                     int c=j+1;\\n                     while(r<n and c<m)\\n                     {\\n                         d1.insert(grid[r][c]);\\n                         r++;\\n                         c++;\\n                     }\\n                     r=i-1;\\n                     c=j-1;\\n                     while(r>=0 and c>=0)\\n                     {\\n                         d2.insert(grid[r][c]);\\n                         r--;\\n                         c--;\\n                     }\\n                      ans[i][j] = abs(static_cast<int>(d1.size() - d2.size()));\\n                 }\\n             }\\n             return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n             int n=grid.size();\\n             int m=grid[0].size();\\n             vector<vector<int>>ans(n,vector<int>(m,0));\\n             for(int i=0;i<n;i++)\\n             {\\n                 for(int j=0;j<m;j++)\\n                 {\\n                     unordered_set<int>d1;\\n                     unordered_set<int>d2;\\n                     int r=i+1;\\n                     int c=j+1;\\n                     while(r<n and c<m)\\n                     {\\n                         d1.insert(grid[r][c]);\\n                         r++;\\n                         c++;\\n                     }\\n                     r=i-1;\\n                     c=j-1;\\n                     while(r>=0 and c>=0)\\n                     {\\n                         d2.insert(grid[r][c]);\\n                         r--;\\n                         c--;\\n                     }\\n                      ans[i][j] = abs(static_cast<int>(d1.size() - d2.size()));\\n                 }\\n             }\\n             return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761794,
                "title": "easy-clean-c-solution",
                "content": "# Intuition\\nGo through each side and move from the corner to the other end\\n\\n# Approach\\nStart from the vertice on top and right edge then move to bottom right to count the top left frequency, then start from vertice on bottom and right edge to top left and calculate the absolute value on the go\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(mn)\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& ret, int m, int n) {\\n        vector<bool> dict(50, 0);\\n        int ct = 0;\\n        for (int x = i, y = j; x + 1 < m && y + 1 < n; ++x, ++y) {\\n            if (!dict[grid[x][y]]) {\\n                ++ct;\\n                dict[grid[x][y]] = 1;\\n            }\\n            ret[x + 1][y + 1] = ct;\\n        }\\n    }\\n    void g(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& ret, int m, int n) {\\n        vector<bool> dict(50, 0);\\n        int ct = 0;\\n        for (int x = i, y = j; x >= 1 && y >= 1; --x, --y) {\\n            if (!dict[grid[x][y]]) {\\n                ++ct;\\n                dict[grid[x][y]] = 1;\\n            }\\n            ret[x - 1][y - 1] = abs(ret[x - 1][y - 1] - ct);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ret(m, vector<int>(n, 0));\\n        // do tl\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n && (i == 0 || j == 0); ++j) {\\n                f(i, j, grid, ret, m, n);\\n            }\\n        }\\n        // do br\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = n - 1; j >= 0 && (i == m - 1 || j == n - 1); --j) {\\n                g(i, j, grid, ret, m, n);\\n            }\\n        }\\n        // return\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& ret, int m, int n) {\\n        vector<bool> dict(50, 0);\\n        int ct = 0;\\n        for (int x = i, y = j; x + 1 < m && y + 1 < n; ++x, ++y) {\\n            if (!dict[grid[x][y]]) {\\n                ++ct;\\n                dict[grid[x][y]] = 1;\\n            }\\n            ret[x + 1][y + 1] = ct;\\n        }\\n    }\\n    void g(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& ret, int m, int n) {\\n        vector<bool> dict(50, 0);\\n        int ct = 0;\\n        for (int x = i, y = j; x >= 1 && y >= 1; --x, --y) {\\n            if (!dict[grid[x][y]]) {\\n                ++ct;\\n                dict[grid[x][y]] = 1;\\n            }\\n            ret[x - 1][y - 1] = abs(ret[x - 1][y - 1] - ct);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ret(m, vector<int>(n, 0));\\n        // do tl\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n && (i == 0 || j == 0); ++j) {\\n                f(i, j, grid, ret, m, n);\\n            }\\n        }\\n        // do br\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = n - 1; j >= 0 && (i == m - 1 || j == n - 1); --j) {\\n                g(i, j, grid, ret, m, n);\\n            }\\n        }\\n        // return\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754937,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func differenceOfDistinctValues(_ grid: [[Int]]) -> [[Int]] {\\n        \\n        func cnt(_ x: Int, _ y: Int, _ dx: Int, _ dy: Int) -> Int {\\n\\n            var x = x + dx\\n            var y = y + dy\\n            var vals = Set<Int>()\\n\\n            while x >= 0, x < grid.count, y >= 0, y < grid[x].count {\\n                vals.insert(grid[x][y])\\n                x += dx\\n                y += dy\\n            }\\n\\n            return vals.count\\n        }\\n\\n        return grid\\n            .indices\\n            .map { i in\\n                grid[i]\\n                    .indices\\n                    .map { j in\\n                        abs(cnt(i, j, -1, -1) - cnt(i, j, 1, 1))\\n                    }\\n            }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func differenceOfDistinctValues(_ grid: [[Int]]) -> [[Int]] {\\n        \\n        func cnt(_ x: Int, _ y: Int, _ dx: Int, _ dy: Int) -> Int {\\n\\n            var x = x + dx\\n            var y = y + dy\\n            var vals = Set<Int>()\\n\\n            while x >= 0, x < grid.count, y >= 0, y < grid[x].count {\\n                vals.insert(grid[x][y])\\n                x += dx\\n                y += dy\\n            }\\n\\n            return vals.count\\n        }\\n\\n        return grid\\n            .indices\\n            .map { i in\\n                grid[i]\\n                    .indices\\n                    .map { j in\\n                        abs(cnt(i, j, -1, -1) - cnt(i, j, 1, 1))\\n                    }\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754489,
                "title": "intuition-based-set",
                "content": "# Intuition\\n- Just focus on how upper and lower diagonal in being defined. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n          vector<int>temp;\\n          for(int j=0;j<m;j++)\\n          {\\n            int x=i-1;\\n            int y=j-1;\\n            set<int>lb;\\n            set<int>up;\\n            while(x>-1 && y>-1)\\n            {\\n                up.insert(grid[x--][y--]);\\n            }\\n            x=i+1;\\n            y=j+1;\\n            while(x<n && y<m)\\n            {\\n              lb.insert(grid[x++][y++]);\\n            }\\n            int val=max(lb.size(),up.size())-min(lb.size(),up.size());\\n            temp.push_back(val);\\n          }\\n          ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n          vector<int>temp;\\n          for(int j=0;j<m;j++)\\n          {\\n            int x=i-1;\\n            int y=j-1;\\n            set<int>lb;\\n            set<int>up;\\n            while(x>-1 && y>-1)\\n            {\\n                up.insert(grid[x--][y--]);\\n            }\\n            x=i+1;\\n            y=j+1;\\n            while(x<n && y<m)\\n            {\\n              lb.insert(grid[x++][y++]);\\n            }\\n            int val=max(lb.size(),up.size())-min(lb.size(),up.size());\\n            temp.push_back(val);\\n          }\\n          ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753655,
                "title": "beats-99-in-time-and-space-o-m-n-solution-iterating-once-for-top-left-bottom-right-diagonals",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>>tops(m,vector<int>(n,0));\\n        vector<vector<int>>bottoms(m,vector<int>(n,0));\\n        bool done = false;\\n\\n        //top left diagonals\\n        int r = m-1,c = 0;\\n        while((r>=0 && c<n)){\\n            bool arr[51] = {false};\\n            memset(arr, false, sizeof(arr));\\n            arr[grid[r][c]] = true;\\n\\n            int ir = r+1,ic = c+1;\\n            int ct = 1;\\n            while(ir<m && ic<n){\\n                tops[ir][ic] = ct;\\n                if(!arr[grid[ir][ic]]){\\n                    ct++;\\n                    arr[grid[ir][ic]] = true;\\n                }\\n                ir++;ic++;\\n            }\\n            if(r==0 && c==0)\\n                done = true;\\n            \\n            if(done)\\n                c++;\\n            else\\n                r--;\\n        }\\n\\n        //bottom right diagonals\\n        r = m-1;c = 0;\\n        done = false;\\n        while((r>=0 && c<n)){\\n            bool arr[51] = {false};\\n            memset(arr, false, sizeof(arr));\\n            arr[grid[r][c]] = true;\\n\\n            int ir = r-1,ic = c-1;\\n            int ct = 1;\\n            while(ir>=0 && ic>=0){\\n                bottoms[ir][ic] = ct;\\n                if(!arr[grid[ir][ic]]){\\n                    ct++;\\n                    arr[grid[ir][ic]] = true;\\n                }\\n                ir--;ic--;\\n            }\\n            if(r==(m-1) && c==(n-1))\\n                done = true;\\n            \\n            if(done)\\n                r--;\\n            else\\n                c++;\\n        }\\n\\n        //taking absolute difference of bottoms and tops\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                tops[i][j] = abs(tops[i][j] - bottoms[i][j]);\\n            \\n        return tops;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>>tops(m,vector<int>(n,0));\\n        vector<vector<int>>bottoms(m,vector<int>(n,0));\\n        bool done = false;\\n\\n        //top left diagonals\\n        int r = m-1,c = 0;\\n        while((r>=0 && c<n)){\\n            bool arr[51] = {false};\\n            memset(arr, false, sizeof(arr));\\n            arr[grid[r][c]] = true;\\n\\n            int ir = r+1,ic = c+1;\\n            int ct = 1;\\n            while(ir<m && ic<n){\\n                tops[ir][ic] = ct;\\n                if(!arr[grid[ir][ic]]){\\n                    ct++;\\n                    arr[grid[ir][ic]] = true;\\n                }\\n                ir++;ic++;\\n            }\\n            if(r==0 && c==0)\\n                done = true;\\n            \\n            if(done)\\n                c++;\\n            else\\n                r--;\\n        }\\n\\n        //bottom right diagonals\\n        r = m-1;c = 0;\\n        done = false;\\n        while((r>=0 && c<n)){\\n            bool arr[51] = {false};\\n            memset(arr, false, sizeof(arr));\\n            arr[grid[r][c]] = true;\\n\\n            int ir = r-1,ic = c-1;\\n            int ct = 1;\\n            while(ir>=0 && ic>=0){\\n                bottoms[ir][ic] = ct;\\n                if(!arr[grid[ir][ic]]){\\n                    ct++;\\n                    arr[grid[ir][ic]] = true;\\n                }\\n                ir--;ic--;\\n            }\\n            if(r==(m-1) && c==(n-1))\\n                done = true;\\n            \\n            if(done)\\n                r--;\\n            else\\n                c++;\\n        }\\n\\n        //taking absolute difference of bottoms and tops\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                tops[i][j] = abs(tops[i][j] - bottoms[i][j]);\\n            \\n        return tops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728963,
                "title": "ok",
                "content": "**time: `O(N*M)`; space: `O(RANGE)`**\\n```\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g)\\n{\\n\\tvector out(size(g), vector(size(g[0]), 0));\\n\\tint m[51]{}, t{};\\n\\tfor(int i{}; i<size(g); ++i)\\n\\t{\\n\\t\\tfor(int j{}, I{i}; I<size(g) and j<size(g[0]); ++I, ++j)\\n\\t\\t\\tout[I][j] = t,\\n\\t\\t\\tt += !m[g[I][j]]++;\\n\\n\\t\\tfor(int j{}, I{i}; I<size(g) and j<size(g[0]); ++I, ++j)\\n\\t\\t\\tt -= !--m[g[I][j]],\\n\\t\\t\\tout[I][j] = abs(out[I][j]-t);\\n\\t}\\n\\n\\tfor(int j{}; j<size(g[0]); ++j)\\n\\t{\\n\\t\\tfor(int i{}, J{j}; i<size(g) and J<size(g[0]); ++i, ++J)\\n\\t\\t\\tout[i][J] = t,\\n\\t\\t\\tt += !m[g[i][J]]++;\\n\\n\\t\\tfor(int i{}, J{j}; i<size(g) and J<size(g[0]); ++i, ++J)\\n\\t\\t\\tt -= !--m[g[i][J]],\\n\\t\\t\\tout[i][J] = abs(out[i][J]-t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g)\\n{\\n\\tvector out(size(g), vector(size(g[0]), 0));\\n\\tint m[51]{}, t{};\\n\\tfor(int i{}; i<size(g); ++i)\\n\\t{\\n\\t\\tfor(int j{}, I{i}; I<size(g) and j<size(g[0]); ++I, ++j)\\n\\t\\t\\tout[I][j] = t,\\n\\t\\t\\tt += !m[g[I][j]]++;\\n\\n\\t\\tfor(int j{}, I{i}; I<size(g) and j<size(g[0]); ++I, ++j)\\n\\t\\t\\tt -= !--m[g[I][j]],\\n\\t\\t\\tout[I][j] = abs(out[I][j]-t);\\n\\t}\\n\\n\\tfor(int j{}; j<size(g[0]); ++j)\\n\\t{\\n\\t\\tfor(int i{}, J{j}; i<size(g) and J<size(g[0]); ++i, ++J)\\n\\t\\t\\tout[i][J] = t,\\n\\t\\t\\tt += !m[g[i][J]]++;\\n\\n\\t\\tfor(int i{}, J{j}; i<size(g) and J<size(g[0]); ++i, ++J)\\n\\t\\t\\tt -= !--m[g[i][J]],\\n\\t\\t\\tout[i][J] = abs(out[i][J]-t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704126,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> ans(m , vector<int> (n));    \\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                set<int> up;\\n                set<int> down;\\n                int r = i-1 , c = j-1;\\n                while (r >= 0 && r < m && c >= 0 && c < n){\\n                    up.insert(grid[r][c]);\\n                    r-- , c--;\\n                }\\n                r = i+1 , c = j+1;\\n                while (r >= 0 && r < m && c >= 0 && c < n){\\n                    down.insert(grid[r][c]);\\n                    r++ , c++;\\n                }\\n                int topLeft = up.size();\\n                int bottomRight = down.size();\\n                ans[i][j] = abs(topLeft - bottomRight);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> ans(m , vector<int> (n));    \\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                set<int> up;\\n                set<int> down;\\n                int r = i-1 , c = j-1;\\n                while (r >= 0 && r < m && c >= 0 && c < n){\\n                    up.insert(grid[r][c]);\\n                    r-- , c--;\\n                }\\n                r = i+1 , c = j+1;\\n                while (r >= 0 && r < m && c >= 0 && c < n){\\n                    down.insert(grid[r][c]);\\n                    r++ , c++;\\n                }\\n                int topLeft = up.size();\\n                int bottomRight = down.size();\\n                ans[i][j] = abs(topLeft - bottomRight);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694509,
                "title": "beats-98-of-the-solution-o-n-m-solution-traversing-all-elements-only-once",
                "content": "# Intuition\\nGet all distinct elements on the digonal initially and keep removing elements from bottom right hashmap as you traverse them and take another hashmap that stores the distinct elements you visit now. that become your top left digonal values\\n\\n# Approach\\n1) Get all distinct elements of the digonal\\n2) Start from top left of the digonal.initially top left hashmap is empty\\n3) Delete the curr element from bottom right hasmap and size become\\nBottom right hasmap.size()-topright hasmap.size();\\n4)Add the curr element to top left digonal\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>mat(grid.size(),vector<int>(grid[0].size()));\\n        for(int i=0;i<grid[0].size();i++){\\n            unordered_map<int,int>mp;\\n            int x=0;\\n            int y=i;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n            x=0;\\n            y=i;\\n            unordered_map<int,int>up;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]--;\\n                if(mp[grid[x][y]]==0){\\n                    mp.erase(grid[x][y]);\\n                }\\n                mat[x][y]=abs((int)mp.size()-(int)up.size());\\n                up[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n        }\\n        for(int i=1;i<grid.size();i++){\\n            int x=i;\\n            int y=0;\\n\\n            unordered_map<int,int>mp;\\n            unordered_map<int,int>up;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n            x=i;\\n            y=0;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]--;\\n                if(mp[grid[x][y]]==0){\\n                    mp.erase(grid[x][y]);\\n                }\\n                mat[x][y]=abs((int)mp.size()-(int)up.size());\\n                up[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>mat(grid.size(),vector<int>(grid[0].size()));\\n        for(int i=0;i<grid[0].size();i++){\\n            unordered_map<int,int>mp;\\n            int x=0;\\n            int y=i;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n            x=0;\\n            y=i;\\n            unordered_map<int,int>up;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]--;\\n                if(mp[grid[x][y]]==0){\\n                    mp.erase(grid[x][y]);\\n                }\\n                mat[x][y]=abs((int)mp.size()-(int)up.size());\\n                up[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n        }\\n        for(int i=1;i<grid.size();i++){\\n            int x=i;\\n            int y=0;\\n\\n            unordered_map<int,int>mp;\\n            unordered_map<int,int>up;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n            x=i;\\n            y=0;\\n            while(x<grid.size()&&y<grid[0].size()){\\n                mp[grid[x][y]]--;\\n                if(mp[grid[x][y]]==0){\\n                    mp.erase(grid[x][y]);\\n                }\\n                mat[x][y]=abs((int)mp.size()-(int)up.size());\\n                up[grid[x][y]]++;\\n                x++;\\n                y++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665517,
                "title": "most-optimized-solution-the-end-faang-set-c-beginner-friendly",
                "content": "# Intuition That is solved by brute force beacause the Constraints are not so big\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Brute Force Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint solve(vector<vector<int>>grid,int i,int j)\\n{\\n    int n=grid.size(),m=grid[0].size();\\n    set<int>st1;\\n    set<int>st2;\\n    int ii=i,jj=j;\\n    while(i>=0 && j>=0)\\n    {\\n        if(i!=ii && j!=jj)\\n        {\\n            st1.insert(grid[i][j]);\\n        }\\n        i--,j--;\\n    }\\n    i=ii,j=jj;\\n    while(i<n && j<m)\\n    {\\n        if(i!=ii && j!=jj)\\n        {\\n            st2.insert(grid[i][j]);\\n        }\\n        i++,j++;\\n    }\\n    if(st1.size()>st2.size())\\n    return st1.size()-st2.size();\\n    else return st2.size()-st1.size();\\n}\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=solve(grid,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nint solve(vector<vector<int>>grid,int i,int j)\\n{\\n    int n=grid.size(),m=grid[0].size();\\n    set<int>st1;\\n    set<int>st2;\\n    int ii=i,jj=j;\\n    while(i>=0 && j>=0)\\n    {\\n        if(i!=ii && j!=jj)\\n        {\\n            st1.insert(grid[i][j]);\\n        }\\n        i--,j--;\\n    }\\n    i=ii,j=jj;\\n    while(i<n && j<m)\\n    {\\n        if(i!=ii && j!=jj)\\n        {\\n            st2.insert(grid[i][j]);\\n        }\\n        i++,j++;\\n    }\\n    if(st1.size()>st2.size())\\n    return st1.size()-st2.size();\\n    else return st2.size()-st1.size();\\n}\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=solve(grid,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655052,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        \\n        int[][] ans = new int[grid.length][grid[0].length];\\n\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\n                HashSet<Integer> lSet = new HashSet<>();\\n                HashSet<Integer> rSet = new HashSet<>();\\n\\n                int k = i-1;\\n                int l = j-1;\\n\\n                while(k>=0 && l>=0){\\n                    lSet.add(grid[k--][l--]);\\n                }\\n\\n                k = i+1;\\n                l = j+1;\\n                \\n                while(k<grid.length && l<grid[0].length){\\n                    rSet.add(grid[k++][l++]);\\n                }\\n                \\n                ans[i][j] = Math.abs(rSet.size()-lSet.size());\\n\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        \\n        int[][] ans = new int[grid.length][grid[0].length];\\n\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\n                HashSet<Integer> lSet = new HashSet<>();\\n                HashSet<Integer> rSet = new HashSet<>();\\n\\n                int k = i-1;\\n                int l = j-1;\\n\\n                while(k>=0 && l>=0){\\n                    lSet.add(grid[k--][l--]);\\n                }\\n\\n                k = i+1;\\n                l = j+1;\\n                \\n                while(k<grid.length && l<grid[0].length){\\n                    rSet.add(grid[k++][l++]);\\n                }\\n                \\n                ans[i][j] = Math.abs(rSet.size()-lSet.size());\\n\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642639,
                "title": "brute-force-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(m^2n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(mn)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    int calc(int grid[][],int r,int c){\\n        Set<Integer> st = new HashSet<>();\\n        for(int i = r - 1,j = c - 1;i >= 0 && j >= 0;--i,--j){\\n            st.add(grid[i][j]);\\n        }\\n        int tmp1 = st.size();\\n        st.clear();\\n        for(int i = r + 1,j = c + 1;i < grid.length && j < grid[0].length;++i,++j){\\n            st.add(grid[i][j]);\\n        }\\n        int tmp2 = st.size();\\n        return Math.abs(tmp1 - tmp2);\\n        \\n    }\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[][] = new int[m][n];\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                ans[i][j] = calc(grid,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    int calc(int grid[][],int r,int c){\\n        Set<Integer> st = new HashSet<>();\\n        for(int i = r - 1,j = c - 1;i >= 0 && j >= 0;--i,--j){\\n            st.add(grid[i][j]);\\n        }\\n        int tmp1 = st.size();\\n        st.clear();\\n        for(int i = r + 1,j = c + 1;i < grid.length && j < grid[0].length;++i,++j){\\n            st.add(grid[i][j]);\\n        }\\n        int tmp2 = st.size();\\n        return Math.abs(tmp1 - tmp2);\\n        \\n    }\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[][] = new int[m][n];\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                ans[i][j] = calc(grid,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636140,
                "title": "python-m-x-n-with-prefix-suffix-sums",
                "content": "This one is in `98%` of the fastest (useless metric)\\n\\nSuch an error prone problem, but with time you get used to such problems.\\n\\nI use `prefix` and `suffix` to calculate diagonal values.\\n\\n```\\ninput:     1 2 3 4 5\\nprefix:    0 1 2 3 4\\nsuffix:    4 3 2 1 0\\nresult:    4 2 0 2 4\\nP[i]-S[i]:\\n```\\n\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        def fill(r, c):\\n            cr = r\\n            cc = c\\n            DIAG_LEN = min(ROWS - r, COLS - c)\\n            prefix = [0] * DIAG_LEN\\n            prefix_set = set()\\n            suffix = [0] * DIAG_LEN\\n            suffix_set = set()\\n            i = 0\\n            while cr < ROWS and cc < COLS:\\n                prefix[i] = len(prefix_set)\\n                prefix_set.add(grid[cr][cc])\\n                suffix[DIAG_LEN - 1 - i] = len(suffix_set)\\n                suffix_set.add(grid[ROWS - 1 - cr][COLS - 1 - cc])\\n                cr += 1\\n                cc += 1\\n                i += 1\\n\\n            cr = r\\n            cc = c\\n            i = 0\\n            while cr < ROWS and cc < COLS:\\n                res[cr][cc] = abs(prefix[i] - suffix[i])\\n                i += 1\\n                cr += 1\\n                cc += 1\\n            \\n        ROWS, COLS = len(grid),len(grid[0])\\n        res = [[0] * COLS for _ in range(ROWS)]\\n        for r in reversed(range(ROWS)):\\n            fill(r, 0)\\n        for c in range(1, COLS):\\n            fill(0, c)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\ninput:     1 2 3 4 5\\nprefix:    0 1 2 3 4\\nsuffix:    4 3 2 1 0\\nresult:    4 2 0 2 4\\nP[i]-S[i]:\\n```\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        def fill(r, c):\\n            cr = r\\n            cc = c\\n            DIAG_LEN = min(ROWS - r, COLS - c)\\n            prefix = [0] * DIAG_LEN\\n            prefix_set = set()\\n            suffix = [0] * DIAG_LEN\\n            suffix_set = set()\\n            i = 0\\n            while cr < ROWS and cc < COLS:\\n                prefix[i] = len(prefix_set)\\n                prefix_set.add(grid[cr][cc])\\n                suffix[DIAG_LEN - 1 - i] = len(suffix_set)\\n                suffix_set.add(grid[ROWS - 1 - cr][COLS - 1 - cc])\\n                cr += 1\\n                cc += 1\\n                i += 1\\n\\n            cr = r\\n            cc = c\\n            i = 0\\n            while cr < ROWS and cc < COLS:\\n                res[cr][cc] = abs(prefix[i] - suffix[i])\\n                i += 1\\n                cr += 1\\n                cc += 1\\n            \\n        ROWS, COLS = len(grid),len(grid[0])\\n        res = [[0] * COLS for _ in range(ROWS)]\\n        for r in reversed(range(ROWS)):\\n            fill(r, 0)\\n        for c in range(1, COLS):\\n            fill(0, c)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621707,
                "title": "python-solution-prefix-and-suffix-of-diagonal-elements",
                "content": "# Intuition\\nEach diagonal can be considered as a linear array, thus the problem can be reduced to finding the number of unique elements before and after current element which can be solved by constructing prefix and suffix arrays\\n\\n# Approach\\nThe picture below shows the sample `grid` array and the diagonals that link its elements. Current element is shown with red dot, the elements of its top-left and bottom-right diagonals are showh  with blue and pink background, respectively.<br>\\n![2711sol.png](https://assets.leetcode.com/users/images/579174cb-70e6-40cf-82f4-7dfdb271d8b6_1686397603.6866615.png)\\n\\n\\nFor the elements in particular diagonal the obvious solution is to get number of unique elements before (prefix) and after (suffix) the particular element of the diagonal and then use this information to calculate the answer as `ans[i][j] = abs(pref[i][j] - suff[i][j])`. To store the prefixes and suffixes we create two matrices `pref` and `suff` of `m x n` size and initialize them with `0`\\n\\nNow, we have two questions:\\n1. how to identify the diagonal to which `grid[i][j]` belongs to?\\nAll elements in the diagonal have the same `(i-j)` value, so we can create a dictionary `diags` where for `(i-j)` key the traversed elements of this diagonal will be stored\\n\\n2. how to find number of unique elements in the diagonal in front of current `grid[i][j]`?\\nThe traversed elements of the diagonal can be added to a `set` (which does not add duplicates if correspondent element is already present in a set). Thus our dictionary `diags` will map key of a diagonal `(i-j)` to the set of elements in this diagonal that were already traversed.\\n\\nFor calculating `pref` we iterate over all `grid` elements, assign `pref[i][j] = len(diags[i-j])` and then add `grid[i][j]` to `diags[i-j]` set. The `suff` is calculated in same manner, but we need to reset `diags` first, and then to iterate over `grid` elements backwards.\\n\\nAs soon as `suff[i][j]` is calculated we can get the answer for current element, so we do not need additional loops to construct the answer. Moreover, we can use `grid` matrix itself to store the result.\\n\\n# Complexity\\n- Time complexity: `O(m x n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(m x n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        diags: DefaultDict[int, Set[int]] = defaultdict(set)\\n        m, n = len(grid), len(grid[0])\\n        pref = [[0] * n for _ in range(m)]\\n        suff = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                pref[i][j] = len(diags[i-j])\\n                diags[i-j].add(grid[i][j])\\n        \\n        diags = defaultdict(set)\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                suff[i][j] = len(diags[i-j])\\n                diags[i-j].add(grid[i][j])\\n                grid[i][j] = abs(pref[i][j] - suff[i][j])\\n        \\n        return grid\\n    # end differenceOfDistinctValues(...)\\n```\\n\\nWe may note that we do not actually need `suff`, as we can reuse `pref[i][j]` to store the result of `abs(pref[i][j] - len(diags[i-j]))`. Then the suffix calculation part will look as:\\n```python\\nfor i in range(m-1, -1, -1):\\n        for j in range(n-1, -1, -1):\\n            pref[i][j] = abs(pref[i][j] - len(diags[i-j]))\\n            diags[i-j].add(grid[i][j])\\n\\n    return pref\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        diags: DefaultDict[int, Set[int]] = defaultdict(set)\\n        m, n = len(grid), len(grid[0])\\n        pref = [[0] * n for _ in range(m)]\\n        suff = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                pref[i][j] = len(diags[i-j])\\n                diags[i-j].add(grid[i][j])\\n        \\n        diags = defaultdict(set)\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                suff[i][j] = len(diags[i-j])\\n                diags[i-j].add(grid[i][j])\\n                grid[i][j] = abs(pref[i][j] - suff[i][j])\\n        \\n        return grid\\n    # end differenceOfDistinctValues(...)\\n```\n```python\\nfor i in range(m-1, -1, -1):\\n        for j in range(n-1, -1, -1):\\n            pref[i][j] = abs(pref[i][j] - len(diags[i-j]))\\n            diags[i-j].add(grid[i][j])\\n\\n    return pref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621116,
                "title": "c-set-easy-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                unordered_set<int>s1;\\n                unordered_set<int>s2;\\n                int r=i-1;\\n                int c=j-1;\\n                while(r>=0 and c>=0)\\n                {\\n                    s1.insert(grid[r][c]);\\n                    r--;\\n                    c--;\\n                }\\n                r=i+1;\\n                c=j+1;\\n                while(r<m and c<n)\\n                {\\n                    s2.insert(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n                ans[i][j]=abs((int)s1.size()-(int)s2.size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                unordered_set<int>s1;\\n                unordered_set<int>s2;\\n                int r=i-1;\\n                int c=j-1;\\n                while(r>=0 and c>=0)\\n                {\\n                    s1.insert(grid[r][c]);\\n                    r--;\\n                    c--;\\n                }\\n                r=i+1;\\n                c=j+1;\\n                while(r<m and c<n)\\n                {\\n                    s2.insert(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n                ans[i][j]=abs((int)s1.size()-(int)s2.size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619567,
                "title": "j",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n= grid[0].size();\\n        vector<vector<int>> left(m, vector<int>(n, 0));\\n        vector<vector<int>> right(m, vector<int>(n, 0));\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        \\n        int r = 0, c = n-1;\\n        for(int i=0; i<m+n-3; i++){\\n            if(r==0&&c>0){\\n                c--;\\n            }\\n            else{\\n                c=0;\\n                r++;\\n            }\\n            \\n            cout<<r<<\" \"<<c<<endl;\\n            int countl = 0;\\n            int countr = 0;\\n            unordered_set<int> mySetl;\\n            unordered_set<int> mySetr;\\n            while(r+1>=0 && c+1>=0 && r+1<m && c+1<n){\\n                if(mySetl.find(grid[r][c])==mySetl.end()){\\n                    countl++;\\n                    mySetl.insert(grid[r][c]);\\n                }\\n                r++;\\n                c++;\\n                left[r][c] = countl;\\n            }\\n            cout<<r<<\"end1 \"<<c<<endl;\\n           while(r-1>=0 && c-1>=0 && r-1<m && c-1<n){\\n               \\n            if(mySetr.find(grid[r][c])==mySetr.end()){\\n                countr++;\\n                mySetr.insert(grid[r][c]);\\n            }\\n            r--;\\n            c--;\\n            right[r][c] = countr;\\n           }       \\n           cout<<r<<\"end \"<<c<<endl;\\n        }\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                ans[i][j] = abs(left[i][j]-right[i][j]);\\n            }\\n            \\n        }\\n            \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n= grid[0].size();\\n        vector<vector<int>> left(m, vector<int>(n, 0));\\n        vector<vector<int>> right(m, vector<int>(n, 0));\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        \\n        int r = 0, c = n-1;\\n        for(int i=0; i<m+n-3; i++){\\n            if(r==0&&c>0){\\n                c--;\\n            }\\n            else{\\n                c=0;\\n                r++;\\n            }\\n            \\n            cout<<r<<\" \"<<c<<endl;\\n            int countl = 0;\\n            int countr = 0;\\n            unordered_set<int> mySetl;\\n            unordered_set<int> mySetr;\\n            while(r+1>=0 && c+1>=0 && r+1<m && c+1<n){\\n                if(mySetl.find(grid[r][c])==mySetl.end()){\\n                    countl++;\\n                    mySetl.insert(grid[r][c]);\\n                }\\n                r++;\\n                c++;\\n                left[r][c] = countl;\\n            }\\n            cout<<r<<\"end1 \"<<c<<endl;\\n           while(r-1>=0 && c-1>=0 && r-1<m && c-1<n){\\n               \\n            if(mySetr.find(grid[r][c])==mySetr.end()){\\n                countr++;\\n                mySetr.insert(grid[r][c]);\\n            }\\n            r--;\\n            c--;\\n            right[r][c] = countr;\\n           }       \\n           cout<<r<<\"end \"<<c<<endl;\\n        }\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                ans[i][j] = abs(left[i][j]-right[i][j]);\\n            }\\n            \\n        }\\n            \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3618922,
                "title": "n2-time-complexity-solution-cpp",
                "content": "It might be little bit lengthy but we will do it in n2 TC and n2 SC, just traverse all the boundaries and update topleft and BottomRight matrix .\\nExplanation: The given code calculates the absolute difference of distinct values in diagonals of a given matrix. \\n\\nIt initializes three matrices: `leftTop`, `rightBottom`, and `ans` with dimensions `m` rows and `n` columns.\\n\\nThe code then calculates the `leftTop` matrix by iterating over each row and column of the matrix. It keeps track of distinct elements encountered in each diagonal using an `unordered_set`. If an element is distinct, it increments the count in the `leftTop` matrix, and if it is not distinct, it copies the count from the previous diagonal element.\\n\\nSimilarly, the code calculates the `rightBottom` matrix by iterating over each column and row of the matrix. It also keeps track of distinct elements encountered in each diagonal using an `unordered_set`.\\n\\nFinally, the code calculates the absolute difference of counts for each element by iterating over the matrix. It retrieves the counts from the `leftTop` and `rightBottom` matrices and stores the absolute difference in the `ans` matrix.\\n\\nThe `ans` matrix represents the absolute difference of distinct values in the diagonals of the input matrix.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n        int m = g.size(), n = g[0].size();\\n        vector<vector<int>> leftTop(m, vector<int> (n, 0));\\n        vector<vector<int>> rightBottom(m, vector<int> (n, 0));\\n        vector<vector<int>> ans(m, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = i, c = 0; r < m && c < n; r++, c++)\\n            {\\n                if(c == 0 || r == 0)\\n                {\\n                    leftTop[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    leftTop[r][c] = 1 + leftTop[r-1][c-1];\\n                     disElements.insert(g[r][c]);   \\n                }\\n                else \\n                    leftTop[r][c] = leftTop[r-1][c-1];\\n                \\n            }\\n        }\\n        \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = 0, c = i; r < m && c < n; r++, c++)\\n            {\\n                if(c == 0 || r == 0)\\n                {\\n                    leftTop[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    leftTop[r][c] = 1 + leftTop[r-1][c-1];\\n                    disElements.insert(g[r][c]);    \\n                }\\n                else\\n                    leftTop[r][c] = leftTop[r-1][c-1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = i, c = n - 1; r >= 0 && c >=0 ; r--, c--)\\n            {\\n                if(c == n - 1 || r == m - 1)\\n                {\\n                    rightBottom[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    rightBottom[r][c] = 1 + rightBottom[r+1][c+1];\\n                    disElements.insert(g[r][c]);   \\n                }\\n                else \\n                    rightBottom[r][c] = rightBottom[r+1][c+1];\\n                \\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = m - 1, c = i; c >= 0 && r >=0 ; r--, c--)\\n            {\\n                if(c == n - 1 || r == m - 1)\\n                {\\n                    rightBottom[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    rightBottom[r][c] = 1 + rightBottom[r+1][c+1];\\n                    disElements.insert(g[r][c]);    \\n                }\\n                else\\n                    rightBottom[r][c] = rightBottom[r+1][c+1];\\n                \\n            }\\n        }\\n        \\n        for(int i =0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int left = 0, right = 0;\\n                \\n                if(i > 0 && j > 0)\\n                    left = leftTop[i-1][j-1];\\n                \\n                if(i < m - 1 && j < n - 1)\\n                    right = rightBottom[i+1][j+1];\\n                \\n                ans[i][j] = abs(left - right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/0b9bcaf5-d39a-46ab-9317-35f06795e2de_1686340981.7012918.png)\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n        int m = g.size(), n = g[0].size();\\n        vector<vector<int>> leftTop(m, vector<int> (n, 0));\\n        vector<vector<int>> rightBottom(m, vector<int> (n, 0));\\n        vector<vector<int>> ans(m, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = i, c = 0; r < m && c < n; r++, c++)\\n            {\\n                if(c == 0 || r == 0)\\n                {\\n                    leftTop[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    leftTop[r][c] = 1 + leftTop[r-1][c-1];\\n                     disElements.insert(g[r][c]);   \\n                }\\n                else \\n                    leftTop[r][c] = leftTop[r-1][c-1];\\n                \\n            }\\n        }\\n        \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = 0, c = i; r < m && c < n; r++, c++)\\n            {\\n                if(c == 0 || r == 0)\\n                {\\n                    leftTop[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    leftTop[r][c] = 1 + leftTop[r-1][c-1];\\n                    disElements.insert(g[r][c]);    \\n                }\\n                else\\n                    leftTop[r][c] = leftTop[r-1][c-1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = i, c = n - 1; r >= 0 && c >=0 ; r--, c--)\\n            {\\n                if(c == n - 1 || r == m - 1)\\n                {\\n                    rightBottom[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    rightBottom[r][c] = 1 + rightBottom[r+1][c+1];\\n                    disElements.insert(g[r][c]);   \\n                }\\n                else \\n                    rightBottom[r][c] = rightBottom[r+1][c+1];\\n                \\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            unordered_set<int> disElements;\\n            for(int r = m - 1, c = i; c >= 0 && r >=0 ; r--, c--)\\n            {\\n                if(c == n - 1 || r == m - 1)\\n                {\\n                    rightBottom[r][c] = 1;\\n                    disElements.insert(g[r][c]); \\n                    continue;\\n                }\\n                if(disElements.find(g[r][c]) == disElements.end())\\n                {\\n                    rightBottom[r][c] = 1 + rightBottom[r+1][c+1];\\n                    disElements.insert(g[r][c]);    \\n                }\\n                else\\n                    rightBottom[r][c] = rightBottom[r+1][c+1];\\n                \\n            }\\n        }\\n        \\n        for(int i =0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int left = 0, right = 0;\\n                \\n                if(i > 0 && j > 0)\\n                    left = leftTop[i-1][j-1];\\n                \\n                if(i < m - 1 && j < n - 1)\\n                    right = rightBottom[i+1][j+1];\\n                \\n                ans[i][j] = abs(left - right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617732,
                "title": "difference-of-number-of-distinct-values-on-diagonals-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size();\\n    int col= grid[0].size();\\n    \\n    vector<vector<int>> ans(row, vector<int>(col));\\n    \\n    for (int i = 0; i < row; i++) \\n    {\\n        for (int j = 0; j < col; j++) \\n        {\\n            unordered_set<int> left;\\n            unordered_set<int> right;\\n            \\n            int r = i - 1;\\n            int c = j - 1;\\n            while (r >= 0 && c >= 0) \\n            {  \\n                left.insert(grid[r--][c--]); \\n            }\\n            \\n            r = i + 1;\\n            c = j + 1;\\n            while (r < row && c < col) \\n            {      \\n                right.insert(grid[r++][c++]);   \\n            }\\n            int topleftdiagonal_distinct=left.size();\\n            int rightBottomdiagonal_distinct=right.size();\\n            \\n            ans[i][j] = abs(topleftdiagonal_distinct-rightBottomdiagonal_distinct);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size();\\n    int col= grid[0].size();\\n    \\n    vector<vector<int>> ans(row, vector<int>(col));\\n    \\n    for (int i = 0; i < row; i++) \\n    {\\n        for (int j = 0; j < col; j++) \\n        {\\n            unordered_set<int> left;\\n            unordered_set<int> right;\\n            \\n            int r = i - 1;\\n            int c = j - 1;\\n            while (r >= 0 && c >= 0) \\n            {  \\n                left.insert(grid[r--][c--]); \\n            }\\n            \\n            r = i + 1;\\n            c = j + 1;\\n            while (r < row && c < col) \\n            {      \\n                right.insert(grid[r++][c++]);   \\n            }\\n            int topleftdiagonal_distinct=left.size();\\n            int rightBottomdiagonal_distinct=right.size();\\n            \\n            ans[i][j] = abs(topleftdiagonal_distinct-rightBottomdiagonal_distinct);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614622,
                "title": "a-good-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <unordered_set>\\nclass Solution {\\npublic:\\n    int CountUnique(vector<vector<int>> &grid, int row, int column){\\n        unordered_set<int> TopLeft;\\n        unordered_set<int> BottomRight;\\n        \\n        \\n        int count_left = 0;\\n        int count_right = 0;\\n\\n        //For Top Left\\n        int r = row - 1;\\n        int c = column - 1;\\n                    cout << \"Top Left: \" << \" \";\\n        while(r >= 0 && c >= 0){\\n            if(TopLeft.find(grid[r][c]) == TopLeft.end()){\\n                count_left++;\\n                TopLeft.insert(grid[r][c]);\\n                cout << grid[r][c] << \" \";\\n            }\\n            r--;\\n            c--;\\n        }\\n        cout << endl << \"Bottom Right: \" << \" \";\\n        // For Bottom Right\\n        r = row + 1;\\n        c = column + 1;\\n        while(r < grid.size() && c < grid[0].size()){\\n            if(BottomRight.find(grid[r][c]) == BottomRight.end()){\\n                count_right++;\\n                BottomRight.insert(grid[r][c]);\\n            }\\n            r++;\\n            c++;\\n        }\\n        cout << endl;\\n        cout << \"left count: \" << count_left << endl;\\n        cout << \"right count: \" << count_right << endl;\\n        cout << \"Answer for cell: \" << abs(count_left - count_right) << endl;\\n        return abs(count_left - count_right);\\n    };\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>> OutputArr;\\n        for(vector<int> row : grid){\\n            OutputArr.push_back(row);\\n        }\\n        for(int r=0; r<grid.size(); r++){\\n            for(int c=0; c<grid[0].size(); c++){\\n                OutputArr[r][c] = CountUnique(grid, r, c);\\n            }\\n        }\\n        \\n        return OutputArr;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <unordered_set>\\nclass Solution {\\npublic:\\n    int CountUnique(vector<vector<int>> &grid, int row, int column){\\n        unordered_set<int> TopLeft;\\n        unordered_set<int> BottomRight;\\n        \\n        \\n        int count_left = 0;\\n        int count_right = 0;\\n\\n        //For Top Left\\n        int r = row - 1;\\n        int c = column - 1;\\n                    cout << \"Top Left: \" << \" \";\\n        while(r >= 0 && c >= 0){\\n            if(TopLeft.find(grid[r][c]) == TopLeft.end()){\\n                count_left++;\\n                TopLeft.insert(grid[r][c]);\\n                cout << grid[r][c] << \" \";\\n            }\\n            r--;\\n            c--;\\n        }\\n        cout << endl << \"Bottom Right: \" << \" \";\\n        // For Bottom Right\\n        r = row + 1;\\n        c = column + 1;\\n        while(r < grid.size() && c < grid[0].size()){\\n            if(BottomRight.find(grid[r][c]) == BottomRight.end()){\\n                count_right++;\\n                BottomRight.insert(grid[r][c]);\\n            }\\n            r++;\\n            c++;\\n        }\\n        cout << endl;\\n        cout << \"left count: \" << count_left << endl;\\n        cout << \"right count: \" << count_right << endl;\\n        cout << \"Answer for cell: \" << abs(count_left - count_right) << endl;\\n        return abs(count_left - count_right);\\n    };\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>> OutputArr;\\n        for(vector<int> row : grid){\\n            OutputArr.push_back(row);\\n        }\\n        for(int r=0; r<grid.size(); r++){\\n            for(int c=0; c<grid[0].size(); c++){\\n                OutputArr[r][c] = CountUnique(grid, r, c);\\n            }\\n        }\\n        \\n        return OutputArr;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3609859,
                "title": "c-diagonal-iteration-of-the-grid-m-n-time-complexity-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n,0));\\n        unordered_map<int,int> topleft;\\n        unordered_map<int,int> bottomRight;\\n\\n        auto l = [&](int cr,int cc){\\n            int i=cr,j=cc;\\n            topleft.clear();\\n            bottomRight.clear();\\n            while(cr<m && cc<n){\\n                bottomRight[grid[cr][cc]]++;\\n                cr++;\\n                cc++;\\n            }\\n            cr=i,cc=j;\\n            while(cr<m && cc<n){\\n                bottomRight[grid[cr][cc]]--;\\n                if (bottomRight[grid[cr][cc]]==0){\\n                    bottomRight.erase(grid[cr][cc]);\\n                }\\n                ans[cr][cc] = std::abs((int)bottomRight.size()-(int)topleft.size());\\n                \\n                topleft[grid[cr][cc]]++;\\n                cr++;\\n                cc++;\\n                \\n            }\\n        };\\n        for(int i=0;i<m;i++){\\n            l(i,0);\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            l(0,i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nTime complexity: O(m*n)\\nm = number of rows in the grid\\nn= number of cols in the grid",
                "solutionTags": [
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n,0));\\n        unordered_map<int,int> topleft;\\n        unordered_map<int,int> bottomRight;\\n\\n        auto l = [&](int cr,int cc){\\n            int i=cr,j=cc;\\n            topleft.clear();\\n            bottomRight.clear();\\n            while(cr<m && cc<n){\\n                bottomRight[grid[cr][cc]]++;\\n                cr++;\\n                cc++;\\n            }\\n            cr=i,cc=j;\\n            while(cr<m && cc<n){\\n                bottomRight[grid[cr][cc]]--;\\n                if (bottomRight[grid[cr][cc]]==0){\\n                    bottomRight.erase(grid[cr][cc]);\\n                }\\n                ans[cr][cc] = std::abs((int)bottomRight.size()-(int)topleft.size());\\n                \\n                topleft[grid[cr][cc]]++;\\n                cr++;\\n                cc++;\\n                \\n            }\\n        };\\n        for(int i=0;i<m;i++){\\n            l(i,0);\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            l(0,i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606869,
                "title": "java-commented-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] answer = new int[m][n];\\n        \\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                Set<Integer> topLeft = new HashSet<>();\\n                Set<Integer> bottomRight = new HashSet<>();\\n                \\n                // Calculate distinct values in top-left diagonal\\n                for (int i = 0; i < r; i++) {\\n                    int j = c - (r - i);\\n                    if (j >= 0) {\\n                        topLeft.add(grid[i][j]);\\n                    }\\n                }\\n                \\n                // Calculate distinct values in bottom-right diagonal\\n                for (int i = r + 1; i < m; i++) {\\n                    int j = c + (i - r);\\n                    if (j < n) {\\n                        bottomRight.add(grid[i][j]);\\n                    }\\n                }\\n                \\n                // Calculate answer for current cell\\n                answer[r][c] = Math.abs(topLeft.size() - bottomRight.size());\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] answer = new int[m][n];\\n        \\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                Set<Integer> topLeft = new HashSet<>();\\n                Set<Integer> bottomRight = new HashSet<>();\\n                \\n                // Calculate distinct values in top-left diagonal\\n                for (int i = 0; i < r; i++) {\\n                    int j = c - (r - i);\\n                    if (j >= 0) {\\n                        topLeft.add(grid[i][j]);\\n                    }\\n                }\\n                \\n                // Calculate distinct values in bottom-right diagonal\\n                for (int i = r + 1; i < m; i++) {\\n                    int j = c + (i - r);\\n                    if (j < n) {\\n                        bottomRight.add(grid[i][j]);\\n                    }\\n                }\\n                \\n                // Calculate answer for current cell\\n                answer[r][c] = Math.abs(topLeft.size() - bottomRight.size());\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603410,
                "title": "c-easy-simple-solution-must-see",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: --> \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,0)); // resultant vector\\n        for(int i=0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                set<int> s; // create set to count distinct element\\n                for(int x = i-1, y = j-1; x>=0 && y>=0; x--, y--) s.insert(grid[x][y]);\\n                int topleft = s.size();\\n                s.clear(); // clear set to reuse\\n                for(int x = i+1, y = j+1; x<m && y <n; x++, y++) s.insert(grid[x][y]);\\n                int bottomright = s.size();\\n                res[i][j] = abs(topleft - bottomright);\\n            }\\n        }\\n        return res;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,0)); // resultant vector\\n        for(int i=0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                set<int> s; // create set to count distinct element\\n                for(int x = i-1, y = j-1; x>=0 && y>=0; x--, y--) s.insert(grid[x][y]);\\n                int topleft = s.size();\\n                s.clear(); // clear set to reuse\\n                for(int x = i+1, y = j+1; x<m && y <n; x++, y++) s.insert(grid[x][y]);\\n                int bottomright = s.size();\\n                res[i][j] = abs(topleft - bottomright);\\n            }\\n        }\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596415,
                "title": "ez-java-82-runtime-beats-99-7-memory-beats",
                "content": "# Complexity\\n- Time complexity:\\nO(m * n * (m + n)) \\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n       HashSet<Integer> tl = new HashSet<>();\\n       HashSet<Integer> br = new HashSet<>();\\n\\n\\n        int row, col;\\n\\n        int [][]ans=new int [n][m];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\n                row=i+1; col=j+1;\\n\\n                while(row>=0 && col>=0 && row<n && col<m){\\n                    br.add(grid[row][col]); row++; col++;\\n                }\\n\\n                row=i-1; col=j-1;\\n                while(row>=0 && col>=0 && row<n && col<m){\\n                     tl.add(grid[row][col]); row--; col--;\\n                }\\n\\n                ans[i][j]=Math.abs(tl.size()-br.size());\\n                tl.clear(); br.clear();\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n       HashSet<Integer> tl = new HashSet<>();\\n       HashSet<Integer> br = new HashSet<>();\\n\\n\\n        int row, col;\\n\\n        int [][]ans=new int [n][m];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\n                row=i+1; col=j+1;\\n\\n                while(row>=0 && col>=0 && row<n && col<m){\\n                    br.add(grid[row][col]); row++; col++;\\n                }\\n\\n                row=i-1; col=j-1;\\n                while(row>=0 && col>=0 && row<n && col<m){\\n                     tl.add(grid[row][col]); row--; col--;\\n                }\\n\\n                ans[i][j]=Math.abs(tl.size()-br.size());\\n                tl.clear(); br.clear();\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596000,
                "title": "grid-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(int x , int y, int ele, vector<vector<int>>& grid)\\n    {\\n        int a = x; \\n        int b = y;\\n        set<int>left;\\n        set<int>right; \\n        \\n        \\n        if(x==0 and y==0)\\n        {\\n            x++;\\n            y++;\\n            while(x<grid.size() and y<grid[0].size())\\n            {\\n                right.insert(grid[x][y]);\\n                x++;\\n                y++;\\n                \\n            }\\n            return right.size();\\n        }\\n        \\n        if(x==grid.size()-1 and y==grid[0].size()-1)\\n        {\\n            x--;\\n            y--;\\n            while(x>=0 and y>=0)\\n            {\\n                left.insert(grid[x][y]);\\n                x--;\\n                y--;\\n                \\n            }\\n            return left.size();\\n        }\\n        \\n        a--;\\n        b--; \\n        while(a>=0 and b>=0)\\n        {\\n            left.insert(grid[a][b]);\\n            a--;\\n            b--;\\n        }\\n        \\n        x++;\\n        y++;\\n        while(x<grid.size() and y<grid[0].size())\\n        {\\n            right.insert(grid[x][y]);\\n            x++;\\n            y++;\\n        }\\n        \\n        \\n        if(left.size() > right.size())return left.size()-right.size();\\n        return  right.size() - left.size();\\n        \\n        \\n    }\\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m  = grid[0].size();\\n        vector<vector<int>>mat(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ele  = grid[i][j];\\n                int x = i;\\n                int y = j;\\n                mat[i][j] = solve(x ,y , ele, grid) ; \\n            }\\n        }\\n        return  mat ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(int x , int y, int ele, vector<vector<int>>& grid)\\n    {\\n        int a = x; \\n        int b = y;\\n        set<int>left;\\n        set<int>right; \\n        \\n        \\n        if(x==0 and y==0)\\n        {\\n            x++;\\n            y++;\\n            while(x<grid.size() and y<grid[0].size())\\n            {\\n                right.insert(grid[x][y]);\\n                x++;\\n                y++;\\n                \\n            }\\n            return right.size();\\n        }\\n        \\n        if(x==grid.size()-1 and y==grid[0].size()-1)\\n        {\\n            x--;\\n            y--;\\n            while(x>=0 and y>=0)\\n            {\\n                left.insert(grid[x][y]);\\n                x--;\\n                y--;\\n                \\n            }\\n            return left.size();\\n        }\\n        \\n        a--;\\n        b--; \\n        while(a>=0 and b>=0)\\n        {\\n            left.insert(grid[a][b]);\\n            a--;\\n            b--;\\n        }\\n        \\n        x++;\\n        y++;\\n        while(x<grid.size() and y<grid[0].size())\\n        {\\n            right.insert(grid[x][y]);\\n            x++;\\n            y++;\\n        }\\n        \\n        \\n        if(left.size() > right.size())return left.size()-right.size();\\n        return  right.size() - left.size();\\n        \\n        \\n    }\\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m  = grid[0].size();\\n        vector<vector<int>>mat(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ele  = grid[i][j];\\n                int x = i;\\n                int y = j;\\n                mat[i][j] = solve(x ,y , ele, grid) ; \\n            }\\n        }\\n        return  mat ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595597,
                "title": "two-approach-brute-force-to-optimal",
                "content": "### Brute Force\\n\\n```\\n\\tpublic int[][] differenceOfDistinctValues(int[][] nums) {\\n        int[][] result = new int[nums.length][nums[0].length];\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums[i].length; j++) {\\n                result[i][j] = countDistinct(nums, i, j);\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n\\tpublic int countDistinct(int[][] nums, int i, int j) {\\n        Set<Integer> upperSet = new HashSet<>();\\n        Set<Integer> lowerSet = new HashSet<>();\\n        int upperI = i - 1, upperJ = j - 1;\\n        int lowerI = i + 1, lowerJ = j + 1;\\n\\n        while (upperI >= 0 && upperJ >= 0) {\\n            upperSet.add(nums[upperI][upperJ]);\\n            upperJ--;\\n            upperI--;\\n        }\\n        while (lowerI < nums.length && lowerJ < nums[0].length) {\\n            lowerSet.add(nums[lowerI][lowerJ]);\\n            lowerJ++;\\n            lowerI++;\\n        }\\n        return Math.abs(lowerSet.size() - upperSet.size());\\n    }\\n```\\nTC: O(MN * (min(M,N)). Cubic time complexity\\nM = rows, N = columns\\n\\n### Optimal Approach\\n```\\n\\tpublic int[][] countDistinctOptimized(int[][] nums) {\\n        int[][] result = new int[nums.length][nums[0].length];\\n        int rows = nums.length, cols = nums[0].length;\\n\\t\\t\\n\\t\\t// Imagine we fold the 2D array across the longest diagonal which passes between (0,0) and (m - 1, n - 1). We traverse the 2 parts in two different ways as shown in the below two for loops\\t\\t\\n        // populate first half\\n        for (int i = rows - 1; i >= 0; i--) {\\n            populateDiagonal(nums, result, i, 0);\\n        }\\n        //populate second half\\n        for (int j = 1; j < cols; j++) {\\n            populateDiagonal(nums, result, 0, j);\\n        }\\n        return result;\\n    }\\n\\n    public void populateDiagonal(int[][] nums, int[][] result, int i, int j) {\\n        boolean[] uniqueNumbers = new boolean[51];\\n        int row = i, col = j;\\n        int uniqueCount = 0;\\n\\t\\t\\n\\t\\t// First, we traverse the 2D array from to bottom in a diagonal format and count the distinct values.\\n        while (row < nums.length && col < nums[0].length) {\\n            result[row][col] = uniqueCount;\\n            if (!uniqueNumbers[nums[row][col]]) {\\n                uniqueCount++;\\n                uniqueNumbers[nums[row][col]] = true;\\n            }\\n            row++;\\n            col++;\\n        }\\n\\t\\t\\n\\t\\t// Once we reach the bottom of the digonal, we need to step back and now count it in the reverse order\\n        row--;\\n        col--;\\n        uniqueNumbers = new boolean[51];\\n        uniqueCount = 0;\\n\\t\\t\\n\\t\\t// Same logic as above but in reverse direction\\n        while (row >= 0 && col >= 0) {\\n            result[row][col] = Math.abs(result[row][col] - uniqueCount);\\n            if (!uniqueNumbers[nums[row][col]]) {\\n                uniqueCount++;\\n                uniqueNumbers[nums[row][col]] = true;\\n            }\\n            row--;\\n            col--;\\n        }\\n    }\\n```\\n\\nTC: O(MN)\\nWhere M is rows and N is columns",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int[][] differenceOfDistinctValues(int[][] nums) {\\n        int[][] result = new int[nums.length][nums[0].length];\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums[i].length; j++) {\\n                result[i][j] = countDistinct(nums, i, j);\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n\\tpublic int countDistinct(int[][] nums, int i, int j) {\\n        Set<Integer> upperSet = new HashSet<>();\\n        Set<Integer> lowerSet = new HashSet<>();\\n        int upperI = i - 1, upperJ = j - 1;\\n        int lowerI = i + 1, lowerJ = j + 1;\\n\\n        while (upperI >= 0 && upperJ >= 0) {\\n            upperSet.add(nums[upperI][upperJ]);\\n            upperJ--;\\n            upperI--;\\n        }\\n        while (lowerI < nums.length && lowerJ < nums[0].length) {\\n            lowerSet.add(nums[lowerI][lowerJ]);\\n            lowerJ++;\\n            lowerI++;\\n        }\\n        return Math.abs(lowerSet.size() - upperSet.size());\\n    }\\n```\n```\\n\\tpublic int[][] countDistinctOptimized(int[][] nums) {\\n        int[][] result = new int[nums.length][nums[0].length];\\n        int rows = nums.length, cols = nums[0].length;\\n\\t\\t\\n\\t\\t// Imagine we fold the 2D array across the longest diagonal which passes between (0,0) and (m - 1, n - 1). We traverse the 2 parts in two different ways as shown in the below two for loops\\t\\t\\n        // populate first half\\n        for (int i = rows - 1; i >= 0; i--) {\\n            populateDiagonal(nums, result, i, 0);\\n        }\\n        //populate second half\\n        for (int j = 1; j < cols; j++) {\\n            populateDiagonal(nums, result, 0, j);\\n        }\\n        return result;\\n    }\\n\\n    public void populateDiagonal(int[][] nums, int[][] result, int i, int j) {\\n        boolean[] uniqueNumbers = new boolean[51];\\n        int row = i, col = j;\\n        int uniqueCount = 0;\\n\\t\\t\\n\\t\\t// First, we traverse the 2D array from to bottom in a diagonal format and count the distinct values.\\n        while (row < nums.length && col < nums[0].length) {\\n            result[row][col] = uniqueCount;\\n            if (!uniqueNumbers[nums[row][col]]) {\\n                uniqueCount++;\\n                uniqueNumbers[nums[row][col]] = true;\\n            }\\n            row++;\\n            col++;\\n        }\\n\\t\\t\\n\\t\\t// Once we reach the bottom of the digonal, we need to step back and now count it in the reverse order\\n        row--;\\n        col--;\\n        uniqueNumbers = new boolean[51];\\n        uniqueCount = 0;\\n\\t\\t\\n\\t\\t// Same logic as above but in reverse direction\\n        while (row >= 0 && col >= 0) {\\n            result[row][col] = Math.abs(result[row][col] - uniqueCount);\\n            if (!uniqueNumbers[nums[row][col]]) {\\n                uniqueCount++;\\n                uniqueNumbers[nums[row][col]] = true;\\n            }\\n            row--;\\n            col--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593316,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int ans[][] = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            \\n            for (int j = 0; j < m; j++) {\\n                ans[i][j] = solve(grid, i, j, n, m);\\n            }\\n        }\\n        return ans;\\n    }\\n    private int solve(int[][] grid, int i, int j, int n, int m) {\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int k = i-1, l = j-1; k >= 0 && l >= 0; k--, l--) {\\n            set1.add(grid[k][l]);\\n        }\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int k = i+1, l = j+1; k < n && l < m; k++, l++) {\\n            set2.add(grid[k][l]);\\n        }\\n        return Math.abs(set1.size() - set2.size());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int ans[][] = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            \\n            for (int j = 0; j < m; j++) {\\n                ans[i][j] = solve(grid, i, j, n, m);\\n            }\\n        }\\n        return ans;\\n    }\\n    private int solve(int[][] grid, int i, int j, int n, int m) {\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int k = i-1, l = j-1; k >= 0 && l >= 0; k--, l--) {\\n            set1.add(grid[k][l]);\\n        }\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int k = i+1, l = j+1; k < n && l < m; k++, l++) {\\n            set2.add(grid[k][l]);\\n        }\\n        return Math.abs(set1.size() - set2.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591607,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        final = [[0] * len(grid[0]) for _ in range(len(grid))]\\n\\n        def helper(x, y):\\n            diag_length = min(len(grid)-x, len(grid[0])-y)\\n            left = [0] * diag_length\\n            right = [0] * diag_length\\n            l_seen = set()\\n            r_seen = set()\\n\\n            for i in range(diag_length):\\n                l_seen.add(grid[x+i][y+i])\\n                r_seen.add(grid[x+diag_length-1-i][y+diag_length-1-i])\\n                left[i] += len(l_seen)\\n                right[-1-i] += len(r_seen)\\n            \\n            for i in range(diag_length):\\n                l = left[i-1] if i else 0\\n                r = right[i+1] if i<diag_length-1 else 0\\n                final[x+i][y+i] = abs(l-r)\\n        \\n        for i in range(1, len(grid)):\\n            helper(i,0)\\n        for i in range(len(grid[0])):\\n            helper(0,i)\\n\\n        return final\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        final = [[0] * len(grid[0]) for _ in range(len(grid))]\\n\\n        def helper(x, y):\\n            diag_length = min(len(grid)-x, len(grid[0])-y)\\n            left = [0] * diag_length\\n            right = [0] * diag_length\\n            l_seen = set()\\n            r_seen = set()\\n\\n            for i in range(diag_length):\\n                l_seen.add(grid[x+i][y+i])\\n                r_seen.add(grid[x+diag_length-1-i][y+diag_length-1-i])\\n                left[i] += len(l_seen)\\n                right[-1-i] += len(r_seen)\\n            \\n            for i in range(diag_length):\\n                l = left[i-1] if i else 0\\n                r = right[i+1] if i<diag_length-1 else 0\\n                final[x+i][y+i] = abs(l-r)\\n        \\n        for i in range(1, len(grid)):\\n            helper(i,0)\\n        for i in range(len(grid[0])):\\n            helper(0,i)\\n\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587331,
                "title": "efficient-solution-explained",
                "content": "# Intuition\\n\\nBrute force solution is accepted and faster for the low problem size. In spite of this, the given approach is asympotically better and would prove useful for larger problem inputs.\\n\\n# Approach\\nFirst, collect all starting points of diagonals / all points on the top or the left side of the input grid.\\n\\nThen, iterate over diagonals and collect values on each diagonal *once*. This can be used to determine the unique values before and after the current cell using STL hash sets.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$, i.e. linear w.r.t. the number of items in the input grid.\\n\\n- Space complexity: $$O(n*m)$$, dominated by the output array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Ensure all elements of diagonal are visited. Stop if end of grid is reached.\\n        int nm = std::max(m, n);\\n\\n        vector<vector<int>> res(m, vector<int>(n));\\n        // Collect start points of diagonals\\n        vector<pair<int,int>> diags;\\n        for (int i = 0; i<n; i++) {\\n            diags.push_back({0, i});\\n        }\\n        for (int i = 0; i<m; i++) {\\n            diags.push_back({i, 0});\\n        }\\n        \\n        for (auto& diag: diags) {\\n            int col0 = diag.second; // start point of current diagonal\\n            int row0 = diag.first;  // start point of current diagonal\\n\\n            vector<int> vals; // Collect values of diagonal\\n            for (int i = 0; i<nm; i++) {\\n                int col = col0 + i;\\n                int row = row0 + i;\\n                if (row >= m || col >= n) { break; }\\n                vals.push_back(grid[row][col]);\\n            }\\n            // Use collected values to populate all entries in diagonal.\\n            for (int i = 0; i<nm; i++) {\\n                int col = col0 + i;\\n                int row = row0 + i;\\n                if (row >= m || col >= n) { break; }\\n                unordered_set<int> valsPrev; // Collect values before current item.\\n                for (int idx = 0; idx < std::min((int)vals.size(), i); idx++) {\\n                    valsPrev.insert(vals[idx]);\\n                }\\n                unordered_set<int> valsPost; // Collect values after current item.\\n                for (int idx = i+1; idx < vals.size(); idx++) {\\n                    valsPost.insert(vals[idx]);\\n                }\\n                res[row][col] = abs((int)(valsPrev.size() - valsPost.size()));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Ensure all elements of diagonal are visited. Stop if end of grid is reached.\\n        int nm = std::max(m, n);\\n\\n        vector<vector<int>> res(m, vector<int>(n));\\n        // Collect start points of diagonals\\n        vector<pair<int,int>> diags;\\n        for (int i = 0; i<n; i++) {\\n            diags.push_back({0, i});\\n        }\\n        for (int i = 0; i<m; i++) {\\n            diags.push_back({i, 0});\\n        }\\n        \\n        for (auto& diag: diags) {\\n            int col0 = diag.second; // start point of current diagonal\\n            int row0 = diag.first;  // start point of current diagonal\\n\\n            vector<int> vals; // Collect values of diagonal\\n            for (int i = 0; i<nm; i++) {\\n                int col = col0 + i;\\n                int row = row0 + i;\\n                if (row >= m || col >= n) { break; }\\n                vals.push_back(grid[row][col]);\\n            }\\n            // Use collected values to populate all entries in diagonal.\\n            for (int i = 0; i<nm; i++) {\\n                int col = col0 + i;\\n                int row = row0 + i;\\n                if (row >= m || col >= n) { break; }\\n                unordered_set<int> valsPrev; // Collect values before current item.\\n                for (int idx = 0; idx < std::min((int)vals.size(), i); idx++) {\\n                    valsPrev.insert(vals[idx]);\\n                }\\n                unordered_set<int> valsPost; // Collect values after current item.\\n                for (int idx = i+1; idx < vals.size(); idx++) {\\n                    valsPost.insert(vals[idx]);\\n                }\\n                res[row][col] = abs((int)(valsPrev.size() - valsPost.size()));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586418,
                "title": "python3-simplest-solution-beats-90-uesrs-beginner-friendly-and-self-explanatory",
                "content": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m,n=len(grid),len(grid[0])\\n        ans=[[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                leftDiagonal,rightDiagonal=set(),set()\\n                r,c=i-1,j-1\\n                while r>=0 and c>=0:\\n                    leftDiagonal.add(grid[r][c])\\n                    r-=1\\n                    c-=1\\n                r,c=i+1,j+1\\n                while r<m and c<n:\\n                    rightDiagonal.add(grid[r][c])\\n                    r+=1\\n                    c+=1\\n                ans[i][j]=abs(len(leftDiagonal)-len(rightDiagonal))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m,n=len(grid),len(grid[0])\\n        ans=[[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                leftDiagonal,rightDiagonal=set(),set()\\n                r,c=i-1,j-1\\n                while r>=0 and c>=0:\\n                    leftDiagonal.add(grid[r][c])\\n                    r-=1\\n                    c-=1\\n                r,c=i+1,j+1\\n                while r<m and c<n:\\n                    rightDiagonal.add(grid[r][c])\\n                    r+=1\\n                    c+=1\\n                ans[i][j]=abs(len(leftDiagonal)-len(rightDiagonal))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583030,
                "title": "ans",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int find_tl(int i,int j,vector<vector<int>>& grid){\\n        unordered_set<int> s;\\n        int x=i-1 , y=j-1;\\n        while(x>=0 && y>=0){\\n            s.insert(grid[x][y]);\\n            x--;\\n            y--;\\n        }\\n        return s.size();  \\n    }\\n    \\n    int find_br(int i,int j,vector<vector<int>>& grid,int n,int m){\\n        unordered_set<int> s;\\n        int x=i+1 , y=j+1;\\n        while(x<n && y<m){\\n            s.insert(grid[x][y]);\\n            x++;\\n            y++;\\n        }\\n        return s.size();  \\n    }\\n    \\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> ans(n , vector<int>(m,0));\\n        \\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                int tl = find_tl(i,j,grid);\\n                cout<<tl<<\" \";\\n                int br = find_br(i,j,grid,n,m);\\n                cout<<br<<endl;\\n                ans[i][j] = abs(tl-br);    \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find_tl(int i,int j,vector<vector<int>>& grid){\\n        unordered_set<int> s;\\n        int x=i-1 , y=j-1;\\n        while(x>=0 && y>=0){\\n            s.insert(grid[x][y]);\\n            x--;\\n            y--;\\n        }\\n        return s.size();  \\n    }\\n    \\n    int find_br(int i,int j,vector<vector<int>>& grid,int n,int m){\\n        unordered_set<int> s;\\n        int x=i+1 , y=j+1;\\n        while(x<n && y<m){\\n            s.insert(grid[x][y]);\\n            x++;\\n            y++;\\n        }\\n        return s.size();  \\n    }\\n    \\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> ans(n , vector<int>(m,0));\\n        \\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                int tl = find_tl(i,j,grid);\\n                cout<<tl<<\" \";\\n                int br = find_br(i,j,grid,n,m);\\n                cout<<br<<endl;\\n                ans[i][j] = abs(tl-br);    \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3583001,
                "title": "very-fast-cpp-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> tl(row, vector<int> (col, 0));\\n        vector<vector<int>> br(row, vector<int> (col, 0));\\n        \\n        unordered_set<int> distinct_top_left;\\n        unordered_set<int> distinct_bottom_right;\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r--;\\n                c--;\\n\\n                while(r >= 0 && c >= 0)\\n                {\\n                    distinct_top_left.insert(grid[r][c]);\\n                    r--;\\n                    c--;\\n                }\\n\\n                tl[i][j] = distinct_top_left.size();\\n                distinct_top_left.clear();\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r++;\\n                c++;\\n\\n                while(r < row && c < col)\\n                {\\n                    distinct_bottom_right.insert(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n\\n                br[i][j] = distinct_bottom_right.size();\\n                distinct_bottom_right.clear();\\n            }\\n        }\\n\\n        vector<vector<int>> answer(row, vector<int> (col, 0));\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                answer[i][j] = abs(tl[i][j] - br[i][j]);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> tl(row, vector<int> (col, 0));\\n        vector<vector<int>> br(row, vector<int> (col, 0));\\n        \\n        unordered_set<int> distinct_top_left;\\n        unordered_set<int> distinct_bottom_right;\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r--;\\n                c--;\\n\\n                while(r >= 0 && c >= 0)\\n                {\\n                    distinct_top_left.insert(grid[r][c]);\\n                    r--;\\n                    c--;\\n                }\\n\\n                tl[i][j] = distinct_top_left.size();\\n                distinct_top_left.clear();\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r++;\\n                c++;\\n\\n                while(r < row && c < col)\\n                {\\n                    distinct_bottom_right.insert(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n\\n                br[i][j] = distinct_bottom_right.size();\\n                distinct_bottom_right.clear();\\n            }\\n        }\\n\\n        vector<vector<int>> answer(row, vector<int> (col, 0));\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                answer[i][j] = abs(tl[i][j] - br[i][j]);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582834,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTopLeft(vector<vector<int>> &grid, int r, int c) {\\n        set<int> s;\\n        \\n        for(int i = r - 1, j = c - 1; i >= 0 and j >= 0; i--, j--) \\n            s.insert(grid[i][j]);\\n        \\n        return s.size();\\n    }\\n    \\n    int countBottomRight(vector<vector<int>> &grid, int r, int c) {\\n        set<int> s;\\n        \\n        for(int i = r + 1, j = c + 1 ; i < grid.size() and j < grid[0].size(); i++, j++) \\n            s.insert(grid[i][j]);\\n        \\n        return s.size();\\n    }\\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> ans(n, vector<int> (m));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                int tl = countTopLeft(grid, i, j);\\n                int br = countBottomRight(grid, i, j);\\n                ans[i][j] = abs(tl - br);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTopLeft(vector<vector<int>> &grid, int r, int c) {\\n        set<int> s;\\n        \\n        for(int i = r - 1, j = c - 1; i >= 0 and j >= 0; i--, j--) \\n            s.insert(grid[i][j]);\\n        \\n        return s.size();\\n    }\\n    \\n    int countBottomRight(vector<vector<int>> &grid, int r, int c) {\\n        set<int> s;\\n        \\n        for(int i = r + 1, j = c + 1 ; i < grid.size() and j < grid[0].size(); i++, j++) \\n            s.insert(grid[i][j]);\\n        \\n        return s.size();\\n    }\\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> ans(n, vector<int> (m));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                int tl = countTopLeft(grid, i, j);\\n                int br = countBottomRight(grid, i, j);\\n                ans[i][j] = abs(tl - br);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580548,
                "title": "c-prefix-postfix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> ans(m, vector<int>(n));\\n    vector<vector<int>> pre(m, vector<int>(n));\\n    vector<vector<int>> post(m, vector<int>(n));\\n    \\n    for(int i = 0; i < m; i++){\\n        int r = i;\\n        int c = 0;\\n        unordered_set<int> st1;\\n        while(r < m && c < n){\\n            pre[r][c] = st1.size();\\n            st1.insert(grid[r][c]);\\n            r++;\\n            c++;\\n        }\\n        r--;\\n        c--;\\n        unordered_set<int> st2;\\n        while(r >= 0 && c >= 0){\\n            post[r][c] = st2.size();\\n            st2.insert(grid[r][c]);\\n            r--;\\n            c--;\\n        }\\n    }\\n    for(int i = 1; i < n; i++){\\n        int c = i;\\n        int r = 0;\\n        unordered_set<int> st1;\\n        while(r < m && c < n){\\n            pre[r][c] = st1.size();\\n            st1.insert(grid[r][c]);\\n            r++;\\n            c++;\\n            }\\n        r--;\\n        c--;\\n        unordered_set<int> st2;\\n        while(r >= 0 && c >= 0){\\n            post[r][c] = st2.size();\\n            st2.insert(grid[r][c]);\\n            r--;\\n            c--;\\n        }\\n    }\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                ans[i][j] = abs(pre[i][j] - post[i][j]);\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> ans(m, vector<int>(n));\\n    vector<vector<int>> pre(m, vector<int>(n));\\n    vector<vector<int>> post(m, vector<int>(n));\\n    \\n    for(int i = 0; i < m; i++){\\n        int r = i;\\n        int c = 0;\\n        unordered_set<int> st1;\\n        while(r < m && c < n){\\n            pre[r][c] = st1.size();\\n            st1.insert(grid[r][c]);\\n            r++;\\n            c++;\\n        }\\n        r--;\\n        c--;\\n        unordered_set<int> st2;\\n        while(r >= 0 && c >= 0){\\n            post[r][c] = st2.size();\\n            st2.insert(grid[r][c]);\\n            r--;\\n            c--;\\n        }\\n    }\\n    for(int i = 1; i < n; i++){\\n        int c = i;\\n        int r = 0;\\n        unordered_set<int> st1;\\n        while(r < m && c < n){\\n            pre[r][c] = st1.size();\\n            st1.insert(grid[r][c]);\\n            r++;\\n            c++;\\n            }\\n        r--;\\n        c--;\\n        unordered_set<int> st2;\\n        while(r >= 0 && c >= 0){\\n            post[r][c] = st2.size();\\n            st2.insert(grid[r][c]);\\n            r--;\\n            c--;\\n        }\\n    }\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                ans[i][j] = abs(pre[i][j] - post[i][j]);\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580146,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] ans = new int[m][n];\\n        for(int i=0;i<n;i++){\\n            int[] freqRight = new int[51];\\n            int[] freqLeft = new int[51];\\n            int distinct = populate(0,i,freqRight,m,n,grid);            \\n            int rightDistinct = distinct;\\n            int leftDistinct = 0;\\n            int row = 0;\\n            int col = i;\\n            while(row<m && col<n){\\n                if(row+1<m && col+1<n){\\n                    rightDistinct = rightDistinct - (freqRight[grid[row][col]] > 1 ? 0 : 1);\\n                    freqRight[grid[row][col]]--;\\n                }else{\\n                    rightDistinct = 0;\\n                }\\n                if(row>0&&col>0){\\n                    leftDistinct = leftDistinct + (freqLeft[grid[row-1][col-1]] == 0 ? 1 : 0);\\n                    freqLeft[grid[row-1][col-1]]++;\\n                }else{\\n                    leftDistinct = 0;\\n                }\\n                ans[row][col] = Math.abs(rightDistinct-leftDistinct);\\n                row++;\\n                col++;\\n            }\\n        }\\n        for(int i=1;i<m;i++){\\n            int[] freqRight = new int[51];\\n            int[] freqLeft = new int[51];\\n            int distinct = populate(i,0,freqRight,m,n,grid);            \\n            int rightDistinct = distinct;\\n            int leftDistinct = 0;\\n            int row = i;\\n            int col = 0;\\n            while(row<m && col<n){\\n                if(row+1<m && col+1<n){\\n                    rightDistinct = rightDistinct - (freqRight[grid[row][col]] > 1 ? 0 : 1);\\n                    freqRight[grid[row][col]]--;\\n                }else{\\n                    rightDistinct = 0;\\n                }\\n                if(row>0&&col>0){\\n                    leftDistinct = leftDistinct + (freqLeft[grid[row-1][col-1]] == 0 ? 1 : 0);\\n                    freqLeft[grid[row-1][col-1]]++;\\n                }else{\\n                    leftDistinct = 0;\\n                }\\n                ans[row][col] = Math.abs(rightDistinct-leftDistinct);\\n                row++;\\n                col++;\\n            }\\n        }\\n        System.gc();\\n        return ans;\\n    }\\n    \\n    private int populate(int row,int col,int[] freq,int m,int n,int[][] grid){\\n        int distinct = 0;\\n        while(row<m&&col<n){\\n            if(freq[grid[row][col]]==0){\\n                distinct++;\\n            }\\n            freq[grid[row][col]]++;\\n            row++;\\n            col++;\\n        }\\n        return distinct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] ans = new int[m][n];\\n        for(int i=0;i<n;i++){\\n            int[] freqRight = new int[51];\\n            int[] freqLeft = new int[51];\\n            int distinct = populate(0,i,freqRight,m,n,grid);            \\n            int rightDistinct = distinct;\\n            int leftDistinct = 0;\\n            int row = 0;\\n            int col = i;\\n            while(row<m && col<n){\\n                if(row+1<m && col+1<n){\\n                    rightDistinct = rightDistinct - (freqRight[grid[row][col]] > 1 ? 0 : 1);\\n                    freqRight[grid[row][col]]--;\\n                }else{\\n                    rightDistinct = 0;\\n                }\\n                if(row>0&&col>0){\\n                    leftDistinct = leftDistinct + (freqLeft[grid[row-1][col-1]] == 0 ? 1 : 0);\\n                    freqLeft[grid[row-1][col-1]]++;\\n                }else{\\n                    leftDistinct = 0;\\n                }\\n                ans[row][col] = Math.abs(rightDistinct-leftDistinct);\\n                row++;\\n                col++;\\n            }\\n        }\\n        for(int i=1;i<m;i++){\\n            int[] freqRight = new int[51];\\n            int[] freqLeft = new int[51];\\n            int distinct = populate(i,0,freqRight,m,n,grid);            \\n            int rightDistinct = distinct;\\n            int leftDistinct = 0;\\n            int row = i;\\n            int col = 0;\\n            while(row<m && col<n){\\n                if(row+1<m && col+1<n){\\n                    rightDistinct = rightDistinct - (freqRight[grid[row][col]] > 1 ? 0 : 1);\\n                    freqRight[grid[row][col]]--;\\n                }else{\\n                    rightDistinct = 0;\\n                }\\n                if(row>0&&col>0){\\n                    leftDistinct = leftDistinct + (freqLeft[grid[row-1][col-1]] == 0 ? 1 : 0);\\n                    freqLeft[grid[row-1][col-1]]++;\\n                }else{\\n                    leftDistinct = 0;\\n                }\\n                ans[row][col] = Math.abs(rightDistinct-leftDistinct);\\n                row++;\\n                col++;\\n            }\\n        }\\n        System.gc();\\n        return ans;\\n    }\\n    \\n    private int populate(int row,int col,int[] freq,int m,int n,int[][] grid){\\n        int distinct = 0;\\n        while(row<m&&col<n){\\n            if(freq[grid[row][col]]==0){\\n                distinct++;\\n            }\\n            freq[grid[row][col]]++;\\n            row++;\\n            col++;\\n        }\\n        return distinct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580065,
                "title": "python-dictionary",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def differenceOfDistinctValues(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        r, c = len(grid), len(grid[0])\\n        ans = [[0 for _ in range(c)] for _ in range(r)]\\n        points = []\\n\\n        for p in range(0, r) :\\n            points.append([p, 0])\\n        \\n        for p in range(1, c) :\\n            points.append([0, p])\\n\\n        for p in points:\\n            m = {}\\n            i, j = p[0], p[1]\\n            while i < r and j < c:\\n                m[grid[i][j]] = m.get(grid[i][j], 0) + 1\\n                i += 1\\n                j += 1\\n            \\n            i, j = p[0], p[1]\\n            n = {}\\n            while i < r and j < c:\\n                m[grid[i][j]] = m.get(grid[i][j], 0) - 1\\n                if(m.get(grid[i][j]) <= 0):\\n                     m.pop(grid[i][j])\\n                ans[i][j] = abs(len(m.keys())- len(n.keys()))\\n                n[grid[i][j]] = n.get(grid[i][j], 0) + 1\\n                i += 1\\n                j += 1\\n                   \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def differenceOfDistinctValues(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        r, c = len(grid), len(grid[0])\\n        ans = [[0 for _ in range(c)] for _ in range(r)]\\n        points = []\\n\\n        for p in range(0, r) :\\n            points.append([p, 0])\\n        \\n        for p in range(1, c) :\\n            points.append([0, p])\\n\\n        for p in points:\\n            m = {}\\n            i, j = p[0], p[1]\\n            while i < r and j < c:\\n                m[grid[i][j]] = m.get(grid[i][j], 0) + 1\\n                i += 1\\n                j += 1\\n            \\n            i, j = p[0], p[1]\\n            n = {}\\n            while i < r and j < c:\\n                m[grid[i][j]] = m.get(grid[i][j], 0) - 1\\n                if(m.get(grid[i][j]) <= 0):\\n                     m.pop(grid[i][j])\\n                ans[i][j] = abs(len(m.keys())- len(n.keys()))\\n                n[grid[i][j]] = n.get(grid[i][j], 0) + 1\\n                i += 1\\n                j += 1\\n                   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580062,
                "title": "easy-to-understand-store-the-results-of-both-diagonals-2-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int [][] bottom = new int[n][];\\n        int [][] up = new int[n][];\\n        for(int i = 0; i < n; i++)\\n        {\\n            bottom[i] = new int[m];\\n            up[i] = new int[m];\\n        }\\n\\n        HashMap<Integer,HashSet<Integer>> map = new HashMap<>();\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i + 1 < n && j + 1 < m)\\n                {\\n                    int key = i - j;\\n                    if(!map.containsKey(key))\\n                    map.put(key,new HashSet<Integer>());\\n                    map.get(key).add(grid[i+1][j+1]);\\n                    bottom[i][j] = map.get(key).size();\\n                }\\n            }\\n        }\\n        \\n        map.clear();\\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i - 1 >= 0 && j - 1 >= 0)\\n                {\\n                    int key = i - j;\\n                    if(!map.containsKey(key))\\n                    map.put(key,new HashSet<Integer>());\\n                    map.get(key).add(grid[i-1][j-1]);\\n                    up[i][j] = map.get(key).size();\\n                }\\n                bottom[i][j] = Math.abs(bottom[i][j] - up[i][j]);\\n            }\\n        }\\n        return bottom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int [][] bottom = new int[n][];\\n        int [][] up = new int[n][];\\n        for(int i = 0; i < n; i++)\\n        {\\n            bottom[i] = new int[m];\\n            up[i] = new int[m];\\n        }\\n\\n        HashMap<Integer,HashSet<Integer>> map = new HashMap<>();\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i + 1 < n && j + 1 < m)\\n                {\\n                    int key = i - j;\\n                    if(!map.containsKey(key))\\n                    map.put(key,new HashSet<Integer>());\\n                    map.get(key).add(grid[i+1][j+1]);\\n                    bottom[i][j] = map.get(key).size();\\n                }\\n            }\\n        }\\n        \\n        map.clear();\\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i - 1 >= 0 && j - 1 >= 0)\\n                {\\n                    int key = i - j;\\n                    if(!map.containsKey(key))\\n                    map.put(key,new HashSet<Integer>());\\n                    map.get(key).add(grid[i-1][j-1]);\\n                    up[i][j] = map.get(key).size();\\n                }\\n                bottom[i][j] = Math.abs(bottom[i][j] - up[i][j]);\\n            }\\n        }\\n        return bottom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580046,
                "title": "simple-c-solutions",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n,0)),topLeft(m,vector<int> (n,0)),bottomRight(m,vector<int> (n,0));\\n        unordered_set<int> l,r;\\n        for(int i=0;i<n;i++){\\n            l.insert(grid[0][i]);\\n            int k = 1;\\n            while(i+k<n&&k<m){\\n                topLeft[k][i+k] = l.size();\\n                l.insert(grid[k][i+k]);\\n                k++;\\n            }\\n            l.clear();\\n        }\\n        for(int i=1;i<m;i++){\\n            l.insert(grid[i][0]);\\n            int k = 1;\\n            while(i+k<m&&k<n){\\n                topLeft[i+k][k] = l.size();\\n                l.insert(grid[i+k][k]);\\n                k++;\\n            }\\n            l.clear();\\n        }\\n        for(int i=0;i<m;i++){\\n            r.insert(grid[i][n-1]);\\n            int k = 1;\\n            while(i-k>=0&&n-1-k>=0){\\n                bottomRight[i-k][n-1-k] = r.size();\\n                r.insert(grid[i-k][n-1-k]);\\n                k++;\\n            }\\n            r.clear();\\n        }\\n        for(int i=1;i<n;i++){\\n            r.insert(grid[m-1][i]);\\n            int k = 1;\\n            while(m-1-k>=0&&i-k>=0){\\n                bottomRight[m-1-k][i-k] = r.size();\\n                r.insert(grid[m-1-k][i-k]);\\n                k++;\\n            }\\n            r.clear();\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j] = abs(topLeft[i][j] - bottomRight[i][j]);\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n,0)),topLeft(m,vector<int> (n,0)),bottomRight(m,vector<int> (n,0));\\n        unordered_set<int> l,r;\\n        for(int i=0;i<n;i++){\\n            l.insert(grid[0][i]);\\n            int k = 1;\\n            while(i+k<n&&k<m){\\n                topLeft[k][i+k] = l.size();\\n                l.insert(grid[k][i+k]);\\n                k++;\\n            }\\n            l.clear();\\n        }\\n        for(int i=1;i<m;i++){\\n            l.insert(grid[i][0]);\\n            int k = 1;\\n            while(i+k<m&&k<n){\\n                topLeft[i+k][k] = l.size();\\n                l.insert(grid[i+k][k]);\\n                k++;\\n            }\\n            l.clear();\\n        }\\n        for(int i=0;i<m;i++){\\n            r.insert(grid[i][n-1]);\\n            int k = 1;\\n            while(i-k>=0&&n-1-k>=0){\\n                bottomRight[i-k][n-1-k] = r.size();\\n                r.insert(grid[i-k][n-1-k]);\\n                k++;\\n            }\\n            r.clear();\\n        }\\n        for(int i=1;i<n;i++){\\n            r.insert(grid[m-1][i]);\\n            int k = 1;\\n            while(m-1-k>=0&&i-k>=0){\\n                bottomRight[m-1-k][i-k] = r.size();\\n                r.insert(grid[m-1-k][i-k]);\\n                k++;\\n            }\\n            r.clear();\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j] = abs(topLeft[i][j] - bottomRight[i][j]);\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579893,
                "title": "two-loop-for-diag-index-append",
                "content": "# Intuition\\nencode diag with i + j. One loop for prev unique element in topLeft. One for bottomRight\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nm)\\n\\n- Space complexity:\\no(mn)\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\'\\'\\'\\n        [[1,2,3],\\n         [3,1,5],\\n         [3,2,1]]\\n         \\n         [[1,1,0],\\n          [1,0,1],\\n          [0,1,1]]\\n        \\n        two loop \\n        (0, 0), (1, 1), (2, 2)\\n        i-j \\n        [[0,-1, -2],\\n         [1, 0, -1],\\n         [2, 1,  0]]\\n\\ndictionary : set, forward and backward. \\n        0:  [1, 1, 1]\\n        -1: [2, 5]\\n        -2: [3]\\n        1:  [3, 2]\\n        2:  [3]\\n        \\'\\'\\' \\n        from collections import defaultdict \\n        m, n = len(grid), len(grid[0])\\n        diag_to_val = defaultdict(set)\\n        output = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                val = grid[i][j]\\n                diag = i - j \\n                prev_unique_num = len(diag_to_val[diag])\\n                output[i][j] = prev_unique_num\\n                diag_to_val[diag].add(val)\\n        \\n        diag_to_val2 = defaultdict(set)\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                val = grid[i][j]\\n                diag = i - j \\n                prev_unique_num = len(diag_to_val2[diag])\\n                output[i][j] = abs(output[i][j] - prev_unique_num)\\n                diag_to_val2[diag].add(val)\\n        return output \\n        \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\'\\'\\'\\n        [[1,2,3],\\n         [3,1,5],\\n         [3,2,1]]\\n         \\n         [[1,1,0],\\n          [1,0,1],\\n          [0,1,1]]\\n        \\n        two loop \\n        (0, 0), (1, 1), (2, 2)\\n        i-j \\n        [[0,-1, -2],\\n         [1, 0, -1],\\n         [2, 1,  0]]\\n\\ndictionary : set, forward and backward. \\n        0:  [1, 1, 1]\\n        -1: [2, 5]\\n        -2: [3]\\n        1:  [3, 2]\\n        2:  [3]\\n        \\'\\'\\' \\n        from collections import defaultdict \\n        m, n = len(grid), len(grid[0])\\n        diag_to_val = defaultdict(set)\\n        output = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                val = grid[i][j]\\n                diag = i - j \\n                prev_unique_num = len(diag_to_val[diag])\\n                output[i][j] = prev_unique_num\\n                diag_to_val[diag].add(val)\\n        \\n        diag_to_val2 = defaultdict(set)\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                val = grid[i][j]\\n                diag = i - j \\n                prev_unique_num = len(diag_to_val2[diag])\\n                output[i][j] = abs(output[i][j] - prev_unique_num)\\n                diag_to_val2[diag].add(val)\\n        return output \\n        \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579649,
                "title": "javascript-using-set",
                "content": "/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar differenceOfDistinctValues = function(grid) {\\n    \\n    let n=grid.length,m=grid[0].length;\\n    \\n    let ans=[]\\n    \\n    for(let i=0;i<n;i++)\\n        {\\n            ans[i]=[]\\n            \\n            for(let j=0;j<m;j++)\\n                {\\n                    let x=i-1,y=j-1;\\n                    let left=new Set(),right=new Set();\\n                    \\n                    while(x>=0 && y>=0)\\n                        {\\n                          left.add(grid[x][y]);\\n                            x--;\\n                            y--;\\n                        }\\n                    \\n                    x=i+1;\\n                    y=j+1;\\n                    \\n                    while(x<n && y<m)\\n                        {\\n                            right.add(grid[x][y]);\\n                            x++;\\n                            y++;\\n                        }\\n                    ans[i][j]=Math.abs(left.size-right.size);\\n                }\\n        }\\n    \\n    return ans;\\n    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Ordered Set"
                ],
                "code": "/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar differenceOfDistinctValues = function(grid) {\\n    \\n    let n=grid.length,m=grid[0].length;\\n    \\n    let ans=[]\\n    \\n    for(let i=0;i<n;i++)\\n        {\\n            ans[i]=[]\\n            \\n            for(let j=0;j<m;j++)\\n                {\\n                    let x=i-1,y=j-1;\\n                    let left=new Set(),right=new Set();\\n                    \\n                    while(x>=0 && y>=0)\\n                        {\\n                          left.add(grid[x][y]);\\n                            x--;\\n                            y--;\\n                        }\\n                    \\n                    x=i+1;\\n                    y=j+1;\\n                    \\n                    while(x<n && y<m)\\n                        {\\n                            right.add(grid[x][y]);\\n                            x++;\\n                            y++;\\n                        }\\n                    ans[i][j]=Math.abs(left.size-right.size);\\n                }\\n        }\\n    \\n    return ans;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3577778,
                "title": "simple-js-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n in the question its given that we need to return the difference of no of distint elements in of each element \\n    so what we can do is we can use set to keep track of all the distant elements of each elements \\n\\nwe can itrate over the matrix and check for all diagonal elements before and after every elemets \\n    for that we can use a while loop \\n\\nthen we add the difference of the size of sets to the answer matrix\\n    \\n     \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar differenceOfDistinctValues = function(grid) {\\n    \\n    let m=grid.length;\\n    let n=grid[0].length;\\n\\n    let out=new Array(m).fill(0).map(()=>new Array(n));\\n   \\n    <!-- itratring over the grid -->\\n    for(let i=0;i<m;i++){\\n        for(let j=0;j<n;j++){\\n            let set=new Set();\\n            let set1=new Set();\\n            // finding previous the row and coloumn diagonal elements\\n            let r=i-1;\\n            let c=j-1;\\n\\n            while(r>=0 && c>=0){\\n                set.add(grid[r][c]);\\n                r--;\\n                c--;\\n            }\\n           // finding the diagonal elements after the elemnts\\n            r=i+1;\\n            c=j+1;\\n\\n            while(r<m && c<n){\\n                set1.add(grid[r][c]);\\n                r++;\\n                c++;\\n            }\\n            \\n            // adding difference value to output \\n            out[i][j] = Math.abs(set.size-set1.size);\\n\\n        }\\n    }\\n    return out;\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[][]}\\n */\\nvar differenceOfDistinctValues = function(grid) {\\n    \\n    let m=grid.length;\\n    let n=grid[0].length;\\n\\n    let out=new Array(m).fill(0).map(()=>new Array(n));\\n   \\n    <!-- itratring over the grid -->\\n    for(let i=0;i<m;i++){\\n        for(let j=0;j<n;j++){\\n            let set=new Set();\\n            let set1=new Set();\\n            // finding previous the row and coloumn diagonal elements\\n            let r=i-1;\\n            let c=j-1;\\n\\n            while(r>=0 && c>=0){\\n                set.add(grid[r][c]);\\n                r--;\\n                c--;\\n            }\\n           // finding the diagonal elements after the elemnts\\n            r=i+1;\\n            c=j+1;\\n\\n            while(r<m && c<n){\\n                set1.add(grid[r][c]);\\n                r++;\\n                c++;\\n            }\\n            \\n            // adding difference value to output \\n            out[i][j] = Math.abs(set.size-set1.size);\\n\\n        }\\n    }\\n    return out;\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577384,
                "title": "java-very-easy-solution-using-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        // BRUTE FORCE\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] ans = new int [m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                Set<Integer> s1 = new HashSet<>();\\n                Set<Integer> s2 = new HashSet<>();\\n                int lt = leftTop(s1,i-1,j-1,grid);\\n                int rb = rightBottom(s2,i+1,j+1,grid);\\n                ans[i][j] = Math.abs((lt-rb));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int leftTop( Set<Integer> leftTop, int a, int b, int [][] matrix){\\n        if(a < 0 || b < 0){\\n            return leftTop.size();\\n        }\\n        leftTop.add(matrix[a][b]);\\n        return leftTop(leftTop, a-1, b-1, matrix);\\n    }\\n\\n    public int rightBottom(Set<Integer> rightBottom, int a, int b, int [][] matrix){\\n        if(a > matrix.length-1 || b > matrix[0].length-1){\\n            return rightBottom.size();\\n        }\\n        rightBottom.add(matrix[a][b]);\\n        return rightBottom(rightBottom, a+1, b+1, matrix);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        // BRUTE FORCE\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] ans = new int [m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                Set<Integer> s1 = new HashSet<>();\\n                Set<Integer> s2 = new HashSet<>();\\n                int lt = leftTop(s1,i-1,j-1,grid);\\n                int rb = rightBottom(s2,i+1,j+1,grid);\\n                ans[i][j] = Math.abs((lt-rb));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int leftTop( Set<Integer> leftTop, int a, int b, int [][] matrix){\\n        if(a < 0 || b < 0){\\n            return leftTop.size();\\n        }\\n        leftTop.add(matrix[a][b]);\\n        return leftTop(leftTop, a-1, b-1, matrix);\\n    }\\n\\n    public int rightBottom(Set<Integer> rightBottom, int a, int b, int [][] matrix){\\n        if(a > matrix.length-1 || b > matrix[0].length-1){\\n            return rightBottom.size();\\n        }\\n        rightBottom.add(matrix[a][b]);\\n        return rightBottom(rightBottom, a+1, b+1, matrix);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577132,
                "title": "difference-of-number-of-distinct-values-on-diagonals-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][]res = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int k1 = i+1;\\n                int k2 = j+1;\\n                Set<Integer> br = new HashSet<Integer>();\\n                while(k1 < m && k2 < n){\\n                    br.add(grid[k1][k2]);\\n                    k1++;\\n                    k2++;\\n                }\\n                k1 = i-1;\\n                k2 = j-1;\\n                Set<Integer> tl = new HashSet<Integer>();\\n                while(k1 >= 0 && k2 >= 0){\\n                    tl.add(grid[k1][k2]);\\n                    k1--;\\n                    k2--;\\n                }\\n                res[i][j] = Math.abs(br.size()-tl.size());\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][]res = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int k1 = i+1;\\n                int k2 = j+1;\\n                Set<Integer> br = new HashSet<Integer>();\\n                while(k1 < m && k2 < n){\\n                    br.add(grid[k1][k2]);\\n                    k1++;\\n                    k2++;\\n                }\\n                k1 = i-1;\\n                k2 = j-1;\\n                Set<Integer> tl = new HashSet<Integer>();\\n                while(k1 >= 0 && k2 >= 0){\\n                    tl.add(grid[k1][k2]);\\n                    k1--;\\n                    k2--;\\n                }\\n                res[i][j] = Math.abs(br.size()-tl.size());\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577129,
                "title": "c-brute-force-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n        int nr=size(g),nc=size(g[0]);\\n        vector<vector<int>> ans(nr,vector<int>(nc));\\n        for(int i=0;i<nr;++i)\\n            for(int j=0;j<nc;++j){\\n                unordered_set<int>tl,br;\\n                int tx=i-1,ty=j-1,bx=i+1,by=j+1;\\n                while(tx>=0 && ty>=0)tl.insert(g[tx--][ty--]);\\n                while(bx<nr && by<nc)br.insert(g[bx++][by++]);\\n                ans[i][j]=abs((int)size(tl)-(int)size(br));\\n            \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& g) {\\n        int nr=size(g),nc=size(g[0]);\\n        vector<vector<int>> ans(nr,vector<int>(nc));\\n        for(int i=0;i<nr;++i)\\n            for(int j=0;j<nc;++j){\\n                unordered_set<int>tl,br;\\n                int tx=i-1,ty=j-1,bx=i+1,by=j+1;\\n                while(tx>=0 && ty>=0)tl.insert(g[tx--][ty--]);\\n                while(bx<nr && by<nc)br.insert(g[bx++][by++]);\\n                ans[i][j]=abs((int)size(tl)-(int)size(br));\\n            \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576959,
                "title": "python-straightforward-solution-with-two-hash-maps-explained",
                "content": "This problem is not hard. No special algorithms and tricks required, we just need to use two hash maps to track the distinct values in the top-left diagonal and distinct values in the bottom-right diagonal.\\n\\nMake sure that all the index are within the grid range.\\n\\nSee the code below.\\n\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        # using two dictionaries to track the distinct values for top-left diagonal and bottom-right diagonal\\n        m, n = len(grid), len(grid[0])\\n        \\n        ans = []\\n        for i in range(m):\\n            ans.append([0] * n)\\n        \\n        # process the diagonals starting from the first row\\n        for j in range(n):\\n            tl = collections.defaultdict(int)\\n            br = collections.defaultdict(int)\\n            start_j, start_i = j + 1, 1\\n            while start_j < n and start_i < m:\\n                br[grid[start_i][start_j]] += 1\\n                start_i += 1\\n                start_j += 1\\n            \\n            start_i, start_j = 0, j\\n            while start_i < m and start_j < n:\\n                if start_i - 1 >= 0 and start_j - 1 >= 0:\\n                    tl[grid[start_i - 1][start_j - 1]] += 1\\n                \\n                ans[start_i][start_j] = abs(len(br) - len(tl))\\n                \\n                if start_i + 1 < m and start_j + 1 < n:\\n                    tval = grid[start_i + 1][start_j + 1]\\n                    br[tval] -= 1\\n                    if br[tval] <= 0:\\n                        del br[tval]\\n                start_i += 1\\n                start_j += 1\\n        # process the diagonals startring from the first col\\n        for i in range(1, m):\\n            tl = collections.defaultdict(int)\\n            br = collections.defaultdict(int)\\n            start_i, start_j = i + 1, 1\\n            while start_j < n and start_i < m:\\n                br[grid[start_i][start_j]] += 1\\n                start_i += 1\\n                start_j += 1\\n            \\n            start_i, start_j = i, 0\\n            while start_i < m and start_j < n:\\n                if start_i - 1 >= 0 and start_j - 1 >= 0:\\n                    tl[grid[start_i - 1][start_j - 1]] += 1\\n                \\n                ans[start_i][start_j] = abs(len(br) - len(tl))\\n                \\n                if start_i + 1 < m and start_j + 1 < n:\\n                    tval = grid[start_i + 1][start_j + 1]\\n                    br[tval] -= 1\\n                    if br[tval] <= 0:\\n                        del br[tval]\\n                start_i += 1\\n                start_j += 1\\n                \\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        # using two dictionaries to track the distinct values for top-left diagonal and bottom-right diagonal\\n        m, n = len(grid), len(grid[0])\\n        \\n        ans = []\\n        for i in range(m):\\n            ans.append([0] * n)\\n        \\n        # process the diagonals starting from the first row\\n        for j in range(n):\\n            tl = collections.defaultdict(int)\\n            br = collections.defaultdict(int)\\n            start_j, start_i = j + 1, 1\\n            while start_j < n and start_i < m:\\n                br[grid[start_i][start_j]] += 1\\n                start_i += 1\\n                start_j += 1\\n            \\n            start_i, start_j = 0, j\\n            while start_i < m and start_j < n:\\n                if start_i - 1 >= 0 and start_j - 1 >= 0:\\n                    tl[grid[start_i - 1][start_j - 1]] += 1\\n                \\n                ans[start_i][start_j] = abs(len(br) - len(tl))\\n                \\n                if start_i + 1 < m and start_j + 1 < n:\\n                    tval = grid[start_i + 1][start_j + 1]\\n                    br[tval] -= 1\\n                    if br[tval] <= 0:\\n                        del br[tval]\\n                start_i += 1\\n                start_j += 1\\n        # process the diagonals startring from the first col\\n        for i in range(1, m):\\n            tl = collections.defaultdict(int)\\n            br = collections.defaultdict(int)\\n            start_i, start_j = i + 1, 1\\n            while start_j < n and start_i < m:\\n                br[grid[start_i][start_j]] += 1\\n                start_i += 1\\n                start_j += 1\\n            \\n            start_i, start_j = i, 0\\n            while start_i < m and start_j < n:\\n                if start_i - 1 >= 0 and start_j - 1 >= 0:\\n                    tl[grid[start_i - 1][start_j - 1]] += 1\\n                \\n                ans[start_i][start_j] = abs(len(br) - len(tl))\\n                \\n                if start_i + 1 < m and start_j + 1 < n:\\n                    tval = grid[start_i + 1][start_j + 1]\\n                    br[tval] -= 1\\n                    if br[tval] <= 0:\\n                        del br[tval]\\n                start_i += 1\\n                start_j += 1\\n                \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576687,
                "title": "python-building-topleft-and-bottomright-tables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can build topLeft and bottomRight tables by prefix set.\\nAnd use these tables to get the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet $a_{ij}$ and $a_{pq}$ be the elements in the grid.\\nWe say they are in the same group if $i - j = p - q$.\\nWe start from the top-left boundary of the grid, traverse group by group, and finally establish the topLeft and bottomRight tables.\\n\\nfor example: grid = [\\n[a, b, c],\\n[d, e, f],\\n[g, h, i]]\\n\\nstart_point for each group: c, b, a, d, g\\ntraversal order = (c) -> (b, f) -> (a, e, i) -> (d, h) -> (g)\\nwe also have end_point for each group: c, f, i, h, g\\n\\nIn each group, we initialize the prefix and suffix sets as empty sets.\\nWe traverse the group in both bottom-right and top-left directions, adding each element to the sets, and filling the size of the sets into the tables.\\n\\n# Complexity\\n$N$: len(grid)  \\n$M$: len(grid[0])  \\n\\n- Time complexity: $O(NM)$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(NM)$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# N: len(grid)\\n# M: len(grid[0])\\n# TC: O(MN)\\n# SC: O(MN)\\n\\nimport collections\\n\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        ans = [[0 for _ in range(m)] for _ in range(n)]\\n        prefix = [[0 for _ in range(m)] for _ in range(n)]\\n        suffix = [[0 for _ in range(m)] for _ in range(n)]\\n\\n        def get_group_last_element_pos(point):\\n            i, j = point\\n            k = min(n - 1 - i, m - 1 - j)\\n            return [i + k, j + k]\\n\\n        def update_prefix(ps, point):\\n            x, y = point\\n            while 0 <= x < n and 0 <= y < m:\\n                val = grid[x][y]\\n                prefix[x][y] = len(ps)\\n                ps.add(val)\\n                x += 1\\n                y += 1\\n\\n        def update_suffix(ss, point):\\n            x, y = point\\n            while 0 <= x < n and 0 <= y < m:\\n                val = grid[x][y]\\n                suffix[x][y] = len(ss)\\n                ss.add(val)\\n                x -= 1\\n                y -= 1\\n\\n        directions = [[0, -1], [1, 0]]\\n        total_group = m + n - 1\\n        cnt = 0\\n        start_point = [0, m - 1]\\n        d = 0\\n        while cnt < total_group:\\n            cnt += 1\\n\\n            prefix_set = set()\\n            update_prefix(prefix_set, start_point)\\n\\n            end_point = get_group_last_element_pos(start_point)\\n            suffix_set = set()\\n            update_suffix(suffix_set, end_point)\\n\\n            start_point[0] += directions[d][0]\\n            start_point[1] += directions[d][1]\\n\\n            if start_point == [0, 0]:\\n                d = 1\\n\\n        for i in range(n):\\n            for j in range(m):\\n                ans[i][j] = abs(prefix[i][j] - suffix[i][j])\\n                \\n                    \\n        return ans\\n           \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n# N: len(grid)\\n# M: len(grid[0])\\n# TC: O(MN)\\n# SC: O(MN)\\n\\nimport collections\\n\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        ans = [[0 for _ in range(m)] for _ in range(n)]\\n        prefix = [[0 for _ in range(m)] for _ in range(n)]\\n        suffix = [[0 for _ in range(m)] for _ in range(n)]\\n\\n        def get_group_last_element_pos(point):\\n            i, j = point\\n            k = min(n - 1 - i, m - 1 - j)\\n            return [i + k, j + k]\\n\\n        def update_prefix(ps, point):\\n            x, y = point\\n            while 0 <= x < n and 0 <= y < m:\\n                val = grid[x][y]\\n                prefix[x][y] = len(ps)\\n                ps.add(val)\\n                x += 1\\n                y += 1\\n\\n        def update_suffix(ss, point):\\n            x, y = point\\n            while 0 <= x < n and 0 <= y < m:\\n                val = grid[x][y]\\n                suffix[x][y] = len(ss)\\n                ss.add(val)\\n                x -= 1\\n                y -= 1\\n\\n        directions = [[0, -1], [1, 0]]\\n        total_group = m + n - 1\\n        cnt = 0\\n        start_point = [0, m - 1]\\n        d = 0\\n        while cnt < total_group:\\n            cnt += 1\\n\\n            prefix_set = set()\\n            update_prefix(prefix_set, start_point)\\n\\n            end_point = get_group_last_element_pos(start_point)\\n            suffix_set = set()\\n            update_suffix(suffix_set, end_point)\\n\\n            start_point[0] += directions[d][0]\\n            start_point[1] += directions[d][1]\\n\\n            if start_point == [0, 0]:\\n                d = 1\\n\\n        for i in range(n):\\n            for j in range(m):\\n                ans[i][j] = abs(prefix[i][j] - suffix[i][j])\\n                \\n                    \\n        return ans\\n           \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576224,
                "title": "c-easy-to-understand-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                int x1=i,y1=j,x2=i,y2=j;\\n                unordered_set<int> st1,st2;\\n                while ((x1-1)>=0 && (y1-1)>=0){\\n                    st1.insert(grid[--x1][--y1]);\\n                    //x1--; y1--;\\n                }\\n                while ((x2+1)<n && (y2+1)<m){\\n                    st2.insert(grid[++x2][++y2]);\\n                    //x2++; y2++;\\n                }\\n                ans[i][j]= (st1.size()-st2.size());\\n                ans[i][j]= abs(ans[i][j]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Matrix",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                int x1=i,y1=j,x2=i,y2=j;\\n                unordered_set<int> st1,st2;\\n                while ((x1-1)>=0 && (y1-1)>=0){\\n                    st1.insert(grid[--x1][--y1]);\\n                    //x1--; y1--;\\n                }\\n                while ((x2+1)<n && (y2+1)<m){\\n                    st2.insert(grid[++x2][++y2]);\\n                    //x2++; y2++;\\n                }\\n                ans[i][j]= (st1.size()-st2.size());\\n                ans[i][j]= abs(ans[i][j]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576150,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        answer=[[0 for j in range(len(grid[0]))]for i in range(len(grid))]\\n        \\n        def topleft(i,j):\\n            set1=set()\\n            while i>=0 and j>=0:\\n                set1.add(grid[i][j])\\n                i-=1\\n                j-=1\\n                \\n            return len(set1)\\n                \\n        def bottomright(i,j):\\n            set2=set()\\n            \\n            while i<len(grid) and j<len(grid[0]):\\n                set2.add(grid[i][j])\\n                i+=1\\n                j+=1\\n                \\n            return len(set2)\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                answer[i][j]=abs(topleft(i-1,j-1)-bottomright(i+1,j+1))\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        answer=[[0 for j in range(len(grid[0]))]for i in range(len(grid))]\\n        \\n        def topleft(i,j):\\n            set1=set()\\n            while i>=0 and j>=0:\\n                set1.add(grid[i][j])\\n                i-=1\\n                j-=1\\n                \\n            return len(set1)\\n                \\n        def bottomright(i,j):\\n            set2=set()\\n            \\n            while i<len(grid) and j<len(grid[0]):\\n                set2.add(grid[i][j])\\n                i+=1\\n                j+=1\\n                \\n            return len(set2)\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                answer[i][j]=abs(topleft(i-1,j-1)-bottomright(i+1,j+1))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576085,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n         \\n        int N = grid.length;\\n        int M = grid[0].length;\\n        int res[][] = new int[N][M];\\n        for(int i=0; i<N; i++) {\\n            for(int j=0; j<M; j++) {\\n                Set<Integer>topLeft = new HashSet<>();\\n                for(int x=i-1, y=j-1; x>=0 && y>=0 ; x--, y--) {\\n                    topLeft.add(grid[x][y]);\\n                }\\n                \\n                Set<Integer>bottomRight = new HashSet<>();\\n                for(int x=i+1, y=j+1; x<N && y<M ; x++, y++) {\\n                    bottomRight.add(grid[x][y]);\\n                }\\n                res[i][j] = Math.abs(topLeft.size()-bottomRight.size());\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n         \\n        int N = grid.length;\\n        int M = grid[0].length;\\n        int res[][] = new int[N][M];\\n        for(int i=0; i<N; i++) {\\n            for(int j=0; j<M; j++) {\\n                Set<Integer>topLeft = new HashSet<>();\\n                for(int x=i-1, y=j-1; x>=0 && y>=0 ; x--, y--) {\\n                    topLeft.add(grid[x][y]);\\n                }\\n                \\n                Set<Integer>bottomRight = new HashSet<>();\\n                for(int x=i+1, y=j+1; x<N && y<M ; x++, y++) {\\n                    bottomRight.add(grid[x][y]);\\n                }\\n                res[i][j] = Math.abs(topLeft.size()-bottomRight.size());\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576060,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) use the past to formulate the future, ie. we reduce asymptotic bounds via prefix and suffix 64-bit integer representation of a set of values from `0..50` inclusive for each diagonal from top-left-to-bottom-right and bottom-right-to-top-left as `L` and `R` correspondingly.\\n\\nLet `f` be a function which counts the bits of each 64-bit integer representation of a set.\\nLet `g` be a function which calculates the absolute difference between the cardinality of sets.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun differenceOfDistinctValues(A: Array<IntArray>): Array<IntArray> {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var L = Array(M){ LongArray(N){ 0L } }\\n        var R = Array(M){ LongArray(N){ 0L } }\\n        for (i in 0 until M) {\\n            var u = M - 1 - i\\n            for (j in 0 until N) {\\n                var v = N - 1 - j\\n                L[i][j] = (1L shl A[i][j]) or (if (0 <= i - 1 && 0 <= j - 1) L[i - 1][j - 1] else 0)\\n                R[u][v] = (1L shl A[u][v]) or (if (u + 1 < M && v + 1 < N) R[u + 1][v + 1] else 0)\\n            }\\n        }\\n        var f = { dp: Array<LongArray>, i: Int, j: Int -> if (0 <= i && i < M && 0 <= j && j < N) dp[i][j].toString(2).toCharArray().filter{ it == \\'1\\' }.size else 0 }\\n        var g = { i: Int, j: Int -> Math.abs(f(L, i - 1, j - 1) - f(R, i + 1, j + 1)) }\\n        return (0 until M).map{ i -> (0 until N).map{ j -> g(i, j) }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, A: List[List[int]], T = 50) -> List[List[int]]:\\n        M, N = len(A), len(A[0])\\n        L = [[0] * N for _ in range(M)]\\n        R = [[0] * N for _ in range(M)]\\n        for i in range(M):\\n            u = M - 1 - i\\n            for j in range(N):\\n                v = N - 1 - j\\n                L[i][j] |= (1 << A[i][j]) | (L[i - 1][j - 1] if i and j else 0)\\n                R[u][v] |= (1 << A[u][v]) | (R[u + 1][v + 1] if u + 1 < M and v + 1 < N else 0)\\n        f = lambda dp, i, j: len([c for c in bin(dp[i][j])[2:] if c == \\'1\\']) if 0 <= i < M and 0 <= j < N else 0\\n        g = lambda i, j: abs(f(L, i - 1, j - 1) - f(R, i + 1, j + 1))\\n        return [[g(i, j) for j in range(N)] for i in range(M)]\\n```\\n\\n---\\n\\n**Brute-Force solutions:**\\n\\n\\u2B50\\uFE0F Actually, the DP solutions above are silly, since we end up iterating through all 50 bits anyhow, so we might as well just brute-force this!\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun differenceOfDistinctValues(A: Array<IntArray>): Array<IntArray> {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        fun f(i: Int, j: Int): Int {\\n            var (L, R) = Pair(mutableSetOf<Int>(), mutableSetOf<Int>())\\n            var (u, v) = Pair(i - 1, j - 1); while (0 <= u && 0 <= v) L.add(A[u--][v--])\\n            var (x, y) = Pair(i + 1, j + 1); while (x < M && y < N) R.add(A[x++][y++])\\n            return Math.abs(L.size - R.size)\\n        }\\n        return (0 until M).map{ i -> (0 until N).map{ j -> f(i, j) }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet differenceOfDistinctValues = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let ans = [...Array(M)].map(_ => Array(N));\\n    let f = (i, j) => {\\n        let [L, R] = [new Set(), new Set()];\\n        for (let u = i - 1, v = j - 1; 0 <= u && 0 <= v; L.add(A[u--][v--]));\\n        for (let u = i + 1, v = j + 1; u < M && v < N; R.add(A[u++][v++]));\\n        return Math.abs(L.size - R.size);\\n    }\\n    return _.range(0, M).map(i => _.range(0, N).map(j => f(i, j)))\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, A: List[List[int]]) -> List[List[int]]:\\n        M, N = len(A), len(A[0])\\n        def f(i, j):\\n            L, R = set(), set()\\n            u, v = i - 1, j - 1\\n            while 0 <= u and 0 <= v: L.add(A[u][v]); u -= 1; v -= 1\\n            u, v = i + 1, j + 1\\n            while u < M and v < N: R.add(A[u][v]); u += 1; v += 1\\n            return abs(len(L) - len(R))\\n        return [[f(i, j) for j in range(N)] for i in range(M)]\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn difference_of_distinct_values(A: VVI) -> VVI {\\n        let (M, N) = (A.len() as i32, A[0].len() as i32);\\n        fn f(A: &VVI, i: i32, j: i32) -> i32 {\\n            let (M, N) = (A.len() as i32, A[0].len() as i32);\\n            let (mut L, mut R) = (HashSet::new(), HashSet::new());\\n            let (mut u, mut v) = (i - 1, j - 1); while 0 <= u && 0 <= v { L.insert(&A[u as usize][v as usize]); u -= 1; v -= 1; }\\n            let (mut u, mut v) = (i + 1, j + 1); while u < M && v < N { R.insert(&A[u as usize][v as usize]); u += 1; v += 1; }\\n            (L.len() as i32 - R.len() as i32).abs()\\n        }\\n        (0..M).map(|i| (0..N).map(|j| f(&A, i, j)).collect::<VI>()).collect::<VVI>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    VVI differenceOfDistinctValues(VVI& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto f = [&](auto i, auto j) {\\n            Set L, R;\\n            for (auto u{ i - 1 }, v{ j - 1 }; 0 <= u && 0 <= v; L.insert(A[u--][v--]));\\n            for (auto u{ i + 1 }, v{ j + 1 }; u < M && v < N; R.insert(A[u++][v++]));\\n            return abs(int(L.size()) - int(R.size()));\\n        };\\n        VVI ans(M, VI(N));\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                ans[i][j] = f(i, j);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun differenceOfDistinctValues(A: Array<IntArray>): Array<IntArray> {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var L = Array(M){ LongArray(N){ 0L } }\\n        var R = Array(M){ LongArray(N){ 0L } }\\n        for (i in 0 until M) {\\n            var u = M - 1 - i\\n            for (j in 0 until N) {\\n                var v = N - 1 - j\\n                L[i][j] = (1L shl A[i][j]) or (if (0 <= i - 1 && 0 <= j - 1) L[i - 1][j - 1] else 0)\\n                R[u][v] = (1L shl A[u][v]) or (if (u + 1 < M && v + 1 < N) R[u + 1][v + 1] else 0)\\n            }\\n        }\\n        var f = { dp: Array<LongArray>, i: Int, j: Int -> if (0 <= i && i < M && 0 <= j && j < N) dp[i][j].toString(2).toCharArray().filter{ it == \\'1\\' }.size else 0 }\\n        var g = { i: Int, j: Int -> Math.abs(f(L, i - 1, j - 1) - f(R, i + 1, j + 1)) }\\n        return (0 until M).map{ i -> (0 until N).map{ j -> g(i, j) }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, A: List[List[int]], T = 50) -> List[List[int]]:\\n        M, N = len(A), len(A[0])\\n        L = [[0] * N for _ in range(M)]\\n        R = [[0] * N for _ in range(M)]\\n        for i in range(M):\\n            u = M - 1 - i\\n            for j in range(N):\\n                v = N - 1 - j\\n                L[i][j] |= (1 << A[i][j]) | (L[i - 1][j - 1] if i and j else 0)\\n                R[u][v] |= (1 << A[u][v]) | (R[u + 1][v + 1] if u + 1 < M and v + 1 < N else 0)\\n        f = lambda dp, i, j: len([c for c in bin(dp[i][j])[2:] if c == \\'1\\']) if 0 <= i < M and 0 <= j < N else 0\\n        g = lambda i, j: abs(f(L, i - 1, j - 1) - f(R, i + 1, j + 1))\\n        return [[g(i, j) for j in range(N)] for i in range(M)]\\n```\n```\\nclass Solution {\\n    fun differenceOfDistinctValues(A: Array<IntArray>): Array<IntArray> {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        fun f(i: Int, j: Int): Int {\\n            var (L, R) = Pair(mutableSetOf<Int>(), mutableSetOf<Int>())\\n            var (u, v) = Pair(i - 1, j - 1); while (0 <= u && 0 <= v) L.add(A[u--][v--])\\n            var (x, y) = Pair(i + 1, j + 1); while (x < M && y < N) R.add(A[x++][y++])\\n            return Math.abs(L.size - R.size)\\n        }\\n        return (0 until M).map{ i -> (0 until N).map{ j -> f(i, j) }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\n```\\nlet differenceOfDistinctValues = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let ans = [...Array(M)].map(_ => Array(N));\\n    let f = (i, j) => {\\n        let [L, R] = [new Set(), new Set()];\\n        for (let u = i - 1, v = j - 1; 0 <= u && 0 <= v; L.add(A[u--][v--]));\\n        for (let u = i + 1, v = j + 1; u < M && v < N; R.add(A[u++][v++]));\\n        return Math.abs(L.size - R.size);\\n    }\\n    return _.range(0, M).map(i => _.range(0, N).map(j => f(i, j)))\\n};\\n```\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, A: List[List[int]]) -> List[List[int]]:\\n        M, N = len(A), len(A[0])\\n        def f(i, j):\\n            L, R = set(), set()\\n            u, v = i - 1, j - 1\\n            while 0 <= u and 0 <= v: L.add(A[u][v]); u -= 1; v -= 1\\n            u, v = i + 1, j + 1\\n            while u < M and v < N: R.add(A[u][v]); u += 1; v += 1\\n            return abs(len(L) - len(R))\\n        return [[f(i, j) for j in range(N)] for i in range(M)]\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn difference_of_distinct_values(A: VVI) -> VVI {\\n        let (M, N) = (A.len() as i32, A[0].len() as i32);\\n        fn f(A: &VVI, i: i32, j: i32) -> i32 {\\n            let (M, N) = (A.len() as i32, A[0].len() as i32);\\n            let (mut L, mut R) = (HashSet::new(), HashSet::new());\\n            let (mut u, mut v) = (i - 1, j - 1); while 0 <= u && 0 <= v { L.insert(&A[u as usize][v as usize]); u -= 1; v -= 1; }\\n            let (mut u, mut v) = (i + 1, j + 1); while u < M && v < N { R.insert(&A[u as usize][v as usize]); u += 1; v += 1; }\\n            (L.len() as i32 - R.len() as i32).abs()\\n        }\\n        (0..M).map(|i| (0..N).map(|j| f(&A, i, j)).collect::<VI>()).collect::<VVI>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    VVI differenceOfDistinctValues(VVI& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto f = [&](auto i, auto j) {\\n            Set L, R;\\n            for (auto u{ i - 1 }, v{ j - 1 }; 0 <= u && 0 <= v; L.insert(A[u--][v--]));\\n            for (auto u{ i + 1 }, v{ j + 1 }; u < M && v < N; R.insert(A[u++][v++]));\\n            return abs(int(L.size()) - int(R.size()));\\n        };\\n        VVI ans(M, VI(N));\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                ans[i][j] = f(i, j);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575843,
                "title": "java-brute-force-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int[][]ans=new int[m][n];\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            int r=i-1,c=j-1;\\n            HashSet<Integer>s1=new HashSet<>();\\n            HashSet<Integer>s2=new HashSet<>();\\n            while(r>=0 && c>=0)s1.add(grid[r--][c--]);\\n            r=i+1;c=j+1;\\n            while(r<m && c<n)s2.add(grid[r++][c++]);\\n            ans[i][j]=Math.abs(s1.size()-s2.size());\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int[][]ans=new int[m][n];\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            int r=i-1,c=j-1;\\n            HashSet<Integer>s1=new HashSet<>();\\n            HashSet<Integer>s2=new HashSet<>();\\n            while(r>=0 && c>=0)s1.add(grid[r--][c--]);\\n            r=i+1;c=j+1;\\n            while(r<m && c<n)s2.add(grid[r++][c++]);\\n            ans[i][j]=Math.abs(s1.size()-s2.size());\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575803,
                "title": "map-c-faster-than-100",
                "content": "***beggars can be choosers if we talk about coding***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>grid,answer;\\n    int m,n;\\n    void setter(int x,int y){\\n        int i=x,j=y;\\n        unordered_map<int,int>topleft,bottomright;\\n        while(i<m&&j<n){\\n            bottomright[grid[i++][j++]]++;\\n        }i=x,j=y;\\n        while(i<m&&j<n){\\n            bottomright[grid[i][j]]--;if(bottomright[grid[i][j]]==0)bottomright.erase(grid[i][j]);\\n            answer[i][j]=abs((int)topleft.size()-(int)bottomright.size());\\n            topleft[grid[i++][j++]]++;\\n        }\\n    }\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        this->grid=grid;this->m=grid.size();this->n=grid[0].size();\\n        answer.assign(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)setter(i,0);\\n        for(int j=1;j<n;j++)setter(0,j);\\n        return answer;\\n    }\\n};\\n```\\n**logik**\\n1. for each index (x,y) in matrix , the diagonal is of the form (x++,y++) till x or y is out of range \\n2. map will store the number of unique numbers \\n3.for each index we will first make 2 maps , top left initally empty and bottom right initially filled with all the diagonal elements\\n4. now while(x<m and y<n) x++,y++ and at each step , remove the element from the bottom right map, put answer(x,y) as absolute of no of elements in leftmap- no of elements in the right map\\n5. put the removed element in the topleft map \\n6. continue for each element in 0th row and 0th column \\n![image](https://assets.leetcode.com/users/images/b02bd4a8-2b91-45fa-8fd4-0cea4bc97235_1685372437.1256337.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>grid,answer;\\n    int m,n;\\n    void setter(int x,int y){\\n        int i=x,j=y;\\n        unordered_map<int,int>topleft,bottomright;\\n        while(i<m&&j<n){\\n            bottomright[grid[i++][j++]]++;\\n        }i=x,j=y;\\n        while(i<m&&j<n){\\n            bottomright[grid[i][j]]--;if(bottomright[grid[i][j]]==0)bottomright.erase(grid[i][j]);\\n            answer[i][j]=abs((int)topleft.size()-(int)bottomright.size());\\n            topleft[grid[i++][j++]]++;\\n        }\\n    }\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        this->grid=grid;this->m=grid.size();this->n=grid[0].size();\\n        answer.assign(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)setter(i,0);\\n        for(int j=1;j<n;j++)setter(0,j);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575734,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        return [ [abs(\\n            len(set(grid[x][y] for x, y in zip(range(i-1, -1, -1), range(j-1, -1, -1)))) -\\n            len(set(grid[x][y] for x, y in zip(range(i+1, len(grid)), range(j+1, len(grid[0])))))\\n            ) for j in range(len(grid[0]))] for i in range(len(grid)) ]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        return [ [abs(\\n            len(set(grid[x][y] for x, y in zip(range(i-1, -1, -1), range(j-1, -1, -1)))) -\\n            len(set(grid[x][y] for x, y in zip(range(i+1, len(grid)), range(j+1, len(grid[0])))))\\n            ) for j in range(len(grid[0]))] for i in range(len(grid)) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575276,
                "title": "very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n\\t{\\n\\t\\t//final ans to be returned from the function\\n\\t\\t\\tvector<vector<int>>ans(grid.size(),vector<int>(grid[0].size(),-1));\\n\\t\\t\\t\\n\\t\\t//traversing through the matrix to generate ans for all the cells\\n\\t\\tfor(int i=0;i<grid.size();i++)\\n\\t\\t{\\n\\t\\t\\t\\tint row = i;\\n\\t\\t\\t\\t\\tfor(int j=0;j<grid[i].size();j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint col = j;\\n\\t\\t\\t\\t\\t\\tunordered_map<int,int>upper_left   = getupperleft(grid,row-1,col-1);\\n\\t\\t\\t\\t\\t\\tunordered_map<int,int>bottom_right = getbottomright(grid,row+1,col+1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tint temp = upper_left.size() - bottom_right.size();\\n\\t\\t\\t\\t\\t\\tans[i][j] = abs(temp); \\n\\t\\t\\t\\t}\\t\\n\\t\\t}        \\n\\t\\treturn ans;\\n\\t}\\n\\t\\tunordered_map<int,int> getupperleft(vector<vector<int>>&mat,int row,int col)\\n\\t\\t{\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\twhile(row>=0 and row<mat.size() and col>=0 and col<mat[0].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ele = mat[row][col];\\n\\t\\t\\t\\tmp[ele]++;\\n\\t\\t\\t\\trow--;\\n\\t\\t\\t\\tcol--;\\n\\t\\t\\t}\\n\\t\\t\\treturn mp;\\n\\t\\t}\\n\\t\\tunordered_map<int,int> getbottomright(vector<vector<int>>&mat,int row,int col)\\n\\t\\t{\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\twhile(row>=0 and row<mat.size() and col>=0 and col<mat[0].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ele = mat[row][col];\\n\\t\\t\\t\\tmp[ele]++;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t}\\n\\t\\t\\treturn mp;\\n\\t\\t}\\n\\t\\t\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n\\t{\\n\\t\\t//final ans to be returned from the function\\n\\t\\t\\tvector<vector<int>>ans(grid.size(),vector<int>(grid[0].size(),-1));\\n\\t\\t\\t\\n\\t\\t//traversing through the matrix to generate ans for all the cells\\n\\t\\tfor(int i=0;i<grid.size();i++)\\n\\t\\t{\\n\\t\\t\\t\\tint row = i;\\n\\t\\t\\t\\t\\tfor(int j=0;j<grid[i].size();j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint col = j;\\n\\t\\t\\t\\t\\t\\tunordered_map<int,int>upper_left   = getupperleft(grid,row-1,col-1);\\n\\t\\t\\t\\t\\t\\tunordered_map<int,int>bottom_right = getbottomright(grid,row+1,col+1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tint temp = upper_left.size() - bottom_right.size();\\n\\t\\t\\t\\t\\t\\tans[i][j] = abs(temp); \\n\\t\\t\\t\\t}\\t\\n\\t\\t}        \\n\\t\\treturn ans;\\n\\t}\\n\\t\\tunordered_map<int,int> getupperleft(vector<vector<int>>&mat,int row,int col)\\n\\t\\t{\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\twhile(row>=0 and row<mat.size() and col>=0 and col<mat[0].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ele = mat[row][col];\\n\\t\\t\\t\\tmp[ele]++;\\n\\t\\t\\t\\trow--;\\n\\t\\t\\t\\tcol--;\\n\\t\\t\\t}\\n\\t\\t\\treturn mp;\\n\\t\\t}\\n\\t\\tunordered_map<int,int> getbottomright(vector<vector<int>>&mat,int row,int col)\\n\\t\\t{\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\twhile(row>=0 and row<mat.size() and col>=0 and col<mat[0].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ele = mat[row][col];\\n\\t\\t\\t\\tmp[ele]++;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t}\\n\\t\\t\\treturn mp;\\n\\t\\t}\\n\\t\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575199,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vector<vector<int>>ans;\\n        ans.resize(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans[i][j]=abs(top_left(grid,i,j)-bottom_right(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n    int top_left(vector<vector<int>>&grid,int &r,int &c)\\n    {\\n        int r1=r-1;\\n        int c1=c-1;\\n        unordered_set<int>st;\\n        while(r1>=0 and c1>=0)\\n        {\\n            st.insert(grid[r1][c1]);\\n            r1--;\\n            c1--;\\n        }\\n        return st.size();\\n    }\\n    int bottom_right(vector<vector<int>>&grid,int &r,int &c)\\n    {\\n        int r1=r+1;\\n        int c1=c+1;\\n        unordered_set<int>st;\\n        while(r1<m and c1<n)\\n        {\\n            st.insert(grid[r1][c1]);\\n            r1++;\\n            c1++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vector<vector<int>>ans;\\n        ans.resize(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans[i][j]=abs(top_left(grid,i,j)-bottom_right(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n    int top_left(vector<vector<int>>&grid,int &r,int &c)\\n    {\\n        int r1=r-1;\\n        int c1=c-1;\\n        unordered_set<int>st;\\n        while(r1>=0 and c1>=0)\\n        {\\n            st.insert(grid[r1][c1]);\\n            r1--;\\n            c1--;\\n        }\\n        return st.size();\\n    }\\n    int bottom_right(vector<vector<int>>&grid,int &r,int &c)\\n    {\\n        int r1=r+1;\\n        int c1=c+1;\\n        unordered_set<int>st;\\n        while(r1<m and c1<n)\\n        {\\n            st.insert(grid[r1][c1]);\\n            r1++;\\n            c1++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574893,
                "title": "java-beats-100-optimal-solution-o-mn-easy-explanation-beginner-friendly",
                "content": "\\n# Approach\\nIterating through a diagonal and storing the distinct elements encountered before it using HashSet, **First top-right to bottom-left , then using the same approach bottom-right to top-left**.But while iterating second time we take the difference and store it for ans.\\n\\n# Complexity\\n- Time complexity: **O(mn)**\\n\\n- Space complexity: **O(mn)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] ans=new int[m][n];\\n        //top row elements iterating to bottom right\\n        for(int i=0;i<n;i++){\\n            helper(0,i,true,grid,ans);\\n        }\\n        //left column elements iterating to bottom right\\n        for(int i=1;i<m;i++){\\n            helper(i,0,true,grid,ans);\\n        }\\n        //bottom row elements iterating to top left\\n        for(int i=0;i<n;i++){\\n            helper(m-1,i,false,grid,ans);\\n        }\\n        //right column elements iterating to top left\\n        for(int i=0;i<m-1;i++){\\n            helper(i,n-1,false,grid,ans);\\n        }\\n        return ans;\\n    }\\n    public void helper(int row,int col,boolean add,int[][] grid,int[][] ans){\\n        //adding elements to set and storing the size as it gives the size of previously found distinct elements\\n        Set<Integer> set=new HashSet();\\n\\n        if(add){\\n            //storing the size of set and then adding element to the set while traversing to bottom right\\n            while(row<grid.length && col<grid[0].length ){\\n                ans[row][col]=set.size();\\n                set.add(grid[row++][col++]);\\n            }\\n        }else{\\n        //storing the size of set and then adding element to the set while traversing to top left\\n        //Taking Mod difference and storing it in ans\\n            while(row>=0 && col>=0){\\n                ans[row][col]= Math.abs(set.size()-ans[row][col]);\\n                set.add(grid[row--][col--]);\\n            }\\n        }\\n    }\\n}\\n```\\n# Code Without Comments\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] ans=new int[m][n];\\n        for(int i=0;i<n;i++){\\n            helper(0,i,true,grid,ans);\\n        }\\n        for(int i=1;i<m;i++){\\n            helper(i,0,true,grid,ans);\\n        }\\n        for(int i=0;i<n;i++){\\n            helper(m-1,i,false,grid,ans);\\n        }\\n        for(int i=0;i<m-1;i++){\\n            helper(i,n-1,false,grid,ans);\\n        }\\n        return ans;\\n    }\\n    public void helper(int row,int col,boolean add,int[][] grid,int[][] ans){\\n        Set<Integer> set=new HashSet();\\n        if(add){\\n            while(row<grid.length && col<grid[0].length ){\\n                ans[row][col]=set.size();\\n                set.add(grid[row++][col++]);\\n            }\\n        }else{\\n            while(row>=0 && col>=0){\\n                ans[row][col]= Math.abs(set.size()-ans[row][col]);\\n                set.add(grid[row--][col--]);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] ans=new int[m][n];\\n        //top row elements iterating to bottom right\\n        for(int i=0;i<n;i++){\\n            helper(0,i,true,grid,ans);\\n        }\\n        //left column elements iterating to bottom right\\n        for(int i=1;i<m;i++){\\n            helper(i,0,true,grid,ans);\\n        }\\n        //bottom row elements iterating to top left\\n        for(int i=0;i<n;i++){\\n            helper(m-1,i,false,grid,ans);\\n        }\\n        //right column elements iterating to top left\\n        for(int i=0;i<m-1;i++){\\n            helper(i,n-1,false,grid,ans);\\n        }\\n        return ans;\\n    }\\n    public void helper(int row,int col,boolean add,int[][] grid,int[][] ans){\\n        //adding elements to set and storing the size as it gives the size of previously found distinct elements\\n        Set<Integer> set=new HashSet();\\n\\n        if(add){\\n            //storing the size of set and then adding element to the set while traversing to bottom right\\n            while(row<grid.length && col<grid[0].length ){\\n                ans[row][col]=set.size();\\n                set.add(grid[row++][col++]);\\n            }\\n        }else{\\n        //storing the size of set and then adding element to the set while traversing to top left\\n        //Taking Mod difference and storing it in ans\\n            while(row>=0 && col>=0){\\n                ans[row][col]= Math.abs(set.size()-ans[row][col]);\\n                set.add(grid[row--][col--]);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] ans=new int[m][n];\\n        for(int i=0;i<n;i++){\\n            helper(0,i,true,grid,ans);\\n        }\\n        for(int i=1;i<m;i++){\\n            helper(i,0,true,grid,ans);\\n        }\\n        for(int i=0;i<n;i++){\\n            helper(m-1,i,false,grid,ans);\\n        }\\n        for(int i=0;i<m-1;i++){\\n            helper(i,n-1,false,grid,ans);\\n        }\\n        return ans;\\n    }\\n    public void helper(int row,int col,boolean add,int[][] grid,int[][] ans){\\n        Set<Integer> set=new HashSet();\\n        if(add){\\n            while(row<grid.length && col<grid[0].length ){\\n                ans[row][col]=set.size();\\n                set.add(grid[row++][col++]);\\n            }\\n        }else{\\n            while(row>=0 && col>=0){\\n                ans[row][col]= Math.abs(set.size()-ans[row][col]);\\n                set.add(grid[row--][col--]);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574811,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMATRIX\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMATRIX\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n# Code\\n```\\nclass Solution {\\n    public static int findarrayWithDuplicates(int arrayWithDuplicates[],int k)\\n    {\\n         HashMap<Integer,Integer> hashmap = new HashMap<Integer,Integer>();   \\n          \\n        //use for loop to pull the elements of array to hashmap\\'s key  \\n        for (int j = 0; j <k; j++) {   \\n            hashmap.put(arrayWithDuplicates[j], j);   \\n        }   \\n        \\n        return hashmap.size();\\n    }\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n     \\n     int topleft[]=new int[grid.length];  \\n     int topright[]=new int[grid.length];  \\n        int k=0;\\n        int b=0;\\n     int mat[][]=new int[grid.length][grid[0].length];   \\n     for(int i=0;i<grid.length;i++)\\n     {\\n         for(int j=0;j<grid[i].length;j++)\\n         {\\n             //System.out.println(grid[i][j]);\\n             //top left\\n             int p=i;\\n             int q=j;\\n             \\n             int l=i;\\n             int m=j;\\n             \\n             //\\n             while(p>=0&&q>=0)\\n             {\\n                 p--;\\n                 q--;\\n                 if(p>=0&&q>=0)\\n                 {    \\n                 // System.out.print(grid[p][q]+\"  \");\\n                  topleft[k++]=grid[p][q];   \\n                 }\\n                else\\n                   break;\\n             }\\n             \\n              while(l<grid.length&&m<grid[0].length)\\n             {\\n                 l++;\\n                 m++;\\n                 if(l<grid.length&&m<grid[0].length)\\n                 {    \\n                 // System.out.print(grid[p][q]+\"  \");\\n                  topright[b++]=grid[l][m];   \\n                 }\\n                else\\n                   break;\\n             }\\n             \\n             \\n             System.out.println(\"\");\\n            \\n             //top-left\\n             System.out.println(\"index \"+\"  \"+i+\"  \"+j);\\n             \\n             System.out.println(\"TOP LEFT\");\\n             for(int z=0;z<k;z++)\\n             {\\n                 System.out.print(topleft[z]+\" \");\\n             }\\n             \\n             System.out.println(\"\");\\n             \\n             //bottom-right\\n             System.out.println(\"BOTTOM RIGHT\");\\n             for(int z=0;z<b;z++)\\n             {\\n                 System.out.print(topright[z]+\" \");\\n             }\\n             \\n             int first=findarrayWithDuplicates(topright,b);\\n             int second=findarrayWithDuplicates(topleft,k);\\n             \\n             //System.out.println(first+\"  \"+second);\\n              k=0;\\n              b=0;\\n             \\n            // System.out.println(second-first);\\n             mat[i][j]=Math.abs(first-second);\\n             \\n             \\n         }\\n     }\\n        return mat;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int findarrayWithDuplicates(int arrayWithDuplicates[],int k)\\n    {\\n         HashMap<Integer,Integer> hashmap = new HashMap<Integer,Integer>();   \\n          \\n        //use for loop to pull the elements of array to hashmap\\'s key  \\n        for (int j = 0; j <k; j++) {   \\n            hashmap.put(arrayWithDuplicates[j], j);   \\n        }   \\n        \\n        return hashmap.size();\\n    }\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n     \\n     int topleft[]=new int[grid.length];  \\n     int topright[]=new int[grid.length];  \\n        int k=0;\\n        int b=0;\\n     int mat[][]=new int[grid.length][grid[0].length];   \\n     for(int i=0;i<grid.length;i++)\\n     {\\n         for(int j=0;j<grid[i].length;j++)\\n         {\\n             //System.out.println(grid[i][j]);\\n             //top left\\n             int p=i;\\n             int q=j;\\n             \\n             int l=i;\\n             int m=j;\\n             \\n             //\\n             while(p>=0&&q>=0)\\n             {\\n                 p--;\\n                 q--;\\n                 if(p>=0&&q>=0)\\n                 {    \\n                 // System.out.print(grid[p][q]+\"  \");\\n                  topleft[k++]=grid[p][q];   \\n                 }\\n                else\\n                   break;\\n             }\\n             \\n              while(l<grid.length&&m<grid[0].length)\\n             {\\n                 l++;\\n                 m++;\\n                 if(l<grid.length&&m<grid[0].length)\\n                 {    \\n                 // System.out.print(grid[p][q]+\"  \");\\n                  topright[b++]=grid[l][m];   \\n                 }\\n                else\\n                   break;\\n             }\\n             \\n             \\n             System.out.println(\"\");\\n            \\n             //top-left\\n             System.out.println(\"index \"+\"  \"+i+\"  \"+j);\\n             \\n             System.out.println(\"TOP LEFT\");\\n             for(int z=0;z<k;z++)\\n             {\\n                 System.out.print(topleft[z]+\" \");\\n             }\\n             \\n             System.out.println(\"\");\\n             \\n             //bottom-right\\n             System.out.println(\"BOTTOM RIGHT\");\\n             for(int z=0;z<b;z++)\\n             {\\n                 System.out.print(topright[z]+\" \");\\n             }\\n             \\n             int first=findarrayWithDuplicates(topright,b);\\n             int second=findarrayWithDuplicates(topleft,k);\\n             \\n             //System.out.println(first+\"  \"+second);\\n              k=0;\\n              b=0;\\n             \\n            // System.out.println(second-first);\\n             mat[i][j]=Math.abs(first-second);\\n             \\n             \\n         }\\n     }\\n        return mat;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574140,
                "title": "c-easy-solution-why-it-is-in-medium-category-unordered-set",
                "content": "\\n# Approach\\nAt every element go to its left diagonal and its right diagonal and compute the distinct elements using set..\\n\\nEasy Brute Force....\\n\\nI am also searching for optimised approach \\uD83E\\uDD72\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n,0));\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                unordered_set<int>s;\\n\\n                // For Traversing Left Diagonal\\n                int a=i, b=j;\\n                while(a-1>=0 && b-1>=0){\\n                    s.insert(grid[a-1][b-1]);\\n                    a--;\\n                    b--;\\n                }\\n                int left= s.size();\\n                s.clear();\\n\\n                // For Traversing Right Diagonal\\n                a=i;\\n                b=j;\\n                while(a+1<m && b+1<n){\\n                    s.insert(grid[a+1][b+1]);\\n                    a++;\\n                    b++;\\n                }\\n                int right=s.size();\\n                ans[i][j]= abs(left-right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>>ans(m, vector<int>(n,0));\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                unordered_set<int>s;\\n\\n                // For Traversing Left Diagonal\\n                int a=i, b=j;\\n                while(a-1>=0 && b-1>=0){\\n                    s.insert(grid[a-1][b-1]);\\n                    a--;\\n                    b--;\\n                }\\n                int left= s.size();\\n                s.clear();\\n\\n                // For Traversing Right Diagonal\\n                a=i;\\n                b=j;\\n                while(a+1<m && b+1<n){\\n                    s.insert(grid[a+1][b+1]);\\n                    a++;\\n                    b++;\\n                }\\n                int right=s.size();\\n                ans[i][j]= abs(left-right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574121,
                "title": "python3-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        r,c=len(grid),len(grid[0])\\n        \\n        def helper(a,b):\\n            \\n            a1,b1=a,b\\n            bottom=set()\\n            \\n            while a1+1<r and b1+1<c:\\n                bottom.add(grid[a1+1][b1+1])\\n                a1+=1\\n                b1+=1\\n            \\n            a2,b2=a,b\\n            top=set()\\n            \\n            while a2-1>=0 and b2-1>=0:\\n                top.add(grid[a2-1][b2-1])\\n                a2-=1\\n                b2-=1\\n            \\n            return abs(len(top)-len(bottom))\\n        \\n            \\n        ans=[[-1]*(c) for i in range(r)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                ans[i][j]=helper(i,j)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        \\n        r,c=len(grid),len(grid[0])\\n        \\n        def helper(a,b):\\n            \\n            a1,b1=a,b\\n            bottom=set()\\n            \\n            while a1+1<r and b1+1<c:\\n                bottom.add(grid[a1+1][b1+1])\\n                a1+=1\\n                b1+=1\\n            \\n            a2,b2=a,b\\n            top=set()\\n            \\n            while a2-1>=0 and b2-1>=0:\\n                top.add(grid[a2-1][b2-1])\\n                a2-=1\\n                b2-=1\\n            \\n            return abs(len(top)-len(bottom))\\n        \\n            \\n        ans=[[-1]*(c) for i in range(r)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                ans[i][j]=helper(i,j)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574056,
                "title": "python-solution-o-n-2-tc-simple-traverse-and-count",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        ans = [[None for _ in range(n)] for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n\\n                tL = set()\\n\\n                for r,c in zip(range(i-1,-1,-1), range(j-1,-1,-1)):\\n                    tL.add(grid[r][c])\\n\\n                bR = set()\\n\\n                for r,c in zip(range(i+1,m), range(j+1,n)):\\n                    bR.add(grid[r][c])\\n\\n                ans[i][j] = abs(\\n                    len(tL) - len(bR)\\n                )\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        ans = [[None for _ in range(n)] for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n\\n                tL = set()\\n\\n                for r,c in zip(range(i-1,-1,-1), range(j-1,-1,-1)):\\n                    tL.add(grid[r][c])\\n\\n                bR = set()\\n\\n                for r,c in zip(range(i+1,m), range(j+1,n)):\\n                    bR.add(grid[r][c])\\n\\n                ans[i][j] = abs(\\n                    len(tL) - len(bR)\\n                )\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573942,
                "title": "c-and-java-100-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe code is quite self explanatory.\\nMaintain prefix and suffix array for each diagonals counting the no of distinct elements\\nand ans=abs(pre[i-1][j-1]-suf[i+1][j+1])\\nno optimization as such just prefix - suffix will serve the job\\nsince the constraints are so small so this will work  effectively\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mx(n+50))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mxn)\\n\\n**PLS UPVOTE IF IT HELPED**\\n\\n# c++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int arr[51];\\n        vector<vector<int>> pre(m,vector<int>(n));\\n        vector<vector<int>> suf(m,vector<int>(n));\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int col=n-1;col>=0;col--){\\n            fill(arr,arr+51,0);\\n            int j=col+1;\\n            pre[0][col]=1;\\n            arr[grid[0][col]]=1;\\n            for(int i=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=1;row<m;row++){\\n            fill(arr,arr+51,0);\\n            int i=row+1;\\n            pre[row][0]=1;\\n            arr[grid[row][0]]=1;\\n            for(int j=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=0;row<m;row++){\\n            fill(arr,arr+51,0);\\n            int i=row-1;\\n            suf[row][n-1]=1;\\n            arr[grid[row][n-1]]=1;\\n            for(int j=n-2;i>=0 && j>=0;i--,j--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int col=n-2;col>=0;col--){\\n            fill(arr,arr+51,0);\\n            int j=col-1;\\n            suf[m-1][col]=1;\\n            arr[grid[m-1][col]]=1;\\n            for(int i=m-2;i>=0 && j>=0;j--,i--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a=0,b=0;\\n                if(i>0 && j>0){\\n                    a=pre[i-1][j-1];\\n                }\\n                if(i<m-1 && j<n-1){\\n                    b=suf[i+1][j+1];\\n                }\\n                ans[i][j]=abs(a-b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int [][] pre=new int[m][n];\\n        int [][] suf=new int[m][n];\\n        int [][] ans=new int[m][n];\\n        for(int col=n-1;col>=0;col--){\\n            int[] arr=new int[51];\\n            int j=col+1;\\n            pre[0][col]=1;\\n            arr[grid[0][col]]=1;\\n            for(int i=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=1;row<m;row++){\\n            int[] arr=new int[51];\\n            int i=row+1;\\n            pre[row][0]=1;\\n            arr[grid[row][0]]=1;\\n            for(int j=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=0;row<m;row++){\\n            int[] arr=new int[51];\\n            int i=row-1;\\n            suf[row][n-1]=1;\\n            arr[grid[row][n-1]]=1;\\n            for(int j=n-2;i>=0 && j>=0;i--,j--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int col=n-2;col>=0;col--){\\n            int[] arr=new int[51];\\n            int j=col-1;\\n            suf[m-1][col]=1;\\n            arr[grid[m-1][col]]=1;\\n            for(int i=m-2;i>=0 && j>=0;j--,i--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a=0,b=0;\\n                if(i>0 && j>0){\\n                    a=pre[i-1][j-1];\\n                }\\n                if(i<m-1 && j<n-1){\\n                    b=suf[i+1][j+1];\\n                }\\n                ans[i][j]=Math.abs(a-b);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int arr[51];\\n        vector<vector<int>> pre(m,vector<int>(n));\\n        vector<vector<int>> suf(m,vector<int>(n));\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int col=n-1;col>=0;col--){\\n            fill(arr,arr+51,0);\\n            int j=col+1;\\n            pre[0][col]=1;\\n            arr[grid[0][col]]=1;\\n            for(int i=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=1;row<m;row++){\\n            fill(arr,arr+51,0);\\n            int i=row+1;\\n            pre[row][0]=1;\\n            arr[grid[row][0]]=1;\\n            for(int j=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=0;row<m;row++){\\n            fill(arr,arr+51,0);\\n            int i=row-1;\\n            suf[row][n-1]=1;\\n            arr[grid[row][n-1]]=1;\\n            for(int j=n-2;i>=0 && j>=0;i--,j--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int col=n-2;col>=0;col--){\\n            fill(arr,arr+51,0);\\n            int j=col-1;\\n            suf[m-1][col]=1;\\n            arr[grid[m-1][col]]=1;\\n            for(int i=m-2;i>=0 && j>=0;j--,i--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a=0,b=0;\\n                if(i>0 && j>0){\\n                    a=pre[i-1][j-1];\\n                }\\n                if(i<m-1 && j<n-1){\\n                    b=suf[i+1][j+1];\\n                }\\n                ans[i][j]=abs(a-b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int [][] pre=new int[m][n];\\n        int [][] suf=new int[m][n];\\n        int [][] ans=new int[m][n];\\n        for(int col=n-1;col>=0;col--){\\n            int[] arr=new int[51];\\n            int j=col+1;\\n            pre[0][col]=1;\\n            arr[grid[0][col]]=1;\\n            for(int i=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=1;row<m;row++){\\n            int[] arr=new int[51];\\n            int i=row+1;\\n            pre[row][0]=1;\\n            arr[grid[row][0]]=1;\\n            for(int j=1;i<m && j<n;j++,i++){\\n                pre[i][j]=pre[i-1][j-1];\\n                if(arr[grid[i][j]]==0) pre[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int row=0;row<m;row++){\\n            int[] arr=new int[51];\\n            int i=row-1;\\n            suf[row][n-1]=1;\\n            arr[grid[row][n-1]]=1;\\n            for(int j=n-2;i>=0 && j>=0;i--,j--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int col=n-2;col>=0;col--){\\n            int[] arr=new int[51];\\n            int j=col-1;\\n            suf[m-1][col]=1;\\n            arr[grid[m-1][col]]=1;\\n            for(int i=m-2;i>=0 && j>=0;j--,i--){\\n                suf[i][j]=suf[i+1][j+1];\\n                if(arr[grid[i][j]]==0) suf[i][j]++;\\n                arr[grid[i][j]]++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a=0,b=0;\\n                if(i>0 && j>0){\\n                    a=pre[i-1][j-1];\\n                }\\n                if(i<m-1 && j<n-1){\\n                    b=suf[i+1][j+1];\\n                }\\n                ans[i][j]=Math.abs(a-b);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573873,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int x=i-1,y=j-1;\\n                set<int>s1;\\n                while(x>=0 && y>=0){\\n                    \\n                    s1.insert(grid[x][y]);\\n                    x--,y--;\\n                }\\n            \\n                 x=i+1,y=j+1;\\n                set<int>s2;\\n                while(x<n && y<m){\\n                   s2.insert(grid[x][y]);\\n                    x++,y++;\\n                }\\n                int a=s1.size(),b=s2.size();\\n                ans[i][j]=abs(a-b);\\n            }\\n        }return ans;\\n    }\\n};\\n```\\n**Please, UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int x=i-1,y=j-1;\\n                set<int>s1;\\n                while(x>=0 && y>=0){\\n                    \\n                    s1.insert(grid[x][y]);\\n                    x--,y--;\\n                }\\n            \\n                 x=i+1,y=j+1;\\n                set<int>s2;\\n                while(x<n && y<m){\\n                   s2.insert(grid[x][y]);\\n                    x++,y++;\\n                }\\n                int a=s1.size(),b=s2.size();\\n                ans[i][j]=abs(a-b);\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573727,
                "title": "python3-process-diagonals-with-prefix-suffix-set",
                "content": "# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        answer = [[0] * n for _ in range(m)]\\n        def calans(arr):\\n            prefix, suffix = [set()], [set()]\\n            for v in arr: prefix.append({v} | prefix[-1])\\n            for v in arr[::-1]: suffix.insert(0, {v} | suffix[0])\\n            return [abs(len(v1) - len(v2)) for v1, v2 in zip(prefix[:-1], suffix[1:])]\\n        def update(i, j):\\n            nonlocal m, n\\n            r, c, arr = i, j, []\\n            while r < m and c < n:\\n                arr.append(grid[r][c])\\n                r += 1\\n                c += 1\\n            arr = calans(arr)\\n            r, c, k = i, j, 0\\n            while r < m and c < n:\\n                answer[r][c] = arr[k]\\n                r += 1\\n                c += 1\\n                k += 1\\n        for r in range(m): update(r, 0)\\n        for c in range(1, n): update(0, c)\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        answer = [[0] * n for _ in range(m)]\\n        def calans(arr):\\n            prefix, suffix = [set()], [set()]\\n            for v in arr: prefix.append({v} | prefix[-1])\\n            for v in arr[::-1]: suffix.insert(0, {v} | suffix[0])\\n            return [abs(len(v1) - len(v2)) for v1, v2 in zip(prefix[:-1], suffix[1:])]\\n        def update(i, j):\\n            nonlocal m, n\\n            r, c, arr = i, j, []\\n            while r < m and c < n:\\n                arr.append(grid[r][c])\\n                r += 1\\n                c += 1\\n            arr = calans(arr)\\n            r, c, k = i, j, 0\\n            while r < m and c < n:\\n                answer[r][c] = arr[k]\\n                r += 1\\n                c += 1\\n                k += 1\\n        for r in range(m): update(r, 0)\\n        for c in range(1, n): update(0, c)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573678,
                "title": "using-set-in-c",
                "content": "\\n# Complexity\\n- Time complexity:The method iterates over each cell of the grid using nested loops, resulting in a time complexity of O(m * n), where m is the number of rows and n is the number of columns in the grid. Within the nested loops, for each cell, it performs two additional traversals of the diagonals, one for the top-left diagonal and one for the bottom-right diagonal. The size of the diagonals depends on the current cell\\'s position and the dimensions of the grid, but in the worst case, when the grid is a square matrix, the diagonal traversal will iterate up to the maximum size of the grid, which is max(m, n). Therefore, the overall time complexity of the method is O(m * n * max(m, n)).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:The method uses three additional 2D vectors, topLeft, bottomRight, and answer, to store the calculated values. Each of these vectors has the same dimensions as the input grid, resulting in a space complexity of O(m * n) to store the answer. Additionally, two unordered sets, topLeftDistinct and bottomRightDistinct, are used to store the distinct values in the diagonals for each cell. The size of these sets can vary depending on the input grid, but at most, they can hold min(m, n) distinct values. Hence, the space complexity for these sets is O(min(m, n)). Therefore, the overall space complexity of the method is O(m * n + min(m, n)).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> topLeft(m, vector<int>(n));\\n        vector<vector<int>> bottomRight(m, vector<int>(n));\\n        vector<vector<int>> answer(m, vector<int>(n));\\n        \\n        // Calculate the topLeft and bottomRight values for each cell\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                unordered_set<int> topLeftDistinct;\\n                unordered_set<int> bottomRightDistinct;\\n                \\n                // Traverse the top-left diagonal\\n                for (int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--) {\\n                    topLeftDistinct.insert(grid[i][j]);\\n                }\\n                \\n                // Traverse the bottom-right diagonal\\n                for (int i = r+1, j = c+1; i < m && j < n; i++, j++) {\\n                    bottomRightDistinct.insert(grid[i][j]);\\n                }\\n                \\n                topLeft[r][c] = topLeftDistinct.size();\\n                bottomRight[r][c] = bottomRightDistinct.size();\\n                \\n                // Calculate the answer based on the difference\\n                answer[r][c] = abs(topLeft[r][c] - bottomRight[r][c]);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> topLeft(m, vector<int>(n));\\n        vector<vector<int>> bottomRight(m, vector<int>(n));\\n        vector<vector<int>> answer(m, vector<int>(n));\\n        \\n        // Calculate the topLeft and bottomRight values for each cell\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                unordered_set<int> topLeftDistinct;\\n                unordered_set<int> bottomRightDistinct;\\n                \\n                // Traverse the top-left diagonal\\n                for (int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--) {\\n                    topLeftDistinct.insert(grid[i][j]);\\n                }\\n                \\n                // Traverse the bottom-right diagonal\\n                for (int i = r+1, j = c+1; i < m && j < n; i++, j++) {\\n                    bottomRightDistinct.insert(grid[i][j]);\\n                }\\n                \\n                topLeft[r][c] = topLeftDistinct.size();\\n                bottomRight[r][c] = bottomRightDistinct.size();\\n                \\n                // Calculate the answer based on the difference\\n                answer[r][c] = abs(topLeft[r][c] - bottomRight[r][c]);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573350,
                "title": "python-easy-to-understand-o-mn",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def isValid(i,j):\\n            return 0<=i<m and 0<=j<n\\n        def search(i,j,di,dj,mat):\\n            curset = set()\\n            distinct = 0\\n            while isValid(i,j):\\n                curset.add(grid[i][j])\\n                mat[i][j] = len(curset)\\n                i += di \\n                j += dj\\n        TL = [[0]*n for _ in range(m)]\\n        BR = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            search(i,0,1,1,TL)\\n        for j in range(1,n):\\n            search(0,j,1,1,TL)\\n        for j in range(n):\\n            search(m-1,j,-1,-1,BR)\\n        for i in range(m-1):\\n            search(i,n-1,-1,-1,BR)\\n        res = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j] = abs((TL[i-1][j-1] if isValid(i-1,j-1) else 0) - (BR[i+1][j+1] if isValid(i+1,j+1) else 0))\\n        return res\\n\\n\\n                \\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def isValid(i,j):\\n            return 0<=i<m and 0<=j<n\\n        def search(i,j,di,dj,mat):\\n            curset = set()\\n            distinct = 0\\n            while isValid(i,j):\\n                curset.add(grid[i][j])\\n                mat[i][j] = len(curset)\\n                i += di \\n                j += dj\\n        TL = [[0]*n for _ in range(m)]\\n        BR = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            search(i,0,1,1,TL)\\n        for j in range(1,n):\\n            search(0,j,1,1,TL)\\n        for j in range(n):\\n            search(m-1,j,-1,-1,BR)\\n        for i in range(m-1):\\n            search(i,n-1,-1,-1,BR)\\n        res = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j] = abs((TL[i-1][j-1] if isValid(i-1,j-1) else 0) - (BR[i+1][j+1] if isValid(i+1,j+1) else 0))\\n        return res\\n\\n\\n                \\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572863,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int ans[][]=new int[grid.length][grid[0].length];\\n     for(int i=0;i<grid.length;i++){\\n         for(int j=0;j<grid[0].length;j++){\\n             //top\\n             HashSet<Integer>set=new HashSet<>();\\n             int ind1=i-1;\\n             int ind2=j-1;\\n             while((ind1>=0&&ind1<grid.length)&&(ind2>=0)){\\n                 set.add(grid[ind1][ind2]);\\n                 ind1--;\\n                 ind2--;\\n             }\\n             HashSet<Integer>set1=new HashSet<>();\\n             ind1=i+1;\\n             ind2=j+1;\\n             while(ind1<grid.length&&ind2<grid[0].length){\\n                 set1.add(grid[ind1][ind2]);\\n                 ind1++;\\n                 ind2++;\\n             }\\n             ans[i][j]=Math.abs(set1.size()-set.size());\\n         }\\n     }   \\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int ans[][]=new int[grid.length][grid[0].length];\\n     for(int i=0;i<grid.length;i++){\\n         for(int j=0;j<grid[0].length;j++){\\n             //top\\n             HashSet<Integer>set=new HashSet<>();\\n             int ind1=i-1;\\n             int ind2=j-1;\\n             while((ind1>=0&&ind1<grid.length)&&(ind2>=0)){\\n                 set.add(grid[ind1][ind2]);\\n                 ind1--;\\n                 ind2--;\\n             }\\n             HashSet<Integer>set1=new HashSet<>();\\n             ind1=i+1;\\n             ind2=j+1;\\n             while(ind1<grid.length&&ind2<grid[0].length){\\n                 set1.add(grid[ind1][ind2]);\\n                 ind1++;\\n                 ind2++;\\n             }\\n             ans[i][j]=Math.abs(set1.size()-set.size());\\n         }\\n     }   \\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572798,
                "title": "easy-c-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid)\\n    {\\n        int l=grid.size(),m=grid[0].size();\\n        vector <vector <int>> topl(l,vector <int> (m));\\n        vector <vector <int>> botr(l,vector <int> (m));\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                unordered_set <int> s;\\n                for(int x=i+1,y=j+1;x<l and y<m;x++,y++)\\n                {\\n                    s.insert(grid[x][y]);\\n                }\\n                botr[i][j]=s.size();\\n            }\\n        }\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                unordered_set <int> s;\\n                for(int x=i-1,y=j-1;x>=0 and y>=0;x--,y--)\\n                {\\n                    s.insert(grid[x][y]);\\n                }\\n                topl[i][j]=s.size();\\n            }\\n        }\\n        vector <vector <int>> ans(l,vector <int> (m,0));\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=abs(topl[i][j]-botr[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid)\\n    {\\n        int l=grid.size(),m=grid[0].size();\\n        vector <vector <int>> topl(l,vector <int> (m));\\n        vector <vector <int>> botr(l,vector <int> (m));\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                unordered_set <int> s;\\n                for(int x=i+1,y=j+1;x<l and y<m;x++,y++)\\n                {\\n                    s.insert(grid[x][y]);\\n                }\\n                botr[i][j]=s.size();\\n            }\\n        }\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                unordered_set <int> s;\\n                for(int x=i-1,y=j-1;x>=0 and y>=0;x--,y--)\\n                {\\n                    s.insert(grid[x][y]);\\n                }\\n                topl[i][j]=s.size();\\n            }\\n        }\\n        vector <vector <int>> ans(l,vector <int> (m,0));\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans[i][j]=abs(topl[i][j]-botr[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572729,
                "title": "java-solution-easy-to-understand-with-o-m-n-by-using-a-map-and-a-set",
                "content": "# Intuition\\nFor an array, we can use a set and a map to record the difference of distinct values in the left side and right side by traversing the array twice.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each diagonal line, we traverse it twice. In the first traverse, a count map is used to record every element\\'s frequency. In the second loop, a set is used to record the number of distinct values in the left side, and then the numbers in the left side were removed from the map. The difference between the size of map and set is the answer for the current location.\\n![Diagonal.png](https://assets.leetcode.com/users/images/8a1e7fe4-ce2f-4abf-b51a-b070ff87237b_1685307187.8987243.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m*n), since we only traverse every element twice. \\n\\n- Space complexity:\\nO(Math.max(m, n)). Each diagonal line will have at most Math.max(m, n) elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] answer = new int[m][n];\\n        Map<Integer, Integer> count;\\n        Set<Integer> set;\\n        for (int line = 2; line < m+n-1; line++) {\\n            // for each diagonal line, find out its start row and col location, and then traverse this line.\\n            int startR = Math.max(0, m-line), startC = Math.max(0, line-m);\\n            count = new HashMap<>();\\n            for (int i = startR, j = startC; i < m && j < n; i++, j++) {\\n                count.put(grid[i][j], count.getOrDefault(grid[i][j], 0) + 1);\\n            }\\n            set = new HashSet<>();\\n            for (int i = startR, j = startC; i < m && j < n; i++, j++) {\\n                count.put(grid[i][j], count.get(grid[i][j]) - 1);\\n                if (count.get(grid[i][j]) == 0) {\\n                    count.remove(grid[i][j]);\\n                }\\n                answer[i][j] = Math.abs(count.size() - set.size());          \\n                set.add(grid[i][j]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] answer = new int[m][n];\\n        Map<Integer, Integer> count;\\n        Set<Integer> set;\\n        for (int line = 2; line < m+n-1; line++) {\\n            // for each diagonal line, find out its start row and col location, and then traverse this line.\\n            int startR = Math.max(0, m-line), startC = Math.max(0, line-m);\\n            count = new HashMap<>();\\n            for (int i = startR, j = startC; i < m && j < n; i++, j++) {\\n                count.put(grid[i][j], count.getOrDefault(grid[i][j], 0) + 1);\\n            }\\n            set = new HashSet<>();\\n            for (int i = startR, j = startC; i < m && j < n; i++, j++) {\\n                count.put(grid[i][j], count.get(grid[i][j]) - 1);\\n                if (count.get(grid[i][j]) == 0) {\\n                    count.remove(grid[i][j]);\\n                }\\n                answer[i][j] = Math.abs(count.size() - set.size());          \\n                set.add(grid[i][j]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572696,
                "title": "easy-to-read-and-understand-solution-c-basic-index-observation",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> tl(row, vector<int> (col, 0));\\n        vector<vector<int>> br(row, vector<int> (col, 0));\\n        \\n        unordered_set<int> distinct_top_left;\\n        unordered_set<int> distinct_bottom_right;\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r -= 1;\\n                c -= 1;\\n\\n                while(r >= 0 && c >= 0)\\n                {\\n                    distinct_top_left.insert(grid[r][c]);\\n                    r -= 1;\\n                    c -= 1;\\n                }\\n\\n                tl[i][j] = distinct_top_left.size();\\n                distinct_top_left.clear();\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r += 1;\\n                c += 1;\\n\\n                while(r < row && c < col)\\n                {\\n                    distinct_bottom_right.insert(grid[r][c]);\\n                    r += 1;\\n                    c += 1;\\n                }\\n\\n                br[i][j] = distinct_bottom_right.size();\\n                distinct_bottom_right.clear();\\n            }\\n        }\\n\\n        vector<vector<int>> answer(row, vector<int> (col, 0));\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                answer[i][j] = abs(tl[i][j] - br[i][j]);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> tl(row, vector<int> (col, 0));\\n        vector<vector<int>> br(row, vector<int> (col, 0));\\n        \\n        unordered_set<int> distinct_top_left;\\n        unordered_set<int> distinct_bottom_right;\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r -= 1;\\n                c -= 1;\\n\\n                while(r >= 0 && c >= 0)\\n                {\\n                    distinct_top_left.insert(grid[r][c]);\\n                    r -= 1;\\n                    c -= 1;\\n                }\\n\\n                tl[i][j] = distinct_top_left.size();\\n                distinct_top_left.clear();\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int r = i;\\n                int c = j;\\n\\n                r += 1;\\n                c += 1;\\n\\n                while(r < row && c < col)\\n                {\\n                    distinct_bottom_right.insert(grid[r][c]);\\n                    r += 1;\\n                    c += 1;\\n                }\\n\\n                br[i][j] = distinct_bottom_right.size();\\n                distinct_bottom_right.clear();\\n            }\\n        }\\n\\n        vector<vector<int>> answer(row, vector<int> (col, 0));\\n\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                answer[i][j] = abs(tl[i][j] - br[i][j]);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572585,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstore the numbers in Hashset to get unique number\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] ans = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                 HashSet<Integer> c = new HashSet<Integer>();\\n                 HashSet<Integer> c2 = new HashSet<Integer>();\\n                int left = 0;\\n                int right = 0;\\n                int leftR = i - 1;\\n                int leftC = j - 1;\\n                int rightR = i + 1;\\n                int rightC = j + 1;\\n                while(leftR >= 0 && leftC >= 0){\\n                    \\n                    c.add(grid[leftR][leftC]);\\n                    leftR--;\\n                    leftC--;\\n                    left = c.size();\\n                    \\n                }\\n                \\n                while(rightR < m && rightC < n){\\n                   \\n                    c2.add(grid[rightR][rightC]);\\n                    rightR++;\\n                    rightC++;\\n                    right = c2.size();\\n\\n                }\\n                \\n                int res = left -  right;\\n                if (res < 0)  res *= -1;\\n                ans[i][j] = res;\\n\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] ans = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                 HashSet<Integer> c = new HashSet<Integer>();\\n                 HashSet<Integer> c2 = new HashSet<Integer>();\\n                int left = 0;\\n                int right = 0;\\n                int leftR = i - 1;\\n                int leftC = j - 1;\\n                int rightR = i + 1;\\n                int rightC = j + 1;\\n                while(leftR >= 0 && leftC >= 0){\\n                    \\n                    c.add(grid[leftR][leftC]);\\n                    leftR--;\\n                    leftC--;\\n                    left = c.size();\\n                    \\n                }\\n                \\n                while(rightR < m && rightC < n){\\n                   \\n                    c2.add(grid[rightR][rightC]);\\n                    rightR++;\\n                    rightC++;\\n                    right = c2.size();\\n\\n                }\\n                \\n                int res = left -  right;\\n                if (res < 0)  res *= -1;\\n                ans[i][j] = res;\\n\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572567,
                "title": "difference-of-number-of-distinct-values-on-diagonals-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(); //row\\n        int n=grid[0].size();  //column\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                int r=i,c=j;\\n                set<int> top;\\n                set<int> bottom;\\n                while((r-1)>=0&&(c-1)>=0)\\n                {\\n                    top.insert(grid[r-1][c-1]);\\n                    r--;\\n                    c--;\\n                }\\n                r=i;\\n                c=j;\\n                while((r+1)<m&&(c+1)<n)\\n                {\\n                    bottom.insert(grid[r+1][c+1]);\\n                    r++;\\n                    c++;\\n                }\\n                int val=top.size()-bottom.size();\\n                if(val<0)\\n                {\\n                    val*=-1;\\n                }\\n                temp.push_back(val);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size(); //row\\n        int n=grid[0].size();  //column\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                int r=i,c=j;\\n                set<int> top;\\n                set<int> bottom;\\n                while((r-1)>=0&&(c-1)>=0)\\n                {\\n                    top.insert(grid[r-1][c-1]);\\n                    r--;\\n                    c--;\\n                }\\n                r=i;\\n                c=j;\\n                while((r+1)<m&&(c+1)<n)\\n                {\\n                    bottom.insert(grid[r+1][c+1]);\\n                    r++;\\n                    c++;\\n                }\\n                int val=top.size()-bottom.size();\\n                if(val<0)\\n                {\\n                    val*=-1;\\n                }\\n                temp.push_back(val);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572460,
                "title": "cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans;\\n        int n=grid.size();;\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            vector<int>vec;\\n            for(int j=0;j<m;j++){\\n                int a=i-1,b=j-1;\\n                set<int>st;\\n                while(a>=0 and b>=0){\\n                    st.insert(grid[a][b]);\\n                    a--;\\n                    b--;\\n                }\\n                set<int>st1;\\n                a=i+1;\\n                b=j+1;\\n                while(a<n and b<m){\\n                    st1.insert(grid[a][b]);\\n                    a++;\\n                    b++;\\n                }\\n                int aa=st.size()-st1.size();\\n                if(aa<0){\\n                    aa*=-1;\\n                }\\n                vec.push_back(aa);\\n            }\\n            ans.push_back(vec);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans;\\n        int n=grid.size();;\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            vector<int>vec;\\n            for(int j=0;j<m;j++){\\n                int a=i-1,b=j-1;\\n                set<int>st;\\n                while(a>=0 and b>=0){\\n                    st.insert(grid[a][b]);\\n                    a--;\\n                    b--;\\n                }\\n                set<int>st1;\\n                a=i+1;\\n                b=j+1;\\n                while(a<n and b<m){\\n                    st1.insert(grid[a][b]);\\n                    a++;\\n                    b++;\\n                }\\n                int aa=st.size()-st1.size();\\n                if(aa<0){\\n                    aa*=-1;\\n                }\\n                vec.push_back(aa);\\n            }\\n            ans.push_back(vec);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572393,
                "title": "java-ugly-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[][] differenceOfDistinctValues(int[][] grid) {\\n    int y = grid.length, x = grid[0].length;\\n    int Y = y-1, X = x-1;\\n\\n    int a[][] = new int[y][x];\\n    int b[][] = new int[y][x];\\n    int ans[][] = new int[y][x];\\n\\n    for(int i = Y; i >= 0; --i){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = i, c = 0; r < y && c < x; ++r, ++c){\\n        a[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n    for(int j = 1; j < x; ++j){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = 0, c = j; r < y && c < x; ++r, ++c){\\n        a[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n    for(int j = 0; j != x; ++j){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = Y, c = j; r >= 0 && c >= 0; --r, --c){\\n        b[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n    for(int i = Y - 1; i >= 0; --i){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = i, c = X; r >= 0 && c >= 0; --r, --c){\\n        b[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n     for(int i = 0; i != y; ++i)\\n       for(int j = 0; j != x; ++j)\\n          ans[i][j] = Math.abs(a[i][j] - b[i][j]);\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[][] differenceOfDistinctValues(int[][] grid) {\\n    int y = grid.length, x = grid[0].length;\\n    int Y = y-1, X = x-1;\\n\\n    int a[][] = new int[y][x];\\n    int b[][] = new int[y][x];\\n    int ans[][] = new int[y][x];\\n\\n    for(int i = Y; i >= 0; --i){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = i, c = 0; r < y && c < x; ++r, ++c){\\n        a[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n    for(int j = 1; j < x; ++j){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = 0, c = j; r < y && c < x; ++r, ++c){\\n        a[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n    for(int j = 0; j != x; ++j){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = Y, c = j; r >= 0 && c >= 0; --r, --c){\\n        b[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n    for(int i = Y - 1; i >= 0; --i){\\n      HashSet<Integer> set = new HashSet<>(50);\\n      for(int r = i, c = X; r >= 0 && c >= 0; --r, --c){\\n        b[r][c] = set.size();\\n        set.add(grid[r][c]);\\n      }\\n      set.clear();\\n    }\\n\\n     for(int i = 0; i != y; ++i)\\n       for(int j = 0; j != x; ++j)\\n          ans[i][j] = Math.abs(a[i][j] - b[i][j]);\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572323,
                "title": "python-simple-brute-force-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = [[0] * n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                topLeft = set()\\n                bottomRight = set()\\n                r = i-1\\n                c = j-1\\n                while r>=0 and c>=0:\\n                    topLeft.add(grid[r][c])\\n                    r-=1\\n                    c-=1\\n                r = i+1\\n                c = j+1\\n                while r<m and c<n:\\n                    bottomRight.add(grid[r][c])\\n                    r+=1\\n                    c+=1\\n                ans[i][j] = abs(len(topLeft) - len(bottomRight))\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = [[0] * n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                topLeft = set()\\n                bottomRight = set()\\n                r = i-1\\n                c = j-1\\n                while r>=0 and c>=0:\\n                    topLeft.add(grid[r][c])\\n                    r-=1\\n                    c-=1\\n                r = i+1\\n                c = j+1\\n                while r<m and c<n:\\n                    bottomRight.add(grid[r][c])\\n                    r+=1\\n                    c+=1\\n                ans[i][j] = abs(len(topLeft) - len(bottomRight))\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572294,
                "title": "c-brute-force-solution-for-beginner-12-acceptance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int B(vector<vector<int>>& grid, int row, int col , int size , int col_size){\\n        unordered_map<int,int> mp;\\n        int bottom = 0;\\n        cout<< row << \" \"<<col <<endl;\\n        row++;\\n        col++;\\n        for(int i=row;i<size && col < col_size;i++){\\n           cout<<grid[i][col]<<\" \";\\n           if(mp[grid[i][col]]==0)bottom++;\\n           mp[grid[i][col]]++; \\n            col++;\\n        }\\n        cout<<endl;\\n        return bottom;\\n    }\\n    int T(vector<vector<int>>& grid, int row, int col , int size , int col_size){\\n        unordered_map<int,int> mp;\\n        int top = 0;\\n        col--;\\n        row--;\\n        for(int i=row;i>=0 && (col < col_size && col >= 0);i--){\\n            if(mp[grid[i][col]]==0)top++;\\n            mp[grid[i][col]]++;\\n            col--;\\n        }\\n        return top;\\n    }\\n\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> ans;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            int col = grid[i].size();\\n            vector<int> temp;\\n            for(int j = 0;j<col;j++){\\n                int bottom = 0 , top = 0;\\n                bottom = B(grid,i,j,n,col);\\n                top = T(grid,i,j,n,col);\\n                int t = abs(bottom-top);\\n                temp.push_back(t);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int B(vector<vector<int>>& grid, int row, int col , int size , int col_size){\\n        unordered_map<int,int> mp;\\n        int bottom = 0;\\n        cout<< row << \" \"<<col <<endl;\\n        row++;\\n        col++;\\n        for(int i=row;i<size && col < col_size;i++){\\n           cout<<grid[i][col]<<\" \";\\n           if(mp[grid[i][col]]==0)bottom++;\\n           mp[grid[i][col]]++; \\n            col++;\\n        }\\n        cout<<endl;\\n        return bottom;\\n    }\\n    int T(vector<vector<int>>& grid, int row, int col , int size , int col_size){\\n        unordered_map<int,int> mp;\\n        int top = 0;\\n        col--;\\n        row--;\\n        for(int i=row;i>=0 && (col < col_size && col >= 0);i--){\\n            if(mp[grid[i][col]]==0)top++;\\n            mp[grid[i][col]]++;\\n            col--;\\n        }\\n        return top;\\n    }\\n\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>> ans;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            int col = grid[i].size();\\n            vector<int> temp;\\n            for(int j = 0;j<col;j++){\\n                int bottom = 0 , top = 0;\\n                bottom = B(grid,i,j,n,col);\\n                top = T(grid,i,j,n,col);\\n                int t = abs(bottom-top);\\n                temp.push_back(t);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3572291,
                "title": "easy-c-solution-using-set-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n           int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> res(n,vector<int>(m,0));\\n        for(int r = 0;r< n;r++){\\n            for(int c = 0;c< m;c++){\\n                set<int> topleft,bottomRight;\\n                \\n                for(int i=r-1,j=c-1;i>=0 && j>=0;i--,j--){\\n                    topleft.insert(grid[i][j]);\\n                }\\n                for(int i=r+1,j=c+1;i<n && j<m;i++,j++){\\n                    bottomRight.insert(grid[i][j]);\\n                }\\n                int x = topleft.size();\\n                int y = bottomRight.size();\\n                res[r][c] = abs(x -y);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n           int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> res(n,vector<int>(m,0));\\n        for(int r = 0;r< n;r++){\\n            for(int c = 0;c< m;c++){\\n                set<int> topleft,bottomRight;\\n                \\n                for(int i=r-1,j=c-1;i>=0 && j>=0;i--,j--){\\n                    topleft.insert(grid[i][j]);\\n                }\\n                for(int i=r+1,j=c+1;i<n && j<m;i++,j++){\\n                    bottomRight.insert(grid[i][j]);\\n                }\\n                int x = topleft.size();\\n                int y = bottomRight.size();\\n                res[r][c] = abs(x -y);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572264,
                "title": "easy-to-understand-solution-c",
                "content": "```\\nint n = grid.size();\\n        int m = grid[0].size();\\n        \\n       map<int, map<int, int>>mp;\\n       map<int, map<int, int>>mp2;\\n        // c-r = idx;\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        vector<vector<int>>dpr(n, vector<int>(m,0));\\n         vector<vector<int>>ans(n, vector<int>(m,0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int idx = j -i;\\n                int val = grid[i][j];\\n                mp[idx][val]++;\\n                dp[i][j] = mp[idx].size();\\n            }\\n        }\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                int idx = j -i;\\n                int val = grid[i][j];\\n                mp2[idx][val]++;\\n                dpr[i][j] = mp2[idx].size();\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int idx = j-i;\\n                int val = grid[i][j];\\n                int left;\\n                int right;\\n                \\n                if(i-1<0 || j-1 <0) left = 0;\\n                else{\\n                    left = dp[i-1][j-1];\\n                }\\n                if(i+1>= n || j+1 >= m) right = 0;\\n                else right = dpr[i+1][j+1];\\n               ans[i][j] = abs(left-right);\\n            }\\n                \\n        }\\n        return ans;\\n        \\n        ```\\n\\t\\t\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint n = grid.size();\\n        int m = grid[0].size();\\n        \\n       map<int, map<int, int>>mp;\\n       map<int, map<int, int>>mp2;\\n        // c-r = idx;\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        vector<vector<int>>dpr(n, vector<int>(m,0));\\n         vector<vector<int>>ans(n, vector<int>(m,0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int idx = j -i;\\n                int val = grid[i][j];\\n                mp[idx][val]++;\\n                dp[i][j] = mp[idx].size();\\n            }\\n        }\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                int idx = j -i;\\n                int val = grid[i][j];\\n                mp2[idx][val]++;\\n                dpr[i][j] = mp2[idx].size();\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int idx = j-i;\\n                int val = grid[i][j];\\n                int left;\\n                int right;\\n                \\n                if(i-1<0 || j-1 <0) left = 0;\\n                else{\\n                    left = dp[i-1][j-1];\\n                }\\n                if(i+1>= n || j+1 >= m) right = 0;\\n                else right = dpr[i+1][j+1];\\n               ans[i][j] = abs(left-right);\\n            }\\n                \\n        }\\n        return ans;\\n        \\n        ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572204,
                "title": "using-hashset-easy-to-understand-java",
                "content": "\\n# Complexity\\n- Time complexity: O(r * r * c)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(r)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int[][] ans = new int[row][col];\\n\\n        for(int i=0;i<row;i++){\\n            for(int j =0;j<col;j++){\\n                Set<Integer> set1 = new HashSet<>();\\n                int l = j-1;\\n                for(int k=i-1;k>=0 && l>=0;k--){\\n                    set1.add(grid[k][l]);\\n                    l--;\\n                }\\n                Set<Integer> set2 = new HashSet<>();\\n                l = j+1;\\n                for(int k=i+1;k<row && l<col;k++){\\n                    set2.add(grid[k][l]);\\n                    l++;\\n                }\\n                ans[i][j] = Math.abs(set1.size()-set2.size());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int[][] ans = new int[row][col];\\n\\n        for(int i=0;i<row;i++){\\n            for(int j =0;j<col;j++){\\n                Set<Integer> set1 = new HashSet<>();\\n                int l = j-1;\\n                for(int k=i-1;k>=0 && l>=0;k--){\\n                    set1.add(grid[k][l]);\\n                    l--;\\n                }\\n                Set<Integer> set2 = new HashSet<>();\\n                l = j+1;\\n                for(int k=i+1;k<row && l<col;k++){\\n                    set2.add(grid[k][l]);\\n                    l++;\\n                }\\n                ans[i][j] = Math.abs(set1.size()-set2.size());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572018,
                "title": "go-and-python-simple-and-modular",
                "content": "### Go\\n``` Go\\nfunc differenceOfDistinctValues(grid [][]int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    res := make([][]int, m)\\n    for i := range res { res[i] = make([]int, n) }\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            topLeft, bottomRight := make(map[int]bool), make(map[int]bool)\\n            getTopLeft(grid, i - 1, j - 1, topLeft)\\n            getBottomRight(grid, i + 1, j + 1, bottomRight)\\n            res[i][j] = abs(len(topLeft) - len(bottomRight))\\n        }\\n    }\\n    return res\\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc getTopLeft(grid [][]int, i, j int, count map[int]bool) {\\n    if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) { return }\\n    count[grid[i][j]] = true\\n    getTopLeft(grid, i - 1, j - 1, count)\\n}\\n\\nfunc getBottomRight(grid [][]int, i, j int, count map[int]bool) {\\n    if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) { return }\\n    count[grid[i][j]] = true\\n    getBottomRight(grid, i + 1, j + 1, count)\\n}\\n```\\n\\n### Python\\n``` Python\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        res = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                topLeft, bottomRight = {}, {}\\n                self.countTopLeft(grid, i - 1, j - 1, topLeft)\\n                self.countBottomRight(grid, i + 1, j + 1, bottomRight)\\n                res[i][j] = abs(len(topLeft) - len(bottomRight))\\n        \\n        return res\\n        \\n    \\n    def countTopLeft(self, grid, i, j, counts):\\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\\n            return\\n        counts[grid[i][j]] = True\\n        self.countTopLeft(grid, i - 1, j - 1, counts)\\n    \\n    def countBottomRight(self, grid, i, j, counts):\\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\\n            return\\n        counts[grid[i][j]] = True\\n        self.countBottomRight(grid, i + 1, j + 1, counts)\\n```",
                "solutionTags": [
                    "Python3",
                    "Go"
                ],
                "code": "``` Go\\nfunc differenceOfDistinctValues(grid [][]int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    res := make([][]int, m)\\n    for i := range res { res[i] = make([]int, n) }\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            topLeft, bottomRight := make(map[int]bool), make(map[int]bool)\\n            getTopLeft(grid, i - 1, j - 1, topLeft)\\n            getBottomRight(grid, i + 1, j + 1, bottomRight)\\n            res[i][j] = abs(len(topLeft) - len(bottomRight))\\n        }\\n    }\\n    return res\\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc getTopLeft(grid [][]int, i, j int, count map[int]bool) {\\n    if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) { return }\\n    count[grid[i][j]] = true\\n    getTopLeft(grid, i - 1, j - 1, count)\\n}\\n\\nfunc getBottomRight(grid [][]int, i, j int, count map[int]bool) {\\n    if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) { return }\\n    count[grid[i][j]] = true\\n    getBottomRight(grid, i + 1, j + 1, count)\\n}\\n```\n``` Python\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        res = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                topLeft, bottomRight = {}, {}\\n                self.countTopLeft(grid, i - 1, j - 1, topLeft)\\n                self.countBottomRight(grid, i + 1, j + 1, bottomRight)\\n                res[i][j] = abs(len(topLeft) - len(bottomRight))\\n        \\n        return res\\n        \\n    \\n    def countTopLeft(self, grid, i, j, counts):\\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\\n            return\\n        counts[grid[i][j]] = True\\n        self.countTopLeft(grid, i - 1, j - 1, counts)\\n    \\n    def countBottomRight(self, grid, i, j, counts):\\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\\n            return\\n        counts[grid[i][j]] = True\\n        self.countBottomRight(grid, i + 1, j + 1, counts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572014,
                "title": "java-easy-set-solution-have-a-look",
                "content": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] answer = new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                int x1 = i-1, y1 = j-1;\\n                int x2 = i+1, y2 = j+1;\\n                Set<Integer> top = new HashSet<>();\\n                Set<Integer> bottom = new HashSet<>();\\n\\t\\t\\t\\t//Traverse through top left diagonal and bottom right diagonal and put them in a set\\n                while(x1>=0 && y1>=0){\\n                    top.add(grid[x1][y1]);\\n                    x1--;\\n                    y1--;\\n                }\\n                while(x2<grid.length && y2<grid[0].length){\\n                    bottom.add(grid[x2][y2]);\\n                    x2++;\\n                    y2++;\\n                }\\n\\t\\t\\t\\t//Prepare answer\\n                answer[i][j] = Math.abs(top.size() - bottom.size());\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] answer = new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                int x1 = i-1, y1 = j-1;\\n                int x2 = i+1, y2 = j+1;\\n                Set<Integer> top = new HashSet<>();\\n                Set<Integer> bottom = new HashSet<>();\\n\\t\\t\\t\\t//Traverse through top left diagonal and bottom right diagonal and put them in a set\\n                while(x1>=0 && y1>=0){\\n                    top.add(grid[x1][y1]);\\n                    x1--;\\n                    y1--;\\n                }\\n                while(x2<grid.length && y2<grid[0].length){\\n                    bottom.add(grid[x2][y2]);\\n                    x2++;\\n                    y2++;\\n                }\\n\\t\\t\\t\\t//Prepare answer\\n                answer[i][j] = Math.abs(top.size() - bottom.size());\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571995,
                "title": "simple-traverse-to-and-fro-on-all-the-diagonals-of-the-matrix-and-you-will-get-the-required-results",
                "content": "# Complexity\\n- Time complexity:\\nO(2 * m*n) as we are going on each element twice.\\n\\n- Space complexity:\\n*O(n * m)* for the answer matrix + *O(m)* for the unordered set for storing distinct elements in the diagonal, as the longest diagonal can be of size m (size of column) so we can say the maximum space will be taken when all the elements of the diagonal are unique.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans(grid.size(), vector<int>(grid[0].size()));\\n\\n        for(int j = 0; j<grid[0].size(); j++){\\n            int currrow = 0;\\n            int currcol = j;\\n            unordered_set<int>us;\\n            while(currrow<grid.size() and currcol<grid[0].size()){\\n                ans[currrow][currcol] = us.size();\\n                us.insert(grid[currrow][currcol]);\\n                currrow++;\\n                currcol++;\\n            }\\n            us.clear();\\n            currrow--;\\n            currcol--;\\n            while(currrow>=0 and currcol>=j){\\n                ans[currrow][currcol]-= us.size();\\n                if(ans[currrow][currcol]<0){\\n                    ans[currrow][currcol]*=-1;\\n                }\\n                us.insert(grid[currrow][currcol]);\\n                currrow--;\\n                currcol--;\\n            }\\n        }\\n\\n        for(int i = 1; i<grid.size(); i++){\\n            int currrow = i;\\n            int currcol = 0;\\n\\n            unordered_set<int>us;\\n            while(currrow<grid.size() and currcol<grid[0].size()){\\n                ans[currrow][currcol] = us.size();\\n                us.insert(grid[currrow][currcol]);\\n                currrow++;\\n                currcol++;\\n            }\\n            us.clear();\\n            currrow--;\\n            currcol--;\\n            while(currrow>=i and currcol>=0){\\n                ans[currrow][currcol]-= us.size();\\n                if(ans[currrow][currcol]<0){\\n                    ans[currrow][currcol]*=-1;\\n                }\\n                us.insert(grid[currrow][currcol]);\\n                currrow--;\\n                currcol--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans(grid.size(), vector<int>(grid[0].size()));\\n\\n        for(int j = 0; j<grid[0].size(); j++){\\n            int currrow = 0;\\n            int currcol = j;\\n            unordered_set<int>us;\\n            while(currrow<grid.size() and currcol<grid[0].size()){\\n                ans[currrow][currcol] = us.size();\\n                us.insert(grid[currrow][currcol]);\\n                currrow++;\\n                currcol++;\\n            }\\n            us.clear();\\n            currrow--;\\n            currcol--;\\n            while(currrow>=0 and currcol>=j){\\n                ans[currrow][currcol]-= us.size();\\n                if(ans[currrow][currcol]<0){\\n                    ans[currrow][currcol]*=-1;\\n                }\\n                us.insert(grid[currrow][currcol]);\\n                currrow--;\\n                currcol--;\\n            }\\n        }\\n\\n        for(int i = 1; i<grid.size(); i++){\\n            int currrow = i;\\n            int currcol = 0;\\n\\n            unordered_set<int>us;\\n            while(currrow<grid.size() and currcol<grid[0].size()){\\n                ans[currrow][currcol] = us.size();\\n                us.insert(grid[currrow][currcol]);\\n                currrow++;\\n                currcol++;\\n            }\\n            us.clear();\\n            currrow--;\\n            currcol--;\\n            while(currrow>=i and currcol>=0){\\n                ans[currrow][currcol]-= us.size();\\n                if(ans[currrow][currcol]<0){\\n                    ans[currrow][currcol]*=-1;\\n                }\\n                us.insert(grid[currrow][currcol]);\\n                currrow--;\\n                currcol--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571964,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        topLeft, bottomRight = defaultdict(set), defaultdict(set)\\n\\n        ans = [[0]*n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(1,min(m,n)):\\n                    if i-k >= 0 and j-k >= 0:\\n                        topLeft[(i,j)].add(grid[i-k][j-k])\\n                    if i+k < m and j+k < n:\\n                        bottomRight[(i,j)].add(grid[i+k][j+k])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = abs(len(topLeft[(i,j)]) - len(bottomRight[(i,j)]))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        topLeft, bottomRight = defaultdict(set), defaultdict(set)\\n\\n        ans = [[0]*n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(1,min(m,n)):\\n                    if i-k >= 0 and j-k >= 0:\\n                        topLeft[(i,j)].add(grid[i-k][j-k])\\n                    if i+k < m and j+k < n:\\n                        bottomRight[(i,j)].add(grid[i+k][j+k])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = abs(len(topLeft[(i,j)]) - len(bottomRight[(i,j)]))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571958,
                "title": "simple-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int cl= grid[0].length;\\n        int rw=grid.length;\\n        int[][] arr= new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                HashSet<Integer> stl= new HashSet<>();\\n                HashSet<Integer> sbr= new HashSet<>();\\n                int r=i+1;\\n                int c=j+1;\\n                while(r<rw && c<cl){\\n                    sbr.add(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n                int r1= i-1;\\n                int c1=j-1;\\n                while( r1>=0 && c1>=0){\\n                    stl.add(grid[r1][c1]);\\n                    r1--;\\n                    c1--;\\n                }\\n                  arr[i][j]=Math.abs(stl.size()-sbr.size());\\n            }            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int cl= grid[0].length;\\n        int rw=grid.length;\\n        int[][] arr= new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                HashSet<Integer> stl= new HashSet<>();\\n                HashSet<Integer> sbr= new HashSet<>();\\n                int r=i+1;\\n                int c=j+1;\\n                while(r<rw && c<cl){\\n                    sbr.add(grid[r][c]);\\n                    r++;\\n                    c++;\\n                }\\n                int r1= i-1;\\n                int c1=j-1;\\n                while( r1>=0 && c1>=0){\\n                    stl.add(grid[r1][c1]);\\n                    r1--;\\n                    c1--;\\n                }\\n                  arr[i][j]=Math.abs(stl.size()-sbr.size());\\n            }            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571938,
                "title": "begginer-c-solutions",
                "content": "class Solution {\\npublic: \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,0));\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int row=i;\\n                int col=j;\\n                set<int>mp;\\n                row=i+1;\\n                col=j+1;\\n            while(row<m && col<n)\\n            {\\n                mp.insert(grid[row][col]);\\n                row++;\\n                col++;\\n            }\\n            int row1=i-1;\\n            int col1=j-1;\\n             set<int>mp1;\\n            while(row1>=0 && col1>=0)\\n            {\\n//                mp1[grid[row1][col1]]++;\\n                mp1.insert(grid[row1][col1]);\\n               row1--;\\n                col1--;\\n            }\\n                int x=mp.size();\\n                int y=mp1.size();\\n                res[i][j]=abs(x-y);\\n                mp.clear();\\n                mp1.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic: \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,0));\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int row=i;\\n                int col=j;\\n                set<int>mp;\\n                row=i+1;\\n                col=j+1;\\n            while(row<m && col<n)\\n            {\\n                mp.insert(grid[row][col]);\\n                row++;\\n                col++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3571900,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        def getDistToTopLeft(grid, row, col):\\n            h = set()\\n            while True:\\n                if row>0 and col>0:\\n                    row -= 1\\n                    col -= 1\\n                    h.add(grid[row][col])\\n                else:\\n                    break\\n            return len(h)\\n\\n        def getDistToBotRight(grid, row, col):\\n            h = set()\\n            while True:\\n                if row<len(grid)-1 and col<len(grid[0])-1:\\n                    row += 1\\n                    col += 1\\n                    h.add(grid[row][col])\\n                else:\\n                    break\\n            return len(h)\\n\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = [[0] * cols for _ in range(rows)]\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                topLeft = getDistToTopLeft(grid, i, j)\\n                botRight = getDistToBotRight(grid, i, j)\\n                df = abs(topLeft - botRight)\\n                answer[i][j] = df\\n                    \\n        return answer\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        def getDistToTopLeft(grid, row, col):\\n            h = set()\\n            while True:\\n                if row>0 and col>0:\\n                    row -= 1\\n                    col -= 1\\n                    h.add(grid[row][col])\\n                else:\\n                    break\\n            return len(h)\\n\\n        def getDistToBotRight(grid, row, col):\\n            h = set()\\n            while True:\\n                if row<len(grid)-1 and col<len(grid[0])-1:\\n                    row += 1\\n                    col += 1\\n                    h.add(grid[row][col])\\n                else:\\n                    break\\n            return len(h)\\n\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = [[0] * cols for _ in range(rows)]\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                topLeft = getDistToTopLeft(grid, i, j)\\n                botRight = getDistToBotRight(grid, i, j)\\n                df = abs(topLeft - botRight)\\n                answer[i][j] = df\\n                    \\n        return answer\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571874,
                "title": "python-using-sets",
                "content": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:            \\n        m, n = len(grid), len(grid[0])\\n        result = [[0]*n  for _ in range(m)]\\n        \\n        def isGood(r, c):\\n            return 0 <= r < m and 0 <= c < n\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                topLeft = set()\\n                bottomRight = set()\\n                \\n                r1, c1 = r - 1, c - 1\\n                r2, c2 = r + 1, c + 1                \\n                while isGood(r1, c1) or isGood(r2, c2):                        \\n                    if isGood(r1, c1):\\n                        topLeft.add(grid[r1][c1])\\n                        r1 -= 1\\n                        c1 -= 1\\n                        \\n                    if isGood(r2, c2):\\n                        bottomRight.add(grid[r2][c2])\\n                        r2 += 1\\n                        c2 += 1\\n                \\n                result[r][c] = abs(len(topLeft) - len(bottomRight))\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:            \\n        m, n = len(grid), len(grid[0])\\n        result = [[0]*n  for _ in range(m)]\\n        \\n        def isGood(r, c):\\n            return 0 <= r < m and 0 <= c < n\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                topLeft = set()\\n                bottomRight = set()\\n                \\n                r1, c1 = r - 1, c - 1\\n                r2, c2 = r + 1, c + 1                \\n                while isGood(r1, c1) or isGood(r2, c2):                        \\n                    if isGood(r1, c1):\\n                        topLeft.add(grid[r1][c1])\\n                        r1 -= 1\\n                        c1 -= 1\\n                        \\n                    if isGood(r2, c2):\\n                        bottomRight.add(grid[r2][c2])\\n                        r2 += 1\\n                        c2 += 1\\n                \\n                result[r][c] = abs(len(topLeft) - len(bottomRight))\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571692,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,0));\\n        for(int r = 0;r<grid.size();r++){\\n            for(int c = 0;c<grid[0].size();c++){\\n                set<int> topLeft,bottomRight;\\n                \\n                for(int i=r-1,j=c-1;i>=0 && j>=0;i--,j--){\\n                    topLeft.insert(grid[i][j]);\\n                }\\n                for(int i=r+1,j=c+1;i<grid.size() && j<grid[0].size();i++,j++){\\n                    bottomRight.insert(grid[i][j]);\\n                }\\n                \\n                int x = topLeft.size();\\n                int y = bottomRight.size();\\n                res[r][c] = abs(x-y);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,0));\\n        for(int r = 0;r<grid.size();r++){\\n            for(int c = 0;c<grid[0].size();c++){\\n                set<int> topLeft,bottomRight;\\n                \\n                for(int i=r-1,j=c-1;i>=0 && j>=0;i--,j--){\\n                    topLeft.insert(grid[i][j]);\\n                }\\n                for(int i=r+1,j=c+1;i<grid.size() && j<grid[0].size();i++,j++){\\n                    bottomRight.insert(grid[i][j]);\\n                }\\n                \\n                int x = topLeft.size();\\n                int y = bottomRight.size();\\n                res[r][c] = abs(x-y);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571560,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>> ans=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                unordered_set<int> topleft,bottomright;\\n                int i=r,j=c,i1=r,j1=c;\\n                while(i>0 && j>0){\\n                    i--;\\n                    j--;\\n                    if(i>=0&&j>=0)\\n                    topleft.insert(grid[i][j]);\\n                }\\n                while(i1<m-1 && j1<n-1){\\n                    i1++;\\n                    j1++;\\n                    if(i1<m&&j1<n)\\n                    bottomright.insert(grid[i1][j1]);\\n                }\\n                int x=(topleft.size()-bottomright.size());\\n                ans[r][c]=abs(x);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```\\n# Upvote if this helped!~ :D\\n![upvote5.jpeg](https://assets.leetcode.com/users/images/458b3457-8aa5-4cc6-8bac-b69a6dec86f4_1685269377.6568317.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>> ans=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                unordered_set<int> topleft,bottomright;\\n                int i=r,j=c,i1=r,j1=c;\\n                while(i>0 && j>0){\\n                    i--;\\n                    j--;\\n                    if(i>=0&&j>=0)\\n                    topleft.insert(grid[i][j]);\\n                }\\n                while(i1<m-1 && j1<n-1){\\n                    i1++;\\n                    j1++;\\n                    if(i1<m&&j1<n)\\n                    bottomright.insert(grid[i1][j1]);\\n                }\\n                int x=(topleft.size()-bottomright.size());\\n                ans[r][c]=abs(x);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571553,
                "title": "fastest-o-n-m-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have to calculate cell value depending on diagonal only we can split problem to on diagonal. In this case diagonal can be represented as array where we have to calculate left and right statistic for each cell in array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- go over diagonals\\n- for each diagonal use two counters for right_up and left_buttom values\\n  - go over diagonal and calculate left_buttom value for first cell\\n  - go over diagonal and calculate result value using counters, increase right_up and decrease left_buttom values\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * m)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(max(n, m))$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        # iter over diagonal starts only\\n        iter_row = ((i, 0) for i in range(len(grid)))\\n        iter_col = ((0, j) for j in range(1, len(grid[0])))\\n        for i, j in chain(iter_row, iter_col):\\n            # use two counters to calculate value for each cell\\n            left_up = Counter()\\n            right_bottom = Counter()\\n\\n            # fill right_bottom counter for diagonal start cell\\n            # right_bottom has all cells except one (start for start cell)\\n            xi = i + 1\\n            xj = j + 1\\n            while xi < len(grid) and xj < len(grid[0]):\\n                right_bottom[grid[xi][xj]] += 1\\n                xi += 1\\n                xj += 1\\n            \\n            # iter over diagonal one more time increasing left_up and decreasing right_bottom\\n            xi = i\\n            xj = j\\n            while True:\\n                # calculate cell result value\\n                r = abs(len(left_up) - len(right_bottom))\\n                # increase left_up\\n                left_up[grid[xi][xj]] += 1\\n                # store result value\\n                grid[xi][xj] = r\\n\\n                # check we in grid bounds\\n                xi += 1\\n                xj += 1\\n                if xi == len(grid) or xj == len(grid[0]):\\n                    break\\n                # decrease right_bottom\\n                right_bottom[grid[xi][xj]] -= 1\\n                if right_bottom[grid[xi][xj]] == 0:\\n                    del right_bottom[grid[xi][xj]]\\n\\n        return grid\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\\n        # iter over diagonal starts only\\n        iter_row = ((i, 0) for i in range(len(grid)))\\n        iter_col = ((0, j) for j in range(1, len(grid[0])))\\n        for i, j in chain(iter_row, iter_col):\\n            # use two counters to calculate value for each cell\\n            left_up = Counter()\\n            right_bottom = Counter()\\n\\n            # fill right_bottom counter for diagonal start cell\\n            # right_bottom has all cells except one (start for start cell)\\n            xi = i + 1\\n            xj = j + 1\\n            while xi < len(grid) and xj < len(grid[0]):\\n                right_bottom[grid[xi][xj]] += 1\\n                xi += 1\\n                xj += 1\\n            \\n            # iter over diagonal one more time increasing left_up and decreasing right_bottom\\n            xi = i\\n            xj = j\\n            while True:\\n                # calculate cell result value\\n                r = abs(len(left_up) - len(right_bottom))\\n                # increase left_up\\n                left_up[grid[xi][xj]] += 1\\n                # store result value\\n                grid[xi][xj] = r\\n\\n                # check we in grid bounds\\n                xi += 1\\n                xj += 1\\n                if xi == len(grid) or xj == len(grid[0]):\\n                    break\\n                # decrease right_bottom\\n                right_bottom[grid[xi][xj]] -= 1\\n                if right_bottom[grid[xi][xj]] == 0:\\n                    del right_bottom[grid[xi][xj]]\\n\\n        return grid\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571445,
                "title": "simple-c-solution-beginner-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>v(51,0);\\n          vector<int>w(51,0);\\n        vector<vector<int>>ans(m,vector<int>(n));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int k=i+1;\\n                int l=j+1;\\n               while(k<m && l<n){\\n                   v[grid[k][l]]=1;\\n                   k++;\\n                   l++;\\n               }\\n                    int s=i-1;\\n                int t=j-1;\\n               while(s>=0 && t>=0){\\n                   w[grid[s][t]]=1;\\n                   s--;\\n                   t--;\\n               }\\n                int sum=0;\\n                int dif=0;\\n                for(int i=0;i<51;i++){\\n                    sum+=v[i];\\n                    v[i]=0;\\n                }\\n                 for(int i=0;i<51;i++){\\n                    dif+=w[i];\\n                    w[i]=0;\\n                }\\n                ans[i][j]=abs(sum-dif);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>v(51,0);\\n          vector<int>w(51,0);\\n        vector<vector<int>>ans(m,vector<int>(n));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int k=i+1;\\n                int l=j+1;\\n               while(k<m && l<n){\\n                   v[grid[k][l]]=1;\\n                   k++;\\n                   l++;\\n               }\\n                    int s=i-1;\\n                int t=j-1;\\n               while(s>=0 && t>=0){\\n                   w[grid[s][t]]=1;\\n                   s--;\\n                   t--;\\n               }\\n                int sum=0;\\n                int dif=0;\\n                for(int i=0;i<51;i++){\\n                    sum+=v[i];\\n                    v[i]=0;\\n                }\\n                 for(int i=0;i<51;i++){\\n                    dif+=w[i];\\n                    w[i]=0;\\n                }\\n                ans[i][j]=abs(sum-dif);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571366,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] ans = new int[grid.length][grid[0].length];\\n        \\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[i].length ; j++){\\n                int r = topLeft(grid, i, j);\\n                int c = bottomRight(grid, i, j);\\n                ans[i][j] = Math.abs(r - c);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int topLeft(int[][] grid, int i, int j){\\n        Set<Integer> hs = new HashSet<>();\\n        if(i == 0  || j == 0){\\n            return 0; \\n        }\\n        int r = i - 1;\\n        int c = j - 1;\\n        while(r >= 0 && c >= 0){\\n            hs.add(grid[r][c]);\\n            r--;\\n            c--;\\n        }\\n        return hs.size();\\n    }\\n    \\n    public int bottomRight(int[][] grid, int i, int j){\\n        Set<Integer> hs = new HashSet<>();\\n        if(i == grid.length - 1  || j == grid[i].length - 1){\\n            return 0; \\n        }\\n        int r = i + 1;\\n        int c = j + 1;\\n        while(r < grid.length && c < grid[i].length){\\n            hs.add(grid[r][c]);\\n            r++;\\n            c++;\\n        }\\n        return hs.size();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] ans = new int[grid.length][grid[0].length];\\n        \\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[i].length ; j++){\\n                int r = topLeft(grid, i, j);\\n                int c = bottomRight(grid, i, j);\\n                ans[i][j] = Math.abs(r - c);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int topLeft(int[][] grid, int i, int j){\\n        Set<Integer> hs = new HashSet<>();\\n        if(i == 0  || j == 0){\\n            return 0; \\n        }\\n        int r = i - 1;\\n        int c = j - 1;\\n        while(r >= 0 && c >= 0){\\n            hs.add(grid[r][c]);\\n            r--;\\n            c--;\\n        }\\n        return hs.size();\\n    }\\n    \\n    public int bottomRight(int[][] grid, int i, int j){\\n        Set<Integer> hs = new HashSet<>();\\n        if(i == grid.length - 1  || j == grid[i].length - 1){\\n            return 0; \\n        }\\n        int r = i + 1;\\n        int c = j + 1;\\n        while(r < grid.length && c < grid[i].length){\\n            hs.add(grid[r][c]);\\n            r++;\\n            c++;\\n        }\\n        return hs.size();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571287,
                "title": "easy-solution-cpp",
                "content": "# Complexity\\n- Time complexity:\\nO(m * n * k)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int topLeft = countDistinctTopLeft(grid, i, j);\\n                int bottomRight = countDistinctBottomRight(grid, i, j);\\n                answer[i][j] = abs(topLeft - bottomRight);\\n            }\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    int countDistinctTopLeft(const vector<vector<int>>& grid, int row, int col) {\\n        set<int> distinctValues;\\n        row--,col--;\\n        while (row >= 0 && col >= 0) {\\n            distinctValues.insert(grid[row][col]);\\n            row--;\\n            col--;\\n        }\\n        return distinctValues.size();\\n    }\\n\\n    int countDistinctBottomRight(const vector<vector<int>>& grid, int row, int col) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        set<int> distinctValues;\\n        row++,col++;\\n        while (row < m && col < n) {\\n            distinctValues.insert(grid[row][col]);\\n            row++;\\n            col++;\\n        }\\n        return distinctValues.size();\\n    }\\n};\\n\\n\\n//[[3,2,1,0],[2,1,0,1],[1,0,1,2],[0,1,2,3]]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n));\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int topLeft = countDistinctTopLeft(grid, i, j);\\n                int bottomRight = countDistinctBottomRight(grid, i, j);\\n                answer[i][j] = abs(topLeft - bottomRight);\\n            }\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    int countDistinctTopLeft(const vector<vector<int>>& grid, int row, int col) {\\n        set<int> distinctValues;\\n        row--,col--;\\n        while (row >= 0 && col >= 0) {\\n            distinctValues.insert(grid[row][col]);\\n            row--;\\n            col--;\\n        }\\n        return distinctValues.size();\\n    }\\n\\n    int countDistinctBottomRight(const vector<vector<int>>& grid, int row, int col) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        set<int> distinctValues;\\n        row++,col++;\\n        while (row < m && col < n) {\\n            distinctValues.insert(grid[row][col]);\\n            row++;\\n            col++;\\n        }\\n        return distinctValues.size();\\n    }\\n};\\n\\n\\n//[[3,2,1,0],[2,1,0,1],[1,0,1,2],[0,1,2,3]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571252,
                "title": "simple-bruteforce-with-unordered-set-easy-elegant-specially-designed-for-beginner-s",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++){\\n            vector<int>temp;\\n            for(int j=0;j<m;j++){\\n                unordered_set<int>st; // to count distinct instances;\\n                int ii=i-1,jj=j-1;\\n                while(ii>=0 and jj>=0){\\n                    st.insert(grid[ii][jj]);\\n                    ii--; jj--;\\n                }\\n                int topleftDia = st.size();\\n                st.clear();\\n                ii=i+1,jj=j+1;\\n                while(ii<n and jj<m){\\n                    st.insert(grid[ii][jj]);\\n                    ii++; jj++;\\n                }\\n                int bottomRightDia = st.size();\\n                temp.push_back(abs(topleftDia-bottomRightDia));\\n            }\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity -> O(n x m x min(n,m)); \\nSpace Complexity -> O(n*m)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        vector<vector<int>>ans;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++){\\n            vector<int>temp;\\n            for(int j=0;j<m;j++){\\n                unordered_set<int>st; // to count distinct instances;\\n                int ii=i-1,jj=j-1;\\n                while(ii>=0 and jj>=0){\\n                    st.insert(grid[ii][jj]);\\n                    ii--; jj--;\\n                }\\n                int topleftDia = st.size();\\n                st.clear();\\n                ii=i+1,jj=j+1;\\n                while(ii<n and jj<m){\\n                    st.insert(grid[ii][jj]);\\n                    ii++; jj++;\\n                }\\n                int bottomRightDia = st.size();\\n                temp.push_back(abs(topleftDia-bottomRightDia));\\n            }\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571251,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] DifferenceOfDistinctValues(int[][] grid) {\\n        int[][] r = new int[grid.Length][];\\n        int i=0;\\n\\t\\twhile(i < r.Length){\\n            r[i] = new int[grid[0].Length];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n        i=0;\\n\\t\\twhile(i < grid.Length){\\n\\t\\t\\tint j=0;\\n\\t\\t\\twhile(j < grid[0].Length){\\n                r[i][j] = Math.Abs(topLeft(grid, i, j) - bottomRight(grid,i,j));\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n        return r;\\n    }\\n\\n    private int topLeft(int[][] grid, int i, int j){\\n        HashSet<int> h = new();\\n\\n        i--;\\n        j--;\\n        while(i > -1 && j > -1){\\n            h.Add(grid[i][j]);\\n            i--;\\n            j--;\\n        }\\n\\n        return h.Count;\\n    }\\n\\n    private int bottomRight(int[][] grid, int i, int j){\\n        HashSet<int> h = new();\\n\\n        i++;\\n        j++;\\n        while(i < grid.Length && j < grid[0].Length){\\n            h.Add(grid[i][j]);\\n            i++;\\n            j++;\\n        }\\n\\n        return h.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] DifferenceOfDistinctValues(int[][] grid) {\\n        int[][] r = new int[grid.Length][];\\n        int i=0;\\n\\t\\twhile(i < r.Length){\\n            r[i] = new int[grid[0].Length];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n        i=0;\\n\\t\\twhile(i < grid.Length){\\n\\t\\t\\tint j=0;\\n\\t\\t\\twhile(j < grid[0].Length){\\n                r[i][j] = Math.Abs(topLeft(grid, i, j) - bottomRight(grid,i,j));\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n        return r;\\n    }\\n\\n    private int topLeft(int[][] grid, int i, int j){\\n        HashSet<int> h = new();\\n\\n        i--;\\n        j--;\\n        while(i > -1 && j > -1){\\n            h.Add(grid[i][j]);\\n            i--;\\n            j--;\\n        }\\n\\n        return h.Count;\\n    }\\n\\n    private int bottomRight(int[][] grid, int i, int j){\\n        HashSet<int> h = new();\\n\\n        i++;\\n        j++;\\n        while(i < grid.Length && j < grid[0].Length){\\n            h.Add(grid[i][j]);\\n            i++;\\n            j++;\\n        }\\n\\n        return h.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571229,
                "title": "magic-of-two-sets-easy-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(m * n * max(m, n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n )\\n        additional space for storing the result  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        vector<vector<int>> ans(row,vector<int>(col));\\n        \\n        for(int i=0;i<row;i++)\\n         for(int j=0;j<col;j++){\\n                unordered_set<int> top;\\n                unordered_set<int> down;\\n             \\n             //find topleft diagnols\\n             int ni=i-1;\\n             int nj=j-1;\\n             while(ni>=0 && nj>=0)\\n                 top.insert(grid[ni--][nj--]);\\n             \\n             //find downright diagnols\\n              ni=i+1;\\n              nj=j+1;\\n             while(ni<row && nj<col)\\n                 down.insert(grid[ni++][nj++]);\\n             int a=top.size();\\n             int b=down.size();\\n             ans[i][j]=abs(a-b);\\n             \\n         }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n//please upvote if this helps you \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        vector<vector<int>> ans(row,vector<int>(col));\\n        \\n        for(int i=0;i<row;i++)\\n         for(int j=0;j<col;j++){\\n                unordered_set<int> top;\\n                unordered_set<int> down;\\n             \\n             //find topleft diagnols\\n             int ni=i-1;\\n             int nj=j-1;\\n             while(ni>=0 && nj>=0)\\n                 top.insert(grid[ni--][nj--]);\\n             \\n             //find downright diagnols\\n              ni=i+1;\\n              nj=j+1;\\n             while(ni<row && nj<col)\\n                 down.insert(grid[ni++][nj++]);\\n             int a=top.size();\\n             int b=down.size();\\n             ans[i][j]=abs(a-b);\\n             \\n         }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n//please upvote if this helps you \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571165,
                "title": "easy-c-sol-using-2-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n      int m=grid.size();\\n        int n=grid[0].size();\\n                vector<vector<int>> res(m,vector<int>(n,0));\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                 set<int> st1;\\n                int si=i-1;\\n                int sj=j-1;\\n                while(si>=0&&sj>=0)\\n                {\\nst1.insert(grid[si][sj]);\\n                    si--;\\n                    sj--;\\n                }        \\n               set<int> st2;\\n                int c=i+1;\\n                int d=j+1;\\n                while(c<m && d<n){\\n                        st2.insert(grid[c][d]);\\n                    c++;\\n                    d++;\\n                }\\n            \\n                int l=st1.size();\\n                int o=st2.size();\\n                res[i][j]=abs(l-o);\\n            }\\n        }\\n        return res;\\n            \\n\\n            }\\n        \\n        \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) \\n    {\\n      int m=grid.size();\\n        int n=grid[0].size();\\n                vector<vector<int>> res(m,vector<int>(n,0));\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                 set<int> st1;\\n                int si=i-1;\\n                int sj=j-1;\\n                while(si>=0&&sj>=0)\\n                {\\nst1.insert(grid[si][sj]);\\n                    si--;\\n                    sj--;\\n                }        \\n               set<int> st2;\\n                int c=i+1;\\n                int d=j+1;\\n                while(c<m && d<n){\\n                        st2.insert(grid[c][d]);\\n                    c++;\\n                    d++;\\n                }\\n            \\n                int l=st1.size();\\n                int o=st2.size();\\n                res[i][j]=abs(l-o);\\n            }\\n        }\\n        return res;\\n            \\n\\n            }\\n        \\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571129,
                "title": "once-we-choose-the-proper-data-structure-the-rest-just-follows",
                "content": "\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<long long>> tl(m + 1, vector<long long>(n + 1));\\n        vector<vector<long long>> br(m + 1, vector<long long>(n + 1));\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                tl[i + 1][j + 1] = tl[i][j] | (1LL << grid[i][j]);\\n        \\n        for (int i = m - 1; i >= 0; --i)\\n            for (int j = n - 1; j >= 0; --j)\\n                br[i][j] = br[i + 1][j + 1] | (1LL << grid[i][j]);\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                grid[i][j] = abs(__builtin_popcountll(tl[i][j]) - __builtin_popcountll(br[i + 1][j + 1]));\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<long long>> tl(m + 1, vector<long long>(n + 1));\\n        vector<vector<long long>> br(m + 1, vector<long long>(n + 1));\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                tl[i + 1][j + 1] = tl[i][j] | (1LL << grid[i][j]);\\n        \\n        for (int i = m - 1; i >= 0; --i)\\n            for (int j = n - 1; j >= 0; --j)\\n                br[i][j] = br[i + 1][j + 1] | (1LL << grid[i][j]);\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                grid[i][j] = abs(__builtin_popcountll(tl[i][j]) - __builtin_popcountll(br[i + 1][j + 1]));\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571112,
                "title": "26ms-java-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] ans = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < grid[i].length; ++j) {\\n                calculate(i, j, ans, grid);\\n            }\\n        }\\n        return ans;\\n    }\\n    public void calculate(int x, int y, int[][] ans, int[][] grid) {\\n        Set<Integer> topSet = new HashSet<>();\\n        Set<Integer> bottomSet = new HashSet<>();\\n        // topSet\\n        int i = x;\\n        int j = y;\\n        while (--i >=0 && --j >= 0) {\\n            topSet.add(grid[i][j]);\\n        }\\n        // bottomSet\\n        i = x;\\n        j = y;\\n        while (++i <= grid.length-1 && ++j <= grid[i].length-1) {\\n            bottomSet.add(grid[i][j]);\\n        }\\n        ans[x][y] = Math.abs(bottomSet.size() - topSet.size());\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int[][] ans = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < grid[i].length; ++j) {\\n                calculate(i, j, ans, grid);\\n            }\\n        }\\n        return ans;\\n    }\\n    public void calculate(int x, int y, int[][] ans, int[][] grid) {\\n        Set<Integer> topSet = new HashSet<>();\\n        Set<Integer> bottomSet = new HashSet<>();\\n        // topSet\\n        int i = x;\\n        int j = y;\\n        while (--i >=0 && --j >= 0) {\\n            topSet.add(grid[i][j]);\\n        }\\n        // bottomSet\\n        i = x;\\n        j = y;\\n        while (++i <= grid.length-1 && ++j <= grid[i].length-1) {\\n            bottomSet.add(grid[i][j]);\\n        }\\n        ans[x][y] = Math.abs(bottomSet.size() - topSet.size());\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571104,
                "title": "c-simplest-solution-traversing-the-diagonal",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int r, int c, vector<vector<int>>& grid, int m, int n, int isTopLeft) {\\n        set<int> s;\\n        if (isTopLeft) {\\n            while (r >= 0 && c >= 0)\\n                s.insert(grid[r--][c--]);\\n        } else {\\n            while (r < m && c < n)\\n                s.insert(grid[r++][c++]);\\n        }\\n        return s.size();\\n    }\\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans[i][j] = abs(helper(i - 1, j - 1, grid, m, n, 1) - helper(i + 1, j + 1, grid, m, n, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int r, int c, vector<vector<int>>& grid, int m, int n, int isTopLeft) {\\n        set<int> s;\\n        if (isTopLeft) {\\n            while (r >= 0 && c >= 0)\\n                s.insert(grid[r--][c--]);\\n        } else {\\n            while (r < m && c < n)\\n                s.insert(grid[r++][c++]);\\n        }\\n        return s.size();\\n    }\\n    \\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans[i][j] = abs(helper(i - 1, j - 1, grid, m, n, 1) - helper(i + 1, j + 1, grid, m, n, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571070,
                "title": "clean-solution-self-explanatory",
                "content": "# Complexity\\n- Time complexity: $$O(n^3)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    bool isValid(int i, int j, int m, int n){\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n}\\n\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                unordered_map<int,int> topLeft,bottomRight; //in order to store unique elements\\n                int x1 = i, x2 = i, y1 = j, y2 = j;\\n\\n                while(isValid(--x1,--y1,m,n)) topLeft[grid[x1][y1]]++;\\n                while(isValid(++x2,++y2,m,n)) bottomRight[grid[x2][y2]]++;\\n\\n                int left = topLeft.size(), right = bottomRight.size();\\n                ans[i][j] = abs(left - right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int i, int j, int m, int n){\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n}\\n\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                unordered_map<int,int> topLeft,bottomRight; //in order to store unique elements\\n                int x1 = i, x2 = i, y1 = j, y2 = j;\\n\\n                while(isValid(--x1,--y1,m,n)) topLeft[grid[x1][y1]]++;\\n                while(isValid(++x2,++y2,m,n)) bottomRight[grid[x2][y2]]++;\\n\\n                int left = topLeft.size(), right = bottomRight.size();\\n                ans[i][j] = abs(left - right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571034,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfsl(vector<vector<int>>& grid, set<int> &s,int n,int m,int i,int j)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return;\\n        s.insert(grid[i][j]);\\n        dfsl(grid,s,n,m,i-1,j-1);\\n    }\\n    void dfsr(vector<vector<int>>& grid, set<int> &s,int n,int m,int i,int j)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return;\\n        s.insert(grid[i][j]);\\n        dfsr(grid,s,n,m,i+1,j+1);\\n    }\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> grid1(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                set<int> s,s1;\\n                dfsl(grid,s,n,m,i-1,j-1);\\n                dfsr(grid,s1,n,m,i+1,j+1);\\n                int x=s.size();\\n                int y=s1.size();\\n                grid1[i][j]=abs(x-y);\\n            }\\n        }\\n        return grid1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfsl(vector<vector<int>>& grid, set<int> &s,int n,int m,int i,int j)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return;\\n        s.insert(grid[i][j]);\\n        dfsl(grid,s,n,m,i-1,j-1);\\n    }\\n    void dfsr(vector<vector<int>>& grid, set<int> &s,int n,int m,int i,int j)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return;\\n        s.insert(grid[i][j]);\\n        dfsr(grid,s,n,m,i+1,j+1);\\n    }\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> grid1(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                set<int> s,s1;\\n                dfsl(grid,s,n,m,i-1,j-1);\\n                dfsr(grid,s1,n,m,i+1,j+1);\\n                int x=s.size();\\n                int y=s1.size();\\n                grid1[i][j]=abs(x-y);\\n            }\\n        }\\n        return grid1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571020,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public HashSet<Integer> findDistinctleft(int[][] mat, int sr,int sc){\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=sr,j=sc; i>=0 && j>=0; i--,j--){\\n            set.add(mat[i][j]);\\n        }\\n        return set;\\n    }\\n    public HashSet<Integer> findDistinctright(int[][] mat, int sr,int sc){\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=sr,j=sc; i<mat.length && j<mat[0].length; i++,j++){\\n            set.add(mat[i][j]);\\n        }\\n        return set;\\n    }\\n    \\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] ans = new int[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                HashSet<Integer> leftdia = findDistinctleft(grid,i-1,j-1);\\n                HashSet<Integer> rightdia = findDistinctright(grid,i+1,j+1);\\n                ans[i][j] = Math.abs(rightdia.size()-leftdia.size());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public HashSet<Integer> findDistinctleft(int[][] mat, int sr,int sc){\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=sr,j=sc; i>=0 && j>=0; i--,j--){\\n            set.add(mat[i][j]);\\n        }\\n        return set;\\n    }\\n    public HashSet<Integer> findDistinctright(int[][] mat, int sr,int sc){\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=sr,j=sc; i<mat.length && j<mat[0].length; i++,j++){\\n            set.add(mat[i][j]);\\n        }\\n        return set;\\n    }\\n    \\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] ans = new int[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                HashSet<Integer> leftdia = findDistinctleft(grid,i-1,j-1);\\n                HashSet<Integer> rightdia = findDistinctright(grid,i+1,j+1);\\n                ans[i][j] = Math.abs(rightdia.size()-leftdia.size());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571019,
                "title": "java-distinct-on-diagonals-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n        \\n        for(int i=0;i<m;i++){\\n           for(int j=0;j<n;j++){\\n               ans[i][j] = Math.abs(distinct(mat,i,j,true) - distinct(mat,i,j,false));\\n           }\\n        }\\n        return ans;\\n    }\\n    \\n    int distinct(int[][] mat, int r, int c, boolean val){\\n        int m = mat.length, n = mat[0].length;\\n        Set<Integer> set = new HashSet<>();\\n        \\n        if(val){ //Top-left Diagonal\\n            while(r > 0 && c > 0)\\n                set.add(mat[--r][--c]);\\n            \\n            return set.size();\\n        }\\n        //Bottom-right Diagonal \\n        while(r < m-1 && c < n-1)\\n           set.add(mat[++r][++c]);\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n        \\n        for(int i=0;i<m;i++){\\n           for(int j=0;j<n;j++){\\n               ans[i][j] = Math.abs(distinct(mat,i,j,true) - distinct(mat,i,j,false));\\n           }\\n        }\\n        return ans;\\n    }\\n    \\n    int distinct(int[][] mat, int r, int c, boolean val){\\n        int m = mat.length, n = mat[0].length;\\n        Set<Integer> set = new HashSet<>();\\n        \\n        if(val){ //Top-left Diagonal\\n            while(r > 0 && c > 0)\\n                set.add(mat[--r][--c]);\\n            \\n            return set.size();\\n        }\\n        //Bottom-right Diagonal \\n        while(r < m-1 && c < n-1)\\n           set.add(mat[++r][++c]);\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570907,
                "title": "easy-java-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n * (m + n)), where m is the number of rows in the grid and n is the number of columns.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[][] = new int[m][n];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j =0; j<n; j++) {\\n                Set<Integer> s1 = new HashSet<>();\\n                Set<Integer> s2 = new HashSet<>();\\n                int r=i-1;\\n                int c=j-1;\\n                \\n                while(r>=0 && c >=0) {\\n                    s1.add(grid[r][c]);\\n                    r--;c--;\\n                }\\n                r = i+1;\\n                c = j+1;\\n                while(r<m && c<n) {\\n                    s2.add(grid[r][c]);\\n                    r++;c++;\\n                }\\n                ans[i][j] = Math.abs(s1.size()-s2.size());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[][] = new int[m][n];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j =0; j<n; j++) {\\n                Set<Integer> s1 = new HashSet<>();\\n                Set<Integer> s2 = new HashSet<>();\\n                int r=i-1;\\n                int c=j-1;\\n                \\n                while(r>=0 && c >=0) {\\n                    s1.add(grid[r][c]);\\n                    r--;c--;\\n                }\\n                r = i+1;\\n                c = j+1;\\n                while(r<m && c<n) {\\n                    s2.add(grid[r][c]);\\n                    r++;c++;\\n                }\\n                ans[i][j] = Math.abs(s1.size()-s2.size());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570863,
                "title": "c-easy-brute-force-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n,0));\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                unordered_set<int> a,b;\\n                for(int k = 0; k < i; ++k){\\n                    for(int l = 0; l < j; ++l){\\n                        if(i - k == j - l){\\n                            a.insert(grid[k][l]);\\n                        }\\n                    }\\n                }\\n                \\n                for(int k = i + 1; k < m; ++k){\\n                    for(int l = j + 1; l < n; ++l){\\n                        if(i - k == j - l){\\n                            b.insert(grid[k][l]);\\n                        }\\n                    }\\n                }\\n                \\n                int x = a.size(),y = b.size();\\n                ans[i][j] = abs(x - y);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n,0));\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                unordered_set<int> a,b;\\n                for(int k = 0; k < i; ++k){\\n                    for(int l = 0; l < j; ++l){\\n                        if(i - k == j - l){\\n                            a.insert(grid[k][l]);\\n                        }\\n                    }\\n                }\\n                \\n                for(int k = i + 1; k < m; ++k){\\n                    for(int l = j + 1; l < n; ++l){\\n                        if(i - k == j - l){\\n                            b.insert(grid[k][l]);\\n                        }\\n                    }\\n                }\\n                \\n                int x = a.size(),y = b.size();\\n                ans[i][j] = abs(x - y);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1908183,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908737,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908660,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908196,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1909900,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1909426,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908966,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908800,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908228,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1942836,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908183,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908737,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908660,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908196,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1909900,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1909426,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908966,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908800,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1908228,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            },
            {
                "id": 1942836,
                "content": [
                    {
                        "username": "AhmadAQ",
                        "content": "is it poorly written or is it just me?"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@Terminator_N2121](/Terminator_N2121) it is medium now xD\\n"
                    },
                    {
                        "username": "Terminator_N2121",
                        "content": "exactlyy!! MindFuck++\\nThey should atleast explain the question well and clear...took >1hr unneccessarily.\\nig it should be tagged as medium "
                    },
                    {
                        "username": "_srahul_",
                        "content": "Such a horribly written problem description, ruined my 15-20 minutes easily. I was on the verge of skipping this problem."
                    },
                    {
                        "username": "aixImk_0",
                        "content": "LC: This is how we turn an easy question into medium."
                    },
                    {
                        "username": "iota_codes",
                        "content": "still not able to comprehend the problem statement \\uD83D\\uDE14"
                    },
                    {
                        "username": "Socrii13",
                        "content": "basically it states that you have to traverse the matrix and find out top left distinct elements diagonally and similarly for bottom right distinct element in the diagonally and take the absolute difference and fill into the answer matrix and that position. hope u get it."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone explain the problem."
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Example 1 ruins it more. The description should have been better."
                    },
                    {
                        "username": "genius52",
                        "content": "Please make description and example better."
                    },
                    {
                        "username": "_srahul_",
                        "content": "For someone, who\\'s still unable to process this question, I\\'ve simplified the problem statement here,\\nhttps://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/solutions/3572121/simplified-problem-statement/"
                    },
                    {
                        "username": "_srahul_",
                        "content": "Yups, submitted the code at 36th minute, that means It took me almost 30 minutes, to understand it."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Nice.. Problem statement was just baffling, bewildering till core.. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Augus7",
                        "content": "why leetcode give these horrible explanations"
                    },
                    {
                        "username": "victCh",
                        "content": "I have not been able to understand the condition of the problem"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "How many of you agree that this is a MEDIUM in terms of description ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Houses in a Circular Street",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Count Occurrences in Text",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2059503,
                "content": [
                    {
                        "username": "hhik1996",
                        "content": "why would this appear in 30 Days of Pandas"
                    },
                    {
                        "username": "laserShark",
                        "content": "[@bytchenko](/bytchenko) The drop down doesn\\'t show the pandas option as of right now. Looks like a bug on leetcodes end."
                    },
                    {
                        "username": "hhik1996",
                        "content": "[@bytchenko](/bytchenko) I know, it\\'s just that we are not offered the python option"
                    },
                    {
                        "username": "bytchenko",
                        "content": "It can be implemented in SQL (and originally it was a SQL problem), but it can be done by Python Pandas as well as Java Streams, C# Linq... "
                    },
                    {
                        "username": "evergreenyoung",
                        "content": "Actually it\\'s asking how many rows containing the key words, because a row \\'bull bull bull\\' is counted as 1."
                    },
                    {
                        "username": "bytchenko",
                        "content": "Note, that **standalone word** means that the *word* must not be the **first** or **last** word in the text, e.g. `bull is not a bear`, doesn't contain `bull` or `bear`. "
                    }
                ]
            },
            {
                "id": 1967393,
                "content": [
                    {
                        "username": "hhik1996",
                        "content": "why would this appear in 30 Days of Pandas"
                    },
                    {
                        "username": "laserShark",
                        "content": "[@bytchenko](/bytchenko) The drop down doesn\\'t show the pandas option as of right now. Looks like a bug on leetcodes end."
                    },
                    {
                        "username": "hhik1996",
                        "content": "[@bytchenko](/bytchenko) I know, it\\'s just that we are not offered the python option"
                    },
                    {
                        "username": "bytchenko",
                        "content": "It can be implemented in SQL (and originally it was a SQL problem), but it can be done by Python Pandas as well as Java Streams, C# Linq... "
                    },
                    {
                        "username": "evergreenyoung",
                        "content": "Actually it\\'s asking how many rows containing the key words, because a row \\'bull bull bull\\' is counted as 1."
                    },
                    {
                        "username": "bytchenko",
                        "content": "Note, that **standalone word** means that the *word* must not be the **first** or **last** word in the text, e.g. `bull is not a bear`, doesn't contain `bull` or `bear`. "
                    }
                ]
            },
            {
                "id": 1932247,
                "content": [
                    {
                        "username": "hhik1996",
                        "content": "why would this appear in 30 Days of Pandas"
                    },
                    {
                        "username": "laserShark",
                        "content": "[@bytchenko](/bytchenko) The drop down doesn\\'t show the pandas option as of right now. Looks like a bug on leetcodes end."
                    },
                    {
                        "username": "hhik1996",
                        "content": "[@bytchenko](/bytchenko) I know, it\\'s just that we are not offered the python option"
                    },
                    {
                        "username": "bytchenko",
                        "content": "It can be implemented in SQL (and originally it was a SQL problem), but it can be done by Python Pandas as well as Java Streams, C# Linq... "
                    },
                    {
                        "username": "evergreenyoung",
                        "content": "Actually it\\'s asking how many rows containing the key words, because a row \\'bull bull bull\\' is counted as 1."
                    },
                    {
                        "username": "bytchenko",
                        "content": "Note, that **standalone word** means that the *word* must not be the **first** or **last** word in the text, e.g. `bull is not a bear`, doesn't contain `bull` or `bear`. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Ways to Split Array Into Good Subarrays",
        "question_content": "<p>You are given a binary array <code>nums</code>.</p>\n\n<p>A subarray of an array is <strong>good</strong> if it contains <strong>exactly</strong> <strong>one</strong> element with the value <code>1</code>.</p>\n\n<p>Return <em>an integer denoting the number of ways to split the array </em><code>nums</code><em> into <strong>good</strong> subarrays</em>. As the number may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0,0,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are 3 ways to split nums into good subarrays:\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There is 1 way to split nums into good subarrays:\n- [0,1,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3679176,
                "title": "explained-multiply-all-zero-counts-between-1-s",
                "content": "<b>Up vote if you like the solution</b>\\n# Approach\\n1. Eliminate initial zeros. Check if iteration reached end or not. If reached then return 0 as there are no 1s in the input.\\n2. Strat counting 0\\'s between two 1s and mulitply (count + 1) to ans, as we can have n+1 number of division possible in between those two 1\\'s\\n\\n# Code\\n```\\nint numberOfGoodSubarraySplits(vector<int>& nums) {\\n    long long ans = 1, m = 1000000007, count  = 0;\\n    int i = 0;\\n    while(i < nums.size() && nums[i] == 0) ++i;\\n    if(i >= nums.size() ) return 0;\\n    while(i < nums.size()){\\n        if(nums[i] == 1){  ans = (ans * (count +1 ))%m;  count = 0; }\\n        else count++;\\n        i++;\\n    }\\n    return ans;\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint numberOfGoodSubarraySplits(vector<int>& nums) {\\n    long long ans = 1, m = 1000000007, count  = 0;\\n    int i = 0;\\n    while(i < nums.size() && nums[i] == 0) ++i;\\n    if(i >= nums.size() ) return 0;\\n    while(i < nums.size()){\\n        if(nums[i] == 1){  ans = (ans * (count +1 ))%m;  count = 0; }\\n        else count++;\\n        i++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679275,
                "title": "c-o-n-time-easy-to-understand",
                "content": "Time complexity : O(n)\\nspace complexity : O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int> v;\\n        bool first = false;\\n        int cnt = 0;\\n\\n        // Iterate over the array\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                if(first) \\n                    v.push_back(cnt); // Store the count of consecutive zeros\\n                first = true;\\n                cnt = 0;\\n            } else {\\n                cnt++; // Count consecutive zeros\\n            }\\n        }\\n\\n        if(!first) \\n            return 0; // If there is no \\'1\\' in the array, return 0\\n\\n        long long ans = 1;\\n        long long mod = 1e9 + 7;\\n\\n        // Multiply all counts by (count + 1) and take the modulo\\n        for(auto val : v) {\\n            ans = (ans * (val + 1)) % mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int> v;\\n        bool first = false;\\n        int cnt = 0;\\n\\n        // Iterate over the array\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                if(first) \\n                    v.push_back(cnt); // Store the count of consecutive zeros\\n                first = true;\\n                cnt = 0;\\n            } else {\\n                cnt++; // Count consecutive zeros\\n            }\\n        }\\n\\n        if(!first) \\n            return 0; // If there is no \\'1\\' in the array, return 0\\n\\n        long long ans = 1;\\n        long long mod = 1e9 + 7;\\n\\n        // Multiply all counts by (count + 1) and take the modulo\\n        for(auto val : v) {\\n            ans = (ans * (val + 1)) % mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679119,
                "title": "java-python-3-sliding-window-w-analysis",
                "content": "Let us study the first example given in the problem: \\nInput: nums = `[0,1,0,0,1]`\\nOutput: `3`\\nExplanation: There are `3` ways to split nums into good subarrays:\\n- [0,1] [0,0,1]\\n- [0,1,0] [0,1]\\n- [0,1,0,0] [1]\\n \\n \\n1. Traverse the input array, before encountering first `1`, there is NO good subarray at all. Therefore, we initialize the `cnt` as `0`;\\n2. After finding the first `1`, we at least can have `1` good subarray and hence we change `cnt` from `0` to `1`;\\n3. Then the sliding window starts: the previous `1` as lower bound, `lo`, exclusively, next `1` as upper bound, `hi`, inclusively (we can refer to the above example for more details.); for each sliding window, we multiply its width, `hi - lo`, to `cnt`;\\n4. Repeat step 3 till the end of the input, and the result modulo `1_000_000_007` is the solution.\\n \\n\\n```java\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long cnt = 0;\\n        for (int lo = -1, hi = 0; hi < nums.length; ++hi) {\\n            if (nums[hi] == 1) {\\n                if (cnt == 0) {\\n                    cnt = 1;\\n                }else {\\n                    cnt *= hi - lo;\\n                    cnt %= 1_000_000_007;\\n                }\\n                lo = hi;\\n            }\\n        }\\n        return (int)cnt;\\n    }\\n```\\n\\n```python\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        cnt = 0\\n        lo = -1\\n        for hi, b in enumerate(nums):\\n            if b == 1:\\n                if cnt == 0:\\n                    cnt = 1\\n                else:\\n                    cnt *= hi - lo\\n                    cnt %= 10 ** 9 + 7\\n                lo = hi\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = nums.length`.\\n\\n----\\n\\n\\nPlease\\n# Upvote\\n\\nif the post is helpful for you.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```java\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long cnt = 0;\\n        for (int lo = -1, hi = 0; hi < nums.length; ++hi) {\\n            if (nums[hi] == 1) {\\n                if (cnt == 0) {\\n                    cnt = 1;\\n                }else {\\n                    cnt *= hi - lo;\\n                    cnt %= 1_000_000_007;\\n                }\\n                lo = hi;\\n            }\\n        }\\n        return (int)cnt;\\n    }\\n```\n```python\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        cnt = 0\\n        lo = -1\\n        for hi, b in enumerate(nums):\\n            if b == 1:\\n                if cnt == 0:\\n                    cnt = 1\\n                else:\\n                    cnt *= hi - lo\\n                    cnt %= 10 ** 9 + 7\\n                lo = hi\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3679975,
                "title": "dp-pick-and-not-pick-explained-handwritten-fully-with-dry-run-o-n-time",
                "content": "# Idea\\n### RECURSIVE ALGO\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![CapturedImage-25-06-2023 11-03-56.png](https://assets.leetcode.com/users/images/46cc1e80-3f1f-4cea-9e3a-5db360b010bb_1687677117.63368.png)\\n### DRY RUN\\n![CapturedImage-25-06-2023 13-03-50.png](https://assets.leetcode.com/users/images/5dca2859-ff42-492e-b1f9-4f5f569cddff_1687678450.494296.png)\\n\\n### Basically\\nPICK is NOT SPLIT\\nNOT PICK is SPLIT \\n\\n\\n# Complexity\\n- Time complexity: O(N*2) \\n- 2 states of count\\n- N states of Idx\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*2) + O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\nconst int MOD = 1e9 + 7;\\nint helper(int idx, int count, vector<int>& nums, vector<vector<int>>& dp){\\n\\n    if(idx < 0){\\n        if(count == 1)\\n            return 1;\\n        return 0;\\n    }\\n    if(nums[idx] == 1) count++;\\n    if(count > 1) //as we cannot keep more than one 1\\n        return 0;  \\n    \\n    if(dp[idx][count] != -1) return dp[idx][count];\\n    \\n    int pick = helper(idx-1, count, nums, dp);\\n    //count remains the same (pick = no split, add into same subarry)\\n    \\n    int notpick = 0;\\n    if(count == 1){\\n        notpick = helper(idx-1, 0, nums, dp);\\n        //we didn\\'t pick into same array, we break and create new subarry\\n        //so count is reset with 0\\n    }\\n    \\n    return dp[idx][count] = (pick + notpick)%MOD;\\n}\\n\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<vector<int>> dp(N, vector<int>(2,-1));\\n        //count has just 2 states => 0 and 1\\n        return helper(N-1, 0, nums, dp);\\n    }\\n};\\n```\\n\\n# SIMPLEST SOL - using GREEDY\\n![CapturedImage-25-06-2023 18-11-17.png](https://assets.leetcode.com/users/images/1feb271b-f9cf-4e04-9590-1203ed341491_1687697084.283015.png)\\n![CapturedImage-25-06-2023 18-13-46.png](https://assets.leetcode.com/users/images/28939fa1-2f6a-44b1-bd1d-823bfebcd5f1_1687697093.790521.png)\\n\\n## CODE\\n```\\nclass Solution {\\n\\npublic:\\n    int mod = 1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        long long ans = 0;\\n        int i=0;\\n        int j=0;\\n        \\n        while(j<N){\\n            while(j<N && nums[j] == 0){\\n                j++;\\n            }\\n            \\n            //we have atleast one 1 which makes the whole array with no splits\\n            if(j<N && nums[j]==1 && ans == 0) ans = 1;\\n            \\n            if(j<N && nums[i] == 1 && nums[j] == 1 && i!=j){\\n                ans = (ans * (j-i))%mod;\\n                //mul the count of zeros +1  in between 2 ones\\n                //count is j-i-1 => j-i-1+1 is done\\n            }\\n            i=j;\\n            j++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\nconst int MOD = 1e9 + 7;\\nint helper(int idx, int count, vector<int>& nums, vector<vector<int>>& dp){\\n\\n    if(idx < 0){\\n        if(count == 1)\\n            return 1;\\n        return 0;\\n    }\\n    if(nums[idx] == 1) count++;\\n    if(count > 1) //as we cannot keep more than one 1\\n        return 0;  \\n    \\n    if(dp[idx][count] != -1) return dp[idx][count];\\n    \\n    int pick = helper(idx-1, count, nums, dp);\\n    //count remains the same (pick = no split, add into same subarry)\\n    \\n    int notpick = 0;\\n    if(count == 1){\\n        notpick = helper(idx-1, 0, nums, dp);\\n        //we didn\\'t pick into same array, we break and create new subarry\\n        //so count is reset with 0\\n    }\\n    \\n    return dp[idx][count] = (pick + notpick)%MOD;\\n}\\n\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<vector<int>> dp(N, vector<int>(2,-1));\\n        //count has just 2 states => 0 and 1\\n        return helper(N-1, 0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\npublic:\\n    int mod = 1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        long long ans = 0;\\n        int i=0;\\n        int j=0;\\n        \\n        while(j<N){\\n            while(j<N && nums[j] == 0){\\n                j++;\\n            }\\n            \\n            //we have atleast one 1 which makes the whole array with no splits\\n            if(j<N && nums[j]==1 && ans == 0) ans = 1;\\n            \\n            if(j<N && nums[i] == 1 && nums[j] == 1 && i!=j){\\n                ans = (ans * (j-i))%mod;\\n                //mul the count of zeros +1  in between 2 ones\\n                //count is j-i-1 => j-i-1+1 is done\\n            }\\n            i=j;\\n            j++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679111,
                "title": "brute-force-pick-non-pick-dp-c",
                "content": "**<<<<<<<UpVote**\\n\\n\\n\\n**Approach** \\n\\n* you can only partition the array where the count 1\\'s is 1 else you have to move ahead*\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(vector<int>&nums,int count,int index,vector<vector<int>> &dp){\\n        if(nums.size()==index) \\n        {  if(count==1) return 1;\\n            \\n           return 0;\\n        }\\n        if(nums[index]==1) count++;\\n        if(count>1) return 0;                   //since we already have two or more 1\\'s so we can\\'t proceed further hence return 0\\n        if(dp[index][count]!=-1) return dp[index][count];\\n        dp[index][count]=0;\\n        if(count==1)                                                     // we have one 1\\'s so we can do partition\\n        {\\n            dp[index][count]=helper(nums,0,index+1,dp);\\n        }\\n        dp[index][count]= (dp[index][count]+helper(nums,count,index+1,dp)) % mod;\\n        return dp[index][count];\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<vector<int>> dp(nums.size(),vector<int>(2,-1));\\n        return helper(nums,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(vector<int>&nums,int count,int index,vector<vector<int>> &dp){\\n        if(nums.size()==index) \\n        {  if(count==1) return 1;\\n            \\n           return 0;\\n        }\\n        if(nums[index]==1) count++;\\n        if(count>1) return 0;                   //since we already have two or more 1\\'s so we can\\'t proceed further hence return 0\\n        if(dp[index][count]!=-1) return dp[index][count];\\n        dp[index][count]=0;\\n        if(count==1)                                                     // we have one 1\\'s so we can do partition\\n        {\\n            dp[index][count]=helper(nums,0,index+1,dp);\\n        }\\n        dp[index][count]= (dp[index][count]+helper(nums,count,index+1,dp)) % mod;\\n        return dp[index][count];\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<vector<int>> dp(nums.size(),vector<int>(2,-1));\\n        return helper(nums,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680669,
                "title": "simple-break-or-not-break",
                "content": "partition only possible when there is one 1\\'s is present in all partition .\\n\\n**APPROACH** \\nI come to at a index and seeing wherther I have 1 previously or not .\\nif I have 1 in prevoious subbarray then there will be two choice :\\n`choice 1:` if **curr** val is **0** then break it before 0 or after 0 .\\n`choice 2 :` if **curr** val is **1** then it is neccessary to break it here .\\n\\nif I dont have 1 in previous then simply go to next index and add the curr val in k.\\n\\n***NOTE : here k is count in subarray from last index where we break the array*** \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int  dp[100001][2];\\n     int MOD=1e9+7;\\n     long long getAns(vector<int > &nums, int i, int k) {\\n        if(i >= nums.size()) {\\n            return k == 1; //if one 1 is there \\n        }\\n        \\n        if(dp[i][k] != -1)return dp[i][k];\\n        \\n\\t\\t\\n        if(k == 1) {\\n            if(nums[i] ==0) { //then i have two choice eithe break it here or  not\\n\\t\\t\\t\\t\\n                return  dp[i][k]= (getAns(nums, i + 1, 0) % MOD + getAns(nums, i + 1, k) % MOD) % MOD;\\n            }\\n            else { //now i have to break it because one 1\\'s in subarray is already present \\n\\t\\t\\t\\n                return dp[i][k]=  getAns(nums, i + 1, 1) % MOD;\\n            }\\n        }\\n        else {\\n\\t\\t\\t\\n            return dp[i][k]=  getAns(nums, i + 1, k + nums[i]) % MOD;\\n        }\\n        \\n        \\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n       return getAns(nums,0,0);\\n    }\\n};\\n```\\n**NOTE:**  **similiar problem** \\n [https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/]()",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  dp[100001][2];\\n     int MOD=1e9+7;\\n     long long getAns(vector<int > &nums, int i, int k) {\\n        if(i >= nums.size()) {\\n            return k == 1; //if one 1 is there \\n        }\\n        \\n        if(dp[i][k] != -1)return dp[i][k];\\n        \\n\\t\\t\\n        if(k == 1) {\\n            if(nums[i] ==0) { //then i have two choice eithe break it here or  not\\n\\t\\t\\t\\t\\n                return  dp[i][k]= (getAns(nums, i + 1, 0) % MOD + getAns(nums, i + 1, k) % MOD) % MOD;\\n            }\\n            else { //now i have to break it because one 1\\'s in subarray is already present \\n\\t\\t\\t\\n                return dp[i][k]=  getAns(nums, i + 1, 1) % MOD;\\n            }\\n        }\\n        else {\\n\\t\\t\\t\\n            return dp[i][k]=  getAns(nums, i + 1, k + nums[i]) % MOD;\\n        }\\n        \\n        \\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n       return getAns(nums,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679451,
                "title": "on-paper-explanation-0s-between-1s",
                "content": "![image.png](https://assets.leetcode.com/users/images/569e71a7-fa7e-4af5-9115-d9d649a55c07_1687668711.301488.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        ans = 0\\n        a = \"\".join([str(i) for i in nums])\\n        a = a.strip(\"0\")\\n        if len(a)==0:\\n            return 0\\n        cnt = 0\\n        arr = []\\n        for i in a:\\n            if i == \"0\":\\n                cnt += 1\\n            else:\\n                if cnt != 0:\\n                    arr.append(cnt + 1)\\n                cnt = 0\\n        prod = 1\\n        for i in arr:\\n            prod *= i\\n        return prod % (10 ** 9 + 7)\\n\\n```\\n\\n```\\n#short code\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        a = \"\".join([str(i) for i in nums])\\n        a = a.strip(\"0\")\\n        if len(a)==0: return 0\\n        cnt,prod=0,1\\n        for i in a:\\n            if i == \"0\":\\n                cnt += 1\\n            elif cnt != 0:\\n                prod*=cnt+1\\n                cnt = 0\\n        return prod % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        ans = 0\\n        a = \"\".join([str(i) for i in nums])\\n        a = a.strip(\"0\")\\n        if len(a)==0:\\n            return 0\\n        cnt = 0\\n        arr = []\\n        for i in a:\\n            if i == \"0\":\\n                cnt += 1\\n            else:\\n                if cnt != 0:\\n                    arr.append(cnt + 1)\\n                cnt = 0\\n        prod = 1\\n        for i in arr:\\n            prod *= i\\n        return prod % (10 ** 9 + 7)\\n\\n```\n```\\n#short code\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        a = \"\".join([str(i) for i in nums])\\n        a = a.strip(\"0\")\\n        if len(a)==0: return 0\\n        cnt,prod=0,1\\n        for i in a:\\n            if i == \"0\":\\n                cnt += 1\\n            elif cnt != 0:\\n                prod*=cnt+1\\n                cnt = 0\\n        return prod % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679137,
                "title": "cpp-o-n",
                "content": "int mod = (int)1e9 + 7;\\nclass Solution {\\npublic:\\n    // [0,1,0,0,1,0,1]\\n    // [0,1] [0,0,1]\\n// - [0,1,0] [0,1]\\n// - [0,1,0,0] [1]\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& v) {\\n        int ones = count(v.begin(),v.end(),1);\\n        int n = v.size();\\n        int cnt = 0, cnt1 = 0;\\n        int ans = 1;\\n        for(int i = 0; i < n; i += 1) {\\n            if(v[i] == 1) {\\n                if(cnt1 > 0) ans = (ans * (cnt + 1LL) % mod);\\n                cnt1 += 1;\\n                cnt = 0;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n        }\\n        if(ones > 0) return ans;\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    // [0,1,0,0,1,0,1]\\n    // [0,1] [0,0,1]\\n// - [0,1,0] [0,1]\\n// - [0,1,0,0] [1]\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& v) {\\n        int ones = count(v.begin(),v.end(),1);\\n        int n = v.size();\\n        int cnt = 0, cnt1 = 0;\\n        int ans = 1;\\n        for(int i = 0; i < n; i += 1) {\\n            if(v[i] == 1) {\\n                if(cnt1 > 0) ans = (ans * (cnt + 1LL) % mod);\\n                cnt1 += 1;\\n                cnt = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3679103,
                "title": "store-the-positions-of-1-s",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    // our answer depends on the number of Zeroes present between two adjacent Ones.\\n    \\n    int mod = 1e9+7;\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> p(n, 0);      //array to store positions of 1\\n        int ind = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1){     // store the position of 1\\n                p[ind] = i;\\n                ind++;\\n            }\\n        }\\n        \\n        if(ind==0)    return 0;     //edge case when there is no 1 present in nums\\n        \\n        long long cntWays = 1;   //otherwise one way always exist\\n        \\n        for(int i=0;i<ind-1;i++){\\n            cntWays = (cntWays * (p[i+1] - p[i]))%mod;    // multiply the ways with the number of zeroes between adjacent 1\\'s,\\n        }\\n        return cntWays;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    // our answer depends on the number of Zeroes present between two adjacent Ones.\\n    \\n    int mod = 1e9+7;\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> p(n, 0);      //array to store positions of 1\\n        int ind = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1){     // store the position of 1\\n                p[ind] = i;\\n                ind++;\\n            }\\n        }\\n        \\n        if(ind==0)    return 0;     //edge case when there is no 1 present in nums\\n        \\n        long long cntWays = 1;   //otherwise one way always exist\\n        \\n        for(int i=0;i<ind-1;i++){\\n            cntWays = (cntWays * (p[i+1] - p[i]))%mod;    // multiply the ways with the number of zeroes between adjacent 1\\'s,\\n        }\\n        return cntWays;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679640,
                "title": "easy-to-understand-well-explained-multiply-zero-counts-between-1-s",
                "content": "**Approach:**\\n\\n* Traverse the input vector and store the indices of elements equal to 1 in a new vector called \"ans\".\\n* Initialize \"res\" with a value of 1.\\nIf \"ans\" is empty (i.e., \"ans.size() == 0\"), return 0 as there are no ones present and no good subarrays can be formed.\\n* Iterate through the \"ans\" vector and calculate the product of the differences between consecutive elements, which represent the indices of the original array. Multiply this product by the current value of \"res\".\\n* To prevent overflow, take the modulo by (1000000007) after each multiplication operation.\\n* Finally, return the value of \"res\".\\n\\n\\n**Code:**\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tconst int mod=1000000007;\\n\\t\\tint numberOfGoodSubarraySplits(vector<int>& nums) {\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==1) ans.push_back(i);\\n\\t\\t\\t}\\n\\t\\t\\tif(ans.size()==0) return 0;\\n\\n\\t\\t\\tlong long res=1;\\n\\t\\t\\tfor(int i=1;i<ans.size();i++){\\n\\t\\t\\t\\tres*=(ans[i]-ans[i-1]);\\n\\t\\t\\t\\tres%=mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tconst int mod=1000000007;\\n\\t\\tint numberOfGoodSubarraySplits(vector<int>& nums) {\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==1) ans.push_back(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3682841,
                "title": "python-3-3-lines-string-manipulation-t-m-80-80",
                "content": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n       \\n        if 1 not in nums: return 0\\n\\n        nums = \\'\\'.join(map(str,nums)).strip(\\'0\\').split(\"1\")\\n\\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007\\n```\\n[https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/submissions/979589101/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n       \\n        if 1 not in nums: return 0\\n\\n        nums = \\'\\'.join(map(str,nums)).strip(\\'0\\').split(\"1\")\\n\\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679360,
                "title": "simple-dp-solution-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- One thing to note about this problem is that in each subarray, **we can have only a single `1`**. \\n- Now since we have to count the number of ways of splitting the subarray, once we make a choice for the first leftmost subarray *our problem essentially gets reduced into a subproblem*.\\n- If we choose the first `i` elements in the first subarray, we need to solve the original problem for the array suffix $$nums[i : n]$$.\\n- Hence, we can think about the problem in terms of dynamic-programming.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Our dp-state will be $$(index, hasOne)$$. \\n- `hasOne` denotes whether we have chosen a `1` in our current subarray or not.\\n- When current value is `0`:\\n    - We can always continue with the current subarray as it is.\\n    - If the current subarray `hasOne`, then we can discontinue and start a new subarray.\\n\\n- When current index value is `1`:\\n    - If the current subarray `hasOne`, we have to start a new subarray.\\n    - If the current subarray does not have one, we continue with the current subarray.\\n- In our final state, we make sure that we have a `1` in the last subarray. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - For each position we pretty much have only 2 choices.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:        \\n        if nums.count(1) == 0:\\n            return 0\\n\\n        n = len(nums)\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dp(i = 0, hasOne = False):\\n            if i == n:\\n                return int(hasOne)\\n            \\n            ans = 0\\n            if nums[i] == 0:\\n                ans += dp(i + 1, hasOne) # Continue Subarray As It is\\n                if hasOne:\\n                    ans += dp(i + 1, False) # Discontinue Subarray\\n            else:\\n                # Continue or Discontinue Subarray\\n                ans = dp(i + 1, True) \\n\\n            return ans % MOD\\n\\n        return dp()\\n```\\n\\n**Have a nice day and do upvote if you like the approach (Vote even if you don\\'t like it :) !**",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:        \\n        if nums.count(1) == 0:\\n            return 0\\n\\n        n = len(nums)\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dp(i = 0, hasOne = False):\\n            if i == n:\\n                return int(hasOne)\\n            \\n            ans = 0\\n            if nums[i] == 0:\\n                ans += dp(i + 1, hasOne) # Continue Subarray As It is\\n                if hasOne:\\n                    ans += dp(i + 1, False) # Discontinue Subarray\\n            else:\\n                # Continue or Discontinue Subarray\\n                ans = dp(i + 1, True) \\n\\n            return ans % MOD\\n\\n        return dp()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679238,
                "title": "product-of-count-of-0-s-between-1-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int count=0;\\n        long ans=1;\\n        int check_1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                if(check_1==1)\\n                    count++;\\n            }\\n            else{\\n                if(check_1==0){\\n                   check_1=1;\\n                    count++;\\n                }\\n                else{\\n                    ans=(ans*count)%1000000007;\\n                    // Again start counting no. of 0\\'s making count=1\\n                    count=1;\\n                }\\n            }\\n        }\\n        if(count==0) return 0;\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int count=0;\\n        long ans=1;\\n        int check_1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                if(check_1==1)\\n                    count++;\\n            }\\n            else{\\n                if(check_1==0){\\n                   check_1=1;\\n                    count++;\\n                }\\n                else{\\n                    ans=(ans*count)%1000000007;\\n                    // Again start counting no. of 0\\'s making count=1\\n                    count=1;\\n                }\\n            }\\n        }\\n        if(count==0) return 0;\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688521,
                "title": "easy-explanation-multiply-all-0-counts-between-1s-beats-99-time-space-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Solution is to think what can be the first subarray value. Now as every subarray must contain exactly one 1, the first value can be any subarray that starts from index 0 and ends somewhere between 1st and 2nd occurance of 1.\\n\\nNow for all these first subarray values, we check for the 2nd subarray value and so on, which eventually boils down the number to be equal to the multiplication of 0 counts between 1s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Elimitate the Zeroes in the start. \\n2. Then interate and check the zeroes between every two ones. Multiply the (count+1) to the answer since we can get count+1 divisions between two ones as shown below.\\n\\n![Explanation.jpg](https://assets.leetcode.com/users/images/40d17005-3114-4d8c-87de-dded2a292070_1687860121.8617623.jpeg)\\n\\n3. Iterate till the end of the array, if you reach the end of the array don\\'t multiply count to answer since those zeroes are not between any consecutive one.  \\n\\n# Complexity\\n- Time complexity: O(N) where N is the size of nums array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int start = 0;\\n        \\n        while(start!=nums.size() && nums[start]!=1){\\n            start++;\\n        }\\n        if(start==nums.size()){\\n            return 0;\\n        }\\n        \\n        long long int ans = 1;\\n        int walker = start;\\n        int mod = 1000000007;\\n        \\n        while(walker<nums.size()){\\n            int count = 1;\\n            walker++;\\n            while(walker!=nums.size() && nums[walker]!=1){\\n                count++;\\n                walker++;\\n            }\\n            \\n            if(walker!=nums.size()){\\n                ans = ((ans%mod)*(count%mod))%mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int start = 0;\\n        \\n        while(start!=nums.size() && nums[start]!=1){\\n            start++;\\n        }\\n        if(start==nums.size()){\\n            return 0;\\n        }\\n        \\n        long long int ans = 1;\\n        int walker = start;\\n        int mod = 1000000007;\\n        \\n        while(walker<nums.size()){\\n            int count = 1;\\n            walker++;\\n            while(walker!=nums.size() && nums[walker]!=1){\\n                count++;\\n                walker++;\\n            }\\n            \\n            if(walker!=nums.size()){\\n                ans = ((ans%mod)*(count%mod))%mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679456,
                "title": "easy-to-understand-brute-force-solution-cpp",
                "content": "# Intuition\\nSave the position of the previously encountered `1` and calculate the product of the differences between the current position of `1` and the previously saved position. This difference represents the number of partitions that can be done between two ones at those indices of array.\\n\\n# Approach\\n- Track the index of `1` and store in vector `one`, then multiply the difference of consecutive `1`\\'s indices which is stored in `one` array using modular multiplication, hence it is the required answer.\\n- Take care of edge case: If no `1` is there then, return 0.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> one; // Stores the indices of ones of the nums array\\n        int mod = 1e9 + 7;\\n\\n        // Find the indices of ones in the input array\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i])\\n                one.push_back(i);\\n        }\\n\\n        if (one.size() == 0) // base case if no ones found return 0\\n            return 0;\\n\\n        long long out = 1; \\n\\n        // Calculate the number of good subarray splits\\n        for (int i = 1; i < one.size(); ++i) {\\n            out = (out * (one[i] - one[i - 1])) % mod;\\n        }\\n\\n        return out;\\n    }\\n};\\n```\\n\\n#### If you find this solution helpful, please consider upvoting it \\uD83D\\uDC4D.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> one; // Stores the indices of ones of the nums array\\n        int mod = 1e9 + 7;\\n\\n        // Find the indices of ones in the input array\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i])\\n                one.push_back(i);\\n        }\\n\\n        if (one.size() == 0) // base case if no ones found return 0\\n            return 0;\\n\\n        long long out = 1; \\n\\n        // Calculate the number of good subarray splits\\n        for (int i = 1; i < one.size(); ++i) {\\n            out = (out * (one[i] - one[i - 1])) % mod;\\n        }\\n\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679231,
                "title": "fully-explained-c-commented-code-dp-knapsack-0-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> a;\\n    int mod = 1e9+7;\\n    int dp[100100][2];\\n    \\n    // Recursive helper function\\n    int rec(int idx, int f) {\\n        if (idx == n) {\\n            return f == 1; // Base case: if the end of the array is reached, and we are checking whether the last subarray has 1 or not.\\n        }\\n        if (dp[idx][f] != -1) {\\n            return dp[idx][f]; // If the value is already computed, return it from dp array\\n        }\\n        \\n        int ans = 0;\\n        if (f == 0) { // If we have not find one in our subarray\\n            if (a[idx] == 1) {\\n                ans = rec(idx + 1, 1); // If current element is 1,we have find 1 for our subarray and continue with f = 1\\n            } else {\\n                ans = rec(idx + 1, 0); // If current element is 0, keep seaching for 1\\n            }\\n        } else { // If we have already find 1 for our subarray then we have two possibilities\\n            if (a[idx] == 0) {\\n                ans = (rec(idx + 1, 1) + rec(idx + 1, 0)) % mod; // If current element is 0, we can either take it or not\\n            } else {\\n                ans = rec(idx + 1, 1); // If current element is 1, we have to start new subarray because we cannot put 2 one\\'s in same subarray\\n            }\\n        }\\n        \\n        return dp[idx][f] = ans; // Store the computed value in dp array and return it\\n    }\\n    \\n    // Entry point function\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        a = nums;\\n        n = nums.size();\\n        memset(dp, -1, sizeof(dp)); // Initialize dp array with -1 values\\n        return rec(0, 0); // Start the recursion with initial values\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> a;\\n    int mod = 1e9+7;\\n    int dp[100100][2];\\n    \\n    // Recursive helper function\\n    int rec(int idx, int f) {\\n        if (idx == n) {\\n            return f == 1; // Base case: if the end of the array is reached, and we are checking whether the last subarray has 1 or not.\\n        }\\n        if (dp[idx][f] != -1) {\\n            return dp[idx][f]; // If the value is already computed, return it from dp array\\n        }\\n        \\n        int ans = 0;\\n        if (f == 0) { // If we have not find one in our subarray\\n            if (a[idx] == 1) {\\n                ans = rec(idx + 1, 1); // If current element is 1,we have find 1 for our subarray and continue with f = 1\\n            } else {\\n                ans = rec(idx + 1, 0); // If current element is 0, keep seaching for 1\\n            }\\n        } else { // If we have already find 1 for our subarray then we have two possibilities\\n            if (a[idx] == 0) {\\n                ans = (rec(idx + 1, 1) + rec(idx + 1, 0)) % mod; // If current element is 0, we can either take it or not\\n            } else {\\n                ans = rec(idx + 1, 1); // If current element is 1, we have to start new subarray because we cannot put 2 one\\'s in same subarray\\n            }\\n        }\\n        \\n        return dp[idx][f] = ans; // Store the computed value in dp array and return it\\n    }\\n    \\n    // Entry point function\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        a = nums;\\n        n = nums.size();\\n        memset(dp, -1, sizeof(dp)); // Initialize dp array with -1 values\\n        return rec(0, 0); // Start the recursion with initial values\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679194,
                "title": "most-simple-c-count-intermediate-0-s",
                "content": "# if this code helps you, please upvote that\\'s helps to me.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int> v;\\n        int i = 0, j = 0, n = nums.size();\\n        while(i<n&&nums[i]==0){\\n            i++;\\n        }\\n        if(i==n)return 0;\\n        while(n--&&nums[n]==0){\\n        }\\n        while(i<n){\\n            if(nums[i]==1){\\n                i++;\\n            }else{\\n                j = 0;\\n                while(i<n&&nums[i]==0){\\n                    j++;\\n                    i++;\\n                }\\n                v.push_back(j+1);\\n            }\\n        }\\n        v.push_back(1);\\n        if(v.size()<=1)return 1;\\n        int ans = 1;\\n        int mod = 1e9+7;\\n        for(auto &i: v){\\n            ans = (ans*1LL*i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int> v;\\n        int i = 0, j = 0, n = nums.size();\\n        while(i<n&&nums[i]==0){\\n            i++;\\n        }\\n        if(i==n)return 0;\\n        while(n--&&nums[n]==0){\\n        }\\n        while(i<n){\\n            if(nums[i]==1){\\n                i++;\\n            }else{\\n                j = 0;\\n                while(i<n&&nums[i]==0){\\n                    j++;\\n                    i++;\\n                }\\n                v.push_back(j+1);\\n            }\\n        }\\n        v.push_back(1);\\n        if(v.size()<=1)return 1;\\n        int ans = 1;\\n        int mod = 1e9+7;\\n        for(auto &i: v){\\n            ans = (ans*1LL*i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679154,
                "title": "two-approaches-1-straightforward-top-down-dp-2-multiply-difference-of-inds",
                "content": "## 1. Top-Down DP\\n```cpp\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        using ll = long long;\\n        ll memo[n][2];\\n        memset(memo, -1, sizeof memo);\\n        ll MOD = 1e9 + 7;\\n        \\n        function<ll(int,bool)> solve = [&](int i, bool has_one) -> ll {\\n            if(i == n) return has_one;\\n            if(memo[i][has_one] != -1) return memo[i][has_one];\\n            \\n            ll result = 0;\\n            \\n            if(has_one) {\\n                if(nums[i] == 1) {\\n                    result += solve(i+1, true);\\n                }\\n                else {\\n                    result += solve(i+1, true) + solve(i+1, false);\\n                }\\n                \\n                result %= MOD;\\n            }\\n            else {\\n                if(nums[i] == 1) {\\n                    result += solve(i+1, true);\\n                }\\n                else {\\n                    result += solve(i+1, false);\\n                }\\n                \\n                result %= MOD;\\n            }\\n            \\n            return memo[i][has_one] = result;\\n        };\\n        \\n        return solve(0, false);\\n    }\\n};\\n```\\n------------------\\n## 2. Multiply the differences between indices of 1\\n```cpp\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        using ll = long long;\\n        ll result = 0, MOD = 1e9 + 7;\\n\\n        for(int i=0, l=-1; i<nums.size(); i++) {\\n            if(nums[i]) {\\n                if(l == -1) l = i, result = 1;\\n                else {\\n                    result *= i-l;\\n                    result %= MOD;\\n                    l = i;\\n                }\\n            }\\n        } \\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        using ll = long long;\\n        ll memo[n][2];\\n        memset(memo, -1, sizeof memo);\\n        ll MOD = 1e9 + 7;\\n        \\n        function<ll(int,bool)> solve = [&](int i, bool has_one) -> ll {\\n            if(i == n) return has_one;\\n            if(memo[i][has_one] != -1) return memo[i][has_one];\\n            \\n            ll result = 0;\\n            \\n            if(has_one) {\\n                if(nums[i] == 1) {\\n                    result += solve(i+1, true);\\n                }\\n                else {\\n                    result += solve(i+1, true) + solve(i+1, false);\\n                }\\n                \\n                result %= MOD;\\n            }\\n            else {\\n                if(nums[i] == 1) {\\n                    result += solve(i+1, true);\\n                }\\n                else {\\n                    result += solve(i+1, false);\\n                }\\n                \\n                result %= MOD;\\n            }\\n            \\n            return memo[i][has_one] = result;\\n        };\\n        \\n        return solve(0, false);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        using ll = long long;\\n        ll result = 0, MOD = 1e9 + 7;\\n\\n        for(int i=0, l=-1; i<nums.size(); i++) {\\n            if(nums[i]) {\\n                if(l == -1) l = i, result = 1;\\n                else {\\n                    result *= i-l;\\n                    result %= MOD;\\n                    l = i;\\n                }\\n            }\\n        } \\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679116,
                "title": "simplest-c-solution-without-dp",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        long long cnt=0, cnt1=0;\\n        long long ways=1;\\n        \\n        int cnt0=0;\\n        for(auto i: nums) if(i==0) cnt0++;\\n        if(cnt0==n) return 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) cnt1++;\\n            if(cnt1==1) cnt++;\\n            \\n            if(cnt1>1){\\n                ways=(ways%mod*cnt)%mod;\\n                cnt=1;\\n                cnt1=1;\\n            }\\n            \\n        }\\n        return (ways)%mod;  \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        long long cnt=0, cnt1=0;\\n        long long ways=1;\\n        \\n        int cnt0=0;\\n        for(auto i: nums) if(i==0) cnt0++;\\n        if(cnt0==n) return 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) cnt1++;\\n            if(cnt1==1) cnt++;\\n            \\n            if(cnt1>1){\\n                ways=(ways%mod*cnt)%mod;\\n                cnt=1;\\n                cnt1=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3679107,
                "title": "c-o-n-time-o-1-space",
                "content": "\\n\\n# Code\\n```\\nint mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        int n=nums.size(),prev=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]){\\n                if(prev!=-1){\\n                    ans = (ans * (i-prev))%mod;\\n                }\\n                prev=i;\\n            }\\n        }\\n        if(prev == -1){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        int n=nums.size(),prev=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]){\\n                if(prev!=-1){\\n                    ans = (ans * (i-prev))%mod;\\n                }\\n                prev=i;\\n            }\\n        }\\n        if(prev == -1){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679093,
                "title": "java-count-zero-between-one-with-slide-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount zero between one from both side.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor `...10001...` case, there are 3 zero, and we can split to 4 different subarrays.\\n```\\n...1|0001...\\n...10|001...\\n...100|01...\\n...1000|1...\\n```\\n\\nIf we have $m$ ways to split the previous array, then we have another $n - 1$ zero between one, **there will be $m * n$ ways to build total different splits**.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private static final int modulo = (int) 1e9 + 7;\\n\\n  public int numberOfGoodSubarraySplits(int[] nums) {\\n    final int n = nums.length;\\n    long count = 0;\\n\\n    // find the first one\\n    int i = 0;\\n    while (i < n && nums[i] != 1) {\\n      i++;\\n    }\\n\\n    if (i < n) {\\n      count++;\\n    }\\n\\n    for (int j = i + 1; j < n; j++) {\\n      while (j < n && nums[j] == 0) {\\n        j++;\\n      }\\n\\n      if (j < n && nums[j] == 1) {\\n        // we have j - i cuts with zero between two one(i, j)\\n        // 10...01\\n        // i ... j\\n        count = count * (j - i) % modulo;\\n        i = j;\\n      }\\n    }\\n\\n    return (int) count;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sliding Window",
                    "Combinatorics"
                ],
                "code": "```\\n...1|0001...\\n...10|001...\\n...100|01...\\n...1000|1...\\n```\n```\\nclass Solution {\\n  private static final int modulo = (int) 1e9 + 7;\\n\\n  public int numberOfGoodSubarraySplits(int[] nums) {\\n    final int n = nums.length;\\n    long count = 0;\\n\\n    // find the first one\\n    int i = 0;\\n    while (i < n && nums[i] != 1) {\\n      i++;\\n    }\\n\\n    if (i < n) {\\n      count++;\\n    }\\n\\n    for (int j = i + 1; j < n; j++) {\\n      while (j < n && nums[j] == 0) {\\n        j++;\\n      }\\n\\n      if (j < n && nums[j] == 1) {\\n        // we have j - i cuts with zero between two one(i, j)\\n        // 10...01\\n        // i ... j\\n        count = count * (j - i) % modulo;\\n        i = j;\\n      }\\n    }\\n\\n    return (int) count;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690469,
                "title": "c-very-easy-o-n-approach",
                "content": "\\n# Approach\\nIterating over the vector once and storing the product the number of zeros that are present in between the one\\'s.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& v) {\\n        int n=v.size();\\n        long long prod=1;\\n        bool flag=false;\\n        int cnt=0;\\n        for(auto i:v){\\n            if(i==1 && !flag){\\n                flag=true;\\n                cnt=0;\\n            }\\n            else if(i==0){\\n                cnt++;\\n            }\\n            else if(i==1){\\n                prod=(prod*(cnt+1))%1000000007;\\n                cnt=0;\\n            }\\n        }\\n        if(!flag)\\n            return 0;\\n        return (int)prod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& v) {\\n        int n=v.size();\\n        long long prod=1;\\n        bool flag=false;\\n        int cnt=0;\\n        for(auto i:v){\\n            if(i==1 && !flag){\\n                flag=true;\\n                cnt=0;\\n            }\\n            else if(i==0){\\n                cnt++;\\n            }\\n            else if(i==1){\\n                prod=(prod*(cnt+1))%1000000007;\\n                cnt=0;\\n            }\\n        }\\n        if(!flag)\\n            return 0;\\n        return (int)prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686196,
                "title": "python-solution-simple-and-easy-solution-runtime-2232-ms-and-memory-20-1-mb",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nStep 1 : First find the index of the first occurrence of the number 1\\nStep 2 : then we find the number of zeros between 2 1s\\nStep 3 : then multiply it each time with the final result\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n\\n        if 1 not in nums :\\n            return 0\\n        ind = nums.index(1)  # first occurence of 1\\n\\n        cnt = 1 \\n        for i in range(ind + 1 , len(nums)) :\\n            if nums[i] == 1 :\\n                # i-ind gives the no of zeros between 2 1s                \\n                cnt = (cnt * (i-ind))%1000000007\\n                ind = i \\n        return cnt\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nStep 1 : First find the index of the first occurrence of the number 1\\nStep 2 : then we find the number of zeros between 2 1s\\nStep 3 : then multiply it each time with the final result\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n\\n        if 1 not in nums :\\n            return 0\\n        ind = nums.index(1)  # first occurence of 1\\n\\n        cnt = 1 \\n        for i in range(ind + 1 , len(nums)) :\\n            if nums[i] == 1 :\\n                # i-ind gives the no of zeros between 2 1s                \\n                cnt = (cnt * (i-ind))%1000000007\\n                ind = i \\n        return cnt\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3682594,
                "title": "c-simple-math-approach-in-linear-time-and-constant-space",
                "content": "# Approach\\n- To count the number of ways to split the array, we need to consider the intervals between consecutive 1s.\\n- For each interval between two consecutive 1s, we split it into multiple subarrays, where each subarray contains only one element with the value 1 and any number of elements with the value 0.\\n- The number of ways to split this interval between two consecutive 1s is equal to the difference between their indices. Consider the following example\\n\\n```\\narr = [0,1,0,0,1]. \\nThe given array can be split into the following subarrys: \\n(i) [0,1][0,0,1] (ii) [0,1,0][0,1] (iii) [0,1,0,0][1]\\nThere are 3 ways which is equal to the difference between the indices of 1s\\n```\\n\\n- So, We calculate the number of ways to split each interval and multiply them together to get the total number of ways to split the array into good subarrays\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        int prevInd = -1;\\n        long long int count=1;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i])\\n            {\\n                if(prevInd != -1)\\n                    count = (count*(i-prevInd) % 1000000007);\\n\\n                prevInd = i;\\n            }\\n        }\\n\\n        if(prevInd == -1) // There are no 1s\\n            return 0;\\n        return (int) count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\narr = [0,1,0,0,1]. \\nThe given array can be split into the following subarrys: \\n(i) [0,1][0,0,1] (ii) [0,1,0][0,1] (iii) [0,1,0,0][1]\\nThere are 3 ways which is equal to the difference between the indices of 1s\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        int prevInd = -1;\\n        long long int count=1;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i])\\n            {\\n                if(prevInd != -1)\\n                    count = (count*(i-prevInd) % 1000000007);\\n\\n                prevInd = i;\\n            }\\n        }\\n\\n        if(prevInd == -1) // There are no 1s\\n            return 0;\\n        return (int) count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681129,
                "title": "java-solution-using-dynamic-programming",
                "content": "# Intuition\\nPartition only possible when there is one 1\\'s is present in all partition.\\n\\n# Approach\\nI come to at a index and seeing wherther I have 1 previously or not .\\nif I have 1 in prevoious subbarray then there will be two choice :\\n\\nChoice 1: if curr val is 0 then break it before 0 or after 0 .\\n\\nChoice 2 : if curr val is 1 then it is neccessary to break it here .\\n\\nif I dont have 1 in previous then simply go to next index and add the curr val in k.\\n\\n# Code\\n```\\nclass Solution {\\n    int M = 1000000007;\\n    public int finder(int[] nums,int ind,int k,int[][] dp){\\n        if(ind == nums.length){\\n            return k;\\n        }\\n\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n        \\n        if(k == 1){\\n            if(nums[ind] == 1){\\n              return dp[ind][k] = finder(nums,ind+1,1,dp)%M;\\n            }\\n            else\\n             return dp[ind][k] = (finder(nums,ind+1,0,dp) + finder(nums,ind+1,1,dp))%M;       \\n        }\\n        else{        \\n             return dp[ind][k] = finder(nums,ind+1,k+nums[ind],dp)%M;\\n        }\\n    }\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int dp[][] = new int[nums.length][2];\\n        for(int[] row: dp)\\n            Arrays.fill(row,-1);\\n        return finder(nums,0,0,dp);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int M = 1000000007;\\n    public int finder(int[] nums,int ind,int k,int[][] dp){\\n        if(ind == nums.length){\\n            return k;\\n        }\\n\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n        \\n        if(k == 1){\\n            if(nums[ind] == 1){\\n              return dp[ind][k] = finder(nums,ind+1,1,dp)%M;\\n            }\\n            else\\n             return dp[ind][k] = (finder(nums,ind+1,0,dp) + finder(nums,ind+1,1,dp))%M;       \\n        }\\n        else{        \\n             return dp[ind][k] = finder(nums,ind+1,k+nums[ind],dp)%M;\\n        }\\n    }\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int dp[][] = new int[nums.length][2];\\n        for(int[] row: dp)\\n            Arrays.fill(row,-1);\\n        return finder(nums,0,0,dp);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679273,
                "title": "java-multiply-spaces-clean-code",
                "content": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        List<Integer> indexes = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 1) indexes.add(i);\\n        }\\n        if(indexes.size() == 0) return 0;\\n        long ways = 1l;\\n        for(int i = 0; i < indexes.size() - 1; i++) {\\n            int space = indexes.get(i+1) - indexes.get(i);\\n            ways = (ways * space) % MOD;\\n        }\\n        return (int)ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        List<Integer> indexes = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 1) indexes.add(i);\\n        }\\n        if(indexes.size() == 0) return 0;\\n        long ways = 1l;\\n        for(int i = 0; i < indexes.size() - 1; i++) {\\n            int space = indexes.get(i+1) - indexes.get(i);\\n            ways = (ways * space) % MOD;\\n        }\\n        return (int)ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679222,
                "title": "c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind all `1` and split them\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind the position of each `1`\\nsplit `0` for each two `1`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // time/space: O(n)/O(n)\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // find all `1`\\'s positions\\n        vector<int> pos;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos.push_back(i);\\n        }\\n        \\n        // edge case: no `1`\\n        int k = pos.size();\\n        if (k == 0) return 0;\\n        \\n        // split between each two `1`\\n        long long result = 1;\\n        for (int i = 0; i < (k - 1); i++) {\\n            result = (result * (long long)(pos[i + 1] - pos[i])) % MOD;\\n        }\\n        return result;\\n    }\\nprivate:\\n    const long long MOD = 1e9 + 7;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // time/space: O(n)/O(n)\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // find all `1`\\'s positions\\n        vector<int> pos;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos.push_back(i);\\n        }\\n        \\n        // edge case: no `1`\\n        int k = pos.size();\\n        if (k == 0) return 0;\\n        \\n        // split between each two `1`\\n        long long result = 1;\\n        for (int i = 0; i < (k - 1); i++) {\\n            result = (result * (long long)(pos[i + 1] - pos[i])) % MOD;\\n        }\\n        return result;\\n    }\\nprivate:\\n    const long long MOD = 1e9 + 7;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841166,
                "title": "o-n-time-o-1-space-explain-like-i-am-5-solution",
                "content": "\\n\\n# Approach\\n![Screenshot 2023-07-30 225845.png](https://assets.leetcode.com/users/images/18a2381c-f8db-44c1-8fd5-9f61311ab45c_1690779539.2431946.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/575b7808-eafc-4a77-b2c3-659a473032cf_1690779557.2961736.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/016aad6c-a04f-4ff5-a6f8-eeaf7637367d_1690779566.9093945.png)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        try:\\n            firstOne = nums.index(1)\\n        except Exception:\\n            return 0\\n\\n        ans = 1\\n        subArrayCount = 1\\n        for i in range(firstOne, len(nums)):\\n            if nums[i] == 0:\\n                subArrayCount += 1\\n            else:\\n                ans *= subArrayCount\\n                ans %= (10 ** 9 + 7)\\n                subArrayCount = 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        try:\\n            firstOne = nums.index(1)\\n        except Exception:\\n            return 0\\n\\n        ans = 1\\n        subArrayCount = 1\\n        for i in range(firstOne, len(nums)):\\n            if nums[i] == 0:\\n                subArrayCount += 1\\n            else:\\n                ans *= subArrayCount\\n                ans %= (10 ** 9 + 7)\\n                subArrayCount = 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787283,
                "title": "c-easy-solution-beats-81",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long result = 1;\\n        int count = 0;\\n        int modulo = 1000000007;\\n        int i=0;\\n        while(i<nums.size()&&nums[i]==0)i++;//To get the first good subarray\\n        if(i>=nums.size())return 0;\\n        while(i<nums.size()) {\\n        if (nums[i] == 1) {\\n             result = (result * (count + 1)) % modulo;\\n            count = 0;\\n        } \\n        else {\\n            count++;\\n        }\\n        i++;\\n    }\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long result = 1;\\n        int count = 0;\\n        int modulo = 1000000007;\\n        int i=0;\\n        while(i<nums.size()&&nums[i]==0)i++;//To get the first good subarray\\n        if(i>=nums.size())return 0;\\n        while(i<nums.size()) {\\n        if (nums[i] == 1) {\\n             result = (result * (count + 1)) % modulo;\\n            count = 0;\\n        } \\n        else {\\n            count++;\\n        }\\n        i++;\\n    }\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735533,
                "title": "java-detailed-explanation-product-of-no-of-zeroes-between-ones-s-strategy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mod = (int)1e9 +7 ;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n = nums.length;\\n        int flag = 0,count=0;\\n        long ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            <!-- this is the 1st 1 in array, so setting flag to 1  -->\\n            if(nums[i]==1 && flag ==0)\\n            {\\n                flag = 1;\\n            }\\n            else if(flag==1 &&  nums[i]==0)\\n            {\\n                count++;\\n            }\\n            <!-- if we have other 1s in array, which is not the 1st one  -->\\n            else if(nums[i]==1 && flag ==1)\\n            {\\n                ans = (ans*(count+1)) %mod;\\n                count = 0;\\n            }\\n        }\\n        if(flag==0) return 0;\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mod = (int)1e9 +7 ;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n = nums.length;\\n        int flag = 0,count=0;\\n        long ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            <!-- this is the 1st 1 in array, so setting flag to 1  -->\\n            if(nums[i]==1 && flag ==0)\\n            {\\n                flag = 1;\\n            }\\n            else if(flag==1 &&  nums[i]==0)\\n            {\\n                count++;\\n            }\\n            <!-- if we have other 1s in array, which is not the 1st one  -->\\n            else if(nums[i]==1 && flag ==1)\\n            {\\n                ans = (ans*(count+1)) %mod;\\n                count = 0;\\n            }\\n        }\\n        if(flag==0) return 0;\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732425,
                "title": "easy-beginner-friendly-approach-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFocus on number of zeros that occured in between two one\\'s.\\nIt is kind of permutations that we have to measure by assigning the zeros to its one who is prefix to them and else zero assign with one who suffix to them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount the number of zeros in between all ones and the product of these count will be the number of subarrays can be formed which satisfies the costraint that subarray contains only one.\\nAnd add some base cases like no zeros present or no ones present.\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)  \\nBecause of aeasy set that we are using for the base case.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int n =nums.size();\\n        int mod = 1e9+7;\\n        int start = 0 ;\\n        int last = n-1;\\n        set<int>s;\\n        \\n        for(auto it : nums) s.insert(it);\\n        \\n        if(s.size()==1 && s.count(1)==0) return 0;\\n        if(s.size()==1 && s.count(1)!=0) return 1;\\n        \\n        while(nums[start]==0 && start <n){\\n            start++;\\n        }\\n        while(nums[last]==0 && last>=0){\\n            last--;\\n        }\\n        \\n        // cout<<start<<\" \"<<last;\\n        long long prod=1;\\n        int count=0;\\n        start++;\\n        while(start<=last){\\n            if(nums[start]==0){\\n                count++;\\n                // cout<<count;\\n            }else{\\n                \\n                prod= (prod*(count+1))%mod;\\n                count=0;\\n                // prod%=mod;\\n            }\\n            start++;\\n        }\\n            \\n       return prod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int n =nums.size();\\n        int mod = 1e9+7;\\n        int start = 0 ;\\n        int last = n-1;\\n        set<int>s;\\n        \\n        for(auto it : nums) s.insert(it);\\n        \\n        if(s.size()==1 && s.count(1)==0) return 0;\\n        if(s.size()==1 && s.count(1)!=0) return 1;\\n        \\n        while(nums[start]==0 && start <n){\\n            start++;\\n        }\\n        while(nums[last]==0 && last>=0){\\n            last--;\\n        }\\n        \\n        // cout<<start<<\" \"<<last;\\n        long long prod=1;\\n        int count=0;\\n        start++;\\n        while(start<=last){\\n            if(nums[start]==0){\\n                count++;\\n                // cout<<count;\\n            }else{\\n                \\n                prod= (prod*(count+1))%mod;\\n                count=0;\\n                // prod%=mod;\\n            }\\n            start++;\\n        }\\n            \\n       return prod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3693303,
                "title": "very-easy-o-n-tc-o-1-sc-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWE JUST NEED TO SEE IN HOW MANY WAYS WE CAN TAKE NO. OF ZEROS IN BETWEEN THE TWO ONES \\nLIKE IF WE HAVE 3 ZEROES IN BETWEEN THE TWO ONES\\n\\n0 0 1 0 0 0 1 0 0\\nTHEN THREE MIDDLE ZEROS HAVE OPTION TO MOVE IN EITHER LEFT SUB ARRAY OR EITHER IN RIGHT SUB ARRAY \\nSO ANS IS 3,\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long cnt=-1;\\n        long long ans=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                // cout<<i<<\" \";\\n                // cout<<cnt<<\" \";\\n                if(cnt==-1){\\n                    cnt=i;\\n                    ans=1;\\n                }\\n                else{\\n                    ans=((ans%mod)*((i-cnt)%mod))%mod;\\n                    // cout<<ans<<\" \";\\n                    cnt=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long cnt=-1;\\n        long long ans=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                // cout<<i<<\" \";\\n                // cout<<cnt<<\" \";\\n                if(cnt==-1){\\n                    cnt=i;\\n                    ans=1;\\n                }\\n                else{\\n                    ans=((ans%mod)*((i-cnt)%mod))%mod;\\n                    // cout<<ans<<\" \";\\n                    cnt=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3683633,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        \\n       List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1) list.add(i);\\n        }\\n        if(list.size()==0) return 0;\\n        if(list.size()==1) return 1;\\n        int mod =(int)1e9+7;\\n        long res = 1;\\n        for(int i=0;i<list.size()-1;i++){\\n                long index1 = (long)list.get(i);\\n                long index2 = (long)list.get(i+1);\\n                res =  ( res%mod * (index2-index1)%mod)%mod;\\n                \\n            \\n        }\\n        return (int)res;\\n         \\n        \\n       \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        \\n       List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1) list.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3682326,
                "title": "dp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int prev = -1;\\n        int mod = 1e9+7;\\n        int n=nums.size();\\n        vector<long long> dp(n,0);\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                prev=i;\\n                break;\\n            }\\n        }\\n        if(prev==-1) return 0;\\n\\n        dp[prev]=1;\\n\\n        for(int i=prev+1;i<n;i++){\\n            if(nums[i]==0){\\n                dp[i]=dp[i-1]%mod;\\n            }\\n            else{\\n                dp[i]=(1LL*dp[prev]*(i-prev))%mod;\\n                prev = i;\\n            }\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int prev = -1;\\n        int mod = 1e9+7;\\n        int n=nums.size();\\n        vector<long long> dp(n,0);\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                prev=i;\\n                break;\\n            }\\n        }\\n        if(prev==-1) return 0;\\n\\n        dp[prev]=1;\\n\\n        for(int i=prev+1;i<n;i++){\\n            if(nums[i]==0){\\n                dp[i]=dp[i-1]%mod;\\n            }\\n            else{\\n                dp[i]=(1LL*dp[prev]*(i-prev))%mod;\\n                prev = i;\\n            }\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682199,
                "title": "python-one-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe multiply difference of indexes of consecutive 1\\'s in the array because we can split the array in one of these indexes. \\n\\nIf we don\\'t have any 1 in the array we should return 0. \\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, N, m = 10**9+7):\\n        return any(N)*prod(b-a for a,b in pairwise(i for i,x in enumerate(N) if x))%m\\n```\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, N, m = 10**9+7):\\n        return any(N)*prod(b-a for a,b in pairwise(i for i,x in enumerate(N) if x))%m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682139,
                "title": "python-clean-o-n-solution",
                "content": "# Intuition\\nThe question is essentially asking for the product of distances between neighbouring 1\\'s.\\nDistances of each pair denotes the number of 0\\'s in front of the latter element in the pair.\\nExample:\\n0,1,1,0,0,0,1,0,0,1,0\\nWe can divide the array to this sequence: <0,1>,<1>,<0,0,0,1>,<0,0,1> and consider **number of 0\\'s in front of each 1** (ignore the first 1). \\nFor the 1st element in the sequence, we cannot donate 0\\'s to the previous 1 since it is the first 1.\\nFor the 2nd, it doesn\\'t have 0\\'s in front of it so we cannot donate 0 either. The distance here is 1 so answer is still 1.\\nFor the 3rd, it can donate 0/1/2/3 zero\\'s to the previous. So the answer is updated to 4.\\nLastly for the 4th, it can donate 0/1/2 zero\\'s to the previous. The final answer would be 4 * 3 = 12.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        # indices of 1\\'s\\n        lst = [i for i, x in enumerate(nums) if x == 1]\\n        if lst == []:\\n            return 0\\n\\n        mod = int(1e9+7)\\n        ans = 1\\n        for i in range(1, len(lst)):\\n            # multiply by distances\\n            ans = (ans * (lst[i] - lst[i-1])) % mod\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        # indices of 1\\'s\\n        lst = [i for i, x in enumerate(nums) if x == 1]\\n        if lst == []:\\n            return 0\\n\\n        mod = int(1e9+7)\\n        ans = 1\\n        for i in range(1, len(lst)):\\n            # multiply by distances\\n            ans = (ans * (lst[i] - lst[i-1])) % mod\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682018,
                "title": "easiest-solution-no-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int prev = 0 , id = 0 , cnt = 0;\\n        vector<int> v;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n         if(nums[i] == 1)\\n         {\\n            cnt++;\\n            id = i;\\n            v.push_back(abs(id - prev ));\\n            prev = i;\\n         } \\n\\n        }\\n        if(cnt == 0)\\n        {\\n            return 0;\\n        }\\n        long long ans = 1 , k = 1 , MOD = 1e9+7;\\n      \\n        for(int i = 1 ; i < v.size() ; i++)\\n        {\\n           \\n           if((i)%k == 0)\\n           {\\n                  // cout<<i<< \" \" << \"ha\" << endl;\\n                  ans = ((ans%MOD)*(v[i]))%MOD;\\n           }\\n        }\\n        return (int)ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int prev = 0 , id = 0 , cnt = 0;\\n        vector<int> v;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n         if(nums[i] == 1)\\n         {\\n            cnt++;\\n            id = i;\\n            v.push_back(abs(id - prev ));\\n            prev = i;\\n         } \\n\\n        }\\n        if(cnt == 0)\\n        {\\n            return 0;\\n        }\\n        long long ans = 1 , k = 1 , MOD = 1e9+7;\\n      \\n        for(int i = 1 ; i < v.size() ; i++)\\n        {\\n           \\n           if((i)%k == 0)\\n           {\\n                  // cout<<i<< \" \" << \"ha\" << endl;\\n                  ans = ((ans%MOD)*(v[i]))%MOD;\\n           }\\n        }\\n        return (int)ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3681866,
                "title": "video-explanation-2-approach-math-bottom-up-dp",
                "content": "# Explanation\\n\\n[Click here for the video](https://youtu.be/aLzp4jf9HCw) \\n\\n# Code\\n```\\ntypedef long long int ll;\\nconst int MOD = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    /*\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        ll result = 1;\\n        int n = nums.size();\\n        \\n        bool is_first_one = true;\\n        for (int j = 0; j < n; j ++) {\\n            int cnt = 0;\\n            while (j < n && nums[j] == 0) cnt ++, j ++;\\n            \\n            if (j == n) break;\\n            \\n            if (is_first_one) is_first_one = false;\\n            else result = (result * (cnt + 1)) % MOD;\\n        }\\n        \\n        if (is_first_one) return 0;\\n        return result;\\n    }\\n    */\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> nxt(n+1, n);\\n        vector<int> nxt_nxt(n+1, n);\\n        \\n        for (int j = n-1; j >= 0; j --) {\\n            if (nums[j] == 1) {\\n                nxt[j] = j;\\n                nxt_nxt[j] = nxt[j+1];\\n            }\\n            else {\\n                nxt[j] = nxt[j+1];\\n                nxt_nxt[j] = nxt_nxt[j+1];\\n            }\\n        }\\n        \\n        vector<ll> result(n+1, 0);\\n        vector<ll> suffix(n+1, 0);\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            int st = nxt[j];\\n            int ed = nxt_nxt[j];\\n            \\n            if (st == ed) continue;\\n            if (ed == n) {\\n                result[j] = 1;\\n                suffix[j] = (suffix[j+1] + result[j]) % MOD;\\n                continue;\\n            }\\n                        \\n            result[j] = (suffix[st+1] - suffix[ed+1] + MOD) % MOD;\\n            suffix[j] = (suffix[j+1] + result[j]) % MOD;\\n        }\\n                \\n        return result[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\nconst int MOD = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    /*\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        ll result = 1;\\n        int n = nums.size();\\n        \\n        bool is_first_one = true;\\n        for (int j = 0; j < n; j ++) {\\n            int cnt = 0;\\n            while (j < n && nums[j] == 0) cnt ++, j ++;\\n            \\n            if (j == n) break;\\n            \\n            if (is_first_one) is_first_one = false;\\n            else result = (result * (cnt + 1)) % MOD;\\n        }\\n        \\n        if (is_first_one) return 0;\\n        return result;\\n    }\\n    */\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> nxt(n+1, n);\\n        vector<int> nxt_nxt(n+1, n);\\n        \\n        for (int j = n-1; j >= 0; j --) {\\n            if (nums[j] == 1) {\\n                nxt[j] = j;\\n                nxt_nxt[j] = nxt[j+1];\\n            }\\n            else {\\n                nxt[j] = nxt[j+1];\\n                nxt_nxt[j] = nxt_nxt[j+1];\\n            }\\n        }\\n        \\n        vector<ll> result(n+1, 0);\\n        vector<ll> suffix(n+1, 0);\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            int st = nxt[j];\\n            int ed = nxt_nxt[j];\\n            \\n            if (st == ed) continue;\\n            if (ed == n) {\\n                result[j] = 1;\\n                suffix[j] = (suffix[j+1] + result[j]) % MOD;\\n                continue;\\n            }\\n                        \\n            result[j] = (suffix[st+1] - suffix[ed+1] + MOD) % MOD;\\n            suffix[j] = (suffix[j+1] + result[j]) % MOD;\\n        }\\n                \\n        return result[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681275,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> id;\\n        int c = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                c++;\\n                id.push_back(i + 1);\\n            }\\n        }\\n        \\n        if (c == 0)\\n            return 0;\\n        \\n        int mod = 1e9 + 7;\\n        long long ans = 1;  \\n        \\n        for (int i = 1; i < id.size(); i++) {\\n            ans = (ans * (id[i] - id[i - 1])) % mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> id;\\n        int c = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                c++;\\n                id.push_back(i + 1);\\n            }\\n        }\\n        \\n        if (c == 0)\\n            return 0;\\n        \\n        int mod = 1e9 + 7;\\n        long long ans = 1;  \\n        \\n        for (int i = 1; i < id.size(); i++) {\\n            ans = (ans * (id[i] - id[i - 1])) % mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681084,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nno.of choices of divisons =no.of zeros+1 \\nbetween two one\\n# Approach\\ncount zero between two ones.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int i=0, count=0,pre_one=-1;\\n        long long int ans=1;\\n\\n       for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1){\\n               count++;\\n               if(count>1){\\n                  ans = (ans*(i-pre_one))%1000000007;\\n               }\\n               pre_one=i;\\n\\n           }\\n       } \\n       if (count==0)return 0;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int i=0, count=0,pre_one=-1;\\n        long long int ans=1;\\n\\n       for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1){\\n               count++;\\n               if(count>1){\\n                  ans = (ans*(i-pre_one))%1000000007;\\n               }\\n               pre_one=i;\\n\\n           }\\n       } \\n       if (count==0)return 0;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679412,
                "title": "c-solution-store-1-s-easy-approach-code-complexity",
                "content": "# Intuition\\nTo find number of ways the number of Zeroes present between two adjacent Ones.\\n\\n# Approach\\n1. We store all the indices where there is a $$1$$ in an array.\\n2. If there are no ones we return zero as there are no good subarrays.\\n3. Using $$windows$$ we find obtain each pair of adjacent ones\\n4. We can choose to subdivide the array in any position between two adjacent indexes  , so we multiply the answer by their absolute difference \\n5. We do this for each pair, taking the modulo.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(N)$$ but can be optimized using pointers\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    const int MOD = 1e9 + 7;\\n    \\n    //Idea : to find number of ways the number of Zeroes present between two adjacent Ones.\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<ll> vec;\\n        int s = nums.size();\\n        \\n        //Step 1 - store the position of ones \\n        for(int i = 0; i < s; i++){\\n            if(nums[i] == 1){\\n                vec.push_back(i);\\n            }\\n        }\\n        //when no ones present \\n        if(vec.size() == 0){\\n            return 0;\\n        }\\n        \\n        ll ans = 1;\\n        //simply take the absolute difference of position and multiply to the ans\\n        //also take mod at each step\\n        for(int i = 1; i < vec.size(); i++){\\n            ans = ((ans%MOD) * ((vec[i - 1] - vec[i])%MOD)) % MOD;\\n        }\\n        \\n        return ans % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    const int MOD = 1e9 + 7;\\n    \\n    //Idea : to find number of ways the number of Zeroes present between two adjacent Ones.\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<ll> vec;\\n        int s = nums.size();\\n        \\n        //Step 1 - store the position of ones \\n        for(int i = 0; i < s; i++){\\n            if(nums[i] == 1){\\n                vec.push_back(i);\\n            }\\n        }\\n        //when no ones present \\n        if(vec.size() == 0){\\n            return 0;\\n        }\\n        \\n        ll ans = 1;\\n        //simply take the absolute difference of position and multiply to the ans\\n        //also take mod at each step\\n        for(int i = 1; i < vec.size(); i++){\\n            ans = ((ans%MOD) * ((vec[i - 1] - vec[i])%MOD)) % MOD;\\n        }\\n        \\n        return ans % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679402,
                "title": "100-beast-ez-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if set(nums)=={0}:return 0\\n        frst_ind_one=nums.index(1)\\n        last_ind_one=nums[::-1].index(1)\\n        nums=nums[frst_ind_one:(len(nums)-last_ind_one)]\\n        res,zeros_count=1,0\\n        mod = 10**9+7\\n        for i in nums:\\n            if i==0:\\n                zeros_count+=1\\n            elif zeros_count>0:\\n                res=res*(zeros_count+1)\\n                res=res%mod\\n                zeros_count=0\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if set(nums)=={0}:return 0\\n        frst_ind_one=nums.index(1)\\n        last_ind_one=nums[::-1].index(1)\\n        nums=nums[frst_ind_one:(len(nums)-last_ind_one)]\\n        res,zeros_count=1,0\\n        mod = 10**9+7\\n        for i in nums:\\n            if i==0:\\n                zeros_count+=1\\n            elif zeros_count>0:\\n                res=res*(zeros_count+1)\\n                res=res%mod\\n                zeros_count=0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679399,
                "title": "java-dynamic-programming-memomization",
                "content": "```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n=nums.length;\\n        int dp[][]=new int[n][2];\\n        for(int rows[]:dp)\\n            Arrays.fill(rows,-1);\\n        return findWays(0,0,nums,dp);\\n    }\\n    public int findWays(int idx,int flag,int nums[],int dp[][]){\\n        if(idx==nums.length)\\n            return flag;\\n        \\n        if(dp[idx][flag]!=-1)\\n            return dp[idx][flag];\\n        \\n        int take=0;\\n        int nottake=0;\\n        if(flag==1){\\n            if(nums[idx]==1)\\n                return 0;\\n            else{\\n                //break here\\n                take=findWays(idx+1,0,nums,dp);\\n                //not break here\\n                nottake=findWays(idx+1,1,nums,dp);\\n                return dp[idx][flag]=(take%mod+nottake%mod)%mod;\\n            }\\n        }\\n        else{\\n            if(nums[idx]==1){\\n                //break here\\n                take=findWays(idx+1,0,nums,dp);\\n            \\n                //not break here\\n                nottake=findWays(idx+1,1,nums,dp);\\n            \\n                return dp[idx][flag]=(take%mod+nottake%mod)%mod;\\n            }    \\n            else{\\n                //not break here\\n                nottake=findWays(idx+1,0,nums,dp);\\n                \\n                return dp[idx][flag]=nottake%mod;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n=nums.length;\\n        int dp[][]=new int[n][2];\\n        for(int rows[]:dp)\\n            Arrays.fill(rows,-1);\\n        return findWays(0,0,nums,dp);\\n    }\\n    public int findWays(int idx,int flag,int nums[],int dp[][]){\\n        if(idx==nums.length)\\n            return flag;\\n        \\n        if(dp[idx][flag]!=-1)\\n            return dp[idx][flag];\\n        \\n        int take=0;\\n        int nottake=0;\\n        if(flag==1){\\n            if(nums[idx]==1)\\n                return 0;\\n            else{\\n                //break here\\n                take=findWays(idx+1,0,nums,dp);\\n                //not break here\\n                nottake=findWays(idx+1,1,nums,dp);\\n                return dp[idx][flag]=(take%mod+nottake%mod)%mod;\\n            }\\n        }\\n        else{\\n            if(nums[idx]==1){\\n                //break here\\n                take=findWays(idx+1,0,nums,dp);\\n            \\n                //not break here\\n                nottake=findWays(idx+1,1,nums,dp);\\n            \\n                return dp[idx][flag]=(take%mod+nottake%mod)%mod;\\n            }    \\n            else{\\n                //not break here\\n                nottake=findWays(idx+1,0,nums,dp);\\n                \\n                return dp[idx][flag]=nottake%mod;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679396,
                "title": "no-sliding-window-no-memory-just-a-simple-iteration",
                "content": "```\\nlong long val = 1,prev = -1,mod = 1e9 + 7;\\nfor(int i=0;i<nums.size();i++)\\n{\\n\\tif(nums[i])\\n\\t{\\n\\t\\tif(prev != -1)\\n\\t\\t{\\n\\t\\t\\tval=(val*(i - prev))%mod;\\n\\t\\t}\\n\\t\\tprev = i;\\n\\t}\\n}\\nreturn prev == -1?0:val;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nlong long val = 1,prev = -1,mod = 1e9 + 7;\\nfor(int i=0;i<nums.size();i++)\\n{\\n\\tif(nums[i])\\n\\t{\\n\\t\\tif(prev != -1)\\n\\t\\t{\\n\\t\\t\\tval=(val*(i - prev))%mod;\\n\\t\\t}\\n\\t\\tprev = i;\\n\\t}\\n}\\nreturn prev == -1?0:val;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679385,
                "title": "c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n     long long dp[100005][3];\\n    int mod=1e9+7;\\n    long long find(vector<int>&s,int index,int k)\\n    {\\n        if(index>=s.size())\\n        {\\n            return k==1;\\n        }\\n        long long ans=0;\\n        if(dp[index][k]!=-1)\\n        {\\n            return dp[index][k]%mod;\\n        }\\n        if(k==1)\\n        {\\n            if(s[index]==0)\\n            {\\n                ans+=find(s,index+1,k)+find(s,index+1,0);\\n            }\\n            else\\n            {\\n                ans+=find(s,index+1,1);\\n            }\\n        }\\n        else\\n        {\\n            \\n            if(s[index]==1)\\n            {\\n                k++;\\n            }\\n            ans+=find(s,index+1,k);\\n        }\\n        return dp[index][k]= ans%mod;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return (int )find(nums,0,0)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long dp[100005][3];\\n    int mod=1e9+7;\\n    long long find(vector<int>&s,int index,int k)\\n    {\\n        if(index>=s.size())\\n        {\\n            return k==1;\\n        }\\n        long long ans=0;\\n        if(dp[index][k]!=-1)\\n        {\\n            return dp[index][k]%mod;\\n        }\\n        if(k==1)\\n        {\\n            if(s[index]==0)\\n            {\\n                ans+=find(s,index+1,k)+find(s,index+1,0);\\n            }\\n            else\\n            {\\n                ans+=find(s,index+1,1);\\n            }\\n        }\\n        else\\n        {\\n            \\n            if(s[index]==1)\\n            {\\n                k++;\\n            }\\n            ans+=find(s,index+1,k);\\n        }\\n        return dp[index][k]= ans%mod;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return (int )find(nums,0,0)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679338,
                "title": "easy-to-understand-c-brute-force-solution",
                "content": "# Intuition\\nSave the previously seen 1 postion and multiply the difference between current 1\\'s position and previously seen 1\\'s position \\n# Approach\\nEdge Case = If all are 0\\'s then return 0\\nsaved the last seen 1\\'s location and then at start iterating over the array and when got a 1 then multiply their location\\'s difference with the result and made the current 1\\'s location as last seen for the upcoming 1\\'s\\n# Complexity\\n- Time complexity:O(n)\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int res = 1, md = 1e9 + 7, sum = accumulate(nums.begin(), nums.end(), 0), r = nums.size() - 1;\\n        if (sum == 0) return 0;\\n        int firstseen = -1;\\n        for (int i = 0; i <= r; i++) {\\n            if (nums[i]) {\\n                if (firstseen == -1) {\\n                    firstseen = i;\\n                    continue;\\n                }\\n                res = (1LL * res * ((i - firstseen) % md)) % md;\\n                firstseen = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int res = 1, md = 1e9 + 7, sum = accumulate(nums.begin(), nums.end(), 0), r = nums.size() - 1;\\n        if (sum == 0) return 0;\\n        int firstseen = -1;\\n        for (int i = 0; i <= r; i++) {\\n            if (nums[i]) {\\n                if (firstseen == -1) {\\n                    firstseen = i;\\n                    continue;\\n                }\\n                res = (1LL * res * ((i - firstseen) % md)) % md;\\n                firstseen = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679323,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 1, mod = 1e9 + 7;\\n        \\n        int last = -1;\\n        for(int i=n-1; i>=0; i--) {\\n            if(nums[i] == 1) last = i;\\n        }\\n        if(last == -1) return 0;\\n        \\n        for(int i=last+1; i<n; i++) {\\n            if(nums[i] == 1) {\\n                ans *= i - last;\\n                last = i;\\n                ans %= mod;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 1, mod = 1e9 + 7;\\n        \\n        int last = -1;\\n        for(int i=n-1; i>=0; i--) {\\n            if(nums[i] == 1) last = i;\\n        }\\n        if(last == -1) return 0;\\n        \\n        for(int i=last+1; i<n; i++) {\\n            if(nums[i] == 1) {\\n                ans *= i - last;\\n                last = i;\\n                ans %= mod;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679322,
                "title": "c-easy-approach",
                "content": "Normally count the number of zeros between ones and multiply all of them by by increasing one which basically its number of permutation\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector< int > arr;\\n        long long x = 1;\\n        int flag = 0;\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(flag == 1 && nums[i] == 0) count++;\\n            if(flag == 1 && nums[i] == 1) {\\n                arr.push_back(count);\\n                count = 0;\\n            } \\n            if(flag == 0 && nums[i] == 1) flag = 1;\\n        }\\n        if(arr.size() == 0 && flag == 0) return 0;\\n        if(arr.size() == 0) return 1;\\n        for(auto i : arr) {\\n            x = (x * (i+1)) % 1000000007;\\n            \\n        }\\n        return x % 1000000007;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector< int > arr;\\n        long long x = 1;\\n        int flag = 0;\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(flag == 1 && nums[i] == 0) count++;\\n            if(flag == 1 && nums[i] == 1) {\\n                arr.push_back(count);\\n                count = 0;\\n            } \\n            if(flag == 0 && nums[i] == 1) flag = 1;\\n        }\\n        if(arr.size() == 0 && flag == 0) return 0;\\n        if(arr.size() == 0) return 1;\\n        for(auto i : arr) {\\n            x = (x * (i+1)) % 1000000007;\\n            \\n        }\\n        return x % 1000000007;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679272,
                "title": "java-solution-easy-and-clean",
                "content": "#    Java Soluton\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        long modulo = 1000000007L;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                res.add(i);\\n        }\\n        long ans = 0;\\n        if (res.size() > 0)\\n            ans = 1;\\n        long kanishk = ans;\\n        for (int i = res.size() - 2; i >= 0; i--) {\\n            int leftInd = res.get(i);\\n            int rightInd = res.get(i + 1);\\n            int df = rightInd - leftInd;\\n            long mul = ((long) df % modulo * (long) kanishk % modulo) % modulo;\\n            kanishk = mul;\\n            ans = mul;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        long modulo = 1000000007L;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                res.add(i);\\n        }\\n        long ans = 0;\\n        if (res.size() > 0)\\n            ans = 1;\\n        long kanishk = ans;\\n        for (int i = res.size() - 2; i >= 0; i--) {\\n            int leftInd = res.get(i);\\n            int rightInd = res.get(i + 1);\\n            int df = rightInd - leftInd;\\n            long mul = ((long) df % modulo * (long) kanishk % modulo) % modulo;\\n            kanishk = mul;\\n            ans = mul;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679265,
                "title": "easy-explanation-100-beat-sliding-window",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Count the 1 in given `nums`.\\n2. And store the index in vector `split`.\\n3. After that traverse vector `split` with subtract `split[i]` and `split[i - 1]` and `i` is `0 < i < split.length()`. \\n4. This subtraction multiply with `count`.\\n5. Return `count`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int> split;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) split.push_back(i);\\n        }\\n                \\n        if (split.size() == 0) return 0;\\n        long long int count = 1;\\n        for (int i = 1; i < split.size(); i++) {\\n            count *= (split[i] - split[i - 1])%MOD;\\n            count  = count%MOD;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int> split;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) split.push_back(i);\\n        }\\n                \\n        if (split.size() == 0) return 0;\\n        long long int count = 1;\\n        for (int i = 1; i < split.size(); i++) {\\n            count *= (split[i] - split[i - 1])%MOD;\\n            count  = count%MOD;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679263,
                "title": "java-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        \\n        int count1 = 0;\\n        List<Integer> lst = new ArrayList<>();\\n        for(int i= 0; i < nums.length; i++){\\n            if(nums[i] == 1){\\n                count1++;\\n                lst.add(i);\\n            }\\n        }\\n        if(count1 == 0) return 0;\\n        if(count1 == 1) return 1;\\n        \\n        int mod = (int)1e9+7;\\n        long ans = 1;\\n        for(int i = 0; i < lst.size()-1; i++){\\n            int val1 = lst.get(i);\\n            int val2 = lst.get(i+1);\\n            int val = val2 - val1;\\n            ans = (ans*val)%mod;\\n        }\\n        \\n        return (int)ans; \\n        \\n    }\\n    \\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        \\n        int count1 = 0;\\n        List<Integer> lst = new ArrayList<>();\\n        for(int i= 0; i < nums.length; i++){\\n            if(nums[i] == 1){\\n                count1++;\\n                lst.add(i);\\n            }\\n        }\\n        if(count1 == 0) return 0;\\n        if(count1 == 1) return 1;\\n        \\n        int mod = (int)1e9+7;\\n        long ans = 1;\\n        for(int i = 0; i < lst.size()-1; i++){\\n            int val1 = lst.get(i);\\n            int val2 = lst.get(i+1);\\n            int val = val2 - val1;\\n            ans = (ans*val)%mod;\\n        }\\n        \\n        return (int)ans; \\n        \\n    }\\n    \\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679262,
                "title": "dp-prefix-sum-c",
                "content": "# Approach\\nDynamic Programming & Prefix Sum\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int MOD = 7 + 1e9;\\n        vector<int> dp(n + 1);\\n        vector<int> sum(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            if (nums[i - 1] == 0) {\\n                dp[i] = dp[i - 1];\\n                sum[i] = sum[i - 1] + dp[i];\\n                sum[i] %= MOD;\\n            }\\n            else {\\n                dp[i] = 1;\\n                sum[i] = sum[i - 1];\\n                dp[i] += sum[i];\\n            }\\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int MOD = 7 + 1e9;\\n        vector<int> dp(n + 1);\\n        vector<int> sum(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            if (nums[i - 1] == 0) {\\n                dp[i] = dp[i - 1];\\n                sum[i] = sum[i - 1] + dp[i];\\n                sum[i] %= MOD;\\n            }\\n            else {\\n                dp[i] = 1;\\n                sum[i] = sum[i - 1];\\n                dp[i] += sum[i];\\n            }\\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679259,
                "title": "simple-o-n-intuitive",
                "content": "# Intuition\\n\\nWe can see that subarrays should end at 1 or we can keep adding 0s to the current subarray until the next 1 appears.\\n\\nThis basically becomes a problem of counting 0s between ones and taking their product.\\n\\nTo keep the number between limits we take mod with 10^9 + 7\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans = 0;\\n        int mod = 1e9+7;\\n        \\n        int curr = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i] == 1) {\\n                if(ans == 0) {\\n                    ans = 1;\\n                    curr = 0;\\n                }\\n                else {\\n                    ans = (ans*(curr+1))%mod;\\n                    curr = 0;\\n                }\\n            } else {\\n                curr++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans = 0;\\n        int mod = 1e9+7;\\n        \\n        int curr = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i] == 1) {\\n                if(ans == 0) {\\n                    ans = 1;\\n                    curr = 0;\\n                }\\n                else {\\n                    ans = (ans*(curr+1))%mod;\\n                    curr = 0;\\n                }\\n            } else {\\n                curr++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679258,
                "title": "easy-python-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if not sum(nums):\\n            return 0\\n        ans = 1\\n        count = 1\\n        for i in range(len(nums)):\\n            if nums[i]:\\n                for j in range(i, len(nums)):\\n                    if nums[j]:\\n                        ans = ans * count % (10**9+7)\\n                        count = 1\\n                    if not nums[j]:\\n                        count += 1\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if not sum(nums):\\n            return 0\\n        ans = 1\\n        count = 1\\n        for i in range(len(nums)):\\n            if nums[i]:\\n                for j in range(i, len(nums)):\\n                    if nums[j]:\\n                        ans = ans * count % (10**9+7)\\n                        count = 1\\n                    if not nums[j]:\\n                        count += 1\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679196,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll mod(ll num){\\n        return num % ll(1e9+7);\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        ll n=nums.size(), nxtOne = n;\\n        vector<ll>ans(n);\\n        for(ll i=n-1; i>-1; --i){\\n            if(nums[i]){\\n                if(nxtOne == n){\\n                    ans[i]=1; // first one encountered ; one partition possible\\n                }\\n                else{\\n                    ans[i] = mod((nxtOne-i) * ans[nxtOne]); // total num of combinations (see #)\\n                }\\n                nxtOne = i; // update\\n            }\\n            else{\\n                ans[i] = i+1<n ? ans[i+1] : 0; // only as many possible as the next index can get ; current zero will simply stick with all those partitions  \\n            }\\n        }\\n        return ans[0];\\n    }\\n};\\n```\\n#at cur and nxtOne positions we have ones, in between, i.e. [cur+1, nxtOne-1] all are 0s. Suppose total number of partitions from nxtone is y and say x = no. of zeroes in between + 1 (cur partition may end at cur itself as well) = nxtOne - cur.\\nFor every ind in [cur, nxtOne-1]:\\n    For p = each of y partitions:\\n\\t    we put a new partition from cur to ind followed by already observed partition p.\\n\\t\\tIn this already calculated partition p, we simply prepend all the 0s from ind+1 to nxtOne-1",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll mod(ll num){\\n        return num % ll(1e9+7);\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        ll n=nums.size(), nxtOne = n;\\n        vector<ll>ans(n);\\n        for(ll i=n-1; i>-1; --i){\\n            if(nums[i]){\\n                if(nxtOne == n){\\n                    ans[i]=1; // first one encountered ; one partition possible\\n                }\\n                else{\\n                    ans[i] = mod((nxtOne-i) * ans[nxtOne]); // total num of combinations (see #)\\n                }\\n                nxtOne = i; // update\\n            }\\n            else{\\n                ans[i] = i+1<n ? ans[i+1] : 0; // only as many possible as the next index can get ; current zero will simply stick with all those partitions  \\n            }\\n        }\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679183,
                "title": "zeros-in-between",
                "content": "We have exactly `m` good subarrays, where `m` is the number of `1`.\\n\\nZeros in between two `1` add split points. Condiser `100101` as the example.\\n\\nBetween first two `1` we can split in 3 points: `1|0|0|1`, and between second two `1` - in 2: `1|0|1`.\\n\\nThe total number of splits is 3 * 2. So we count `zeros` in between of two `1`, and mulitply the result by `zeros + 1`.\\n\\n**C++**\\n```cpp\\nint numberOfGoodSubarraySplits(vector<int>& nums) {\\n    long long res = 0, zeros = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        if (nums[i] == 0)\\n            zeros += res > 0;\\n        else {\\n            res = res ? res * (zeros + 1) % 1000000007 : 1;\\n            zeros = 0;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numberOfGoodSubarraySplits(vector<int>& nums) {\\n    long long res = 0, zeros = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        if (nums[i] == 0)\\n            zeros += res > 0;\\n        else {\\n            res = res ? res * (zeros + 1) % 1000000007 : 1;\\n            zeros = 0;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679092,
                "title": "o-n-product-of-number-of-zeros-plus-1-that-are-between-ones",
                "content": "```python3\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        total, zero, mod = 0, 1, 1_000_000_007\\n        for i in nums:\\n            if i == 0:\\n                zero += 1\\n            else:\\n                total = 1 if total == 0 else total * zero % mod\\n                zero = 1\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        total, zero, mod = 0, 1, 1_000_000_007\\n        for i in nums:\\n            if i == 0:\\n                zero += 1\\n            else:\\n                total = 1 if total == 0 else total * zero % mod\\n                zero = 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098954,
                "title": "cpp-solution-in-linear-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int count = 0;\\n        int mod = 1000000007;\\n        long long int ans = 1;\\n\\n        // remove initial zeros\\n        int i = 0;\\n        while(i < nums.size() && nums[i] == 0)\\n            i++;\\n        \\n        if(i >= nums.size())\\n            return 0;\\n\\n        // now multiply ans with total no. of zero bwteen two one\\'s \\n        while(i < nums.size())\\n        {\\n            if(nums[i] == 1)\\n            {\\n                ans = (ans * (count + 1) ) % mod;\\n                count = 0;\\n            }\\n            else\\n                count++;\\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int count = 0;\\n        int mod = 1000000007;\\n        long long int ans = 1;\\n\\n        // remove initial zeros\\n        int i = 0;\\n        while(i < nums.size() && nums[i] == 0)\\n            i++;\\n        \\n        if(i >= nums.size())\\n            return 0;\\n\\n        // now multiply ans with total no. of zero bwteen two one\\'s \\n        while(i < nums.size())\\n        {\\n            if(nums[i] == 1)\\n            {\\n                ans = (ans * (count + 1) ) % mod;\\n                count = 0;\\n            }\\n            else\\n                count++;\\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086022,
                "title": "fast-java-solution-o-n-time-complexity-beats-99",
                "content": "# Intuition\\n\\ntry every possible combinations of zeros for all index where the value is 1 and multiply all those ..\\n# Approach\\nfor every index where the value is 1 count the zeros at their left  till you reach the 1 that is at left of your current 1 and do the similar stuff with every index where the value is 1 and multiply all those ... \\n\\n# Complexity\\n- Time complexity:\\nO(N) ;\\n\\n- Space complexity:\\nO(1) ;\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n = nums.length ;\\n        \\n   int mod = 1000000007 ;\\n        \\n        int  k = 1 ;\\n        long total = 0  ;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == 0 ){\\n                k++ ;\\n            }else{\\n                total = (total * k)%mod ;\\n           if(total == 0 ){\\n               total = 1 ;\\n           }\\n                k= 1 ;\\n            }\\n        }\\n     \\n        return (int)total%mod  ;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n = nums.length ;\\n        \\n   int mod = 1000000007 ;\\n        \\n        int  k = 1 ;\\n        long total = 0  ;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == 0 ){\\n                k++ ;\\n            }else{\\n                total = (total * k)%mod ;\\n           if(total == 0 ){\\n               total = 1 ;\\n           }\\n                k= 1 ;\\n            }\\n        }\\n     \\n        return (int)total%mod  ;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079144,
                "title": "best-c-sol-in-o-n-time-and-o-1-space-using-single-traversal",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int prev=-1;\\n        int ans=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                if(prev!=-1){\\n                    ans = (ans%mod * (long)(i-prev)) %mod;\\n                }\\n                prev=i;\\n            }\\n        }\\n        if(prev==-1) return 0;\\n        return ans;\\n    }\\n};\\n```\\nUpvote the sol \\uD83D\\uDE04",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int prev=-1;\\n        int ans=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                if(prev!=-1){\\n                    ans = (ans%mod * (long)(i-prev)) %mod;\\n                }\\n                prev=i;\\n            }\\n        }\\n        if(prev==-1) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074982,
                "title": "dart",
                "content": "# Code\\n```\\nclass Solution {\\n  int numberOfGoodSubarraySplits(List<int> nums) {\\n    const MOD = 1000000007;\\n    int prev = -1;\\n    var res = 1;\\n    var has = false;\\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i] == 0) continue;\\n      has = true;\\n      if (prev != -1)\\n        res = (res * (i - prev)) % MOD;\\n      prev = i;\\n    }\\n    return has ? res : 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int numberOfGoodSubarraySplits(List<int> nums) {\\n    const MOD = 1000000007;\\n    int prev = -1;\\n    var res = 1;\\n    var has = false;\\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i] == 0) continue;\\n      has = true;\\n      if (prev != -1)\\n        res = (res * (i - prev)) % MOD;\\n      prev = i;\\n    }\\n    return has ? res : 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031842,
                "title": "simple-and-easy-solution-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long ans = 1;\\n        int i = 0, j = 0, res = 1, ok = 0;\\n        long mod = (long)1e9 + 7;\\n\\n        while(i < nums.length){\\n            if(nums[i] == 1 && ok == 0){\\n                ok = 1;\\n            }\\n            else if(nums[i] == 1 && ok == 1){\\n                ans = (ans * res) % mod;\\n                res = 1;\\n            }else if(nums[i] == 0 && ok == 1){\\n                res++;\\n            }\\n            i++;\\n        }\\n        if(ok == 1)\\n            return (int)ans;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long ans = 1;\\n        int i = 0, j = 0, res = 1, ok = 0;\\n        long mod = (long)1e9 + 7;\\n\\n        while(i < nums.length){\\n            if(nums[i] == 1 && ok == 0){\\n                ok = 1;\\n            }\\n            else if(nums[i] == 1 && ok == 1){\\n                ans = (ans * res) % mod;\\n                res = 1;\\n            }else if(nums[i] == 0 && ok == 1){\\n                res++;\\n            }\\n            i++;\\n        }\\n        if(ok == 1)\\n            return (int)ans;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002374,
                "title": "o-n-time-o-1-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int mod = 1e9+7;\\n        int prev = -1;\\n        long long ans = 0;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1){\\n                if(prev == -1)\\n                    prev = i;\\n                else\\n                    break;    \\n            }\\n        }\\n        if(prev == -1)\\n            return 0;\\n        if(prev == n-1)\\n            return 1;\\n        int a = prev;\\n        int temp;\\n        for(int i = a+1;i < n;i++){\\n            if(nums[i] == 1){\\n                temp = i - prev;\\n                if(ans == 0)\\n                    ans += (i - prev);\\n                else\\n                    ans = (ans * temp) % mod; \\n                prev = i;\\n            }\\n        } \\n        return ans == 0 ? 1 : (int)ans;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int mod = 1e9+7;\\n        int prev = -1;\\n        long long ans = 0;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1){\\n                if(prev == -1)\\n                    prev = i;\\n                else\\n                    break;    \\n            }\\n        }\\n        if(prev == -1)\\n            return 0;\\n        if(prev == n-1)\\n            return 1;\\n        int a = prev;\\n        int temp;\\n        for(int i = a+1;i < n;i++){\\n            if(nums[i] == 1){\\n                temp = i - prev;\\n                if(ans == 0)\\n                    ans += (i - prev);\\n                else\\n                    ans = (ans * temp) % mod; \\n                prev = i;\\n            }\\n        } \\n        return ans == 0 ? 1 : (int)ans;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975798,
                "title": "c-just-number-of-combination-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans = 1;\\n        int j = -1;\\n        int mod = 1e9+7;\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1){\\n               if(j==-1)j=i;\\n               else ans = (ans%mod *(i-j)%mod)%mod;\\n               j = i;\\n               ans %= mod;\\n           }\\n        }\\n        return j==-1 ? 0 : ans%mod;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans = 1;\\n        int j = -1;\\n        int mod = 1e9+7;\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1){\\n               if(j==-1)j=i;\\n               else ans = (ans%mod *(i-j)%mod)%mod;\\n               j = i;\\n               ans %= mod;\\n           }\\n        }\\n        return j==-1 ? 0 : ans%mod;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954977,
                "title": "golang-simple-solution",
                "content": "# Code\\n```go\\nfunc numberOfGoodSubarraySplits(nums []int) int {\\n\\tlast1 := -1\\n\\ttotal := 1\\n\\tfor i, v := range nums {\\n\\t\\tif v == 1 {\\n\\t\\t\\tif last1 == -1 {\\n\\t\\t\\t\\tlast1 = i\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcount0 := i - last1\\n\\t\\t\\ttotal = (total * count0) % 1000000007\\n\\t\\t\\tlast1 = i\\n\\t\\t}\\n\\t}\\n\\tif last1 == -1 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numberOfGoodSubarraySplits(nums []int) int {\\n\\tlast1 := -1\\n\\ttotal := 1\\n\\tfor i, v := range nums {\\n\\t\\tif v == 1 {\\n\\t\\t\\tif last1 == -1 {\\n\\t\\t\\t\\tlast1 = i\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcount0 := i - last1\\n\\t\\t\\ttotal = (total * count0) % 1000000007\\n\\t\\t\\tlast1 = i\\n\\t\\t}\\n\\t}\\n\\tif last1 == -1 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917349,
                "title": "java-simple-solution-math-count-number-of-zeros-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple approach is - \\n    >  Count no.of Zeros between two consecutive 1\\'s  + 1 - i.e ans * count(zeros) + 1;\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int lastOne = -1;\\n        int n = nums.length;\\n        long ans = 1;\\n        long mod = (long)1e9 + 7;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1){\\n                if(lastOne == -1){\\n                    lastOne = i;\\n                }\\n                else{\\n                    ans = ans * (long)(i - lastOne) % mod;\\n                }\\n                lastOne = i;\\n            }\\n        }\\n        if(lastOne == -1){\\n            return 0;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int lastOne = -1;\\n        int n = nums.length;\\n        long ans = 1;\\n        long mod = (long)1e9 + 7;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1){\\n                if(lastOne == -1){\\n                    lastOne = i;\\n                }\\n                else{\\n                    ans = ans * (long)(i - lastOne) % mod;\\n                }\\n                lastOne = i;\\n            }\\n        }\\n        if(lastOne == -1){\\n            return 0;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915593,
                "title": "runtime-beats-97-58-memory-beats-69-87-python3-simple-with-explanation",
                "content": "# Intuition\\nI ran into this problem when search for Dynamic Programming, but it\\'s actually not a DP problem, becasue easier formular can be used to solve it.\\n\\n# Approach\\nJust to find out how many intervals begins with 1 and end with 1 inside the number list.\\nFor each interval (i, j), there are i-j number of ways to cut the zeros, so that the 1st part 0s belongs to the front 1, and the 2nd part 0s belongs to the 1 at the end.\\nThe total ways of cutting all the interval is to multiply the number of ways in each interval together.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        prevOne = -1\\n        intervals = []\\n### Find out how many intervals begins with 1 and end with 1 inside the number list.\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                if prevOne != -1:\\n                    intervals.append(i-prevOne)\\n                prevOne = i\\n### If there\\'s no 1 in the list, return 0\\n        if prevOne == -1:\\n            return 0\\n### Calculate the total number of cutting ways in all intervals\\n        total = 1\\n        for interval in intervals:\\n            total *= interval\\n        return total % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        prevOne = -1\\n        intervals = []\\n### Find out how many intervals begins with 1 and end with 1 inside the number list.\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                if prevOne != -1:\\n                    intervals.append(i-prevOne)\\n                prevOne = i\\n### If there\\'s no 1 in the list, return 0\\n        if prevOne == -1:\\n            return 0\\n### Calculate the total number of cutting ways in all intervals\\n        total = 1\\n        for interval in intervals:\\n            total *= interval\\n        return total % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900935,
                "title": "ways-to-split-in-good-subarrays-java-easy-to-understand-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n\\n        for(int n:nums){\\n            if(n==1){\\n                ones++;\\n            }\\n        }\\n\\n        if(ones==1)return 1;\\n        if(ones==0)return 0;\\n        int mod=1000000007;\\n\\n        int i=0;\\n        long ans=1;\\n        int c=0;\\n\\n        while(i<nums.length){\\n            if(nums[i]==1){\\n                c++;\\n                if(c==ones){\\n                    break;\\n                }\\n                int j=i+1;\\n                while(j<nums.length && nums[j]==0){\\n                    j++;\\n                }\\n\\n                int len=j-i-1;\\n                if(len!=0){\\n                    ans=(ans%mod*(len+1)%mod)%mod;\\n                }\\n\\n                i=j;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n\\n        for(int n:nums){\\n            if(n==1){\\n                ones++;\\n            }\\n        }\\n\\n        if(ones==1)return 1;\\n        if(ones==0)return 0;\\n        int mod=1000000007;\\n\\n        int i=0;\\n        long ans=1;\\n        int c=0;\\n\\n        while(i<nums.length){\\n            if(nums[i]==1){\\n                c++;\\n                if(c==ones){\\n                    break;\\n                }\\n                int j=i+1;\\n                while(j<nums.length && nums[j]==0){\\n                    j++;\\n                }\\n\\n                int len=j-i-1;\\n                if(len!=0){\\n                    ans=(ans%mod*(len+1)%mod)%mod;\\n                }\\n\\n                i=j;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895532,
                "title": "o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        int n = nums.size();\\n        int val = pow(10,9)+7;\\n        int prev=-1,curr=0,flag=0;\\n        while(curr<n){\\n            while(curr<n && !nums[curr]) curr++;\\n            if(curr!=n) {\\n                flag=1;\\n                if(prev!=-1) ans = (ans*(curr-prev)) % val;\\n            }\\n            prev = curr;\\n            curr++;\\n        }\\n        return flag ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        int n = nums.size();\\n        int val = pow(10,9)+7;\\n        int prev=-1,curr=0,flag=0;\\n        while(curr<n){\\n            while(curr<n && !nums[curr]) curr++;\\n            if(curr!=n) {\\n                flag=1;\\n                if(prev!=-1) ans = (ans*(curr-prev)) % val;\\n            }\\n            prev = curr;\\n            curr++;\\n        }\\n        return flag ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888091,
                "title": "c-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long ans = 1, c = 1, m = 1e9 + 7;\\n        bool first = true;\\n        for (auto& n : nums)\\n            if (n) ans = (ans * c) % m, c = 1, first = false;\\n            else if (!first) ++c;\\n        return first ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long ans = 1, c = 1, m = 1e9 + 7;\\n        bool first = true;\\n        for (auto& n : nums)\\n            if (n) ans = (ans * c) % m, c = 1, first = false;\\n            else if (!first) ++c;\\n        return first ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879627,
                "title": "c-easy-to-understand-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {        \\n        vector<int> count;\\n        int cnt = 0;\\n        bool zero = true;        \\n        for (int a: nums) {\\n            if (a == 1) {\\n                if (!zero && cnt > 0) {\\n                    count.push_back(cnt + 1);\\n                }\\n                zero = false;\\n                cnt = 0;\\n            } else {\\n                cnt++;\\n            }\\n        }\\n        if (zero) {\\n            return 0;\\n        }\\n        long ans = 1;\\n        int mod = 1e9 + 7;\\n        for (int c: count) {\\n            ans *= c;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {        \\n        vector<int> count;\\n        int cnt = 0;\\n        bool zero = true;        \\n        for (int a: nums) {\\n            if (a == 1) {\\n                if (!zero && cnt > 0) {\\n                    count.push_back(cnt + 1);\\n                }\\n                zero = false;\\n                cnt = 0;\\n            } else {\\n                cnt++;\\n            }\\n        }\\n        if (zero) {\\n            return 0;\\n        }\\n        long ans = 1;\\n        int mod = 1e9 + 7;\\n        for (int c: count) {\\n            ans *= c;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874847,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting the difference b/t 1\\'s and simply multiplying them\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        const unsigned int M = 1000000007;\\n        int ans=0;\\n        long long anss=1;\\n        long long pre=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(pre!=-1 && nums[i]==1){\\n                anss=(anss*(i-pre))%M;\\n                pre=i;\\n            }    \\n            if(pre==-1 && nums[i]==1) pre=i;\\n            }\\n        if(pre==-1) return 0;\\n        return anss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        const unsigned int M = 1000000007;\\n        int ans=0;\\n        long long anss=1;\\n        long long pre=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(pre!=-1 && nums[i]==1){\\n                anss=(anss*(i-pre))%M;\\n                pre=i;\\n            }    \\n            if(pre==-1 && nums[i]==1) pre=i;\\n            }\\n        if(pre==-1) return 0;\\n        return anss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871664,
                "title": "math-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long res =0;\\n        long long md = 1e9 + 7;\\n        int prev = -1, n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i]){\\n                if(prev == -1){\\n                    res = 1;\\n                }\\n                else{\\n                    res = (res * (i-prev)) % md; \\n                }\\n                prev = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long res =0;\\n        long long md = 1e9 + 7;\\n        int prev = -1, n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i]){\\n                if(prev == -1){\\n                    res = 1;\\n                }\\n                else{\\n                    res = (res * (i-prev)) % md; \\n                }\\n                prev = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866746,
                "title": "c-simple-solution-two-pointers-beats-100-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod= 1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n= nums.size(), i=0, j= 0;\\n        long long ans= 1;\\n        while(i<n && nums[i]!=1) i++;\\n        if(i>=n) return 0;\\n        j= i+1;\\n        while(j<n){\\n            while(j<n && nums[j]!=1){\\n                j++;\\n            }\\n            if(j>=n) break;\\n            ans= (ans* (j-i))%mod;\\n            i= j;\\n            j++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod= 1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n= nums.size(), i=0, j= 0;\\n        long long ans= 1;\\n        while(i<n && nums[i]!=1) i++;\\n        if(i>=n) return 0;\\n        j= i+1;\\n        while(j<n){\\n            while(j<n && nums[j]!=1){\\n                j++;\\n            }\\n            if(j>=n) break;\\n            ans= (ans* (j-i))%mod;\\n            i= j;\\n            j++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858882,
                "title": "dp-solution-different-than-other-solutions",
                "content": "# Intuition\\nwhat will happen if we add 0 or 1 to an already exisiting array and how the answer will change\\n\\n# Approach\\nadding 0 to an already exisiting array wont change its answer but adding one will and we have to take in account the changes till the next one occurence( see code for better understanding)\\n\\n# Complexity\\n- Time complexity:\\nn\\n\\n- Space complexity:\\n<n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int ans=0;\\n        int n=nums.size();\\n        int dp[n];\\n        int m=1000000007;\\n        int sum=1;\\n        int flag=0;\\n        if(nums[n-1]==1){\\n            flag++;\\n        }\\n        dp[n-1]=1;\\n        int i;\\n        for(i=n-2;i>=0;i--){\\n               if(nums[i]==0){\\n                   dp[i]=(dp[i+1]%m);\\n                   if(flag>0){\\n                            sum=(sum+dp[i])%m;\\n                   }\\n                   \\n               } \\n               else if(nums[i]==1){\\n                   flag++;\\n                       dp[i]=(sum%m);\\n                       sum=dp[i];\\n               }\\n              \\n        }\\n        if(flag==0){\\n            return 0;\\n        }\\n\\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int ans=0;\\n        int n=nums.size();\\n        int dp[n];\\n        int m=1000000007;\\n        int sum=1;\\n        int flag=0;\\n        if(nums[n-1]==1){\\n            flag++;\\n        }\\n        dp[n-1]=1;\\n        int i;\\n        for(i=n-2;i>=0;i--){\\n               if(nums[i]==0){\\n                   dp[i]=(dp[i+1]%m);\\n                   if(flag>0){\\n                            sum=(sum+dp[i])%m;\\n                   }\\n                   \\n               } \\n               else if(nums[i]==1){\\n                   flag++;\\n                       dp[i]=(sum%m);\\n                       sum=dp[i];\\n               }\\n              \\n        }\\n        if(flag==0){\\n            return 0;\\n        }\\n\\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850785,
                "title": "simple-c-sol-beats-99",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        int n=nums.size();\\n        int last=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                last=i;\\n            }\\n        }\\n        if(last==-1){\\n            return 0;\\n        }\\n        for(int i=0;i<=last;i++){\\n            int c=1;\\n            if(nums[i]==1){\\n                i++;\\n                while(i<last and nums[i]!=1){\\n                    c++;\\n                    i++;\\n                }\\n                ans=((ans%mod)*(c%mod))%mod;\\n                ans%=mod;\\n                if(i==n){\\n                    return (int)ans%mod;\\n                }\\n                else{\\n                    i--;\\n                }\\n            }\\n        }\\n        return (int)ans%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        int n=nums.size();\\n        int last=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                last=i;\\n            }\\n        }\\n        if(last==-1){\\n            return 0;\\n        }\\n        for(int i=0;i<=last;i++){\\n            int c=1;\\n            if(nums[i]==1){\\n                i++;\\n                while(i<last and nums[i]!=1){\\n                    c++;\\n                    i++;\\n                }\\n                ans=((ans%mod)*(c%mod))%mod;\\n                ans%=mod;\\n                if(i==n){\\n                    return (int)ans%mod;\\n                }\\n                else{\\n                    i--;\\n                }\\n            }\\n        }\\n        return (int)ans%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846856,
                "title": "java-solution",
                "content": "# Intuition\\n```\\nIntuition that i got from the test case is that we just need to \\n find the product of the number of elements present between the 1\\'s.\\nExample-[0,1,0,0,1,0,0,1]\\n    from index i=1 to 4-->3\\n    from index i=4 to 7-->3\\n    Result=3*3=9\\n```\\n# Approach\\n```\\n1.Find the total number of ones in the array, if there is no 1\\'s \\npresent return 0.\\n2.Traverse the array again, if 1 is encountered calculate \\nresult=result*count, set count=1, decrement c (total 1\\'s) and set \\nstart=true.\\n3.If start is true increment the count by 1.\\n4.Continue this until c is 0.\\n5.Return the result.\\n```\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n- Space complexity:$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int c=0,mod=(int)1e9+7;\\n        long res=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                c++;\\n            }\\n        }\\n        if(c==0) return 0;\\n        int count=1;\\n        boolean start=false;\\n        for(int i=0;i<nums.length && c!=0;i++){\\n            if(nums[i]==1){\\n                res=(res*count)%mod;\\n                count=1;\\n                start=true;\\n                c--;\\n            }\\n            else if(start){\\n                count++;\\n            }\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nIntuition that i got from the test case is that we just need to \\n find the product of the number of elements present between the 1\\'s.\\nExample-[0,1,0,0,1,0,0,1]\\n    from index i=1 to 4-->3\\n    from index i=4 to 7-->3\\n    Result=3*3=9\\n```\n```\\n1.Find the total number of ones in the array, if there is no 1\\'s \\npresent return 0.\\n2.Traverse the array again, if 1 is encountered calculate \\nresult=result*count, set count=1, decrement c (total 1\\'s) and set \\nstart=true.\\n3.If start is true increment the count by 1.\\n4.Continue this until c is 0.\\n5.Return the result.\\n```\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int c=0,mod=(int)1e9+7;\\n        long res=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                c++;\\n            }\\n        }\\n        if(c==0) return 0;\\n        int count=1;\\n        boolean start=false;\\n        for(int i=0;i<nums.length && c!=0;i++){\\n            if(nums[i]==1){\\n                res=(res*count)%mod;\\n                count=1;\\n                start=true;\\n                c--;\\n            }\\n            else if(start){\\n                count++;\\n            }\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831004,
                "title": "beats-100-java-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ans =1;\\n        int start=0;\\n        int end = nums.length-1;\\n        int count=0;\\n        int mod = 1000000007;\\n        while (start<nums.length && nums[start]!=1)\\n        start++;\\n        while (end>=0 && nums[end]!=1)\\n        end--;\\n\\n        if (end<start)\\n        return 0;\\n\\n        for (int i=start;i<=end;i++)\\n        {\\n            if (nums[i]==1)\\n            {\\n                ans =(int)((1L*(count+1)*ans)%mod);\\n                count=0;\\n            }\\n            else \\n            count+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ans =1;\\n        int start=0;\\n        int end = nums.length-1;\\n        int count=0;\\n        int mod = 1000000007;\\n        while (start<nums.length && nums[start]!=1)\\n        start++;\\n        while (end>=0 && nums[end]!=1)\\n        end--;\\n\\n        if (end<start)\\n        return 0;\\n\\n        for (int i=start;i<=end;i++)\\n        {\\n            if (nums[i]==1)\\n            {\\n                ans =(int)((1L*(count+1)*ans)%mod);\\n                count=0;\\n            }\\n            else \\n            count+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814703,
                "title": "simple-answer-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code iterates through the nums list, and whenever it encounters the element 1, it checks whether the subarray formed by consecutive 1\\'s constitutes a good split. If it does, it updates the count of good splits accordingly.\\n\\nIf the current element is 1:\\n\\n* If count is 0 (no good splits encountered yet), set count to 1 (found one good split).\\n* If count is not 0 (good splits already found), update count by multiplying it with the length of the current subarray (the number of consecutive 1\\'s), to account for the new good splits formed by the current subarray.\\nUpdate count to be the current index to mark the start of a new potential subarray split.\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        count, last_one_index = 0, -1\\n        \\n        for current_index, num in enumerate(nums):\\n            if num == 1:\\n                if count == 0:\\n                    count = 1\\n                else:\\n                    count = count * (current_index - last_one_index) % MOD \\n                \\n                last_one_index = current_index\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        count, last_one_index = 0, -1\\n        \\n        for current_index, num in enumerate(nums):\\n            if num == 1:\\n                if count == 0:\\n                    count = 1\\n                else:\\n                    count = count * (current_index - last_one_index) % MOD \\n                \\n                last_one_index = current_index\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798426,
                "title": "o-n-solution-explained-with-example-python3",
                "content": "# Intuition\\n```\\nwe are going to have as many splits/subarrays as we have ones.\\n\\nex: \\n0, 1, 1, 0\\n01 - 10 \\n(splits = 2, ones = 2)\\n\\nex: \\n1, 1, 1\\n1 - 1 - 1 \\n(splits = 3, ones = 3)\\n\\nex: \\n0, 1, 0, 1, 1\\n01 - 01 - 1\\n010 - 1 - 1\\n(splits = 3, ones = 3)\\n```\\n# Approach\\n\\n```\\nlets have the index of all the ones in a list : ones\\n\\nexample 1:\\nsay we have: [0,1,0,0,1]\\nso, ones = [1, 4]\\n\\n4 - 1 = 3 = # ways to split the array\\n\\n01, 001\\n010, 01\\n0100, 1\\n\\n\\n\\nexample 2:\\n[1,0,0,0,0,0,1,0,1]\\n\\nones = [0, 6, 8]\\n\\n6 - 0 = 6 = # ways to split first two subarrays\\n\\n1 - 000001\\n10 - 00001\\n100 - 0001\\n1000 - 001\\n10000 - 01\\n100000 - 1\\n\\n8 - 6 = 2 = # ways to split the last two subarrays\\n\\n1 - 01\\n10 - 1\\n\\nTherefore total ways to split all 3 subarrays = 6 * 2 = 12\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n\\n        mod = 10**9 + 7\\n        # base case, if we dont have 1\\n        if sum(nums) == 0:\\n            return 0\\n        \\n        # store the index of all the ones\\n        ones = [] \\n        for i, num in enumerate(nums):\\n            if num == 1:\\n                ones.append(i)\\n\\n        count = 1\\n        for i in range(1, len(ones)):\\n            # ways to split the subarrays\\n            count *= ones[i] - ones[i - 1]\\n            count %= mod\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nwe are going to have as many splits/subarrays as we have ones.\\n\\nex: \\n0, 1, 1, 0\\n01 - 10 \\n(splits = 2, ones = 2)\\n\\nex: \\n1, 1, 1\\n1 - 1 - 1 \\n(splits = 3, ones = 3)\\n\\nex: \\n0, 1, 0, 1, 1\\n01 - 01 - 1\\n010 - 1 - 1\\n(splits = 3, ones = 3)\\n```\n```\\nlets have the index of all the ones in a list : ones\\n\\nexample 1:\\nsay we have: [0,1,0,0,1]\\nso, ones = [1, 4]\\n\\n4 - 1 = 3 = # ways to split the array\\n\\n01, 001\\n010, 01\\n0100, 1\\n\\n\\n\\nexample 2:\\n[1,0,0,0,0,0,1,0,1]\\n\\nones = [0, 6, 8]\\n\\n6 - 0 = 6 = # ways to split first two subarrays\\n\\n1 - 000001\\n10 - 00001\\n100 - 0001\\n1000 - 001\\n10000 - 01\\n100000 - 1\\n\\n8 - 6 = 2 = # ways to split the last two subarrays\\n\\n1 - 01\\n10 - 1\\n\\nTherefore total ways to split all 3 subarrays = 6 * 2 = 12\\n\\n```\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n\\n        mod = 10**9 + 7\\n        # base case, if we dont have 1\\n        if sum(nums) == 0:\\n            return 0\\n        \\n        # store the index of all the ones\\n        ones = [] \\n        for i, num in enumerate(nums):\\n            if num == 1:\\n                ones.append(i)\\n\\n        count = 1\\n        for i in range(1, len(ones)):\\n            # ways to split the subarrays\\n            count *= ones[i] - ones[i - 1]\\n            count %= mod\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798379,
                "title": "python-simple-solution-with-string-split",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# 0001000\\n# 1 -> for each of these, there\\'s 3 possibilities\\n# 01\\n# 001\\n# 0001\\n\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if 1 not in nums:\\n            return 0\\n        segments = list(map(len, \"\".join(str(num) for num in nums).split(\\'1\\')))\\n        product = 1\\n        for i, segment in enumerate(segments):\\n            if i == 0 or i == len(segments) - 1:\\n                continue\\n            product *= segment + 1\\n        return product % (10 ** 9 + 7) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# 0001000\\n# 1 -> for each of these, there\\'s 3 possibilities\\n# 01\\n# 001\\n# 0001\\n\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if 1 not in nums:\\n            return 0\\n        segments = list(map(len, \"\".join(str(num) for num in nums).split(\\'1\\')))\\n        product = 1\\n        for i, segment in enumerate(segments):\\n            if i == 0 or i == len(segments) - 1:\\n                continue\\n            product *= segment + 1\\n        return product % (10 ** 9 + 7) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794809,
                "title": "counting-solution-beats-88-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        //vector<int> v;\\n        int l = 0;\\n        int r=  0;\\n        int sum = 0;\\n        int count = 0;\\n        long long mod = 1e9+7;\\n        vector<int> v;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]==1){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==0){\\n            return  0;\\n        }\\n        if(v.size()==1){\\n            return 1;\\n        }\\n        long long ans = 1;\\n        for(int i = 0; i<v.size()-1; i++){\\n            ans=(ans*(v[i+1]-v[i]))%mod;\\n        }\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        //vector<int> v;\\n        int l = 0;\\n        int r=  0;\\n        int sum = 0;\\n        int count = 0;\\n        long long mod = 1e9+7;\\n        vector<int> v;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]==1){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==0){\\n            return  0;\\n        }\\n        if(v.size()==1){\\n            return 1;\\n        }\\n        long long ans = 1;\\n        for(int i = 0; i<v.size()-1; i++){\\n            ans=(ans*(v[i+1]-v[i]))%mod;\\n        }\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789608,
                "title": "top-bottom-dp",
                "content": "# Approach\\nMain idea is to cut an array by segments and each of the segment has to contain ONLY single 1\\nif there are 3 ones it should be 3 segments\\n\\nWe use top-down DP on each DFS call we try 2 posibilities\\n1) Once we confident we have 1 in a subarray we can CUT it now\\n2) AND we can skip and cut it later\\nWe need to keep track of 1s in a sub array and we can have only single 1. In order to do this we have to pass additional flag in each dfs\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar numberOfGoodSubarraySplits = function(nums) {\\n    const allOnes=nums.reduce((acc,cur)=>acc+cur), MOD=Math.pow(10,9)+7;\\n    if(allOnes===0) return 0;\\n\\n    const dfs=(i,hasOne,ones,dp)=>{\\n      if(ones===0) return 1;\\n      if(i===nums.length) return 0;\\n      if(hasOne && nums[i]===1) return 0; // if we have two 1s this is invalid case\\n\\n      const key=`${i}_${ones}`;\\n      if(dp[key]) return dp[key];\\n      \\n      // we can cut only if we have 1 in a subarray so we extend a window till we find a 1  \\n      if(!hasOne) while(nums[i]===0){i++;}\\n      \\n      const cut = dfs(i+1,false,ones-1,dp); // cut now\\n\\n      // cut later if we confident there is a 1 in the next portion, e.g [0,1,0,0] once we cut at index 1 it does not meke any sence to skip a cut cause there is no 1s anymore\\n      const skip = ones>1?dfs(i+1,true,ones,dp):0; \\n      return dp[key]=(cut+skip)%MOD;\\n    }\\n\\n    return dfs(0,false,allOnes,{});\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar numberOfGoodSubarraySplits = function(nums) {\\n    const allOnes=nums.reduce((acc,cur)=>acc+cur), MOD=Math.pow(10,9)+7;\\n    if(allOnes===0) return 0;\\n\\n    const dfs=(i,hasOne,ones,dp)=>{\\n      if(ones===0) return 1;\\n      if(i===nums.length) return 0;\\n      if(hasOne && nums[i]===1) return 0; // if we have two 1s this is invalid case\\n\\n      const key=`${i}_${ones}`;\\n      if(dp[key]) return dp[key];\\n      \\n      // we can cut only if we have 1 in a subarray so we extend a window till we find a 1  \\n      if(!hasOne) while(nums[i]===0){i++;}\\n      \\n      const cut = dfs(i+1,false,ones-1,dp); // cut now\\n\\n      // cut later if we confident there is a 1 in the next portion, e.g [0,1,0,0] once we cut at index 1 it does not meke any sence to skip a cut cause there is no 1s anymore\\n      const skip = ones>1?dfs(i+1,true,ones,dp):0; \\n      return dp[key]=(cut+skip)%MOD;\\n    }\\n\\n    return dfs(0,false,allOnes,{});\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787971,
                "title": "simplest-6-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O( n )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int p=-1;\\n        long mul=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(p==-1&&nums[i]==1) p=i;\\n            else if(nums[i]==1){\\n                mul=mul*(i-p);\\n                p=i;\\n                mul=mul%1000000007;\\n            }\\n        }\\n        if(p==-1) return 0;\\n        return mul;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int p=-1;\\n        long mul=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(p==-1&&nums[i]==1) p=i;\\n            else if(nums[i]==1){\\n                mul=mul*(i-p);\\n                p=i;\\n                mul=mul%1000000007;\\n            }\\n        }\\n        if(p==-1) return 0;\\n        return mul;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786012,
                "title": "easy-understanding-cpp-solution-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod= 1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& arr) {\\n        \\n        \\n        int n=arr.size();\\n        \\n    \\n        int flag=0;\\n        long long prev=1;\\n        long long  total=1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(arr[i]==1)\\n            {\\n                flag=1;\\n                total=((total % mod)*(prev % mod)) % mod;\\n                prev=1;\\n                \\n            }\\n            else if((arr[i] == 0) && flag==1)\\n            {\\n                prev++;\\n            }\\n        }\\n        \\n        if(flag==0)\\n        {\\n            return 0;\\n        }\\n        return total;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int mod= 1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& arr) {\\n        \\n        \\n        int n=arr.size();\\n        \\n    \\n        int flag=0;\\n        long long prev=1;\\n        long long  total=1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(arr[i]==1)\\n            {\\n                flag=1;\\n                total=((total % mod)*(prev % mod)) % mod;\\n                prev=1;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3783715,
                "title": "easy-soln-sliding-window-easy-java-please-upvote",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD=1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int zeroes=0;\\n        int res=1;\\n        int i=0;\\n        boolean flag=false;\\n        while(i<nums.length&&nums[i]!=1) i++;\\n        for( ;i<nums.length;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n            }\\n            else{\\n                flag=true;\\n                res=(int)((long)res*(zeroes+1)%MOD) ;\\n                zeroes=0;\\n            }\\n        }\\n        return flag?res:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    int MOD=1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int zeroes=0;\\n        int res=1;\\n        int i=0;\\n        boolean flag=false;\\n        while(i<nums.length&&nums[i]!=1) i++;\\n        for( ;i<nums.length;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n            }\\n            else{\\n                flag=true;\\n                res=(int)((long)res*(zeroes+1)%MOD) ;\\n                zeroes=0;\\n            }\\n        }\\n        return flag?res:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783058,
                "title": "easy-to-understand-python-solution-t-s-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(1, len(nums)+1):\\n            if nums[i - 1] == 1:\\n                if res == 0:\\n                    prev = i\\n                    res = 1\\n                else:\\n                    res = res * (i - prev)\\n                    prev = i\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(1, len(nums)+1):\\n            if nums[i - 1] == 1:\\n                if res == 0:\\n                    prev = i\\n                    res = 1\\n                else:\\n                    res = res * (i - prev)\\n                    prev = i\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742043,
                "title": "straight-forward-100-fast-just-count-upcoming-zeroes",
                "content": "```\\nclass Solution {\\nint mod = 1e9+7;\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long count = 1, curr_count = 0;\\n        bool flag = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(flag){\\n                if(nums[i]==0){\\n                    curr_count++;\\n                }\\n                else{\\n                    count = (((curr_count+1)%mod)*(count%mod))%mod;\\n                    curr_count = 0;\\n                }\\n            }\\n            else if(nums[i]==1){\\n                flag = 1;\\n            }\\n        }\\n        if(flag==0) return 0;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint mod = 1e9+7;\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long count = 1, curr_count = 0;\\n        bool flag = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(flag){\\n                if(nums[i]==0){\\n                    curr_count++;\\n                }\\n                else{\\n                    count = (((curr_count+1)%mod)*(count%mod))%mod;\\n                    curr_count = 0;\\n                }\\n            }\\n            else if(nums[i]==1){\\n                flag = 1;\\n            }\\n        }\\n        if(flag==0) return 0;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737565,
                "title": "2750-ways-to-split-array-into-good-subarrays-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfGoodSubarraySplits = function(nums) {\\n    let ind = []; let res = 1; const mod = 1e9 + 7;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i]===1){\\n            ind.push(i)\\n        }\\n    }\\n\\n    for(let i=1; i<ind.length; i++){\\n        res *= (ind[i]-ind[i-1])\\n        res %= mod\\n    }\\n\\n    return ind.length?res:0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfGoodSubarraySplits = function(nums) {\\n    let ind = []; let res = 1; const mod = 1e9 + 7;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i]===1){\\n            ind.push(i)\\n        }\\n    }\\n\\n    for(let i=1; i<ind.length; i++){\\n        res *= (ind[i]-ind[i-1])\\n        res %= mod\\n    }\\n\\n    return ind.length?res:0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732649,
                "title": "simple-python-solution-with-explanation-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we take a closer look at the examples and try out a few scenarios by ourselves we can figure out that the result is going to be the product of the distance between the ones.\\n\\nLets take an example\\n\\n1 0 0 0 1\\nWe can split it in the following 4 ways\\n1000 1\\n100 01\\n10 001\\n1 0001\\n\\nNow if we add 01 to the end of the array\\n1 0 0 0 1 0 1\\nWe can split it in the following 8 ways\\n1000 10 1\\n100 010 1\\n10 0010 1\\n1 00010 1\\n\\n1000 1 01\\n100 01 01\\n10 001 01\\n1 0001 01\\n\\nFrom the above example we can see that the total number of ways is given by (dist between idx 0 and 4) * (dist between idx 4 and 6) = 4*2 = 8\\n\\nPS: This is my first ever solution submission.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numberOfGoodSubarraySplits(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mod = 10**9 + 7\\n        prev = -1\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                if prev == -1:\\n                    res = 1\\n                    prev = i\\n                else:\\n                    res *= (i - prev)\\n                    res %= mod\\n                    prev = i\\n        return res%mod\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfGoodSubarraySplits(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mod = 10**9 + 7\\n        prev = -1\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                if prev == -1:\\n                    res = 1\\n                    prev = i\\n                else:\\n                    res *= (i - prev)\\n                    res %= mod\\n                    prev = i\\n        return res%mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724356,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int last = -1, mod = 1e9 + 7;\\n        long ans = 1; \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i]) {\\n                if(last != -1) ans = (ans * (i - last) % mod) % mod;\\n                last = i;\\n            }   \\n        }\\n        return last == -1? 0: ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int last = -1, mod = 1e9 + 7;\\n        long ans = 1; \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i]) {\\n                if(last != -1) ans = (ans * (i - last) % mod) % mod;\\n                last = i;\\n            }   \\n        }\\n        return last == -1? 0: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723797,
                "title": "cpp-count-no-of-zeroes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int i =0;\\n        long ans = 1;\\n        int count=0;\\n        int mode=1e9+7;\\n        while(i<n && nums[i]!=1) i++;\\n        if(i==n)\\n            return 0;\\n\\n        while(i<n){\\n            if(nums[i]==0)\\n                count++;\\n            else{\\n                ans=(ans*(count+1))%mode;\\n                count=0;\\n            }\\n            i++;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int i =0;\\n        long ans = 1;\\n        int count=0;\\n        int mode=1e9+7;\\n        while(i<n && nums[i]!=1) i++;\\n        if(i==n)\\n            return 0;\\n\\n        while(i<n){\\n            if(nums[i]==0)\\n                count++;\\n            else{\\n                ans=(ans*(count+1))%mode;\\n                count=0;\\n            }\\n            i++;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720886,
                "title": "python-explained-approach-o-n",
                "content": "# Intuition\\nJust count the number of ways between ones and multiply them.\\n\\n# Approach\\nThere are at least X ways to split nums where X = the number of ones in nums. But then you have zeros between them. To solve this you need first to count the ways of splitting a subarray as this one 1 0 0 .. 0 1. You will find out below that the number of ways of splitting that is the number of zeros + 1. Then you just multiply for every way and get the result.\\nEG:\\n \\n    1 0 0 0 1 - 3 zeros - 4 ways\\n    1 0 0 0 | 1\\n    1 0 0 | 0 1\\n    1 0 | 0 0 1\\n    1 | 0 0 0 1\\n    \\n    1 0 0 0 0 1 - 4 zeros - 5 ways\\n    1 0 0 0 0 | 1\\n    1 0 0 0 | 0 1\\n    1 0 0 | 0 0 1\\n    1 0 | 0 0 0 1\\n    1 | 0 0 0 0 1\\n    => n+1 where n = number of zeros between the ones\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        prev, ones, ans = -1, 0, 1\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                ones += 1\\n                if ones > 1:  # we have at least 2 so we can count the ways of splitting \\n                    zeros = i-prev-1\\n                    ans *= zeros + 1\\n                prev = i  \\n        if ones == 0 or ones == 1:  \\n            return ones\\n        return ans % 1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        prev, ones, ans = -1, 0, 1\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                ones += 1\\n                if ones > 1:  # we have at least 2 so we can count the ways of splitting \\n                    zeros = i-prev-1\\n                    ans *= zeros + 1\\n                prev = i  \\n        if ones == 0 or ones == 1:  \\n            return ones\\n        return ans % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720169,
                "title": "c-simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        long long m = 1000000007; \\n        int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long count1 = 0; \\n        long count0 = 0;  \\n        long ans = 0;\\n        int n= nums.size();\\n        for (int i=0;i<n;i++) {\\n            if (nums[i]==0){\\n                count0++;\\n            }\\n            else {\\n                count1++;\\n                if(count1==1){\\n                    ans = 1;\\n                }\\n                else {\\n                    ans = (ans*(count0+1))%m;\\n                }\\n                count0 = 0; \\n            }\\n           \\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        long long m = 1000000007; \\n        int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long count1 = 0; \\n        long count0 = 0;  \\n        long ans = 0;\\n        int n= nums.size();\\n        for (int i=0;i<n;i++) {\\n            if (nums[i]==0){\\n                count0++;\\n            }\\n            else {\\n                count1++;\\n                if(count1==1){\\n                    ans = 1;\\n                }\\n                else {\\n                    ans = (ans*(count0+1))%m;\\n                }\\n                count0 = 0; \\n            }\\n           \\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715921,
                "title": "dart-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  int numberOfGoodSubarraySplits(List<int> nums) {\\n    int ans = 1, m = 1000000007, count = 0, i = 0;\\n\\n    while (i < nums.length && nums[i] == 0) {\\n      i++;\\n    }\\n\\n    if (i >= nums.length) {\\n      return 0;\\n    }\\n\\n    while (i < nums.length) {\\n      if (nums[i] == 1) {\\n        ans = (ans * (count + 1)) % m;\\n        count = 0;\\n      } else {\\n        count++;\\n      }\\n      i++;\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int numberOfGoodSubarraySplits(List<int> nums) {\\n    int ans = 1, m = 1000000007, count = 0, i = 0;\\n\\n    while (i < nums.length && nums[i] == 0) {\\n      i++;\\n    }\\n\\n    if (i >= nums.length) {\\n      return 0;\\n    }\\n\\n    while (i < nums.length) {\\n      if (nums[i] == 1) {\\n        ans = (ans * (count + 1)) % m;\\n        count = 0;\\n      } else {\\n        count++;\\n      }\\n      i++;\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715294,
                "title": "c-simple-concise-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int res = 1, n = nums.size(), lastIdx = 0;\\n        while (lastIdx < n && nums[lastIdx] == 0) ++ lastIdx;\\n        if (lastIdx == n) return 0;\\n        for (int i = lastIdx + 1; i < n; ++ i) {\\n            if (nums[i] == 1) {\\n                res = (res * 1LL * (i - lastIdx)) % mod;\\n                lastIdx = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int res = 1, n = nums.size(), lastIdx = 0;\\n        while (lastIdx < n && nums[lastIdx] == 0) ++ lastIdx;\\n        if (lastIdx == n) return 0;\\n        for (int i = lastIdx + 1; i < n; ++ i) {\\n            if (nums[i] == 1) {\\n                res = (res * 1LL * (i - lastIdx)) % mod;\\n                lastIdx = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715067,
                "title": "java-easy-and-clean-code-with-intuition",
                "content": "# Intuition\\nThink about using a knife to cut the array. Once you hit a \"one\", you can cut right between this \"one\" and the next element. If there are some zeros after this \"one\", alternatively you can cut the array between these zeros, until you hit the next \"one\", so you know how many ways you have for this single cut. The product of all the cuts mod 1000000007 is the final answer.\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int modulo = 1000000007;\\n        long count = 0;\\n        int prevOne = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                if (prevOne == -1) {\\n                    count = 1;\\n                } else {\\n                    count = ((count * (i - prevOne)) % modulo);\\n                }\\n                prevOne = i;\\n            }\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int modulo = 1000000007;\\n        long count = 0;\\n        int prevOne = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                if (prevOne == -1) {\\n                    count = 1;\\n                } else {\\n                    count = ((count * (i - prevOne)) % modulo);\\n                }\\n                prevOne = i;\\n            }\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707988,
                "title": "math-combinations-java",
                "content": "# Intuition\\nThe intuition is that you are trying all different combinations of splitting numbers into groups containing at least one occurence of 1. Suppose you formed 3 groups as in this example: [1,0,0,0,0,0,1,0,1] - now the last group can be either [0,1] or [1], now if you fix let\\'s say [1], then you need to try all the different combinations on group1 and group2 - like group1 [1] group2 [0,0,0,0,0,1,0], or group1 [1,0] group2 [0,0,0,0,1,0] - you got the point. Now you should be able to see the clear emergence of trying all different combinations here.\\n\\n# Approach\\nJust count occurences of zeros and keep two pointers approach, where left points to previous occurence of 1, and right is current occurence of 1. Left = k, right = i\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int k = -1;\\n        final int MOD = 100_000_000_7;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                k = i;\\n                break;\\n            }\\n        }\\n        if (k == -1) return 0;\\n        \\n        long answer = 1;\\n        for (int i = k+1; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                answer *= (i - k);\\n                k = i;\\n                answer %= MOD;\\n            }\\n        }\\n        return (int)answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int k = -1;\\n        final int MOD = 100_000_000_7;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                k = i;\\n                break;\\n            }\\n        }\\n        if (k == -1) return 0;\\n        \\n        long answer = 1;\\n        for (int i = k+1; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                answer *= (i - k);\\n                k = i;\\n                answer %= MOD;\\n            }\\n        }\\n        return (int)answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707857,
                "title": "c-faster-than-75-o-n",
                "content": "# Intuition\\nJust go through array.\\n\\n# Approach\\nGo through array and calculate the lengths of subarrays with all 0s:\\n```\\nfor (int i = index0 + 1; i <= index1; i++)\\n{\\n    if (nums[i] == 0)\\n    {\\n        len++;\\n    }\\n    else\\n    {\\n        rs *= (len + 1);\\n        rs %= 1_000_000_007;\\n        len = 0;\\n    }\\n}\\n```\\nwhere index0 and index1 are the indexes if the 1st and the last 1s in array nums.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumberOfGoodSubarraySplits(int[] nums) {\\n        var rs = 1L;\\n        var index0 = 0;\\n        while (nums[index0] == 0)\\n        {\\n            index0++;\\n            if (index0 >= nums.Length) return 0;\\n        }\\n        var index1 = nums.Length - 1;\\n        while (nums[index1] == 0)\\n        {\\n            index1--;\\n        }\\n        var len = 0;\\n        for (int i = index0 + 1; i <= index1; i++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                rs *= (len + 1);\\n                rs %= 1_000_000_007;\\n                len = 0;\\n            }\\n        }\\n        return (int)rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\nfor (int i = index0 + 1; i <= index1; i++)\\n{\\n    if (nums[i] == 0)\\n    {\\n        len++;\\n    }\\n    else\\n    {\\n        rs *= (len + 1);\\n        rs %= 1_000_000_007;\\n        len = 0;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int NumberOfGoodSubarraySplits(int[] nums) {\\n        var rs = 1L;\\n        var index0 = 0;\\n        while (nums[index0] == 0)\\n        {\\n            index0++;\\n            if (index0 >= nums.Length) return 0;\\n        }\\n        var index1 = nums.Length - 1;\\n        while (nums[index1] == 0)\\n        {\\n            index1--;\\n        }\\n        var len = 0;\\n        for (int i = index0 + 1; i <= index1; i++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                rs *= (len + 1);\\n                rs %= 1_000_000_007;\\n                len = 0;\\n            }\\n        }\\n        return (int)rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705456,
                "title": "small-sliding-window-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1000000007;\\n int find(vector<int>&nums){\\n    \\n     long long i=0, j=0,count=1,k=0,first=-1;\\n      while(j<nums.size()){\\n         if(nums[j]==1)k++;\\n         if(nums[j]==1&&k==1)first=j;\\n         if(k>1){\\n             count=((count%mod)*((j-first)%mod))%mod;\\n             first=j;\\n             k--;\\n         }\\n         j++; }\\n    return first==-1?0:count;\\n }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        return find(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1000000007;\\n int find(vector<int>&nums){\\n    \\n     long long i=0, j=0,count=1,k=0,first=-1;\\n      while(j<nums.size()){\\n         if(nums[j]==1)k++;\\n         if(nums[j]==1&&k==1)first=j;\\n         if(k>1){\\n             count=((count%mod)*((j-first)%mod))%mod;\\n             first=j;\\n             k--;\\n         }\\n         j++; }\\n    return first==-1?0:count;\\n }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        return find(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700395,
                "title": "scala-foldleft-or-recursion",
                "content": "# FoldLeft code\\n```\\ndef numberOfGoodSubarraySplits(nums: Array[Int]): Int = {\\n  val arr = nums.dropWhile(_ == 0)\\n  if (arr.isEmpty) 0\\n  else\\n    arr.foldLeft((1L, 0)) { case ((cnt, zeros), num) =>\\n      if (num == 0) (cnt, zeros + 1)\\n      else ((cnt * (zeros + 1)) % 1000000007, 0)\\n    }._1.toInt\\n}\\n```\\n\\n# Recursion code\\n```\\ndef numberOfGoodSubarraySplits(nums: Array[Int]): Int = {\\n  val list = nums.toList.dropWhile(_ == 0)\\n  if (list.isEmpty) 0 else go(list, 1, 0)\\n}\\n\\ndef go(nums: List[Int], cnt: Long, zeros: Int): Int =\\n  nums match {\\n    case Nil => cnt.toInt\\n    case 0 :: tail => go(tail, cnt, zeros + 1)\\n    case _ :: tail => go(tail, (cnt * (zeros + 1)) % 1000000007, 0)\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef numberOfGoodSubarraySplits(nums: Array[Int]): Int = {\\n  val arr = nums.dropWhile(_ == 0)\\n  if (arr.isEmpty) 0\\n  else\\n    arr.foldLeft((1L, 0)) { case ((cnt, zeros), num) =>\\n      if (num == 0) (cnt, zeros + 1)\\n      else ((cnt * (zeros + 1)) % 1000000007, 0)\\n    }._1.toInt\\n}\\n```\n```\\ndef numberOfGoodSubarraySplits(nums: Array[Int]): Int = {\\n  val list = nums.toList.dropWhile(_ == 0)\\n  if (list.isEmpty) 0 else go(list, 1, 0)\\n}\\n\\ndef go(nums: List[Int], cnt: Long, zeros: Int): Int =\\n  nums match {\\n    case Nil => cnt.toInt\\n    case 0 :: tail => go(tail, cnt, zeros + 1)\\n    case _ :: tail => go(tail, (cnt * (zeros + 1)) % 1000000007, 0)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3699502,
                "title": "concise-python-o-n-time-o-1-space-with-explanation",
                "content": "# Intuition\\nWe look at how many ways we can have for the last segment. We can see that the last segment needs to have a 1. So we have to go from right to left to find a 1 first. Then depending on how many 0s we see until we see the next 1, that\\'d be our number of ways to make the last segment (minus one). For example, if we have an input like this: 001001000100. Then there\\'re 4 ways to have last segment: 100, 0100, 00100, 000100.\\n\\n# Approach\\nIf I want to find how many ways to split the string from index 0 to index i, I have 2 cases:\\n\\n1. The current digit at index i is 0: Then the result should be the same as the previous result. Because I know this 0 belongs to the last segment. So I just need to know how you split the string from 0 to index i-1, then add this 0 to the last segment.\\n\\n2. The current digit at index i is 1. Then I wanna ask how many 0\\'s from the current index to the left to the next digit 1. Because then I can use recursion formula here. Let\\'s say there\\'re k number of 0\\'s from the current index to the next one (right to left direction). Then my number of ways to split the string from index 0 to index i is: f(i) = f(i-k-1)*(k+1). All I need to know is how many 0\\'s I\\'ve seen since the last digit 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        ans = 0\\n        zeros = 0 # Number of 0\\'s seen so far since the last 1\\n        sawOne = False # This is to handle edge case: only 1 of 1\\'s\\n        for num in nums:\\n            if num == 0:\\n                zeros += 1\\n            else:\\n                if sawOne:\\n                    ans = (zeros + 1)*ans % (10**9+7)\\n                else:\\n                    sawOne = True\\n                    ans = 1\\n                zeros = 0\\n        return ans\\n```\\n\\nBonus: After viewing others\\' solutions, I really like one solution from @rock. It\\'s the same idea but it\\'s written in a more clever way. I rewrote it a litle bit to make it more concise.\\n\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        ans, prev = 0, -1\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                ans = 1 if ans == 0 else (i-prev)*ans % (10**9+7)\\n                prev = i\\n        return ans\\n```\\n\\n@rock\\'s solution is here: https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/solutions/3679119/java-python-3-sliding-window-w-analysis/\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        ans = 0\\n        zeros = 0 # Number of 0\\'s seen so far since the last 1\\n        sawOne = False # This is to handle edge case: only 1 of 1\\'s\\n        for num in nums:\\n            if num == 0:\\n                zeros += 1\\n            else:\\n                if sawOne:\\n                    ans = (zeros + 1)*ans % (10**9+7)\\n                else:\\n                    sawOne = True\\n                    ans = 1\\n                zeros = 0\\n        return ans\\n```\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        ans, prev = 0, -1\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                ans = 1 if ans == 0 else (i-prev)*ans % (10**9+7)\\n                prev = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698825,
                "title": "top-down-dp-search-from-i-bool",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        m = len(nums)\\n        \\n        @cache\\n        def dp(i, include):\\n            if i == m:\\n\\n                return include\\n            \\n            if include:\\n                if nums[i]==1:\\n                    return dp(i+1, 1)\\n                else:\\n                    return (dp(i+1, 0) + dp(i+1, 1))%mod\\n            else:\\n                return dp(i+1, nums[i])\\n        return dp(0,0)% mod\\n                    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        m = len(nums)\\n        \\n        @cache\\n        def dp(i, include):\\n            if i == m:\\n\\n                return include\\n            \\n            if include:\\n                if nums[i]==1:\\n                    return dp(i+1, 1)\\n                else:\\n                    return (dp(i+1, 0) + dp(i+1, 1))%mod\\n            else:\\n                return dp(i+1, nums[i])\\n        return dp(0,0)% mod\\n                    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698791,
                "title": "simple-recursion-without-return-recursion-with-return-memoization",
                "content": "\\nWithout return\\n\\n```\\nclass Solution {\\n     int count = 0;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        solve(nums, 0, 0);\\n        return count;\\n    }\\n    \\n    \\n    private void solve(int[] nums, int pos, int sum) {\\n         if(pos==nums.length && sum == 1){\\n            count++;\\n            return;\\n         }\\n        if(pos>=nums.length) return;\\n        if(sum == 1){\\n            solve(nums, pos+1, nums[pos]);\\n            if(nums[pos]==0){\\n                solve(nums, pos+1, sum+nums[pos]);\\n            }\\n        }else {\\n            solve(nums, pos+1, sum+nums[pos]);\\n        }\\n     }\\n}\\n```\\n\\nWith return\\n\\n```\\nclass Solution {\\n     int count = 0;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        return solve(nums, 0, 0);\\n    }\\n    \\n    \\n    private int solve(int[] nums, int pos, int sum) {\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n         if(pos==nums.length && sum == 1){\\n            return 1;\\n         }\\n        if(pos>=nums.length) return 0;\\n        if(sum == 1){\\n           a = solve(nums, pos+1, nums[pos]);\\n            if(nums[pos]==0){\\n              b =  solve(nums, pos+1, sum+nums[pos]);\\n            }\\n        }else {\\n           c = solve(nums, pos+1, sum+nums[pos]);\\n        }\\n        return (a+b+c);\\n     }\\n}\\n```\\n\\nWith memoization\\n\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int dp[][] = new int[nums.length+1][2];\\n        for (int d[] : dp) {\\n            Arrays.fill(d, -1);\\n        }\\n       return solve(nums, 0, 0, dp);\\n    }\\n    \\n     private int solve(int[] nums, int pos, int sum, int dp[][]) {\\n        int a = 0;\\n        int c = 0;\\n        if(sum>1) return 0;\\n        if (pos == nums.length && sum == 1) {\\n            return 1;\\n        }\\n        if (dp[pos][sum] != -1) return dp[pos][sum];\\n        if (pos >= nums.length) return 0;\\n        if (sum == 1) {\\n            dp[pos][sum] =  a = solve(nums, pos + 1, nums[pos], dp);\\n        }\\n        dp[pos][sum] = c = solve(nums, pos + 1, sum + nums[pos], dp);\\n        return dp[pos][sum] = (a + c) % 1000000007;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     int count = 0;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        solve(nums, 0, 0);\\n        return count;\\n    }\\n    \\n    \\n    private void solve(int[] nums, int pos, int sum) {\\n         if(pos==nums.length && sum == 1){\\n            count++;\\n            return;\\n         }\\n        if(pos>=nums.length) return;\\n        if(sum == 1){\\n            solve(nums, pos+1, nums[pos]);\\n            if(nums[pos]==0){\\n                solve(nums, pos+1, sum+nums[pos]);\\n            }\\n        }else {\\n            solve(nums, pos+1, sum+nums[pos]);\\n        }\\n     }\\n}\\n```\n```\\nclass Solution {\\n     int count = 0;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        return solve(nums, 0, 0);\\n    }\\n    \\n    \\n    private int solve(int[] nums, int pos, int sum) {\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n         if(pos==nums.length && sum == 1){\\n            return 1;\\n         }\\n        if(pos>=nums.length) return 0;\\n        if(sum == 1){\\n           a = solve(nums, pos+1, nums[pos]);\\n            if(nums[pos]==0){\\n              b =  solve(nums, pos+1, sum+nums[pos]);\\n            }\\n        }else {\\n           c = solve(nums, pos+1, sum+nums[pos]);\\n        }\\n        return (a+b+c);\\n     }\\n}\\n```\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int dp[][] = new int[nums.length+1][2];\\n        for (int d[] : dp) {\\n            Arrays.fill(d, -1);\\n        }\\n       return solve(nums, 0, 0, dp);\\n    }\\n    \\n     private int solve(int[] nums, int pos, int sum, int dp[][]) {\\n        int a = 0;\\n        int c = 0;\\n        if(sum>1) return 0;\\n        if (pos == nums.length && sum == 1) {\\n            return 1;\\n        }\\n        if (dp[pos][sum] != -1) return dp[pos][sum];\\n        if (pos >= nums.length) return 0;\\n        if (sum == 1) {\\n            dp[pos][sum] =  a = solve(nums, pos + 1, nums[pos], dp);\\n        }\\n        dp[pos][sum] = c = solve(nums, pos + 1, sum + nums[pos], dp);\\n        return dp[pos][sum] = (a + c) % 1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698339,
                "title": "a-few-solutions",
                "content": "Use the rule-of-product to count the total `t` subarray splits, ie. for each subarray of consecutive zeros of length `n` between ones, multiply `t` by `n + 1`.\\n\\nNote: we skip the leading & trailing zeros\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var numberOfGoodSubarraySplits = { A: IntArray -> if (A.sum()!! == 0) 0 else A.joinToString(\"\").trim(\\'0\\').split(\\'1\\').map{ it.length }.filter{ 0 < it }.fold(1L){ t, n -> t * (n + 1) % (1e9.toInt() + 7) }.toInt() }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numberOfGoodSubarraySplits = A => !_.sum(A) ? 0 : _.trim(A.join(\\'\\'), \\'0\\').split(\\'1\\').map(s => s.length).map(n => n).reduce((t, n) => t * (n + 1) % Number(1e9 + 7), 1);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, A: List[int]) -> int:\\n        Z = [len(s) for s in \\'\\'.join(str(x) for x in A).strip(\\'0\\').split(\\'1\\') if len(s)]\\n        return 0 if not len(S) else reduce(lambda t, n: (t * (n + 1)) % int(1e9 + 7), Z, 1)\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn number_of_good_subarray_splits(A: Vec<i32>) -> i32 {\\n        if A.iter().all(|x| *x == 0) {\\n            return 0;\\n        }\\n        let S = A.into_iter().map(|x| x.to_string()).collect::<String>();\\n        S.trim_matches(\\'0\\').split(\\'1\\').map(|s| s.len()).filter(|n| 0 < *n).fold(1usize, |t, n| t * (n + 1) % (1e9 as usize + 7)) as i32\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    int numberOfGoodSubarraySplits(VI& A, LL t = 1, int n = 0) {\\n        if (all_of(A.begin(), A.end(), [](auto x) { return !x; }))\\n            return 0;\\n        auto [i, j] = make_pair(0, A.size() - 1);\\n        while (i < j && !A[i]) ++i;\\n        while (i < j && !A[j]) --j;\\n        for (auto k{ i }; k <= j; ++k)\\n            if (A[k])\\n                t = t * (n + 1) % int(1e9 + 7), n = 0;\\n            else\\n                ++n;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var numberOfGoodSubarraySplits = { A: IntArray -> if (A.sum()!! == 0) 0 else A.joinToString(\"\").trim(\\'0\\').split(\\'1\\').map{ it.length }.filter{ 0 < it }.fold(1L){ t, n -> t * (n + 1) % (1e9.toInt() + 7) }.toInt() }\\n}\\n```\n```\\nlet numberOfGoodSubarraySplits = A => !_.sum(A) ? 0 : _.trim(A.join(\\'\\'), \\'0\\').split(\\'1\\').map(s => s.length).map(n => n).reduce((t, n) => t * (n + 1) % Number(1e9 + 7), 1);\\n```\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, A: List[int]) -> int:\\n        Z = [len(s) for s in \\'\\'.join(str(x) for x in A).strip(\\'0\\').split(\\'1\\') if len(s)]\\n        return 0 if not len(S) else reduce(lambda t, n: (t * (n + 1)) % int(1e9 + 7), Z, 1)\\n```\n```\\nimpl Solution {\\n    pub fn number_of_good_subarray_splits(A: Vec<i32>) -> i32 {\\n        if A.iter().all(|x| *x == 0) {\\n            return 0;\\n        }\\n        let S = A.into_iter().map(|x| x.to_string()).collect::<String>();\\n        S.trim_matches(\\'0\\').split(\\'1\\').map(|s| s.len()).filter(|n| 0 < *n).fold(1usize, |t, n| t * (n + 1) % (1e9 as usize + 7)) as i32\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    int numberOfGoodSubarraySplits(VI& A, LL t = 1, int n = 0) {\\n        if (all_of(A.begin(), A.end(), [](auto x) { return !x; }))\\n            return 0;\\n        auto [i, j] = make_pair(0, A.size() - 1);\\n        while (i < j && !A[i]) ++i;\\n        while (i < j && !A[j]) --j;\\n        for (auto k{ i }; k <= j; ++k)\\n            if (A[k])\\n                t = t * (n + 1) % int(1e9 + 7), n = 0;\\n            else\\n                ++n;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697259,
                "title": "python-simple-solution-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        \\n        \\n        \\n        n=len(nums)\\n        l1=[]\\n        for i in range(n):\\n            if nums[i]==1:\\n                l1.append(i)\\n        li_diff=[]\\n        if len(l1)==1:\\n            return 1\\n        if len(l1)==0:\\n            return 0\\n        for i in range(1,len(l1)):\\n            li_diff.append(l1[i]-l1[i-1]) \\n        if len(li_diff)==1:\\n            return li_diff[0]\\n        \\n        res=1\\n        for v in li_diff:\\n            res=res*v\\n        return res%((10**9)+7)\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        \\n        \\n        \\n        n=len(nums)\\n        l1=[]\\n        for i in range(n):\\n            if nums[i]==1:\\n                l1.append(i)\\n        li_diff=[]\\n        if len(l1)==1:\\n            return 1\\n        if len(l1)==0:\\n            return 0\\n        for i in range(1,len(l1)):\\n            li_diff.append(l1[i]-l1[i-1]) \\n        if len(li_diff)==1:\\n            return li_diff[0]\\n        \\n        res=1\\n        for v in li_diff:\\n            res=res*v\\n        return res%((10**9)+7)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697253,
                "title": "c-count-zeroes",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int modulo = 1000000007;\\n        long ans =1;\\n        int lastOnePos=-1;\\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i]==1)\\n            {\\n                if (lastOnePos!=-1) ans = (ans*(i-lastOnePos))%modulo;\\n                lastOnePos = i;\\n            }\\n        }\\n        return lastOnePos!=-1?static_cast<int>(ans):0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int modulo = 1000000007;\\n        long ans =1;\\n        int lastOnePos=-1;\\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i]==1)\\n            {\\n                if (lastOnePos!=-1) ans = (ans*(i-lastOnePos))%modulo;\\n                lastOnePos = i;\\n            }\\n        }\\n        return lastOnePos!=-1?static_cast<int>(ans):0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695798,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply just after the 1st 1 count zeros between two 1 till the last 1 and multiply each count+1 with previous ans which is initialized by 1 and updated continously.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n#include<cmath>\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        bool istrue=false;\\n        int ans=0,count=1;\\n        int mod=1e9+7;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(istrue==true&&nums[i]==1)\\n            {\\n                ans=(((long)ans)*count)%mod;\\n                count=1;\\n            }\\n            else if(istrue==true&&nums[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(nums[i]==1)\\n            {\\n                istrue=true;\\n                ans=1;\\n            }\\n          \\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<cmath>\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        bool istrue=false;\\n        int ans=0,count=1;\\n        int mod=1e9+7;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(istrue==true&&nums[i]==1)\\n            {\\n                ans=(((long)ans)*count)%mod;\\n                count=1;\\n            }\\n            else if(istrue==true&&nums[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(nums[i]==1)\\n            {\\n                istrue=true;\\n                ans=1;\\n            }\\n          \\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3695611,
                "title": "c-o-n-time-easy-to-understand",
                "content": "# Intuition\\nC++ || O(n) time || Easy to Understand\\n\\n# Approach\\nStoring the Indices of each 1\\'s in new vector container and multiplying the corresponding indices gives the count of ways.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> store;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(nums[i]==1)\\n                store.push_back(i);\\n        }\\n        \\n        if(store.size()==0)\\n            return 0;\\n        \\n        long long int cnt=1;\\n        int mod = 1e9+7; \\n        for(int i=1; i<store.size(); i++) {\\n            \\n            cnt = cnt%mod*(store[i] - store[i-1])%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> store;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(nums[i]==1)\\n                store.push_back(i);\\n        }\\n        \\n        if(store.size()==0)\\n            return 0;\\n        \\n        long long int cnt=1;\\n        int mod = 1e9+7; \\n        for(int i=1; i<store.size(); i++) {\\n            \\n            cnt = cnt%mod*(store[i] - store[i-1])%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695610,
                "title": "c-o-n-time-easy-to-understand",
                "content": "# Intuition\\nC++ || O(n) time || Easy to Understand\\n\\n# Approach\\nStoring the Indices of each 1\\'s in new vector container and multiplying the corresponding indices gives the count of ways.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> store;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(nums[i]==1)\\n                store.push_back(i);\\n        }\\n        \\n        if(store.size()==0)\\n            return 0;\\n        \\n        long long int cnt=1;\\n        int mod = 1e9+7; \\n        for(int i=1; i<store.size(); i++) {\\n            \\n            cnt = cnt%mod*(store[i] - store[i-1])%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> store;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(nums[i]==1)\\n                store.push_back(i);\\n        }\\n        \\n        if(store.size()==0)\\n            return 0;\\n        \\n        long long int cnt=1;\\n        int mod = 1e9+7; \\n        for(int i=1; i<store.size(); i++) {\\n            \\n            cnt = cnt%mod*(store[i] - store[i-1])%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694838,
                "title": "python3-clear-and-easily-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math \\n\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if not 1 in nums:\\n            return 0 \\n\\n        start_1 = nums.index(1)\\n        nums = nums[start_1:][::-1]\\n        end_1 = nums.index(1)\\n        nums = nums[end_1:]\\n        if len(nums) == 1:\\n            return 1 \\n\\n        temp = [i for i in range(len(nums)) if nums[i] == 1]\\n        return math.prod([temp[j] - temp[j-1] for j in range(1, len(temp))]) % (10**9 + 7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math \\n\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if not 1 in nums:\\n            return 0 \\n\\n        start_1 = nums.index(1)\\n        nums = nums[start_1:][::-1]\\n        end_1 = nums.index(1)\\n        nums = nums[end_1:]\\n        if len(nums) == 1:\\n            return 1 \\n\\n        temp = [i for i in range(len(nums)) if nums[i] == 1]\\n        return math.prod([temp[j] - temp[j-1] for j in range(1, len(temp))]) % (10**9 + 7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693405,
                "title": "optimized-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        List<Integer> indexes = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 1) indexes.add(i);\\n        }\\n        if(indexes.size() == 0) return 0;\\n        long ways = 1l;\\n        for(int i = 0; i < indexes.size() - 1; i++) {\\n            int space = indexes.get(i+1) - indexes.get(i);\\n            ways = (ways * space) % MOD;\\n        }\\n        return (int)ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        List<Integer> indexes = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 1) indexes.add(i);\\n        }\\n        if(indexes.size() == 0) return 0;\\n        long ways = 1l;\\n        for(int i = 0; i < indexes.size() - 1; i++) {\\n            int space = indexes.get(i+1) - indexes.get(i);\\n            ways = (ways * space) % MOD;\\n        }\\n        return (int)ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693337,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int mod= (int) 1e9 + 7;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int i;\\n        long count=1;\\n        for(i =0;i<nums.length;i++)\\n        {\\n            if(nums[i] == 1)\\n            break;\\n        }\\n        if(i== nums.length)\\n        return 0;\\n        for(int j = i+1;j<nums.length;j++)\\n        {\\n            if(nums[j]==1)\\n            {\\n                count = count * (j-i)%mod;\\n                i=j;\\n            }\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private static final int mod= (int) 1e9 + 7;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int i;\\n        long count=1;\\n        for(i =0;i<nums.length;i++)\\n        {\\n            if(nums[i] == 1)\\n            break;\\n        }\\n        if(i== nums.length)\\n        return 0;\\n        for(int j = i+1;j<nums.length;j++)\\n        {\\n            if(nums[j]==1)\\n            {\\n                count = count * (j-i)%mod;\\n                i=j;\\n            }\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691914,
                "title": "java-easy-math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int numberOfGoodSubarraySplits(int[] nums) {\\n    int i = 0, n = nums.length;\\n    for(; i != n && nums[i] == 0; ++i);\\n    if(i == n) return 0;\\n\\n    long ans = 1, z = 0;\\n    for(++i; i != n; ++i)\\n      if(nums[i] == 0) ++z;\\n      else if(z != 0) {ans = (ans* (z + 1)) % 1000000007; z = 0;}\\n\\n\\n    return (int)(ans % 1000000007);       \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int numberOfGoodSubarraySplits(int[] nums) {\\n    int i = 0, n = nums.length;\\n    for(; i != n && nums[i] == 0; ++i);\\n    if(i == n) return 0;\\n\\n    long ans = 1, z = 0;\\n    for(++i; i != n; ++i)\\n      if(nums[i] == 0) ++z;\\n      else if(z != 0) {ans = (ans* (z + 1)) % 1000000007; z = 0;}\\n\\n\\n    return (int)(ans % 1000000007);       \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691067,
                "title": "editoial-beginner-friendly-c-solution-explained-in-detail",
                "content": "# Intuition\\nThe code aims to find the number of good subarray splits in a given vector `nums`. A good subarray split is defined as a split such that the number of 1s on the left side of the split is equal to the number of 0s on the right side of the split.\\n\\n# Approach\\nThe code initializes `ans` and `p` variables to 0. The `ans` variable will store the final result, and `p` will keep track of the index of the first occurrence of a 1 in `nums`.\\n\\nIn the first for loop, the code iterates through `nums` to find the first occurrence of a 1. When a 1 is found at index `i`, `p` is set to `i`, `ans` is set to 1, and the loop is terminated using `break`. This means the first occurrence of a 1 is found, and `p` marks the starting point of the left side of a potential good subarray split.\\n\\nIn the second for loop, the code iterates through `nums` again. When a 1 is found at index `i` (excluding the first occurrence marked by `p`), the code calculates the difference `diff` between `i` and `p`, representing the number of elements between two occurrences of 1. `p` is updated to `i` for the next iteration. The code then updates `ans` by multiplying it with `diff` and performing modulo 1000000007 operation to ensure the result remains within the range.\\n\\nFinally, the code returns `ans` modulo 1000000007.\\n\\n# Example\\n\\nConsider the input vector `nums = {1, 0, 1, 0, 1, 1, 0, 1}`.\\n\\nStep 1: Initialization\\n- `ans = 0`\\n- `p = 0`\\n\\nStep 2: Finding the first occurrence of 1\\nThe first for loop iterates through `nums` to find the index of the first occurrence of 1.\\n- At index 0, the value is 1. Set `p = 0` and `ans = 1`.\\n- Break out of the loop since the first occurrence is found.\\n\\nPictorial representation:\\n```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4  5  6  7\\n         ^\\n         |\\n         p=0\\n```\\n\\nStep 3: Finding subsequent occurrences of 1\\nThe second for loop iterates through `nums` again, starting from index 0.\\n- At index 2, another occurrence of 1 is found.\\n  - Calculate `diff = 2 - 0 = 2`.\\n  - Update `p = 2` for the next iteration.\\n  - Update `ans = ((ans % 1000000007) * diff) % 1000000007 = (1 * 2) % 1000000007 = 2`.\\n\\nPictorial representation:\\n```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4   5  6  7\\n         ^        ^\\n         |        |\\n         p=0      p=2\\n```\\n\\n- At index 4, another occurrence of 1 is found.\\n  - Calculate `diff = 4 - 2 = 2`.\\n  - Update `p = 4` for the next iteration.\\n  - Update `ans = ((ans % 1000000007) * diff) % 1000000007 = (2 * 2) % 1000000007 = 4`.\\n\\nPictorial representation:\\n```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4   5  6  7\\n         ^              ^\\n         |              |\\n         p=0            p=4\\n```\\n\\n- At index 5, another occurrence of 1 is found.\\n  - Calculate `diff = 5 - 4 = 1`.\\n  - Update `p = 5` for the next iteration.\\n  - Update `ans = ((ans % 1000000007) * diff) % 1000000007 = (4 * 1) % 1000000007 = 4`.\\n\\nPictorial representation:\\n```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4   5  6  7\\n         ^                 ^\\n         |                 |\\n         p=0               p=5\\n```\\n\\n- At index 7, another occurrence of 1 is found.\\n  - Calculate `diff = 7 - 5 = 2`.\\n \\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the input vector `nums`. The code iterates through `nums` twice, which takes linear time.\\n- Space complexity: O(1). The code uses a constant amount of additional space regardless of the input size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        int ans=0;\\n        int p=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                p=i;\\n                ans=1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1 && i!=p)\\n            {\\n                int diff=i-p;\\n                p=i;\\n                ans = ((static_cast<long long>(ans) % 1000000007) * diff) % 1000000007;\\n            }\\n        }\\n        return ans%1000000007;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4  5  6  7\\n         ^\\n         |\\n         p=0\\n```\n```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4   5  6  7\\n         ^        ^\\n         |        |\\n         p=0      p=2\\n```\n```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4   5  6  7\\n         ^              ^\\n         |              |\\n         p=0            p=4\\n```\n```\\nnums:  1  0  1  0  1  1  0  1\\nindex: 0  1  2  3  4   5  6  7\\n         ^                 ^\\n         |                 |\\n         p=0               p=5\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        int ans=0;\\n        int p=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                p=i;\\n                ans=1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1 && i!=p)\\n            {\\n                int diff=i-p;\\n                p=i;\\n                ans = ((static_cast<long long>(ans) % 1000000007) * diff) % 1000000007;\\n            }\\n        }\\n        return ans%1000000007;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690740,
                "title": "python3-well-commented-solution-99-8-th-percentile-memory-89-th-percentil-runtime",
                "content": "\\n# Approach\\nIf there are m 1s in the array, there will be m subarrays, as each contains a single 1.  The partition is fully-specified by where to place the m-1 start/end indices of each subarray, since the first and last subarray have fixed bounds.\\n\\nWe use start indices so that we can place them whenever we come across a 1 and complete the problem in a single pass. Whenever we come across a 1 at index i, there are x starting points for the subarray containing it, where x = (i - last_i).\\n\\nSince we place these independently, we multiply them together to get our final result. An array with no 1s returns 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n), optimal as we can\\'t avoid scanning the entire input for 1s\\n\\n- Space complexity:\\nO(1), optimal\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        total = 1\\n        # Location of the last 1 we came across\\n        last_i = None\\n        # Place the start idx of each 1\\n        for i, val in enumerate(nums):\\n            if val == 1:\\n                if last_i is not None:\\n                    total = (total*(i - last_i)) % (10**9 + 7)\\n                last_i = i\\n        \\n        # Return 0 if no 1s were found\\n        return 0 if last_i is None else total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        total = 1\\n        # Location of the last 1 we came across\\n        last_i = None\\n        # Place the start idx of each 1\\n        for i, val in enumerate(nums):\\n            if val == 1:\\n                if last_i is not None:\\n                    total = (total*(i - last_i)) % (10**9 + 7)\\n                last_i = i\\n        \\n        # Return 0 if no 1s were found\\n        return 0 if last_i is None else total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690513,
                "title": "easy-c-basic-maths-o-n-solution",
                "content": "# Intuition\\nstore the indexes having occurence of 1 \\nall possible cases can be simply obtained by multiplying the difference in the index of 1\\'s\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(number of 1\\'s in nums): worst case having all 1\\'s: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        long long mod=1e9+7;\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                a.push_back(i);\\n            }\\n        }\\n        if(a.size()==0)return 0;\\n        \\n        for(int i=1;i<a.size();i++){\\n            ans=(ans*(a[i]-a[i-1])%mod)%mod;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans=1;\\n        long long mod=1e9+7;\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                a.push_back(i);\\n            }\\n        }\\n        if(a.size()==0)return 0;\\n        \\n        for(int i=1;i<a.size();i++){\\n            ans=(ans*(a[i]-a[i-1])%mod)%mod;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690234,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n\\n        int zeroes = 0;\\n        long res = 1;\\n        int mod = 1000000007;\\n\\n        int i=0;\\n        for(i=0;i<nums.length;i++)\\n            if(nums[i]==1)break;\\n        \\n        if(i==nums.length)return 0;\\n        \\n        boolean first = true;\\n        for(;i<nums.length;i++){\\n            if(nums[i]==1){\\n                if(first){\\n                   first = false; \\n                }else{\\n                    res = (res*(1+zeroes))%mod;\\n                    zeroes = 0;    \\n                }\\n            }else{\\n                ++zeroes;\\n            }\\n        }\\n        return (int)res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n\\n        int zeroes = 0;\\n        long res = 1;\\n        int mod = 1000000007;\\n\\n        int i=0;\\n        for(i=0;i<nums.length;i++)\\n            if(nums[i]==1)break;\\n        \\n        if(i==nums.length)return 0;\\n        \\n        boolean first = true;\\n        for(;i<nums.length;i++){\\n            if(nums[i]==1){\\n                if(first){\\n                   first = false; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3690068,
                "title": "c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ct = 1, ct1 = 0;\\n        int flag = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                if(flag==1)\\n                {\\n                    ct = (ct*(ct1+1))%mod;\\n                }\\n                ct1 = 0;\\n                flag = 1;\\n            }\\n            else\\n            {\\n                ct1++;\\n            }\\n        }\\n        if(flag==0) return 0;\\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ct = 1, ct1 = 0;\\n        int flag = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                if(flag==1)\\n                {\\n                    ct = (ct*(ct1+1))%mod;\\n                }\\n                ct1 = 0;\\n                flag = 1;\\n            }\\n            else\\n            {\\n                ct1++;\\n            }\\n        }\\n        if(flag==0) return 0;\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689567,
                "title": "ways-to-split-array-into-good-arrays-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) \\n    {\\n        int zero = 0;\\n        int one = 0;\\n        vector<int>zerocount;\\n        int mo = 1e9+7;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n                if(zero>0)\\n                {\\n                                    zerocount.push_back(zero);\\n                zero = 0;\\n                }\\n            }\\n            else\\n            {\\n                zero++;\\n            }\\n        }\\n        if(one==0)\\n        {\\n            return 0;\\n        }\\n        if(one==1)\\n        {\\n            return 1;\\n        }\\n        // for(int i = 0; i<zerocount.size(); i++)\\n        // {\\n        //     cout<<zerocount[i]<<\" \";\\n        // }\\n        // if(nums[nums.size()-1]==0)\\n        // {\\n        //     zerocount.pop_back();\\n        // }\\n        \\n        \\n        \\n        \\n        if(nums[0]==0)\\n        {\\n            reverse(zerocount.begin(),zerocount.end());\\n            zerocount.pop_back();\\n        }\\n        long long int res = 1;\\n        for(int i = 0; i<zerocount.size(); i++)\\n        {\\n            res = (res*(zerocount[i]+1))%mo;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) \\n    {\\n        int zero = 0;\\n        int one = 0;\\n        vector<int>zerocount;\\n        int mo = 1e9+7;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n                if(zero>0)\\n                {\\n                                    zerocount.push_back(zero);\\n                zero = 0;\\n                }\\n            }\\n            else\\n            {\\n                zero++;\\n            }\\n        }\\n        if(one==0)\\n        {\\n            return 0;\\n        }\\n        if(one==1)\\n        {\\n            return 1;\\n        }\\n        // for(int i = 0; i<zerocount.size(); i++)\\n        // {\\n        //     cout<<zerocount[i]<<\" \";\\n        // }\\n        // if(nums[nums.size()-1]==0)\\n        // {\\n        //     zerocount.pop_back();\\n        // }\\n        \\n        \\n        \\n        \\n        if(nums[0]==0)\\n        {\\n            reverse(zerocount.begin(),zerocount.end());\\n            zerocount.pop_back();\\n        }\\n        long long int res = 1;\\n        for(int i = 0; i<zerocount.size(); i++)\\n        {\\n            res = (res*(zerocount[i]+1))%mo;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689230,
                "title": "java-best-solution-o-n-only-space-o-1-count-zeros-between-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int mod= (int) (1e9+7);\\n        int c0=0;\\n        int c1=0;\\n        long ans=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                c0++;\\n            }\\n            if(nums[i]==1){\\n                if(c1>=1){\\n                    ans=(ans*(c0+1))%mod;\\n                    c1=1;\\n                    c0=0;\\n                }\\n                else {\\n                    c1++;\\n                    c0 = 0;\\n                }\\n            }\\n        }\\n        if(c0==nums.length){\\n            return 0;\\n        }\\n        else {\\n            return (int) ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int mod= (int) (1e9+7);\\n        int c0=0;\\n        int c1=0;\\n        long ans=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                c0++;\\n            }\\n            if(nums[i]==1){\\n                if(c1>=1){\\n                    ans=(ans*(c0+1))%mod;\\n                    c1=1;\\n                    c0=0;\\n                }\\n                else {\\n                    c1++;\\n                    c0 = 0;\\n                }\\n            }\\n        }\\n        if(c0==nums.length){\\n            return 0;\\n        }\\n        else {\\n            return (int) ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688137,
                "title": "maths-problem",
                "content": "# Intuition\\nAt first, it might seem like dp but it is a simple math problem.\\n\\n# Approach\\nCalculate (numberofzeroesbetweentwo1s + 1) for all pair of 1s and multiply them all. If number of ones is 1 then there is only one answer, and if zero, it is impossible.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N = 1000000007;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i]==1)\\n                v.push_back(i);\\n        }\\n        if(v.size()<=1)\\n            return v.size();\\n        long long prod = 1;\\n        for(int i=1; i<v.size();i++) {\\n            prod = ((prod%N)*((v[i]-v[i-1])%N))%N;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N = 1000000007;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i]==1)\\n                v.push_back(i);\\n        }\\n        if(v.size()<=1)\\n            return v.size();\\n        long long prod = 1;\\n        for(int i=1; i<v.size();i++) {\\n            prod = ((prod%N)*((v[i]-v[i-1])%N))%N;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687889,
                "title": "easiest-c-solution-simple-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int>ans;\\n        int i = 0;\\n        int j = 0; \\n        int mod = 1000000007;\\n        int count = 0;\\n        \\n        while(i<nums.size() && j<nums.size() )\\n        {\\n            if(nums[j] == 1)\\n            {\\n                  count++;\\n            }\\n             if(nums[i] == 1 && nums[j] == 1 && i!=j )\\n             {\\n                    int x = j-i-1;\\n                    ans.push_back(x);\\n                 i = j;\\n                \\n             }\\n            \\n            if(nums[i] == 0)\\n            {\\n                i++;\\n            }\\n            j++;\\n                 \\n             \\n        }\\n        if(count == 1)\\n        {\\n            return 1;\\n        }\\n        if(ans.size() == 0)\\n        {\\n           return 0;\\n        }\\n       long long int res = 1;\\n        for(int i = 0; i<ans.size(); i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n           res = res * (ans[i]+1)%mod;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<int>ans;\\n        int i = 0;\\n        int j = 0; \\n        int mod = 1000000007;\\n        int count = 0;\\n        \\n        while(i<nums.size() && j<nums.size() )\\n        {\\n            if(nums[j] == 1)\\n            {\\n                  count++;\\n            }\\n             if(nums[i] == 1 && nums[j] == 1 && i!=j )\\n             {\\n                    int x = j-i-1;\\n                    ans.push_back(x);\\n                 i = j;\\n                \\n             }\\n            \\n            if(nums[i] == 0)\\n            {\\n                i++;\\n            }\\n            j++;\\n                 \\n             \\n        }\\n        if(count == 1)\\n        {\\n            return 1;\\n        }\\n        if(ans.size() == 0)\\n        {\\n           return 0;\\n        }\\n       long long int res = 1;\\n        for(int i = 0; i<ans.size(); i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n           res = res * (ans[i]+1)%mod;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3687719,
                "title": "easy-o-n-time-o-1-space-python-solution",
                "content": "# Intuition\\nWe count number of 0\\'s between the 1\\'s\\nAnd then we multiply that amount with each other to get a result\\n\\n# Complexity\\n- Time complexity:   $$O(n)$$\\n\\n- Space complexity:  $$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        # this is final res we will be returning\\n        res = 1\\n        # this is local count of 0\\'s between 1\\'s\\n        count = 1\\n        # we only want to start counting 0\\'s when we see our first 1\\n        start = False\\n        for num in nums:\\n            if num == 1:\\n                start = True\\n                res*=count\\n                count = 1\\n            else:\\n                if start:\\n                    count += 1\\n        # our result by default is 1, and because of that when we didn\\'t see a single 1, we would like to return 0 instead of res\\n        return res % (10**9+7) if start else 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        # this is final res we will be returning\\n        res = 1\\n        # this is local count of 0\\'s between 1\\'s\\n        count = 1\\n        # we only want to start counting 0\\'s when we see our first 1\\n        start = False\\n        for num in nums:\\n            if num == 1:\\n                start = True\\n                res*=count\\n                count = 1\\n            else:\\n                if start:\\n                    count += 1\\n        # our result by default is 1, and because of that when we didn\\'t see a single 1, we would like to return 0 instead of res\\n        return res % (10**9+7) if start else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687313,
                "title": "tle-memorized-different-rec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically there are two appraoches to reach at the answer using recursion . \\n1 ) Using three varibles (2 * 2 * n) TC\\n2 ) Two varibles  ( 2 * n) TC\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# TLE\\n\\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    HashMap<String,Integer> hash = new HashMap<>();\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n       \\n        return solve(nums,0,0,false);\\n    }\\n\\n    int solve(int[] nums ,int oneC , int index ,boolean notakeb) {\\n        if(index >= nums.length) {\\n            if(notakeb == true) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n\\n\\n        String key = index + \".\" + oneC + \".\" + notakeb;\\n    if(hash.containsKey(key)) {\\n        return hash.get(key);\\n    }\\n        int take = 0;\\n        \\n\\n            if(nums[index] == 1) {\\n                if(oneC  == 0) {\\n                    //  System.out.println(index);\\n                 take = solve(nums,0,index+1,false);\\n                }\\n               \\n            } else if(nums[index] == 0) {\\n                if(oneC == 1) {\\n                    // System.out.println(\"from zero\" + index);\\n                    take = solve(nums,0,index + 1,false);\\n                }\\n            }\\n            \\n           \\n        \\n         \\n        int notake = 0;\\n        if(nums[index] == 1) {\\n               notake = solve(nums,oneC + 1,index + 1,true);\\n        } else {\\n               notake = solve(nums,oneC,index + 1,true);\\n        }\\n     int ans = (notake % mod + take % mod ) % mod;\\nhash.put(key,ans);\\n        return ans; \\n    }\\n}\\n```\\n\\n\\n\\n# Accepted\\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    int[][] t;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        t = new int[nums.length + 1][2];\\n        for(int[] i : t) {\\n            Arrays.fill(i,-1);\\n        }\\n        return solve(nums,0,0);\\n    }\\n\\n\\n    int solve(int[] nums , int i , int k) {\\n\\n        if(i >= nums.length) {\\n            if(k == 1) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if(t[i][k] != -1) {\\n            return t[i][k];\\n        }\\n\\n        int take = 0;\\n        int notake = 0;\\n        if(k == 1) {\\n            if(nums[i] == 0) {\\n                take = solve(nums,i+1,0);\\n                notake = solve(nums,i+1,k);\\n            } else {\\n                take = solve(nums,i+1,1);\\n            }\\n        } else {\\n            notake = solve(nums,i+1,k+nums[i]);\\n        }\\n\\n        int ans = (take % mod + notake % mod) % mod;\\n\\n        return t[i][k] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    HashMap<String,Integer> hash = new HashMap<>();\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n       \\n        return solve(nums,0,0,false);\\n    }\\n\\n    int solve(int[] nums ,int oneC , int index ,boolean notakeb) {\\n        if(index >= nums.length) {\\n            if(notakeb == true) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n\\n\\n        String key = index + \".\" + oneC + \".\" + notakeb;\\n    if(hash.containsKey(key)) {\\n        return hash.get(key);\\n    }\\n        int take = 0;\\n        \\n\\n            if(nums[index] == 1) {\\n                if(oneC  == 0) {\\n                    //  System.out.println(index);\\n                 take = solve(nums,0,index+1,false);\\n                }\\n               \\n            } else if(nums[index] == 0) {\\n                if(oneC == 1) {\\n                    // System.out.println(\"from zero\" + index);\\n                    take = solve(nums,0,index + 1,false);\\n                }\\n            }\\n            \\n           \\n        \\n         \\n        int notake = 0;\\n        if(nums[index] == 1) {\\n               notake = solve(nums,oneC + 1,index + 1,true);\\n        } else {\\n               notake = solve(nums,oneC,index + 1,true);\\n        }\\n     int ans = (notake % mod + take % mod ) % mod;\\nhash.put(key,ans);\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    int[][] t;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        t = new int[nums.length + 1][2];\\n        for(int[] i : t) {\\n            Arrays.fill(i,-1);\\n        }\\n        return solve(nums,0,0);\\n    }\\n\\n\\n    int solve(int[] nums , int i , int k) {\\n\\n        if(i >= nums.length) {\\n            if(k == 1) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if(t[i][k] != -1) {\\n            return t[i][k];\\n        }\\n\\n        int take = 0;\\n        int notake = 0;\\n        if(k == 1) {\\n            if(nums[i] == 0) {\\n                take = solve(nums,i+1,0);\\n                notake = solve(nums,i+1,k);\\n            } else {\\n                take = solve(nums,i+1,1);\\n            }\\n        } else {\\n            notake = solve(nums,i+1,k+nums[i]);\\n        }\\n\\n        int ans = (take % mod + notake % mod) % mod;\\n\\n        return t[i][k] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687156,
                "title": "python3-dp",
                "content": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        mem=[[-1,-1] for n in nums]\\n        def dp(i,f):\\n            if i>=len(nums):return 1 if f else 0\\n            if mem[i][f]!=-1:return mem[i][f]\\n            if f==1:\\n                a=0\\n                if nums[i]==0:a+=dp(i+1,0)\\n                mem[i][f]=(dp(i+1,1)+a)%((10**9)+7)\\n                return mem[i][f]\\n            a=0\\n            if nums[i]==1:a=dp(i+1,1)\\n            else:a=dp(i+1,0)\\n            mem[i][f]=a%((10**9)+7)\\n            return mem[i][f]\\n        return dp(0,0)%((10**9)+7)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        mem=[[-1,-1] for n in nums]\\n        def dp(i,f):\\n            if i>=len(nums):return 1 if f else 0\\n            if mem[i][f]!=-1:return mem[i][f]\\n            if f==1:\\n                a=0\\n                if nums[i]==0:a+=dp(i+1,0)\\n                mem[i][f]=(dp(i+1,1)+a)%((10**9)+7)\\n                return mem[i][f]\\n            a=0\\n            if nums[i]==1:a=dp(i+1,1)\\n            else:a=dp(i+1,0)\\n            mem[i][f]=a%((10**9)+7)\\n            return mem[i][f]\\n        return dp(0,0)%((10**9)+7)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686819,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1)\\n                arr.add(i);\\n        }\\n        \\n        long result = arr.size() == 0 ? 0 : 1;\\n        for(int i=1; i<arr.size(); i++) {\\n            result = (result * (long)(arr.get(i) - arr.get(i-1))) % 1000000007;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1)\\n                arr.add(i);\\n        }\\n        \\n        long result = arr.size() == 0 ? 0 : 1;\\n        for(int i=1; i<arr.size(); i++) {\\n            result = (result * (long)(arr.get(i) - arr.get(i-1))) % 1000000007;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686809,
                "title": "javascript-math-dp-two-solutions",
                "content": "Solution 1: Math count with seperate adjacent 1\\'s (221ms)\\n```\\nconst mod = 1e9 + 7;\\n\\nconst numberOfGoodSubarraySplits = (a) => {\\n    let se = new Set(a);\\n    if (se.size == 1 && se.values().next().value == 0) return 0;\\n    let ia = [], res = 1;\\n    a.map((x, i) => {\\n        if (x == 1) ia.push(i);\\n    });\\n    for (let i = 1; i < ia.length; i++) {\\n        res *= ia[i] - ia[i - 1]; // adjacent 1\\'s\\n        res %= mod;\\n    }\\n    return res;\\n};\\n```\\nSolution 2: DP 488ms\\n```\\nconst mod = 1e9 + 7;\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\n\\nconst numberOfGoodSubarraySplits = (a) => {\\n    // f[i][state] : state:0,1 reprenet if has one 1\\'s\\n    let n = a.length, f = initialize2DArray(n, 2);\\n    f[0][0] = a[0] ^ 1;\\n    f[0][1] = a[0];\\n    for (let i = 1; i < n; i++) {\\n        if (a[i] == 0) {\\n            f[i][0] = (f[i - 1][0] + f[i - 1][1]) % mod;\\n            f[i][1] = f[i - 1][1];\\n        } else {\\n            f[i][0] = 0;\\n            f[i][1] = (f[i - 1][0] + f[i - 1][1]) % mod;\\n        }\\n    }\\n    return f[n - 1][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst mod = 1e9 + 7;\\n\\nconst numberOfGoodSubarraySplits = (a) => {\\n    let se = new Set(a);\\n    if (se.size == 1 && se.values().next().value == 0) return 0;\\n    let ia = [], res = 1;\\n    a.map((x, i) => {\\n        if (x == 1) ia.push(i);\\n    });\\n    for (let i = 1; i < ia.length; i++) {\\n        res *= ia[i] - ia[i - 1]; // adjacent 1\\'s\\n        res %= mod;\\n    }\\n    return res;\\n};\\n```\n```\\nconst mod = 1e9 + 7;\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\n\\nconst numberOfGoodSubarraySplits = (a) => {\\n    // f[i][state] : state:0,1 reprenet if has one 1\\'s\\n    let n = a.length, f = initialize2DArray(n, 2);\\n    f[0][0] = a[0] ^ 1;\\n    f[0][1] = a[0];\\n    for (let i = 1; i < n; i++) {\\n        if (a[i] == 0) {\\n            f[i][0] = (f[i - 1][0] + f[i - 1][1]) % mod;\\n            f[i][1] = f[i - 1][1];\\n        } else {\\n            f[i][0] = 0;\\n            f[i][1] = (f[i - 1][0] + f[i - 1][1]) % mod;\\n        }\\n    }\\n    return f[n - 1][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686471,
                "title": "basic-sliding-window-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        const long MOD=1000000007;\\n        long ans=1;\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<nums.size()&&nums[s]!=1)s++;\\n        while(e>=0&&nums[e]!=1)e--;\\n        if(s==nums.size())return 0;\\n        s++;\\n        int cnt=1;\\n        while(s<e){\\n            while(nums[s]!=1){\\n                s++;cnt++;\\n            }\\n            ans=(ans*cnt)%MOD;\\n            if(s==e)break;\\n            s++;\\n            cnt=1;\\n        }\\n        // return (int)(ans%MOD);\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        const long MOD=1000000007;\\n        long ans=1;\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<nums.size()&&nums[s]!=1)s++;\\n        while(e>=0&&nums[e]!=1)e--;\\n        if(s==nums.size())return 0;\\n        s++;\\n        int cnt=1;\\n        while(s<e){\\n            while(nums[s]!=1){\\n                s++;cnt++;\\n            }\\n            ans=(ans*cnt)%MOD;\\n            if(s==e)break;\\n            s++;\\n            cnt=1;\\n        }\\n        // return (int)(ans%MOD);\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686114,
                "title": "ways-to-split-array-into-good-subarrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        def rec(ind,one):\\n            if ind==len(nums):\\n                if one:\\n                    return 1\\n                return 0\\n            if (ind,one) not in dp:\\n                if nums[ind]:\\n                    ans=rec(ind+1,True)\\n                    if one:\\n                        ans=rec(ind+1,True)\\n                    else:\\n                        ans=rec(ind+1,True)    \\n                else:\\n                    if one:\\n                        ans=rec(ind+1,one)+rec(ind+1,False)\\n                    else:\\n                        ans=rec(ind+1,one)\\n                dp[(ind,one)]=ans%(10**9+7)\\n            return dp[(ind,one)]\\n        dp=dict()    \\n        return rec(0,False)                            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        def rec(ind,one):\\n            if ind==len(nums):\\n                if one:\\n                    return 1\\n                return 0\\n            if (ind,one) not in dp:\\n                if nums[ind]:\\n                    ans=rec(ind+1,True)\\n                    if one:\\n                        ans=rec(ind+1,True)\\n                    else:\\n                        ans=rec(ind+1,True)    \\n                else:\\n                    if one:\\n                        ans=rec(ind+1,one)+rec(ind+1,False)\\n                    else:\\n                        ans=rec(ind+1,one)\\n                dp[(ind,one)]=ans%(10**9+7)\\n            return dp[(ind,one)]\\n        dp=dict()    \\n        return rec(0,False)                            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686099,
                "title": "python-easy-o-n-time-and-space",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n\\n        idx_list = [idx for idx,val in enumerate(nums) if val == 1]\\n\\n        if len(idx_list) <= 1:\\n            return len(idx_list)\\n\\n        result = 1\\n\\n        for i in range(1, len(idx_list)):\\n            result *= idx_list[i] - idx_list[i-1]\\n\\n        return result%(10**9+7)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n\\n        idx_list = [idx for idx,val in enumerate(nums) if val == 1]\\n\\n        if len(idx_list) <= 1:\\n            return len(idx_list)\\n\\n        result = 1\\n\\n        for i in range(1, len(idx_list)):\\n            result *= idx_list[i] - idx_list[i-1]\\n\\n        return result%(10**9+7)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685659,
                "title": "math-based-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    int MOD = (int)1e9 + 7;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long curr = 0;\\n        long ans = 0;\\n        boolean flag = false;\\n        for(int i = nums.length - 1;i >= 0;--i){\\n            if(nums[i] == 1){\\n                if(flag){\\n                    ans = (ans * (curr + 1) % MOD) % MOD;\\n                }\\n                else ans = 1;\\n                curr = 0;\\n                flag = true;\\n            }\\n            else curr++;\\n        }\\n        if(nums[0] == 1) ans = (ans * (curr + 1) % MOD) % MOD;\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```java\\nclass Solution {\\n    int MOD = (int)1e9 + 7;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long curr = 0;\\n        long ans = 0;\\n        boolean flag = false;\\n        for(int i = nums.length - 1;i >= 0;--i){\\n            if(nums[i] == 1){\\n                if(flag){\\n                    ans = (ans * (curr + 1) % MOD) % MOD;\\n                }\\n                else ans = 1;\\n                curr = 0;\\n                flag = true;\\n            }\\n            else curr++;\\n        }\\n        if(nums[0] == 1) ans = (ans * (curr + 1) % MOD) % MOD;\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685241,
                "title": "java-optimal-solution-o-n-beats-100-0s-trapped-between-1s-best-solution",
                "content": "# Intuition\\nThe number of ways the 0s in middle of two 1s can be shared.\\nCombination of every possible distribution is the ans.\\n\\n# Approach\\n**Suppose 1 0 0 0 1, there are three 0s means each 1 has 4 options to take 0,1,2,3 0s and the other gets the rest. So the number of zeros +1 (case of zero 0 taken) multiplied across all the zeros trapped in between.**\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# PLEASE UPVOTE GUYS !!! PLEASE\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long ans=1; \\n        int curr=1;    //current number of zeros spotted\\n        boolean start=false;     //to know if 1 has been spotted so to add the ans ignoring the zeros spotted at the beginning of array\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                if(start){\\n                    //after the first 1 spotted we can multiply the current number of zeros to the ans\\n                     ans=(ans*curr)%1000000007;     //take modulo as ans go very large\\n                }\\n                curr=1;     //make the curr value to 1 again if spotted one\\n                start=true; //to check if 1 spotted\\n            }else{\\n                //if zero add to curr value\\n                curr++; \\n            }\\n        }\\n        //ending zeros are ignored\\n        //if start is true that means array contains atleast one 1\\n        //else return 0\\n        return start?(int)ans:0;\\n        \\n    }\\n}\\n```\\n# Code without Comments\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long ans=1;\\n        int curr=1;\\n        boolean start=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                if(start){\\n                     ans=(ans*curr)%1000000007;\\n                }\\n                curr=1;\\n                start=true;\\n            }else{\\n                curr++;\\n            }\\n        }\\n        return start?(int)ans:0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long ans=1; \\n        int curr=1;    //current number of zeros spotted\\n        boolean start=false;     //to know if 1 has been spotted so to add the ans ignoring the zeros spotted at the beginning of array\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                if(start){\\n                    //after the first 1 spotted we can multiply the current number of zeros to the ans\\n                     ans=(ans*curr)%1000000007;     //take modulo as ans go very large\\n                }\\n                curr=1;     //make the curr value to 1 again if spotted one\\n                start=true; //to check if 1 spotted\\n            }else{\\n                //if zero add to curr value\\n                curr++; \\n            }\\n        }\\n        //ending zeros are ignored\\n        //if start is true that means array contains atleast one 1\\n        //else return 0\\n        return start?(int)ans:0;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        long ans=1;\\n        int curr=1;\\n        boolean start=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                if(start){\\n                     ans=(ans*curr)%1000000007;\\n                }\\n                curr=1;\\n                start=true;\\n            }else{\\n                curr++;\\n            }\\n        }\\n        return start?(int)ans:0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685150,
                "title": "beats-100-best-c-sol-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        long long ans=1;\\n        int n=nums.size();\\n        int i=0;\\n        \\n        long long ones=0;\\n        \\n        for(auto x:nums) if(x==1) ones++;\\n        \\n        if(ones==0) return 0;\\n        if(ones==1) return 1;\\n        \\n        while(i<n){\\n            \\n            if(nums[i]==1){\\n                ones--;\\n                int cnt=1;\\n                i++;\\n                while(i<n && nums[i]!=1 && ones>0){\\n                    cnt++;\\n                    i++;\\n                }\\n                ans=((ans%mod)*(cnt%mod))%mod;\\n            }\\n            else i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        \\n        long long ans=1;\\n        int n=nums.size();\\n        int i=0;\\n        \\n        long long ones=0;\\n        \\n        for(auto x:nums) if(x==1) ones++;\\n        \\n        if(ones==0) return 0;\\n        if(ones==1) return 1;\\n        \\n        while(i<n){\\n            \\n            if(nums[i]==1){\\n                ones--;\\n                int cnt=1;\\n                i++;\\n                while(i<n && nums[i]!=1 && ones>0){\\n                    cnt++;\\n                    i++;\\n                }\\n                ans=((ans%mod)*(cnt%mod))%mod;\\n            }\\n            else i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684964,
                "title": "c-sol-o-n-t-c-o-1-s-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long int ans=INT_MAX,count=-1,mod=1e9+7;;\\n        bool flag=false;\\n        for(auto i:nums){\\n            if(i==1){\\n                if(!flag)ans=1;\\n                if(flag)ans=(ans*count)%mod;\\n                flag=true;\\n                count=1;\\n            }else count++;\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long int ans=INT_MAX,count=-1,mod=1e9+7;;\\n        bool flag=false;\\n        for(auto i:nums){\\n            if(i==1){\\n                if(!flag)ans=1;\\n                if(flag)ans=(ans*count)%mod;\\n                flag=true;\\n                count=1;\\n            }else count++;\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684916,
                "title": "easy-and-best-approach-c-o-n-time-iterative-approach-greedy",
                "content": "# Intuition\\nWe will first store the indexes of 1\\'s and then keep on multiplying them with each other so as to get the desired result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\'\\nStore the indes of 1\\'s in array ans and then we will traverse it and keep on doing modular multiplication so as to get our answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) for traversing the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for storing the index of 1\\'s.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int val = 1;\\n        int n = nums.size();\\n        vector<int> ans;\\n        for(int i =0;i<n;i++){\\n            if(nums[i]) ans.push_back(i);\\n        }\\n        \\n        if(ans.size() == 0) return  0;\\n        \\n        int m = 1e9 + 7;\\n        if(ans.size() == 1) return 1;\\n        for(int i = 1;i<ans.size();i++){\\n            val = (1LL * val * (ans[i]-ans[i-1]))%m;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int val = 1;\\n        int n = nums.size();\\n        vector<int> ans;\\n        for(int i =0;i<n;i++){\\n            if(nums[i]) ans.push_back(i);\\n        }\\n        \\n        if(ans.size() == 0) return  0;\\n        \\n        int m = 1e9 + 7;\\n        if(ans.size() == 1) return 1;\\n        for(int i = 1;i<ans.size();i++){\\n            val = (1LL * val * (ans[i]-ans[i-1]))%m;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684815,
                "title": "java-clean-readable-with-explanation",
                "content": "The idea is simple, we count number of zeroes between `1`s and multiply the result by `zeroes_count+1`.\\n\\nThought process:\\n```\\n//Let\\'s have a look at several cases:\\n//1,1       - 1 split\\n//1,0,1     - 2 splits\\n//1,0,0,1   - 3 splits\\n//1,0,0,0,1 - 4 splits | zeroesCount+1\\n\\n\\n//1,1,1     - 1 split\\n//1,0,1,1   - 2 splits\\n//1,0,1,0,1 - 2*2 splits = 4 | (zeroes_count_1+1)*(zeroes_count_2+1)\\n\\n//the pattern can be observed\\n//edge cases:\\n//no 1\\'s : [0,0,0,0,0] - 0 splits\\n```\\nhere\\'s my impementation:\\n```\\n//finding the first 1 index.\\n//counting the number of zeroes between one\\'s and multiply the result by (zeroes_count+1).\\npublic int numberOfGoodSubarraySplits(int[] arr) {\\n\\tint MOD = 1_000_000_007, first1Idx = -1;\\n\\tfor (int i=0;i<arr.length;i++) if (arr[i]==1) {first1Idx=i;break;}\\n\\tif (first1Idx==-1) return 0;\\n\\n\\tlong res = 1L;\\n\\tfor (int i=first1Idx,cnt=0;i<arr.length;i++){\\n\\t\\tif (arr[i]==0) {\\n\\t\\t\\tcnt++;\\n\\t\\t} else {\\n\\t\\t\\tres*=(cnt+1);\\n\\t\\t\\tres%=MOD;\\n\\t\\t\\tcnt=0;\\n\\t\\t}\\n\\t}\\n\\treturn (int)res;\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n//Let\\'s have a look at several cases:\\n//1,1       - 1 split\\n//1,0,1     - 2 splits\\n//1,0,0,1   - 3 splits\\n//1,0,0,0,1 - 4 splits | zeroesCount+1\\n\\n\\n//1,1,1     - 1 split\\n//1,0,1,1   - 2 splits\\n//1,0,1,0,1 - 2*2 splits = 4 | (zeroes_count_1+1)*(zeroes_count_2+1)\\n\\n//the pattern can be observed\\n//edge cases:\\n//no 1\\'s : [0,0,0,0,0] - 0 splits\\n```\n```\\n//finding the first 1 index.\\n//counting the number of zeroes between one\\'s and multiply the result by (zeroes_count+1).\\npublic int numberOfGoodSubarraySplits(int[] arr) {\\n\\tint MOD = 1_000_000_007, first1Idx = -1;\\n\\tfor (int i=0;i<arr.length;i++) if (arr[i]==1) {first1Idx=i;break;}\\n\\tif (first1Idx==-1) return 0;\\n\\n\\tlong res = 1L;\\n\\tfor (int i=first1Idx,cnt=0;i<arr.length;i++){\\n\\t\\tif (arr[i]==0) {\\n\\t\\t\\tcnt++;\\n\\t\\t} else {\\n\\t\\t\\tres*=(cnt+1);\\n\\t\\t\\tres%=MOD;\\n\\t\\t\\tcnt=0;\\n\\t\\t}\\n\\t}\\n\\treturn (int)res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3684284,
                "title": "javascript-solution-straight-forward",
                "content": "Just recording what I too dumb to simply add %= M for the res\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfGoodSubarraySplits = function(nums) {\\n    let res = 0\\n    let idx = -1\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] === 1 && idx !== -1) {\\n            res *= (i - idx) // <------- not here\\n            res %= M // <----- add here\\n            idx = i\\n        } else if (nums[i] === 1) idx = i, res++\\n    }\\n    \\n    return res % M\\n};\\n\\nconst M = 10**9+7\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfGoodSubarraySplits = function(nums) {\\n    let res = 0\\n    let idx = -1\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] === 1 && idx !== -1) {\\n            res *= (i - idx) // <------- not here\\n            res %= M // <----- add here\\n            idx = i\\n        } else if (nums[i] === 1) idx = i, res++\\n    }\\n    \\n    return res % M\\n};\\n\\nconst M = 10**9+7\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3684112,
                "title": "count-zeros-between-2-ones-c-solution-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        const int MOD = 1000000007;\\n        int count = 0;\\n        long long result = 1;\\n        int flag=0,flag2=0;\\n            \\n    \\n        bool foundOne = false;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) {\\n                if (foundOne) {\\n                    result =(1LL) *(result*(count+1))%MOD;\\n                }\\n                count = 0;\\n                foundOne = true;\\n            } else if (foundOne) {\\n                count++;\\n            }\\n        }\\n\\n        if(!foundOne)return 0;\\n        else return result % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        const int MOD = 1000000007;\\n        int count = 0;\\n        long long result = 1;\\n        int flag=0,flag2=0;\\n            \\n    \\n        bool foundOne = false;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) {\\n                if (foundOne) {\\n                    result =(1LL) *(result*(count+1))%MOD;\\n                }\\n                count = 0;\\n                foundOne = true;\\n            } else if (foundOne) {\\n                count++;\\n            }\\n        }\\n\\n        if(!foundOne)return 0;\\n        else return result % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684110,
                "title": "easy-o-n-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans = 1;\\n        long long cnt =0;\\n        int mod = pow(10,9)+7;\\n        bool flag = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                flag = 1;\\n                ans = (ans*(cnt+1))%mod;\\n                cnt = 0;\\n            }\\n            else if(nums[i] == 0 && flag == 1){\\n                cnt++;\\n            }\\n        }\\n        if(flag == 0){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        long long ans = 1;\\n        long long cnt =0;\\n        int mod = pow(10,9)+7;\\n        bool flag = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                flag = 1;\\n                ans = (ans*(cnt+1))%mod;\\n                cnt = 0;\\n            }\\n            else if(nums[i] == 0 && flag == 1){\\n                cnt++;\\n            }\\n        }\\n        if(flag == 0){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683903,
                "title": "easy-and-efficient-code-with-step-by-step-explanation-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code assumes that the input array nums contains only 0s and 1s, which is not guaranteed by the problem statement. The problem statement mentions that the array nums is binary, but it doesn\\'t restrict the elements to only 0 and 1.\\n2. The code uses an undefined constant MOD without declaring or initializing it. It should be defined as const int MOD = 1e9 + 7; to represent the modulo value 10^9 + 7.\\n3. The code directly accesses the elements of the pos array beyond its valid range. Since pos is declared as int pos[n], where n is the size of nums, it should be declared as vector<int> pos(p), where p is the count of 1s in nums. This ensures that the pos vector has enough space to store the positions of all 1s.\\n4. The code calculates the product of differences using ways = (ways * (pos[i + 1] - pos[i]) % MOD), but the modulus operation should be performed before the multiplication to prevent integer overflow. It should be written as ways = (ways % MOD * (pos[i + 1] - pos[i]) % MOD) % MOD.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos[n], p = 0, i;\\n    int modulo = 1000000007;\\n    // for loop for saving the positions of all 1s\\n    for (i = 0; i < n; i++) {\\n        if (nums[i] == 1) {\\n            pos[p] = i + 1;\\n            p++;\\n        }\\n    }\\n \\n    // If array contains only 0s\\n    if (p == 0)\\n        return 0;\\n \\n    long long int ways = 1;\\n    for (i = 0; i < p - 1; i++) {\\n        ways =((ways) %modulo* (pos[i + 1] - pos[i])%modulo)%modulo;\\n    }\\n \\n    // Return the total ways\\n    return ways;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos[n], p = 0, i;\\n    int modulo = 1000000007;\\n    // for loop for saving the positions of all 1s\\n    for (i = 0; i < n; i++) {\\n        if (nums[i] == 1) {\\n            pos[p] = i + 1;\\n            p++;\\n        }\\n    }\\n \\n    // If array contains only 0s\\n    if (p == 0)\\n        return 0;\\n \\n    long long int ways = 1;\\n    for (i = 0; i < p - 1; i++) {\\n        ways =((ways) %modulo* (pos[i + 1] - pos[i])%modulo)%modulo;\\n    }\\n \\n    // Return the total ways\\n    return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683825,
                "title": "c-easy-solution-o-n-time-o-1-space",
                "content": "# Intuition\\nJust remember that we have to find Ways to Split Array Into Good SUBARRAYS.\\n\\nMy first thoughts to the question were that the \\'0\\' that are at the left of the leftmost \\'1\\' and at the right of the rightmost \\'1\\' will not change my answer as they must be taken together everytime else it will not be a good subarray.\\n\\nSo the number of ways to find good subarray just depend on the number of \\'0\\' that are present in between two \\'1\\'.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. We are calculating the count just by calculating the`(number of zeroes in between each pair of ones) + 1`. The 1 is added as we can also choose no zero from one of the sides.\\n2. Multiply every count and store it as the answer to get the Ways to Split Array Into Good SUBARRAYS.\\n\\nI have provided comments on each step of my code for your understanding. \\n\\nPlease UPVOTE !! if you liked my solution.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long M = 1000000007;\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int cnt = 0; // Counter for zeros in a subarray\\n        long long ans = 1; // Variable to store the number of ways to split the array\\n        int i, j;\\n\\n        // Find the first occurrence of 1 from the left side\\n        for (i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) break;\\n        }\\n        \\n        if (i == nums.size()) return 0; // No 1 found, return 0\\n        \\n        // Find the last occurrence of 1 from the right side\\n        for (j = nums.size() - 1; j >= 0; j--) {\\n            if (nums[j] == 1) break;\\n        }\\n        \\n        // Iterate from the leftmost 1 to the rightmost 1\\n        for (i; i <= j; i++) {\\n            if (nums[i] == 0) {\\n                cnt++; // Increment count for zeros\\n            } else if (nums[i] == 1) {\\n                ans = (ans * (cnt + 1)) % M; // Update the number of ways to split by multiplying with (cnt + 1)\\n                cnt = 0; // Reset the count for zeros\\n            }\\n        }\\n        \\n        return (int)ans; // Return the number of ways to split as an integer\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long M = 1000000007;\\n\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int cnt = 0; // Counter for zeros in a subarray\\n        long long ans = 1; // Variable to store the number of ways to split the array\\n        int i, j;\\n\\n        // Find the first occurrence of 1 from the left side\\n        for (i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) break;\\n        }\\n        \\n        if (i == nums.size()) return 0; // No 1 found, return 0\\n        \\n        // Find the last occurrence of 1 from the right side\\n        for (j = nums.size() - 1; j >= 0; j--) {\\n            if (nums[j] == 1) break;\\n        }\\n        \\n        // Iterate from the leftmost 1 to the rightmost 1\\n        for (i; i <= j; i++) {\\n            if (nums[i] == 0) {\\n                cnt++; // Increment count for zeros\\n            } else if (nums[i] == 1) {\\n                ans = (ans * (cnt + 1)) % M; // Update the number of ways to split by multiplying with (cnt + 1)\\n                cnt = 0; // Reset the count for zeros\\n            }\\n        }\\n        \\n        return (int)ans; // Return the number of ways to split as an integer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683690,
                "title": "easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically it is combinatorics problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly you have to store the indexes that contains \\'1\\' in a new vector, then iterate through that vector and multiply the answer by number of zeroes between current Index && prevIndex.\\nIf number of \\'1\\'s is zero then our answer will be zero. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) . It can be done using O(1) space complexity also but to make implementation easier, rather I had used O(n) space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n            if(nums[i]==1)v.push_back(i);\\n        long long ans=v.size()==0?0:1;\\n        for(int i=1;i<v.size();i++)\\n            ans=(ans*(v[i]-v[i-1]))%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n            if(nums[i]==1)v.push_back(i);\\n        long long ans=v.size()==0?0:1;\\n        for(int i=1;i<v.size();i++)\\n            ans=(ans*(v[i]-v[i-1]))%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683576,
                "title": "java-easy-solution-multiply-each-partition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought I could just multiply the number of each partition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nexample)\\n001000101\\n001|0001|01 -> 1 x 4 x 2 = 8\\n*The first partition is fixed at 1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int res = 0;\\n        int i = 0;\\n        while (i < nums.length) {\\n            if (nums[i++] == 1) {\\n                res++;\\n                break;\\n            }\\n        }\\n        long c = 0;\\n        while (i < nums.length) {\\n            c++;\\n            if (nums[i++] == 1) {\\n                res = (int)((res * c) % 1000000007);\\n                c = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int res = 0;\\n        int i = 0;\\n        while (i < nums.length) {\\n            if (nums[i++] == 1) {\\n                res++;\\n                break;\\n            }\\n        }\\n        long c = 0;\\n        while (i < nums.length) {\\n            c++;\\n            if (nums[i++] == 1) {\\n                res = (int)((res * c) % 1000000007);\\n                c = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683522,
                "title": "simple-greedy-distance-between-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n         long long ans=1;\\n        int prev=-1;\\n        unordered_set<int> st(nums.begin(),nums.end());\\n        if(st.size()==1 && nums[0]==0) return 0;  \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1 && prev==-1){\\n                prev=i; continue;\\n            }\\n            if(nums[i]==1){\\n                ans= (ans *(i-prev))%mod;\\n                prev=i;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n         long long ans=1;\\n        int prev=-1;\\n        unordered_set<int> st(nums.begin(),nums.end());\\n        if(st.size()==1 && nums[0]==0) return 0;  \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1 && prev==-1){\\n                prev=i; continue;\\n            }\\n            if(nums[i]==1){\\n                ans= (ans *(i-prev))%mod;\\n                prev=i;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683409,
                "title": "simple-java-solution-dynamic-programming-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int mod=(int)1e9+7;\\n    public int fun(int i,int[] nums,int[] dp)\\n    {\\n        if(i==nums.length)  return 1;\\n        int cnt=0;\\n        int ind=i;\\n        boolean found=false;\\n        for(int j=i;j<nums.length;j++) \\n        {\\n            if(nums[j]==1)\\n            {\\n                ind=j;\\n                found=true;\\n                break;\\n            }\\n        }\\n        if(!found)  return 0;\\n        if(dp[i]!=-1)  return dp[i];\\n        for(int j=ind;j<nums.length;j++)\\n        {\\n            if(j==ind || nums[j]==0) \\n            {\\n                cnt=(cnt+fun(j+1,nums,dp))%mod;\\n            } \\n            else\\n            break;\\n        }\\n        return dp[i]=cnt;\\n    }\\n    public int numberOfGoodSubarraySplits(int[] nums) \\n    {\\n        int[] dp=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return fun(0,nums,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int mod=(int)1e9+7;\\n    public int fun(int i,int[] nums,int[] dp)\\n    {\\n        if(i==nums.length)  return 1;\\n        int cnt=0;\\n        int ind=i;\\n        boolean found=false;\\n        for(int j=i;j<nums.length;j++) \\n        {\\n            if(nums[j]==1)\\n            {\\n                ind=j;\\n                found=true;\\n                break;\\n            }\\n        }\\n        if(!found)  return 0;\\n        if(dp[i]!=-1)  return dp[i];\\n        for(int j=ind;j<nums.length;j++)\\n        {\\n            if(j==ind || nums[j]==0) \\n            {\\n                cnt=(cnt+fun(j+1,nums,dp))%mod;\\n            } \\n            else\\n            break;\\n        }\\n        return dp[i]=cnt;\\n    }\\n    public int numberOfGoodSubarraySplits(int[] nums) \\n    {\\n        int[] dp=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return fun(0,nums,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683205,
                "title": "fastest-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Sliding window\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private static final int MOD = 1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        boolean oneCountered = false;\\n        int count0 = 0;\\n        int currentSplit = 0;\\n        long totalSplit = 0;\\n\\n\\n        for(int i = 0;i<nums.length;i++) {\\n            if(nums[i] == 1) {\\n                   oneCountered = true;\\n                   currentSplit = count0 + 1;\\n                   totalSplit = (totalSplit == 0 ? currentSplit : totalSplit * currentSplit) % MOD;\\n                   count0=0;\\n            } else {\\n                if(oneCountered) {\\n                    count0 += 1;\\n                }\\n            }\\n        }\\n\\n        return (int)totalSplit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int MOD = 1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        boolean oneCountered = false;\\n        int count0 = 0;\\n        int currentSplit = 0;\\n        long totalSplit = 0;\\n\\n\\n        for(int i = 0;i<nums.length;i++) {\\n            if(nums[i] == 1) {\\n                   oneCountered = true;\\n                   currentSplit = count0 + 1;\\n                   totalSplit = (totalSplit == 0 ? currentSplit : totalSplit * currentSplit) % MOD;\\n                   count0=0;\\n            } else {\\n                if(oneCountered) {\\n                    count0 += 1;\\n                }\\n            }\\n        }\\n\\n        return (int)totalSplit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683168,
                "title": "python-3-lines-count-zeros",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe see that all we need to do is to move the cursor in zeroes positions between two 1\\'s, and each move is completely independent of another move. so in order to solve it we have to multiply them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe get 1\\'s indices and their differences to calculate the number of 0\\'s between each two 1. and multiply them together.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        one_indices = [i for i, n in enumerate(nums) if n == 1]\\n        diff = [b - a for a, b in zip(one_indices[:-1], one_indices[1:])]\\n        return reduce(lambda x, y: x * y % 1_000_000_007, diff, 1) if 1 in nums else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        one_indices = [i for i, n in enumerate(nums) if n == 1]\\n        diff = [b - a for a, b in zip(one_indices[:-1], one_indices[1:])]\\n        return reduce(lambda x, y: x * y % 1_000_000_007, diff, 1) if 1 in nums else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683088,
                "title": "python-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if not nums.count(1): return 0\\n        MOD = 10**9 + 7\\n        res = 1\\n        indexes = []\\n        for i in range(len(nums)):\\n            if nums[i]:\\n                indexes.append(i)\\n        for j in range(len(indexes)-1):\\n            res = (res * (indexes[j+1]-indexes[j]))%MOD \\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if not nums.count(1): return 0\\n        MOD = 10**9 + 7\\n        res = 1\\n        indexes = []\\n        for i in range(len(nums)):\\n            if nums[i]:\\n                indexes.append(i)\\n        for j in range(len(indexes)-1):\\n            res = (res * (indexes[j+1]-indexes[j]))%MOD \\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682956,
                "title": "python-easy-code-with-greedy-approach-count-intermediate-0-s-between-two-1-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMultiply all zero counts between two consecutive 1\\'s\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store the indecise of all 1\\n- Index difference between two consecutive 1\\'s is the number of ways (0 count + 1) we can split the two conescutive 1 into good subarrays\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nApproach 01: $$O(n)$$ \\nApproach 02: $$O(1)$$ \\n\\n# Code\\n\\nApproach 01:\\n\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if sum(nums) == 0: return 0\\n        if sum(nums) == 1 or sum(nums) == len(nums): return 1\\n        \\n        indices_of_one = []\\n        for i, num in enumerate(nums):\\n            if num == 1: indices_of_one.append(i)\\n        \\n        count, modulus = 1, 10**9 + 7\\n        for i in range(1, len(indices_of_one)):\\n            count = count * (indices_of_one[i] - indices_of_one[i-1])\\n            count = count % modulus\\n        return count   \\n```\\n\\nApproach 01:\\nWithout storing all the indices of 1 | Two pointer appraoch\\n\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if sum(nums) == 0: return 0\\n        if sum(nums) == 1 or sum(nums) == len(nums): return 1\\n        \\n        idx_starting_one = None\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                idx_starting_one = i\\n                break\\n        \\n        count, modulus = 1, 10**9 + 7\\n        for i in range(idx_starting_one+1, len(nums)):\\n            if nums[i] == 0:\\n                continue\\n            count = count * (i - idx_starting_one)\\n            count = count % modulus\\n            idx_starting_one = i\\n\\n        return count \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if sum(nums) == 0: return 0\\n        if sum(nums) == 1 or sum(nums) == len(nums): return 1\\n        \\n        indices_of_one = []\\n        for i, num in enumerate(nums):\\n            if num == 1: indices_of_one.append(i)\\n        \\n        count, modulus = 1, 10**9 + 7\\n        for i in range(1, len(indices_of_one)):\\n            count = count * (indices_of_one[i] - indices_of_one[i-1])\\n            count = count % modulus\\n        return count   \\n```\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        if sum(nums) == 0: return 0\\n        if sum(nums) == 1 or sum(nums) == len(nums): return 1\\n        \\n        idx_starting_one = None\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                idx_starting_one = i\\n                break\\n        \\n        count, modulus = 1, 10**9 + 7\\n        for i in range(idx_starting_one+1, len(nums)):\\n            if nums[i] == 0:\\n                continue\\n            count = count * (i - idx_starting_one)\\n            count = count % modulus\\n            idx_starting_one = i\\n\\n        return count \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1944031,
                "content": [
                    {
                        "username": "rakhikumari6602",
                        "content": "I am thinking of prefix sum concept."
                    },
                    {
                        "username": "batteraOp",
                        "content": "So, the first thought most noobs like me must have had was dp, right?\\nbut I later came up with  a solution in O(n) tc which is very easy to understand\\n\\nso the points to be noticed are:\\n1. the initial and final zeroes will be added with the first and last ones only so we can ignore them while calculating the number of ways.\\n2. find the count of ones, if it is zero or one then return count (this is because if no ones are present then no good subarrays are there and if only one one is present then the array itself is the only possible good array.\\n\\nwe initialise a variable ans with one;\\n3. then we find the first occurrence and the last occurrence of ones, start iterating the array from the next index of the first occurrence, and we keep a count of zeroes and every time  we encounter a one , we multiply ans with count of zeroes plus one and update zero count to 0;\\n\\nyou can check out my solution below:\\n\\nany suggestions or criticism is welcomed!(posting for the first time,so i m sorry for any mistakes)\\n\\n\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count==0||count==1){\\n            return count;\\n        }\\n        int zeroes=0;\\n        int i,last;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                break;\\n            }\\n        }\\n        for(last=nums.length-1;last>=0;last--){\\n            if(nums[last]==1){\\n                break;\\n            }\\n        }\\n        int ans=1;\\n        for(i=i+1;i<=last;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n\\n            }else if(nums[i]==1){\\n                if(zeroes!=0){\\n                    ans=ans*(zeroes+1)%MOD;\\n                    zeroes=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    "
                    },
                    {
                        "username": "emlitke",
                        "content": "Dont post solutions"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Always try to solve a problem using recursion"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "what would be the answer if instead of exactly one 1 we are asked for atleast one 1;\nI read it atleast 1st time and wasted almost half an hour;"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Hint: just find the distance between two 1s and then multiply it to get the ans. Make sure to update the distance cuz there can be multiple ones."
                    },
                    {
                        "username": "kajal_k13",
                        "content": "how you got this intuition? "
                    },
                    {
                        "username": "harsitsinha",
                        "content": "Why is this giving TLE?? I have partitioned it and checked for the remaining right subarray. 522/553 passed.\\n\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int recurse(int index, vector<int>& nums, vector<long long> &prefix, long long prefixint, vector<long long> &memo){\\n        if(memo[index]!=-1){\\n            return memo[index];\\n        }\\n        if(index == nums.size()){\\n            return 1;\\n        }\\n        if(index>nums.size()) return 0;\\n        long long count = 0;\\n        for(int i =index;i<nums.size();i++){\\n            if(prefix[i]-prefixint==1){\\n                 count+=recurse(i+1, nums, prefix, prefix[i],memo);\\n                count%=mod;\\n            }\\n        }\\n        return memo[index] = count;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> prefix(nums.size(), 0);\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i] = sum;\\n        }\\n        long long count = 0;\\n        vector<long long> memo(nums.size()+1,-1);\\n        for(int i =0;i<nums.size();i++){\\n            if(prefix[i]==1)\\n            count += recurse(i+1, nums, prefix, 1,memo);\\n            count%=mod;\\n        }\\n        return (int)count;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    const int Mod=1e9+7;\\n    \\n    long long Recursion(long long i,vector<long long> &Sum,vector<long long> &DP)\\n    {\\n        if(i==Sum.size()-1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(DP[i+1]!=-1)\\n        {\\n            return DP[i+1];\\n        }\\n        \\n        long long x=0;\\n        if(i!=-1)\\n        {\\n            x=Sum[i];\\n        }\\n        \\n        long long Ans=0;        \\n        long long l=upper_bound(Sum.begin(),Sum.end(),x)-Sum.begin();\\n        if(l<Sum.size())\\n        {\\n            int j=l;\\n            while(j<Sum.size() && Sum[l]==Sum[j])\\n            {\\n                Ans+=Recursion(j,Sum,DP);\\n                j++;\\n            }\\n        }\\n        \\n        return DP[i+1]=Ans%Mod;\\n    }\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        vector<long long> Sum;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            Sum.push_back(sum);\\n        }\\n        cout<<sum;\\n        if(sum==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<long long> DP(nums.size(),-1);\\n        \\n        return Recursion(-1,Sum,DP)%Mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "I found that the Sum computation part is unnecessary here and taking 1 complete traversal, instead we can just take the sum to be the second variable with it\\'s possible values being 0 and 1 and just apply 2D dp"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "[@Minsor](/Minsor) that\\'s ok but it shall get accepted too right? It\\'s at max nlogn and shall pass according to the constraints plus I saw some dp solutions too"
                    },
                    {
                        "username": "arpansaha13",
                        "content": "At first glance this appears to be a dp problem. I too did the same mistake. But actually it has a linear time and constant space solution, which will be much faster than the dp approach.\n\n\nHint below...\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\nTry thinking about the number of subarrays you can create with two ones and a handful of zeroes in between."
                    }
                ]
            },
            {
                "id": 1943907,
                "content": [
                    {
                        "username": "rakhikumari6602",
                        "content": "I am thinking of prefix sum concept."
                    },
                    {
                        "username": "batteraOp",
                        "content": "So, the first thought most noobs like me must have had was dp, right?\\nbut I later came up with  a solution in O(n) tc which is very easy to understand\\n\\nso the points to be noticed are:\\n1. the initial and final zeroes will be added with the first and last ones only so we can ignore them while calculating the number of ways.\\n2. find the count of ones, if it is zero or one then return count (this is because if no ones are present then no good subarrays are there and if only one one is present then the array itself is the only possible good array.\\n\\nwe initialise a variable ans with one;\\n3. then we find the first occurrence and the last occurrence of ones, start iterating the array from the next index of the first occurrence, and we keep a count of zeroes and every time  we encounter a one , we multiply ans with count of zeroes plus one and update zero count to 0;\\n\\nyou can check out my solution below:\\n\\nany suggestions or criticism is welcomed!(posting for the first time,so i m sorry for any mistakes)\\n\\n\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count==0||count==1){\\n            return count;\\n        }\\n        int zeroes=0;\\n        int i,last;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                break;\\n            }\\n        }\\n        for(last=nums.length-1;last>=0;last--){\\n            if(nums[last]==1){\\n                break;\\n            }\\n        }\\n        int ans=1;\\n        for(i=i+1;i<=last;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n\\n            }else if(nums[i]==1){\\n                if(zeroes!=0){\\n                    ans=ans*(zeroes+1)%MOD;\\n                    zeroes=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    "
                    },
                    {
                        "username": "emlitke",
                        "content": "Dont post solutions"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Always try to solve a problem using recursion"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "what would be the answer if instead of exactly one 1 we are asked for atleast one 1;\nI read it atleast 1st time and wasted almost half an hour;"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Hint: just find the distance between two 1s and then multiply it to get the ans. Make sure to update the distance cuz there can be multiple ones."
                    },
                    {
                        "username": "kajal_k13",
                        "content": "how you got this intuition? "
                    },
                    {
                        "username": "harsitsinha",
                        "content": "Why is this giving TLE?? I have partitioned it and checked for the remaining right subarray. 522/553 passed.\\n\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int recurse(int index, vector<int>& nums, vector<long long> &prefix, long long prefixint, vector<long long> &memo){\\n        if(memo[index]!=-1){\\n            return memo[index];\\n        }\\n        if(index == nums.size()){\\n            return 1;\\n        }\\n        if(index>nums.size()) return 0;\\n        long long count = 0;\\n        for(int i =index;i<nums.size();i++){\\n            if(prefix[i]-prefixint==1){\\n                 count+=recurse(i+1, nums, prefix, prefix[i],memo);\\n                count%=mod;\\n            }\\n        }\\n        return memo[index] = count;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> prefix(nums.size(), 0);\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i] = sum;\\n        }\\n        long long count = 0;\\n        vector<long long> memo(nums.size()+1,-1);\\n        for(int i =0;i<nums.size();i++){\\n            if(prefix[i]==1)\\n            count += recurse(i+1, nums, prefix, 1,memo);\\n            count%=mod;\\n        }\\n        return (int)count;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    const int Mod=1e9+7;\\n    \\n    long long Recursion(long long i,vector<long long> &Sum,vector<long long> &DP)\\n    {\\n        if(i==Sum.size()-1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(DP[i+1]!=-1)\\n        {\\n            return DP[i+1];\\n        }\\n        \\n        long long x=0;\\n        if(i!=-1)\\n        {\\n            x=Sum[i];\\n        }\\n        \\n        long long Ans=0;        \\n        long long l=upper_bound(Sum.begin(),Sum.end(),x)-Sum.begin();\\n        if(l<Sum.size())\\n        {\\n            int j=l;\\n            while(j<Sum.size() && Sum[l]==Sum[j])\\n            {\\n                Ans+=Recursion(j,Sum,DP);\\n                j++;\\n            }\\n        }\\n        \\n        return DP[i+1]=Ans%Mod;\\n    }\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        vector<long long> Sum;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            Sum.push_back(sum);\\n        }\\n        cout<<sum;\\n        if(sum==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<long long> DP(nums.size(),-1);\\n        \\n        return Recursion(-1,Sum,DP)%Mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "I found that the Sum computation part is unnecessary here and taking 1 complete traversal, instead we can just take the sum to be the second variable with it\\'s possible values being 0 and 1 and just apply 2D dp"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "[@Minsor](/Minsor) that\\'s ok but it shall get accepted too right? It\\'s at max nlogn and shall pass according to the constraints plus I saw some dp solutions too"
                    },
                    {
                        "username": "arpansaha13",
                        "content": "At first glance this appears to be a dp problem. I too did the same mistake. But actually it has a linear time and constant space solution, which will be much faster than the dp approach.\n\n\nHint below...\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\nTry thinking about the number of subarrays you can create with two ones and a handful of zeroes in between."
                    }
                ]
            },
            {
                "id": 1946201,
                "content": [
                    {
                        "username": "rakhikumari6602",
                        "content": "I am thinking of prefix sum concept."
                    },
                    {
                        "username": "batteraOp",
                        "content": "So, the first thought most noobs like me must have had was dp, right?\\nbut I later came up with  a solution in O(n) tc which is very easy to understand\\n\\nso the points to be noticed are:\\n1. the initial and final zeroes will be added with the first and last ones only so we can ignore them while calculating the number of ways.\\n2. find the count of ones, if it is zero or one then return count (this is because if no ones are present then no good subarrays are there and if only one one is present then the array itself is the only possible good array.\\n\\nwe initialise a variable ans with one;\\n3. then we find the first occurrence and the last occurrence of ones, start iterating the array from the next index of the first occurrence, and we keep a count of zeroes and every time  we encounter a one , we multiply ans with count of zeroes plus one and update zero count to 0;\\n\\nyou can check out my solution below:\\n\\nany suggestions or criticism is welcomed!(posting for the first time,so i m sorry for any mistakes)\\n\\n\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count==0||count==1){\\n            return count;\\n        }\\n        int zeroes=0;\\n        int i,last;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                break;\\n            }\\n        }\\n        for(last=nums.length-1;last>=0;last--){\\n            if(nums[last]==1){\\n                break;\\n            }\\n        }\\n        int ans=1;\\n        for(i=i+1;i<=last;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n\\n            }else if(nums[i]==1){\\n                if(zeroes!=0){\\n                    ans=ans*(zeroes+1)%MOD;\\n                    zeroes=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    "
                    },
                    {
                        "username": "emlitke",
                        "content": "Dont post solutions"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Always try to solve a problem using recursion"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "what would be the answer if instead of exactly one 1 we are asked for atleast one 1;\nI read it atleast 1st time and wasted almost half an hour;"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Hint: just find the distance between two 1s and then multiply it to get the ans. Make sure to update the distance cuz there can be multiple ones."
                    },
                    {
                        "username": "kajal_k13",
                        "content": "how you got this intuition? "
                    },
                    {
                        "username": "harsitsinha",
                        "content": "Why is this giving TLE?? I have partitioned it and checked for the remaining right subarray. 522/553 passed.\\n\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int recurse(int index, vector<int>& nums, vector<long long> &prefix, long long prefixint, vector<long long> &memo){\\n        if(memo[index]!=-1){\\n            return memo[index];\\n        }\\n        if(index == nums.size()){\\n            return 1;\\n        }\\n        if(index>nums.size()) return 0;\\n        long long count = 0;\\n        for(int i =index;i<nums.size();i++){\\n            if(prefix[i]-prefixint==1){\\n                 count+=recurse(i+1, nums, prefix, prefix[i],memo);\\n                count%=mod;\\n            }\\n        }\\n        return memo[index] = count;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> prefix(nums.size(), 0);\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i] = sum;\\n        }\\n        long long count = 0;\\n        vector<long long> memo(nums.size()+1,-1);\\n        for(int i =0;i<nums.size();i++){\\n            if(prefix[i]==1)\\n            count += recurse(i+1, nums, prefix, 1,memo);\\n            count%=mod;\\n        }\\n        return (int)count;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    const int Mod=1e9+7;\\n    \\n    long long Recursion(long long i,vector<long long> &Sum,vector<long long> &DP)\\n    {\\n        if(i==Sum.size()-1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(DP[i+1]!=-1)\\n        {\\n            return DP[i+1];\\n        }\\n        \\n        long long x=0;\\n        if(i!=-1)\\n        {\\n            x=Sum[i];\\n        }\\n        \\n        long long Ans=0;        \\n        long long l=upper_bound(Sum.begin(),Sum.end(),x)-Sum.begin();\\n        if(l<Sum.size())\\n        {\\n            int j=l;\\n            while(j<Sum.size() && Sum[l]==Sum[j])\\n            {\\n                Ans+=Recursion(j,Sum,DP);\\n                j++;\\n            }\\n        }\\n        \\n        return DP[i+1]=Ans%Mod;\\n    }\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        vector<long long> Sum;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            Sum.push_back(sum);\\n        }\\n        cout<<sum;\\n        if(sum==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<long long> DP(nums.size(),-1);\\n        \\n        return Recursion(-1,Sum,DP)%Mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "I found that the Sum computation part is unnecessary here and taking 1 complete traversal, instead we can just take the sum to be the second variable with it\\'s possible values being 0 and 1 and just apply 2D dp"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "[@Minsor](/Minsor) that\\'s ok but it shall get accepted too right? It\\'s at max nlogn and shall pass according to the constraints plus I saw some dp solutions too"
                    },
                    {
                        "username": "arpansaha13",
                        "content": "At first glance this appears to be a dp problem. I too did the same mistake. But actually it has a linear time and constant space solution, which will be much faster than the dp approach.\n\n\nHint below...\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\nTry thinking about the number of subarrays you can create with two ones and a handful of zeroes in between."
                    }
                ]
            },
            {
                "id": 1944084,
                "content": [
                    {
                        "username": "rakhikumari6602",
                        "content": "I am thinking of prefix sum concept."
                    },
                    {
                        "username": "batteraOp",
                        "content": "So, the first thought most noobs like me must have had was dp, right?\\nbut I later came up with  a solution in O(n) tc which is very easy to understand\\n\\nso the points to be noticed are:\\n1. the initial and final zeroes will be added with the first and last ones only so we can ignore them while calculating the number of ways.\\n2. find the count of ones, if it is zero or one then return count (this is because if no ones are present then no good subarrays are there and if only one one is present then the array itself is the only possible good array.\\n\\nwe initialise a variable ans with one;\\n3. then we find the first occurrence and the last occurrence of ones, start iterating the array from the next index of the first occurrence, and we keep a count of zeroes and every time  we encounter a one , we multiply ans with count of zeroes plus one and update zero count to 0;\\n\\nyou can check out my solution below:\\n\\nany suggestions or criticism is welcomed!(posting for the first time,so i m sorry for any mistakes)\\n\\n\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count==0||count==1){\\n            return count;\\n        }\\n        int zeroes=0;\\n        int i,last;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                break;\\n            }\\n        }\\n        for(last=nums.length-1;last>=0;last--){\\n            if(nums[last]==1){\\n                break;\\n            }\\n        }\\n        int ans=1;\\n        for(i=i+1;i<=last;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n\\n            }else if(nums[i]==1){\\n                if(zeroes!=0){\\n                    ans=ans*(zeroes+1)%MOD;\\n                    zeroes=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    "
                    },
                    {
                        "username": "emlitke",
                        "content": "Dont post solutions"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Always try to solve a problem using recursion"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "what would be the answer if instead of exactly one 1 we are asked for atleast one 1;\nI read it atleast 1st time and wasted almost half an hour;"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Hint: just find the distance between two 1s and then multiply it to get the ans. Make sure to update the distance cuz there can be multiple ones."
                    },
                    {
                        "username": "kajal_k13",
                        "content": "how you got this intuition? "
                    },
                    {
                        "username": "harsitsinha",
                        "content": "Why is this giving TLE?? I have partitioned it and checked for the remaining right subarray. 522/553 passed.\\n\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int recurse(int index, vector<int>& nums, vector<long long> &prefix, long long prefixint, vector<long long> &memo){\\n        if(memo[index]!=-1){\\n            return memo[index];\\n        }\\n        if(index == nums.size()){\\n            return 1;\\n        }\\n        if(index>nums.size()) return 0;\\n        long long count = 0;\\n        for(int i =index;i<nums.size();i++){\\n            if(prefix[i]-prefixint==1){\\n                 count+=recurse(i+1, nums, prefix, prefix[i],memo);\\n                count%=mod;\\n            }\\n        }\\n        return memo[index] = count;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> prefix(nums.size(), 0);\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i] = sum;\\n        }\\n        long long count = 0;\\n        vector<long long> memo(nums.size()+1,-1);\\n        for(int i =0;i<nums.size();i++){\\n            if(prefix[i]==1)\\n            count += recurse(i+1, nums, prefix, 1,memo);\\n            count%=mod;\\n        }\\n        return (int)count;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    const int Mod=1e9+7;\\n    \\n    long long Recursion(long long i,vector<long long> &Sum,vector<long long> &DP)\\n    {\\n        if(i==Sum.size()-1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(DP[i+1]!=-1)\\n        {\\n            return DP[i+1];\\n        }\\n        \\n        long long x=0;\\n        if(i!=-1)\\n        {\\n            x=Sum[i];\\n        }\\n        \\n        long long Ans=0;        \\n        long long l=upper_bound(Sum.begin(),Sum.end(),x)-Sum.begin();\\n        if(l<Sum.size())\\n        {\\n            int j=l;\\n            while(j<Sum.size() && Sum[l]==Sum[j])\\n            {\\n                Ans+=Recursion(j,Sum,DP);\\n                j++;\\n            }\\n        }\\n        \\n        return DP[i+1]=Ans%Mod;\\n    }\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        vector<long long> Sum;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            Sum.push_back(sum);\\n        }\\n        cout<<sum;\\n        if(sum==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<long long> DP(nums.size(),-1);\\n        \\n        return Recursion(-1,Sum,DP)%Mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "I found that the Sum computation part is unnecessary here and taking 1 complete traversal, instead we can just take the sum to be the second variable with it\\'s possible values being 0 and 1 and just apply 2D dp"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "[@Minsor](/Minsor) that\\'s ok but it shall get accepted too right? It\\'s at max nlogn and shall pass according to the constraints plus I saw some dp solutions too"
                    },
                    {
                        "username": "arpansaha13",
                        "content": "At first glance this appears to be a dp problem. I too did the same mistake. But actually it has a linear time and constant space solution, which will be much faster than the dp approach.\n\n\nHint below...\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\nTry thinking about the number of subarrays you can create with two ones and a handful of zeroes in between."
                    }
                ]
            },
            {
                "id": 1943784,
                "content": [
                    {
                        "username": "rakhikumari6602",
                        "content": "I am thinking of prefix sum concept."
                    },
                    {
                        "username": "batteraOp",
                        "content": "So, the first thought most noobs like me must have had was dp, right?\\nbut I later came up with  a solution in O(n) tc which is very easy to understand\\n\\nso the points to be noticed are:\\n1. the initial and final zeroes will be added with the first and last ones only so we can ignore them while calculating the number of ways.\\n2. find the count of ones, if it is zero or one then return count (this is because if no ones are present then no good subarrays are there and if only one one is present then the array itself is the only possible good array.\\n\\nwe initialise a variable ans with one;\\n3. then we find the first occurrence and the last occurrence of ones, start iterating the array from the next index of the first occurrence, and we keep a count of zeroes and every time  we encounter a one , we multiply ans with count of zeroes plus one and update zero count to 0;\\n\\nyou can check out my solution below:\\n\\nany suggestions or criticism is welcomed!(posting for the first time,so i m sorry for any mistakes)\\n\\n\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count==0||count==1){\\n            return count;\\n        }\\n        int zeroes=0;\\n        int i,last;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                break;\\n            }\\n        }\\n        for(last=nums.length-1;last>=0;last--){\\n            if(nums[last]==1){\\n                break;\\n            }\\n        }\\n        int ans=1;\\n        for(i=i+1;i<=last;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n\\n            }else if(nums[i]==1){\\n                if(zeroes!=0){\\n                    ans=ans*(zeroes+1)%MOD;\\n                    zeroes=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    "
                    },
                    {
                        "username": "emlitke",
                        "content": "Dont post solutions"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Always try to solve a problem using recursion"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "what would be the answer if instead of exactly one 1 we are asked for atleast one 1;\nI read it atleast 1st time and wasted almost half an hour;"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Hint: just find the distance between two 1s and then multiply it to get the ans. Make sure to update the distance cuz there can be multiple ones."
                    },
                    {
                        "username": "kajal_k13",
                        "content": "how you got this intuition? "
                    },
                    {
                        "username": "harsitsinha",
                        "content": "Why is this giving TLE?? I have partitioned it and checked for the remaining right subarray. 522/553 passed.\\n\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int recurse(int index, vector<int>& nums, vector<long long> &prefix, long long prefixint, vector<long long> &memo){\\n        if(memo[index]!=-1){\\n            return memo[index];\\n        }\\n        if(index == nums.size()){\\n            return 1;\\n        }\\n        if(index>nums.size()) return 0;\\n        long long count = 0;\\n        for(int i =index;i<nums.size();i++){\\n            if(prefix[i]-prefixint==1){\\n                 count+=recurse(i+1, nums, prefix, prefix[i],memo);\\n                count%=mod;\\n            }\\n        }\\n        return memo[index] = count;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> prefix(nums.size(), 0);\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i] = sum;\\n        }\\n        long long count = 0;\\n        vector<long long> memo(nums.size()+1,-1);\\n        for(int i =0;i<nums.size();i++){\\n            if(prefix[i]==1)\\n            count += recurse(i+1, nums, prefix, 1,memo);\\n            count%=mod;\\n        }\\n        return (int)count;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    const int Mod=1e9+7;\\n    \\n    long long Recursion(long long i,vector<long long> &Sum,vector<long long> &DP)\\n    {\\n        if(i==Sum.size()-1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(DP[i+1]!=-1)\\n        {\\n            return DP[i+1];\\n        }\\n        \\n        long long x=0;\\n        if(i!=-1)\\n        {\\n            x=Sum[i];\\n        }\\n        \\n        long long Ans=0;        \\n        long long l=upper_bound(Sum.begin(),Sum.end(),x)-Sum.begin();\\n        if(l<Sum.size())\\n        {\\n            int j=l;\\n            while(j<Sum.size() && Sum[l]==Sum[j])\\n            {\\n                Ans+=Recursion(j,Sum,DP);\\n                j++;\\n            }\\n        }\\n        \\n        return DP[i+1]=Ans%Mod;\\n    }\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        vector<long long> Sum;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            Sum.push_back(sum);\\n        }\\n        cout<<sum;\\n        if(sum==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<long long> DP(nums.size(),-1);\\n        \\n        return Recursion(-1,Sum,DP)%Mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "I found that the Sum computation part is unnecessary here and taking 1 complete traversal, instead we can just take the sum to be the second variable with it\\'s possible values being 0 and 1 and just apply 2D dp"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "[@Minsor](/Minsor) that\\'s ok but it shall get accepted too right? It\\'s at max nlogn and shall pass according to the constraints plus I saw some dp solutions too"
                    },
                    {
                        "username": "arpansaha13",
                        "content": "At first glance this appears to be a dp problem. I too did the same mistake. But actually it has a linear time and constant space solution, which will be much faster than the dp approach.\n\n\nHint below...\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\nTry thinking about the number of subarrays you can create with two ones and a handful of zeroes in between."
                    }
                ]
            },
            {
                "id": 2017719,
                "content": [
                    {
                        "username": "rakhikumari6602",
                        "content": "I am thinking of prefix sum concept."
                    },
                    {
                        "username": "batteraOp",
                        "content": "So, the first thought most noobs like me must have had was dp, right?\\nbut I later came up with  a solution in O(n) tc which is very easy to understand\\n\\nso the points to be noticed are:\\n1. the initial and final zeroes will be added with the first and last ones only so we can ignore them while calculating the number of ways.\\n2. find the count of ones, if it is zero or one then return count (this is because if no ones are present then no good subarrays are there and if only one one is present then the array itself is the only possible good array.\\n\\nwe initialise a variable ans with one;\\n3. then we find the first occurrence and the last occurrence of ones, start iterating the array from the next index of the first occurrence, and we keep a count of zeroes and every time  we encounter a one , we multiply ans with count of zeroes plus one and update zero count to 0;\\n\\nyou can check out my solution below:\\n\\nany suggestions or criticism is welcomed!(posting for the first time,so i m sorry for any mistakes)\\n\\n\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count==0||count==1){\\n            return count;\\n        }\\n        int zeroes=0;\\n        int i,last;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                break;\\n            }\\n        }\\n        for(last=nums.length-1;last>=0;last--){\\n            if(nums[last]==1){\\n                break;\\n            }\\n        }\\n        int ans=1;\\n        for(i=i+1;i<=last;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n\\n            }else if(nums[i]==1){\\n                if(zeroes!=0){\\n                    ans=ans*(zeroes+1)%MOD;\\n                    zeroes=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    "
                    },
                    {
                        "username": "emlitke",
                        "content": "Dont post solutions"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Always try to solve a problem using recursion"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "what would be the answer if instead of exactly one 1 we are asked for atleast one 1;\nI read it atleast 1st time and wasted almost half an hour;"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Hint: just find the distance between two 1s and then multiply it to get the ans. Make sure to update the distance cuz there can be multiple ones."
                    },
                    {
                        "username": "kajal_k13",
                        "content": "how you got this intuition? "
                    },
                    {
                        "username": "harsitsinha",
                        "content": "Why is this giving TLE?? I have partitioned it and checked for the remaining right subarray. 522/553 passed.\\n\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int recurse(int index, vector<int>& nums, vector<long long> &prefix, long long prefixint, vector<long long> &memo){\\n        if(memo[index]!=-1){\\n            return memo[index];\\n        }\\n        if(index == nums.size()){\\n            return 1;\\n        }\\n        if(index>nums.size()) return 0;\\n        long long count = 0;\\n        for(int i =index;i<nums.size();i++){\\n            if(prefix[i]-prefixint==1){\\n                 count+=recurse(i+1, nums, prefix, prefix[i],memo);\\n                count%=mod;\\n            }\\n        }\\n        return memo[index] = count;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> prefix(nums.size(), 0);\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i] = sum;\\n        }\\n        long long count = 0;\\n        vector<long long> memo(nums.size()+1,-1);\\n        for(int i =0;i<nums.size();i++){\\n            if(prefix[i]==1)\\n            count += recurse(i+1, nums, prefix, 1,memo);\\n            count%=mod;\\n        }\\n        return (int)count;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    const int Mod=1e9+7;\\n    \\n    long long Recursion(long long i,vector<long long> &Sum,vector<long long> &DP)\\n    {\\n        if(i==Sum.size()-1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(DP[i+1]!=-1)\\n        {\\n            return DP[i+1];\\n        }\\n        \\n        long long x=0;\\n        if(i!=-1)\\n        {\\n            x=Sum[i];\\n        }\\n        \\n        long long Ans=0;        \\n        long long l=upper_bound(Sum.begin(),Sum.end(),x)-Sum.begin();\\n        if(l<Sum.size())\\n        {\\n            int j=l;\\n            while(j<Sum.size() && Sum[l]==Sum[j])\\n            {\\n                Ans+=Recursion(j,Sum,DP);\\n                j++;\\n            }\\n        }\\n        \\n        return DP[i+1]=Ans%Mod;\\n    }\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        vector<long long> Sum;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            Sum.push_back(sum);\\n        }\\n        cout<<sum;\\n        if(sum==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<long long> DP(nums.size(),-1);\\n        \\n        return Recursion(-1,Sum,DP)%Mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "I found that the Sum computation part is unnecessary here and taking 1 complete traversal, instead we can just take the sum to be the second variable with it\\'s possible values being 0 and 1 and just apply 2D dp"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "[@Minsor](/Minsor) that\\'s ok but it shall get accepted too right? It\\'s at max nlogn and shall pass according to the constraints plus I saw some dp solutions too"
                    },
                    {
                        "username": "arpansaha13",
                        "content": "At first glance this appears to be a dp problem. I too did the same mistake. But actually it has a linear time and constant space solution, which will be much faster than the dp approach.\n\n\nHint below...\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\nTry thinking about the number of subarrays you can create with two ones and a handful of zeroes in between."
                    }
                ]
            },
            {
                "id": 1943297,
                "content": [
                    {
                        "username": "rakhikumari6602",
                        "content": "I am thinking of prefix sum concept."
                    },
                    {
                        "username": "batteraOp",
                        "content": "So, the first thought most noobs like me must have had was dp, right?\\nbut I later came up with  a solution in O(n) tc which is very easy to understand\\n\\nso the points to be noticed are:\\n1. the initial and final zeroes will be added with the first and last ones only so we can ignore them while calculating the number of ways.\\n2. find the count of ones, if it is zero or one then return count (this is because if no ones are present then no good subarrays are there and if only one one is present then the array itself is the only possible good array.\\n\\nwe initialise a variable ans with one;\\n3. then we find the first occurrence and the last occurrence of ones, start iterating the array from the next index of the first occurrence, and we keep a count of zeroes and every time  we encounter a one , we multiply ans with count of zeroes plus one and update zero count to 0;\\n\\nyou can check out my solution below:\\n\\nany suggestions or criticism is welcomed!(posting for the first time,so i m sorry for any mistakes)\\n\\n\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int ones=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count==0||count==1){\\n            return count;\\n        }\\n        int zeroes=0;\\n        int i,last;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                break;\\n            }\\n        }\\n        for(last=nums.length-1;last>=0;last--){\\n            if(nums[last]==1){\\n                break;\\n            }\\n        }\\n        int ans=1;\\n        for(i=i+1;i<=last;i++){\\n            if(nums[i]==0){\\n                zeroes++;\\n\\n            }else if(nums[i]==1){\\n                if(zeroes!=0){\\n                    ans=ans*(zeroes+1)%MOD;\\n                    zeroes=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    "
                    },
                    {
                        "username": "emlitke",
                        "content": "Dont post solutions"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Always try to solve a problem using recursion"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "what would be the answer if instead of exactly one 1 we are asked for atleast one 1;\nI read it atleast 1st time and wasted almost half an hour;"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Hint: just find the distance between two 1s and then multiply it to get the ans. Make sure to update the distance cuz there can be multiple ones."
                    },
                    {
                        "username": "kajal_k13",
                        "content": "how you got this intuition? "
                    },
                    {
                        "username": "harsitsinha",
                        "content": "Why is this giving TLE?? I have partitioned it and checked for the remaining right subarray. 522/553 passed.\\n\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int recurse(int index, vector<int>& nums, vector<long long> &prefix, long long prefixint, vector<long long> &memo){\\n        if(memo[index]!=-1){\\n            return memo[index];\\n        }\\n        if(index == nums.size()){\\n            return 1;\\n        }\\n        if(index>nums.size()) return 0;\\n        long long count = 0;\\n        for(int i =index;i<nums.size();i++){\\n            if(prefix[i]-prefixint==1){\\n                 count+=recurse(i+1, nums, prefix, prefix[i],memo);\\n                count%=mod;\\n            }\\n        }\\n        return memo[index] = count;\\n    }\\n    int numberOfGoodSubarraySplits(vector<int>& nums) {\\n        vector<long long> prefix(nums.size(), 0);\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i] = sum;\\n        }\\n        long long count = 0;\\n        vector<long long> memo(nums.size()+1,-1);\\n        for(int i =0;i<nums.size();i++){\\n            if(prefix[i]==1)\\n            count += recurse(i+1, nums, prefix, 1,memo);\\n            count%=mod;\\n        }\\n        return (int)count;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    const int Mod=1e9+7;\\n    \\n    long long Recursion(long long i,vector<long long> &Sum,vector<long long> &DP)\\n    {\\n        if(i==Sum.size()-1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(DP[i+1]!=-1)\\n        {\\n            return DP[i+1];\\n        }\\n        \\n        long long x=0;\\n        if(i!=-1)\\n        {\\n            x=Sum[i];\\n        }\\n        \\n        long long Ans=0;        \\n        long long l=upper_bound(Sum.begin(),Sum.end(),x)-Sum.begin();\\n        if(l<Sum.size())\\n        {\\n            int j=l;\\n            while(j<Sum.size() && Sum[l]==Sum[j])\\n            {\\n                Ans+=Recursion(j,Sum,DP);\\n                j++;\\n            }\\n        }\\n        \\n        return DP[i+1]=Ans%Mod;\\n    }\\n    \\n    int numberOfGoodSubarraySplits(vector<int>& nums)\\n    {\\n        vector<long long> Sum;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            Sum.push_back(sum);\\n        }\\n        cout<<sum;\\n        if(sum==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<long long> DP(nums.size(),-1);\\n        \\n        return Recursion(-1,Sum,DP)%Mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "I found that the Sum computation part is unnecessary here and taking 1 complete traversal, instead we can just take the sum to be the second variable with it\\'s possible values being 0 and 1 and just apply 2D dp"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "[@Minsor](/Minsor) that\\'s ok but it shall get accepted too right? It\\'s at max nlogn and shall pass according to the constraints plus I saw some dp solutions too"
                    },
                    {
                        "username": "arpansaha13",
                        "content": "At first glance this appears to be a dp problem. I too did the same mistake. But actually it has a linear time and constant space solution, which will be much faster than the dp approach.\n\n\nHint below...\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\nTry thinking about the number of subarrays you can create with two ones and a handful of zeroes in between."
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Even Odd Subarray With Threshold",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>threshold</code>.</p>\n\n<p>Find the length of the <strong>longest subarray</strong> of <code>nums</code> starting at index <code>l</code> and ending at index <code>r</code> <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> that satisfies the following conditions:</p>\n\n<ul>\n\t<li><code>nums[l] % 2 == 0</code></li>\n\t<li>For all indices <code>i</code> in the range <code>[l, r - 1]</code>, <code>nums[i] % 2 != nums[i + 1] % 2</code></li>\n\t<li>For all indices <code>i</code> in the range <code>[l, r]</code>, <code>nums[i] &lt;= threshold</code></li>\n</ul>\n\n<p>Return <em>an integer denoting the length of the longest such subarray.</em></p>\n\n<p><strong>Note:</strong> A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,5,4], threshold = 5\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> In this example, we can select the subarray that starts at l = 1 and ends at r = 3 =&gt; [2,5,4]. This subarray satisfies the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2], threshold = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> In this example, we can select the subarray that starts at l = 1 and ends at r = 1 =&gt; [2]. \nIt satisfies all the conditions and we can show that 1 is the maximum possible achievable length.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,4,5], threshold = 4\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> In this example, we can select the subarray that starts at l = 0 and ends at r = 2 =&gt; [2,3,4]. \nIt satisfies all the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100 </code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100 </code></li>\n\t<li><code>1 &lt;= threshold &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3706400,
                "title": "sliding-window-very-simple-and-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nint longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n    int ans = 0, i = 0, last = INT_MAX;\\n    while(i < nums.size()){\\n        if(nums[i] > threshold || (i > 0 && (nums[i] % 2) == (nums[i-1] % 2)) ){\\n            ans = max(ans, i - last );\\n            last = INT_MAX;\\n        }\\n        if(last == INT_MAX && nums[i] <= threshold && nums[i] % 2 == 0) last = i;\\n        i++;\\n    }\\n    ans = max(ans, i - last );\\n    return ans;\\n}\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n    int ans = 0, i = 0, last = INT_MAX;\\n    while(i < nums.size()){\\n        if(nums[i] > threshold || (i > 0 && (nums[i] % 2) == (nums[i-1] % 2)) ){\\n            ans = max(ans, i - last );\\n            last = INT_MAX;\\n        }\\n        if(last == INT_MAX && nums[i] <= threshold && nums[i] % 2 == 0) last = i;\\n        i++;\\n    }\\n    ans = max(ans, i - last );\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706650,
                "title": "sliding-window-c-java-clean-easy-to-understand",
                "content": "### Connect on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n# Please Upvote if u found it useful\\uD83E\\uDD17\\n# *C++ Code:-*\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int th) {\\n        int n = nums.size(),maxi = 0,i = 0,j = 0,flag = 0;\\n        while(j < n){\\n            if(flag == 0){\\n               if(nums[j] % 2 == 0 && nums[j] <= th){\\n                    i = j;\\n                    maxi = max(maxi,j - i + 1);\\n                    flag = 1;\\n                } \\n            }\\n            else if(flag == 1){\\n                int x = nums[j-1],y = nums[j],c = x + y;\\n                if(c % 2 && nums[j] <= th) //if we add 2 even nos or add 2 odd nos then we will always get an even number whereas if we add an odd no with an even no then we will always get an odd number\\n                    maxi = max(maxi,j - i + 1);\\n                else{\\n                    flag = 0;\\n                    j--; \\n                }\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n# *JAVA Code :-*\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int th) {\\n        int n = nums.length,maxi = 0,i = 0,j = 0,flag = 0;\\n        while(j < n){\\n            if(flag == 0){\\n               if(nums[j] % 2 == 0 && nums[j] <= th){\\n                    i = j;\\n                    maxi = Math.max(maxi,j - i + 1);\\n                    flag = 1;\\n                } \\n            }\\n            else if(flag == 1){\\n                int x = nums[j-1],y = nums[j],c = x + y;\\n                if(c % 2 != 0 && nums[j] <= th)\\n                    maxi = Math.max(maxi,j - i + 1);\\n                else{\\n                    flag = 0;\\n                    j--;\\n                }\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n}\\n```\\n# *Python3 Code:-*\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, th):\\n        n = len(nums)\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        flag = 0\\n\\n        while j < n:\\n            if flag == 0:\\n                if nums[j] % 2 == 0 and nums[j] <= th:\\n                    i = j\\n                    maxi = max(maxi, j - i + 1)\\n                    flag = 1\\n            elif flag == 1:\\n                x = nums[j - 1]\\n                y = nums[j]\\n                c = x + y\\n                if c % 2 and nums[j] <= th:\\n                    maxi = max(maxi, j - i + 1)\\n                else:\\n                    flag = 0\\n                    j -= 1\\n            j += 1\\n\\n        return maxi\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/628fabf9-c652-4443-ae13-61126ed2263f_1688274211.4904199.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int th) {\\n        int n = nums.size(),maxi = 0,i = 0,j = 0,flag = 0;\\n        while(j < n){\\n            if(flag == 0){\\n               if(nums[j] % 2 == 0 && nums[j] <= th){\\n                    i = j;\\n                    maxi = max(maxi,j - i + 1);\\n                    flag = 1;\\n                } \\n            }\\n            else if(flag == 1){\\n                int x = nums[j-1],y = nums[j],c = x + y;\\n                if(c % 2 && nums[j] <= th) //if we add 2 even nos or add 2 odd nos then we will always get an even number whereas if we add an odd no with an even no then we will always get an odd number\\n                    maxi = max(maxi,j - i + 1);\\n                else{\\n                    flag = 0;\\n                    j--; \\n                }\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int th) {\\n        int n = nums.length,maxi = 0,i = 0,j = 0,flag = 0;\\n        while(j < n){\\n            if(flag == 0){\\n               if(nums[j] % 2 == 0 && nums[j] <= th){\\n                    i = j;\\n                    maxi = Math.max(maxi,j - i + 1);\\n                    flag = 1;\\n                } \\n            }\\n            else if(flag == 1){\\n                int x = nums[j-1],y = nums[j],c = x + y;\\n                if(c % 2 != 0 && nums[j] <= th)\\n                    maxi = Math.max(maxi,j - i + 1);\\n                else{\\n                    flag = 0;\\n                    j--;\\n                }\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, th):\\n        n = len(nums)\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        flag = 0\\n\\n        while j < n:\\n            if flag == 0:\\n                if nums[j] % 2 == 0 and nums[j] <= th:\\n                    i = j\\n                    maxi = max(maxi, j - i + 1)\\n                    flag = 1\\n            elif flag == 1:\\n                x = nums[j - 1]\\n                y = nums[j]\\n                c = x + y\\n                if c % 2 and nums[j] <= th:\\n                    maxi = max(maxi, j - i + 1)\\n                else:\\n                    flag = 0\\n                    j -= 1\\n            j += 1\\n\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706665,
                "title": "easy-intuition-brute-force-approach",
                "content": "# Intuition\\nThe code finds the length of the longest subarray in a given vector of numbers. The subarray must alternate between even and odd numbers, and each number must be less than or equal to a given threshold.\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0, curr = 1, n = nums.size();\\n        \\n        // Check if the input vector is empty\\n        if (n == 0) \\n            return n;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Check if the current number is even, less than or equal to the threshold,\\n            // and it is the first even number encountered in the subarray\\n            if (nums[i] % 2 == 0 && ans == 0 && nums[i] <= threshold) \\n                ans = 1; \\n            \\n            for (int j = i + 1; j < n; j++) {\\n                // Check if the current number is even, the next number is odd (alternating),\\n                // less than or equal to the threshold, and update the length of the current subarray\\n                if (nums[i] % 2 == 0 && nums[j] % 2 != nums[j - 1] % 2 && nums[j] <= threshold && nums[i] <= threshold )  {\\n                    curr++;\\n                    ans = max(ans, curr);\\n                } else \\n                    break;\\n            }\\n            curr = 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0, curr = 1, n = nums.size();\\n        \\n        // Check if the input vector is empty\\n        if (n == 0) \\n            return n;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Check if the current number is even, less than or equal to the threshold,\\n            // and it is the first even number encountered in the subarray\\n            if (nums[i] % 2 == 0 && ans == 0 && nums[i] <= threshold) \\n                ans = 1; \\n            \\n            for (int j = i + 1; j < n; j++) {\\n                // Check if the current number is even, the next number is odd (alternating),\\n                // less than or equal to the threshold, and update the length of the current subarray\\n                if (nums[i] % 2 == 0 && nums[j] % 2 != nums[j - 1] % 2 && nums[j] <= threshold && nums[i] <= threshold )  {\\n                    curr++;\\n                    ans = max(ans, curr);\\n                } else \\n                    break;\\n            }\\n            curr = 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706604,
                "title": "typical-dp-problem-intuition-explained",
                "content": "> Variation of [674. Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)\\n# Intuition:\\nIt is same as that of typical DP problems where we need to find subarray where a property is followed among every pair of subarray.\\n\\n# Why DP ?\\nWe know that our answer will end at a particular index, right??\\nIf we compute such subarray length till every index.\\nOur answer will be maximum of all the lengths computed.\\n\\n# Choices :\\n+ For an element to start a subarray:\\n    - It should be **even** && should be <= **threshold**\\n+ For an element to pair up with its previous element:\\n    - It should be **odd** and previous should **even** or **vice versa**.\\n    - Both should be <= **threshold**\\n  \\n# C++ (DP) :\\n    bool OddEven(int a, int b) {\\n        return (a & 1) != (b & 1);\\n    }\\n    \\n    int longestAlternatingSubarray(vector<int>& A, int K) {\\n        int cnt = 0, res = 0;\\n        for(int i = 0;i < size(A); ++i) {\\n            if(i > 0 && OddEven(A[i], A[i - 1]) && max(A[i], A[i - 1]) <= K) ++cnt; \\n            else cnt = A[i] % 2 == 0 && A[i] <= K;\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "> Variation of [674. Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)\\n# Intuition:\\nIt is same as that of typical DP problems where we need to find subarray where a property is followed among every pair of subarray.\\n\\n# Why DP ?\\nWe know that our answer will end at a particular index, right??\\nIf we compute such subarray length till every index.\\nOur answer will be maximum of all the lengths computed.\\n\\n# Choices :\\n+ For an element to start a subarray:\\n    - It should be **even** && should be <= **threshold**\\n+ For an element to pair up with its previous element:\\n    - It should be **odd** and previous should **even** or **vice versa**.\\n    - Both should be <= **threshold**\\n  \\n# C++ (DP) :\\n    bool OddEven(int a, int b) {\\n        return (a & 1) != (b & 1);\\n    }\\n    \\n    int longestAlternatingSubarray(vector<int>& A, int K) {\\n        int cnt = 0, res = 0;\\n        for(int i = 0;i < size(A); ++i) {\\n            if(i > 0 && OddEven(A[i], A[i - 1]) && max(A[i], A[i - 1]) <= K) ++cnt; \\n            else cnt = A[i] % 2 == 0 && A[i] <= K;\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3706503,
                "title": "o-n",
                "content": "Alternating subarrays cannot overlap.\\n\\nSo, we start over when two consecutive numbers have the same parity, resulting in a linear solution.\\n\\n**C++**\\n```cpp\\nint longestAlternatingSubarray(vector<int>& n, int threshold) {\\n    int res = 0;\\n    for (int l = 0, cnt = 0; l < n.size(); ++l) {\\n        if (n[l] <= threshold)\\n            cnt = cnt == 0 ?\\n                n[l] % 2 == 0 :\\n                n[l] % 2 == n[l - 1] % 2 ? n[l] % 2 == 0 : cnt + 1;\\n        else\\n            cnt = 0;\\n        res = max(res, cnt);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint longestAlternatingSubarray(vector<int>& n, int threshold) {\\n    int res = 0;\\n    for (int l = 0, cnt = 0; l < n.size(); ++l) {\\n        if (n[l] <= threshold)\\n            cnt = cnt == 0 ?\\n                n[l] % 2 == 0 :\\n                n[l] % 2 == n[l - 1] % 2 ? n[l] % 2 == 0 : cnt + 1;\\n        else\\n            cnt = 0;\\n        res = max(res, cnt);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3711574,
                "title": "c-solution-python-java-easy-understanding-brute-force",
                "content": "`Time complexity: ` $$O(n^2)$$\\n\\n`Space complexity: `$$O(1)$$\\n\\n\\n# $$C++$$\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& v, int k) {\\n        int ans = 0;\\n        for(int i = 0;i < v.size();i++){\\n            int ct = 0;\\n            if((v[i] % 2 == 0) && (v[i] <= k)){\\n                ct = 1;\\n                for(int j = i + 1;j < v.size();j++){\\n                    if((v[j] % 2 == v[j - 1] % 2) || v[j] > k) break;\\n                    ct++;\\n                }\\n            }\\n            \\n            ans = max(ans,ct);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# $$Python$$\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans\\n\\n\\n```\\n\\n# $$Java$$ \\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i]%2==0 && nums[i]<=threshold) {\\n                int e = i+1;\\n                while(e<n && nums[e]<=threshold && nums[e]%2!=nums[e-1]%2){\\n                    e++;\\n                }\\n                ans = Math.max(ans, e-i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n![upvote(jaishreeram).jpeg](https://assets.leetcode.com/users/images/d4a58e4a-a55b-4fa9-8084-f11769260dee_1688368454.7835622.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& v, int k) {\\n        int ans = 0;\\n        for(int i = 0;i < v.size();i++){\\n            int ct = 0;\\n            if((v[i] % 2 == 0) && (v[i] <= k)){\\n                ct = 1;\\n                for(int j = i + 1;j < v.size();j++){\\n                    if((v[j] % 2 == v[j - 1] % 2) || v[j] > k) break;\\n                    ct++;\\n                }\\n            }\\n            \\n            ans = max(ans,ct);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans\\n\\n\\n```\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i]%2==0 && nums[i]<=threshold) {\\n                int e = i+1;\\n                while(e<n && nums[e]<=threshold && nums[e]%2!=nums[e-1]%2){\\n                    e++;\\n                }\\n                ans = Math.max(ans, e-i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707007,
                "title": "easy-java-solution",
                "content": "Please upvote if you like :)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int val) {\\n        int n=nums.length;\\n        //if(n<=2 && nums[n-1]%2==0 && nums[n-1]<=threshold) return 1;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] %2 ==0 && nums[i]<=val){\\n                int j=i+1;\\n                while(j < n && nums[j] <= val && (nums[j] % 2 != nums[j - 1] % 2)){\\n                    j++;\\n                }\\n                count=Math.max(count,j-i);\\n            }\\n            else continue;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int val) {\\n        int n=nums.length;\\n        //if(n<=2 && nums[n-1]%2==0 && nums[n-1]<=threshold) return 1;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] %2 ==0 && nums[i]<=val){\\n                int j=i+1;\\n                while(j < n && nums[j] <= val && (nums[j] % 2 != nums[j - 1] % 2)){\\n                    j++;\\n                }\\n                count=Math.max(count,j-i);\\n            }\\n            else continue;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706619,
                "title": "sliding-window-explained-simple-java-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use the Sliding Window Technique to find the longest subarray that also satisfies the given conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start at each possible left index and go right as far as you can.\\n- For each iteration, check whether the conditions are satisfied:\\n    - If the conditions are not satisfied, store the maximum of *previous* and *current* possible subarray length in answer.\\n    - If the conditions are satisfied, increase the length of subarray\\n- Return the maximum possible subarray length that satisfies the given conditions.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int answer = 0, i = 1, r = Integer.MAX_VALUE;\\n        if(nums[0] <= threshold && nums[0] % 2 == 0) {\\n            r = 0;\\n        }\\n        while(i < nums.length){\\n            if( nums[i] > threshold || ((nums[i] % 2) == (nums[i-1] % 2)) ){\\n                // Conditions not satisfied\\n                answer = Math.max(answer, i - r );\\n                r = Integer.MAX_VALUE;\\n            }\\n            if(r == Integer.MAX_VALUE && nums[i] <= threshold && nums[i] % 2 == 0){\\n                // Conditions satisfied - increase the length of subarray\\n                r = i;\\n            }\\n            i++;\\n        }\\n        answer = Math.max(answer, i - r );\\n        return answer;\\n    }\\n}\\n```\\n\\n### Please upvote if you find the answer helpful",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int answer = 0, i = 1, r = Integer.MAX_VALUE;\\n        if(nums[0] <= threshold && nums[0] % 2 == 0) {\\n            r = 0;\\n        }\\n        while(i < nums.length){\\n            if( nums[i] > threshold || ((nums[i] % 2) == (nums[i-1] % 2)) ){\\n                // Conditions not satisfied\\n                answer = Math.max(answer, i - r );\\n                r = Integer.MAX_VALUE;\\n            }\\n            if(r == Integer.MAX_VALUE && nums[i] <= threshold && nums[i] % 2 == 0){\\n                // Conditions satisfied - increase the length of subarray\\n                r = i;\\n            }\\n            i++;\\n        }\\n        answer = Math.max(answer, i - r );\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709377,
                "title": "brute-force-to-sliding-window-n-2-to-n",
                "content": "# Bruteforce Solution:\\n``` Java []\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i]%2==0 && nums[i]<=threshold) {\\n                int e = i+1;\\n                while(e<n && nums[e]<=threshold && nums[e]%2!=nums[e-1]%2){\\n                    e++;\\n                }\\n                ans = Math.max(ans, e-i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\nThe constrains were:\\n    - `1 <= nums.length <= 100 `\\n    - `1 <= nums[i] <= 100 `\\n    - `1 <= threshold <= 100`\\n\\nFor this, $$O(N^2)$$ solution will pass very easily.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nNo new array was declared.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Sliding Window Solution:\\n\\n``` Java []\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0, i=1, l = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        // check for first element\\n        if(nums[0] <= threshold && nums[0]%2 == 0) {\\n            l = 0;\\n        }\\n        while(i < n) {\\n            if(nums[i] > threshold || nums[i]%2 == nums[i-1]%2) {\\n                ans = Math.max(ans, i-l);\\n                l = Integer.MAX_VALUE;\\n            }\\n            if(l == Integer.MAX_VALUE && nums[i] <= threshold && nums[i]%2 == 0) {\\n                l = i;\\n            }\\n            i++;\\n        }\\n        // the last element may fall under the second if condition, therefore need to calculate including it.\\n        ans = Math.max(i-l, ans);\\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: $$O(N)$$\\nWe iterate the loop only once in the while loop.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nNo new array was declared.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i]%2==0 && nums[i]<=threshold) {\\n                int e = i+1;\\n                while(e<n && nums[e]<=threshold && nums[e]%2!=nums[e-1]%2){\\n                    e++;\\n                }\\n                ans = Math.max(ans, e-i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0, i=1, l = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        // check for first element\\n        if(nums[0] <= threshold && nums[0]%2 == 0) {\\n            l = 0;\\n        }\\n        while(i < n) {\\n            if(nums[i] > threshold || nums[i]%2 == nums[i-1]%2) {\\n                ans = Math.max(ans, i-l);\\n                l = Integer.MAX_VALUE;\\n            }\\n            if(l == Integer.MAX_VALUE && nums[i] <= threshold && nums[i]%2 == 0) {\\n                l = i;\\n            }\\n            i++;\\n        }\\n        // the last element may fall under the second if condition, therefore need to calculate including it.\\n        ans = Math.max(i-l, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706696,
                "title": "c-most-easiest-solution-brute-force-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First loop iterate to find the starting index i.e. l  and check if\\nnums[i]%2 == 0 && nums[i] <= threshold\\n\\n2. 2nd loop to find continuous subarray with reamining two condition \\ni.e.  (nums[j]%2 != nums[j+1]%2)  && nums[j+1] <= threshold) else break\\n\\n3. Within all the possible subarray return the length of max sized subarray with count and c variable\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int count = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]%2 == 0 && nums[i] <= threshold){\\n                int c = 1;\\n                for(; i<nums.size()-1; i++){\\n                    if((nums[i]%2 != nums[i+1]%2)  && nums[i+1] <= threshold)\\n                        c++;\\n                    else \\n                        break;\\n                }\\n                \\n                count = max(count,c);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int count = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]%2 == 0 && nums[i] <= threshold){\\n                int c = 1;\\n                for(; i<nums.size()-1; i++){\\n                    if((nums[i]%2 != nums[i+1]%2)  && nums[i+1] <= threshold)\\n                        c++;\\n                    else \\n                        break;\\n                }\\n                \\n                count = max(count,c);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709278,
                "title": "python-3-12-lines-w-explanation-t-m-100-54",
                "content": "Here\\'s how the code works:\\n\\nThe variables `ans` and `cnt` are initialized to 0. `ans` stores the length of the current longest subarray, and `cnt` will keep track of the length of the current subarray being examined.\\n\\nWe iterate over the elements of`nums`, noting which of three conditions, which determines the length of the current subarray:\\n\\n- If `num` is greater than threshold, it means the current subarray cannot continue, so `cnt` is reset to 0.\\n\\n- If cnt is non-zero (c`nt != 0`) and the parity (even/odd) of the previous number (`parity`) is different from the parity of the current number (`num%2`), it means the current subarray can continue, so `cnt` is incremented by 1. The parity is updated by XORing (`parity^= 1`) the current parity value with 1.\\n\\n- If the above conditions are not met, it means a new subarray with a different parity needs to be started. The current number determines the parity, and `cnt` is set to the opposite parity (`parity^1`).\\n\\nAfter updating `cnt` based on the conditions, the code updates`ans`.\\n\\nOnce the loop is finished, the code returns`ans`, which represents the length of the longest subarray satisfying the conditions. --*ChatGPT*\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n\\n        ans, cnt = 0, 0\\n\\n        for i, num in enumerate(nums):\\n\\n            if num > threshold:\\n                cnt = 0\\n\\n            elif cnt and parity != num%2:\\n                parity^= 1\\n                cnt+= 1\\n\\n            else:\\n                parity = num%2\\n                cnt = parity^1\\n\\n            ans = max(ans, cnt)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/longest-even-odd-subarray-with-threshold/submissions/984648317/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n\\n        ans, cnt = 0, 0\\n\\n        for i, num in enumerate(nums):\\n\\n            if num > threshold:\\n                cnt = 0\\n\\n            elif cnt and parity != num%2:\\n                parity^= 1\\n                cnt+= 1\\n\\n            else:\\n                parity = num%2\\n                cnt = parity^1\\n\\n            ans = max(ans, cnt)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707408,
                "title": "c-intuitive-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold)\\n    {\\n        int n = nums.size();\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] % 2 == 0 && nums[i] <= threshold)\\n            {\\n                int cnt = 1;\\n\\n                for(int j=i+1; j<n; j++)\\n                {\\n                    if(nums[j]%2 != nums[j-1]%2 && nums[j] <= threshold)\\n                        cnt++;\\n                    else\\n                        break;\\n                }\\n\\n                ans = max(ans, cnt);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold)\\n    {\\n        int n = nums.size();\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] % 2 == 0 && nums[i] <= threshold)\\n            {\\n                int cnt = 1;\\n\\n                for(int j=i+1; j<n; j++)\\n                {\\n                    if(nums[j]%2 != nums[j-1]%2 && nums[j] <= threshold)\\n                        cnt++;\\n                    else\\n                        break;\\n                }\\n\\n                ans = max(ans, cnt);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706846,
                "title": "c-simple-9-lines-o-n-sliding-window",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int L=0, R=0, ans=0, n=nums.size();        \\n        while(L<n && R<n) \\n            if(! (nums[L]%2==0 && nums[L]<=threshold)) \\n                R=++L; \\n            else if(R+1<n && nums[R+1]<=threshold && nums[R]%2!=nums[R+1]%2) \\n                ans = max(ans, ++R-L+1);\\n            else \\n                L=++R, ans = max(ans ,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int L=0, R=0, ans=0, n=nums.size();        \\n        while(L<n && R<n) \\n            if(! (nums[L]%2==0 && nums[L]<=threshold)) \\n                R=++L; \\n            else if(R+1<n && nums[R+1]<=threshold && nums[R]%2!=nums[R+1]%2) \\n                ans = max(ans, ++R-L+1);\\n            else \\n                L=++R, ans = max(ans ,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706552,
                "title": "two-pointer-approach-o-n-time-and-o-1-space",
                "content": "# Intuition\\nIt is a basic two pointer approach where we have to maintain two pointer. \\n\\n\\n# Approach\\nIn this approach we fix the backward pointer and increment the forward pointer such that condition is met.\\nWhen we find the condition is not met then we break the loop update the backward pointer and repeat until all the elements are scanned\\nHere, \\ni-> backward pointer\\nj -> forward pointer\\ncondition to be met -> alternate even-odd subarray with starting element as even all the elements are smaller than threshold\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int t) {\\n        int len = 0, i = 0, j = 0;\\n        while( i<nums.size() ){\\n            // if i does not meet conditon then move forward\\n            if( nums[i]%2!=0 or nums[i]>t ){\\n                i++;\\n                continue;\\n            }\\n            int j = i; \\n            int curr = 0;\\n            // increment the j until the condition are met or it reaches the end\\n            // here we have used curr to mark if element should be even or odd\\n            while( j<nums.size() and nums[j]%2==curr and nums[j]<=t ){\\n                j++;\\n                curr = (curr+1)%2;\\n            }\\n            \\n            len = max(len,j-i);\\n            i = j;\\n        } \\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int t) {\\n        int len = 0, i = 0, j = 0;\\n        while( i<nums.size() ){\\n            // if i does not meet conditon then move forward\\n            if( nums[i]%2!=0 or nums[i]>t ){\\n                i++;\\n                continue;\\n            }\\n            int j = i; \\n            int curr = 0;\\n            // increment the j until the condition are met or it reaches the end\\n            // here we have used curr to mark if element should be even or odd\\n            while( j<nums.size() and nums[j]%2==curr and nums[j]<=t ){\\n                j++;\\n                curr = (curr+1)%2;\\n            }\\n            \\n            len = max(len,j-i);\\n            i = j;\\n        } \\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706403,
                "title": "c-very-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            if(nums[i]%2 == 0){\\n                int j;\\n                for(j=i+1; j<n; j++){\\n                    if((nums[j-1]%2 != nums[j]%2) && (nums[j-1] <= threshold)){\\n                        cnt++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(nums[j-1]<=threshold){\\n                    cnt++;\\n                }\\n            }\\n            ans = max(ans, cnt);\\n        }\\n    \\xA0\\xA0\\xA0\\xA0return\\xA0ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            if(nums[i]%2 == 0){\\n                int j;\\n                for(j=i+1; j<n; j++){\\n                    if((nums[j-1]%2 != nums[j]%2) && (nums[j-1] <= threshold)){\\n                        cnt++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(nums[j-1]<=threshold){\\n                    cnt++;\\n                }\\n            }\\n            ans = max(ans, cnt);\\n        }\\n    \\xA0\\xA0\\xA0\\xA0return\\xA0ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706676,
                "title": "110-understandable-simple-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int ans=0;\\n        for(int l=0;l<n;l++)\\n        {\\n            if(nums[l]%2!=0) continue;\\n            int r;\\n            int len=0;\\n            for(r=l;r<n-1;r++)\\n            {\\n                if(nums[r]%2==nums[r+1]%2) break;\\n                if(nums[r]>k) break;\\n                len=(r-l+1);\\n            }\\n            if(nums[r]<=k) len++; //because at r==n-1 also need to check \\n            ans=max(ans,len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int ans=0;\\n        for(int l=0;l<n;l++)\\n        {\\n            if(nums[l]%2!=0) continue;\\n            int r;\\n            int len=0;\\n            for(r=l;r<n-1;r++)\\n            {\\n                if(nums[r]%2==nums[r+1]%2) break;\\n                if(nums[r]>k) break;\\n                len=(r-l+1);\\n            }\\n            if(nums[r]<=k) len++; //because at r==n-1 also need to check \\n            ans=max(ans,len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735792,
                "title": "simple-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int maxLen = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0 && nums[i]<= threshold ){\\n                int count = 1;\\n                for(int j=i; j<nums.length-1; j++){\\n                    if(nums[j]%2 != nums[j+1]%2 && nums[j+1]<=threshold){\\n                        count++; \\n                    }\\n                    else{\\n                        break;\\n                    }\\n                 }\\n                 maxLen = Math.max(maxLen, count);\\n            }\\n            \\n        }\\n\\n        return maxLen;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int maxLen = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0 && nums[i]<= threshold ){\\n                int count = 1;\\n                for(int j=i; j<nums.length-1; j++){\\n                    if(nums[j]%2 != nums[j+1]%2 && nums[j+1]<=threshold){\\n                        count++; \\n                    }\\n                    else{\\n                        break;\\n                    }\\n                 }\\n                 maxLen = Math.max(maxLen, count);\\n            }\\n            \\n        }\\n\\n        return maxLen;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727385,
                "title": "o-n-python",
                "content": "Note : Every element is visited only once, do not get confused w the nested while loops.\\n```\\n        i = 0\\n        sz = maxi = 0\\n        \\n        while i<len(nums):\\n            if nums[i]%2==0 and nums[i]<=threshold:\\n                start = i\\n                while i < len(nums)-1 and nums[i] % 2 != nums[i + 1] % 2 and nums[i+1]<=threshold:\\n                    i += 1\\n                sz = i-start+1\\n                maxi = max(maxi,sz)\\n            i += 1\\n        \\n        return maxi\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        i = 0\\n        sz = maxi = 0\\n        \\n        while i<len(nums):\\n            if nums[i]%2==0 and nums[i]<=threshold:\\n                start = i\\n                while i < len(nums)-1 and nums[i] % 2 != nums[i + 1] % 2 and nums[i+1]<=threshold:\\n                    i += 1\\n                sz = i-start+1\\n                maxi = max(maxi,sz)\\n            i += 1\\n        \\n        return maxi\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719207,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int n = nums.length, left = 0, right = 0, res = 0;\\n        while (right < n) {\\n            while (left < n && \\n                   (nums[left] % 2 == 1 || \\n                    nums[left] > threshold)) {\\n                left++;\\n            }\\n            if (left == n) break;\\n            right = left;\\n            while (right + 1 < n && \\n                   nums[right] % 2 != nums[right + 1] % 2 && \\n                   nums[right + 1] <= threshold) {\\n                right++;\\n            }\\n            res = Math.max(res, right - left + 1);\\n            right++;\\n            left = right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int n = nums.length, left = 0, right = 0, res = 0;\\n        while (right < n) {\\n            while (left < n && \\n                   (nums[left] % 2 == 1 || \\n                    nums[left] > threshold)) {\\n                left++;\\n            }\\n            if (left == n) break;\\n            right = left;\\n            while (right + 1 < n && \\n                   nums[right] % 2 != nums[right + 1] % 2 && \\n                   nums[right + 1] <= threshold) {\\n                right++;\\n            }\\n            res = Math.max(res, right - left + 1);\\n            right++;\\n            left = right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712735,
                "title": "c-solution-o-n-time-complexity",
                "content": "\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere you just have to find the longest subarray with even odd even odd... elements \\n\\nBelow ,is the simple written code for this aproach.. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n\\n       int count =0 ,n=nums.size();\\n\\n       for(int i=0 ;i<n;i++){\\n           if(nums[i]%2==0 && nums[i]<=threshold){\\n             int c=1;\\n             for(;i<n-1;i++){\\n                 if(nums[i]%2 != nums[i+1]%2 && nums[i+1]<=threshold){\\n                     c++;\\n                 }\\n                 else {\\n                     break;\\n                 }\\n             }\\n\\n             count=max(count,c);\\n           }\\n       } \\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n\\n       int count =0 ,n=nums.size();\\n\\n       for(int i=0 ;i<n;i++){\\n           if(nums[i]%2==0 && nums[i]<=threshold){\\n             int c=1;\\n             for(;i<n-1;i++){\\n                 if(nums[i]%2 != nums[i+1]%2 && nums[i+1]<=threshold){\\n                     c++;\\n                 }\\n                 else {\\n                     break;\\n                 }\\n             }\\n\\n             count=max(count,c);\\n           }\\n       } \\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706609,
                "title": "python-double-pointer-with-comment",
                "content": "# Code\\n```python[]\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        ans = 0\\n        for l in range(len(nums)):\\n            # check nums[l] is valid\\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\\n                ans = max(ans, 1) # nums[l] is valid\\n                # check l+1 to the last element\\n                # break if any condition is not satisfied\\n                for r in range(l+1, len(nums)):\\n                    if nums[r] % 2 == nums[r-1] % 2:\\n                        break\\n                    if nums[r] > threshold:\\n                        break\\n                    # if ok, the length is r-l+1\\n                    ans = max(ans, r - l + 1)\\n        return ans\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python[]\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        ans = 0\\n        for l in range(len(nums)):\\n            # check nums[l] is valid\\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\\n                ans = max(ans, 1) # nums[l] is valid\\n                # check l+1 to the last element\\n                # break if any condition is not satisfied\\n                for r in range(l+1, len(nums)):\\n                    if nums[r] % 2 == nums[r-1] % 2:\\n                        break\\n                    if nums[r] > threshold:\\n                        break\\n                    # if ok, the length is r-l+1\\n                    ans = max(ans, r - l + 1)\\n        return ans\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826564,
                "title": "o-n-solution-faster-than-100",
                "content": "\\n\\n# Approach\\nWe iterate over the array with a left pointer, and for each even number that is not greater than the threshold, we try to extend a subarray to the right as far as possible. Once we cannot extend the subarray anymore, we update the maximum length and skip all the elements that have already been considered\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function (nums, threshold) {\\n\\n    let maxLength = 0;\\n\\n    for (let left = 0; left < nums.length; left++) {\\n\\n        // Skip if the number is odd or larger than the threshold\\n        if (nums[left] > threshold || nums[left] % 2 !== 0) continue;\\n\\n        let right = left + 1;\\n        let prev = nums[left];\\n\\n        // at this point we know nums[l] % 2 == 0\\n        // Extend the subarray to the right as far as possible\\n        \\n        while (right < nums.length && nums[right] <= threshold && nums[right] % 2 !== prev % 2) {\\n            prev = nums[right];\\n            right++;\\n        }\\n\\n        // Update the maximum length\\n        maxLength = Math.max(maxLength, right - left);\\n\\n        // Skip the elements that have already been considered\\n        left = right - 1;\\n    }\\n\\n    return maxLength;\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function (nums, threshold) {\\n\\n    let maxLength = 0;\\n\\n    for (let left = 0; left < nums.length; left++) {\\n\\n        // Skip if the number is odd or larger than the threshold\\n        if (nums[left] > threshold || nums[left] % 2 !== 0) continue;\\n\\n        let right = left + 1;\\n        let prev = nums[left];\\n\\n        // at this point we know nums[l] % 2 == 0\\n        // Extend the subarray to the right as far as possible\\n        \\n        while (right < nums.length && nums[right] <= threshold && nums[right] % 2 !== prev % 2) {\\n            prev = nums[right];\\n            right++;\\n        }\\n\\n        // Update the maximum length\\n        maxLength = Math.max(maxLength, right - left);\\n\\n        // Skip the elements that have already been considered\\n        left = right - 1;\\n    }\\n\\n    return maxLength;\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788242,
                "title": "video-cracking-the-code-longest-even-odd-subarray-with-threshold",
                "content": "# Intuition\\nOn first glance, this problem seems to be about managing multiple conditions to manipulate an array. My initial thoughts were to iterate through the array while checking each condition. We would likely keep track of the longest sequence that meets all conditions and update it when necessary.\\n\\nhttps://youtu.be/4wrs6d8fj-o\\n\\n# Approach\\nThe approach I took was to iterate through the array using a for loop. I created two variables, \\'longest\\' and \\'current\\', to keep track of the longest subarray meeting the criteria and the current length of such a subarray, respectively. \\n\\nIf a number is greater than the threshold, it can\\'t be included in a valid subarray, so the \\'current\\' counter is reset to zero. Then we check the parity (even or odd) of the number. If \\'current\\' is zero (indicating we\\'re not in a valid subarray) and the number is even, a new subarray can be started and \\'current\\' is set to 1. If we\\'re in a valid subarray and the current number has a different parity from the last one, we can extend our subarray, incrementing \\'current\\'. Otherwise, if the number is even, we start a new subarray, otherwise, \\'current\\' is set to zero. At each iteration, \\'longest\\' is updated if the current subarray is longer than the previously longest subarray.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is $$O(n)$$ where n is the length of the array. This is because we process each element in the array exactly once.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$ since we only use a fixed amount of space to store our variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        longest = 0 \\n        current = 0 \\n        for i in range(len(nums)): \\n            if nums[i] > threshold: \\n                current = 0 \\n            elif current == 0 and nums[i] % 2 == 0: \\n                current = 1 \\n            elif current > 0 and nums[i] % 2 != nums[i - 1] % 2: \\n                current += 1 \\n            else: \\n                current = 1 if nums[i] % 2 == 0 else 0 \\n            longest = max(longest, current) \\n        return longest \\n```\\nThis Python solution illustrates the approach described above. It identifies the longest subarray that meets the provided conditions and returns its length.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        longest = 0 \\n        current = 0 \\n        for i in range(len(nums)): \\n            if nums[i] > threshold: \\n                current = 0 \\n            elif current == 0 and nums[i] % 2 == 0: \\n                current = 1 \\n            elif current > 0 and nums[i] % 2 != nums[i - 1] % 2: \\n                current += 1 \\n            else: \\n                current = 1 if nums[i] % 2 == 0 else 0 \\n            longest = max(longest, current) \\n        return longest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713253,
                "title": "noob-sol-easy-to-understand-with-comments",
                "content": "# Approach\\nWe find current suitable index using temp. Then calculate the max window size from that temp. After this, we increase temp to find another suitable index for the window.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold)\\n    {\\n        int n = nums.size();\\n        int l = 0;  // left window pointer\\n        int r = 0; // right window pointer\\n        int maxi = 0; // to store max window size\\n\\n        int temp = 0; // will be used to find suitable left pointer\\n        bool flag = false; // true when suitable left pointer found\\n         \\n\\n        if(n == 1 && nums[0] % 2 == 0) // edge case 1\\n        {\\n            if(nums[0] <= threshold)\\n                return 1;\\n                \\n            else\\n                return 0;    \\n        }\\n\\n        if(n == 1 && nums[0] % 2 != 0) // edge case 2\\n            return 0;\\n\\n\\n\\n\\n\\n        while(temp < n) \\n        {\\n            if(nums[temp] % 2 == 0 && nums[temp] <= threshold)\\n            {\\n                l = r = temp;\\n                flag = true; // suitable left pointer found. It will remain true till\\n                             // we find the max window size and then set it to false\\n                             // again.\\n            }\\n\\n            if(flag)  // calculate subarray from existing left pointer\\n            {   \\n                \\n                while(r < n-1 && nums[r] <= threshold) // if the next element is not\\n                {                                      // suitable, we consider the \\n                    if(nums[r] % 2 != nums[r+1] % 2)   // only current element in the\\n                    {                                  // subaray.\\n                        maxi = max(maxi, r - l + 1);\\n                        r++;\\n                    }\\n\\n                    else //if the next element is suitable, we consider that element too\\n                    {\\n                        maxi = max(maxi, r - l + 1);\\n                        break;\\n                    }\\n\\n                }\\n\\n                if(r == n-1 && nums[r] <= threshold) //toprevent nums[n]%2 != nums[n+1]%2\\n                {                                    // as num[n+1] is out of bounds.\\n                    maxi = max(maxi, r - l + 1);\\n                }                \\n            }\\n\\n            flag = false; // window size from current temp is found. We will find the\\n                          // next suitable left window pointer again.\\n            temp++;\\n        }\\n\\n        return maxi;\\n\\n    }\\n};\\n```\\n![cat.webp](https://assets.leetcode.com/users/images/ede61e56-0ed2-41a4-b4b8-06b8ab0655ea_1688396241.1860385.webp)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold)\\n    {\\n        int n = nums.size();\\n        int l = 0;  // left window pointer\\n        int r = 0; // right window pointer\\n        int maxi = 0; // to store max window size\\n\\n        int temp = 0; // will be used to find suitable left pointer\\n        bool flag = false; // true when suitable left pointer found\\n         \\n\\n        if(n == 1 && nums[0] % 2 == 0) // edge case 1\\n        {\\n            if(nums[0] <= threshold)\\n                return 1;\\n                \\n            else\\n                return 0;    \\n        }\\n\\n        if(n == 1 && nums[0] % 2 != 0) // edge case 2\\n            return 0;\\n\\n\\n\\n\\n\\n        while(temp < n) \\n        {\\n            if(nums[temp] % 2 == 0 && nums[temp] <= threshold)\\n            {\\n                l = r = temp;\\n                flag = true; // suitable left pointer found. It will remain true till\\n                             // we find the max window size and then set it to false\\n                             // again.\\n            }\\n\\n            if(flag)  // calculate subarray from existing left pointer\\n            {   \\n                \\n                while(r < n-1 && nums[r] <= threshold) // if the next element is not\\n                {                                      // suitable, we consider the \\n                    if(nums[r] % 2 != nums[r+1] % 2)   // only current element in the\\n                    {                                  // subaray.\\n                        maxi = max(maxi, r - l + 1);\\n                        r++;\\n                    }\\n\\n                    else //if the next element is suitable, we consider that element too\\n                    {\\n                        maxi = max(maxi, r - l + 1);\\n                        break;\\n                    }\\n\\n                }\\n\\n                if(r == n-1 && nums[r] <= threshold) //toprevent nums[n]%2 != nums[n+1]%2\\n                {                                    // as num[n+1] is out of bounds.\\n                    maxi = max(maxi, r - l + 1);\\n                }                \\n            }\\n\\n            flag = false; // window size from current temp is found. We will find the\\n                          // next suitable left window pointer again.\\n            temp++;\\n        }\\n\\n        return maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711310,
                "title": "c-sliding-window-optimized",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans=0,i=0,last=INT_MAX;\\n        while(i<nums.size()){\\n\\n            if(nums[i]>threshold || (i>0 && nums[i]%2==nums[i-1]%2)){\\n                ans=max(ans,i-last);\\n                last=INT_MAX;\\n            }\\n\\n            if(nums[i]<=threshold && last==INT_MAX && nums[i]%2==0) last=i;\\n            i++;\\n        }\\n        ans=max(ans,i-last);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans=0,i=0,last=INT_MAX;\\n        while(i<nums.size()){\\n\\n            if(nums[i]>threshold || (i>0 && nums[i]%2==nums[i-1]%2)){\\n                ans=max(ans,i-last);\\n                last=INT_MAX;\\n            }\\n\\n            if(nums[i]<=threshold && last==INT_MAX && nums[i]%2==0) last=i;\\n            i++;\\n        }\\n        ans=max(ans,i-last);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710268,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer[]} nums\\n# @param {Integer} threshold\\n# @return {Integer}\\ndef longest_alternating_subarray(nums, threshold)\\n  nums.map { _1 > threshold ? ?? : _1[0] }.join.scan(/(?:01)*0?/).map(&:size).max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} threshold\\n# @return {Integer}\\ndef longest_alternating_subarray(nums, threshold)\\n  nums.map { _1 > threshold ? ?? : _1[0] }.join.scan(/(?:01)*0?/).map(&:size).max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3709637,
                "title": "intuitive-java-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the solution, we need to check all possible subarrays for the given condition and continuously update the answer with the maximum length of a valid subarray. Considering that the constraints are small, an O(n^2) approach would be suitable for this problem.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int n=nums.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n\\n            //check if number at index i is even\\n            //check if number at index i is less than or equal to threshold\\n            //if above conditions are not true, we will not consider element at index i\\n            if(nums[i]%2!=0 || nums[i]>threshold)\\n                continue;\\n            int j=i;\\n            for(;j<n-1;j++){\\n                // check if parity of adjacent elements is same\\n                // check if element is less than threshold\\n                //if condition fails, break the loop \\n                if((nums[j]%2==nums[j+1]%2) || nums[j+1]>threshold)\\n                    break;\\n            }\\n            //keep on updating the ans with maximum length\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int n=nums.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n\\n            //check if number at index i is even\\n            //check if number at index i is less than or equal to threshold\\n            //if above conditions are not true, we will not consider element at index i\\n            if(nums[i]%2!=0 || nums[i]>threshold)\\n                continue;\\n            int j=i;\\n            for(;j<n-1;j++){\\n                // check if parity of adjacent elements is same\\n                // check if element is less than threshold\\n                //if condition fails, break the loop \\n                if((nums[j]%2==nums[j+1]%2) || nums[j+1]>threshold)\\n                    break;\\n            }\\n            //keep on updating the ans with maximum length\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709092,
                "title": "simple-javascript-solution-beating-100",
                "content": "# Intuition\\nChecks if number is odd and even, and decide next operation accordingly\\n\\n# Approach\\nIt checks if the prevNumber is even and odd, and as we are looking for alternatively even (er decide for further opertions accordinglu)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let start = null;\\n    let end = null;\\n    let isPrevEven = null;\\n    let i=0;\\n    let maxLength = 0;\\n    if(nums.length === 0){\\n        return null;\\n    }\\n    while(i<nums.length){\\n        if(nums[i] <= threshold){\\n            if(nums[i] % 2 === 0){\\n                if(start === null){\\n                    start = i;\\n                } else {\\n                    if(isPrevEven){\\n                        end = i-1\\n                        if(start !== null){\\n                            maxLength = Math.max(maxLength, ((end-start)+1));\\n                        }\\n                        //assigning start to be same index, as we have to start with even number only\\n                        start = i;\\n                    } else {\\n                        // do nothing\\n                    }\\n                }\\n            }\\n\\n            if(nums[i] % 2 !== 0){\\n                if(start === null){\\n                    //do nothing\\n                } else {\\n                    if(isPrevEven){\\n                        // do nothing\\n                    } else {\\n                        end = i-1;\\n                        if(start !== null){\\n                            maxLength = Math.max(maxLength, ((end-start)+1));\\n                        }\\n                         //assigning start to be same index, as we have to start with even number only, and odd can\\'t be assigned\\n                        start = null;\\n                    }\\n                }\\n            }\\n        } else {\\n            end = i-1;\\n            if(start !== null){\\n                maxLength = Math.max(maxLength, ((end-start)+1));\\n            }\\n            \\n            start = null;\\n            isPrevEven = null;\\n        }\\n        isPrevEven = nums[i] % 2 === 0;\\n        i++;\\n    }\\n\\n    if(start !== null){\\n        maxLength = Math.max(maxLength, nums.length - start);\\n    }\\n\\n    return maxLength;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let start = null;\\n    let end = null;\\n    let isPrevEven = null;\\n    let i=0;\\n    let maxLength = 0;\\n    if(nums.length === 0){\\n        return null;\\n    }\\n    while(i<nums.length){\\n        if(nums[i] <= threshold){\\n            if(nums[i] % 2 === 0){\\n                if(start === null){\\n                    start = i;\\n                } else {\\n                    if(isPrevEven){\\n                        end = i-1\\n                        if(start !== null){\\n                            maxLength = Math.max(maxLength, ((end-start)+1));\\n                        }\\n                        //assigning start to be same index, as we have to start with even number only\\n                        start = i;\\n                    } else {\\n                        // do nothing\\n                    }\\n                }\\n            }\\n\\n            if(nums[i] % 2 !== 0){\\n                if(start === null){\\n                    //do nothing\\n                } else {\\n                    if(isPrevEven){\\n                        // do nothing\\n                    } else {\\n                        end = i-1;\\n                        if(start !== null){\\n                            maxLength = Math.max(maxLength, ((end-start)+1));\\n                        }\\n                         //assigning start to be same index, as we have to start with even number only, and odd can\\'t be assigned\\n                        start = null;\\n                    }\\n                }\\n            }\\n        } else {\\n            end = i-1;\\n            if(start !== null){\\n                maxLength = Math.max(maxLength, ((end-start)+1));\\n            }\\n            \\n            start = null;\\n            isPrevEven = null;\\n        }\\n        isPrevEven = nums[i] % 2 === 0;\\n        i++;\\n    }\\n\\n    if(start !== null){\\n        maxLength = Math.max(maxLength, nums.length - start);\\n    }\\n\\n    return maxLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708878,
                "title": "easy-and-fast-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int findEven(int nums[], int ths, int i) {\\n        while(i < nums.length) {\\n            if(nums[i] <= ths && nums[i] % 2 == 0) break;\\n            i++;\\n        }\\n        return i;\\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int l = findEven(nums, threshold, 0);\\n        if(l == nums.length) return 0;\\n        int r = l + 1;\\n        int maxLen = 1;\\n        int i = 1;\\n        while(r < nums.length) {\\n            if(nums[r] <= threshold && nums[r] % 2 == i++) i %= 2;\\n            else {\\n                maxLen = Math.max(maxLen, r - l);\\n                l = findEven(nums, threshold, r);\\n                r = l;\\n                i = 1;\\n            }\\n            r++;\\n        }\\n        maxLen = Math.max(maxLen, r - l);\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int findEven(int nums[], int ths, int i) {\\n        while(i < nums.length) {\\n            if(nums[i] <= ths && nums[i] % 2 == 0) break;\\n            i++;\\n        }\\n        return i;\\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int l = findEven(nums, threshold, 0);\\n        if(l == nums.length) return 0;\\n        int r = l + 1;\\n        int maxLen = 1;\\n        int i = 1;\\n        while(r < nums.length) {\\n            if(nums[r] <= threshold && nums[r] % 2 == i++) i %= 2;\\n            else {\\n                maxLen = Math.max(maxLen, r - l);\\n                l = findEven(nums, threshold, r);\\n                r = l;\\n                i = 1;\\n            }\\n            r++;\\n        }\\n        maxLen = Math.max(maxLen, r - l);\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708702,
                "title": "easy-to-understand-beats-100-solution-in-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem we have to find the largest subarray which start from even number and then alternating odd after even number till last length -1 of subarray:\\n***There are some important point to solve problem:***\\n- Check if the input vector is empty\\n-  Check if the current number is even, less than or equal to the threshold,and it is the first even number encountered in the subarray\\n-  Check if the current number is even, the next number is odd (alternating),less than or equal to the threshold, and update the length of the current subarray\\n                                                                               \\n# Code\\n```\\n//Code by Ashutosh Kumar\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0, curr = 1, n = nums.size();\\n        if (n == 0) \\n            return n;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 == 0 && ans == 0 && nums[i] <= threshold) \\n                ans = 1; \\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] % 2 == 0 && nums[j] % 2 != nums[j - 1] % 2 && nums[j] <= threshold && nums[i] <= threshold )  {\\n                    curr++;\\n                    ans = max(ans, curr);\\n                } else \\n                    break;\\n            }\\n            curr = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Code by Ashutosh Kumar\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0, curr = 1, n = nums.size();\\n        if (n == 0) \\n            return n;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 == 0 && ans == 0 && nums[i] <= threshold) \\n                ans = 1; \\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] % 2 == 0 && nums[j] % 2 != nums[j - 1] % 2 && nums[j] <= threshold && nums[i] <= threshold )  {\\n                    curr++;\\n                    ans = max(ans, curr);\\n                } else \\n                    break;\\n            }\\n            curr = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708421,
                "title": "sliding-window-c-clean-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans=0,i=1,last=INT_MAX,n=nums.size();\\n        if(nums[0]%2==0 and nums[0]<=threshold)last=0;\\n        while(i<n){\\n            if(nums[i]>threshold or ((nums[i]%2)==(nums[i-1]%2))){\\n                ans=max(ans,i-last);\\n                last=INT_MAX;\\n            }\\n            if(last==INT_MAX and nums[i]<=threshold and nums[i]%2==0)\\n                last=i;\\n            i++;\\n        }\\n        ans=max(ans,i-last);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans=0,i=1,last=INT_MAX,n=nums.size();\\n        if(nums[0]%2==0 and nums[0]<=threshold)last=0;\\n        while(i<n){\\n            if(nums[i]>threshold or ((nums[i]%2)==(nums[i-1]%2))){\\n                ans=max(ans,i-last);\\n                last=INT_MAX;\\n            }\\n            if(last==INT_MAX and nums[i]<=threshold and nums[i]%2==0)\\n                last=i;\\n            i++;\\n        }\\n        ans=max(ans,i-last);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707820,
                "title": "a-simple-sliding-window-unlike-other-complex-solutions",
                "content": "I see so many people complicating the solution .Here is a simple sliding window solution.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int left = 0;   \\n        int right = 0; \\n        int res = 0;\\n        \\n        while (right < n) {\\n            if (right > 0 && (nums[right] % 2 == nums[right - 1] % 2 || nums[right] > threshold)) {\\n                left = right;\\n            }\\n            if(nums[left]%2!=0||nums[left]>threshold) left++;\\n            res = max(res, right - left + 1);\\n            \\n            right++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int left = 0;   \\n        int right = 0; \\n        int res = 0;\\n        \\n        while (right < n) {\\n            if (right > 0 && (nums[right] % 2 == nums[right - 1] % 2 || nums[right] > threshold)) {\\n                left = right;\\n            }\\n            if(nums[left]%2!=0||nums[left]>threshold) left++;\\n            res = max(res, right - left + 1);\\n            \\n            right++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707469,
                "title": "simple-c-solution",
                "content": "# C++ Codes\\n\\n### Code 1: Brute Froce\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size(),ans = 0,len,j;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2 != 0)\\n                continue;\\n            len=0;\\n            for(j=i;j<n-1;j++){\\n                if(nums[j]%2 == nums[j+1]%2)\\n                    break;\\n                if(nums[j]>threshold)\\n                    break;\\n                len++;\\n            }\\n            if(nums[j]<=threshold)\\n                len++;\\n            cout << len << endl;\\n            ans = max(ans,len);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n### Code 2: Sliding Window\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size(),ans=0,i=0,j=0,flag=0;\\n        while(j<n){\\n            if(flag){\\n                if(nums[j]%2 != nums[j-1]%2 && nums[j]<=threshold)\\n                    ans = max(ans,j-i+1);\\n                else\\n                    flag=0,j--;\\n            }\\n            else{\\n                if(nums[j] % 2 == 0 && nums[j] <= threshold){\\n                    i = j;\\n                    ans = max(ans,j-i+1);\\n                    flag=1;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size(),ans = 0,len,j;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2 != 0)\\n                continue;\\n            len=0;\\n            for(j=i;j<n-1;j++){\\n                if(nums[j]%2 == nums[j+1]%2)\\n                    break;\\n                if(nums[j]>threshold)\\n                    break;\\n                len++;\\n            }\\n            if(nums[j]<=threshold)\\n                len++;\\n            cout << len << endl;\\n            ans = max(ans,len);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size(),ans=0,i=0,j=0,flag=0;\\n        while(j<n){\\n            if(flag){\\n                if(nums[j]%2 != nums[j-1]%2 && nums[j]<=threshold)\\n                    ans = max(ans,j-i+1);\\n                else\\n                    flag=0,j--;\\n            }\\n            else{\\n                if(nums[j] % 2 == 0 && nums[j] <= threshold){\\n                    i = j;\\n                    ans = max(ans,j-i+1);\\n                    flag=1;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3707428,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 621 ms, faster than 23.08% of Python3 online submissions for Longest Even Odd Subarray With Threshold.\\n# Memory Usage: 16.3 MB, less than 92.31% of Python3 online submissions for Longest Even Odd Subarray With Threshold.\\n\\n\\tclass Solution:\\n\\t\\tdef longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\n\\t\\t\\t\\tif nums[i] % 2 == 0 and nums[i] <= threshold:\\n\\n\\t\\t\\t\\t\\tcurrent_length = 1\\n\\n\\t\\t\\t\\t\\tfor j in range(i , len(nums)-1):\\n\\n\\t\\t\\t\\t\\t\\tif nums[j] % 2 != nums[j+1] % 2 and nums[j+1] <= threshold:\\n\\t\\t\\t\\t\\t\\t\\tcurrent_length = current_length + 1\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\tresult = max(result , current_length)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 621 ms, faster than 23.08% of Python3 online submissions for Longest Even Odd Subarray With Threshold.\\n# Memory Usage: 16.3 MB, less than 92.31% of Python3 online submissions for Longest Even Odd Subarray With Threshold.\\n\\n\\tclass Solution:\\n\\t\\tdef longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\n\\t\\t\\t\\tif nums[i] % 2 == 0 and nums[i] <= threshold:\\n\\n\\t\\t\\t\\t\\tcurrent_length = 1\\n\\n\\t\\t\\t\\t\\tfor j in range(i , len(nums)-1):\\n\\n\\t\\t\\t\\t\\t\\tif nums[j] % 2 != nums[j+1] % 2 and nums[j+1] <= threshold:\\n\\t\\t\\t\\t\\t\\t\\tcurrent_length = current_length + 1\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\tresult = max(result , current_length)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3707357,
                "title": "c-easy-to-understand-solution-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplying the problem conditions one by one while handling the edge cases.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1. Check and find the valid starting index of the first subarray\\n2. If no valid first index found return 0\\n3. Start the for loop from the valid index until end (excluding end)\\n4. Add a condition to make sure the new subarray starts from even number\\n4. Increasing the counter if the current value is less than threshold\\n5. Resetting counter if we find the end of current subarray for cases like breaking even odd combination or when current value > threshold\\n6. Outside the for loop handle corner case for the last element\\n7. Return the maximum count\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     int longestAlternatingSubarray(vector<int>& nums, int threshold) \\n     {\\n        int l = 0;\\n        int r = nums.size()-1;\\n        int count = 0;\\n        int maxCount = INT_MIN;\\n\\n        // Finding the first valid number which is even and lower than threshold\\n        while(l <= r && (nums[l]%2 != 0 || nums[l] > threshold))\\n            l++;\\n\\n        // Handling corner case if all the elements are greater than threshold or odd\\n        if(l>r)\\n            return 0;\\n\\n        for(int i = l; i < r; i++)\\n        {\\n            // Making sure the new subarray starts from even number\\n            if(count == 0 && nums[i]%2 != 0)\\n                continue;\\n\\n            if(nums[i] <= threshold)\\n            {\\n                // Increasing the count\\n                count++;\\n\\n                // Resetting count as we found the end of current subarray\\n                if(nums[i]%2 == nums[i+1]%2)\\n                {\\n                    maxCount = max(count, maxCount);\\n                    count = 0;\\n                }\\n            }\\n            else // Resetting count as we found the end of current subarray\\n            {\\n                maxCount = max(count, maxCount);\\n                count = 0;\\n            }\\n        }\\n        // Handling corner case of the last element\\n        if(nums[r] <= threshold)\\n        {\\n            count++;\\n        }\\n        return max(maxCount,count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     int longestAlternatingSubarray(vector<int>& nums, int threshold) \\n     {\\n        int l = 0;\\n        int r = nums.size()-1;\\n        int count = 0;\\n        int maxCount = INT_MIN;\\n\\n        // Finding the first valid number which is even and lower than threshold\\n        while(l <= r && (nums[l]%2 != 0 || nums[l] > threshold))\\n            l++;\\n\\n        // Handling corner case if all the elements are greater than threshold or odd\\n        if(l>r)\\n            return 0;\\n\\n        for(int i = l; i < r; i++)\\n        {\\n            // Making sure the new subarray starts from even number\\n            if(count == 0 && nums[i]%2 != 0)\\n                continue;\\n\\n            if(nums[i] <= threshold)\\n            {\\n                // Increasing the count\\n                count++;\\n\\n                // Resetting count as we found the end of current subarray\\n                if(nums[i]%2 == nums[i+1]%2)\\n                {\\n                    maxCount = max(count, maxCount);\\n                    count = 0;\\n                }\\n            }\\n            else // Resetting count as we found the end of current subarray\\n            {\\n                maxCount = max(count, maxCount);\\n                count = 0;\\n            }\\n        }\\n        // Handling corner case of the last element\\n        if(nums[r] <= threshold)\\n        {\\n            count++;\\n        }\\n        return max(maxCount,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707060,
                "title": "sliding-window-simple-and-fast-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst start from index which has even value then simply traverse the array until given condition is satisfied.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int thresold) {\\n        int ans=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0 and nums[i]<=thresold){\\n                i+=1;\\n                int f=1;\\n                while(i<nums.size()){\\n                    if((nums[i-1]%2)==(nums[i]%2) or nums[i]>thresold){\\n                        break;\\n                    }\\n                    f+=1;\\n                    i+=1;\\n                }\\n                i-=1;\\n                ans=max(ans,f);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int thresold) {\\n        int ans=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0 and nums[i]<=thresold){\\n                i+=1;\\n                int f=1;\\n                while(i<nums.size()){\\n                    if((nums[i-1]%2)==(nums[i]%2) or nums[i]>thresold){\\n                        break;\\n                    }\\n                    f+=1;\\n                    i+=1;\\n                }\\n                i-=1;\\n                ans=max(ans,f);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706953,
                "title": "python-bruteforce",
                "content": "# Intuition\\nJust bruteforce solution with two loops\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n\\n# Code\\n```\\nclass Solution:\\n  def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n    res = 0\\n    for l in range(len(nums)):\\n      if nums[l] % 2 == 0 and nums[l] <= threshold:\\n        r = l\\n        while r + 1 < len(nums) and nums[r + 1] <= threshold and nums[r] % 2 != nums[r + 1] % 2:\\n          r += 1\\n        res = max(res, r - l + 1)\\n\\n    return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n    res = 0\\n    for l in range(len(nums)):\\n      if nums[l] % 2 == 0 and nums[l] <= threshold:\\n        r = l\\n        while r + 1 < len(nums) and nums[r + 1] <= threshold and nums[r] % 2 != nums[r + 1] % 2:\\n          r += 1\\n        res = max(res, r - l + 1)\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706949,
                "title": "c-easy-beginner-friendly-o-n",
                "content": "# Intuition\\n1. From problem statement it is confirm that first element of subarray must be even.\\n2. And all elements must be less than or equal to threshold.\\n\\n# Approach: #comments\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int i=0;    // Start Index\\n        int n=nums.size();\\n        int ans=0; // Maximum length of any subarray\\n        while(i<n){\\n            // Check if element is even and <=threshold\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                // Start count by 1 as nums[i] is also in subarray\\n                // prev_rem store remainder of last element\\n                int c=1,prev_rem=0;                 \\n                i++;\\n                // Run the loop while element is <= threshold\\n                // And remainder is not same as previous\\n                while(i<n && nums[i]%2!=prev_rem && nums[i]<=threshold){ \\n                    prev_rem=nums[i]%2;\\n                    c++; // Increase the count\\n                    i++;\\n                }\\n                ans=max(ans,c); // Update the answer\\n            }else{\\n                // If odd element then increase the index\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int i=0;    // Start Index\\n        int n=nums.size();\\n        int ans=0; // Maximum length of any subarray\\n        while(i<n){\\n            // Check if element is even and <=threshold\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                // Start count by 1 as nums[i] is also in subarray\\n                // prev_rem store remainder of last element\\n                int c=1,prev_rem=0;                 \\n                i++;\\n                // Run the loop while element is <= threshold\\n                // And remainder is not same as previous\\n                while(i<n && nums[i]%2!=prev_rem && nums[i]<=threshold){ \\n                    prev_rem=nums[i]%2;\\n                    c++; // Increase the count\\n                    i++;\\n                }\\n                ans=max(ans,c); // Update the answer\\n            }else{\\n                // If odd element then increase the index\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706763,
                "title": "my-thought-process-one-loop-o-n-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. array will start with an even number\\n2. then the sequence will look like `[even, odd, even, odd, ....]`\\n3. now there are cases where this sequence will break\\n   - `[... even, odd, odd, ...]`, `[... even, even, ...]` in both these cases we will need to start the new subsequence\\n   - `nums[i] > threshold` in this case too we will need to start with the new sequence\\n4. implies => we will need to increament the current running length till the condition is satisfied else we will start with the new sequence\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. for every `number` see \\n    1. if it\\'s `current running length` is `greater than zero` and it follows the given conditions\\n    2. else if the `number` is even start the `running length` with `1` else `0`\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int runningLength = 0, maxLength = 0, prev = 0;\\n        for(int num: nums) {\\n            // num & 1 == 1 means last bit is on i.e odd else even\\n            if (runningLength > 0 && (prev & 1) != (num & 1) && threshold >= num) {\\n                runningLength++;\\n            } else {\\n                runningLength = ((num & 1) == 0 && threshold >= num);\\n            }\\n            maxLength = max(runningLength, maxLength);\\n            prev = num;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int runningLength = 0, maxLength = 0, prev = 0;\\n        for(int num: nums) {\\n            // num & 1 == 1 means last bit is on i.e odd else even\\n            if (runningLength > 0 && (prev & 1) != (num & 1) && threshold >= num) {\\n                runningLength++;\\n            } else {\\n                runningLength = ((num & 1) == 0 && threshold >= num);\\n            }\\n            maxLength = max(runningLength, maxLength);\\n            prev = num;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706731,
                "title": "c-very-easy-solution-with-brief-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are using variable\\n- count : to count current maximum subarray length.\\n- ans : to count overall maximum subarray length\\n- flag : it has two states \\n```\\nflag == 0  check number is even\\nflag == 1  check number is odd\\n```\\nTraverse the array if element follows `<even odd even odd>` sequence within `threshold` increase the count and togggle the flag .\\nOtherwise set `count = 0` if current element is `odd` and `count = 0` if `even`.\\nAnd store the answer .\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        \\n       int n=nums.size();\\n       int count = 0 , f = 0,ans = 0;\\n     \\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            if(nums[i] <= threshold and nums[i] %2 == f)\\n            {\\n                count++;\\n                f=f^1;       //toggle between 0 and 1\\n            }\\n            else\\n            {\\n                ans = max(ans , count) ;\\n                f = 0 ;\\n                count = 0;\\n                if(nums[i] <= threshold and nums[i] %2 == 0)\\n                {count = 1 ; f = 1 ;}\\n            \\n            }\\n            \\n        }\\n        ans = max(ans , count) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nflag == 0  check number is even\\nflag == 1  check number is odd\\n```\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        \\n       int n=nums.size();\\n       int count = 0 , f = 0,ans = 0;\\n     \\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            if(nums[i] <= threshold and nums[i] %2 == f)\\n            {\\n                count++;\\n                f=f^1;       //toggle between 0 and 1\\n            }\\n            else\\n            {\\n                ans = max(ans , count) ;\\n                f = 0 ;\\n                count = 0;\\n                if(nums[i] <= threshold and nums[i] %2 == 0)\\n                {count = 1 ; f = 1 ;}\\n            \\n            }\\n            \\n        }\\n        ans = max(ans , count) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706698,
                "title": "the-easiest-solution-ever-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        for (int p = 0; p < nums.size(); p++) {\\n            if (nums[p] % 2 != 0 || nums[p] > threshold)\\n                continue;\\n            ans = max(ans, 1);\\n            for (int a = p + 1; a < nums.size(); a++) {\\n                if (nums[a] % 2 != nums[a - 1] % 2 && nums[a] <= threshold) {\\n                    ans = max(ans, a - p + 1);\\n                } else {\\n                    p = a - 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3cd26314-7236-4d39-9504-48e4e39f90f9_1688274576.038691.gif)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        for (int p = 0; p < nums.size(); p++) {\\n            if (nums[p] % 2 != 0 || nums[p] > threshold)\\n                continue;\\n            ans = max(ans, 1);\\n            for (int a = p + 1; a < nums.size(); a++) {\\n                if (nums[a] % 2 != nums[a - 1] % 2 && nums[a] <= threshold) {\\n                    ans = max(ans, a - p + 1);\\n                } else {\\n                    p = a - 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706694,
                "title": "java-sliding-window-beats-70-simple-and-easy-approach",
                "content": "## Problem Statement:\\n\\nGiven an integer array `nums` and an integer `threshold`, find the length of the longest subarray such that all its elements are less than or equal to `threshold` and the elements alternate between even and odd.\\n\\n## Approach:\\n\\nThe approach is to iterate over the array and for each element that is even and less than or equal to the threshold, find the length of the subarray starting at that element where the elements alternate between even and odd. Keep track of the maximum length of such subarrays.\\n\\n## Java Solution:\\n\\n```java\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        // Initialize the maximum length to 0\\n        int maxLen = 0;\\n        \\n        // Initialize the left pointer to 0\\n        int left = 0;\\n\\n        // Iterate over the array\\n        while (left < nums.length) {\\n            // If the current element is even and less than or equal to the threshold\\n            if (nums[left] % 2 == 0 && nums[left] <= threshold) {\\n                // Initialize the right pointer to the next element\\n                int right = left + 1;\\n                \\n                // Find the end of the subarray where the elements alternate between even and odd\\n                while (right < nums.length && nums[right] <= threshold) {\\n                    int currentMod = nums[right] % 2;\\n                    int previousMod = nums[right - 1] % 2;\\n                    // If the current element and the previous element are alternating\\n                    if (currentMod != previousMod) {\\n                        // Move the right pointer to the next element\\n                        right++;\\n                    } else {\\n                        // If they are not alternating, break the loop\\n                        break;\\n                    }\\n                }\\n                \\n                // Calculate the length of the current subarray and update the maximum length if necessary\\n                maxLen = Math.max(maxLen, right - left);\\n                \\n                // Move the left pointer to the right pointer to start checking the next subarray\\n                left = right;\\n            } else {\\n                // If the current element is not even or greater than the threshold, move the left pointer to the next element\\n                left++;\\n            }\\n        }\\n\\n        // Return the maximum length\\n        return maxLen;\\n    }\\n}\\n```\\n\\n## Complexity Analysis:\\n\\nThe time complexity of the solution is O(n), where n is the size of the array. This is because we are iterating over the array once.\\n\\nThe space complexity of the solution is O(1). This is because we are not using any additional data structures that scale with the size of the input.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        // Initialize the maximum length to 0\\n        int maxLen = 0;\\n        \\n        // Initialize the left pointer to 0\\n        int left = 0;\\n\\n        // Iterate over the array\\n        while (left < nums.length) {\\n            // If the current element is even and less than or equal to the threshold\\n            if (nums[left] % 2 == 0 && nums[left] <= threshold) {\\n                // Initialize the right pointer to the next element\\n                int right = left + 1;\\n                \\n                // Find the end of the subarray where the elements alternate between even and odd\\n                while (right < nums.length && nums[right] <= threshold) {\\n                    int currentMod = nums[right] % 2;\\n                    int previousMod = nums[right - 1] % 2;\\n                    // If the current element and the previous element are alternating\\n                    if (currentMod != previousMod) {\\n                        // Move the right pointer to the next element\\n                        right++;\\n                    } else {\\n                        // If they are not alternating, break the loop\\n                        break;\\n                    }\\n                }\\n                \\n                // Calculate the length of the current subarray and update the maximum length if necessary\\n                maxLen = Math.max(maxLen, right - left);\\n                \\n                // Move the left pointer to the right pointer to start checking the next subarray\\n                left = right;\\n            } else {\\n                // If the current element is not even or greater than the threshold, move the left pointer to the next element\\n                left++;\\n            }\\n        }\\n\\n        // Return the maximum length\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706568,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n            int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n                if(nums[i]%2==0 && nums[i]<=threshold)\\n                {int count=1;\\n                    int j=i+1;\\n                        int flag=0;\\n                        while(j<nums.length)\\n                        {\\n                                if(flag==0 && nums[j]%2!=0 && nums[j]<=threshold)\\n                                   {\\n                                        j++;\\n                                        flag=1;\\n                                        count++;\\n                                   }\\n                                else if(flag==1 && nums[j]%2==0 && nums[j]<=threshold)\\n                                {\\n                                        flag=0;\\n                                        j++;\\n                                        count++;\\n                                }\\n                                else\\n                                {\\n                                        break;\\n                                }\\n                        }\\n                        ans=Math.max(ans,count);\\n                }\\n        }\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n            int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n                if(nums[i]%2==0 && nums[i]<=threshold)\\n                {int count=1;\\n                    int j=i+1;\\n                        int flag=0;\\n                        while(j<nums.length)\\n                        {\\n                                if(flag==0 && nums[j]%2!=0 && nums[j]<=threshold)\\n                                   {\\n                                        j++;\\n                                        flag=1;\\n                                        count++;\\n                                   }\\n                                else if(flag==1 && nums[j]%2==0 && nums[j]<=threshold)\\n                                {\\n                                        flag=0;\\n                                        j++;\\n                                        count++;\\n                                }\\n                                else\\n                                {\\n                                        break;\\n                                }\\n                        }\\n                        ans=Math.max(ans,count);\\n                }\\n        }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706494,
                "title": "c-solution-implementation-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n                int flag;\\n                int c;\\n                for(int j=i;j<n;j++){\\n                    c=0;\\n                    flag=0;\\n                    for(int k=i;k<=j;k++){\\n                        if(nums[k]%2!=0 && nums[k]<=threshold && flag==1){\\n                            c++;\\n                            flag=0;\\n                        }\\n                        else if(nums[k]%2==0 && nums[k]<=threshold && flag==0){\\n                            c++;\\n                            flag=1;\\n                        }\\n                        else{\\n                            ans=max(ans,c);\\n                            flag=0;\\n                            c=0;\\n                        }\\n                    }\\n                    ans=max(ans,c);\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n                int flag;\\n                int c;\\n                for(int j=i;j<n;j++){\\n                    c=0;\\n                    flag=0;\\n                    for(int k=i;k<=j;k++){\\n                        if(nums[k]%2!=0 && nums[k]<=threshold && flag==1){\\n                            c++;\\n                            flag=0;\\n                        }\\n                        else if(nums[k]%2==0 && nums[k]<=threshold && flag==0){\\n                            c++;\\n                            flag=1;\\n                        }\\n                        else{\\n                            ans=max(ans,c);\\n                            flag=0;\\n                            c=0;\\n                        }\\n                    }\\n                    ans=max(ans,c);\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706469,
                "title": "brute-force-java-c-python",
                "content": "Java\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(List<Integer> nums, int x) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums.get(i) % 2 == 0 && nums.get(i) <= x) {\\n                int cnt = 1;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (nums.get(j) % 2 != nums.get(j - 1) % 2 && nums.get(j) <= x) {\\n                        cnt++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                ans = Math.max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int x) \\n    {\\n        int ans=0,n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0 && nums[i]<=x)\\n            {\\n                int cnt=1;\\n               \\n                for(int j=i+1;j<n;j++)\\n                {\\n               \\n                    if(nums[j]%2!=nums[j-1]%2 && nums[j]<=x)\\n                    {\\n                        cnt++;\\n                    }\\n                    else\\n                        break;\\n                }\\n                ans=max(ans,cnt);\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, x):\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] % 2 == 0 and nums[i] <= x:\\n                cnt = 1\\n                for j in range(i + 1, n):\\n                    if nums[j] % 2 != nums[j - 1] % 2 and nums[j] <= x:\\n                        cnt += 1\\n                    else:\\n                        break\\n                ans = max(ans, cnt)\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(List<Integer> nums, int x) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums.get(i) % 2 == 0 && nums.get(i) <= x) {\\n                int cnt = 1;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (nums.get(j) % 2 != nums.get(j - 1) % 2 && nums.get(j) <= x) {\\n                        cnt++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                ans = Math.max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int x) \\n    {\\n        int ans=0,n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0 && nums[i]<=x)\\n            {\\n                int cnt=1;\\n               \\n                for(int j=i+1;j<n;j++)\\n                {\\n               \\n                    if(nums[j]%2!=nums[j-1]%2 && nums[j]<=x)\\n                    {\\n                        cnt++;\\n                    }\\n                    else\\n                        break;\\n                }\\n                ans=max(ans,cnt);\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, x):\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] % 2 == 0 and nums[i] <= x:\\n                cnt = 1\\n                for j in range(i + 1, n):\\n                    if nums[j] % 2 != nums[j - 1] % 2 and nums[j] <= x:\\n                        cnt += 1\\n                    else:\\n                        break\\n                ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085126,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n        int maxLen = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0 && nums[i]<= threshold ){\\n                int count = 1;\\n                for(int j=i; j<nums.length-1; j++){\\n                    if(nums[j]%2 != nums[j+1]%2 && nums[j+1]<=threshold){\\n                        count++; \\n                    }\\n                    else{\\n                        break;\\n                    }\\n                 }\\n                 maxLen = Math.max(maxLen, count);\\n            }\\n            \\n        }\\n\\n        return maxLen;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n        int maxLen = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0 && nums[i]<= threshold ){\\n                int count = 1;\\n                for(int j=i; j<nums.length-1; j++){\\n                    if(nums[j]%2 != nums[j+1]%2 && nums[j+1]<=threshold){\\n                        count++; \\n                    }\\n                    else{\\n                        break;\\n                    }\\n                 }\\n                 maxLen = Math.max(maxLen, count);\\n            }\\n            \\n        }\\n\\n        return maxLen;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083946,
                "title": "my-first-ever-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n        int l = 0;\\n            int max = 0;\\n            int r = nums.Length-1;\\n\\n            for(int i= 0; i<nums.Length; i++)\\n            {\\n                if (nums[l] % 2 != 0 || nums[i] > threshold)\\n                {\\n                    if (max < (i) - l)\\n                    {\\n                        max = (i) - l;\\n                    }\\n                    l = i + 1;\\n                    continue;\\n                }\\n                if(i<r && nums[i+1] %2 == nums[i] % 2)\\n                {\\n                    if(max< (i + 1) - l)\\n                    {\\n                        max = (i + 1)-l;\\n                    }\\n                    l = i + 1;\\n                    continue;\\n                }\\n            }\\n            if (r - l + 1 > max) max = r - l + 1;\\n            return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n        int l = 0;\\n            int max = 0;\\n            int r = nums.Length-1;\\n\\n            for(int i= 0; i<nums.Length; i++)\\n            {\\n                if (nums[l] % 2 != 0 || nums[i] > threshold)\\n                {\\n                    if (max < (i) - l)\\n                    {\\n                        max = (i) - l;\\n                    }\\n                    l = i + 1;\\n                    continue;\\n                }\\n                if(i<r && nums[i+1] %2 == nums[i] % 2)\\n                {\\n                    if(max< (i + 1) - l)\\n                    {\\n                        max = (i + 1)-l;\\n                    }\\n                    l = i + 1;\\n                    continue;\\n                }\\n            }\\n            if (r - l + 1 > max) max = r - l + 1;\\n            return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070143,
                "title": "scan-with-anchoring-o-n-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nscan with anchoring\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) beats 99%\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        anchor, trend = -1, -1\\n        res = 0\\n        for i, n in enumerate(nums):\\n            if anchor == -1:\\n                if n % 2 == 0 and n <= threshold:\\n                    anchor = i\\n                    trend = (i + n) % 2\\n            else:\\n                if (i + n) % 2 == trend and n <= threshold:\\n                    continue\\n                else:\\n                    res = max(res, i-anchor)\\n                    if n % 2 == 0 and n <= threshold:\\n                        anchor = i\\n                        trend = (i + n) % 2\\n                        continue\\n                    anchor, trend = -1, -1\\n        if anchor != -1:\\n            res = max(res, len(nums)-anchor)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        anchor, trend = -1, -1\\n        res = 0\\n        for i, n in enumerate(nums):\\n            if anchor == -1:\\n                if n % 2 == 0 and n <= threshold:\\n                    anchor = i\\n                    trend = (i + n) % 2\\n            else:\\n                if (i + n) % 2 == trend and n <= threshold:\\n                    continue\\n                else:\\n                    res = max(res, i-anchor)\\n                    if n % 2 == 0 and n <= threshold:\\n                        anchor = i\\n                        trend = (i + n) % 2\\n                        continue\\n                    anchor, trend = -1, -1\\n        if anchor != -1:\\n            res = max(res, len(nums)-anchor)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052979,
                "title": "java-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int subArrayLength = 0;\\n        final int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > threshold || nums[i] %2 != 0) \\n            continue ;\\n            int j = i;\\n            while (j < n - 1 && nums[j + 1] <= threshold && nums[j] % 2 != nums[j + 1] % 2) {\\n                j++;\\n            }\\n            subArrayLength = Math.max(subArrayLength, j-i+1);\\n            if(j < n && nums[j] > threshold){\\n                break;\\n            }\\n            i = j ;\\n        }\\n        return subArrayLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int subArrayLength = 0;\\n        final int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > threshold || nums[i] %2 != 0) \\n            continue ;\\n            int j = i;\\n            while (j < n - 1 && nums[j + 1] <= threshold && nums[j] % 2 != nums[j + 1] % 2) {\\n                j++;\\n            }\\n            subArrayLength = Math.max(subArrayLength, j-i+1);\\n            if(j < n && nums[j] > threshold){\\n                break;\\n            }\\n            i = j ;\\n        }\\n        return subArrayLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042267,
                "title": "python-beats-99-23-and-97-35",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/94462f08-db55-4132-8326-2ebd696c3c7d_1694662501.3120975.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        Output = 0\\n        temp = []\\n        start = False\\n        curr_is_odd = False\\n        curr_is_even = False\\n\\n        for i in nums:\\n            if i <= threshold:\\n                if i % 2 == 0:\\n                    if start == False:\\n                        start = True\\n                        curr_is_even = True\\n                        curr_is_odd = False\\n                        temp.append(i)\\n                    elif start == True:\\n                        if curr_is_even == True:\\n                            if len(temp) > Output:\\n                                Output = len(temp)\\n                            temp = [i]\\n                            curr_is_odd = False\\n                            curr_is_even = True\\n                        elif curr_is_odd == True:\\n                            temp.append(i)\\n                            curr_is_odd = False\\n                            curr_is_even = True\\n                elif i % 2 != 0:\\n                    if start == True:\\n                        if curr_is_even == True:\\n                            curr_is_odd = True\\n                            curr_is_even = False\\n                            temp.append(i)\\n                        elif curr_is_odd == True:\\n                            if len(temp) > Output:\\n                                Output = len(temp)\\n                            temp = []\\n                            start = False\\n                            curr_is_odd = False\\n                            curr_is_even = False\\n                    else:\\n                        pass\\n            else:\\n                if len(temp) > Output:\\n                    Output = len(temp)\\n                temp = []\\n                start = False\\n                curr_is_odd = False\\n                curr_is_even = False\\n\\n        if len(temp) > Output:\\n            Output = len(temp)\\n\\n        return Output\\n\\n        # 20230914\\n```\\n\\nAlthough it\\'s long LOL",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        Output = 0\\n        temp = []\\n        start = False\\n        curr_is_odd = False\\n        curr_is_even = False\\n\\n        for i in nums:\\n            if i <= threshold:\\n                if i % 2 == 0:\\n                    if start == False:\\n                        start = True\\n                        curr_is_even = True\\n                        curr_is_odd = False\\n                        temp.append(i)\\n                    elif start == True:\\n                        if curr_is_even == True:\\n                            if len(temp) > Output:\\n                                Output = len(temp)\\n                            temp = [i]\\n                            curr_is_odd = False\\n                            curr_is_even = True\\n                        elif curr_is_odd == True:\\n                            temp.append(i)\\n                            curr_is_odd = False\\n                            curr_is_even = True\\n                elif i % 2 != 0:\\n                    if start == True:\\n                        if curr_is_even == True:\\n                            curr_is_odd = True\\n                            curr_is_even = False\\n                            temp.append(i)\\n                        elif curr_is_odd == True:\\n                            if len(temp) > Output:\\n                                Output = len(temp)\\n                            temp = []\\n                            start = False\\n                            curr_is_odd = False\\n                            curr_is_even = False\\n                    else:\\n                        pass\\n            else:\\n                if len(temp) > Output:\\n                    Output = len(temp)\\n                temp = []\\n                start = False\\n                curr_is_odd = False\\n                curr_is_even = False\\n\\n        if len(temp) > Output:\\n            Output = len(temp)\\n\\n        return Output\\n\\n        # 20230914\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033647,
                "title": "python-1-liner",
                "content": "# Approach\\nRegex\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], thresh: int) -> int:\\n        return max([x.end() - x.start() for x in re.finditer(\\'(01)*0?\\', \\'\\'.join([str(x%2) if x <= thresh else \\'2\\' for x in nums]))])  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], thresh: int) -> int:\\n        return max([x.end() - x.start() for x in re.finditer(\\'(01)*0?\\', \\'\\'.join([str(x%2) if x <= thresh else \\'2\\' for x in nums]))])  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029231,
                "title": "java-solution-using-two-pointers",
                "content": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int i = 0, j = 0;\\n        int res = 0;\\n        while(j < nums.length){\\n            if(i < nums.length && (nums[i] % 2 != 0 || nums[i] > threshold)){\\n                i++;\\n                j = i;\\n            }else if(nums[j] > threshold){\\n                i = j;\\n                j++;\\n            }else if(i < j && nums[j] % 2 == nums[j - 1] % 2){\\n                i = j;\\n                j++;\\n            }else{\\n                res = Math.max(res, j - i + 1);\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int i = 0, j = 0;\\n        int res = 0;\\n        while(j < nums.length){\\n            if(i < nums.length && (nums[i] % 2 != 0 || nums[i] > threshold)){\\n                i++;\\n                j = i;\\n            }else if(nums[j] > threshold){\\n                i = j;\\n                j++;\\n            }else if(i < j && nums[j] % 2 == nums[j - 1] % 2){\\n                i = j;\\n                j++;\\n            }else{\\n                res = Math.max(res, j - i + 1);\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028186,
                "title": "easy-iterative-solution-without-dp-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int count = 0;\\n\\n        if(nums.length==1 && nums[0]<=threshold && nums[0]%2==0){\\n            return 1;\\n        }\\n        else if(nums.length==1){\\n            return 0;\\n        }\\n\\n        for(int i=0; i<nums.length;i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n\\n                int j=i+1;\\n                for(j = i+1; j<nums.length;j++){\\n                    if(nums[j]%2 == nums[j-1]%2){\\n                        break;\\n                    }\\n                    if(nums[j]>threshold){\\n                        break;\\n                    }\\n                }\\n\\n                if(j==nums.length){\\n                    count = Math.max(count, j-i);\\n                }\\n                else if(nums[j]>threshold || nums[j]%2 == nums[j-1]%2){\\n                    count = Math.max(count, j-i);\\n                }\\n\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int count = 0;\\n\\n        if(nums.length==1 && nums[0]<=threshold && nums[0]%2==0){\\n            return 1;\\n        }\\n        else if(nums.length==1){\\n            return 0;\\n        }\\n\\n        for(int i=0; i<nums.length;i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n\\n                int j=i+1;\\n                for(j = i+1; j<nums.length;j++){\\n                    if(nums[j]%2 == nums[j-1]%2){\\n                        break;\\n                    }\\n                    if(nums[j]>threshold){\\n                        break;\\n                    }\\n                }\\n\\n                if(j==nums.length){\\n                    count = Math.max(count, j-i);\\n                }\\n                else if(nums[j]>threshold || nums[j]%2 == nums[j-1]%2){\\n                    count = Math.max(count, j-i);\\n                }\\n\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011567,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l = 0\\n        m = 0\\n\\n        while l < len(nums):\\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\\n                r = l + 1\\n\\n                while r < len(nums):\\n                    if nums[r] % 2 != nums[r-1] % 2 and nums[r] <= threshold:\\n                        r += 1\\n                    else:\\n                        break\\n                m = max(m, r-l)\\n            l += 1\\n        \\n        return m\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l = 0\\n        m = 0\\n\\n        while l < len(nums):\\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\\n                r = l + 1\\n\\n                while r < len(nums):\\n                    if nums[r] % 2 != nums[r-1] % 2 and nums[r] <= threshold:\\n                        r += 1\\n                    else:\\n                        break\\n                m = max(m, r-l)\\n            l += 1\\n        \\n        return m\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007005,
                "title": "simple-o-n-javascript-typescript-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst longestAlternatingSubarray = (\\n  nums: number[],\\n  threshold: number\\n): number => {\\n  let curLength = 0;\\n  let maxLength = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] > threshold) curLength = 0;\\n    else if (curLength && nums[i] % 2 !== nums[i - 1] % 2) curLength++;\\n    else curLength = +(nums[i] % 2 === 0);\\n    maxLength = Math.max(maxLength, curLength);\\n  }\\n\\n  return maxLength;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst longestAlternatingSubarray = (\\n  nums: number[],\\n  threshold: number\\n): number => {\\n  let curLength = 0;\\n  let maxLength = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] > threshold) curLength = 0;\\n    else if (curLength && nums[i] % 2 !== nums[i - 1] % 2) curLength++;\\n    else curLength = +(nums[i] % 2 === 0);\\n    maxLength = Math.max(maxLength, curLength);\\n  }\\n\\n  return maxLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002228,
                "title": "simple-java-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Java Solution/Sliding Window\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Java Solution/Sliding Window\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int l = 0;\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] % 2 != 0 || nums[i] > threshold)\\n                continue;\\n\\n            l = i;\\n            Boolean evenToggle = true;\\n            while(l < nums.length && \\n                    nums[l] % 2 == (evenToggle?0:1) && \\n                    nums[l] <= threshold){\\n\\n                evenToggle = !evenToggle;\\n                l++;\\n            }\\n\\n            if(l-i > max)\\n                max = l-i;\\n            \\n            i=l-1;\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int l = 0;\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] % 2 != 0 || nums[i] > threshold)\\n                continue;\\n\\n            l = i;\\n            Boolean evenToggle = true;\\n            while(l < nums.length && \\n                    nums[l] % 2 == (evenToggle?0:1) && \\n                    nums[l] <= threshold){\\n\\n                evenToggle = !evenToggle;\\n                l++;\\n            }\\n\\n            if(l-i > max)\\n                max = l-i;\\n            \\n            i=l-1;\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997421,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n\\n        // APPROACH 1 O(N^2)\\n\\n        /*int maxL=0;\\n        if(nums.size()==1){\\n            if(nums[0]%2==0 && nums[0]<=threshold)\\n            maxL=1;\\n\\n            return maxL;\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n        int count = 1;\\n        if (nums[i] % 2 == 0 && nums[i] <= threshold) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                if (nums[j] % 2 != nums[j - 1] % 2 && nums[j] <= threshold) {\\n                    count++;\\n                } else {\\n                    break;\\n                }\\n            }\\n\\n            maxL = max(count, maxL);\\n        }\\n    }\\n\\n    return maxL;*/\\n         int i=0;\\n         int count=0;\\n         bool flag=false;\\n         int maxL=0;\\n         while(i<nums.size()){\\n             if(!flag){\\n                if(nums[i]%2==0 && nums[i]<=threshold){\\n                    count=1;\\n                    flag=true;\\n                    i++;\\n                }else{\\n                    i++;\\n                    flag=false;\\n                }\\n             }\\n             else if(flag){\\n                 if(nums[i]%2!=nums[i-1]%2 && nums[i]<=threshold){\\n                     count++;\\n                     i++;\\n                 }\\n                 else{\\n                     flag=false;\\n                     count=0;\\n                     //i++;\\n                 }\\n             }\\n             maxL=max(maxL,count);\\n         }\\n         return maxL;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n\\n        // APPROACH 1 O(N^2)\\n\\n        /*int maxL=0;\\n        if(nums.size()==1){\\n            if(nums[0]%2==0 && nums[0]<=threshold)\\n            maxL=1;\\n\\n            return maxL;\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n        int count = 1;\\n        if (nums[i] % 2 == 0 && nums[i] <= threshold) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                if (nums[j] % 2 != nums[j - 1] % 2 && nums[j] <= threshold) {\\n                    count++;\\n                } else {\\n                    break;\\n                }\\n            }\\n\\n            maxL = max(count, maxL);\\n        }\\n    }\\n\\n    return maxL;*/\\n         int i=0;\\n         int count=0;\\n         bool flag=false;\\n         int maxL=0;\\n         while(i<nums.size()){\\n             if(!flag){\\n                if(nums[i]%2==0 && nums[i]<=threshold){\\n                    count=1;\\n                    flag=true;\\n                    i++;\\n                }else{\\n                    i++;\\n                    flag=false;\\n                }\\n             }\\n             else if(flag){\\n                 if(nums[i]%2!=nums[i-1]%2 && nums[i]<=threshold){\\n                     count++;\\n                     i++;\\n                 }\\n                 else{\\n                     flag=false;\\n                     count=0;\\n                     //i++;\\n                 }\\n             }\\n             maxL=max(maxL,count);\\n         }\\n         return maxL;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983793,
                "title": "c-solution-o-n-2-s-1",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) \\n    {\\n        if (nums.size() == 1)\\n        {\\n            return nums[0] <= threshold && nums[0] % 2 == 0;\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1 || nums[i] > threshold)\\n            {\\n                continue;\\n            }\\n\\n            res = std::max(res, findRight(nums, i, threshold) - i + 1);\\n        }\\n        return res;\\n    }\\nprivate:\\n    int findRight(const std::vector<int>& nums, int start, int threshold)\\n    {\\n        bool odd = false;\\n        for (int i = start; i < nums.size() && nums[i] ; i++)\\n        {\\n            if ((nums[i] & 1) != odd || nums[i] > threshold)\\n            {\\n                return i - 1;\\n            }\\n\\n            odd = !odd;\\n        }\\n\\n        return nums.size() - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) \\n    {\\n        if (nums.size() == 1)\\n        {\\n            return nums[0] <= threshold && nums[0] % 2 == 0;\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1 || nums[i] > threshold)\\n            {\\n                continue;\\n            }\\n\\n            res = std::max(res, findRight(nums, i, threshold) - i + 1);\\n        }\\n        return res;\\n    }\\nprivate:\\n    int findRight(const std::vector<int>& nums, int start, int threshold)\\n    {\\n        bool odd = false;\\n        for (int i = start; i < nums.size() && nums[i] ; i++)\\n        {\\n            if ((nums[i] & 1) != odd || nums[i] > threshold)\\n            {\\n                return i - 1;\\n            }\\n\\n            odd = !odd;\\n        }\\n\\n        return nums.size() - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980303,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int max_length=0;\\n        for(int i=0;i<nums.size();i++){\\n            int length=0;\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                length++;\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j-1] % 2 != nums[j] % 2 && nums[j]<=threshold){\\n                    length++;\\n                }\\n                else if(nums[j-1] % 2 == nums[j] % 2)\\n                break;\\n                else{\\n                    if(nums[j]<=threshold)\\n                    length++;\\n                    break;\\n                }\\n            }\\n            max_length=max(max_length,length);\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int max_length=0;\\n        for(int i=0;i<nums.size();i++){\\n            int length=0;\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                length++;\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j-1] % 2 != nums[j] % 2 && nums[j]<=threshold){\\n                    length++;\\n                }\\n                else if(nums[j-1] % 2 == nums[j] % 2)\\n                break;\\n                else{\\n                    if(nums[j]<=threshold)\\n                    length++;\\n                    break;\\n                }\\n            }\\n            max_length=max(max_length,length);\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979767,
                "title": "o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n      int n=nums.length;\\n     int ans=0;\\n\\n      for(int i= 0; i<n; i++){\\n         int count=0;\\n      if(nums[i]%2==0 && nums[i] <= threshold){\\n          count=1;\\n        \\n        for(int j=i+1; j<n; j++){\\n          if(nums[j]>threshold || nums[j]%2==nums[j-1]%2)\\n         break;\\n           \\n           count++;\\n        }\\n           }\\n           ans=Math.max(ans,count);\\n      }\\n      return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n      int n=nums.length;\\n     int ans=0;\\n\\n      for(int i= 0; i<n; i++){\\n         int count=0;\\n      if(nums[i]%2==0 && nums[i] <= threshold){\\n          count=1;\\n        \\n        for(int j=i+1; j<n; j++){\\n          if(nums[j]>threshold || nums[j]%2==nums[j-1]%2)\\n         break;\\n           \\n           count++;\\n        }\\n           }\\n           ans=Math.max(ans,count);\\n      }\\n      return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972671,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=0;\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[i]%2!=0||nums[i]>threshold){\\n                i++;\\n            }\\n            else if(nums[i]%2==0 && nums[i]<=threshold){\\n                if(j==i){\\n                    ans=max(ans,j-i+1);\\n                }\\n                else if((j-i)>=1 && (nums[j]%2)!=(nums[j-1]%2) && nums[j]<=threshold){\\n                    ans=max(ans,j-i+1);\\n                }\\n                else{\\n                    i=j;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=0;\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[i]%2!=0||nums[i]>threshold){\\n                i++;\\n            }\\n            else if(nums[i]%2==0 && nums[i]<=threshold){\\n                if(j==i){\\n                    ans=max(ans,j-i+1);\\n                }\\n                else if((j-i)>=1 && (nums[j]%2)!=(nums[j-1]%2) && nums[j]<=threshold){\\n                    ans=max(ans,j-i+1);\\n                }\\n                else{\\n                    i=j;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969481,
                "title": "python-3-two-pointers",
                "content": "# Complexity\\n- Time complexity: $$$O(n)$$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$$O(n)$$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        n, ans, visited = len(nums), 0, set()\\n        for i in range(n):\\n            if i in visited or nums[i] > threshold or nums[i] % 2 == 1:\\n                continue\\n            left = right = i\\n            while right + 1 < n and nums[right + 1] <= threshold and ((nums[right] % 2) ^ (nums[right + 1] % 2) == 1):\\n                right += 1\\n                visited.add(right)\\n            ans = max(ans, right - left + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        n, ans, visited = len(nums), 0, set()\\n        for i in range(n):\\n            if i in visited or nums[i] > threshold or nums[i] % 2 == 1:\\n                continue\\n            left = right = i\\n            while right + 1 < n and nums[right + 1] <= threshold and ((nums[right] % 2) ^ (nums[right + 1] % 2) == 1):\\n                right += 1\\n                visited.add(right)\\n            ans = max(ans, right - left + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959758,
                "title": "best-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int mx) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for (int i = 0; i < n;) {\\n            if (nums[i] & 1 || nums[i] > mx) {\\n                i++;\\n                continue;\\n            }\\n            bool even = true;\\n            int j = i + 1;\\n            while (j < n && nums[j] <= mx) {\\n                if ((even && nums[j] % 2 == 0) || (!even && nums[j] & 1)) break;\\n                if (even) even = false;\\n                else even = true;\\n                j++;\\n            }\\n            ans = max(ans, j - i);\\n            i = j;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int mx) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for (int i = 0; i < n;) {\\n            if (nums[i] & 1 || nums[i] > mx) {\\n                i++;\\n                continue;\\n            }\\n            bool even = true;\\n            int j = i + 1;\\n            while (j < n && nums[j] <= mx) {\\n                if ((even && nums[j] % 2 == 0) || (!even && nums[j] & 1)) break;\\n                if (even) even = false;\\n                else even = true;\\n                j++;\\n            }\\n            ans = max(ans, j - i);\\n            i = j;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955135,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int maxi = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                ans++;\\n                for(int j=i+1; j<nums.size(); j++){\\n                    if(nums[j]%2 != nums[j-1]%2 && nums[j]<=threshold && nums[j-1]<=threshold){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n\\n                maxi = max(maxi,ans);\\n                ans = 0;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int maxi = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                ans++;\\n                for(int j=i+1; j<nums.size(); j++){\\n                    if(nums[j]%2 != nums[j-1]%2 && nums[j]<=threshold && nums[j-1]<=threshold){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n\\n                maxi = max(maxi,ans);\\n                ans = 0;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947600,
                "title": "o-n-beats-99-29",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        prev_even = False\\n        count = 0\\n        result = 0\\n        for num in nums:\\n            even = (num % 2 == 0)\\n            if num > threshold or even == prev_even:\\n                result = max(result, count)\\n                count = 0\\n\\n            count += (num <= threshold) and (even or count > 0)\\n            prev_even = even\\n\\n        return max(result, count)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        prev_even = False\\n        count = 0\\n        result = 0\\n        for num in nums:\\n            even = (num % 2 == 0)\\n            if num > threshold or even == prev_even:\\n                result = max(result, count)\\n                count = 0\\n\\n            count += (num <= threshold) and (even or count > 0)\\n            prev_even = even\\n\\n        return max(result, count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943272,
                "title": "c-beats-everyone-o-n-tc",
                "content": "# Intuition\\nsubarray ,contiguous\\n\\n# Approach\\nsliding window, two pointer, brute force\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nApproach 1 - 2 pointers\\n```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n      int longest = 0;\\n      for(int l = 0; l < nums.Length; l++)\\n      {\\n        if(nums[l] % 2 != 0 || nums[l] > threshold) continue;\\n        int len = 1;\\n        for(int r = l+1; r < nums.Length; r++)\\n        {\\n          if(nums[r] > threshold || nums[r]%2 == nums[r-1]%2)\\n          {\\n            l = r-1;\\n            break;\\n          }\\n          len++;\\n        }\\n        longest = Math.Max(longest, len);\\n      }\\n\\n      return longest;\\n    }\\n}\\n```\\n\\nApproach 2 - Sliding Window\\n```\\npublic class Solution \\n{\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n      int longest = 0;\\n      int l = -1;\\n\\n      for(int r = 0; r < nums.Length; r++)\\n      {\\n        if(l != -1 && ((r > 0 && nums[r]%2 == nums[r-1]%2) || nums[r] > threshold))\\n        {\\n          longest = Math.Max(longest, r-l);\\n          l = -1;\\n        }\\n\\n        if(l == -1 && nums[r]%2 == 0 && nums[r] <= threshold) l = r;\\n      }\\n\\n      if(l != -1) longest = Math.Max(longest, nums.Length-l);\\n\\n      return longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n      int longest = 0;\\n      for(int l = 0; l < nums.Length; l++)\\n      {\\n        if(nums[l] % 2 != 0 || nums[l] > threshold) continue;\\n        int len = 1;\\n        for(int r = l+1; r < nums.Length; r++)\\n        {\\n          if(nums[r] > threshold || nums[r]%2 == nums[r-1]%2)\\n          {\\n            l = r-1;\\n            break;\\n          }\\n          len++;\\n        }\\n        longest = Math.Max(longest, len);\\n      }\\n\\n      return longest;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) \\n    {\\n      int longest = 0;\\n      int l = -1;\\n\\n      for(int r = 0; r < nums.Length; r++)\\n      {\\n        if(l != -1 && ((r > 0 && nums[r]%2 == nums[r-1]%2) || nums[r] > threshold))\\n        {\\n          longest = Math.Max(longest, r-l);\\n          l = -1;\\n        }\\n\\n        if(l == -1 && nums[r]%2 == 0 && nums[r] <= threshold) l = r;\\n      }\\n\\n      if(l != -1) longest = Math.Max(longest, nums.Length-l);\\n\\n      return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937918,
                "title": "full-explanation-with-the-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n\\n        int maxLength = 0,count = 0, eO = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            \\n            // checking alternate even odd thing and the current element is less than or equal to threshold\\n            if( nums[i] <= threshold && nums[i] % 2 == eO){\\n                count++;\\n                eO = eO ^ 1; // if the current number is even then marking the next number for odd.\\n            }\\n            // if the number is less then threshold but consequtive even or consequtive odd, in this case\\n            else{\\n                maxLength = max(maxLength, count);\\n                eO = 0; \\n                count = 0;\\n                // if the consequtive element is even then start the new subarray from here only.\\n                if(nums[i] <= threshold && nums[i] % 2 == 0){\\n                    count = 1;\\n                    eO = 1; // marking the next element as odd. \\n                }\\n            }\\n\\n        }\\n\\n        maxLength = max(maxLength,count);\\n\\n        return maxLength;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n\\n        int maxLength = 0,count = 0, eO = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            \\n            // checking alternate even odd thing and the current element is less than or equal to threshold\\n            if( nums[i] <= threshold && nums[i] % 2 == eO){\\n                count++;\\n                eO = eO ^ 1; // if the current number is even then marking the next number for odd.\\n            }\\n            // if the number is less then threshold but consequtive even or consequtive odd, in this case\\n            else{\\n                maxLength = max(maxLength, count);\\n                eO = 0; \\n                count = 0;\\n                // if the consequtive element is even then start the new subarray from here only.\\n                if(nums[i] <= threshold && nums[i] % 2 == 0){\\n                    count = 1;\\n                    eO = 1; // marking the next element as odd. \\n                }\\n            }\\n\\n        }\\n\\n        maxLength = max(maxLength,count);\\n\\n        return maxLength;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935793,
                "title": "simple-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        result, count = 0, 0\\n\\n        for num in nums:\\n            if num > threshold:\\n                count = 0\\n                continue\\n                \\n            if num % 2 == count % 2:\\n                count += 1\\n            else:\\n                count = 1 if num % 2 == 0 else 0\\n\\n            result = max(result, count)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        result, count = 0, 0\\n\\n        for num in nums:\\n            if num > threshold:\\n                count = 0\\n                continue\\n                \\n            if num % 2 == count % 2:\\n                count += 1\\n            else:\\n                count = 1 if num % 2 == 0 else 0\\n\\n            result = max(result, count)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935792,
                "title": "simple-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        result, count = 0, 0\\n\\n        for num in nums:\\n            if num > threshold:\\n                count = 0\\n                continue\\n                \\n            if num % 2 == count % 2:\\n                count += 1\\n            else:\\n                count = 1 if num % 2 == 0 else 0\\n\\n            result = max(result, count)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        result, count = 0, 0\\n\\n        for num in nums:\\n            if num > threshold:\\n                count = 0\\n                continue\\n                \\n            if num % 2 == count % 2:\\n                count += 1\\n            else:\\n                count = 1 if num % 2 == 0 else 0\\n\\n            result = max(result, count)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933781,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int max_len=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                int count=1;\\n                for(;i<nums.size()-1;i++){\\n                    if(nums[i]%2!=nums[i+1]%2 && nums[i+1]<=threshold){\\n                        count++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                max_len=max(max_len,count);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int max_len=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                int count=1;\\n                for(;i<nums.size()-1;i++){\\n                    if(nums[i]%2!=nums[i+1]%2 && nums[i+1]<=threshold){\\n                        count++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                max_len=max(max_len,count);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932912,
                "title": "explaination-required-c-code-help",
                "content": "The Question given is not accurate.I had to refer other solutions to understand whats going on. I am still confused as to why threshold is given.Here is my code which i refered from someone :\\n```cpp\\nint longestAlternatingSubarray(vector<int>& nums, int threshold) \\n    {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int curr=0;\\n            if(nums[i]%2==0)\\n            {\\n                int j;\\n                for( j=i+1;j<nums.size();j++)\\n                {\\n                    if((nums[j-1]%2 != nums[j]%2) and (nums[j-1]<=threshold))\\n                        \\n                    {\\n                        curr++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(nums[j-1]<=threshold)\\n                {\\n                    curr++;\\n                }\\n            }\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "The Question given is not accurate.I had to refer other solutions to understand whats going on. I am still confused as to why threshold is given.Here is my code which i refered from someone :\\n```cpp\\nint longestAlternatingSubarray(vector<int>& nums, int threshold) \\n    {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int curr=0;\\n            if(nums[i]%2==0)\\n            {\\n                int j;\\n                for( j=i+1;j<nums.size();j++)\\n                {\\n                    if((nums[j-1]%2 != nums[j]%2) and (nums[j-1]<=threshold))\\n                        \\n                    {\\n                        curr++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(nums[j-1]<=threshold)\\n                {\\n                    curr++;\\n                }\\n            }\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3931331,
                "title": "time-complexity-o-n-detailed-solution-with-explanation-for-all-the-possible-conditions",
                "content": "# Intuition\\n- My first thoughts was to use a sliding window/two pointer approach with a left and right variable. I decided to think that way maybe because of the need of a subarray which is contiguous.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int l = -1;\\n        // r would be the variable that iterates through the nums array\\n        int r = 0;\\n        int maxLen = 0;\\n        while(r < nums.size()){\\n            if(l == -1 && nums[r] % 2 == 0 && nums[r] <= threshold){\\n                // This condition is to make sure, the first element of the subarray is an even number and is less than the threshold\\n                l = r;\\n                r++;\\n            } else if ( l != -1 && (nums[r] % 2) != (nums[r - 1] % 2) && nums[r] <= threshold){\\n                // This condition is to make sure the constraints are satisfied [Even/Odd pair and <= threshold] \\n                r++;\\n            } else if(nums[r] > threshold || nums[r] % 2 == 1){\\n                // The below two conditions are to check if the failed r is the start of a new subarray\\n\\n                // This condition is to check whether we should increment the r variable or not. If the result constraints fail due to an odd number or the current value at the position of r is greater than threshold then there is no possibility for that positioned to be the start of the subarray again\\n                r++;\\n                l = -1;\\n            } else {\\n                // This condition is when our cases fail due to an even number, if this is just an even number, this position might be our start of a new subarray\\n                l = -1;\\n            }\\n            \\n            if(l != -1){\\n                // r - l because, at every single instance r will be incremented to the next possible index\\n                maxLen = max(maxLen, r - l);\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int l = -1;\\n        // r would be the variable that iterates through the nums array\\n        int r = 0;\\n        int maxLen = 0;\\n        while(r < nums.size()){\\n            if(l == -1 && nums[r] % 2 == 0 && nums[r] <= threshold){\\n                // This condition is to make sure, the first element of the subarray is an even number and is less than the threshold\\n                l = r;\\n                r++;\\n            } else if ( l != -1 && (nums[r] % 2) != (nums[r - 1] % 2) && nums[r] <= threshold){\\n                // This condition is to make sure the constraints are satisfied [Even/Odd pair and <= threshold] \\n                r++;\\n            } else if(nums[r] > threshold || nums[r] % 2 == 1){\\n                // The below two conditions are to check if the failed r is the start of a new subarray\\n\\n                // This condition is to check whether we should increment the r variable or not. If the result constraints fail due to an odd number or the current value at the position of r is greater than threshold then there is no possibility for that positioned to be the start of the subarray again\\n                r++;\\n                l = -1;\\n            } else {\\n                // This condition is when our cases fail due to an even number, if this is just an even number, this position might be our start of a new subarray\\n                l = -1;\\n            }\\n            \\n            if(l != -1){\\n                // r - l because, at every single instance r will be incremented to the next possible index\\n                maxLen = max(maxLen, r - l);\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918800,
                "title": "python-15-lines",
                "content": "# Approach using Sliding Window\\n\\n1. We start with left==0 in range(n)\\n2. Find first left where nums[left]%2==0 which satisfies the first condition\\n3. Then set right=left+1\\n4. Find all consecutive elements that satisfies last two condition. 1) The last value of element added in arr[] and nums[right] should not be having same parity. 2) nums[right]<=threshold.\\n5. Keep a variable to track the longest length arrived so far.\\n6. Return the variable\\n    \\n*Note: The left variable is the ith element of the range and keeps track of every consecutive element that exists which is less than threshold and has different consecutive parities and starts with an even element so if nums = [2,3,4,5], threshold = 4 then every arr=[2,3,4] and arr=[4] both are considered although in given example first arr has greater length than second arr, there is a probability that it might become long in some other example*\\n\\nThe same is specified in comments\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        arr=[]\\n        n=len(nums)\\n        ans=0\\n\\n        for left in range(n):\\n            #calculating first left and checking if its less than threshold\\n            #Here we satisfy first condition, nums[l] % 2 == 0\\n\\n            if nums[left]%2==0 and nums[left]<=threshold:\\n                arr.append(nums[left])\\n            else:\\n                continue\\n\\n            #after adding first left, we start right from next element of left so right=left+1\\n            #Then add all consecutive elements that satisfy remaining 2 conditions:\\n            #nums[i] % 2 != nums[i + 1] % 2\\n            #nums[i] <= threshold\\n            #Also check right doesn\\'t go out of bounds, results in IndexError otherwise\\n\\n            right=left+1\\n            while right<n and arr[-1]%2!=nums[right]%2 and nums[right]<=threshold:\\n                arr.append(nums[right])\\n                right+=1\\n\\n            #Find length of largest array satisfying the threshold value\\n            #Empty arr for adding next values\\n            ans=max(ans,len(arr))\\n            arr=[]\\n\\n        #print(queue)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        arr=[]\\n        n=len(nums)\\n        ans=0\\n\\n        for left in range(n):\\n            #calculating first left and checking if its less than threshold\\n            #Here we satisfy first condition, nums[l] % 2 == 0\\n\\n            if nums[left]%2==0 and nums[left]<=threshold:\\n                arr.append(nums[left])\\n            else:\\n                continue\\n\\n            #after adding first left, we start right from next element of left so right=left+1\\n            #Then add all consecutive elements that satisfy remaining 2 conditions:\\n            #nums[i] % 2 != nums[i + 1] % 2\\n            #nums[i] <= threshold\\n            #Also check right doesn\\'t go out of bounds, results in IndexError otherwise\\n\\n            right=left+1\\n            while right<n and arr[-1]%2!=nums[right]%2 and nums[right]<=threshold:\\n                arr.append(nums[right])\\n                right+=1\\n\\n            #Find length of largest array satisfying the threshold value\\n            #Empty arr for adding next values\\n            ans=max(ans,len(arr))\\n            arr=[]\\n\\n        #print(queue)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918243,
                "title": "easy-fast-two-pointers-approach-beats-100",
                "content": "# Intuition\\n`\\uD83D\\uDC26 Don\\'t forget to UpVote \\uD83D\\uDC26`\\n\\n# Approach\\n`Two Pointers Intuitive Approach`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0, cur = 1, n = nums.size(), i = 0, prev = 0;\\n        bool isGreen = false;\\n        while(i<n) {\\n            if(isGreen) {\\n                if(nums[i]%2 != prev && nums[i] <= threshold) {\\n                    cur++;\\n                    prev = nums[i]%2;\\n                } else {\\n                    isGreen = false;\\n                    i--;\\n                }\\n                if(ans < cur) ans = cur; \\n            } else {\\n                if(nums[i]%2 == 0 && nums[i] <= threshold) {\\n                    isGreen = true;\\n                    cur = 1;\\n                    prev = 0;\\n                    if(ans < cur) ans = cur; \\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0, cur = 1, n = nums.size(), i = 0, prev = 0;\\n        bool isGreen = false;\\n        while(i<n) {\\n            if(isGreen) {\\n                if(nums[i]%2 != prev && nums[i] <= threshold) {\\n                    cur++;\\n                    prev = nums[i]%2;\\n                } else {\\n                    isGreen = false;\\n                    i--;\\n                }\\n                if(ans < cur) ans = cur; \\n            } else {\\n                if(nums[i]%2 == 0 && nums[i] <= threshold) {\\n                    isGreen = true;\\n                    cur = 1;\\n                    prev = 0;\\n                    if(ans < cur) ans = cur; \\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913080,
                "title": "simple-solution-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let res = 0\\n    let counter = 0\\n    let i = 0\\n    while (i < nums.length){\\n        if (nums[i] <= threshold){\\n            if (counter === 0){\\n                if (nums[i] % 2 === 0){\\n                    counter++\\n                }\\n                i++\\n            } else {\\n                if (nums[i - 1] % 2 === nums[i] % 2){\\n                    if (counter > res) res = counter\\n                    counter = 0\\n                } else {\\n                    counter++\\n                    i++\\n                }\\n            }\\n        } else {\\n            if (counter > res) res = counter\\n            counter = 0\\n            i++\\n        }\\n    }\\n    if (counter > res) res = counter\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let res = 0\\n    let counter = 0\\n    let i = 0\\n    while (i < nums.length){\\n        if (nums[i] <= threshold){\\n            if (counter === 0){\\n                if (nums[i] % 2 === 0){\\n                    counter++\\n                }\\n                i++\\n            } else {\\n                if (nums[i - 1] % 2 === nums[i] % 2){\\n                    if (counter > res) res = counter\\n                    counter = 0\\n                } else {\\n                    counter++\\n                    i++\\n                }\\n            }\\n        } else {\\n            if (counter > res) res = counter\\n            counter = 0\\n            i++\\n        }\\n    }\\n    if (counter > res) res = counter\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912295,
                "title": "easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            if(nums[i]%2 == 0){\\n                int j;\\n                for(j=i+1; j<n; j++){\\n                    if((nums[j-1]%2 != nums[j]%2) && (nums[j-1] <= threshold)){\\n                        cnt++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(nums[j-1]<=threshold){\\n                    cnt++;\\n                }\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            if(nums[i]%2 == 0){\\n                int j;\\n                for(j=i+1; j<n; j++){\\n                    if((nums[j-1]%2 != nums[j]%2) && (nums[j-1] <= threshold)){\\n                        cnt++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(nums[j-1]<=threshold){\\n                    cnt++;\\n                }\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908556,
                "title": "most-simple-solution-python-javascript",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```python []\\nclass Solution(object):\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        result, count = 0, 0\\n\\n        for num in nums:\\n            if num > threshold:\\n                count = 0\\n                continue\\n                \\n            if num % 2 == count % 2:\\n                count += 1\\n            else:\\n                count = 1 if num % 2 == 0 else 0\\n\\n            result = max(result, count)\\n\\n        return result\\n```\\n\\n```javascript []\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let result = 0;\\n    let count = 0;\\n\\n    for (const num of nums) {\\n        if (num > threshold) {\\n            count = 0;\\n            continue;\\n        }\\n\\n        if (num % 2 === count % 2) {\\n            count++;\\n        } else {\\n            count = num % 2 === 0 ? 1 : 0;\\n        }\\n\\n        result = Math.max(result, count);\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution(object):\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        result, count = 0, 0\\n\\n        for num in nums:\\n            if num > threshold:\\n                count = 0\\n                continue\\n                \\n            if num % 2 == count % 2:\\n                count += 1\\n            else:\\n                count = 1 if num % 2 == 0 else 0\\n\\n            result = max(result, count)\\n\\n        return result\\n```\n```javascript []\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let result = 0;\\n    let count = 0;\\n\\n    for (const num of nums) {\\n        if (num > threshold) {\\n            count = 0;\\n            continue;\\n        }\\n\\n        if (num % 2 === count % 2) {\\n            count++;\\n        } else {\\n            count = num % 2 === 0 ? 1 : 0;\\n        }\\n\\n        result = Math.max(result, count);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906600,
                "title": "o-n-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int l = 0,r = 0,n = nums.length,result=0;\\n        while( r < n ){\\n            int diff = (r - l) % 2;\\n            if( l==r && nums[l]%2==1 ){\\n                l++;\\n                r++;\\n                continue;\\n            }\\n            if ( nums[r] <= threshold ){\\n            boolean success = diff == 0 ? nums[r] % 2 == 0 :  nums[r] % 2 == 1;\\n            if ( success ){\\n                    r++;\\n                    continue;\\n            } else {\\n                result = result < (r - l) ? (r - l) : result;\\n                l = r;\\n                continue;\\n            }\\n            } else {\\n                result = result < (r - l) ? (r - l) : result;\\n                l = r + 1;\\n            }\\n            r++;\\n        }\\n        return result < (r - l) ? (r - l) : result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int l = 0,r = 0,n = nums.length,result=0;\\n        while( r < n ){\\n            int diff = (r - l) % 2;\\n            if( l==r && nums[l]%2==1 ){\\n                l++;\\n                r++;\\n                continue;\\n            }\\n            if ( nums[r] <= threshold ){\\n            boolean success = diff == 0 ? nums[r] % 2 == 0 :  nums[r] % 2 == 1;\\n            if ( success ){\\n                    r++;\\n                    continue;\\n            } else {\\n                result = result < (r - l) ? (r - l) : result;\\n                l = r;\\n                continue;\\n            }\\n            } else {\\n                result = result < (r - l) ? (r - l) : result;\\n                l = r + 1;\\n            }\\n            r++;\\n        }\\n        return result < (r - l) ? (r - l) : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905321,
                "title": "swift-solution-173ms-beats-100-sliding-window-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {\\n\\n       var maxLen = 0\\n       var foundStartFlag = false \\n\\n       var left = 0 , right = 0 \\n       \\n       var n = nums.count \\n\\n       while right < n {\\n\\n        //check if the even left \\n         if  nums[left] % 2 != 0 && !foundStartFlag {\\n           right += 1 \\n           left += 1\\n           continue\\n         }\\n\\n\\n         foundStartFlag = true\\n\\n         //calculating the previous index Modulas \\n         let prevInd = (right - 1 >=  0 ? right - 1  : -1)\\n         let prevIndMod = (prevInd == -1  ? -1 : nums[prevInd] % 2)\\n         \\n        // current right value is less than or equal threshold and the previous value is not the same modulas result \\n        // or in the other cases of starting a new range \\n        // ex 3 1 5 4 8 threshold = 4 \\n        // when right equal ind 2 the contigous sequence condition will fail because the prev is odd like right\\n        // so it will satsify the second condition which will set the right equal left for only one time for every new range \\n        // left == right says that a new range is being calculated \\n  \\n          if nums[right] <= threshold && (nums[right] % 2 != prevIndMod || left == right){\\n            maxLen = max(maxLen, right - left + 1)\\n          }\\n\\n          // right != left to prevent the loop of checking prev modulas value from happenning \\n          // left = right not right + 1 because we want to add the current right to the new range \\n          // it is less than threshold  \\n          else if nums[right] % 2 == prevIndMod && right != left {\\n            foundStartFlag = false\\n            left = right \\n            continue \\n          }\\n\\n          // left = right + 1 because the right value is greater than threshold\\n          else {\\n            foundStartFlag = false\\n            left = right + 1\\n          }\\n\\n         right += 1\\n         \\n       }\\n\\n\\n     return maxLen \\n      \\n   }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {\\n\\n       var maxLen = 0\\n       var foundStartFlag = false \\n\\n       var left = 0 , right = 0 \\n       \\n       var n = nums.count \\n\\n       while right < n {\\n\\n        //check if the even left \\n         if  nums[left] % 2 != 0 && !foundStartFlag {\\n           right += 1 \\n           left += 1\\n           continue\\n         }\\n\\n\\n         foundStartFlag = true\\n\\n         //calculating the previous index Modulas \\n         let prevInd = (right - 1 >=  0 ? right - 1  : -1)\\n         let prevIndMod = (prevInd == -1  ? -1 : nums[prevInd] % 2)\\n         \\n        // current right value is less than or equal threshold and the previous value is not the same modulas result \\n        // or in the other cases of starting a new range \\n        // ex 3 1 5 4 8 threshold = 4 \\n        // when right equal ind 2 the contigous sequence condition will fail because the prev is odd like right\\n        // so it will satsify the second condition which will set the right equal left for only one time for every new range \\n        // left == right says that a new range is being calculated \\n  \\n          if nums[right] <= threshold && (nums[right] % 2 != prevIndMod || left == right){\\n            maxLen = max(maxLen, right - left + 1)\\n          }\\n\\n          // right != left to prevent the loop of checking prev modulas value from happenning \\n          // left = right not right + 1 because we want to add the current right to the new range \\n          // it is less than threshold  \\n          else if nums[right] % 2 == prevIndMod && right != left {\\n            foundStartFlag = false\\n            left = right \\n            continue \\n          }\\n\\n          // left = right + 1 because the right value is greater than threshold\\n          else {\\n            foundStartFlag = false\\n            left = right + 1\\n          }\\n\\n         right += 1\\n         \\n       }\\n\\n\\n     return maxLen \\n      \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897711,
                "title": "longest-even-odd-subarray-with-threshold-c-dp",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        if(n == 1) if(nums[0] <= threshold) return nums[0] % 2 == 0 ? 1: 0; else return 0;\\n        int val = (nums[n-1] % 2 == 0 ? 0 : -1);\\n        \\n        int ans;\\n        if(nums[n-1] <= threshold) ans = val, dp[n-1] = 0;\\n        else ans = -1, dp[n-1] = -1;\\n        \\n        for(int i = n-2; i >= 0; --i) {\\n            if(nums[i] <= threshold) {\\n                if(nums[i] % 2 == 0 && nums[i+1] % 2 == 1) {\\n                    dp[i] = max(dp[i], dp[i+1] + 1);\\n                } else if(nums[i] % 2 == 1 && nums[i+1] % 2 == 0) {\\n                    dp[i] = max(dp[i], dp[i+1] + 1);\\n                }\\n\\n                if(nums[i] % 2 == 0) ans = max(ans, dp[i]);\\n            } else {\\n                dp[i] = -1;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        if(n == 1) if(nums[0] <= threshold) return nums[0] % 2 == 0 ? 1: 0; else return 0;\\n        int val = (nums[n-1] % 2 == 0 ? 0 : -1);\\n        \\n        int ans;\\n        if(nums[n-1] <= threshold) ans = val, dp[n-1] = 0;\\n        else ans = -1, dp[n-1] = -1;\\n        \\n        for(int i = n-2; i >= 0; --i) {\\n            if(nums[i] <= threshold) {\\n                if(nums[i] % 2 == 0 && nums[i+1] % 2 == 1) {\\n                    dp[i] = max(dp[i], dp[i+1] + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3896387,
                "title": "js-runtime-147-ms-beats-85-8",
                "content": "# Intuition\\nDouble loop and Logic.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    var max = 0\\n    var l = nums.length;\\n\\n\\n    for (var i = 0; i < l; i++){\\n        var sub = []\\n        if(nums[i]<=threshold){sub.push(nums[i])}\\n\\n        for (var j = i+1; j < l; j++){\\n            var bool0 = nums[j]<=threshold\\n            var bool1 = nums[j-1] % 2 != nums[j] % 2\\n            \\n            if(bool0 && bool1){ sub.push(nums[j])}else{\\n                break\\n            }        \\n        }\\n\\n        if(sub[0] % 2 == 0 && sub.length>max){\\n            max = Math.max(max,sub.length)\\n        }\\n       \\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    var max = 0\\n    var l = nums.length;\\n\\n\\n    for (var i = 0; i < l; i++){\\n        var sub = []\\n        if(nums[i]<=threshold){sub.push(nums[i])}\\n\\n        for (var j = i+1; j < l; j++){\\n            var bool0 = nums[j]<=threshold\\n            var bool1 = nums[j-1] % 2 != nums[j] % 2\\n            \\n            if(bool0 && bool1){ sub.push(nums[j])}else{\\n                break\\n            }        \\n        }\\n\\n        if(sub[0] % 2 == 0 && sub.length>max){\\n            max = Math.max(max,sub.length)\\n        }\\n       \\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894180,
                "title": "longest-even-odd-subarray-with-threshold-java-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int global=0;\\n\\n        int i=0;\\n\\n        int n=nums.length;\\n\\n        while(i<n){\\n            if(nums[i]>threshold || nums[i]%2!=0){\\n                i++;\\n                continue;\\n            }\\n\\n\\n\\n            int j=i+1;\\n\\n            while(j<n && nums[j]<=threshold){\\n                if((j-i)%2!=0){\\n                    if(nums[j]%2==0){\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[j]%2!=0){\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n\\n            global=Math.max(global,j-i);\\n            i=j;\\n            \\n        }\\n\\n        return global;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int global=0;\\n\\n        int i=0;\\n\\n        int n=nums.length;\\n\\n        while(i<n){\\n            if(nums[i]>threshold || nums[i]%2!=0){\\n                i++;\\n                continue;\\n            }\\n\\n\\n\\n            int j=i+1;\\n\\n            while(j<n && nums[j]<=threshold){\\n                if((j-i)%2!=0){\\n                    if(nums[j]%2==0){\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[j]%2!=0){\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n\\n            global=Math.max(global,j-i);\\n            i=j;\\n            \\n        }\\n\\n        return global;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893284,
                "title": "o-n-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        j = 0 \\n        count = 0 \\n        l = len(nums)\\n        arr = []\\n\\n        while(j<l):\\n            if nums[j] <= threshold:\\n                if len(arr) and arr[-1]%2 == 0 and nums[j] % 2 != 0 :\\n                    arr.append(nums[j])\\n                elif len(arr) and arr[-1]%2 != 0 and nums[j] % 2 == 0 :\\n                    arr.append(nums[j])\\n                elif len(arr) == 0 and nums[j] % 2 == 0 :\\n                    arr.append(nums[j])\\n                else :\\n                    count = max(count,len(arr))\\n                    arr = []\\n                    if nums[j] % 2 == 0 :\\n                        arr.append(nums[j])\\n            else :\\n                count = max(count,len(arr))\\n                arr = []\\n\\n            j += 1\\n        count = max(count,len(arr))\\n        return count\\n                \\n                \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        j = 0 \\n        count = 0 \\n        l = len(nums)\\n        arr = []\\n\\n        while(j<l):\\n            if nums[j] <= threshold:\\n                if len(arr) and arr[-1]%2 == 0 and nums[j] % 2 != 0 :\\n                    arr.append(nums[j])\\n                elif len(arr) and arr[-1]%2 != 0 and nums[j] % 2 == 0 :\\n                    arr.append(nums[j])\\n                elif len(arr) == 0 and nums[j] % 2 == 0 :\\n                    arr.append(nums[j])\\n                else :\\n                    count = max(count,len(arr))\\n                    arr = []\\n                    if nums[j] % 2 == 0 :\\n                        arr.append(nums[j])\\n            else :\\n                count = max(count,len(arr))\\n                arr = []\\n\\n            j += 1\\n        count = max(count,len(arr))\\n        return count\\n                \\n                \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893182,
                "title": "java-4ms-beats-99-69",
                "content": "# Intuition & Approach\\n- two-pointer strategy\\n- conveniently alternate target parity using `targetParity = (targetParity + 1) % 2;`\\n- restart outer loop where inner one failed using `l = r - 1;`\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 4ms Beats 99.69%\\n\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n\\n        // range looks like: [even odd even odd even odd...], with all vals <= `threshold`\\n\\n        int maxLength = 0;  // what we\\'ll return\\n\\n        for (int l = 0; l < nums.length; ++l) {\\n\\n            if (nums[l] % 2 != 0 || nums[l] > threshold) {\\n                continue;\\n            }\\n\\n            int curLength = 1;\\n            int targetParity = 1;\\n\\n            int r = l + 1;\\n            for ( ; r < nums.length; ++r) {\\n                if (nums[r] % 2 != targetParity || nums[r] > threshold) {\\n                    break;\\n                }\\n\\n                ++curLength;\\n                targetParity = (targetParity + 1) % 2;\\n            }\\n\\n            maxLength = Math.max(maxLength, curLength);\\n            l = r - 1;\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 4ms Beats 99.69%\\n\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n\\n        // range looks like: [even odd even odd even odd...], with all vals <= `threshold`\\n\\n        int maxLength = 0;  // what we\\'ll return\\n\\n        for (int l = 0; l < nums.length; ++l) {\\n\\n            if (nums[l] % 2 != 0 || nums[l] > threshold) {\\n                continue;\\n            }\\n\\n            int curLength = 1;\\n            int targetParity = 1;\\n\\n            int r = l + 1;\\n            for ( ; r < nums.length; ++r) {\\n                if (nums[r] % 2 != targetParity || nums[r] > threshold) {\\n                    break;\\n                }\\n\\n                ++curLength;\\n                targetParity = (targetParity + 1) % 2;\\n            }\\n\\n            maxLength = Math.max(maxLength, curLength);\\n            l = r - 1;\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889077,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# ********# creating all subarrays********\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# then checking all conditions\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n## ***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                if(nums[i]>threshold) continue;\\n                int count=1;\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2!=nums[j-1]%2 && nums[j]<=threshold)\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                \\n                ans=max(count,ans);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                if(nums[i]>threshold) continue;\\n                int count=1;\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2!=nums[j-1]%2 && nums[j]<=threshold)\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                \\n                ans=max(count,ans);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885676,
                "title": "2-approach-c-and-python-easy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int answ = 0;\\n        int mx = 0;\\n        for (int i = 0; i < nums.size();i++){\\n            int zp = i;\\n            while (i < nums.size() && nums[i] <= threshold && nums[i] % 2 == answ % 2){\\n                ++answ;\\n                mx = max(mx , answ);\\n                ++i;\\n            }\\n            answ = 0;\\n            i = zp;\\n            \\n        }\\n        return mx;\\n        \\n    }\\n};\\n\\n```\\n# Code\\n# Python\\n---\\n```python []\\n#2 POINTERS APPROACH\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l = 0\\n        r = 0\\n        answ = 0\\n        mx = 0\\n        n = len(nums)\\n        while l < n and r < n:\\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\\n                if nums[r] <= threshold:\\n                    if (r - l) % 2 == 0 and nums[r] % 2 == nums[l] % 2:\\n                        answ += 1\\n                        mx = max(mx , answ)\\n                        r += 1\\n                        continue\\n                    if (r - l) % 2 == 0 and nums[r] % 2 != nums[l] % 2:\\n                        answ = 0\\n                        l += 1\\n                        r = l\\n                        continue\\n                    \\n                    if (r - l) % 2 != 0 and nums[r] % 2 != nums[l] % 2:\\n                        answ += 1\\n                        mx = max(mx , answ)\\n                        r += 1\\n                        continue\\n                    \\n                    if (r - l) % 2 != 0 and nums[r] % 2 == nums[l] % 2:\\n                        answ = 0\\n                        l += 1\\n                        r = l\\n                        continue\\n                else:\\n                    answ = 0\\n                    l += 1\\n                    r = l\\n            else:\\n                answ = 0\\n                l += 1\\n                r = l\\n        return mx\\n        \\n\\n\\n```\\n```python []\\n#Sliding window approach\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        answ = mx = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) and nums[i] <= threshold and nums[i] % 2 == answ % 2:\\n                answ += 1\\n                mx = max(mx , answ)\\n                i += 1\\n            answ = 0\\n        return mx\\n\\n                \\n\\n        \\n            \\n\\n            \\n\\n        \\n        \\n        \\n\\n            \\n\\n            \\n\\n        \\n        \\n        \\n        \\n\\n\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int answ = 0;\\n        int mx = 0;\\n        for (int i = 0; i < nums.size();i++){\\n            int zp = i;\\n            while (i < nums.size() && nums[i] <= threshold && nums[i] % 2 == answ % 2){\\n                ++answ;\\n                mx = max(mx , answ);\\n                ++i;\\n            }\\n            answ = 0;\\n            i = zp;\\n            \\n        }\\n        return mx;\\n        \\n    }\\n};\\n\\n```\n```python []\\n#2 POINTERS APPROACH\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l = 0\\n        r = 0\\n        answ = 0\\n        mx = 0\\n        n = len(nums)\\n        while l < n and r < n:\\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\\n                if nums[r] <= threshold:\\n                    if (r - l) % 2 == 0 and nums[r] % 2 == nums[l] % 2:\\n                        answ += 1\\n                        mx = max(mx , answ)\\n                        r += 1\\n                        continue\\n                    if (r - l) % 2 == 0 and nums[r] % 2 != nums[l] % 2:\\n                        answ = 0\\n                        l += 1\\n                        r = l\\n                        continue\\n                    \\n                    if (r - l) % 2 != 0 and nums[r] % 2 != nums[l] % 2:\\n                        answ += 1\\n                        mx = max(mx , answ)\\n                        r += 1\\n                        continue\\n                    \\n                    if (r - l) % 2 != 0 and nums[r] % 2 == nums[l] % 2:\\n                        answ = 0\\n                        l += 1\\n                        r = l\\n                        continue\\n                else:\\n                    answ = 0\\n                    l += 1\\n                    r = l\\n            else:\\n                answ = 0\\n                l += 1\\n                r = l\\n        return mx\\n        \\n\\n\\n```\n```python []\\n#Sliding window approach\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        answ = mx = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) and nums[i] <= threshold and nums[i] % 2 == answ % 2:\\n                answ += 1\\n                mx = max(mx , answ)\\n                i += 1\\n            answ = 0\\n        return mx\\n\\n                \\n\\n        \\n            \\n\\n            \\n\\n        \\n        \\n        \\n\\n            \\n\\n            \\n\\n        \\n        \\n        \\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885453,
                "title": "nice-and-elegant-solution-in-java-beats-97-rt-and-99-memory",
                "content": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int output = 0;\\n        int current = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            current = 0;\\n            int k = i;\\n            while (k < nums.length && nums[k] % 2 == 0 && nums[k] <= threshold) {\\n                current++;\\n                output = Math.max(output, current);\\n                if (k + 1 < nums.length && nums[++k] % 2 != 0 && nums[k++] <= threshold) {\\n                    current++;\\n                    output = Math.max(output, current);\\n                } else {\\n                    output = Math.max(output, current);\\n                    break;\\n                }\\n            }\\n        }\\n        return output;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int output = 0;\\n        int current = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            current = 0;\\n            int k = i;\\n            while (k < nums.length && nums[k] % 2 == 0 && nums[k] <= threshold) {\\n                current++;\\n                output = Math.max(output, current);\\n                if (k + 1 < nums.length && nums[++k] % 2 != 0 && nums[k++] <= threshold) {\\n                    current++;\\n                    output = Math.max(output, current);\\n                } else {\\n                    output = Math.max(output, current);\\n                    break;\\n                }\\n            }\\n        }\\n        return output;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884793,
                "title": "java-easiest-solution-to-understand-the-problem",
                "content": "# Intuition\\nMy first intitution was to use a simple logic to check if i + 1 and i is alternating but I didn\\'t see the instruction clearly. So, wasted a lot of time.\\n\\n# Approach\\n- In the solution we first keep the res, curr = 0, in case all elements are odd and since we need our first element to be even nums[l] % 2 == 0 \\n- After that we run a loop from i = 0 to i < n and check if our current element is even and is below or equal to threshold and we increase the curr = 1, because we find the first even element and minimum subarray length can be 1.\\n- Then, we run a while loop to check if the i + 1 (odd) element is alternating to i element(even) \\n- We increase the curr if true, else we break and increase i.\\n- check if the curr is max such that res = Math.max(res, curr)\\n- and we reset curr = 0 for every element. \\n- return res. \\n# Complexity\\n- Time complexity:\\n  O(n)\\n- Space complexity:\\n  O(1)\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n       int res = 0;\\n        int curr = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            curr = 0;\\n            if (nums[i] % 2 == 0 && nums[i] <= threshold) {\\n                curr++;\\n                while(i+1 < n){\\n                    if((nums[i+1] % 2 != nums[i] % 2) && (nums[i+1] <= threshold)){\\n                      curr++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                    i++;\\n                }\\n            res = Math.max(res,curr);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n       int res = 0;\\n        int curr = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            curr = 0;\\n            if (nums[i] % 2 == 0 && nums[i] <= threshold) {\\n                curr++;\\n                while(i+1 < n){\\n                    if((nums[i+1] % 2 != nums[i] % 2) && (nums[i+1] <= threshold)){\\n                      curr++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                    i++;\\n                }\\n            res = Math.max(res,curr);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877832,
                "title": "go-two-pointers-with-comments",
                "content": "```\\nfunc longestAlternatingSubarray(nums []int, t int) int {\\n    res := 0\\n\\n    // start the left pointer at index 0\\n    for l := 0; l < len(nums); {\\n        // if the left pointer is not even or exceeds the threshold, increment it\\n        if nums[l] % 2 != 0 || nums[l] > t {\\n            l++\\n            continue\\n        }\\n\\n        // the right pointer is ahead to see how long the even odd subarray can be\\n        r := l + 1\\n\\n        // while right pointer points at value within threshold and follows even odd\\n        for r < len(nums) && nums[r] <= t && nums[r - 1] % 2 != nums[r] % 2 {\\n            r++\\n        }\\n\\n        // this is the length of [l, r - 1] inclusive\\n        cur := r - l\\n\\n        // update if new longest found\\n        if cur > res {\\n            res = cur\\n        }\\n\\n        // continue checking from right pointer onwards\\n        l = r\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestAlternatingSubarray(nums []int, t int) int {\\n    res := 0\\n\\n    // start the left pointer at index 0\\n    for l := 0; l < len(nums); {\\n        // if the left pointer is not even or exceeds the threshold, increment it\\n        if nums[l] % 2 != 0 || nums[l] > t {\\n            l++\\n            continue\\n        }\\n\\n        // the right pointer is ahead to see how long the even odd subarray can be\\n        r := l + 1\\n\\n        // while right pointer points at value within threshold and follows even odd\\n        for r < len(nums) && nums[r] <= t && nums[r - 1] % 2 != nums[r] % 2 {\\n            r++\\n        }\\n\\n        // this is the length of [l, r - 1] inclusive\\n        cur := r - l\\n\\n        // update if new longest found\\n        if cur > res {\\n            res = cur\\n        }\\n\\n        // continue checking from right pointer onwards\\n        l = r\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3875836,
                "title": "longest-even-odd-subarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        num=0\\n        for i in range(len(nums)):\\n            if nums[i]%2==0 and nums[i]<=threshold:\\n                lst=[i]\\n                for j in range(i+1,len(nums)):\\n                    if (j-i)%2!=0 and nums[j]<=threshold and nums[j]%2!=0:\\n                        lst.append(nums[j])\\n                    elif (j-i)%2==0 and nums[j]<=threshold and nums[j]%2==0:\\n                        lst.append(nums[j])\\n                    else:\\n                        break\\n                if num<len(lst):\\n                    num=len(lst)\\n        return num\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        num=0\\n        for i in range(len(nums)):\\n            if nums[i]%2==0 and nums[i]<=threshold:\\n                lst=[i]\\n                for j in range(i+1,len(nums)):\\n                    if (j-i)%2!=0 and nums[j]<=threshold and nums[j]%2!=0:\\n                        lst.append(nums[j])\\n                    elif (j-i)%2==0 and nums[j]<=threshold and nums[j]%2==0:\\n                        lst.append(nums[j])\\n                    else:\\n                        break\\n                if num<len(lst):\\n                    num=len(lst)\\n        return num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864685,
                "title": "swift-o-n-time-o-1-space-beats-100-explained-in-comments",
                "content": "# Code\\n```\\nclass Solution {\\n    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {\\n        var (limit, longest) = (0, 0)\\n        while limit < nums.count {\\n            // Find a valid starting point in the remaining portion of the array\\n            guard let l = nums[limit...].firstIndex(where: { $0 % 2 == 0 && $0 <= threshold }) else { return longest }\\n            // Given this starting point, extend the sequence as far as we can\\n            var r = l + 1\\n            while r < nums.count && nums[r] <= threshold && nums[r - 1] % 2 != nums[r] % 2 {\\n                r += 1\\n            }\\n            // Update longest and contiue searching the remainder of the array\\n            (limit,longest) = (r, max(longest, r - l))\\n        }\\n        return longest\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {\\n        var (limit, longest) = (0, 0)\\n        while limit < nums.count {\\n            // Find a valid starting point in the remaining portion of the array\\n            guard let l = nums[limit...].firstIndex(where: { $0 % 2 == 0 && $0 <= threshold }) else { return longest }\\n            // Given this starting point, extend the sequence as far as we can\\n            var r = l + 1\\n            while r < nums.count && nums[r] <= threshold && nums[r - 1] % 2 != nums[r] % 2 {\\n                r += 1\\n            }\\n            // Update longest and contiue searching the remainder of the array\\n            (limit,longest) = (r, max(longest, r - l))\\n        }\\n        return longest\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863089,
                "title": "easiest-java-solution-two-pointers",
                "content": "# Intuition\\nThinking how to write the code\\n\\n# Approach\\nWriting the code\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] % 2 == 0 && nums[i] <= threshold) {\\n                int l = i + 1;\\n                while(l < nums.length && nums[l] <= threshold &&\\n                nums[l] % 2 != nums[l - 1] % 2) {\\n                    l++;\\n                }\\n\\n                ans = Math.max(ans, l - i);\\n            }\\n            else continue;\\n        }     \\n\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nUpvote if you are a gigachad",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] % 2 == 0 && nums[i] <= threshold) {\\n                int l = i + 1;\\n                while(l < nums.length && nums[l] <= threshold &&\\n                nums[l] % 2 != nums[l - 1] % 2) {\\n                    l++;\\n                }\\n\\n                ans = Math.max(ans, l - i);\\n            }\\n            else continue;\\n        }     \\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862659,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {\\n        \\n        guard var l = nums.firstIndex(where: { $0 % 2 == 0 && $0 <= threshold }) else {\\n            return 0\\n        }\\n\\n        var best = 0\\n\\n        while l < nums.count {\\n        \\n            var r = l\\n\\n            while r < nums.count - 1, nums[r + 1] <= threshold, nums[r + 1] % 2 != nums[r] % 2 {\\n                r += 1\\n            }\\n\\n            best = max(best, r - l + 1)\\n            l = r + 1\\n\\n            while l < nums.count && (nums[l] > threshold || nums[l] % 2 != 0) {\\n                l += 1\\n            }\\n        }\\n\\n        return best\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {\\n        \\n        guard var l = nums.firstIndex(where: { $0 % 2 == 0 && $0 <= threshold }) else {\\n            return 0\\n        }\\n\\n        var best = 0\\n\\n        while l < nums.count {\\n        \\n            var r = l\\n\\n            while r < nums.count - 1, nums[r + 1] <= threshold, nums[r + 1] % 2 != nums[r] % 2 {\\n                r += 1\\n            }\\n\\n            best = max(best, r - l + 1)\\n            l = r + 1\\n\\n            while l < nums.count && (nums[l] > threshold || nums[l] % 2 != 0) {\\n                l += 1\\n            }\\n        }\\n\\n        return best\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854790,
                "title": "java-solution-with-explaination",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe would have to keep account of 2 variables - one that would get the count for each iteration, and another that will store the maximum of these counts. \\nHence, initialize count and ans to 0.\\nNow start the iteration:\\n* Initialise count to 0\\n*  Check whether the 1st element of subarray is even, and <= threshold\\n    If so :\\n    *  Increment the count, and start iterating through the subarray-\\n    *   Check the condition given in the problem, and increment count\\n    *   If the condition isn\\'t satisfied, then break the loop\\n* After the subarray ends, store the max of current count and previous count in ans\\n\\n* Return ans \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            count=0;\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                count++;\\n                while(i+1 <nums.length){\\n                    if(nums[i]%2!=nums[i+1]%2 && nums[i+1]<=threshold){\\n                        count++;\\n                    }\\n                    else break;\\n                    i++;\\n                }\\n                ans=Math.max(ans,count);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            count=0;\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                count++;\\n                while(i+1 <nums.length){\\n                    if(nums[i]%2!=nums[i+1]%2 && nums[i+1]<=threshold){\\n                        count++;\\n                    }\\n                    else break;\\n                    i++;\\n                }\\n                ans=Math.max(ans,count);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851671,
                "title": "fastest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int th) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=th && nums[i]%2==0){\\n                int j=i+1;\\n                while(j<nums.length && nums[j]<=th && (nums[j]%2 != nums[j-1]%2)) j++;  \\n            c=(c<(j-i))?(j-i):c;              \\n            i=j-1;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int th) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=th && nums[i]%2==0){\\n                int j=i+1;\\n                while(j<nums.length && nums[j]<=th && (nums[j]%2 != nums[j-1]%2)) j++;  \\n            c=(c<(j-i))?(j-i):c;              \\n            i=j-1;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849020,
                "title": "easy-to-understand-linear-time-complexity-constant-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l, r, ans, n = 0, 0, 0, len(nums)\\n        while l < n and r < n:\\n            if l < n and nums[l] % 2 == 0 and nums[l] <= threshold:\\n                r = l + 1\\n                while r < n and nums[r-1] % 2 != nums[r] % 2 and nums[r] <= threshold:\\n                    r += 1\\n                ans = max(ans, r-l)\\n                l = r - 1\\n            l += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l, r, ans, n = 0, 0, 0, len(nums)\\n        while l < n and r < n:\\n            if l < n and nums[l] % 2 == 0 and nums[l] <= threshold:\\n                r = l + 1\\n                while r < n and nums[r-1] % 2 != nums[r] % 2 and nums[r] <= threshold:\\n                    r += 1\\n                ans = max(ans, r-l)\\n                l = r - 1\\n            l += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846008,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Use the Sliding Window Technique to find the longest subarray that also satisfies the given conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Let the end pointer iterate normaly in the for loop\\n- move the start pointer according the this conditions: \\n    - nums[l] % 2 == 0\\n    - For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2\\n    - For all indices i in the range [l, r], nums[i] <= threshold \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        start = 0\\n        length = len(nums)\\n        end = 0\\n        maxi = 0\\n\\n        for end in range(length):\\n            while start < length and (nums[start] % 2 != 0 or nums[start] > threshold):\\n                start += 1\\n\\n            if end > start and (nums[end] % 2 == nums[end-1] % 2 or nums[end] > threshold):\\n                start = end\\n\\n            if start <= end:\\n                maxi = max(maxi, end - start + 1)\\n\\n        return maxi\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        start = 0\\n        length = len(nums)\\n        end = 0\\n        maxi = 0\\n\\n        for end in range(length):\\n            while start < length and (nums[start] % 2 != 0 or nums[start] > threshold):\\n                start += 1\\n\\n            if end > start and (nums[end] % 2 == nums[end-1] % 2 or nums[end] > threshold):\\n                start = end\\n\\n            if start <= end:\\n                maxi = max(maxi, end - start + 1)\\n\\n        return maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838006,
                "title": "easiest-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& arr, int th) {\\n        int n = arr.size();\\n        int f = 0, b = 0;\\n        int ans = 0;\\n        bool hasFound = false;\\n        while(1) {\\n            if(arr[f]%2 == 0 && arr[f] <= th) {\\n                hasFound = true;\\n                // cout << \\'f\\' << endl;\\n            } else {\\n                // cout << (arr[f]) << \\' \\' << (!(arr[f]%2)) << \\' \\' << (arr[f] <= th) << endl;\\n                hasFound = false;\\n                f++; \\n                b++;\\n            }\\n            \\n            if(f == n) break;\\n            \\n            if(hasFound) {\\n                bool parity = false;\\n                while(f < n && arr[f]%2 == parity && arr[f] <= th) {\\n                    f++;\\n                    parity = !parity;\\n                }\\n                ans = max(ans, f - b);\\n                b = f;\\n            } \\n            \\n            if(f == n) {\\n                break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& arr, int th) {\\n        int n = arr.size();\\n        int f = 0, b = 0;\\n        int ans = 0;\\n        bool hasFound = false;\\n        while(1) {\\n            if(arr[f]%2 == 0 && arr[f] <= th) {\\n                hasFound = true;\\n                // cout << \\'f\\' << endl;\\n            } else {\\n                // cout << (arr[f]) << \\' \\' << (!(arr[f]%2)) << \\' \\' << (arr[f] <= th) << endl;\\n                hasFound = false;\\n                f++; \\n                b++;\\n            }\\n            \\n            if(f == n) break;\\n            \\n            if(hasFound) {\\n                bool parity = false;\\n                while(f < n && arr[f]%2 == parity && arr[f] <= th) {\\n                    f++;\\n                    parity = !parity;\\n                }\\n                ans = max(ans, f - b);\\n                b = f;\\n            } \\n            \\n            if(f == n) {\\n                break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3826164,
                "title": "sliding-window-two-pointers-o-n-solution",
                "content": "# Intuition\\nTwo pointer problem, keep track of left and right pointer. First make sure left pointer is at a valid value, then keep incrementing right pointer until right pointer either reaches end or invalidates the condition, then calculate and compare with previous max length, and move left pointer up\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        left, right = 0, 0\\n        max_len = 0\\n\\n        while right < len(nums):\\n            if nums[left] % 2 != 0 or nums[left] > threshold:\\n                left += 1\\n                right += 1\\n                continue\\n            if nums[right] > threshold:\\n                max_len = max(max_len, right - left)\\n                left = right + 1\\n                right = right + 1\\n                continue\\n            if nums[right] % 2 != nums[right - 1] % 2:\\n                right += 1\\n            else:\\n                max_len = max(max_len, right - left)\\n                left = right\\n                right = left + 1\\n        return max(max_len, right - left)\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        left, right = 0, 0\\n        max_len = 0\\n\\n        while right < len(nums):\\n            if nums[left] % 2 != 0 or nums[left] > threshold:\\n                left += 1\\n                right += 1\\n                continue\\n            if nums[right] > threshold:\\n                max_len = max(max_len, right - left)\\n                left = right + 1\\n                right = right + 1\\n                continue\\n            if nums[right] % 2 != nums[right - 1] % 2:\\n                right += 1\\n            else:\\n                max_len = max(max_len, right - left)\\n                left = right\\n                right = left + 1\\n        return max(max_len, right - left)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821761,
                "title": "using-java-sliding-window-easy-question-but-with-many-edge-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int ans = 0;\\n        int start= -1;\\n        int currAns = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(start==-1 && nums[i]%2==0 && nums[i]<=threshold){\\n                start = i;     \\n            }\\n\\n            if(start!=-1 && nums[i]<=threshold){\\n                if(currAns==0){\\n                    currAns++;\\n                }\\n                else{\\n                    if(nums[i]%2 != nums[i-1]%2){\\n                        currAns++;\\n                    }\\n                    else{\\n                        ans = Math.max(ans,currAns);\\n                        start=(nums[i]%2==0)?i:-1;\\n                        currAns = start!=-1?1:0;\\n                    }\\n                }\\n                ans = Math.max(ans,currAns);\\n            }\\n            else{\\n                ans = Math.max(ans,currAns);\\n                start=-1;\\n                currAns = 0;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int ans = 0;\\n        int start= -1;\\n        int currAns = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(start==-1 && nums[i]%2==0 && nums[i]<=threshold){\\n                start = i;     \\n            }\\n\\n            if(start!=-1 && nums[i]<=threshold){\\n                if(currAns==0){\\n                    currAns++;\\n                }\\n                else{\\n                    if(nums[i]%2 != nums[i-1]%2){\\n                        currAns++;\\n                    }\\n                    else{\\n                        ans = Math.max(ans,currAns);\\n                        start=(nums[i]%2==0)?i:-1;\\n                        currAns = start!=-1?1:0;\\n                    }\\n                }\\n                ans = Math.max(ans,currAns);\\n            }\\n            else{\\n                ans = Math.max(ans,currAns);\\n                start=-1;\\n                currAns = 0;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817407,
                "title": "go-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind each member\\'s longest array to get the max one.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc longestAlternatingSubarray(nums []int, threshold int) int {\\n\\tres := 0\\n\\tfor i, v := range nums {\\n\\t\\tif v%2 == 0 && res < len(nums)-i{\\n\\t\\t\\ttemp := FindLongestArray(nums[i:], threshold)\\n\\t\\t\\tif temp > res {\\n\\t\\t\\t\\tres = temp\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc FindLongestArray(nums []int, threshold int) int {\\n\\tres := 0\\n\\tfor _, v := range nums {\\n\\t\\tif ((v-res)%2 != 0) || (v > threshold) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tres++\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestAlternatingSubarray(nums []int, threshold int) int {\\n\\tres := 0\\n\\tfor i, v := range nums {\\n\\t\\tif v%2 == 0 && res < len(nums)-i{\\n\\t\\t\\ttemp := FindLongestArray(nums[i:], threshold)\\n\\t\\t\\tif temp > res {\\n\\t\\t\\t\\tres = temp\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc FindLongestArray(nums []int, threshold int) int {\\n\\tres := 0\\n\\tfor _, v := range nums {\\n\\t\\tif ((v-res)%2 != 0) || (v > threshold) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tres++\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3812945,
                "title": "c-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int res = 0, curr = 0, prev = 1;\\n        for (int i = 0; i < nums.size(); ++ i) {\\n            if (nums[i] <= threshold && ((nums[i] & 1) ^ prev)) {\\n                prev ^= 1;\\n                ++ curr;\\n            } else {\\n                res = max(res, curr);\\n                if (nums[i] > threshold || nums[i] & 1) {\\n                    prev = 1;\\n                    curr = 0;\\n                } else {\\n                    prev = 0;\\n                    curr = 1;\\n                }\\n            }\\n        }\\n        res = max(res, curr);\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int res = 0, curr = 0, prev = 1;\\n        for (int i = 0; i < nums.size(); ++ i) {\\n            if (nums[i] <= threshold && ((nums[i] & 1) ^ prev)) {\\n                prev ^= 1;\\n                ++ curr;\\n            } else {\\n                res = max(res, curr);\\n                if (nums[i] > threshold || nums[i] & 1) {\\n                    prev = 1;\\n                    curr = 0;\\n                } else {\\n                    prev = 0;\\n                    curr = 1;\\n                }\\n            }\\n        }\\n        res = max(res, curr);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806897,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let res=0;\\n    let n=0;\\n    let is_starting = false;\\n    for (let i=0; i<nums.length; i++){\\n        if(nums[i]%2==0 && !is_starting && nums[i]<= threshold){\\n            is_starting=true;\\n            n++;\\n        } else if(is_starting && nums[i]<= threshold && nums[i-1]%2 != nums[i]%2){\\n            n++;\\n        }else{\\n            if(is_starting) i--;\\n            is_starting=false;\\n            n=0;\\n        }\\n        if(n>res){\\n            res=n;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let res=0;\\n    let n=0;\\n    let is_starting = false;\\n    for (let i=0; i<nums.length; i++){\\n        if(nums[i]%2==0 && !is_starting && nums[i]<= threshold){\\n            is_starting=true;\\n            n++;\\n        } else if(is_starting && nums[i]<= threshold && nums[i-1]%2 != nums[i]%2){\\n            n++;\\n        }else{\\n            if(is_starting) i--;\\n            is_starting=false;\\n            n=0;\\n        }\\n        if(n>res){\\n            res=n;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806324,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun longestAlternatingSubarray(nums: IntArray, threshold: Int): Int {\\n        var maxLength = 0\\n        var i = 0\\n\\n        while (i < nums.size) {\\n            if (nums[i] % 2 == 0 && nums[i] <= threshold) {\\n                var length = 1\\n                var j = i + 1\\n\\n                while (j < nums.size\\n                        && nums[j] <= threshold\\n                        && nums[j] % 2 != nums[j-1] % 2) {\\n                    length++\\n                    j++\\n                }\\n\\n                maxLength = Math.max(maxLength, length)\\n                i = j - 1\\n            }\\n\\n            i++\\n        }\\n\\n        return maxLength\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun longestAlternatingSubarray(nums: IntArray, threshold: Int): Int {\\n        var maxLength = 0\\n        var i = 0\\n\\n        while (i < nums.size) {\\n            if (nums[i] % 2 == 0 && nums[i] <= threshold) {\\n                var length = 1\\n                var j = i + 1\\n\\n                while (j < nums.size\\n                        && nums[j] <= threshold\\n                        && nums[j] % 2 != nums[j-1] % 2) {\\n                    length++\\n                    j++\\n                }\\n\\n                maxLength = Math.max(maxLength, length)\\n                i = j - 1\\n            }\\n\\n            i++\\n        }\\n\\n        return maxLength\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805262,
                "title": "nested-for-loop-with-7-ms-simple-solution-with-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int max = 0;\\n        for ( int i = 0; i<nums.length && max < (nums.length-i); i++){ //filtering when the remaining elements are impossible to greater than max\\n            int count = 0;\\n            if (nums[i] %2 !=0  || nums[i] > threshold){ // ignore nums that are odd or exceed threshold, ignore and return max = 0 directly\\n                continue;\\n            }\\n            else{\\n                count+=1; // To deal with the situation of sigle arr with only one even num\\n                max = Math.max(count,max);\\n            }\\n            for (int j = i + 1 ; j< nums.length  ;j++){\\n                if (nums[j]%2 != nums[j-1]%2 && nums[j] <= threshold){ // even -> odd -> even\\n                    count+=1;\\n                    max = Math.max(count,max);\\n                    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int max = 0;\\n        for ( int i = 0; i<nums.length && max < (nums.length-i); i++){ //filtering when the remaining elements are impossible to greater than max\\n            int count = 0;\\n            if (nums[i] %2 !=0  || nums[i] > threshold){ // ignore nums that are odd or exceed threshold, ignore and return max = 0 directly\\n                continue;\\n            }\\n            else{\\n                count+=1; // To deal with the situation of sigle arr with only one even num\\n                max = Math.max(count,max);\\n            }\\n            for (int j = i + 1 ; j< nums.length  ;j++){\\n                if (nums[j]%2 != nums[j-1]%2 && nums[j] <= threshold){ // even -> odd -> even\\n                    count+=1;\\n                    max = Math.max(count,max);\\n                    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799946,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool oddeven(int a, int b){\\n        return ((a&1) != (b&1));\\n    }\\n\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]%2 == 0 && nums[i]<= threshold){\\n                int count = 1;\\n\\n                for(int j=i+1; j<n; j++){\\n                    if(oddeven(nums[j],nums[j-1]) && max(nums[j],nums[j-1])<=threshold) count++;\\n                    else break;\\n                }\\n\\n                ans = max(count, ans);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool oddeven(int a, int b){\\n        return ((a&1) != (b&1));\\n    }\\n\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]%2 == 0 && nums[i]<= threshold){\\n                int count = 1;\\n\\n                for(int j=i+1; j<n; j++){\\n                    if(oddeven(nums[j],nums[j-1]) && max(nums[j],nums[j-1])<=threshold) count++;\\n                    else break;\\n                }\\n\\n                ans = max(count, ans);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798650,
                "title": "simple-o-n-speed",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) {\\n    \\n        var counter = 0;\\n        var maxSub = 0;\\n\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if ((nums[i] % 2 == 0) && (nums[i] <= threshold))\\n            {\\n                counter++;\\n                if (i+1 < nums.Length)\\n                {\\n                        if ((nums[i+1] % 2 != 0) && (nums[i+1] <= threshold))\\n                        {\\n                            counter++;\\n                            i++;\\n                        }\\n\\n                        else\\n                        {\\n                            maxSub = Math.Max(counter, maxSub);\\n                            counter = 0;\\n                        }\\n                }  \\n            }\\n            else\\n                {\\n                    maxSub = Math.Max(counter, maxSub);\\n                    counter = 0;\\n                }\\n\\n        }\\n\\n        return Math.Max(counter, maxSub);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) {\\n    \\n        var counter = 0;\\n        var maxSub = 0;\\n\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if ((nums[i] % 2 == 0) && (nums[i] <= threshold))\\n            {\\n                counter++;\\n                if (i+1 < nums.Length)\\n                {\\n                        if ((nums[i+1] % 2 != 0) && (nums[i+1] <= threshold))\\n                        {\\n                            counter++;\\n                            i++;\\n                        }\\n\\n                        else\\n                        {\\n                            maxSub = Math.Max(counter, maxSub);\\n                            counter = 0;\\n                        }\\n                }  \\n            }\\n            else\\n                {\\n                    maxSub = Math.Max(counter, maxSub);\\n                    counter = 0;\\n                }\\n\\n        }\\n\\n        return Math.Max(counter, maxSub);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793779,
                "title": "very-easy-solution-in-java-100-understand",
                "content": "# Intuition:\\n\\nThe problem asks to find the length of the longest alternating subarray satisfying certain conditions. The alternating subarray is defined as follows: the first element must be an even number less than or equal to `threshold`, and for all subsequent elements, the parity (odd or even) must be different from the previous element. Additionally, all elements in the subarray must be less than or equal to the given `threshold`.\\n\\n# Approach:\\n\\nThe given solution implements a simple approach using a single loop to iterate over the `nums` array. For each element in the array that satisfies the condition of being an even number less than or equal to `threshold`, it checks the length of the longest alternating subarray starting from that element. To find this length, the code uses a nested `while` loop, which continues as long as the next element satisfies the alternating condition and is less than or equal to `threshold`. This way, the code finds the length of the longest alternating subarray starting from each suitable element and keeps track of the maximum length found.\\n\\n# Time Complexity:\\n\\nThe time complexity of this solution is O(n), where n is the length of the `nums` array. The single loop iterates over each element once, and for each element, the nested `while` loop checks the condition for alternating subarrays. The maximum number of times the nested loop runs is proportional to the number of elements that satisfy the alternating condition, which is at most n (considering the entire array). Therefore, the overall time complexity is linear.\\n\\n# Space Complexity:\\n\\nThe space complexity of the solution is O(1) since it uses a constant amount of extra space. The space required for variables `len`, `i`, and `j` remains constant, irrespective of the input size. The solution does not use any additional data structures whose space requirements depend on the input size. Thus, the space complexity is constant.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int len = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                int j = i+1;\\n                while(j< nums.length && nums[j]<= threshold && (nums[j-1]%2 != nums[j]%2)){\\n                    j++;\\n                }\\n                len = Math.max(len,j-i);\\n            }    \\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int len = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                int j = i+1;\\n                while(j< nums.length && nums[j]<= threshold && (nums[j-1]%2 != nums[j]%2)){\\n                    j++;\\n                }\\n                len = Math.max(len,j-i);\\n            }    \\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792094,
                "title": "linear-time-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, threshold: int) -> int:\\n        self.nums = nums\\n        self.threshold = threshold\\n        left = self.maintain_left()\\n        res = 0\\n        temp = 0\\n        even = True\\n        while left < len(self.nums):\\n            if even and self.nums[left] % 2 == 0 and self.nums[left] <= threshold:\\n                temp += 1\\n                even = not even\\n            elif not even and self.nums[left] % 2 and self.nums[left] <= threshold:\\n                temp += 1\\n                even = not even\\n            else:\\n                res = max(temp, res)\\n                temp = 1\\n                left = self.maintain_left(left)\\n                even = False\\n                if left == -1:\\n                    return res\\n            left += 1\\n            \\n        return max(res, temp)\\n        \\n            \\n        \\n    def maintain_left(self, i = 0):\\n        for i in range(i, len(self.nums)):\\n            if self.nums[i] % 2 == 0 and self.nums[i] <= self.threshold: return i\\n            \\n        return -1\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums, threshold: int) -> int:\\n        self.nums = nums\\n        self.threshold = threshold\\n        left = self.maintain_left()\\n        res = 0\\n        temp = 0\\n        even = True\\n        while left < len(self.nums):\\n            if even and self.nums[left] % 2 == 0 and self.nums[left] <= threshold:\\n                temp += 1\\n                even = not even\\n            elif not even and self.nums[left] % 2 and self.nums[left] <= threshold:\\n                temp += 1\\n                even = not even\\n            else:\\n                res = max(temp, res)\\n                temp = 1\\n                left = self.maintain_left(left)\\n                even = False\\n                if left == -1:\\n                    return res\\n            left += 1\\n            \\n        return max(res, temp)\\n        \\n            \\n        \\n    def maintain_left(self, i = 0):\\n        for i in range(i, len(self.nums)):\\n            if self.nums[i] % 2 == 0 and self.nums[i] <= self.threshold: return i\\n            \\n        return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785179,
                "title": "java-2-pointers-explained",
                "content": "**Idea:**\\n* Iterate through the array and skip any `left` number which is not even or > `threshold`, since the sub-array must begin at an even number\\n* If the even-odd parity is opposite for the neighbors and the right neighbor \\u2264 `threshold`, then increment the size, else stop\\n* Record the local maxima size and store in global maxima if it exceeds the current value\\n* Don\\'t get confused by nested loops to be quadratic time. The left pointer runs in both the loops and runs from end to end just once\\n* IMO, for a linear time, constant space solution, this problem is a low Medium\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int longestAlternatingSubarray(int[] nums, int threshold) {\\n\\tvar maxSize = 0;\\n\\tvar n = nums.length;\\n\\n\\tfor (var left = 0; left < n; left++) {\\n\\t\\tif ((nums[left] & 1) == 1 || nums[left] > threshold)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar size = 1;\\n\\t\\tfor (; left + 1 < n && (nums[left] & 1) != (nums[left + 1] & 1) && nums[left + 1] <= threshold; left++, size++);\\n\\t\\tmaxSize = Math.max(maxSize, size);\\n\\t}\\n\\n\\treturn maxSize;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int longestAlternatingSubarray(int[] nums, int threshold) {\\n\\tvar maxSize = 0;\\n\\tvar n = nums.length;\\n\\n\\tfor (var left = 0; left < n; left++) {\\n\\t\\tif ((nums[left] & 1) == 1 || nums[left] > threshold)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar size = 1;\\n\\t\\tfor (; left + 1 < n && (nums[left] & 1) != (nums[left + 1] & 1) && nums[left + 1] <= threshold; left++, size++);\\n\\t\\tmaxSize = Math.max(maxSize, size);\\n\\t}\\n\\n\\treturn maxSize;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782634,
                "title": "c-2-pointer-solution-99-time-81ms-80-space-90-92mb",
                "content": "Nice neat 2 pointer/sliding window problem we can conveniently pass in linear time and with very little memory.\\n\\nTo do so, we will start with our support variables:\\n* `len` will store the length of `nums`;\\n* `res` will be our usual result variable, initially set to `0` (ie: no element matching our requirements).\\n\\nWe will then loop with `i` through each element in `nums` and:\\n* store `nums[i]` in `n`;\\n* move past elements not fitting our requirements, being either odd (ie: `n & 1`) or above the limit (ie: `n > t`), with a `continue` statement;\\n* set up our inner loops variables, with `j` being one position past `i` (ie: `i + 1`) and `curr`, being the length of our current streak, set to an initial value of `1` (ie: the cell pointed by `i` we just validated);\\n* loop potentially `while` we are not out of boundaries and:\\n    * store `nums[j]` in `n`;\\n    * increase `j` by `1`;\\n    * `break` if either `n` is `> t` like before or it does not match the expected even-odd pattern that we can check with `curr` (ie: `(n & 1) != (curr & 1)`);\\n    * increase `curr` by `1`;\\n* finally, update `res` to be the maximum between its current value and `curr`.\\n\\nOnce done, we can just `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int> &nums, int t) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        // parsing nums\\n        for (int i = 0, j, curr, n; i < len; i++) {\\n            n = nums[i];\\n            // ignoring odd starting or above t elements\\n            if ((n & 1) || n > t) continue;\\n            j = i + 1, curr = 1;\\n            while (j < len) {\\n                n = nums[j++];\\n                // stopping when we find values above t or not matching the even-odd pattern\\n                if (n > t || (n & 1) != (curr & 1)) break;\\n                curr++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWe can do a bit better at the end of our loop if we consider that there is no poin in re-parsing elements of a series we already validated, so we can update `i` to equal `j`, minus `1` if `curr` is odd:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int> &nums, int t) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        // parsing nums\\n        for (int i = 0, j, curr, n; i < len; i++) {\\n            n = nums[i];\\n            // ignoring odd starting elements\\n            if ((n & 1) || n > t) continue;\\n            j = i + 1, curr = 1;\\n            while (j < len) {\\n                n = nums[j];\\n                // stopping when we find values above t or not matching the even-odd pattern\\n                if (n > t || (n & 1) != (curr & 1)) break;\\n                curr++, j++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n            // skipping the parsed elements with i\\n            i = j - (curr & 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int> &nums, int t) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        // parsing nums\\n        for (int i = 0, j, curr, n; i < len; i++) {\\n            n = nums[i];\\n            // ignoring odd starting or above t elements\\n            if ((n & 1) || n > t) continue;\\n            j = i + 1, curr = 1;\\n            while (j < len) {\\n                n = nums[j++];\\n                // stopping when we find values above t or not matching the even-odd pattern\\n                if (n > t || (n & 1) != (curr & 1)) break;\\n                curr++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int> &nums, int t) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        // parsing nums\\n        for (int i = 0, j, curr, n; i < len; i++) {\\n            n = nums[i];\\n            // ignoring odd starting elements\\n            if ((n & 1) || n > t) continue;\\n            j = i + 1, curr = 1;\\n            while (j < len) {\\n                n = nums[j];\\n                // stopping when we find values above t or not matching the even-odd pattern\\n                if (n > t || (n & 1) != (curr & 1)) break;\\n                curr++, j++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n            // skipping the parsed elements with i\\n            i = j - (curr & 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781424,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        int i = 0;\\n\\n        for( ; i < nums.length ; i++){\\n            if(nums[i] % 2 != 0 || nums[i] > threshold){\\n                continue;\\n            }\\n            int temp = 1;\\n            int j = i;\\n            for( ; j < nums.length - 1 ; j++){\\n                if(nums[j] % 2 != nums[j + 1] % 2 && nums[j + 1] <= threshold){\\n                    temp++;\\n                }else{\\n                    break;\\n                }\\n            }\\n\\n            ans = Math.max(ans , temp);\\n            i = j;\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        int i = 0;\\n\\n        for( ; i < nums.length ; i++){\\n            if(nums[i] % 2 != 0 || nums[i] > threshold){\\n                continue;\\n            }\\n            int temp = 1;\\n            int j = i;\\n            for( ; j < nums.length - 1 ; j++){\\n                if(nums[j] % 2 != nums[j + 1] % 2 && nums[j + 1] <= threshold){\\n                    temp++;\\n                }else{\\n                    break;\\n                }\\n            }\\n\\n            ans = Math.max(ans , temp);\\n            i = j;\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780865,
                "title": "javascript-sloution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)2$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let max = 0;\\n    let n = nums.length;\\n    for (let i=0; i<n; i++) {\\n        if (nums[i] % 2 != 0 || nums[i] > threshold) continue;\\n        let start = i;\\n        while (i < n && nums[i] % 2 != nums[i+1] % 2 && nums[i+1] <= threshold) i++;\\n        max = Math.max(max, i-start+1);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let max = 0;\\n    let n = nums.length;\\n    for (let i=0; i<n; i++) {\\n        if (nums[i] % 2 != 0 || nums[i] > threshold) continue;\\n        let start = i;\\n        while (i < n && nums[i] % 2 != nums[i+1] % 2 && nums[i+1] <= threshold) i++;\\n        max = Math.max(max, i-start+1);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780864,
                "title": "javascript-sloution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)2$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let max = 0;\\n    let n = nums.length;\\n    for (let i=0; i<n; i++) {\\n        if (nums[i] % 2 != 0 || nums[i] > threshold) continue;\\n        let start = i;\\n        while (i < n && nums[i] % 2 != nums[i+1] % 2 && nums[i+1] <= threshold) i++;\\n        max = Math.max(max, i-start+1);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let max = 0;\\n    let n = nums.length;\\n    for (let i=0; i<n; i++) {\\n        if (nums[i] % 2 != 0 || nums[i] > threshold) continue;\\n        let start = i;\\n        while (i < n && nums[i] % 2 != nums[i+1] % 2 && nums[i+1] <= threshold) i++;\\n        max = Math.max(max, i-start+1);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767418,
                "title": "cpp-two-pointer-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int i=0;\\n        int j=0;\\n        int cnt = 0;\\n        int maxx = 0;\\n        while(i<nums.size() && j<nums.size()){\\n            // cout<<\"i=\"<<i<<endl;\\n            // cout<<\"j=\"<<j<<endl;\\n            if(cnt==0){\\n                if(nums[i]<=threshold && nums[i]%2==0){\\n                    j=i+1;\\n                    cnt++;\\n                    maxx = max(maxx,cnt);\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            else{\\n                if(nums[j]%2 != nums[j-1]%2 && nums[j]<=threshold){\\n                    cnt++;\\n                    j++;\\n                    maxx = max(maxx,cnt);\\n                }\\n                else{\\n                    i=j;\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int i=0;\\n        int j=0;\\n        int cnt = 0;\\n        int maxx = 0;\\n        while(i<nums.size() && j<nums.size()){\\n            // cout<<\"i=\"<<i<<endl;\\n            // cout<<\"j=\"<<j<<endl;\\n            if(cnt==0){\\n                if(nums[i]<=threshold && nums[i]%2==0){\\n                    j=i+1;\\n                    cnt++;\\n                    maxx = max(maxx,cnt);\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            else{\\n                if(nums[j]%2 != nums[j-1]%2 && nums[j]<=threshold){\\n                    cnt++;\\n                    j++;\\n                    maxx = max(maxx,cnt);\\n                }\\n                else{\\n                    i=j;\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3763881,
                "title": "happy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint longestAlternatingSubarray(int* nums, int numsSize, int threshold){\\n    int i,n=numsSize,m=0,c;\\n    i=0;\\n    while(i<n)\\n    {\\n        if(nums[i]%2==0)\\n        {\\n            c=1;\\n            while(i<n-1 && nums[i]<=threshold && nums[i]%2!=nums[i+1]%2)\\n            {\\n                i++;\\n                c++;\\n            }\\n        if(nums[i]>threshold)\\n        c--;\\n        if(c>m)\\n        m=c;\\n        }\\n        i++;\\n    }\\n    return m;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestAlternatingSubarray(int* nums, int numsSize, int threshold){\\n    int i,n=numsSize,m=0,c;\\n    i=0;\\n    while(i<n)\\n    {\\n        if(nums[i]%2==0)\\n        {\\n            c=1;\\n            while(i<n-1 && nums[i]<=threshold && nums[i]%2!=nums[i+1]%2)\\n            {\\n                i++;\\n                c++;\\n            }\\n        if(nums[i]>threshold)\\n        c--;\\n        if(c>m)\\n        m=c;\\n        }\\n        i++;\\n    }\\n    return m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761362,
                "title": "c",
                "content": "# Intuition\\n Follow the question as it says we have to find longest subarray which follow certain rules.....therefore taken counter \\'c\\' to track number of element in subarray and then maxv variable for holding largest value of c \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int maxv=0;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(c==0){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                c++;maxv=max(maxv,c);\\n                cout<<nums[i]<<endl;\\n            }\\n            }\\n          else  if(c>=1 ){\\n                if(nums[i]<=threshold && nums[i] % 2 != nums[i - 1] % 2)  { \\n                    c++;maxv=max(maxv,c);\\n                    cout<<nums[i];\\n                    }\\n                else if(nums[i]>threshold || nums[i] % 2 == nums[i - 1] % 2){\\n                    if(nums[i]%2==0 && nums[i]<=threshold)\\n                    c=1;\\n                    else c=0;\\n                }\\n                    \\n            }\\n        }\\n        return maxv;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int maxv=0;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(c==0){\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                c++;maxv=max(maxv,c);\\n                cout<<nums[i]<<endl;\\n            }\\n            }\\n          else  if(c>=1 ){\\n                if(nums[i]<=threshold && nums[i] % 2 != nums[i - 1] % 2)  { \\n                    c++;maxv=max(maxv,c);\\n                    cout<<nums[i];\\n                    }\\n                else if(nums[i]>threshold || nums[i] % 2 == nums[i - 1] % 2){\\n                    if(nums[i]%2==0 && nums[i]<=threshold)\\n                    c=1;\\n                    else c=0;\\n                }\\n                    \\n            }\\n        }\\n        return maxv;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3761278,
                "title": "longest-even-odd-subarray-with-threshold",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let enqueue=[];\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]%2===0){\\n            enqueue.push(i);\\n        }\\n    }\\n    while(enqueue.length){\\n        let index=enqueue.pop();\\n        let arr=[nums[index]];\\n        if(arr[0]<=threshold){\\n            for(let i=index+1;i<nums.length;i++){\\n                if(nums[i]%2!=arr[arr.length-1]%2 && nums[i]<=threshold){arr.push(nums[i])}\\n                else{break}\\n            }\\n            max = Math.max(max,arr.length)\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar longestAlternatingSubarray = function(nums, threshold) {\\n    let enqueue=[];\\n    let max=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]%2===0){\\n            enqueue.push(i);\\n        }\\n    }\\n    while(enqueue.length){\\n        let index=enqueue.pop();\\n        let arr=[nums[index]];\\n        if(arr[0]<=threshold){\\n            for(let i=index+1;i<nums.length;i++){\\n                if(nums[i]%2!=arr[arr.length-1]%2 && nums[i]<=threshold){arr.push(nums[i])}\\n                else{break}\\n            }\\n            max = Math.max(max,arr.length)\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760959,
                "title": "efficient-but-complicated-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        res = curr = 0\\n        for v in nums:\\n            if v > threshold:\\n                curr = 0\\n            elif (v + curr) % 2:\\n                curr = (v % 2) ^ 1\\n            else:\\n                curr += 1\\n                res = max(res, curr)\\n        return res\\n            \\n\\n```\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        res = curr = 0\\n        for v in nums:\\n            if v > threshold:\\n                curr = 0\\n            elif (v + curr) % 2:\\n                curr = (v % 2) ^ 1\\n            else:\\n                curr += 1\\n                res = max(res, curr)\\n        return res\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760533,
                "title": "cpp-short-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\uD83D\\uDFE2 O(N)\\n\\n- Space complexity:\\n\\uD83D\\uDFE2 O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int cnt =0;\\n        int ans = 0;\\n        if((nums[0]%2 == 0) && (nums[0] <= threshold)) cnt = 1;\\n        ans = max(ans, cnt);\\n        for(int i=1; i<n; i++){\\n            if( cnt > 0 && (nums[i]%2) != (nums[i-1]%2) && (nums[i] <= threshold)){\\n                cnt++;\\n            }\\n            else if((nums[i]%2 == 0) && (nums[i] <= threshold)) cnt = 1;\\n            else cnt = 0;\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int cnt =0;\\n        int ans = 0;\\n        if((nums[0]%2 == 0) && (nums[0] <= threshold)) cnt = 1;\\n        ans = max(ans, cnt);\\n        for(int i=1; i<n; i++){\\n            if( cnt > 0 && (nums[i]%2) != (nums[i-1]%2) && (nums[i] <= threshold)){\\n                cnt++;\\n            }\\n            else if((nums[i]%2 == 0) && (nums[i] <= threshold)) cnt = 1;\\n            else cnt = 0;\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759698,
                "title": "simple-solution-images-with-o-n-runtime-beats-97-15-84ms",
                "content": "# Intuition\\nsimilar to kadane\\'s algorithm but we count the sub-array size .\\n\\n# Approach\\ncounting the size of the maximum sub-array.\\n\\n**Starting state:**\\n1. **Started** (bool): used to start counting the sub-array\\n2. **Switching** (bool): used to alternate between odd and even in the subarray\\n3. **ans** (int): the final answer for the solution\\n4. **count** (int): the counter for the sub-array size \\n \\nstarting state image:\\n![image.png](https://assets.leetcode.com/users/images/441678f9-17f0-43a9-9dae-b12dfda70c76_1689255714.8266103.png)\\n\\n# 1st iteration:\\nas starting point requirements for the sub-array, we must check if its\\n`nums[l] % 2 == 0`  and `nums[l] <= threshold`.\\nin our first iteration, **it does not meet the requirments** so we dont change.\\n\\n\\u2B50 **in every iteration, the count is checked if its bigger than ans**\\n\\n1st iteration image:\\n![image (1).png](https://assets.leetcode.com/users/images/605849f5-2544-400d-8b0d-cc2ec38d226a_1689255682.0281453.png)\\n\\n# 2nd iteration:\\nwe are still looking for the requirements as a starting point for the sub-array\\n`nums[l] % 2 == 0`  and `nums[l] <= threshold`.\\n\\nin our second iteration, it meets our requirements so we change `started` to `True`\\nthen we start alternating between odd and even and increasing the count if it\\'s alternating.\\n\\n\\u2B50 **in every iteration, the count is checked if its bigger than ans**\\n\\n2nd iteration image:\\n![image (2).png](https://assets.leetcode.com/users/images/0b9153bf-0233-4260-8c9f-1029806a8ecb_1689255757.4149773.png)\\nnow that we started counting the sub-array, we check if its alternating and increase the count by 1.\\nif it does not meet the requirements, we reset the variables\\n(`started` -> `False`, `count` -> `0`)\\n`switching` is set to start checking from odd on the next the sub-array.\\n\\n# 3rd iteration:\\nin our third iteration, it does meet the requirements\\n`nums[i] <= threshold` and `nums[i] % 2 != nums[i + 1] % 2`\\n\\n\\u2B50 **in every iteration, the count is checked if its bigger than ans**\\n\\n3rd iteration image:\\n![image (3).png](https://assets.leetcode.com/users/images/0c9f99d5-b530-478e-a484-d39415c69ed0_1689255768.707453.png)\\n# 4th iteration:\\n\\nin our fourth iteration, the sub-array contiunes in size.\\n\\n4th iteration image:\\n![image (4).png](https://assets.leetcode.com/users/images/3ec0a48d-c52d-4a85-9908-f20e419ba0d0_1689255790.8195677.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        bool started = false;\\n        bool switching = false;\\n        int count = 0;\\n\\n        for(auto inp : nums){\\n            if(started){\\n                //alternating between even and odd\\n                if(switching){\\n                    if(inp % 2 == 0 && inp <= threshold)\\n                        count += 1;\\n                    else{\\n                        //resetting the variables\\n                        //because does not meet requirements\\n                        count = 0;\\n                        started = false;\\n                        switching = true;\\n                    }\\n                }\\n                else{\\n                    if(inp % 2 == 1 && inp <= threshold)\\n                        count += 1;\\n                    else{\\n                        //resetting the variables \\n                        //because does not meet requirements\\n                        count = 0;\\n                        started = false;\\n                        switching = true;\\n                    }\\n                }\\n                switching = (switching ? false : true);\\n            }\\n\\n            //checks the starting point for the sub-array\\n            if(!started && inp % 2 == 0 && inp <= threshold){\\n                started = true;\\n                count = 1;\\n            }\\n            \\n            if(count > ans)\\n                ans = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        bool started = false;\\n        bool switching = false;\\n        int count = 0;\\n\\n        for(auto inp : nums){\\n            if(started){\\n                //alternating between even and odd\\n                if(switching){\\n                    if(inp % 2 == 0 && inp <= threshold)\\n                        count += 1;\\n                    else{\\n                        //resetting the variables\\n                        //because does not meet requirements\\n                        count = 0;\\n                        started = false;\\n                        switching = true;\\n                    }\\n                }\\n                else{\\n                    if(inp % 2 == 1 && inp <= threshold)\\n                        count += 1;\\n                    else{\\n                        //resetting the variables \\n                        //because does not meet requirements\\n                        count = 0;\\n                        started = false;\\n                        switching = true;\\n                    }\\n                }\\n                switching = (switching ? false : true);\\n            }\\n\\n            //checks the starting point for the sub-array\\n            if(!started && inp % 2 == 0 && inp <= threshold){\\n                started = true;\\n                count = 1;\\n            }\\n            \\n            if(count > ans)\\n                ans = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757719,
                "title": "o-n-solution-to-longest-even-odd-subarray-with-threshold-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int i, left=0, right=0, flag=0, max=0, even=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(even==0 && nums[i]%2==0 && nums[i]<=threshold)\\n            {\\n                left = i;\\n                right = i;\\n                flag=1;\\n                even=1;\\n            }\\n            else if(flag==1 && nums[i]%2==1 && nums[i]<=threshold)\\n            {\\n                flag=0;\\n                right = i;\\n            }\\n            else if(flag==0 && nums[i]%2==0 && nums[i]<=threshold)\\n            {\\n                flag=1;\\n                right = i;\\n            }\\n            else\\n            {\\n                if((right-left+1)>max && even==1)\\n                {\\n                    max = right-left+1;\\n                }\\n                if(nums[i]<=threshold && nums[i]%2==0)\\n                {\\n                    even=1;\\n                }\\n                else\\n                    even=0;\\n                left=i;\\n            }\\n        }\\n        if((right-left+1)>max && even==1)\\n        {\\n            max = right-left+1;\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b02400df-f03a-4602-a321-dcd67751be98_1689226446.4078321.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int i, left=0, right=0, flag=0, max=0, even=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(even==0 && nums[i]%2==0 && nums[i]<=threshold)\\n            {\\n                left = i;\\n                right = i;\\n                flag=1;\\n                even=1;\\n            }\\n            else if(flag==1 && nums[i]%2==1 && nums[i]<=threshold)\\n            {\\n                flag=0;\\n                right = i;\\n            }\\n            else if(flag==0 && nums[i]%2==0 && nums[i]<=threshold)\\n            {\\n                flag=1;\\n                right = i;\\n            }\\n            else\\n            {\\n                if((right-left+1)>max && even==1)\\n                {\\n                    max = right-left+1;\\n                }\\n                if(nums[i]<=threshold && nums[i]%2==0)\\n                {\\n                    even=1;\\n                }\\n                else\\n                    even=0;\\n                left=i;\\n            }\\n        }\\n        if((right-left+1)>max && even==1)\\n        {\\n            max = right-left+1;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756695,
                "title": "simple-one",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int maxLen = 0;\\n        int curLen = 0;\\n\\n        int lastNum = 0;\\n\\n        for (int thisNum : nums) {\\n            if (thisNum <= threshold) {\\n                if (thisNum % 2 == 0) {\\n                    if (lastNum % 2 == 1 && curLen > 0) {\\n                        curLen++;\\n                    } else {\\n                        curLen = 1;\\n                    }\\n                } else {\\n                    if (lastNum % 2 == 0 && curLen > 0) {\\n                        curLen++;\\n                    } else {\\n                        curLen = 0;\\n                    }\\n                }\\n            } else {\\n                curLen = 0;\\n            }\\n\\n            lastNum = thisNum;\\n\\n            if (curLen > maxLen) {\\n                maxLen = curLen;\\n            }\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int maxLen = 0;\\n        int curLen = 0;\\n\\n        int lastNum = 0;\\n\\n        for (int thisNum : nums) {\\n            if (thisNum <= threshold) {\\n                if (thisNum % 2 == 0) {\\n                    if (lastNum % 2 == 1 && curLen > 0) {\\n                        curLen++;\\n                    } else {\\n                        curLen = 1;\\n                    }\\n                } else {\\n                    if (lastNum % 2 == 0 && curLen > 0) {\\n                        curLen++;\\n                    } else {\\n                        curLen = 0;\\n                    }\\n                }\\n            } else {\\n                curLen = 0;\\n            }\\n\\n            lastNum = thisNum;\\n\\n            if (curLen > maxLen) {\\n                maxLen = curLen;\\n            }\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754836,
                "title": "simple-bruteforce",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int t) {\\n      int res = 0, j;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            bool check = false;\\n            if (nums[i] % 2 == 0 and nums[i]<=t) {\\n                int count = 1;\\n                check = true;\\n                \\n                for (j = i + 1; j < nums.size(); j++) {\\n                    if (nums[j] > t || nums[j] % 2 == nums[j - 1] % 2) {\\n                        break;\\n                    } else {\\n                        count++;\\n                    }\\n                }\\n                \\n                res = max(res, count);\\n            }\\n            \\n            if (res == 0 && check) {\\n                res = 1;\\n            }\\n        }\\n        \\n        return res;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int t) {\\n      int res = 0, j;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            bool check = false;\\n            if (nums[i] % 2 == 0 and nums[i]<=t) {\\n                int count = 1;\\n                check = true;\\n                \\n                for (j = i + 1; j < nums.size(); j++) {\\n                    if (nums[j] > t || nums[j] % 2 == nums[j - 1] % 2) {\\n                        break;\\n                    } else {\\n                        count++;\\n                    }\\n                }\\n                \\n                res = max(res, count);\\n            }\\n            \\n            if (res == 0 && check) {\\n                res = 1;\\n            }\\n        }\\n        \\n        return res;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752155,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& a, int t) {\\n        int n=a.size();\\n        int left=0;\\n        int maxi=0;\\n        for(int right=1;right<n;right++)\\n        {\\n            if((a[left]%2==0 && a[left]<=t))\\n            {\\n                maxi=max(maxi,1);\\n                if(a[right]%2!=a[right-1]%2 && a[right]<=t)\\n                {\\n                    maxi=max(maxi,right-left+1);\\n                }\\n                else\\n                left=right;\\n            } \\n            else\\n                left=right;\\n        }\\n        if(a[left]%2==0 && a[left]<=t)\\n        maxi=max(maxi,1);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& a, int t) {\\n        int n=a.size();\\n        int left=0;\\n        int maxi=0;\\n        for(int right=1;right<n;right++)\\n        {\\n            if((a[left]%2==0 && a[left]<=t))\\n            {\\n                maxi=max(maxi,1);\\n                if(a[right]%2!=a[right-1]%2 && a[right]<=t)\\n                {\\n                    maxi=max(maxi,right-left+1);\\n                }\\n                else\\n                left=right;\\n            } \\n            else\\n                left=right;\\n        }\\n        if(a[left]%2==0 && a[left]<=t)\\n        maxi=max(maxi,1);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748069,
                "title": "longest-even-odd-subarray-with-threshold-python3",
                "content": "Intuition:\\nThe goal is to find the length of the longest alternating subarray in the given list of numbers that satisfies the threshold condition. An alternating subarray is one in which the elements differ in parity (even/odd). The given code iterates through the list of numbers and keeps track of the current alternating subarray length (`cnt`) and the maximum length seen so far (`ans`).\\n\\nApproach:\\n1. Initialize `ans` and `cnt` to 0.\\n2. Iterate through the `nums` list using `enumerate` to access both the indices and values.\\n3. If the current number is greater than the threshold, it breaks the alternating pattern. Reset `cnt` to 0.\\n4. If `cnt` is not 0 (indicating an ongoing subarray) and the parity of the current number is different from the previous number\\'s parity, update the parity and increment `cnt` by 1.\\n5. If the above conditions are not met, either `cnt` is 0 (starting a new subarray) or the parity of the current number is the same as the previous number\\'s parity. In such cases, update the parity and set `cnt` to the opposite parity.\\n6. Update `ans` with the maximum value between `ans` and `cnt`.\\n7. After the loop ends, return the value of `ans`, which represents the length of the longest alternating subarray.\\n\\nComplexity:\\nTime complexity: The given code iterates through the `nums` list once, so the time complexity is O(n), where n is the length of the `nums` list.\\nSpace complexity: The code uses a constant amount of space for the variables `ans`, `cnt`, and `parity`, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n\\n        ans, cnt = 0, 0\\n\\n        for i, num in enumerate(nums):\\n\\n            if num > threshold:\\n                cnt = 0\\n\\n            elif cnt and parity != num%2:\\n                parity^= 1\\n                cnt+= 1\\n\\n            else:\\n                parity = num%2\\n                cnt = parity^1\\n\\n            ans = max(ans, cnt)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n\\n        ans, cnt = 0, 0\\n\\n        for i, num in enumerate(nums):\\n\\n            if num > threshold:\\n                cnt = 0\\n\\n            elif cnt and parity != num%2:\\n                parity^= 1\\n                cnt+= 1\\n\\n            else:\\n                parity = num%2\\n                cnt = parity^1\\n\\n            ans = max(ans, cnt)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746401,
                "title": "easy-solution-two-pointers",
                "content": "# Intuition\\nTo solve this problem, we can iterate over each index `i` in the given array `nums`. For each index, we can extend the subarray starting from that index until the conditions are no longer satisfied. We need to keep track of the maximum length of the alternating subarray that we encounter.\\n\\n# Approach\\n1. Initialize a variable `ans` to store the maximum length of the alternating subarray.\\n2. Iterate over each index `i` from `0` to `n-1` in the array `nums`.\\n3. For each index `i`, initialize a variable `j` to `i` to mark the starting point of the subarray.\\n4. Use a while loop to extend the subarray until the conditions are no longer satisfied:\\n   - Increment `j` while `j < n` and the following conditions hold:\\n     - `nums[j] <= threshold` (current element is less than or equal to the threshold)\\n     - `((j - i) % 2 == nums[j] % 2)` (parity of the distance between `j` and `i` is the same as the parity of the current element)\\n5. Update `ans` with the maximum length between `ans` and `j - i` (length of the current subarray).\\n6. Finally, return `ans`, which represents the length of the longest alternating subarray.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the array `nums`. We iterate over each element in the worst case.\\n- Space complexity: O(1). We use a constant amount of extra space.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            int j = i;\\n            while(j < n && nums[j] <= threshold && ((j - i) % 2 == nums[j] % 2)) {\\n                j++;\\n            }\\n            ans = max(ans, j - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            int j = i;\\n            while(j < n && nums[j] <= threshold && ((j - i) % 2 == nums[j] % 2)) {\\n                j++;\\n            }\\n            ans = max(ans, j - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746042,
                "title": "go-simple-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc longestAlternatingSubarray(nums []int, threshold int) int {\\n    \\n    l:=0\\n    r:=0\\n\\n    maxLen := 0\\n    for r <= len(nums) - 1 {\\n        if nums[l] % 2 != 0 {\\n            l++\\n            r++\\n            continue\\n        }\\n\\n        if nums[r] <= threshold {\\n           \\n           ln := (r - l) + 1     \\n\\n            if ln > maxLen {\\n                maxLen = ln\\n            }\\n            \\n        }else {\\n            r++\\n            l = r \\n            continue\\n        }\\n\\n        if (r < len(nums) - 1) && (nums[r] % 2 != nums[r + 1] % 2) {\\n            r++\\n        }else {\\n            r++\\n            l = r \\n        }\\n        \\n    } \\n\\n    return maxLen\\n\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nfunc longestAlternatingSubarray(nums []int, threshold int) int {\\n    \\n    l:=0\\n    r:=0\\n\\n    maxLen := 0\\n    for r <= len(nums) - 1 {\\n        if nums[l] % 2 != 0 {\\n            l++\\n            r++\\n            continue\\n        }\\n\\n        if nums[r] <= threshold {\\n           \\n           ln := (r - l) + 1     \\n\\n            if ln > maxLen {\\n                maxLen = ln\\n            }\\n            \\n        }else {\\n            r++\\n            l = r \\n            continue\\n        }\\n\\n        if (r < len(nums) - 1) && (nums[r] % 2 != nums[r + 1] % 2) {\\n            r++\\n        }else {\\n            r++\\n            l = r \\n        }\\n        \\n    } \\n\\n    return maxLen\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745738,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int i;\\n    public int n;\\n    public int helper(int[] nums,int threshold){\\n        while(i < n){\\n            if(nums[i]%2 == 0)\\n                break;\\n            i++;\\n        }\\n        if(i == n || nums[i]%2 != 0 || nums[i] > threshold)\\n            return 0;\\n        int count = 1;\\n        while(i < n-1){\\n            if(nums[i] %2 == nums[i+1]%2 || nums[i] > threshold || nums[i+1] > threshold)\\n                break;\\n            count++;\\n            i++;\\n        }\\n        System.out.println();\\n        return count;\\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        i = 0;\\n        n = nums.length;\\n        for(i = 0;i < n;i++)\\n            ans = Math.max(ans,helper(nums,threshold));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int i;\\n    public int n;\\n    public int helper(int[] nums,int threshold){\\n        while(i < n){\\n            if(nums[i]%2 == 0)\\n                break;\\n            i++;\\n        }\\n        if(i == n || nums[i]%2 != 0 || nums[i] > threshold)\\n            return 0;\\n        int count = 1;\\n        while(i < n-1){\\n            if(nums[i] %2 == nums[i+1]%2 || nums[i] > threshold || nums[i+1] > threshold)\\n                break;\\n            count++;\\n            i++;\\n        }\\n        System.out.println();\\n        return count;\\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int ans = 0;\\n        i = 0;\\n        n = nums.length;\\n        for(i = 0;i < n;i++)\\n            ans = Math.max(ans,helper(nums,threshold));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744293,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\n    bool flip(int i, int j) {\\n        return ((i ^ j) & 1);\\n    }\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        const int N = nums.size();\\n        int ans = 0;\\n        int i = 0;\\n        while(i < N) {\\n            if(nums[i] > threshold || (nums[i] & 1)) {\\n                ++i;\\n                continue;\\n            }\\n            ans = max(ans, 1);\\n            int j = i + 1;\\n            while(j < N && nums[j] <= threshold && flip(nums[j-1], nums[j])) {\\n                ++j;\\n            }\\n            ans = max(ans, j - i);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool flip(int i, int j) {\\n        return ((i ^ j) & 1);\\n    }\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        const int N = nums.size();\\n        int ans = 0;\\n        int i = 0;\\n        while(i < N) {\\n            if(nums[i] > threshold || (nums[i] & 1)) {\\n                ++i;\\n                continue;\\n            }\\n            ans = max(ans, 1);\\n            int j = i + 1;\\n            while(j < N && nums[j] <= threshold && flip(nums[j-1], nums[j])) {\\n                ++j;\\n            }\\n            ans = max(ans, j - i);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740931,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums , int x) {\\n        int count=0;\\n        int max=0;\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]%2==0 && nums[i]<=x)\\n          {\\n              count=1;\\n          for(int j=i+1;j<n;j++)\\n          {\\n              if(nums[j]%2 !=nums[j-1]%2 && nums[j]<=x)\\n              {\\n                  count++;\\n              }\\n              else\\n              {\\n                  break;\\n              }\\n          }\\n          max=Math.max(max,count);\\n        }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums , int x) {\\n        int count=0;\\n        int max=0;\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]%2==0 && nums[i]<=x)\\n          {\\n              count=1;\\n          for(int j=i+1;j<n;j++)\\n          {\\n              if(nums[j]%2 !=nums[j-1]%2 && nums[j]<=x)\\n              {\\n                  count++;\\n              }\\n              else\\n              {\\n                  break;\\n              }\\n          }\\n          max=Math.max(max,count);\\n        }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738890,
                "title": "c-93ms-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int longestAlternatingSubarray(std::vector<int>& nums, int threshold) {\\n    size_t sz = nums.size();\\n    size_t i = 0;\\n    size_t j = 0;\\n    int result = 0;\\n    auto satisfied = [threshold](int n, int desired) {\\n      return (n & 1) == desired && n <= threshold;\\n    };\\n    while (i < sz) {\\n      int tmp = 0;\\n      // Seek to next even\\n      while (i < sz && !satisfied(nums[i], 0)) {\\n        ++i;\\n      }\\n      if (i < sz) {\\n        ++tmp;\\n      }\\n      // Counting 01 pairs\\n      int odd = 1;\\n      j = i + 1;\\n      while (j < sz && satisfied(nums[j], odd)) {\\n        ++j;\\n        odd = !odd;\\n        tmp += 1;\\n      }\\n      if (tmp > result) {\\n        result = tmp;\\n      }\\n      i = j;\\n    }\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int longestAlternatingSubarray(std::vector<int>& nums, int threshold) {\\n    size_t sz = nums.size();\\n    size_t i = 0;\\n    size_t j = 0;\\n    int result = 0;\\n    auto satisfied = [threshold](int n, int desired) {\\n      return (n & 1) == desired && n <= threshold;\\n    };\\n    while (i < sz) {\\n      int tmp = 0;\\n      // Seek to next even\\n      while (i < sz && !satisfied(nums[i], 0)) {\\n        ++i;\\n      }\\n      if (i < sz) {\\n        ++tmp;\\n      }\\n      // Counting 01 pairs\\n      int odd = 1;\\n      j = i + 1;\\n      while (j < sz && satisfied(nums[j], odd)) {\\n        ++j;\\n        odd = !odd;\\n        tmp += 1;\\n      }\\n      if (tmp > result) {\\n        result = tmp;\\n      }\\n      i = j;\\n    }\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738150,
                "title": "with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int n=nums.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i]%2!=0 || nums[i]>threshold)\\n                continue;\\n            int j=i;\\n            for(;j<n-1;j++){ \\n                if((nums[j]%2==nums[j+1]%2) || nums[j+1]>threshold)\\n                    break;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int n=nums.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i]%2!=0 || nums[i]>threshold)\\n                continue;\\n            int j=i;\\n            for(;j<n-1;j++){ \\n                if((nums[j]%2==nums[j+1]%2) || nums[j+1]>threshold)\\n                    break;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737505,
                "title": "messy-o-n-python-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(N)$$ -->  \\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l=0\\n        res = 0;n=len(nums)\\n        r=l\\n        while r<n:\\n            while r < n and nums[l]%2==0 and nums[r]<=threshold:\\n                if r<n-1 and (nums[r+1]%2==nums[r]%2 or nums[r+1]>threshold): break\\n                r+=1\\n            if nums[l]%2==0 : # to check subarrays of len 1\\n                if r==n: r-= 1 # if r goes upon boundries decrement by one to validate(r-l+1)\\n                if nums[r]<=threshold: res = max(res , r-l+1)\\n            r+=1;l=r\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        l=0\\n        res = 0;n=len(nums)\\n        r=l\\n        while r<n:\\n            while r < n and nums[l]%2==0 and nums[r]<=threshold:\\n                if r<n-1 and (nums[r+1]%2==nums[r]%2 or nums[r+1]>threshold): break\\n                r+=1\\n            if nums[l]%2==0 : # to check subarrays of len 1\\n                if r==n: r-= 1 # if r goes upon boundries decrement by one to validate(r-l+1)\\n                if nums[r]<=threshold: res = max(res , r-l+1)\\n            r+=1;l=r\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737153,
                "title": "java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int ans = 0;\\n        int count = 0;\\n        boolean bool = true;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(bool){\\n                if(nums[i]%2 == 0 && nums[i] <= threshold){ count = 1; bool = false; }\\n            }\\n            else{\\n                if(nums[i] > threshold){ count = 0; bool = true; }\\n                else if(nums[i-1]%2 != nums[i]%2){ count++; }\\n                else{ \\n                    if(nums[i]%2 == 0){ count = 1; }\\n                    else{ count = 0; bool = true; }\\n                }\\n            }\\n\\n            ans = Math.max(ans, count);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        \\n        int ans = 0;\\n        int count = 0;\\n        boolean bool = true;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(bool){\\n                if(nums[i]%2 == 0 && nums[i] <= threshold){ count = 1; bool = false; }\\n            }\\n            else{\\n                if(nums[i] > threshold){ count = 0; bool = true; }\\n                else if(nums[i-1]%2 != nums[i]%2){ count++; }\\n                else{ \\n                    if(nums[i]%2 == 0){ count = 1; }\\n                    else{ count = 0; bool = true; }\\n                }\\n            }\\n\\n            ans = Math.max(ans, count);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736004,
                "title": "easy-c-solution",
                "content": "# Intuition\\nsimple Implementation\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int ans = 0;\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            count =0;\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                count++;\\n                while(i+1<n){\\n                    if(nums[i]%2!=nums[i+1]%2 && nums[i+1]<=threshold)\\n                        count++;\\n                    else\\n                        break;\\n                    i++;\\n                }\\n                ans = max(ans,count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        int ans = 0;\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            count =0;\\n            if(nums[i]%2==0 && nums[i]<=threshold){\\n                count++;\\n                while(i+1<n){\\n                    if(nums[i]%2!=nums[i+1]%2 && nums[i+1]<=threshold)\\n                        count++;\\n                    else\\n                        break;\\n                    i++;\\n                }\\n                ans = max(ans,count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735536,
                "title": "easy-to-understand-code-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) {\\n        int start = 0;\\n        int maxLengthTillNow = 0;\\n\\n        while (start < nums.Length){\\n            if (nums[start] % 2 == 0 && nums[start] <= threshold){\\n                int currentLength = 1;\\n                int innerIndex = start + 1;\\n\\n                while (innerIndex < nums.Length){\\n                    // threshold check\\n                    if (nums[innerIndex] > threshold){\\n                        break;\\n                    }\\n\\n                    if (nums[innerIndex] % 2 == nums[innerIndex-1] %2){\\n                        break;\\n                    }\\n\\n                    // valid number\\n                    currentLength = innerIndex - start + 1;\\n                    innerIndex ++;\\n                }\\n\\n                if (currentLength > maxLengthTillNow){\\n                    maxLengthTillNow = currentLength;\\n                }\\n\\n\\n            }\\n            start ++;\\n        }\\n\\n        return maxLengthTillNow;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestAlternatingSubarray(int[] nums, int threshold) {\\n        int start = 0;\\n        int maxLengthTillNow = 0;\\n\\n        while (start < nums.Length){\\n            if (nums[start] % 2 == 0 && nums[start] <= threshold){\\n                int currentLength = 1;\\n                int innerIndex = start + 1;\\n\\n                while (innerIndex < nums.Length){\\n                    // threshold check\\n                    if (nums[innerIndex] > threshold){\\n                        break;\\n                    }\\n\\n                    if (nums[innerIndex] % 2 == nums[innerIndex-1] %2){\\n                        break;\\n                    }\\n\\n                    // valid number\\n                    currentLength = innerIndex - start + 1;\\n                    innerIndex ++;\\n                }\\n\\n                if (currentLength > maxLengthTillNow){\\n                    maxLengthTillNow = currentLength;\\n                }\\n\\n\\n            }\\n            start ++;\\n        }\\n\\n        return maxLengthTillNow;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734846,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n  def longestAlternatingSubarray(nums: Array[Int], threshold: Int): Int =\\n    Iterator.iterate((0, 0, 0)) { case (maxLen, currLen, i) =>\\n      if (nums(i) > threshold) (maxLen, 0, i + 1)\\n      else {\\n        val newLen =\\n          if (currLen == 0) if (nums(i) % 2 == 0) 1 else 0\\n          else if (nums(i) % 2 == nums(i - 1) % 2) if (nums(i) % 2 == 0) 1 else 0 else currLen + 1\\n        (maxLen.max(newLen), newLen, i + 1)\\n      }\\n    }.dropWhile { case (_, _, i) => i < nums.length }.next()._1\\n```\\n\\nor \\n\\n```\\n  def longestAlternatingSubarray(nums: Array[Int], threshold: Int): Int = {\\n    def f(i: Int, curres: Int, res: Int, OddEven: Boolean, start: Boolean): Int = {\\n      if(i == nums.length) res max curres\\n      else if(start && nums(i) % 2 == 0 && nums(i) <= threshold) f(i + 1, 1, res, false, false)\\n      else if(start)  f(i + 1, 0, res, true, true)\\n      else if(nums(i) % 2 == 0 && OddEven && nums(i) <= threshold) f(i + 1, curres + 1, res, false, false)\\n      else if(nums(i) % 2 == 0 && nums(i) <= threshold) f(i + 1, 1, curres max res, false, false)\\n      else if(nums(i) % 2 == 0) f(i + 1, 0, curres max res, true, true)\\n      else if(nums(i) % 2 == 1 && !OddEven && nums(i) <= threshold) f(i + 1, curres + 1, res, true, false)\\n      else f(i + 1, 0, curres max res, true, true)\\n    }\\n\\n    f(0, 0, 0, true, true)\\n  }\\n    \\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def longestAlternatingSubarray(nums: Array[Int], threshold: Int): Int =\\n    Iterator.iterate((0, 0, 0)) { case (maxLen, currLen, i) =>\\n      if (nums(i) > threshold) (maxLen, 0, i + 1)\\n      else {\\n        val newLen =\\n          if (currLen == 0) if (nums(i) % 2 == 0) 1 else 0\\n          else if (nums(i) % 2 == nums(i - 1) % 2) if (nums(i) % 2 == 0) 1 else 0 else currLen + 1\\n        (maxLen.max(newLen), newLen, i + 1)\\n      }\\n    }.dropWhile { case (_, _, i) => i < nums.length }.next()._1\\n```\n```\\n  def longestAlternatingSubarray(nums: Array[Int], threshold: Int): Int = {\\n    def f(i: Int, curres: Int, res: Int, OddEven: Boolean, start: Boolean): Int = {\\n      if(i == nums.length) res max curres\\n      else if(start && nums(i) % 2 == 0 && nums(i) <= threshold) f(i + 1, 1, res, false, false)\\n      else if(start)  f(i + 1, 0, res, true, true)\\n      else if(nums(i) % 2 == 0 && OddEven && nums(i) <= threshold) f(i + 1, curres + 1, res, false, false)\\n      else if(nums(i) % 2 == 0 && nums(i) <= threshold) f(i + 1, 1, curres max res, false, false)\\n      else if(nums(i) % 2 == 0) f(i + 1, 0, curres max res, true, true)\\n      else if(nums(i) % 2 == 1 && !OddEven && nums(i) <= threshold) f(i + 1, curres + 1, res, true, false)\\n      else f(i + 1, 0, curres max res, true, true)\\n    }\\n\\n    f(0, 0, 0, true, true)\\n  }\\n    \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3734726,
                "title": "c-easy-solution-sliding-window-approach",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis function takes a vector of integers nums and an integer threshold as input parameters. It aims to find the length of the longest subarray within nums that alternates between even and odd numbers, with the additional condition that each number in the subarray is less than or equal to the threshold value.\\n\\n1. The function initializes a variable n with the size of the input vector nums and sets ans to 0. These variables will be used to keep track of the length of the longest alternating subarray and the final result, respectively.\\n\\n2. The code then enters a loop that iterates through each element of the nums vector. The loop variable i represents the current index being considered.\\n\\n3. Inside the loop, a local variable len is initialized to 0. This variable will store the length of the current alternating subarray being examined.\\n\\n4. The code checks if the current number at index i is an even number (nums[i] % 2 == 0) and is less than or equal to the threshold value. If both conditions are true, it means that a potential subarray can be formed starting from this index.\\n\\n5. If the conditions are met, the len variable is incremented by 1, indicating that the first element of the subarray has been found. Then, an inner loop begins, starting from j = i + 1, to search for more elements to add to the subarray.\\n\\n6. Inside the inner loop, the code checks two conditions to determine if the current number (nums[j]) can be added to the subarray:\\n\\n7. If the number is greater than the threshold value (nums[j] > threshold), it breaks the inner loop since the subarray cannot contain numbers exceeding the threshold.\\nIf the parity (odd or even) of the current number is the same as the previous number in the subarray (nums[j] % 2 == nums[j - 1] % 2), it breaks the loop because the subarray should alternate between even and odd numbers.\\nIf both conditions are false, the len variable is incremented by 1, and the inner loop continues to the next iteration.\\n\\n8. Once the inner loop finishes, the code compares the length of the current subarray (len) with the current longest length (ans) and updates ans if the current subarray is longer.\\n\\n9. The outer loop continues to the next index, and the process repeats until all elements of the nums vector have been examined.\\n\\n10. Finally, the function returns the value of ans, which represents the length of the longest alternating subarray meeting the specified conditions.\\n\\nThe code uses nested loops to iterate through the elements of the input vector. It identifies potential subarrays by checking for even numbers that are less than or equal to the threshold value. It then extends each subarray by searching for subsequent elements that meet the alternating and threshold conditions. The length of the longest subarray found is returned as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len=0;\\n            if(nums[i]%2==0 and nums[i]<=threshold)\\n            {\\n                len++;\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]>threshold || nums[j]%2==nums[j-1]%2)\\n                    break;\\n                    len++;\\n                }\\n            }\\n            ans=max(len,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len=0;\\n            if(nums[i]%2==0 and nums[i]<=threshold)\\n            {\\n                len++;\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]>threshold || nums[j]%2==nums[j-1]%2)\\n                    break;\\n                    len++;\\n                }\\n            }\\n            ans=max(len,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734332,
                "title": "elixir-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 957ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 65MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport Bitwise\\ndefmodule Solution do\\n  @spec longest_alternating_subarray(nums :: [integer], threshold :: integer) :: integer\\n  def longest_alternating_subarray(nums, threshold) do\\n    nums |> Enum.reduce({0, 0, 0}, fn num, {ans, cnt, parity} ->\\n      {parity, cnt} =\\n      cond do\\n        num > threshold ->\\n          {parity, 0}\\n        cnt >= 1 and parity != rem(num, 2) ->\\n          {bxor(parity, 1), cnt + 1}\\n        true ->\\n          parity = rem(num, 2)\\n          {parity, bxor(parity, 1)}\\n      end\\n      {max(ans, cnt), cnt, parity}\\n    end) |> elem(0)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\nimport Bitwise\\ndefmodule Solution do\\n  @spec longest_alternating_subarray(nums :: [integer], threshold :: integer) :: integer\\n  def longest_alternating_subarray(nums, threshold) do\\n    nums |> Enum.reduce({0, 0, 0}, fn num, {ans, cnt, parity} ->\\n      {parity, cnt} =\\n      cond do\\n        num > threshold ->\\n          {parity, 0}\\n        cnt >= 1 and parity != rem(num, 2) ->\\n          {bxor(parity, 1), cnt + 1}\\n        true ->\\n          parity = rem(num, 2)\\n          {parity, bxor(parity, 1)}\\n      end\\n      {max(ans, cnt), cnt, parity}\\n    end) |> elem(0)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3732902,
                "title": "c-brute-force-beats-85-o-n",
                "content": "# Approach\\nStarting Point of Sub-array: Even number <= threshold value\\nEnd point: Until Odd-Even alternates and every nums[i] <= threshold value\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int res = 0;  //final result\\n        for(int i=0; i<nums.size(); ){\\n            int count=0;  //temporary count for each appropriate sub-array found\\n            if( nums[i]%2==0 && nums[i]<=threshold ){  //First no.: even\\n                ++count;\\n                ++i;\\n                while(i<nums.size()){  //Checking alternate Odd-Even till all conditions are met\\n                    if( nums[i]%2!=0 && nums[i]<=threshold ){ //Odd\\n                        ++i; ++count;\\n                    } else break;\\n\\n                    if( i<nums.size() && nums[i]%2==0 && nums[i]<=threshold ){  //Even\\n                        ++i; ++count;\\n                    } else break;\\n                }\\n            } \\n            else ++i;  //Updating i here and not inside loop statement\\n            res=max(res, count);  //comparing present sub-array with max sub-array length found \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int res = 0;  //final result\\n        for(int i=0; i<nums.size(); ){\\n            int count=0;  //temporary count for each appropriate sub-array found\\n            if( nums[i]%2==0 && nums[i]<=threshold ){  //First no.: even\\n                ++count;\\n                ++i;\\n                while(i<nums.size()){  //Checking alternate Odd-Even till all conditions are met\\n                    if( nums[i]%2!=0 && nums[i]<=threshold ){ //Odd\\n                        ++i; ++count;\\n                    } else break;\\n\\n                    if( i<nums.size() && nums[i]%2==0 && nums[i]<=threshold ){  //Even\\n                        ++i; ++count;\\n                    } else break;\\n                }\\n            } \\n            else ++i;  //Updating i here and not inside loop statement\\n            res=max(res, count);  //comparing present sub-array with max sub-array length found \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732694,
                "title": "java-7ms-beats-98-and-clean-code",
                "content": "# Approach\\n1. Use two variables: longest (holds the answer) and start (marks the start of a good sequence)\\n2. Iterate over each number and check against threshhold and/or even/odd against previous number\\n    - If current > threshhold, reset start to -1 and continue.\\n    - If current and previous have same modulo, set start to -1 (if current is odd (eg:1,1) or start = i if current is even) (eg: 4,4): the 2nd 4 can be the start of a new sequence \\n    - If the two numbers have different modulos and start is -1 and current is odd, set start to i, as this number is even and can be the start of a good sequence\\n4. At any step, if start != -1 (you have a valid sequence), set longest = max(longest, windowSize)\\n5. Return longest.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int longest = 0, start = -1, prev = 2;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > threshold) {\\n                start = -1;\\n            } else if (nums[i] % 2 == prev % 2) {\\n                start = nums[i] % 2 == 0 ? i : -1;\\n            } else if (nums[i] % 2 == 0 && start == -1) {\\n                start = i;\\n            }\\n            prev = nums[i];\\n            if (start != -1) {\\n                longest = Math.max(longest, i + 1 - start);\\n            }\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int longest = 0, start = -1, prev = 2;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > threshold) {\\n                start = -1;\\n            } else if (nums[i] % 2 == prev % 2) {\\n                start = nums[i] % 2 == 0 ? i : -1;\\n            } else if (nums[i] % 2 == 0 && start == -1) {\\n                start = i;\\n            }\\n            prev = nums[i];\\n            if (start != -1) {\\n                longest = Math.max(longest, i + 1 - start);\\n            }\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729354,
                "title": "sliding-window-solution-with-explanation-java",
                "content": "# Intuition\\nFirst thing you can notice is \\'Subarray\\'. When you see it just call to mind about \\'Sliding window\\' pattern solution\\n# Approach\\nWe have some cases for each element of array:\\n1) Element greater then threshold\\n2) Element is start of subarray\\n3) Element is not start of subarray\\n    3.1) Element is part of current subarray\\n    3.2) Element is start of new subarray\\n\\nIn order to understand which case our element belongs to, it is enough to compare element with threshold and track the current length of subarray. Just put it in \\'curLength\\' variable.\\n\\nAfter that, we need to carefully write the code for each case and compare current length of subarray with current max length for each element.\\n\\nThat\\'s it =)\\n \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int index = 0;\\n        int curLength = 0;\\n        int result = 0;\\n\\n        for(;index < nums.length; index++) {\\n            // CASE #1\\n            if(nums[index] > threshold)\\n                curLength = 0;\\n            else {\\n                // CASE #2\\n                if(curLength == 0) {\\n                    if (nums[index] % 2 == 0)\\n                        curLength++;    \\n                } else {//CASE #3\\n                    \\n                    if(nums[index] % 2 != nums[index - 1] % 2)\\n                        //CASE #3.1\\n                        curLength++;\\n                    else {\\n                        //CASE #3.2\\n                        if(nums[index] % 2 == 0)\\n                            curLength = 1;\\n                        else\\n                            curLength = 0; \\n                    }       \\n                }\\n            }\\n            result = Math.max(result, curLength);\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int index = 0;\\n        int curLength = 0;\\n        int result = 0;\\n\\n        for(;index < nums.length; index++) {\\n            // CASE #1\\n            if(nums[index] > threshold)\\n                curLength = 0;\\n            else {\\n                // CASE #2\\n                if(curLength == 0) {\\n                    if (nums[index] % 2 == 0)\\n                        curLength++;    \\n                } else {//CASE #3\\n                    \\n                    if(nums[index] % 2 != nums[index - 1] % 2)\\n                        //CASE #3.1\\n                        curLength++;\\n                    else {\\n                        //CASE #3.2\\n                        if(nums[index] % 2 == 0)\\n                            curLength = 1;\\n                        else\\n                            curLength = 0; \\n                    }       \\n                }\\n            }\\n            result = Math.max(result, curLength);\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728750,
                "title": "sliding-window-o-n-time-easy-to-understand",
                "content": "# Approach\\nJust traverse the array using sliding window and check for the required conditions\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int i = 0;\\n        while(i < nums.size()){\\n            if(nums[i] %2 != 0 || nums[i] > threshold){\\n                i++;\\n                continue;\\n            }\\n            bool even = false;\\n            int j = i+1;\\n            while(j<nums.size()){\\n                if(nums[j] > threshold){\\n                    break;\\n                }\\n                if(even && nums[j]%2!=0){\\n                    break;\\n                }\\n                if(!even && nums[j]%2==0){\\n                    break;\\n                }\\n                j++;\\n                even = !even;\\n            }\\n            ans = max(ans, j-i);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        int ans = 0;\\n        int i = 0;\\n        while(i < nums.size()){\\n            if(nums[i] %2 != 0 || nums[i] > threshold){\\n                i++;\\n                continue;\\n            }\\n            bool even = false;\\n            int j = i+1;\\n            while(j<nums.size()){\\n                if(nums[j] > threshold){\\n                    break;\\n                }\\n                if(even && nums[j]%2!=0){\\n                    break;\\n                }\\n                if(!even && nums[j]%2==0){\\n                    break;\\n                }\\n                j++;\\n                even = !even;\\n            }\\n            ans = max(ans, j-i);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726863,
                "title": "easy-intuitive-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& a, int th) {\\n        int n = a.size();\\n        int ans=0;\\n\\t\\t//Running on every element \\n        for(int i=0;i<n;i++){\\n\\t\\t//checking if a[i] is less than threshold & a[i] is even then we move inside if block\\n            if(a[i]<=th && a[i]%2==0){\\n                int cnt=1;\\n                int j=i;\\n\\t\\t\\t\\t// In while loop I\\'m just checking that j+1 doesn\\'t go out of array & all element that I\\'m adding in window are less than threshold\\n                while(j<n-1 &&  a[j]<=th && a[j+1]<=th && a[j]%2 != a[j+1]%2){\\n                    cnt++;\\n                    j++;\\n                }\\n                ans = max(cnt,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& a, int th) {\\n        int n = a.size();\\n        int ans=0;\\n\\t\\t//Running on every element \\n        for(int i=0;i<n;i++){\\n\\t\\t//checking if a[i] is less than threshold & a[i] is even then we move inside if block\\n            if(a[i]<=th && a[i]%2==0){\\n                int cnt=1;\\n                int j=i;\\n\\t\\t\\t\\t// In while loop I\\'m just checking that j+1 doesn\\'t go out of array & all element that I\\'m adding in window are less than threshold\\n                while(j<n-1 &&  a[j]<=th && a[j+1]<=th && a[j]%2 != a[j+1]%2){\\n                    cnt++;\\n                    j++;\\n                }\\n                ans = max(cnt,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726098,
                "title": "c-easy-to-understand-tc-o-n-explanation-in-the-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        //Length of maximum eligible subarray\\n        int ans = 0;\\n        //Length of eligible subarray\\n        int l = 0;\\n        for(int i=0;i<nums.size();i++){\\n            /* If the number is greater than threshold, \\n            we disregard it and reset the length of subarray to 0 */\\n            if(nums[i]>threshold){\\n                l=0;   \\n            /* If the current number does not follow pattern we reset\\n               length to 0 if the number is odd, or \\n               the length to 1 if number is even */\\n            }else if((l%2)!=(nums[i]%2)){\\n                l=(nums[i]%2)==0?1:0;   \\n            }\\n            /*  If it is following pattern, simply increase length \\n                and keep track of maximum length */\\n            else{\\n                l++;\\n                ans=max(ans,l);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\\n        //Length of maximum eligible subarray\\n        int ans = 0;\\n        //Length of eligible subarray\\n        int l = 0;\\n        for(int i=0;i<nums.size();i++){\\n            /* If the number is greater than threshold, \\n            we disregard it and reset the length of subarray to 0 */\\n            if(nums[i]>threshold){\\n                l=0;   \\n            /* If the current number does not follow pattern we reset\\n               length to 0 if the number is odd, or \\n               the length to 1 if number is even */\\n            }else if((l%2)!=(nums[i]%2)){\\n                l=(nums[i]%2)==0?1:0;   \\n            }\\n            /*  If it is following pattern, simply increase length \\n                and keep track of maximum length */\\n            else{\\n                l++;\\n                ans=max(ans,l);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725894,
                "title": "easy-solution-in-java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTWO LOOPS AND CHECKING CONDITION\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTWO LOOPS AND CHECKING CONDITION\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\n    public boolean check1(int i,int j,int nums[],int thershold)\\n    {\\n       for(int l=i;l<=j;l++)\\n       {\\n           if(nums[l]<=thershold)\\n           {\\n               \\n           }\\n           else\\n           {\\n               return false;\\n           }\\n       }\\n        return true;\\n    }\\n      public boolean check2(int i,int j,int nums[],int thershold)\\n    {\\n          \\n       int res[]=new int[j-i+1];\\n          \\n          //System.out.println(\"size\"+(j-i)+\" \"+nums[2]);\\n          int d=i;\\n       for(int k=0;k<(j-i+1);k++)\\n       {\\n           //System.out.println(nums[d]);\\n           res[k]=nums[d++]%2;\\n           \\n       }\\n          \\n       int result=res[0];\\n       if(result==0)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==0)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==1)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n           if(result==1)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==1)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==0)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n          return true;\\n          \\n       \\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int max=0;\\n        int count=0;\\n       \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2!=0)\\n                 count++;\\n        }\\n        if(count==nums.length)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                if(nums[i]%2==0)\\n                {\\n                    boolean result1=check1(i,j,nums,threshold);\\n                    boolean result2=check2(i,j,nums,threshold);\\n                    \\n                    if(result1==true&&result2==true)\\n                    {\\n                        //System.out.println(\"hello \"+i+\"  \"+j);\\n                       max=Math.max(max,j-i+1);     \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check1(int i,int j,int nums[],int thershold)\\n    {\\n       for(int l=i;l<=j;l++)\\n       {\\n           if(nums[l]<=thershold)\\n           {\\n               \\n           }\\n           else\\n           {\\n               return false;\\n           }\\n       }\\n        return true;\\n    }\\n      public boolean check2(int i,int j,int nums[],int thershold)\\n    {\\n          \\n       int res[]=new int[j-i+1];\\n          \\n          //System.out.println(\"size\"+(j-i)+\" \"+nums[2]);\\n          int d=i;\\n       for(int k=0;k<(j-i+1);k++)\\n       {\\n           //System.out.println(nums[d]);\\n           res[k]=nums[d++]%2;\\n           \\n       }\\n          \\n       int result=res[0];\\n       if(result==0)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==0)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==1)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n           if(result==1)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==1)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==0)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n          return true;\\n          \\n       \\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int max=0;\\n        int count=0;\\n       \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2!=0)\\n                 count++;\\n        }\\n        if(count==nums.length)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                if(nums[i]%2==0)\\n                {\\n                    boolean result1=check1(i,j,nums,threshold);\\n                    boolean result2=check2(i,j,nums,threshold);\\n                    \\n                    if(result1==true&&result2==true)\\n                    {\\n                        //System.out.println(\"hello \"+i+\"  \"+j);\\n                       max=Math.max(max,j-i+1);     \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725893,
                "title": "easy-solution-in-java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTWO LOOPS AND CHECKING CONDITION\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTWO LOOPS AND CHECKING CONDITION\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\n    public boolean check1(int i,int j,int nums[],int thershold)\\n    {\\n       for(int l=i;l<=j;l++)\\n       {\\n           if(nums[l]<=thershold)\\n           {\\n               \\n           }\\n           else\\n           {\\n               return false;\\n           }\\n       }\\n        return true;\\n    }\\n      public boolean check2(int i,int j,int nums[],int thershold)\\n    {\\n          \\n       int res[]=new int[j-i+1];\\n          \\n          //System.out.println(\"size\"+(j-i)+\" \"+nums[2]);\\n          int d=i;\\n       for(int k=0;k<(j-i+1);k++)\\n       {\\n           //System.out.println(nums[d]);\\n           res[k]=nums[d++]%2;\\n           \\n       }\\n          \\n       int result=res[0];\\n       if(result==0)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==0)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==1)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n           if(result==1)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==1)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==0)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n          return true;\\n          \\n       \\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int max=0;\\n        int count=0;\\n       \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2!=0)\\n                 count++;\\n        }\\n        if(count==nums.length)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                if(nums[i]%2==0)\\n                {\\n                    boolean result1=check1(i,j,nums,threshold);\\n                    boolean result2=check2(i,j,nums,threshold);\\n                    \\n                    if(result1==true&&result2==true)\\n                    {\\n                        //System.out.println(\"hello \"+i+\"  \"+j);\\n                       max=Math.max(max,j-i+1);     \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check1(int i,int j,int nums[],int thershold)\\n    {\\n       for(int l=i;l<=j;l++)\\n       {\\n           if(nums[l]<=thershold)\\n           {\\n               \\n           }\\n           else\\n           {\\n               return false;\\n           }\\n       }\\n        return true;\\n    }\\n      public boolean check2(int i,int j,int nums[],int thershold)\\n    {\\n          \\n       int res[]=new int[j-i+1];\\n          \\n          //System.out.println(\"size\"+(j-i)+\" \"+nums[2]);\\n          int d=i;\\n       for(int k=0;k<(j-i+1);k++)\\n       {\\n           //System.out.println(nums[d]);\\n           res[k]=nums[d++]%2;\\n           \\n       }\\n          \\n       int result=res[0];\\n       if(result==0)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==0)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==1)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n           if(result==1)\\n       {\\n           for(int p=1;p<res.length;p++)\\n           {\\n               if(p%2!=0)\\n               {\\n                   if(res[p]==1)\\n                   {\\n                       return false;\\n                   }\\n               }\\n               else\\n               {\\n                 if(res[p]==0)\\n                   {\\n                       return false;\\n                   }  \\n               }\\n           }\\n       }\\n          return true;\\n          \\n       \\n    }\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n        int max=0;\\n        int count=0;\\n       \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2!=0)\\n                 count++;\\n        }\\n        if(count==nums.length)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                if(nums[i]%2==0)\\n                {\\n                    boolean result1=check1(i,j,nums,threshold);\\n                    boolean result2=check2(i,j,nums,threshold);\\n                    \\n                    if(result1==true&&result2==true)\\n                    {\\n                        //System.out.println(\"hello \"+i+\"  \"+j);\\n                       max=Math.max(max,j-i+1);     \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725427,
                "title": "python-straightforward-o-n",
                "content": "1. The variable `start` indicates whether we are extending a valid subarray, and `length` is the size of the subarray.\\n2. For each `n` in `nums`, check all conditions to update `start` and `length`, then compare `length` with `ans`.\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        ans = 0\\n        start = False\\n        length = 0\\n        for i, n in enumerate(nums):\\n            if start:\\n                if n <= threshold:\\n                    if (n + nums[i-1]) & 1:\\n                        length += 1\\n                    elif not n & 1:\\n                        length = 1\\n                    else:\\n                        start = False\\n                else:\\n                    start = False\\n            elif n <= threshold and not n & 1:\\n                start = True\\n                length = 1\\n            ans = max(ans, length)\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. The variable `start` indicates whether we are extending a valid subarray, and `length` is the size of the subarray.\\n2. For each `n` in `nums`, check all conditions to update `start` and `length`, then compare `length` with `ans`.\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        ans = 0\\n        start = False\\n        length = 0\\n        for i, n in enumerate(nums):\\n            if start:\\n                if n <= threshold:\\n                    if (n + nums[i-1]) & 1:\\n                        length += 1\\n                    elif not n & 1:\\n                        length = 1\\n                    else:\\n                        start = False\\n                else:\\n                    start = False\\n            elif n <= threshold and not n & 1:\\n                start = True\\n                length = 1\\n            ans = max(ans, length)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3725408,
                "title": "sliding-window",
                "content": "1. Once find an even number which satisfies threshold limit, start expanding the window by keep on checking the odd even flow.\\n2. Else, shrink the window.\\n\\n\\n\\t\\tdef longestAlternatingSubarray(self, a: List[int], threshold: int) -> int:\\n\\t\\t\\ti,j = 0,0\\n\\t\\t\\tn = len(a) \\n\\t\\t\\tres = 0\\n\\t\\t\\twhile i<n and j<n: \\n\\t\\t\\t\\tif a[i]%2 == 0 and a[i]<=threshold: \\n\\t\\t\\t\\t\\todd = 0\\n\\t\\t\\t\\t\\twhile j<n and odd == a[j]&1:  \\n\\t\\t\\t\\t\\t\\tif a[j] > threshold: \\n\\t\\t\\t\\t\\t\\t\\ti=j\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\todd ^= 1 \\n\\t\\t\\t\\t\\t\\tres = max(res,j-i+1) \\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\telse: j-=1 \\n\\t\\t\\t\\ti+=1 \\n\\t\\t\\t\\tif i>j: j=i\\n\\t\\t\\treturn res\\n\\n\\n",
                "solutionTags": [],
                "code": "1. Once find an even number which satisfies threshold limit, start expanding the window by keep on checking the odd even flow.\\n2. Else, shrink the window.\\n\\n\\n\\t\\tdef longestAlternatingSubarray(self, a: List[int], threshold: int) -> int:\\n\\t\\t\\ti,j = 0,0\\n\\t\\t\\tn = len(a) \\n\\t\\t\\tres = 0\\n\\t\\t\\twhile i<n and j<n: \\n\\t\\t\\t\\tif a[i]%2 == 0 and a[i]<=threshold: \\n\\t\\t\\t\\t\\todd = 0\\n\\t\\t\\t\\t\\twhile j<n and odd == a[j]&1:  \\n\\t\\t\\t\\t\\t\\tif a[j] > threshold: \\n\\t\\t\\t\\t\\t\\t\\ti=j\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\todd ^= 1 \\n\\t\\t\\t\\t\\t\\tres = max(res,j-i+1) \\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\telse: j-=1 \\n\\t\\t\\t\\ti+=1 \\n\\t\\t\\t\\tif i>j: j=i\\n\\t\\t\\treturn res\\n\\n\\n",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1952615,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1952604,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1952640,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1954564,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 2026925,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1959555,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1953002,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 2071715,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1963730,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1959562,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1952615,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1952604,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1952640,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1954564,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 2026925,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1959555,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1953002,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 2071715,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1963730,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            },
            {
                "id": 1959562,
                "content": [
                    {
                        "username": "user2889l",
                        "content": "how the f is this easy"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why in leetcode contest easy problem give more penalty than medium \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "ross8888",
                        "content": "low constraints makes it easy while edge case makes it medium-hard if someone wants to solve in one go."
                    },
                    {
                        "username": "Ultron03",
                        "content": "let's make it simple ! !\n\nIn this question we have to find the longest length subarray with elements as even odd even odd even odd..... with a condition that every element should be less than a particular value.."
                    },
                    {
                        "username": "tonynin1",
                        "content": "It\\'s an easy problem, easy to get penalty :) bruh"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "definitely not an easy question. Took time to take care of edge cases ;("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**BRUTE FORCE WORKS**\\nTake care of edge cases like when threshold is less than the minimum number present in an array\\nor there is only one element in array  whose value is odd.\\n\\n**BY THE WAY TOO MANY EDGE CASES**"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888) ohh I was telling only if threshold is greater than 8  thanks for correcting "
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 fails the condition which is  nums[i] <= threshold."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@ross8888](/ross8888)  why? You can start with index 1 with 8 as starting element"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) 8 is not valid subarray"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@guptatanish145](/guptatanish145) 2 and 8 both are valid subarray with size 1 you can take any since there is condition that subarray should start with mums[i] %2==0 followed by alternate odd and even no that is less than equal to threshold value  \nSince 8 is less than threshold value so there is only one valid subarray with value 2 and length 1"
                    },
                    {
                        "username": "ross8888",
                        "content": "[@guptatanish145](/guptatanish145) [2] can be a valid subarray"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "nums =\\n[2,8]\\nthreshold =\\n4\\nOutput\\n0\\nExpected\\n1\\nHow the expected answer is 1 ?"
                    },
                    {
                        "username": "sriram7507",
                        "content": "Can we do this without brute force ??"
                    },
                    {
                        "username": "SergeiLenkov",
                        "content": "The edge test case when the input is [2] says the expected answer is 1 (obviously [2]). So the subarray is THE array in this case. Index 0 of the item is less then len(nums) == 1.\\nBut the case when the input is [1,2] says it also expects the answer 1,  which contradicts the logic then. Why can\\'t we take [1,2] as the answer then with the output 2??"
                    },
                    {
                        "username": "prasannapande",
                        "content": "because the first element in the subarray has to be even."
                    },
                    {
                        "username": "Pernell14",
                        "content": "Here!!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Jumps to Reach the Last Index",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of <code>n</code> integers and an integer <code>target</code>.</p>\n\n<p>You are initially positioned at index <code>0</code>. In one step, you can jump from index <code>i</code> to any index <code>j</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code></li>\n\t<li><code>-target &lt;= nums[j] - nums[i] &lt;= target</code></li>\n</ul>\n\n<p>Return <em>the <strong>maximum number of jumps</strong> you can make to reach index</em> <code>n - 1</code>.</p>\n\n<p>If there is no way to reach index <code>n - 1</code>, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,6,4,1,2], target = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:\n- Jump from index 0 to index 1. \n- Jump from index 1 to index 3.\n- Jump from index 3 to index 5.\nIt can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 3 jumps. Hence, the answer is 3. </pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,6,4,1,2], target = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:\n- Jump from index 0 to index 1.\n- Jump from index 1 to index 2.\n- Jump from index 2 to index 3.\n- Jump from index 3 to index 4.\n- Jump from index 4 to index 5.\nIt can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 5 jumps. Hence, the answer is 5. </pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,6,4,1,2], target = 0\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It can be proven that there is no jumping sequence that goes from 0 to n - 1. Hence, the answer is -1. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length == n &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= target &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3739319,
                "title": "c-recursion-memoization-explained",
                "content": "# Intuition\\nIf we are at any index i then we can have multiple indexes to which we can jump.So we need to explore all possible choices.\\nSo how we explore all choices ?? RECURSION \\n\\n# Approach\\nLet\\'s suppose we are at index i.We will loop from i+1 till nums.size()\\nand check whether we can jump to current index.\\nTo check whether you can jump just ensure that condition is fulfilled:\\nabs(nums[ind]-nums[i])<=target\\nIf we can jump we will move to index ind ,increase jumps by 1 and calculate ans for ind;\\n\\n\\n\\n# Reecursive Code [TLE]\\n```\\nclass Solution {\\npublic:\\n    \\n    int find(int ind,vector<int>&nums,int tar)\\n    {\\n        if(ind==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]-nums[ind])<=tar) //checking  if we can jump to i\\n            {\\n                ans=max(ans,1+find(i,nums,tar)); // jump to i \\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar)\\n    {\\n       \\n        int ans=find(0,nums,tar);\\n       if(ans>0)\\n           return ans;\\n        else\\n            return -1;\\n    }\\n};\\n```\\n# Complexity of recursive code\\n- Time complexity:\\nno of states=n \\n and in each state we are doing a loop from i+1 to n\\nso TC=n^n\\n  \\n\\n- Space complexity:\\n- Auxiliary stack space :O(n)\\n\\n\\n\\n# Memoized Code[ACCEPTED]\\n```\\nclass Solution {\\npublic:\\n    \\n    int find(int ind,vector<int>&nums,int tar,vector<int>&dp)\\n    {\\n        if(ind==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]-nums[ind])<=tar)\\n            {\\n                ans=max(ans,1+find(i,nums,tar,dp));\\n            }\\n        }\\n        return dp[ind]=ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar)\\n    {\\n        vector<int>dp(nums.size(),-1);\\n        int ans=find(0,nums,tar,dp);\\n       if(ans>0)\\n           return ans;\\n        else\\n            return -1;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int ind,vector<int>&nums,int tar)\\n    {\\n        if(ind==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]-nums[ind])<=tar) //checking  if we can jump to i\\n            {\\n                ans=max(ans,1+find(i,nums,tar)); // jump to i \\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar)\\n    {\\n       \\n        int ans=find(0,nums,tar);\\n       if(ans>0)\\n           return ans;\\n        else\\n            return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int find(int ind,vector<int>&nums,int tar,vector<int>&dp)\\n    {\\n        if(ind==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]-nums[ind])<=tar)\\n            {\\n                ans=max(ans,1+find(i,nums,tar,dp));\\n            }\\n        }\\n        return dp[ind]=ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar)\\n    {\\n        vector<int>dp(nums.size(),-1);\\n        int ans=find(0,nums,tar,dp);\\n       if(ans>0)\\n           return ans;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739012,
                "title": "dp-with-memorisation-very-simple-and-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nint solve(vector<int>& nums, int& target, int i, int last, vector<int>& dp){\\n    if(i == nums.size()-1) return 0;\\n    if(dp[i] != INT_MIN) return dp[i];\\n    int res = -1;\\n    for(int j = i+1; j < nums.size(); ++j){\\n        if(abs(nums[j] - last) <= target) {\\n            int t = solve(nums, target, j, nums[j], dp);\\n            if(t != -1) res = max(res, 1 + t );\\n        }\\n    }\\n    return dp[i] = res;\\n}\\nint maximumJumps(vector<int>& nums, int target) {\\n    vector<int> dp(nums.size(), INT_MIN);\\n    return solve(nums, target, 0, nums[0], dp);\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint solve(vector<int>& nums, int& target, int i, int last, vector<int>& dp){\\n    if(i == nums.size()-1) return 0;\\n    if(dp[i] != INT_MIN) return dp[i];\\n    int res = -1;\\n    for(int j = i+1; j < nums.size(); ++j){\\n        if(abs(nums[j] - last) <= target) {\\n            int t = solve(nums, target, j, nums[j], dp);\\n            if(t != -1) res = max(res, 1 + t );\\n        }\\n    }\\n    return dp[i] = res;\\n}\\nint maximumJumps(vector<int>& nums, int target) {\\n    vector<int> dp(nums.size(), INT_MIN);\\n    return solve(nums, target, 0, nums[0], dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739047,
                "title": "c-python-dp-with-approach-easy-to-understand",
                "content": "# Approach \\nThe approach utilizes dynamic programming with an array dp to store the maximum jumps from index 0 to index i. Initially, all elements in dp are set to -1, except for dp[0] which is set to 0 to represent the starting index.\\n\\nThe code then iterates through each index from 1 to n-1 (where n is the size of nums). For each index, it looks back at previous indices (from i - 1 to max(0, i - target)) and checks if the jump from that index to the current index is within the given target range. If it is, and if there is a valid jump from that previous index (dp[j] != -1), the code updates the current dp[i] value by either setting it for the first time or taking the minimum of the current value and dp[j] + 1.\\n\\nFinally, the code returns the value at the last index of dp, which represents the maximum number of jumps required to reach the last index. If dp[n - 1] is still -1, it means reaching the last index is not possible, so the code returns -1 as the result.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1); // dp[i] represents the maximum jumps from index 0 to index i\\n        \\n        dp[0] = 0; // Starting index\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = i - 1; j >= max(0, i - target); j--) {\\n                if (nums[j] >= nums[i] - target && nums[j] <= nums[i] + target) {\\n                    if (dp[j] != -1) {\\n                        if (dp[i] == -1) {\\n                            dp[i] = dp[j] + 1;\\n                        }\\n                        else {\\n                            dp[i] = min(dp[i], dp[j] + 1);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1] == -1 ? -1 : dp[n - 1];\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = [-1] * len(nums)\\n        dp[0] = 0\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i - 1, -1, -1):\\n                if -target <= nums[i] - nums[j] and nums[i] - nums[j] <= target:\\n                    if dp[j] > -1:\\n                        dp[i] = max(dp[i], dp[j] + 1)\\n\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1); // dp[i] represents the maximum jumps from index 0 to index i\\n        \\n        dp[0] = 0; // Starting index\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = i - 1; j >= max(0, i - target); j--) {\\n                if (nums[j] >= nums[i] - target && nums[j] <= nums[i] + target) {\\n                    if (dp[j] != -1) {\\n                        if (dp[i] == -1) {\\n                            dp[i] = dp[j] + 1;\\n                        }\\n                        else {\\n                            dp[i] = min(dp[i], dp[j] + 1);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1] == -1 ? -1 : dp[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = [-1] * len(nums)\\n        dp[0] = 0\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i - 1, -1, -1):\\n                if -target <= nums[i] - nums[j] and nums[i] - nums[j] <= target:\\n                    if dp[j] > -1:\\n                        dp[i] = max(dp[i], dp[j] + 1)\\n\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738973,
                "title": "c-javascript-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            dp[i]=INT_MIN;\\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]-nums[i]>=-target&&nums[j]-nums[i]<=target&&dp[j]!=INT_MIN){\\n                   dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        if(dp[0]==INT_MIN){\\n           return -1;\\n        }\\n        return dp[0]; \\n    }\\n};\\n```\\n**JavaScript**\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n      const n = nums.length;\\n      const dp = new Array(n).fill(1); \\n      dp[n-1] = 0;\\n      for (let i = n-2; i >=0; i--) {\\n\\t  dp[i]=INT_MIN;\\n        for (let j = i+1; j < n; j++) {\\n          if (nums[j] - nums[i] >=-target && nums[j]-nums[i]<=target&&dp[j] !=INT_MIN) {\\n               dp[i]=max(dp[i],1+dp[j]);\\n            }\\n          }\\n        }\\n\\t    if(dp[0]==INT_MIN){\\n\\t\\treturn -1;\\n      }\\n      return dp[0]; \\n   }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            dp[i]=INT_MIN;\\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]-nums[i]>=-target&&nums[j]-nums[i]<=target&&dp[j]!=INT_MIN){\\n                   dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        if(dp[0]==INT_MIN){\\n           return -1;\\n        }\\n        return dp[0]; \\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n      const n = nums.length;\\n      const dp = new Array(n).fill(1); \\n      dp[n-1] = 0;\\n      for (let i = n-2; i >=0; i--) {\\n\\t  dp[i]=INT_MIN;\\n        for (let j = i+1; j < n; j++) {\\n          if (nums[j] - nums[i] >=-target && nums[j]-nums[i]<=target&&dp[j] !=INT_MIN) {\\n               dp[i]=max(dp[i],1+dp[j]);\\n            }\\n          }\\n        }\\n\\t    if(dp[0]==INT_MIN){\\n\\t\\treturn -1;\\n      }\\n      return dp[0]; \\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738971,
                "title": "dp-with-full-explanation",
                "content": "Main idea of this algorithm is checking every num between nums[0, i - 1] is reachable or not to nums[i] i =0..n, where n = nums.length\\n\\nNext steps:\\n1) create array which stores number of jumps, dp[n], where n = nums.length\\n2) initialize dp[0] = 0, because it is initial position, and rest of them fill with -1, because in the beginning they are not reachable\\n3) then for every i=1,n(why from 1?, because we should compare at least with one num behind curr number) check every j=0,i - 1 that satisfies next condition:\\n3.1) abs(nums[i] - nums[j]) <= target\\n3.2) nums[j] != -1 (it means that nums[j] reachable from nums[0])\\n\\nthen update dp[i] with max(dp[i], (dp[j] + 1))\\n\\n![image](https://assets.leetcode.com/users/images/4c40685d-7dfa-4e43-8036-8aec275cd3ab_1688875312.7443366.png)\\n\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n       int n = nums.length;\\n       int[] dp = new int[n + 1];\\n       Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n       for(int i = 1; i < n; i++) {\\n           for(int j = 0; j < i; j++) {\\n               if(Math.abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                   dp[i] = Math.max(dp[i], dp[j] + 1);\\n               }\\n           }\\n       }\\n        \\n       return dp[n - 1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n       int n = nums.length;\\n       int[] dp = new int[n + 1];\\n       Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n       for(int i = 1; i < n; i++) {\\n           for(int j = 0; j < i; j++) {\\n               if(Math.abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                   dp[i] = Math.max(dp[i], dp[j] + 1);\\n               }\\n           }\\n       }\\n        \\n       return dp[n - 1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739009,
                "title": "easy-clean-c-code-dp",
                "content": "### Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n## An Upvote will be encouraging\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001]; // Memoization array to store calculated results\\n    \\n    int helper(int ind, int n, vector<int>& nums, int t, int prev) {\\n        if (ind == n) {\\n            if (prev == n-1)\\n                return 0;\\n            return INT_MIN;\\n        }\\n        \\n        if (dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n        \\n        int ans = INT_MIN; // Initializing answer variable to negative infinity\\n        int x = nums[ind] - nums[prev]; // Calculating difference between current and previous element\\n        \\n        if (x >= -1*t && x <= t) // Checking if difference is within the allowed range\\n            ans = max(ans, 1 + helper(ind+1, n, nums, t, ind)); // Recursive call with current index as new previous index\\n        \\n        ans = max(ans, helper(ind+1, n, nums, t, prev)); // Recursive call without making a jump\\n        \\n        return dp[ind][prev] = ans; // Storing calculated result in dp array and returning the answer\\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp)); // Initializing dp array with -1\\n        \\n        int ans = helper(0, n, nums, target, 0); // Calling helper function to get maximum jumps\\n        \\n        return ans > 0 ? ans - 1 : -1; // Returning the result, subtracting 1 if valid sequence found, otherwise -1\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/de04b237-3cf9-47d5-80f1-d3f07296a6f5_1688875478.2895532.png)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001]; // Memoization array to store calculated results\\n    \\n    int helper(int ind, int n, vector<int>& nums, int t, int prev) {\\n        if (ind == n) {\\n            if (prev == n-1)\\n                return 0;\\n            return INT_MIN;\\n        }\\n        \\n        if (dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n        \\n        int ans = INT_MIN; // Initializing answer variable to negative infinity\\n        int x = nums[ind] - nums[prev]; // Calculating difference between current and previous element\\n        \\n        if (x >= -1*t && x <= t) // Checking if difference is within the allowed range\\n            ans = max(ans, 1 + helper(ind+1, n, nums, t, ind)); // Recursive call with current index as new previous index\\n        \\n        ans = max(ans, helper(ind+1, n, nums, t, prev)); // Recursive call without making a jump\\n        \\n        return dp[ind][prev] = ans; // Storing calculated result in dp array and returning the answer\\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp)); // Initializing dp array with -1\\n        \\n        int ans = helper(0, n, nums, target, 0); // Calling helper function to get maximum jumps\\n        \\n        return ans > 0 ? ans - 1 : -1; // Returning the result, subtracting 1 if valid sequence found, otherwise -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738993,
                "title": "python3-dp",
                "content": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n \\n        dp[-1] = 0 \\n        for i in range(n-2, -1, -1): \\n            for j in range(i+1, n): \\n                if abs(nums[i] - nums[j]) <= target and dp[j] != -1:\\n                    dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n \\n        dp[-1] = 0 \\n        for i in range(n-2, -1, -1): \\n            for j in range(i+1, n): \\n                if abs(nums[i] - nums[j]) <= target and dp[j] != -1:\\n                    dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739288,
                "title": "easy-dp-c",
                "content": "# Complexity\\n- Time complexity:\\n O(n*n)\\n\\n- Space complexity:\\n O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==-1)  continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(abs(nums[j]-nums[i])<=target)   dp[j]=max(dp[i]+1,dp[j]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==-1)  continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(abs(nums[j]-nums[i])<=target)   dp[j]=max(dp[i]+1,dp[j]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739233,
                "title": "dp-on-subsequences-variation-of-0-1-knapsack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to the question, \\nFor every index we have 2 choices - \\n1. Take the index - \\n    \\n    - We can only take a index if - \\n        \\n            -target <= nums[j] - nums[i] <= target  \\n            => -target + nums[i] <= nums[j] <= target + nums[i],  where 0 <= i < j < n.\\n\\n        that is, if the number of current index lie in the range - \\n    \\n            [-target + nums[i], target + nums[i]], where i = previous index.\\n2. Donot take the the index\\n\\nso, we have to explore all the possible case. Hence, we have to use Recursion. \\n\\nIf you draw Recursion Tree, there will be overlapping subproblems. so, to optimize it we have to apply Memoization.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nClearly, We can see that this problem is `variation of 0-1 knapsack`.\\n\\n# Complexity\\n- Time complexity: `O(n*n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n*n) + O(n)` `[ O(n) - Recursion Stack Space]`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int f(int ind, int prev,int &target,int &n,vector<int> &nums, vector<vector<int>> &dp){\\n        //Base Condition\\n        if(ind == n-1){\\n            long long lowh = ((-1)*(long long)target + (long long)nums[prev]);\\n            long long highh = ((long long)target + (long long)nums[prev]);\\n            \\n            if(nums[ind] <= highh && lowh <= nums[ind]) return 1;\\n            else return -1e9;\\n        }\\n        \\n        if(dp[ind][prev] != -1) return dp[ind][prev];\\n        \\n        long long nontake = f(ind+1,prev,target,n,nums,dp); // non-take\\n        \\n        long long low = ((-1)*(long long)target + (long long)nums[prev]);\\n        long long high = ((long long)target + (long long)nums[prev]);\\n        \\n        long long take = -1e9;\\n        if(nums[ind] <= high && low <= nums[ind]) take = 1 + f(ind+1,ind,target,n,nums,dp); // take\\n        \\n        return dp[ind][prev] = (int) max(take,nontake);\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        int ans = f(1,0,target,n,nums,dp);\\n        \\n        return (ans < 0) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int f(int ind, int prev,int &target,int &n,vector<int> &nums, vector<vector<int>> &dp){\\n        //Base Condition\\n        if(ind == n-1){\\n            long long lowh = ((-1)*(long long)target + (long long)nums[prev]);\\n            long long highh = ((long long)target + (long long)nums[prev]);\\n            \\n            if(nums[ind] <= highh && lowh <= nums[ind]) return 1;\\n            else return -1e9;\\n        }\\n        \\n        if(dp[ind][prev] != -1) return dp[ind][prev];\\n        \\n        long long nontake = f(ind+1,prev,target,n,nums,dp); // non-take\\n        \\n        long long low = ((-1)*(long long)target + (long long)nums[prev]);\\n        long long high = ((long long)target + (long long)nums[prev]);\\n        \\n        long long take = -1e9;\\n        if(nums[ind] <= high && low <= nums[ind]) take = 1 + f(ind+1,ind,target,n,nums,dp); // take\\n        \\n        return dp[ind][prev] = (int) max(take,nontake);\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        int ans = f(1,0,target,n,nums,dp);\\n        \\n        return (ans < 0) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739008,
                "title": "simple-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1002];\\n    int jump(int i,vector<int> &nums,int tar)\\n    {\\n        if(i==nums.size()-1) return 0;\\n        if(i>=nums.size())  return -1e9;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        int ans=INT_MIN;\\n        for(int j=i+1;j<nums.size();j++)\\n        {\\n            if(abs(nums[j]-nums[i])<=tar)\\n            {\\n                ans=max(ans,1+jump(j,nums,tar));\\n            }\\n        }\\n        return dp[i]= ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        int ans=jump(0,nums,tar);\\n        if(ans<=-1e9) return -1;\\n        \\n        return ans;\\n        // return ans==0 ? -1 :ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002];\\n    int jump(int i,vector<int> &nums,int tar)\\n    {\\n        if(i==nums.size()-1) return 0;\\n        if(i>=nums.size())  return -1e9;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        int ans=INT_MIN;\\n        for(int j=i+1;j<nums.size();j++)\\n        {\\n            if(abs(nums[j]-nums[i])<=tar)\\n            {\\n                ans=max(ans,1+jump(j,nums,tar));\\n            }\\n        }\\n        return dp[i]= ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        int ans=jump(0,nums,tar);\\n        if(ans<=-1e9) return -1;\\n        \\n        return ans;\\n        // return ans==0 ? -1 :ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739274,
                "title": "recursion-memoization-simple-and-easy-to-understand-c-java-python",
                "content": "# Intuition\\nAt every index we can have n possible jumps, so this gives us the idea of recursion. Using recurison the complexity will be O(n^n) which is not at all feasible, and so we need to apply memoization. (store answer of the sub-problems)\\n\\n# Approach\\n1. From every index we will try to jump at every possible index. (ensuring the required condition is met)\\n2. The current jump will add 1 to our answer and recursion call will give the number of jumps rerquired for that sub problem.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) stack space and O(n) size of the dp\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int solve(int idx, vector<int>& dp, vector<int>& nums, int target){\\n        if(idx==nums.size()-1) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n        \\n        int res=INT_MIN;\\n        for(int i=idx+1; i<nums.size(); i++){\\n            if(nums[i]-nums[idx]<=target && nums[i]-nums[idx]>=-target){\\n                res=max(res,1+solve(i,dp,nums,target));\\n            }\\n        }\\n        \\n        return dp[idx]=res;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        \\n        int ans=solve(0,dp,nums,target);\\n        return ans<0 ? -1 : ans;\\n        \\n    }\\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int solve(int idx, int[] dp, int[] nums, int target) {\\n        if (idx == nums.length - 1) return 0;\\n\\n        if (dp[idx] != -1) return dp[idx];\\n\\n        int res = Integer.MIN_VALUE;\\n        for (int i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] - nums[idx] <= target && nums[i] - nums[idx] >= -target) {\\n                res = Math.max(res, 1 + solve(i, dp, nums, target));\\n            }\\n        }\\n\\n        return dp[idx] = res;\\n    }\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n\\n        int ans = solve(0, dp, nums, target);\\n        return ans < 0 ? -1 : ans;\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def solve(self, idx, dp, nums, target):\\n        if idx == len(nums) - 1:\\n            return 0\\n\\n        if dp[idx] != -1:\\n            return dp[idx]\\n\\n        res = float(\\'-inf\\')\\n        for i in range(idx + 1, len(nums)):\\n            if nums[i] - nums[idx] <= target and nums[i] - nums[idx] >= -target:\\n                res = max(res, 1 + self.solve(i, dp, nums, target))\\n\\n        dp[idx] = res\\n        return dp[idx]\\n\\n    def maximumJumps(self, nums, target):\\n        n = len(nums)\\n        dp = [-1] * n\\n\\n        ans = self.solve(0, dp, nums, target)\\n        return -1 if ans < 0 else ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int idx, vector<int>& dp, vector<int>& nums, int target){\\n        if(idx==nums.size()-1) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n        \\n        int res=INT_MIN;\\n        for(int i=idx+1; i<nums.size(); i++){\\n            if(nums[i]-nums[idx]<=target && nums[i]-nums[idx]>=-target){\\n                res=max(res,1+solve(i,dp,nums,target));\\n            }\\n        }\\n        \\n        return dp[idx]=res;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        \\n        int ans=solve(0,dp,nums,target);\\n        return ans<0 ? -1 : ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int solve(int idx, int[] dp, int[] nums, int target) {\\n        if (idx == nums.length - 1) return 0;\\n\\n        if (dp[idx] != -1) return dp[idx];\\n\\n        int res = Integer.MIN_VALUE;\\n        for (int i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] - nums[idx] <= target && nums[i] - nums[idx] >= -target) {\\n                res = Math.max(res, 1 + solve(i, dp, nums, target));\\n            }\\n        }\\n\\n        return dp[idx] = res;\\n    }\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n\\n        int ans = solve(0, dp, nums, target);\\n        return ans < 0 ? -1 : ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def solve(self, idx, dp, nums, target):\\n        if idx == len(nums) - 1:\\n            return 0\\n\\n        if dp[idx] != -1:\\n            return dp[idx]\\n\\n        res = float(\\'-inf\\')\\n        for i in range(idx + 1, len(nums)):\\n            if nums[i] - nums[idx] <= target and nums[i] - nums[idx] >= -target:\\n                res = max(res, 1 + self.solve(i, dp, nums, target))\\n\\n        dp[idx] = res\\n        return dp[idx]\\n\\n    def maximumJumps(self, nums, target):\\n        n = len(nums)\\n        dp = [-1] * n\\n\\n        ans = self.solve(0, dp, nums, target)\\n        return -1 if ans < 0 else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739071,
                "title": "c-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    int maximumJumps(vector<int>& a, int t) {\\n        int n=a.size();\\n        \\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                ll int diff = 0;\\n                if(a[i]>a[j]){\\n                    diff = (ll)a[i] - (ll)a[j];\\n                }else{\\n                    diff = (ll)a[j] - (ll)a[i];\\n                }\\n                \\n                if(diff <= t && dp[j]!=-1) dp[i]=max(dp[i],1+dp[j]);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    int maximumJumps(vector<int>& a, int t) {\\n        int n=a.size();\\n        \\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                ll int diff = 0;\\n                if(a[i]>a[j]){\\n                    diff = (ll)a[i] - (ll)a[j];\\n                }else{\\n                    diff = (ll)a[j] - (ll)a[i];\\n                }\\n                \\n                if(diff <= t && dp[j]!=-1) dp[i]=max(dp[i],1+dp[j]);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738930,
                "title": "easy-dp-memoization-c",
                "content": "\\n**<<<<<<UpVote**\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target,int index,vector<int>&dp){\\n        if(index>=nums.size()-1) return 0;\\n        int maxi=INT_MIN;\\n        if(dp[index]!=-1) return dp[index];\\n        for(int i=index+1;i<nums.size();i++){\\n            if(abs(nums[index]-nums[i])<=target){\\n                    maxi=max(maxi,1+helper(nums,target,i,dp));\\n            }\\n        }\\n        return dp[index]=maxi;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),-1);\\n        int ans=helper(nums,target,0,dp);\\n        return ans<=0?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target,int index,vector<int>&dp){\\n        if(index>=nums.size()-1) return 0;\\n        int maxi=INT_MIN;\\n        if(dp[index]!=-1) return dp[index];\\n        for(int i=index+1;i<nums.size();i++){\\n            if(abs(nums[index]-nums[i])<=target){\\n                    maxi=max(maxi,1+helper(nums,target,i,dp));\\n            }\\n        }\\n        return dp[index]=maxi;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),-1);\\n        int ans=helper(nums,target,0,dp);\\n        return ans<=0?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832302,
                "title": "100-beats-c-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dp[i] != -1)\\n            for(int j = i+1; j < n; j++){\\n                if(abs(nums[i]-nums[j]) <= target){\\n                    dp[j] = max(dp[j],dp[i]+1);\\n                }\\n            }\\n        }\\n        //<!-- for(auto &i: dp)cout<<i<<\" \"; -->\\n        if(dp[n-1]==-1)return -1;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dp[i] != -1)\\n            for(int j = i+1; j < n; j++){\\n                if(abs(nums[i]-nums[j]) <= target){\\n                    dp[j] = max(dp[j],dp[i]+1);\\n                }\\n            }\\n        }\\n        //<!-- for(auto &i: dp)cout<<i<<\" \"; -->\\n        if(dp[n-1]==-1)return -1;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3764474,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &nums, int target, bool &reached, vector<int> &dp) {\\n        if(i == n - 1) {\\n            reached = true;\\n            return 0;\\n        }\\n        if(dp[i] != -1) return dp[i];\\n        \\n        int ans = -1e9;\\n        for(int j=i+1; j<n; j++) {\\n            if(nums[j] - nums[i] >= -target && nums[j] - nums[i] <= target) {\\n                ans = max(ans, 1 + dfs(j, n, nums, target, reached, dp));\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        bool reached = false;\\n        vector<int> dp(n, -1);\\n        \\n        int ans = dfs(0, n, nums, target, reached, dp);\\n        return reached ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &nums, int target, bool &reached, vector<int> &dp) {\\n        if(i == n - 1) {\\n            reached = true;\\n            return 0;\\n        }\\n        if(dp[i] != -1) return dp[i];\\n        \\n        int ans = -1e9;\\n        for(int j=i+1; j<n; j++) {\\n            if(nums[j] - nums[i] >= -target && nums[j] - nums[i] <= target) {\\n                ans = max(ans, 1 + dfs(j, n, nums, target, reached, dp));\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        bool reached = false;\\n        vector<int> dp(n, -1);\\n        \\n        int ans = dfs(0, n, nums, target, reached, dp);\\n        return reached ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759692,
                "title": "recursion-memoization-tabulation-1d-dp-solution-dp-c",
                "content": "**RECURSION**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int n, int last, vector<int> &nums, int &t) {\\n        if (n == 0) {\\n            int diff = abs(nums[last] - nums[n]);\\n        \\n            if (diff <= t) {\\n                return 1;\\n            }\\n            \\n            return INT_MIN;\\n        }\\n        \\n        int notTake = solve(n - 1, last, nums, t);\\n        int take = INT_MIN;\\n        int diff = abs(nums[last] - nums[n]);\\n        \\n        if (diff <= t) {\\n            take = 1 + solve(n - 1, n, nums, t);\\n        }\\n        \\n        return max(take, notTake);\\n    }\\npublic:\\n\\t\\tint maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans = solve(n - 2, n - 1, nums, target);\\n        \\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n```\\n\\n**MEMOIZATION**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int n, int last, vector<int> &nums, int &t, vector<vector<int>> &dp) {\\n        if (n == 0) {\\n            int diff = abs(nums[last] - nums[n]);\\n        \\n            if (diff <= t) {\\n                return 1;\\n            }\\n            \\n            return INT_MIN;\\n        }\\n        \\n        if (dp[n][last] != -1)\\n            return dp[n][last];\\n        \\n        int notTake = solve(n - 1, last, nums, t, dp);\\n        int take = INT_MIN;\\n        int diff = abs(nums[last] - nums[n]);\\n        \\n        if (diff <= t) {\\n            take = 1 + solve(n - 1, n, nums, t, dp);\\n        }\\n        \\n        return dp[n][last] = max(take, notTake);\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int ans = solve(n - 2, n - 1, nums, target, dp);\\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n```\\n\\n**TABULATION**\\n```\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, INT_MIN));\\n        \\n        // base case\\n        for (int i = 0; i < n; i++) {\\n            int diff = abs(nums[i] - nums[0]);\\n            \\n            if (diff <= target) \\n                dp[0][i] = 1;\\n        }\\n        \\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int notTake = dp[i - 1][j];\\n                int take = INT_MIN;\\n                int diff = abs(nums[j] - nums[i]);\\n\\n                if (diff <= target) {\\n                    take = 1 + dp[i - 1][i];\\n                }\\n\\n                dp[i][j] = max(take, notTake);\\n            }\\n        }\\n        \\n        int ans = dp[n - 2][n - 1];\\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n\\n```\\n**1D DP SOLUTION**\\n```\\nclass Solution {\\nprivate:\\n    int solve(int n, vector<int> &nums, int t, vector<int> &dp) {\\n        if (n == nums.size() - 1) {\\n            return 0;\\n        }\\n        \\n        if (dp[n] != -1)\\n            return dp[n];\\n        \\n        int dist = INT_MIN;\\n        for (int i = n + 1; i < nums.size(); i++) {\\n            int diff = nums[i] - nums[n];\\n                \\n            if (diff >= -t and diff <= t) {\\n                int currDist = solve(i, nums, t, dp);\\n                dist = max(dist, currDist + 1);\\n            }\\n        }\\n        \\n        return dp[n] = dist;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(), -1);\\n        \\n        int ans = solve(0, nums, target, dp);\\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n```\\n\\nPlease Upvote in case you find it helpful",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int n, int last, vector<int> &nums, int &t) {\\n        if (n == 0) {\\n            int diff = abs(nums[last] - nums[n]);\\n        \\n            if (diff <= t) {\\n                return 1;\\n            }\\n            \\n            return INT_MIN;\\n        }\\n        \\n        int notTake = solve(n - 1, last, nums, t);\\n        int take = INT_MIN;\\n        int diff = abs(nums[last] - nums[n]);\\n        \\n        if (diff <= t) {\\n            take = 1 + solve(n - 1, n, nums, t);\\n        }\\n        \\n        return max(take, notTake);\\n    }\\npublic:\\n\\t\\tint maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans = solve(n - 2, n - 1, nums, target);\\n        \\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int n, int last, vector<int> &nums, int &t, vector<vector<int>> &dp) {\\n        if (n == 0) {\\n            int diff = abs(nums[last] - nums[n]);\\n        \\n            if (diff <= t) {\\n                return 1;\\n            }\\n            \\n            return INT_MIN;\\n        }\\n        \\n        if (dp[n][last] != -1)\\n            return dp[n][last];\\n        \\n        int notTake = solve(n - 1, last, nums, t, dp);\\n        int take = INT_MIN;\\n        int diff = abs(nums[last] - nums[n]);\\n        \\n        if (diff <= t) {\\n            take = 1 + solve(n - 1, n, nums, t, dp);\\n        }\\n        \\n        return dp[n][last] = max(take, notTake);\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int ans = solve(n - 2, n - 1, nums, target, dp);\\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n```\n```\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, INT_MIN));\\n        \\n        // base case\\n        for (int i = 0; i < n; i++) {\\n            int diff = abs(nums[i] - nums[0]);\\n            \\n            if (diff <= target) \\n                dp[0][i] = 1;\\n        }\\n        \\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int notTake = dp[i - 1][j];\\n                int take = INT_MIN;\\n                int diff = abs(nums[j] - nums[i]);\\n\\n                if (diff <= target) {\\n                    take = 1 + dp[i - 1][i];\\n                }\\n\\n                dp[i][j] = max(take, notTake);\\n            }\\n        }\\n        \\n        int ans = dp[n - 2][n - 1];\\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int n, vector<int> &nums, int t, vector<int> &dp) {\\n        if (n == nums.size() - 1) {\\n            return 0;\\n        }\\n        \\n        if (dp[n] != -1)\\n            return dp[n];\\n        \\n        int dist = INT_MIN;\\n        for (int i = n + 1; i < nums.size(); i++) {\\n            int diff = nums[i] - nums[n];\\n                \\n            if (diff >= -t and diff <= t) {\\n                int currDist = solve(i, nums, t, dp);\\n                dist = max(dist, currDist + 1);\\n            }\\n        }\\n        \\n        return dp[n] = dist;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(), -1);\\n        \\n        int ans = solve(0, nums, target, dp);\\n        return ans <= 0 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745755,
                "title": "easy-tabulation-solution-1d-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(abs(nums[j]-nums[i])<=target && dp[j]!=-1){\\n                dp[i]=max(dp[i],1+dp[j]);\\n             }\\n         }\\n      }\\n    return dp[n-1];\\n    }\\n};\\n```\\n# Credit to Aryan Mittal for the approach\\n\\n# Video Link\\nhttps://www.youtube.com/watch?v=gGJhgzIHkCY",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(abs(nums[j]-nums[i])<=target && dp[j]!=-1){\\n                dp[i]=max(dp[i],1+dp[j]);\\n             }\\n         }\\n      }\\n    return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739108,
                "title": "leetcode-45-jump-game-ii-java-c-php",
                "content": "# Do upvote if it helps\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Slight Variation of Jump Game II\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Java\\n```\\n    public int maximumJumps(int[] nums, int target) {\\n        int []dp = new int[nums.length];\\n\\n        dp[0] = 0;//0 jump required to reach the dirst element\\n        for (int i = 1;i<nums.length;++i)\\n            dp[i] = Integer.MIN_VALUE;\\n        for (int i = 1;i<nums.length;++i) {\\n            //check if we can reach till i \\n            for (int j = 0;j<i;++j) {\\n                //condition given in question\\n                if (Math.abs(nums[j]-nums[i])<=target)\\n                {\\n                    //update dp if preiously reached index is not MIN Value\\n                    if (dp[j] != Integer.MIN_VALUE)\\n                        dp[i] = Math.max(dp[i], dp[j]+1);\\n                }\\n            }\\n        }\\n        return dp[nums.length-1] == Integer.MIN_VALUE ? -1 : dp[nums.length-1];\\n    }\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n       int n = nums.size();\\n       vector<int> dp(n, INT_MIN);\\n       dp[0] = 0;\\n\\n       for (int i = 1; i < n; ++i) {\\n          for (int j = 0; j < i; ++j) {\\n              if (nums[j] - nums[i] <= target && nums[j] - nums[i] >= -target)\\n                 if (dp[j] != INT_MIN)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n          }\\n       }\\n\\n       return dp[n - 1] == INT_MIN ? -1 : dp[n-1];\\n    }\\n};\\n```\\n# PHP\\n\\n```\\n  function maximumJumps($nums, $target) {\\n        $n = count($nums);\\n        \\n        $dp = array();\\n        for ($i = 1;$i<$n;$i++)\\n            $dp[$i] = PHP_INT_MIN;\\n        for ($i = 1;$i<$n; $i++)\\n        {\\n            for ($j = 0;$j<$i; $j++) {\\n                if (abs($nums[$j]-$nums[$i])<=$target)\\n                if ($dp[$j] != PHP_INT_MIN)\\n                    $dp[$i] = max($dp[$i], $dp[$j]+1);\\n            }\\n        }\\n        \\n        return $dp[$n-1] == PHP_INT_MIN ? -1 : $dp[$n-1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "PHP"
                ],
                "code": "```\\n    public int maximumJumps(int[] nums, int target) {\\n        int []dp = new int[nums.length];\\n\\n        dp[0] = 0;//0 jump required to reach the dirst element\\n        for (int i = 1;i<nums.length;++i)\\n            dp[i] = Integer.MIN_VALUE;\\n        for (int i = 1;i<nums.length;++i) {\\n            //check if we can reach till i \\n            for (int j = 0;j<i;++j) {\\n                //condition given in question\\n                if (Math.abs(nums[j]-nums[i])<=target)\\n                {\\n                    //update dp if preiously reached index is not MIN Value\\n                    if (dp[j] != Integer.MIN_VALUE)\\n                        dp[i] = Math.max(dp[i], dp[j]+1);\\n                }\\n            }\\n        }\\n        return dp[nums.length-1] == Integer.MIN_VALUE ? -1 : dp[nums.length-1];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n       int n = nums.size();\\n       vector<int> dp(n, INT_MIN);\\n       dp[0] = 0;\\n\\n       for (int i = 1; i < n; ++i) {\\n          for (int j = 0; j < i; ++j) {\\n              if (nums[j] - nums[i] <= target && nums[j] - nums[i] >= -target)\\n                 if (dp[j] != INT_MIN)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n          }\\n       }\\n\\n       return dp[n - 1] == INT_MIN ? -1 : dp[n-1];\\n    }\\n};\\n```\n```\\n  function maximumJumps($nums, $target) {\\n        $n = count($nums);\\n        \\n        $dp = array();\\n        for ($i = 1;$i<$n;$i++)\\n            $dp[$i] = PHP_INT_MIN;\\n        for ($i = 1;$i<$n; $i++)\\n        {\\n            for ($j = 0;$j<$i; $j++) {\\n                if (abs($nums[$j]-$nums[$i])<=$target)\\n                if ($dp[$j] != PHP_INT_MIN)\\n                    $dp[$i] = max($dp[$i], $dp[$j]+1);\\n            }\\n        }\\n        \\n        return $dp[$n-1] == PHP_INT_MIN ? -1 : $dp[$n-1];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739085,
                "title": "c-easy-dp-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    int dp[1001];\\n    int solve(vector<int> &nums, int i, int tar)\\n    {\\n        if(i==n-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1e9;\\n        for(int idx=i+1; idx<n; idx++)\\n        {\\n            int dif=nums[idx]-nums[i];\\n            if(dif>=-1*tar && dif<=tar)\\n            {\\n                ans=max(ans, 1+solve(nums, idx, tar));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int tar) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        n=nums.size();\\n        int ans = solve(nums, 0, tar);\\n        if(ans < 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int dp[1001];\\n    int solve(vector<int> &nums, int i, int tar)\\n    {\\n        if(i==n-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1e9;\\n        for(int idx=i+1; idx<n; idx++)\\n        {\\n            int dif=nums[idx]-nums[i];\\n            if(dif>=-1*tar && dif<=tar)\\n            {\\n                ans=max(ans, 1+solve(nums, idx, tar));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int tar) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        n=nums.size();\\n        int ans = solve(nums, 0, tar);\\n        if(ans < 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739049,
                "title": "simple-c-java-pair-solution",
                "content": "\\n```C++ []\\nclass Solution {\\npublic:\\n    struct Pair {\\n        int prev;\\n        int len;\\n        \\n        Pair(int prev, int len) : prev(prev), len(len) {}\\n    };\\n    int maximumJumps(vector<int>& nums, int target){\\n        int n = nums.size();\\n        vector<Pair> arr(n, Pair(-1, 0));\\n        arr[0] = Pair(0, 0);\\n        for(int i = 1; i < n; i++){\\n            for(int j = i - 1; j >= 0; j--){\\n                if(abs(nums[i] - nums[j]) <= target){\\n                    if(arr[j].prev != -1 && arr[j].len + 1 > arr[i].len){\\n                        arr[i].prev = j;\\n                        arr[i].len = arr[j].len + 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return arr[n - 1].len > 0 ? arr[n - 1].len : -1;\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    class Pair {\\n        int prev;\\n        int len;\\n\\n        public Pair(int prev, int len) {\\n            this.prev = prev;\\n            this.len = len;\\n        }\\n    }\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        Pair[] arr = new Pair[nums.length];\\n        arr[0] = new Pair(0, 0);\\n        for(int i = 1; i < nums.length; i++){\\n            arr[i] = new Pair(-1, 0);\\n            for(int j = i - 1; j >= 0; j--){\\n                if(Math.abs(nums[i] - nums[j]) <= target){\\n                    if(arr[j].prev != -1 && arr[j].len + 1 > arr[i].len){\\n                        arr[i].prev = j;\\n                        arr[i].len = arr[j].len + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return arr[nums.length - 1].len > 0 ? arr[nums.length - 1].len : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    struct Pair {\\n        int prev;\\n        int len;\\n        \\n        Pair(int prev, int len) : prev(prev), len(len) {}\\n    };\\n    int maximumJumps(vector<int>& nums, int target){\\n        int n = nums.size();\\n        vector<Pair> arr(n, Pair(-1, 0));\\n        arr[0] = Pair(0, 0);\\n        for(int i = 1; i < n; i++){\\n            for(int j = i - 1; j >= 0; j--){\\n                if(abs(nums[i] - nums[j]) <= target){\\n                    if(arr[j].prev != -1 && arr[j].len + 1 > arr[i].len){\\n                        arr[i].prev = j;\\n                        arr[i].len = arr[j].len + 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return arr[n - 1].len > 0 ? arr[n - 1].len : -1;\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    class Pair {\\n        int prev;\\n        int len;\\n\\n        public Pair(int prev, int len) {\\n            this.prev = prev;\\n            this.len = len;\\n        }\\n    }\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        Pair[] arr = new Pair[nums.length];\\n        arr[0] = new Pair(0, 0);\\n        for(int i = 1; i < nums.length; i++){\\n            arr[i] = new Pair(-1, 0);\\n            for(int j = i - 1; j >= 0; j--){\\n                if(Math.abs(nums[i] - nums[j]) <= target){\\n                    if(arr[j].prev != -1 && arr[j].len + 1 > arr[i].len){\\n                        arr[i].prev = j;\\n                        arr[i].len = arr[j].len + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return arr[nums.length - 1].len > 0 ? arr[nums.length - 1].len : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739021,
                "title": "easy-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int func(int ind, int n, vector<int>& nums, int target){\\n        if(ind == n){\\n            return 0;\\n        }\\n        if(dp[ind] != -2){\\n            return dp[ind];\\n        }\\n        int val=-1;\\n        for(int i=ind+1;i<=n;i++){\\n            if( abs(nums[i]-nums[ind]) <= target ){\\n                int ans =func(i, n, nums, target);\\n                if(ans != -1)\\n                    val = max(val,ans+1);\\n            }\\n        }\\n        \\n        return dp[ind] = val;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        dp.resize(n,-2);\\n         func(0,n-1,nums,target);\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int func(int ind, int n, vector<int>& nums, int target){\\n        if(ind == n){\\n            return 0;\\n        }\\n        if(dp[ind] != -2){\\n            return dp[ind];\\n        }\\n        int val=-1;\\n        for(int i=ind+1;i<=n;i++){\\n            if( abs(nums[i]-nums[ind]) <= target ){\\n                int ans =func(i, n, nums, target);\\n                if(ans != -1)\\n                    val = max(val,ans+1);\\n            }\\n        }\\n        \\n        return dp[ind] = val;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        dp.resize(n,-2);\\n         func(0,n-1,nums,target);\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744346,
                "title": "similar-to-jump-game-ii",
                "content": "# Intuition\\nAt any index i we can jump to any index j where i<j and this pair of indics satisfies the condition\\n\\n# Approach\\nWe\\'ll run a loop from j = i+1 to j<n and for all the i & j that satisfies the condition nums[j]-nums[i] <= abs(target), we\\'ll choose that j that\\'ll give us the maximum number of steps.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N) + O(N) = O(2N) (stack space + dp)\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[10001];\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int val = f(0,nums,target);\\n        return val < 0 ? -1 : val;\\n    }\\n    \\n    int f(int i, vector<int>& vec, int target) {\\n        if(i>=vec.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans = -1e9;\\n        for(int j=i+1 ; j<vec.size() ; ++j) {\\n            int diff = vec[j]-vec[i];\\n            if(diff >= -target && target >= diff) {\\n                ans = max(ans, 1 + f(j,vec,target));\\n                \\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[10001];\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int val = f(0,nums,target);\\n        return val < 0 ? -1 : val;\\n    }\\n    \\n    int f(int i, vector<int>& vec, int target) {\\n        if(i>=vec.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans = -1e9;\\n        for(int j=i+1 ; j<vec.size() ; ++j) {\\n            int diff = vec[j]-vec[i];\\n            if(diff >= -target && target >= diff) {\\n                ans = max(ans, 1 + f(j,vec,target));\\n                \\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742670,
                "title": "c-recursion-0-1-knacksack-easy-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple 0/1 knacksack as we can choose most optimal subsequence\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n# Code\\n```\\nclass Solution {\\n    int solve(int i,int n,vector<int>&nums,int&t,int pre,int&target,int c,vector<vector<int>>&dp){\\n        if(i==n-1){\\n            if(abs(nums[i]-nums[pre])<=target){\\n                return 1;\\n            }\\n            return -1e9;\\n        }\\n        if(dp[i][pre]!=-1)return dp[i][pre];\\n        int take=-1e9;\\n        if(abs(nums[i]-nums[pre])<=target){\\n            take=1+solve(i+1,n,nums,t,i,target,c,dp);\\n        }\\n        int not_take=solve(i+1,n,nums,t,pre,target,c,dp);\\n        return dp[i][pre]=max(take,not_take);\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int t=0;\\n        int c=0;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        int pre=nums[0];\\n        int k=solve(1,n,nums,t,0,target,c,dp);\\n        if(k<=0)return -1;\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int i,int n,vector<int>&nums,int&t,int pre,int&target,int c,vector<vector<int>>&dp){\\n        if(i==n-1){\\n            if(abs(nums[i]-nums[pre])<=target){\\n                return 1;\\n            }\\n            return -1e9;\\n        }\\n        if(dp[i][pre]!=-1)return dp[i][pre];\\n        int take=-1e9;\\n        if(abs(nums[i]-nums[pre])<=target){\\n            take=1+solve(i+1,n,nums,t,i,target,c,dp);\\n        }\\n        int not_take=solve(i+1,n,nums,t,pre,target,c,dp);\\n        return dp[i][pre]=max(take,not_take);\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int t=0;\\n        int c=0;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        int pre=nums[0];\\n        int k=solve(1,n,nums,t,0,target,c,dp);\\n        if(k<=0)return -1;\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741718,
                "title": "easy-dp-solution-beginner-friendly-easy-to-understand",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(), -1);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (-target <= nums[i] - nums[j] && nums[i] - nums[j] <= target) {\\n                    if (dp[j] > -1) {\\n                        dp[i] = max(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i < nums.length; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (-target <= nums[i] - nums[j] && nums[i] - nums[j] <= target) {\\n                    if (dp[j] > -1) {\\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(), -1);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (-target <= nums[i] - nums[j] && nums[i] - nums[j] <= target) {\\n                    if (dp[j] > -1) {\\n                        dp[i] = max(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i < nums.length; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (-target <= nums[i] - nums[j] && nums[i] - nums[j] <= target) {\\n                    if (dp[j] > -1) {\\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740572,
                "title": "c-o-nlogn-dp-segment-tree-optimize-step-by-step-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is the same as [2407. Longest Increasing Subsequence II](https://leetcode.com/problems/longest-increasing-subsequence-ii/description/) but the first element of the subsequence is `nums[0]` and the last element of the subsequence is `nums[n-1]`. Also the limit of the difference between adjacent elements from `0~k` changes to `-target ~ target`.\\nSince there is a limit, we can\\'t use the binary search solution in [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/?envType=list&envId=rrosikri). However, we can solve it with dp.\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nDefine the meaning of `dp[i]` is the length of longest increasing subsequence that start at index `0` and end at index `i`.\\nTo compute `dp[i]`, we have to check all index j that is in front of i. If `abs(nums[j] - nums[i]) <= target`, we can update `dp[i]`.\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[0] = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                //skip if it is impossible to jump to idx j\\n                if(dp[j] == -1) {\\n                    continue;\\n                }\\n                if(abs(nums[j] - nums[i]) <= target) {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n``` \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\nTo further improve the time complextity, we change the definition of `dp`.\\n`dp[nums[i]]` : The length of longest increasing subsequence start with `nums[0]` and end with `nums[i]`.\\n\\nTo compute `dp[nums[i]]`, the question changes to find maximum value in the interval `[nums[i]-target, nums[i]+target]` which can optimize by segment tree.\\n\\nSince the range of `nums[i]` is `-1e9 ~ 1e9`, we can\\'t create the tree with array. Thus we create the tree dynamicly.\\n```\\nclass Node {\\npublic:\\n    Node(int L, int R) : l(L), r(R), mx(INT_MIN), left(nullptr), right(nullptr) {\\n\\n    }\\n    int l;\\n    int r;\\n    int mx;\\n    Node* left;\\n    Node* right;\\n};\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        Node* root = new Node(-1e9, 1e9);\\n\\n        function<void(Node*, int, int)> modify = [&] (Node* now, int pos, int val) {\\n            if(now->l == now->r) {\\n                now->mx = val;\\n                return;\\n            }\\n            int mid = now->l + (now->r - now->l) / 2;\\n            if(pos <= mid) {\\n                if(!now->left) {\\n                    now->left = new Node(now->l, mid);\\n                }\\n                modify(now->left, pos, val);\\n                now->mx = max(now->mx, now->left->mx);\\n            }\\n            else {\\n                if(!now->right) {\\n                    now->right = new Node(mid+1, now->r);\\n                }\\n                modify(now->right, pos, val);\\n                now->mx = max(now->mx, now->right->mx);\\n            }\\n        };\\n\\n        function<int(Node*, int, int)> query = [&] (Node* now, int L, int R) {\\n            if(L <= now->l && now->r <= R) {\\n                return now->mx;\\n            }\\n            int mid = now->l + (now->r - now->l) / 2;\\n            int left = INT_MIN, right = INT_MIN;\\n            if(L <= mid) {\\n                if(!now->left) {\\n                    now->left = new Node(now->l, mid);\\n                }\\n                left = query(now->left, L, R);\\n            }\\n            if(R > mid) {\\n                if(!now->right) {\\n                    now->right = new Node(mid+1, now->r);\\n                }\\n                right = query(now->right, L, R);\\n            }\\n            return max(left, right);\\n        };\\n\\n        modify(root, nums[0], 0);\\n        int ans = -1;\\n        for(int i=1; i<n; i++) {\\n            long long L = max(static_cast<long long>(-1e9), static_cast<long long>(nums[i]) - target);\\n            long long R = min(static_cast<long long>(1e9), static_cast<long long>(nums[i]) + target);\\n            int len = 1 + query(root, L, R);\\n            if(i == n-1) {\\n                ans = max(ans, len);\\n                break;\\n            }\\n            modify(root, nums[i], len);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(nlogV)$$ , $$V$$ = `1e9 - (-1e9)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(nlogV)$$ , since we call query and modify n times. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Approach 3\\n<!-- Describe your approach to solving the problem. -->\\nWe can find out that we actually don\\'t care about the numbers that is not in the array nums because they never occur in the subsequence.\\n\\nWe can simply remove duplicates, sort the input array nums and change the interval of segment tree to `[0, m-1]`, where `m` is the number of distinct value in nums. By this changing, we can use an array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        set<int> s(nums.begin(), nums.end());\\n        vector<int> num(s.begin(), s.end());\\n        int m = num.size();\\n\\n        vector<int> segTree(4*m, INT_MIN);\\n        function<void(int, int, int, int, int)> modify = [&] (int i, int l, int r, int pos, int val) {\\n            if(l == r) {\\n                segTree[i] = val;\\n                return;\\n            }\\n            int mid = l + (r - l) / 2;\\n            if(pos <= num[mid]) {\\n                modify(2*i+1, l, mid, pos, val);\\n            }\\n            else {\\n                modify(2*i+2, mid+1, r, pos, val);\\n            }\\n            segTree[i] = max(segTree[2*i+1], segTree[2*i+2]);\\n        };\\n        \\n        function<int(int, int, int, int, int)> query = [&] (int i, int l, int r, int L, int R) {\\n            if(R < num[l] || L > num[r]) {\\n                return INT_MIN;\\n            }\\n            if(L <= num[l] && num[r] <= R) {\\n                return segTree[i];\\n            }\\n            int mid = l + (r - l) / 2;\\n            int left = INT_MIN, right = INT_MIN;\\n            if(L <= num[mid]) {\\n                left = query(2*i+1, l, mid, L, R);\\n            }\\n            if(R > num[mid]) {\\n                right = query(2*i+2, mid+1, r, L, R);\\n            }\\n            return max(left, right);\\n        };\\n\\n        modify(0, 0, m-1, nums[0], 0);\\n        int ans = -1;\\n        for(int i=1; i<n; i++) {\\n            long long L = max(static_cast<long long>(-1e9), static_cast<long long>(nums[i]) - target);\\n            long long R = min(static_cast<long long>(1e9), static_cast<long long>(nums[i]) + target);\\n            int len = 1 + query(0, 0, m-1, L, R);\\n            if(i == n-1) {\\n                ans = max(ans, len);\\n                break;\\n            }\\n            modify(0, 0, m-1, nums[i], len);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[0] = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                //skip if it is impossible to jump to idx j\\n                if(dp[j] == -1) {\\n                    continue;\\n                }\\n                if(abs(nums[j] - nums[i]) <= target) {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Node {\\npublic:\\n    Node(int L, int R) : l(L), r(R), mx(INT_MIN), left(nullptr), right(nullptr) {\\n\\n    }\\n    int l;\\n    int r;\\n    int mx;\\n    Node* left;\\n    Node* right;\\n};\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        Node* root = new Node(-1e9, 1e9);\\n\\n        function<void(Node*, int, int)> modify = [&] (Node* now, int pos, int val) {\\n            if(now->l == now->r) {\\n                now->mx = val;\\n                return;\\n            }\\n            int mid = now->l + (now->r - now->l) / 2;\\n            if(pos <= mid) {\\n                if(!now->left) {\\n                    now->left = new Node(now->l, mid);\\n                }\\n                modify(now->left, pos, val);\\n                now->mx = max(now->mx, now->left->mx);\\n            }\\n            else {\\n                if(!now->right) {\\n                    now->right = new Node(mid+1, now->r);\\n                }\\n                modify(now->right, pos, val);\\n                now->mx = max(now->mx, now->right->mx);\\n            }\\n        };\\n\\n        function<int(Node*, int, int)> query = [&] (Node* now, int L, int R) {\\n            if(L <= now->l && now->r <= R) {\\n                return now->mx;\\n            }\\n            int mid = now->l + (now->r - now->l) / 2;\\n            int left = INT_MIN, right = INT_MIN;\\n            if(L <= mid) {\\n                if(!now->left) {\\n                    now->left = new Node(now->l, mid);\\n                }\\n                left = query(now->left, L, R);\\n            }\\n            if(R > mid) {\\n                if(!now->right) {\\n                    now->right = new Node(mid+1, now->r);\\n                }\\n                right = query(now->right, L, R);\\n            }\\n            return max(left, right);\\n        };\\n\\n        modify(root, nums[0], 0);\\n        int ans = -1;\\n        for(int i=1; i<n; i++) {\\n            long long L = max(static_cast<long long>(-1e9), static_cast<long long>(nums[i]) - target);\\n            long long R = min(static_cast<long long>(1e9), static_cast<long long>(nums[i]) + target);\\n            int len = 1 + query(root, L, R);\\n            if(i == n-1) {\\n                ans = max(ans, len);\\n                break;\\n            }\\n            modify(root, nums[i], len);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        set<int> s(nums.begin(), nums.end());\\n        vector<int> num(s.begin(), s.end());\\n        int m = num.size();\\n\\n        vector<int> segTree(4*m, INT_MIN);\\n        function<void(int, int, int, int, int)> modify = [&] (int i, int l, int r, int pos, int val) {\\n            if(l == r) {\\n                segTree[i] = val;\\n                return;\\n            }\\n            int mid = l + (r - l) / 2;\\n            if(pos <= num[mid]) {\\n                modify(2*i+1, l, mid, pos, val);\\n            }\\n            else {\\n                modify(2*i+2, mid+1, r, pos, val);\\n            }\\n            segTree[i] = max(segTree[2*i+1], segTree[2*i+2]);\\n        };\\n        \\n        function<int(int, int, int, int, int)> query = [&] (int i, int l, int r, int L, int R) {\\n            if(R < num[l] || L > num[r]) {\\n                return INT_MIN;\\n            }\\n            if(L <= num[l] && num[r] <= R) {\\n                return segTree[i];\\n            }\\n            int mid = l + (r - l) / 2;\\n            int left = INT_MIN, right = INT_MIN;\\n            if(L <= num[mid]) {\\n                left = query(2*i+1, l, mid, L, R);\\n            }\\n            if(R > num[mid]) {\\n                right = query(2*i+2, mid+1, r, L, R);\\n            }\\n            return max(left, right);\\n        };\\n\\n        modify(0, 0, m-1, nums[0], 0);\\n        int ans = -1;\\n        for(int i=1; i<n; i++) {\\n            long long L = max(static_cast<long long>(-1e9), static_cast<long long>(nums[i]) - target);\\n            long long R = min(static_cast<long long>(1e9), static_cast<long long>(nums[i]) + target);\\n            int len = 1 + query(0, 0, m-1, L, R);\\n            if(i == n-1) {\\n                ans = max(ans, len);\\n                break;\\n            }\\n            modify(0, 0, m-1, nums[i], len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740116,
                "title": "python-recursion-cache",
                "content": "```python\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        \\n        @cache\\n        def dp(i):\\n            if i == len(nums) - 1:\\n                return 0\\n\\n            m = 0\\n            for j in range(i + 1, len(nums)):\\n                if -target <= nums[j] - nums[i] <= target:\\n                    m = max(m, dp(j) + 1)\\n\\n            if m == 0:\\n                return float(\\'-inf\\')\\n\\n            return m\\n            \\n        res = dp(0)\\n        if res == float(\\'-inf\\'):\\n            return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        \\n        @cache\\n        def dp(i):\\n            if i == len(nums) - 1:\\n                return 0\\n\\n            m = 0\\n            for j in range(i + 1, len(nums)):\\n                if -target <= nums[j] - nums[i] <= target:\\n                    m = max(m, dp(j) + 1)\\n\\n            if m == 0:\\n                return float(\\'-inf\\')\\n\\n            return m\\n            \\n        res = dp(0)\\n        if res == float(\\'-inf\\'):\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802538,
                "title": "c-easy-memoization",
                "content": "\\n# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int f(int index,vector<int>&nums,int target,vector<int>&dp){\\n        if(index==nums.size()-1)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        //The stuff\\n        int jumps=INT_MIN;\\n        for(int i=index+1;i<nums.size();i++){\\n            \\n            if (abs(nums[i] - nums[index]) <= target) {\\n                jumps=max(jumps,1+f(i,nums,target,dp));\\n            }\\n        }\\n        return dp[index]=jumps;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();  \\n        vector<int>dp(n,-1);\\n        int ans=f(0,nums,target,dp);\\n        if(ans<=0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int f(int index,vector<int>&nums,int target,vector<int>&dp){\\n        if(index==nums.size()-1)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        //The stuff\\n        int jumps=INT_MIN;\\n        for(int i=index+1;i<nums.size();i++){\\n            \\n            if (abs(nums[i] - nums[index]) <= target) {\\n                jumps=max(jumps,1+f(i,nums,target,dp));\\n            }\\n        }\\n        return dp[index]=jumps;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();  \\n        vector<int>dp(n,-1);\\n        int ans=f(0,nums,target,dp);\\n        if(ans<=0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769612,
                "title": "simple-take-nottake-approach-memoization-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    <!-- /* Memoization\\n    int solve(int n, int prev, vector<int>& nums, int target, vector<vector<int>>& dp){\\n        if(n==0){\\n            if(abs(nums[n] - nums[prev])<=target) return 1;\\n            else return -1e8;\\n        }\\n\\n        if(dp[n][prev] != -1) return dp[n][prev];\\n\\n        int notTake = solve(n-1, prev, nums, target, dp);\\n        int take = -1e8;\\n        if(abs(nums[n] - nums[prev])<=target) take = 1 + solve(n-1, n, nums, target, dp);\\n\\n        return dp[n][prev] = max(take, notTake);\\n    }\\n    */ -->\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        //Tabulation\\n        for(int i=0; i<n; i++){\\n            if(abs(nums[0] - nums[i])<=target) dp[0][i] = 1;\\n            else dp[0][i] = -1e8;\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){        \\n                int notTake = dp[i-1][j];\\n                int take = -1e8;\\n                if(abs(nums[i] - nums[j])<=target) take = 1 + dp[i-1][i];\\n                dp[i][j] = max(take, notTake);\\n            }\\n        }\\n        int ans = dp[n-2][n-1]; \\n        if(ans > 0) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    <!-- /* Memoization\\n    int solve(int n, int prev, vector<int>& nums, int target, vector<vector<int>>& dp){\\n        if(n==0){\\n            if(abs(nums[n] - nums[prev])<=target) return 1;\\n            else return -1e8;\\n        }\\n\\n        if(dp[n][prev] != -1) return dp[n][prev];\\n\\n        int notTake = solve(n-1, prev, nums, target, dp);\\n        int take = -1e8;\\n        if(abs(nums[n] - nums[prev])<=target) take = 1 + solve(n-1, n, nums, target, dp);\\n\\n        return dp[n][prev] = max(take, notTake);\\n    }\\n    */ -->\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        //Tabulation\\n        for(int i=0; i<n; i++){\\n            if(abs(nums[0] - nums[i])<=target) dp[0][i] = 1;\\n            else dp[0][i] = -1e8;\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){        \\n                int notTake = dp[i-1][j];\\n                int take = -1e8;\\n                if(abs(nums[i] - nums[j])<=target) take = 1 + dp[i-1][i];\\n                dp[i][j] = max(take, notTake);\\n            }\\n        }\\n        int ans = dp[n-2][n-1]; \\n        if(ans > 0) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756830,
                "title": "c-beats-100-dp-simple-beginner-solution-very-easy-intuitive",
                "content": "# Intuition\\nSuppose we have reached index j with x number of jumps ,then the indices i>j can be reached with x+1 number of jumps if they satisfy the condition.\\n\\n# Approach\\nMake a dp array ,which will contain maximum number of jumps to reach the indices. Now we are at 0 index.Iterate the array.Inside main loop,run another loop from j=i-1 to 0.And for every j check the condition and if condition is satisfied then dp[i]=max(dp[j]+1,dp[i]).\\n\\nNote:-        if(j>0 && dp[j]==0)\\n              continue;\\nThis condition ensures that to jump from index j to i,we have successfully reached index j.If index j is not reached ,then we cannot jump to index i.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maximumJumps(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n               long int val=nums[i]-nums[j];\\n                if(val>=-k && val<=k )\\n                {\\n                    if(j>0 && dp[j]==0)\\n                        continue;\\n                    dp[i]=max(dp[j]+1,dp[i]);\\n                }\\n            }\\n        }\\n        if(dp[n-1]<=0)return -1;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumJumps(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n               long int val=nums[i]-nums[j];\\n                if(val>=-k && val<=k )\\n                {\\n                    if(j>0 && dp[j]==0)\\n                        continue;\\n                    dp[i]=max(dp[j]+1,dp[i]);\\n                }\\n            }\\n        }\\n        if(dp[n-1]<=0)return -1;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753067,
                "title": "easy-solution-same-as-frog-jump",
                "content": "# Approach\\nSimilar approach as frog jump !!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001]={0};\\n    int solve(vector<int> &nums,int t,int i){\\n        if(i==0){\\n            return 0;\\n        }\\n        if(dp[i]!=0){\\n            return dp[i];\\n        }\\n        int maxi=-1;\\n        for(int j=0;j<i;j++){\\n            int diff=nums[i]-nums[j];\\n            if(diff>=-t && diff<=t){\\n                maxi=max(maxi,1+solve(nums,t,j));\\n            }\\n        }\\n        if(maxi==0){\\n            return dp[i]=-1;\\n        }\\n        return dp[i]=maxi;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return solve(nums,target,nums.size()-1);\\n    }\\n};\\n```\\n**if you all like my solution, please do upvote me, it really helps me to improvise my solutions !!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001]={0};\\n    int solve(vector<int> &nums,int t,int i){\\n        if(i==0){\\n            return 0;\\n        }\\n        if(dp[i]!=0){\\n            return dp[i];\\n        }\\n        int maxi=-1;\\n        for(int j=0;j<i;j++){\\n            int diff=nums[i]-nums[j];\\n            if(diff>=-t && diff<=t){\\n                maxi=max(maxi,1+solve(nums,t,j));\\n            }\\n        }\\n        if(maxi==0){\\n            return dp[i]=-1;\\n        }\\n        return dp[i]=maxi;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return solve(nums,target,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749641,
                "title": "c-tabulatin-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        for(int ind=1;ind<n;ind++){\\n            int steps=INT_MIN;\\n            for(int i=ind-1;i>=0;i--){\\n                if(abs(nums[ind]-nums[i])<=target){\\n                    steps=max(steps,1+dp[i]);\\n                }\\n            }\\n            dp[ind]=steps;\\n        }\\n        int ans=dp[n-1];\\n        return ans>0?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        for(int ind=1;ind<n;ind++){\\n            int steps=INT_MIN;\\n            for(int i=ind-1;i>=0;i--){\\n                if(abs(nums[ind]-nums[i])<=target){\\n                    steps=max(steps,1+dp[i]);\\n                }\\n            }\\n            dp[ind]=steps;\\n        }\\n        int ans=dp[n-1];\\n        return ans>0?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745384,
                "title": "python-top-down-dp",
                "content": "# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        @cache\\n        def dfs(i):\\n            if i == n-1: return 0\\n            res = float(\\'-inf\\')\\n            for j in range(i+1, n):\\n                if abs(nums[i]-nums[j]) <= target:\\n                    res = max(res, 1 + dfs(j))\\n            return res\\n        result = dfs(0)\\n        return -1 if result == float(\\'-inf\\') else result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        @cache\\n        def dfs(i):\\n            if i == n-1: return 0\\n            res = float(\\'-inf\\')\\n            for j in range(i+1, n):\\n                if abs(nums[i]-nums[j]) <= target:\\n                    res = max(res, 1 + dfs(j))\\n            return res\\n        result = dfs(0)\\n        return -1 if result == float(\\'-inf\\') else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744360,
                "title": "memoization-java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    int memo[];\\n    private int help(int nums[], int i, int target){\\n        if(i==nums.length-1) return 0;\\n        else if(memo[i]!=0) return memo[i];\\n        int min_val=-1;\\n        for(int j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=target){\\n                int v=help(nums, j, target);\\n                if(v>=0) v+=1;\\n                min_val=Math.max(v, min_val);\\n            }\\n        }\\n        return memo[i]=min_val;\\n    }\\n    public int maximumJumps(int[] nums, int target) {\\n        memo=new int[nums.length];\\n        return help(nums, 0, target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int memo[];\\n    private int help(int nums[], int i, int target){\\n        if(i==nums.length-1) return 0;\\n        else if(memo[i]!=0) return memo[i];\\n        int min_val=-1;\\n        for(int j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=target){\\n                int v=help(nums, j, target);\\n                if(v>=0) v+=1;\\n                min_val=Math.max(v, min_val);\\n            }\\n        }\\n        return memo[i]=min_val;\\n    }\\n    public int maximumJumps(int[] nums, int target) {\\n        memo=new int[nums.length];\\n        return help(nums, 0, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742973,
                "title": "rust-functional-recursive-memoization-100-18ms-100-2-1-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each number, we want to find all eligible jumps and count them as we are considering them. Because jumps must move forward, this makes the problem suitable for recursive dynamic programming, where after each jump we can consider we are working with a new, smaller array.\\n\\nThe base case is that we are at the last index, so we can begin unwinding the recursion, starting the count from 0 at the end (it is 0 because we will be considering in essence how to jump from the last number to itself).\\n\\nWe want to filter out any later indices that number is outside the target difference, and we also only want to consider indices to the right of our cursor.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs a good example of a straightforward dynamic programming problem, it\\'s also useful to memoize. Indeed, the scale of the problem constraints indicates we will TLE if we don\\'t build our memo.\\n\\nWe use Option<i32> rather than magic numbers 0 and -1 so that we can properly track whether we have set our jump_counts and found valid paths in our recursive calls.\\n\\nWe also use Option<Option<i32>> in our memo so we can use the same index as the input array, initializing all values to None, but perhaps later setting invalid paths / jump targets to Some(None).\\n\\nWe use filter_map() to filter out any ineligible jumps that will be greater than the target difference, and map the index, forgetting about the number. We use this resulting list of indices to make our recursive calls.\\n\\nFinally, we use fold() with an initial value of None to track our max_jumps in our recursive calls\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) as we have to iterate on the order of through combinations of the input size of the array n,\\nhowever, with memoization we bring this down to O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf we didn\\'t have TLE restriction, we would certainly stack overflow on large inputs. The stack for a recursive call on a large input can take up an enormous amount of space.\\n\\nHowever, with memoization, we are now passing around the reference to the memo with our calls, and otherwise we only need to store O(n) with the memo itself.\\n\\n# Code\\n```\\nuse std::cmp;\\n\\nimpl Solution {\\n    pub fn maximum_jumps(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut jump_memo: Vec<Option<Option<i32>>> = vec![None; nums.len()];\\n            //In our memoization, we are using an option of options to avoid repeating\\n            //calculations for which there is no valid path (e.g. recursive function\\n            //rightfully returns None). Those entries will be stored in the memo as\\n            //Some(None) so we can skip them after first calculation because\\n            //memo[index].is_none() will be False\\n        Self::recursive_max_jumps(&nums, 0, &target, &mut jump_memo).unwrap_or(-1)\\n            //unwrap_or(-1) gives us the i32 in the Option, or if there is no valid path,\\n            //we know we should return -1\\n    }\\n\\n    fn recursive_max_jumps(nums: &Vec<i32>, first_index: usize, target: &i32, mut memo: &mut Vec<Option<Option<i32>>>) -> Option<i32> {\\n        //In our recursive function, we do not need to pass the last_index,\\n        //as that is not changing in this problem. In other problems, we might\\n        //pass last_index if we want to move it in a more general case\\n        if memo[first_index].is_none() {\\n            //If the outer option hasn\\'t been set (this is different from Some(None)),\\n            //Perform the calculation and memoize it\\n\\n            memo[first_index] = Some({\\n                let last_index: usize = nums.len() - 1;\\n\\n                if first_index == last_index { Some(0) }\\n                else {\\n                        //if first_index is the last_index, return valid path\\n                        //Note we increment on each jump from the back to the front,\\n                        //so this is is where the count starts, from 0\\n                        Self::find_next_jump(&nums, first_index, &target, &mut memo)\\n                    }\\n            });\\n        }\\n        //There is no else needed: If there is a value, including Some(None), \\n        //just return it here. Since we have already checked is_none(), unwrap() is safe\\n        //though there may be a more idiomatic way to write it\\n        memo[first_index].unwrap()\\n    }\\n\\n    fn find_next_jump(nums: &Vec<i32>, cursor: usize, target: &i32, mut memo: &mut Vec<Option<Option<i32>>>) -> Option<i32> {\\n        let this_number: i32 = nums[cursor];\\n\\n        nums.iter().enumerate().skip(cursor + 1)\\n            //We need both index and the number for our filter\\n            .filter_map(|(index, num)| {\\n                if (num - this_number).abs() <= *target { Some(index) }\\n                //For any eligible jumps, return the index (we no \\n                //longer need the number itself)\\n                else { None }\\n                //filter out any numbers that are outside the target difference\\n            })\\n            .fold(None, |jump_count, cur_sor| {\\n                //Now we are operating only on candidate indices to which we can jump\\n                //We start our accumulator with max_jumps = None to indicate it\\'s not set\\n                //We need to track jump_count through our recursive calls, which will\\n                //end up being max_jumps once the recursion winds back up\\n                if let Some(jumps) = Self::recursive_max_jumps(&nums, cur_sor, &target, &mut memo) {\\n                    // if the recursive call to the next index produces a valid path...\\n                    Some(\\n                        match jump_count {\\n                            Some(max_j) => cmp::max(jumps + 1, max_j),\\n                                //return as jump_count (accumulator), max of \\n                                //jumps so far and current value of jump_count, or...\\n                            _ => jumps + 1,\\n                                //if jump_count still not set, return jumps so far to\\n                                //the fold accumulator\\n                        }\\n                    )\\n                } else { jump_count }\\n                // if no valid path, return jump_count unchanged to the accumulator...\\n                // This was my biggest logic error. If we find no path, we should not return none\\n                //or a max_jumps value. We are in the middle of recursion, so we can\\n                //just use the fold accumulator. If we find an invalid path in the middle\\n                //of the recursion, this will still track the max_jumps so far\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nuse std::cmp;\\n\\nimpl Solution {\\n    pub fn maximum_jumps(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut jump_memo: Vec<Option<Option<i32>>> = vec![None; nums.len()];\\n            //In our memoization, we are using an option of options to avoid repeating\\n            //calculations for which there is no valid path (e.g. recursive function\\n            //rightfully returns None). Those entries will be stored in the memo as\\n            //Some(None) so we can skip them after first calculation because\\n            //memo[index].is_none() will be False\\n        Self::recursive_max_jumps(&nums, 0, &target, &mut jump_memo).unwrap_or(-1)\\n            //unwrap_or(-1) gives us the i32 in the Option, or if there is no valid path,\\n            //we know we should return -1\\n    }\\n\\n    fn recursive_max_jumps(nums: &Vec<i32>, first_index: usize, target: &i32, mut memo: &mut Vec<Option<Option<i32>>>) -> Option<i32> {\\n        //In our recursive function, we do not need to pass the last_index,\\n        //as that is not changing in this problem. In other problems, we might\\n        //pass last_index if we want to move it in a more general case\\n        if memo[first_index].is_none() {\\n            //If the outer option hasn\\'t been set (this is different from Some(None)),\\n            //Perform the calculation and memoize it\\n\\n            memo[first_index] = Some({\\n                let last_index: usize = nums.len() - 1;\\n\\n                if first_index == last_index { Some(0) }\\n                else {\\n                        //if first_index is the last_index, return valid path\\n                        //Note we increment on each jump from the back to the front,\\n                        //so this is is where the count starts, from 0\\n                        Self::find_next_jump(&nums, first_index, &target, &mut memo)\\n                    }\\n            });\\n        }\\n        //There is no else needed: If there is a value, including Some(None), \\n        //just return it here. Since we have already checked is_none(), unwrap() is safe\\n        //though there may be a more idiomatic way to write it\\n        memo[first_index].unwrap()\\n    }\\n\\n    fn find_next_jump(nums: &Vec<i32>, cursor: usize, target: &i32, mut memo: &mut Vec<Option<Option<i32>>>) -> Option<i32> {\\n        let this_number: i32 = nums[cursor];\\n\\n        nums.iter().enumerate().skip(cursor + 1)\\n            //We need both index and the number for our filter\\n            .filter_map(|(index, num)| {\\n                if (num - this_number).abs() <= *target { Some(index) }\\n                //For any eligible jumps, return the index (we no \\n                //longer need the number itself)\\n                else { None }\\n                //filter out any numbers that are outside the target difference\\n            })\\n            .fold(None, |jump_count, cur_sor| {\\n                //Now we are operating only on candidate indices to which we can jump\\n                //We start our accumulator with max_jumps = None to indicate it\\'s not set\\n                //We need to track jump_count through our recursive calls, which will\\n                //end up being max_jumps once the recursion winds back up\\n                if let Some(jumps) = Self::recursive_max_jumps(&nums, cur_sor, &target, &mut memo) {\\n                    // if the recursive call to the next index produces a valid path...\\n                    Some(\\n                        match jump_count {\\n                            Some(max_j) => cmp::max(jumps + 1, max_j),\\n                                //return as jump_count (accumulator), max of \\n                                //jumps so far and current value of jump_count, or...\\n                            _ => jumps + 1,\\n                                //if jump_count still not set, return jumps so far to\\n                                //the fold accumulator\\n                        }\\n                    )\\n                } else { jump_count }\\n                // if no valid path, return jump_count unchanged to the accumulator...\\n                // This was my biggest logic error. If we find no path, we should not return none\\n                //or a max_jumps value. We are in the middle of recursion, so we can\\n                //just use the fold accumulator. If we find an invalid path in the middle\\n                //of the recursion, this will still track the max_jumps so far\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742456,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n=len(nums)\\n        dp=[-1]*n\\n        dp[-1]=0\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,n):\\n                if abs(nums[i]-nums[j])<=target and dp[j]!=-1:\\n                    dp[i]=max(dp[i],1+dp[j])\\n                    \\n        return dp[i]            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n=len(nums)\\n        dp=[-1]*n\\n        dp[-1]=0\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,n):\\n                if abs(nums[i]-nums[j])<=target and dp[j]!=-1:\\n                    dp[i]=max(dp[i],1+dp[j])\\n                    \\n        return dp[i]            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742141,
                "title": "java-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -2);\\n        return rec(nums,n,0,target,dp);\\n    }\\n    public int rec(int[] nums,int n,int idx,int target,int[] dp)\\n    {\\n        if(idx==n-1)return 0;\\n        if(dp[idx]!=-2)return dp[idx];\\n        int res=-1;\\n        for(int i=idx+1;i<n;i++)\\n        {\\n            int x=nums[idx]-nums[i];\\n            if(x<=target && x>=-1*target){\\n                res=Math.max(rec(nums,n,i,target,dp)+1,res);\\n            }\\n            \\n        }\\n        return dp[idx]=res==0?-1:res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -2);\\n        return rec(nums,n,0,target,dp);\\n    }\\n    public int rec(int[] nums,int n,int idx,int target,int[] dp)\\n    {\\n        if(idx==n-1)return 0;\\n        if(dp[idx]!=-2)return dp[idx];\\n        int res=-1;\\n        for(int i=idx+1;i<n;i++)\\n        {\\n            int x=nums[idx]-nums[i];\\n            if(x<=target && x>=-1*target){\\n                res=Math.max(rec(nums,n,i,target,dp)+1,res);\\n            }\\n            \\n        }\\n        return dp[idx]=res==0?-1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742132,
                "title": "easy-dp-appraoch",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<int>dp(n,-1);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            { \\n                if((abs(nums[i] - nums[j]) <= target) && dp[j]!=-1) // the check the target is less i -j \\n                dp[i] = max(dp[i],1+dp[j]); // the find max \\n            }\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<int>dp(n,-1);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            { \\n                if((abs(nums[i] - nums[j]) <= target) && dp[j]!=-1) // the check the target is less i -j \\n                dp[i] = max(dp[i],1+dp[j]); // the find max \\n            }\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741151,
                "title": "maximum-jump-to-reach-last-index-using-dynamic-programming-easy-tabulation-approach",
                "content": "# Video Explanation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://youtu.be/3bbTYoKgFvA\\n\\n# Approach\\n1. Every iteration we have to figure out the all possible way to reach the current index.\\n2. Let say if you are in 3rd index. Then index 0,1,2 are possible way\\nare make a jump to reach index 3.\\n3. Then check our constraint given in question. Math.abs(Num[j] - Num[i]) <= target\\n4. if pass our constrain please add 1 step to our current index.\\n5. if multiple possibles are available please pick maximum among that.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n    const dpArray = new Array(nums.length).fill(-1);\\n    dpArray[0] = 0;\\n    for (let i = 1; i < nums.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (Math.abs(nums[j] - nums[i]) <= target && dpArray[j] !== -1) {\\n                dpArray[i] = Math.max(dpArray[i], 1 + dpArray[j]);\\n            }\\n        }\\n    }\\n    return dpArray[nums.length - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n    const dpArray = new Array(nums.length).fill(-1);\\n    dpArray[0] = 0;\\n    for (let i = 1; i < nums.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (Math.abs(nums[j] - nums[i]) <= target && dpArray[j] !== -1) {\\n                dpArray[i] = Math.max(dpArray[i], 1 + dpArray[j]);\\n            }\\n        }\\n    }\\n    return dpArray[nums.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740324,
                "title": "easy-memoization-solution-detialed-expalnation-c",
                "content": "# Approach :\\n1. The maximumJumps function creates a dp vector of size n and initializes all its elements to -1. This vector will be used to store the results of the dfs function for each index i.\\n1. The maximumJumps function calls the dfs function with arguments 0, nums, target, and dp, and assigns its return value to res.\\n1. The dfs function takes as input an index i, the input array nums, the target value, and the dp vector. It returns the maximum number of jumps that can be made to reach the last index of the array starting from index i.\\n1. If i is equal to n-1, the last index of the array, the function returns 0 because no more jumps are needed to reach the last index.\\n1. If the value of dp[i] is not equal to -1, it means that the result for index i has already been calculated and stored in the dp vector. In this case, the function returns the value of dp[i].\\n1. Otherwise, if the value of dp[i] is equal to -1, it means that the result for index i has not been calculated yet. In this case, the function initializes a variable ans to INT_MIN and iterates over all indices j such that i < j < n. For each such index, it checks if -target <= nums[j] - nums[i] <= target. If this condition is satisfied, it means that a valid jump can be made from index i to index j. In this case, it calls itself recursively with arguments j, nums, target, and dp, adds 1 to its return value, and updates the value of ans with the maximum of its current value and this new value.\\n1. After iterating over all indices j, the function assigns the value of ans to dp[i] and returns it.\\n1. Finally, after calling the dfs function, the maximumJumps function checks if its return value is greater than 0. If it is, it returns this value directly. Otherwise, it returns -1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : The time complexity of the given solution is dependent on the number of elements in the input array, n, and the maximum number of jumps that can be made from a single index. In the worst case scenario, where there are no valid jumps and the DFS explores all possible paths, the time complexity can be considered as $$O(n^2)$$. This is because for each index, the algorithm potentially explores all subsequent indices.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int i,vector<int>& nums, int target,vector<int>&dp){\\n        int n = nums.size();\\n        if(i==n-1)return 0;\\n        int ans = INT_MIN;\\n        if(dp[i]!=-1)return dp[i];\\n        for(int j=i+1;j<n;j++){\\n            if(abs(nums[j]-nums[i])<=target){\\n                ans=max(ans,1+dfs(j,nums,target,dp));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int>dp(n,-1);\\n        int res = dfs(0,nums,target,dp);\\n        return res>0?res:-1;\\n    }\\n};\\n```\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/93686102-dbe7-4ef2-b0f8-c51803e713fc_1688895052.2607343.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int i,vector<int>& nums, int target,vector<int>&dp){\\n        int n = nums.size();\\n        if(i==n-1)return 0;\\n        int ans = INT_MIN;\\n        if(dp[i]!=-1)return dp[i];\\n        for(int j=i+1;j<n;j++){\\n            if(abs(nums[j]-nums[i])<=target){\\n                ans=max(ans,1+dfs(j,nums,target,dp));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int>dp(n,-1);\\n        int res = dfs(0,nums,target,dp);\\n        return res>0?res:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740286,
                "title": "simple-memorisation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>& nums, int target, int i, int n, vector<int>& dp){\\n        if(i==n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int x = INT_MIN;\\n        for(int k=i+1; k<n; k++){\\n            long long check = nums[k]-nums[i];\\n            if(check<=target && check>=(-target)){\\n               x = max(x,find(nums, target, k, n, dp)+1);\\n            }\\n        }\\n        \\n        dp[i] = x;\\n        return dp[i];\\n        \\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        int ans = find(nums, target, 0, n, dp);\\n        if(ans<0){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Please Vote Up \\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>& nums, int target, int i, int n, vector<int>& dp){\\n        if(i==n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int x = INT_MIN;\\n        for(int k=i+1; k<n; k++){\\n            long long check = nums[k]-nums[i];\\n            if(check<=target && check>=(-target)){\\n               x = max(x,find(nums, target, k, n, dp)+1);\\n            }\\n        }\\n        \\n        dp[i] = x;\\n        return dp[i];\\n        \\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        int ans = find(nums, target, 0, n, dp);\\n        if(ans<0){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Please Vote Up \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740209,
                "title": "dp-solution-recursion-memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solv(int ind, int t, vector<int>& nums, vector<int>& dp)\\n    {\\n        if(ind==nums.size() || ind== nums.size()-1)\\n            return 1;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int ans=0;\\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]-nums[ind])<=t)\\n                ans=max(ans,solv(i,t,nums,dp));\\n        }\\n        if(ans==0)\\n            return dp[ind]=0;\\n        return dp[ind]=ans+1;\\n    }\\n    int maximumJumps(vector<int>& nums, int t) {\\n        vector<int>dp(nums.size(),-1);\\n        return solv(0,t,nums,dp)-1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int solv(int ind, int t, vector<int>& nums, vector<int>& dp)\\n    {\\n        if(ind==nums.size() || ind== nums.size()-1)\\n            return 1;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int ans=0;\\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]-nums[ind])<=t)\\n                ans=max(ans,solv(i,t,nums,dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3739913,
                "title": "ez-c-dp-solution-1d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n    bool f=false;\\n    int calc(vector<int>&nums,int target,int i){\\n        int ans=INT_MIN;\\n        if(i==nums.size()-1){               \\n                f=true; //This is used to mark whether the final index is reachable or NOT               \\n            return 0;\\n        }      \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        for(int j=i+1;j<nums.size();j++){\\n            if(nums[j]-nums[i]<=target&&nums[j]-nums[i]>=-target)//Choose element within the given range\\n                ans=max(ans,1+calc(nums,target,j));\\n        }\\n        \\n        return dp[i]=ans;\\n            \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        if(target==0) return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int x=calc(nums,target,0);\\n        return !f?-1:x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n    bool f=false;\\n    int calc(vector<int>&nums,int target,int i){\\n        int ans=INT_MIN;\\n        if(i==nums.size()-1){               \\n                f=true; //This is used to mark whether the final index is reachable or NOT               \\n            return 0;\\n        }      \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        for(int j=i+1;j<nums.size();j++){\\n            if(nums[j]-nums[i]<=target&&nums[j]-nums[i]>=-target)//Choose element within the given range\\n                ans=max(ans,1+calc(nums,target,j));\\n        }\\n        \\n        return dp[i]=ans;\\n            \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        if(target==0) return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int x=calc(nums,target,0);\\n        return !f?-1:x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739794,
                "title": "understandable-dp-solution-c-code",
                "content": "### DO UPVOTE if it helps!!\\n\\n# Complexity\\n- Time complexity:O(N X N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dis(n,-1);\\n        dis[0]=0;\\n        for(int i=0; i<n ; i++){\\n            if(dis[i]==-1){\\n                continue;\\n            }\\n            for(int j=i+1 ; j<n ; j++){\\n                if(abs(nums[j]-nums[i])<=target){\\n                    if(1+dis[i]>dis[j]){\\n                        dis[j]=1+dis[i];\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dis(n,-1);\\n        dis[0]=0;\\n        for(int i=0; i<n ; i++){\\n            if(dis[i]==-1){\\n                continue;\\n            }\\n            for(int j=i+1 ; j<n ; j++){\\n                if(abs(nums[j]-nums[i])<=target){\\n                    if(1+dis[i]>dis[j]){\\n                        dis[j]=1+dis[i];\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739614,
                "title": "c-using-bfs-graph-unique-approach-dijkstra-great-intution-for-graph-beginners-easiest-way",
                "content": "# Intuition\\nWhat the intuition is like if **two indexes** are having a **relation that is their abs difference is less than equal to target** means they **are connected**. And than we just need to **find the longest path.** **with** kinda **dijkstra algo**\\n\\n# Approach\\nSo what i have done is first i have created a adjacency list from the relation of the indexes and this will give me a directed graph as you cant go backward and than on the adjacency list i applied longest path algo using queue as its kinda BFS and this is something like dijkstra algorithm.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n       vector<int>adjls[nums.size()];\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            for(int j = i+1 ; j < nums.size() ; j++){\\n                if(abs(nums[i] - nums[j]) <= target && i!=j){\\n                    adjls[i].push_back(j);\\n                }\\n            }\\n        }\\n        int n = nums.size();\\n        vector<int>dis(nums.size(),INT_MIN);\\n        queue<int>q;\\n        q.push(0);\\n        dis[0] = 0;\\n        while(q.size() > 0){\\n            int point = q.front();\\n            q.pop();\\n            for(auto it: adjls[point]){\\n                if(dis[it] < dis[point]+1){\\n                    q.push(it);\\n                    dis[it] = dis[point]+1;\\n                }\\n            }\\n        }\\n        if(dis[n-1] == INT_MIN)return -1;\\n        return dis[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n       vector<int>adjls[nums.size()];\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            for(int j = i+1 ; j < nums.size() ; j++){\\n                if(abs(nums[i] - nums[j]) <= target && i!=j){\\n                    adjls[i].push_back(j);\\n                }\\n            }\\n        }\\n        int n = nums.size();\\n        vector<int>dis(nums.size(),INT_MIN);\\n        queue<int>q;\\n        q.push(0);\\n        dis[0] = 0;\\n        while(q.size() > 0){\\n            int point = q.front();\\n            q.pop();\\n            for(auto it: adjls[point]){\\n                if(dis[it] < dis[point]+1){\\n                    q.push(it);\\n                    dis[it] = dis[point]+1;\\n                }\\n            }\\n        }\\n        if(dis[n-1] == INT_MIN)return -1;\\n        return dis[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739449,
                "title": "java-straightforward-dp",
                "content": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        int res = findMaxJumps(0, target, dp, nums);\\n        return res == Integer.MIN_VALUE ? -1 : res;\\n    }\\n\\n    public int findMaxJumps(int index, int target, int[] dp, int[] nums) {\\n        if (index == dp.length - 1) return dp[index] = 0;\\n        if (dp[index] != -1) return dp[index];\\n        int max = Integer.MIN_VALUE;\\n        for (int j = index + 1; j < dp.length; j++) {\\n            if (Math.abs((long) nums[j] - nums[index]) <= target) {\\n                max = Math.max(max, findMaxJumps(j, target, dp, nums));\\n            }\\n        }\\n        return dp[index] = max == Integer.MIN_VALUE ? max : max + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        int res = findMaxJumps(0, target, dp, nums);\\n        return res == Integer.MIN_VALUE ? -1 : res;\\n    }\\n\\n    public int findMaxJumps(int index, int target, int[] dp, int[] nums) {\\n        if (index == dp.length - 1) return dp[index] = 0;\\n        if (dp[index] != -1) return dp[index];\\n        int max = Integer.MIN_VALUE;\\n        for (int j = index + 1; j < dp.length; j++) {\\n            if (Math.abs((long) nums[j] - nums[index]) <= target) {\\n                max = Math.max(max, findMaxJumps(j, target, dp, nums));\\n            }\\n        }\\n        return dp[index] = max == Integer.MIN_VALUE ? max : max + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739388,
                "title": "dp-solution-beats-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int cnt=0;\\n        int n=nums.size();\\n        vector<int> dp(n, -1);\\n        dp[0]=0;\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=i-1; j>=0; j--)\\n            {\\n                if(abs(nums[j]-nums[i])<=target && dp[j]!=-1)\\n                dp[i]=max(1+dp[j],dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int cnt=0;\\n        int n=nums.size();\\n        vector<int> dp(n, -1);\\n        dp[0]=0;\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=i-1; j>=0; j--)\\n            {\\n                if(abs(nums[j]-nums[i])<=target && dp[j]!=-1)\\n                dp[i]=max(1+dp[j],dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739252,
                "title": "javascript-dp-easy-to-understand",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n      const n = nums.length;\\n      const dp = new Array(n).fill(-1); \\n\\n      dp[0] = 0; // base case\\n\\n      for (let i = 1; i < n; i++) {\\n        for (let j = 0; j < i; j++) {\\n          if (Math.abs(nums[i] - nums[j]) <= target && dp[j] !== -1) {\\n            if (dp[i] === -1 || dp[j] + 1 > dp[i]) {\\n              dp[i] = dp[j] + 1;\\n            }\\n          }\\n        }\\n      }\\n\\n      return dp[n - 1]; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n      const n = nums.length;\\n      const dp = new Array(n).fill(-1); \\n\\n      dp[0] = 0; // base case\\n\\n      for (let i = 1; i < n; i++) {\\n        for (let j = 0; j < i; j++) {\\n          if (Math.abs(nums[i] - nums[j]) <= target && dp[j] !== -1) {\\n            if (dp[i] === -1 || dp[j] + 1 > dp[i]) {\\n              dp[i] = dp[j] + 1;\\n            }\\n          }\\n        }\\n      }\\n\\n      return dp[n - 1]; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739160,
                "title": "python3-top-down-and-bottom-up",
                "content": "# Approach 1: Top Down\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        \\n        @lru_cache(None) \\n        def dp(i):\\n            if i == len(nums) - 1:\\n                return 0\\n            res = 0\\n            f = False\\n            for j in range(i + 1, len(nums)):\\n                dj = dp(j)\\n                if abs(nums[j] - nums[i]) <= target and dj != -1:\\n                    res = max(res, 1 + dj)\\n                    f = True\\n            if not f:\\n                return -1\\n            return res\\n                \\n        return dp(0)\\n\\n```\\n\\n# Approach 2: Bottom Up\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        \\n        dp = [-1] * (len(nums) - 1) + [0]\\n        for i in range(len(nums) - 2, -1, -1):\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[i] - nums[j]) <= target and dp[j] != -1:\\n                    dp[i] = max(dp[i], 1 + dp[j])                \\n            \\n        return dp[0]\\n```\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        \\n        @lru_cache(None) \\n        def dp(i):\\n            if i == len(nums) - 1:\\n                return 0\\n            res = 0\\n            f = False\\n            for j in range(i + 1, len(nums)):\\n                dj = dp(j)\\n                if abs(nums[j] - nums[i]) <= target and dj != -1:\\n                    res = max(res, 1 + dj)\\n                    f = True\\n            if not f:\\n                return -1\\n            return res\\n                \\n        return dp(0)\\n\\n```\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        \\n        dp = [-1] * (len(nums) - 1) + [0]\\n        for i in range(len(nums) - 2, -1, -1):\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[i] - nums[j]) <= target and dp[j] != -1:\\n                    dp[i] = max(dp[i], 1 + dp[j])                \\n            \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739159,
                "title": "c-very-basic-intuitive-dp",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1); //-1 means that the index is not yet reached\\n        dp[0] = 0; //we are already at 0 so we need 0 moves\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j = 0;j<i;j++)\\n            {\\n                if(dp[j]!=-1 and abs(nums[j]-nums[i])<=target) //dp[j]!=-1 means the jth index has been reached otherwise we cant reach i from j if j itself is not reachable.\\n                {\\n                    dp[i] = max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n\\nPlease upvote if you understood the solution!!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1); //-1 means that the index is not yet reached\\n        dp[0] = 0; //we are already at 0 so we need 0 moves\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j = 0;j<i;j++)\\n            {\\n                if(dp[j]!=-1 and abs(nums[j]-nums[i])<=target) //dp[j]!=-1 means the jth index has been reached otherwise we cant reach i from j if j itself is not reachable.\\n                {\\n                    dp[i] = max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739105,
                "title": "simple-iterative-solution-space-o-n-time-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int t) {\\n        int st = 0;\\n        int c = 0;\\n        Integer dp[] = new Integer[nums.length];\\n        dp[0] = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(dp[i]==null) continue;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(t>=Math.abs(nums[i]-nums[j]))\\n                    dp[j] = Math.max(dp[j]==null?0:dp[j],dp[i]+1);\\n            } \\n        }\\n        return dp[nums.length-1]==null?-1:dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int t) {\\n        int st = 0;\\n        int c = 0;\\n        Integer dp[] = new Integer[nums.length];\\n        dp[0] = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(dp[i]==null) continue;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(t>=Math.abs(nums[i]-nums[j]))\\n                    dp[j] = Math.max(dp[j]==null?0:dp[j],dp[i]+1);\\n            } \\n        }\\n        return dp[nums.length-1]==null?-1:dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739074,
                "title": "easy-dp-memoization-tabulation-short-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust run a loop on current index and check the next index i to satisfy the condition and then take max of them.\\n\\n\\n# Memoized Code (TLE)\\n```\\nclass Solution {\\npublic:\\n    int lol(int ind, int t, vector<int> &nums,vector<int>&dp){\\n        int n=nums.size();\\n        if(ind==0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int jumps=0;\\n        for(int i=ind-1;i>=0;i--){\\n            if(abs(nums[ind]-nums[i])<=t){\\n                int njumps=lol(i,t,nums,dp);\\n                if(njumps!=-1) jumps=max(jumps,njumps+1);\\n            }\\n        }\\n        dp[ind]=jumps!=0?jumps:-1;\\n        return dp[ind];\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        return lol(n-1,target,nums,dp); \\n    }\\n};\\n```\\n# Tabulated Code (AC)\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int ind=1;ind<n;ind++){\\n            int jumps=0;\\n            for(int i=ind-1;i>=0;i--){\\n                if(abs(nums[ind]-nums[i])<=target){\\n                    int njumps=dp[i];\\n                    if(njumps!=-1) jumps=max(jumps,njumps+1);\\n                }\\n            }\\n            dp[ind]=jumps!=0?jumps:-1;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lol(int ind, int t, vector<int> &nums,vector<int>&dp){\\n        int n=nums.size();\\n        if(ind==0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int jumps=0;\\n        for(int i=ind-1;i>=0;i--){\\n            if(abs(nums[ind]-nums[i])<=t){\\n                int njumps=lol(i,t,nums,dp);\\n                if(njumps!=-1) jumps=max(jumps,njumps+1);\\n            }\\n        }\\n        dp[ind]=jumps!=0?jumps:-1;\\n        return dp[ind];\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        return lol(n-1,target,nums,dp); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int ind=1;ind<n;ind++){\\n            int jumps=0;\\n            for(int i=ind-1;i>=0;i--){\\n                if(abs(nums[ind]-nums[i])<=target){\\n                    int njumps=dp[i];\\n                    if(njumps!=-1) jumps=max(jumps,njumps+1);\\n                }\\n            }\\n            dp[ind]=jumps!=0?jumps:-1;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739019,
                "title": "c-dp-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(int i, int target, vector<int>& nums, vector<int>& memo){\\n        int n = nums.size();\\n        if(i == n - 1){\\n            return 0;\\n        }\\n        if(memo[i] != -1){\\n            return memo[i];\\n        }\\n        int ans = INT_MIN;\\n        for (int j = i + 1; j < n; j++){\\n            if(-target <= nums[j] - nums[i] && nums[j] - nums[i] <= target){\\n                int temp = helper(j, target, nums, memo);\\n                if(temp != INT_MIN){\\n                    ans =  max(ans, 1 + temp);\\n                }\\n            }\\n        } \\n        return memo[i] = ans;\\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> memo(1001, -1);\\n        int ans = helper(0, target, nums, memo);\\n        if(ans == INT_MIN){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(int i, int target, vector<int>& nums, vector<int>& memo){\\n        int n = nums.size();\\n        if(i == n - 1){\\n            return 0;\\n        }\\n        if(memo[i] != -1){\\n            return memo[i];\\n        }\\n        int ans = INT_MIN;\\n        for (int j = i + 1; j < n; j++){\\n            if(-target <= nums[j] - nums[i] && nums[j] - nums[i] <= target){\\n                int temp = helper(j, target, nums, memo);\\n                if(temp != INT_MIN){\\n                    ans =  max(ans, 1 + temp);\\n                }\\n            }\\n        } \\n        return memo[i] = ans;\\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> memo(1001, -1);\\n        int ans = helper(0, target, nums, memo);\\n        if(ans == INT_MIN){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092696,
                "title": "java-easy-upvote",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];  \\n        Arrays.fill(dp,-2);      \\n        return solver(nums,0,target,dp);\\n    }\\n    public int solver(int[] nums, int curr, int target, int[] dp){\\n        if(curr==nums.length-1) return 0;\\n        if(dp[curr]!=-2) return dp[curr];\\n        int ans = -1;\\n        for(int j=curr+1;j<nums.length;j++){\\n            if(Math.abs(nums[j]-nums[curr])<=target){\\n                ans = Math.max(ans,1+solver(nums,j,target,dp));\\n            }\\n        }\\n        if(ans==0) return dp[curr]=-1;\\n        return dp[curr]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];  \\n        Arrays.fill(dp,-2);      \\n        return solver(nums,0,target,dp);\\n    }\\n    public int solver(int[] nums, int curr, int target, int[] dp){\\n        if(curr==nums.length-1) return 0;\\n        if(dp[curr]!=-2) return dp[curr];\\n        int ans = -1;\\n        for(int j=curr+1;j<nums.length;j++){\\n            if(Math.abs(nums[j]-nums[curr])<=target){\\n                ans = Math.max(ans,1+solver(nums,j,target,dp));\\n            }\\n        }\\n        if(ans==0) return dp[curr]=-1;\\n        return dp[curr]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089876,
                "title": "dp-with-explanation-o-n-2-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry all possible indices `j` before index `i` for finding maximum path to reach `ith` index\\nHence, store ans for calculated index in `dp[i]` for all `i`. If its value is `-1`, its unreachable.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially dp[0] = 0 denoting max 0 steps to reach 0th index\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(abs(nums[i] - nums[j]) <= target)\\n                    if(dp[j] != -1)\\n                        dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(abs(nums[i] - nums[j]) <= target)\\n                    if(dp[j] != -1)\\n                        dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082728,
                "title": "c-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> v(nums.size(), -2);\\n        return dfs(v, nums, 0, target);\\n    }\\n    int dfs(vector<int>& v, vector<int>& nums, int i, int target){\\n        if (i == nums.size() - 1) return 0;\\n        if (v[i] != -2) return v[i];\\n        v[i] = -1;\\n        for (int y = i + 1; y < v.size(); ++y)\\n            if (abs(nums[i] - nums[y]) <= target){\\n                int val = dfs(v, nums, y, target);\\n                if (val != -1) v[i] = max(v[i], 1 + val);\\n            }\\n        return v[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> v(nums.size(), -2);\\n        return dfs(v, nums, 0, target);\\n    }\\n    int dfs(vector<int>& v, vector<int>& nums, int i, int target){\\n        if (i == nums.size() - 1) return 0;\\n        if (v[i] != -2) return v[i];\\n        v[i] = -1;\\n        for (int y = i + 1; y < v.size(); ++y)\\n            if (abs(nums[i] - nums[y]) <= target){\\n                int val = dfs(v, nums, y, target);\\n                if (val != -1) v[i] = max(v[i], 1 + val);\\n            }\\n        return v[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065073,
                "title": "java-dp-beats-96",
                "content": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            int max = Integer.MIN_VALUE;\\n            boolean canReach = false;\\n            for (int j = i + 1; j <= nums.length - 1; j++) {\\n                if (nums[j] - nums[i] <= target && nums[j] - nums[i] >= -target) {\\n                    max = Math.max(max, dp[j]);\\n                    canReach = true;\\n                }\\n            }\\n            if (!canReach || max == Integer.MIN_VALUE) dp[i] = Integer.MIN_VALUE;\\n            else dp[i] = 1 + max;\\n        }\\n        return dp[0] == Integer.MIN_VALUE ? -1 : dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp = new int[nums.length];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            int max = Integer.MIN_VALUE;\\n            boolean canReach = false;\\n            for (int j = i + 1; j <= nums.length - 1; j++) {\\n                if (nums[j] - nums[i] <= target && nums[j] - nums[i] >= -target) {\\n                    max = Math.max(max, dp[j]);\\n                    canReach = true;\\n                }\\n            }\\n            if (!canReach || max == Integer.MIN_VALUE) dp[i] = Integer.MIN_VALUE;\\n            else dp[i] = 1 + max;\\n        }\\n        return dp[0] == Integer.MIN_VALUE ? -1 : dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056005,
                "title": "recursion-memo-1d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n    int solve(int idx, vector<int> &nums, int &target){\\n        if(idx >= nums.size()-1){\\n            return dp[idx]=0;\\n        }\\n\\n        if(dp[idx] != -1){\\n            return dp[idx];\\n        }\\n        int op1 = 0;\\n        for(int i = idx+1; i < nums.size(); i++){\\n            if(abs(nums[i]-nums[idx]) <= target){\\n                int curr = solve(i, nums, target);\\n                op1 = max(op1, 1+curr);\\n            }\\n        }\\n        if(op1 == 0){\\n            return dp[idx]=-2;\\n        }\\n        return dp[idx]=op1;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        int temp = solve(0, nums, target);\\n        if(temp == -2){\\n            return -1;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n    int solve(int idx, vector<int> &nums, int &target){\\n        if(idx >= nums.size()-1){\\n            return dp[idx]=0;\\n        }\\n\\n        if(dp[idx] != -1){\\n            return dp[idx];\\n        }\\n        int op1 = 0;\\n        for(int i = idx+1; i < nums.size(); i++){\\n            if(abs(nums[i]-nums[idx]) <= target){\\n                int curr = solve(i, nums, target);\\n                op1 = max(op1, 1+curr);\\n            }\\n        }\\n        if(op1 == 0){\\n            return dp[idx]=-2;\\n        }\\n        return dp[idx]=op1;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        int temp = solve(0, nums, target);\\n        if(temp == -2){\\n            return -1;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047361,
                "title": "java-dp",
                "content": "# Intuition\\nStraightforward approach - just for each element in initial array we need to store value, indicating the max number of jumps we need to do to reach it. As input array length is not long, we can iterate array for each element of it, calculate diff and decided max number of jumps need to reach current index.\\n\\n# Complexity\\n- Time complexity:\\nO (n^2) - as we are iterating full array for each element \\n\\n- Space complexity:\\nO (n) - additional array of `dp` for storing answer\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] a, int target) {\\n        int n = a.length;\\n        // For each element of input array store max number of jumps\\n        // needed to reach it\\n        int[] dp = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            // dp[i] = 0 means that it is not possible\\n            // to reach current index so we can skip it\\n            if(i > 0 && dp[i] == 0) continue;\\n            for(int j = i + 1; j < n; j++) {\\n                int diff = a[j] - a[i];\\n                if(diff >= -target && diff <= target) {\\n                    // Calculating what is higher:\\n                    // jumping from current index until j \\n                    // or we could jump to j with even more jumps \\n                    // from some previous indexes\\n                    dp[j] = Math.max(dp[j], dp[i] + 1);\\n                }\\n            }\\n        }\\n        return dp[n-1] == 0 ? -1 : dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] a, int target) {\\n        int n = a.length;\\n        // For each element of input array store max number of jumps\\n        // needed to reach it\\n        int[] dp = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            // dp[i] = 0 means that it is not possible\\n            // to reach current index so we can skip it\\n            if(i > 0 && dp[i] == 0) continue;\\n            for(int j = i + 1; j < n; j++) {\\n                int diff = a[j] - a[i];\\n                if(diff >= -target && diff <= target) {\\n                    // Calculating what is higher:\\n                    // jumping from current index until j \\n                    // or we could jump to j with even more jumps \\n                    // from some previous indexes\\n                    dp[j] = Math.max(dp[j], dp[i] + 1);\\n                }\\n            }\\n        }\\n        return dp[n-1] == 0 ? -1 : dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040078,
                "title": "easy-and-concise",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi(vector<long long int>&dp,int n,int ind,int target,vector<int>&nums)\\n    {\\n        //cout<<ind<<\\' \\';\\n        if(ind>=n-1)\\n            return 0;\\n        if(dp[ind]<-1)\\n        return INT_MIN;\\n        if(dp[ind]>0){\\n           // cout<<\"por\"<<endl;\\n            return dp[ind];\\n        }\\n        else\\n        {\\n            int res=-1;\\n            for(int i=ind+1;i<nums.size();i++)\\n            {\\n                if(abs(nums[ind]-nums[i])<=target)\\n                    res=max(res,1+maxi(dp,n,i,target,nums));\\n            }\\n            if(res==-1)\\n            res=INT_MIN;\\n            return dp[ind]=res;\\n        }\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<long long int>dp(n,-1);\\n        return max(-1,maxi(dp,n,0,target,nums));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi(vector<long long int>&dp,int n,int ind,int target,vector<int>&nums)\\n    {\\n        //cout<<ind<<\\' \\';\\n        if(ind>=n-1)\\n            return 0;\\n        if(dp[ind]<-1)\\n        return INT_MIN;\\n        if(dp[ind]>0){\\n           // cout<<\"por\"<<endl;\\n            return dp[ind];\\n        }\\n        else\\n        {\\n            int res=-1;\\n            for(int i=ind+1;i<nums.size();i++)\\n            {\\n                if(abs(nums[ind]-nums[i])<=target)\\n                    res=max(res,1+maxi(dp,n,i,target,nums));\\n            }\\n            if(res==-1)\\n            res=INT_MIN;\\n            return dp[ind]=res;\\n        }\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<long long int>dp(n,-1);\\n        return max(-1,maxi(dp,n,0,target,nums));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4039626,
                "title": "bottom-up-dp-solution-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question is very similar to Minimum Jumps to Reach the end of Array with variable jumps allowed (Jump Game 2) so instantly we think of a DP approach. My original idea was to create a hashmap where i can map each index corresponding to the list of indexes which are reachable as per the given condition ( j>i && -target<=(nums[j]-nums[i])<=target). Post that i proceeded with recursive approach and further memoized it. But this will take n^2 space complexity. So I optimized it and wrote bottom up dp solution for the same. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[0]=0 as we are already on index 0. Iterate on each index i, now for each index i check from 0 to i-1th index(let it be j) if the conditions are satisfied that indicates we can make a jump on the current index from the jth index. So now we can update the dp for ith index accordingly after checking if 1+dp[j] is greater that current value. Note that if -Infinity is encountered on jth index it means that the index was not reachable and we have to ignore it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int tar) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i]=Integer.MIN_VALUE;\\n            for(int j=i-1;j>=0;j--){\\n                int diff=nums[i]-nums[j];\\n                if(diff>=-tar && diff<=tar){\\n                    if(dp[j]==Integer.MIN_VALUE) continue;\\n                    dp[i]=Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        if(dp[n-1]==Integer.MIN_VALUE) return -1;\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int tar) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i]=Integer.MIN_VALUE;\\n            for(int j=i-1;j>=0;j--){\\n                int diff=nums[i]-nums[j];\\n                if(diff>=-tar && diff<=tar){\\n                    if(dp[j]==Integer.MIN_VALUE) continue;\\n                    dp[i]=Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        if(dp[n-1]==Integer.MIN_VALUE) return -1;\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015350,
                "title": "java-1dp-beat-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[]dp=new int[nums.length];\\n        dp[0]=0; \\n        for(int i = 1 ;i<nums.length;i++){\\n            int ans =-1;\\n            for(int j=0 ; j<i ; j++ ){\\n                \\n                if(Math.abs(nums[j]-nums[i])<=target){\\n                    \\n                    if(dp[j]>ans) {ans = dp[j];}\\n                }\\n                if(ans==-1){dp[i]=-1 ;}\\n                else{dp[i]=ans+1 ; }\\n            }\\n        }\\n       return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[]dp=new int[nums.length];\\n        dp[0]=0; \\n        for(int i = 1 ;i<nums.length;i++){\\n            int ans =-1;\\n            for(int j=0 ; j<i ; j++ ){\\n                \\n                if(Math.abs(nums[j]-nums[i])<=target){\\n                    \\n                    if(dp[j]>ans) {ans = dp[j];}\\n                }\\n                if(ans==-1){dp[i]=-1 ;}\\n                else{dp[i]=ans+1 ; }\\n            }\\n        }\\n       return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997712,
                "title": "recursion-memorization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[1001];\\n\\n    int dfs(int idx , vector<int>&nums , int target , int n)\\n    {\\n\\n        if(idx >= n)\\n            return INT_MIN;\\n\\n        if(idx == n-1)\\n            return 0;    \\n\\n        if(dp[idx] != -1)\\n            return dp[idx];    \\n\\n        int mx_cost = INT_MIN;\\n\\n        for(int i = idx+1 ; i < n ; i++)\\n        {\\n            if(-target <= nums[idx]-nums[i] && target >= nums[idx]-nums[i])\\n            {\\n                int cost = dfs(i , nums, target , n);\\n                mx_cost = max(mx_cost , (cost == INT_MIN) ? INT_MIN : cost+1);\\n            }\\n        }    \\n\\n        return dp[idx] = mx_cost;\\n    }\\n\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        memset(dp , -1 , sizeof(dp));\\n        int ans = dfs(0 , nums , target , n);\\n        return ans == INT_MIN ? -1 : ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[1001];\\n\\n    int dfs(int idx , vector<int>&nums , int target , int n)\\n    {\\n\\n        if(idx >= n)\\n            return INT_MIN;\\n\\n        if(idx == n-1)\\n            return 0;    \\n\\n        if(dp[idx] != -1)\\n            return dp[idx];    \\n\\n        int mx_cost = INT_MIN;\\n\\n        for(int i = idx+1 ; i < n ; i++)\\n        {\\n            if(-target <= nums[idx]-nums[i] && target >= nums[idx]-nums[i])\\n            {\\n                int cost = dfs(i , nums, target , n);\\n                mx_cost = max(mx_cost , (cost == INT_MIN) ? INT_MIN : cost+1);\\n            }\\n        }    \\n\\n        return dp[idx] = mx_cost;\\n    }\\n\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        memset(dp , -1 , sizeof(dp));\\n        int ans = dfs(0 , nums , target , n);\\n        return ans == INT_MIN ? -1 : ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993704,
                "title": "ruby-solution-with-memoization-explained",
                "content": "# Intuition\\nAt each point, check which of the later points can be jumped to and which leads to the maximum sequence.  Memoize for efficiency.\\n\\n# Approach\\n1. Store nums and target as class variables so they can be accessed in the helper function.\\n2. Create a memo.\\n3. Find the maximum number of jumps starting at 0.\\n4. Return -1 if it\\'s not possible to reach the end, max jumps otherwise.\\n\\nHelper function:\\n1. Return 0 if you\\'re at the end of nums -- there are no more jumps possible.\\n2. Return a stored result if it\\'s in memo.\\n3. Create an array of options for each later point in nums:\\n    - If you can not jump directly to that point, return the value - infinity to signify it\\'s impossible.\\n    - Otherwise, perform the jump and return 1 + the function starting at the new point.\\n4. Memoize and return whichever option has the highest value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ (could probably be improved)\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef maximum_jumps(nums, target)\\n    @nums, @target = nums, target\\n    @memo = Array.new(nums.length+1,nil)    \\n    res = jumps(0)\\n    res == -Float::INFINITY ? -1 : res\\nend\\n\\ndef jumps(i)\\n    return 0 if i == @nums.length - 1\\n    return @memo[i] if @memo[i]\\n\\n    options = (i+1...@nums.length).map do |k|\\n        if (@nums[i] - @nums[k]).abs > @target\\n            -Float::INFINITY\\n        else\\n            1 + jumps(k)\\n        end\\n    end\\n    @memo[i] = options.max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef maximum_jumps(nums, target)\\n    @nums, @target = nums, target\\n    @memo = Array.new(nums.length+1,nil)    \\n    res = jumps(0)\\n    res == -Float::INFINITY ? -1 : res\\nend\\n\\ndef jumps(i)\\n    return 0 if i == @nums.length - 1\\n    return @memo[i] if @memo[i]\\n\\n    options = (i+1...@nums.length).map do |k|\\n        if (@nums[i] - @nums[k]).abs > @target\\n            -Float::INFINITY\\n        else\\n            1 + jumps(k)\\n        end\\n    end\\n    @memo[i] = options.max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3992275,
                "title": "c-dp",
                "content": "```\\nint maximumJumps(vector<int>& a, int k) {\\n    int n = a.size();\\n\\n    vector<int> dp(n, -1);\\n    dp[0] = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (abs(a[i] - a[j]) <= k && dp[j] != -1) {\\n                dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n        }\\n    }\\n\\n    return dp[n - 1];\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint maximumJumps(vector<int>& a, int k) {\\n    int n = a.size();\\n\\n    vector<int> dp(n, -1);\\n    dp[0] = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (abs(a[i] - a[j]) <= k && dp[j] != -1) {\\n                dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n        }\\n    }\\n\\n    return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3988371,
                "title": "dp-memoization-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEze question jst apply dp fundamentals and you are through\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napply memoization and tabulation\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn^2  guess could be better could be worse\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) space complexiyt\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recu(vector<int> nums, int target,int i1,int i2,vector<vector<int>> &dp){\\n        if(i1 == nums.size() - 1)\\n            return 0;\\n        if(i2 >= nums.size())\\n            return -1e5;\\n        if(dp[i1][i2] != -1)\\n            return dp[i1][i2];\\n        int take = -1e5;\\n        if(abs(nums[i1] - nums[i2]) <= target){\\n            take = 1 + recu(nums,target,i2,i2 + 1,dp);\\n        }\\n        int not_tek = recu(nums,target,i1,i2 + 1,dp);\\n        dp[i1][i2] = max(take,not_tek);\\n        return max(take,not_tek);\\n    } \\n\\n    int tabulation(vector<int> nums,int target){\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n + 1,0));\\n        for(int i = 0; i < n;i++)\\n            dp[i][n] = -1e9 - 1;\\n        for(int i = 0; i <= n; i++)\\n            dp[n - 1][i] = 0;\\n        for(int i1 = n - 2;i1 >= 0; i1--){\\n            for(int i2 = n - 1;i2 >= 0; i2--){\\n                long long take = -1e9 - 1;\\n                if(abs(nums[i1] - nums[i2]) <= target){\\n                    take = 1 + dp[i2][i2 + 1];\\n                }\\n                int not_tek = dp[i1][i2 + 1];\\n                dp[i1][i2] = (take > not_tek)?take:not_tek;    \\n            }\\n        }\\n        return (dp[0][1] > 0)?dp[0][1]:-1;\\n    }    \\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        // vector<vector<int>> dp(nums.size(),vector<int>(nums.size(), -1 ));\\n        // int ele = recu(nums,target,0,1,dp);\\n        // return (ele <= 0)?-1:ele;\\n        return tabulation(nums,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recu(vector<int> nums, int target,int i1,int i2,vector<vector<int>> &dp){\\n        if(i1 == nums.size() - 1)\\n            return 0;\\n        if(i2 >= nums.size())\\n            return -1e5;\\n        if(dp[i1][i2] != -1)\\n            return dp[i1][i2];\\n        int take = -1e5;\\n        if(abs(nums[i1] - nums[i2]) <= target){\\n            take = 1 + recu(nums,target,i2,i2 + 1,dp);\\n        }\\n        int not_tek = recu(nums,target,i1,i2 + 1,dp);\\n        dp[i1][i2] = max(take,not_tek);\\n        return max(take,not_tek);\\n    } \\n\\n    int tabulation(vector<int> nums,int target){\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n + 1,0));\\n        for(int i = 0; i < n;i++)\\n            dp[i][n] = -1e9 - 1;\\n        for(int i = 0; i <= n; i++)\\n            dp[n - 1][i] = 0;\\n        for(int i1 = n - 2;i1 >= 0; i1--){\\n            for(int i2 = n - 1;i2 >= 0; i2--){\\n                long long take = -1e9 - 1;\\n                if(abs(nums[i1] - nums[i2]) <= target){\\n                    take = 1 + dp[i2][i2 + 1];\\n                }\\n                int not_tek = dp[i1][i2 + 1];\\n                dp[i1][i2] = (take > not_tek)?take:not_tek;    \\n            }\\n        }\\n        return (dp[0][1] > 0)?dp[0][1]:-1;\\n    }    \\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        // vector<vector<int>> dp(nums.size(),vector<int>(nums.size(), -1 ));\\n        // int ele = recu(nums,target,0,1,dp);\\n        // return (ele <= 0)?-1:ele;\\n        return tabulation(nums,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976689,
                "title": "easy-to-understand-iterative-dp",
                "content": "# Intution\\nIf we are at any index \\'**i**\\', then we can jump to many indices possible on the right. But we will choose the one which allows for maximum jumps to the last index. Since the answer for current index depends on the answer for indices to the right and we need to explore all of them to find the max jump, so we use dynamic programming.\\n# Approach\\nsuppose we are at index i, then we will check to which indices in the range **[i+1,N-1]** can we jump to, and which of them will lead in the maximum jumps to the last index from current index.\\nthe condition to check if we can jump from current index to last index is **abs(nums[j]-nums[i])<=target**\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            int max_jumps=-1;\\n            for(int j=i+1;j<n;j++){\\n                if(abs(nums[j]-nums[i])<=target && dp[j]!=-1){\\n                    max_jumps=max(max_jumps,1+dp[j]);\\n                }\\n            }\\n            dp[i]=max_jumps;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            int max_jumps=-1;\\n            for(int j=i+1;j<n;j++){\\n                if(abs(nums[j]-nums[i])<=target && dp[j]!=-1){\\n                    max_jumps=max(max_jumps,1+dp[j]);\\n                }\\n            }\\n            dp[i]=max_jumps;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967650,
                "title": "best-dp-approach-python-here",
                "content": "# Approach\\nIts just to find the next step from bottom up to come to early stage and easy to track down to reach the first step. Store every step indeed to check whether the next step is solution and prev step could not be repeated.As it is a Simple DP solution.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n \\n\\n        dp[-1] = 0 \\n        for i in range(n-2, -1, -1): \\n            for j in range(i+1, n): \\n                if abs(nums[i] - nums[j]) <= target:\\n                    if dp[j] != -1:\\n                        dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[i]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n \\n\\n        dp[-1] = 0 \\n        for i in range(n-2, -1, -1): \\n            for j in range(i+1, n): \\n                if abs(nums[i] - nums[j]) <= target:\\n                    if dp[j] != -1:\\n                        dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967440,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[1005];\\n    int solve(int i, int n, vector<int> &nums, int target){\\n        if(i == n){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int ans = -1e9;\\n        for(int j=i+1; j<=n; j++){\\n            if(abs(nums[j]-nums[i]) <= abs(target)){\\n                ans = max(ans, 1 + solve(j, n, nums, target));\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maximumJumps(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solve(0, n-1, nums, target);\\n        return (ans < 0)?-1:ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[1005];\\n    int solve(int i, int n, vector<int> &nums, int target){\\n        if(i == n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3950845,
                "title": "simple-dp-top-down-memo",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        return dfs(nums, target, 0, dp);   \\n    }\\n\\n    private int dfs(int[] nums, int target, int ci, int[] dp){\\n        if (ci==nums.length-1) return 0;\\n        if (dp[ci]!=0) return dp[ci];\\n\\n        int curr = -1;\\n        for (int i=ci+1; i<nums.length; i++){\\n            if (Math.abs(nums[i]-nums[ci])>target) continue;\\n            int next = dfs(nums, target, i, dp);\\n            if (next!=-1)\\n                curr = Math.max(curr, 1+next);\\n        }\\n        dp[ci] = curr;\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        return dfs(nums, target, 0, dp);   \\n    }\\n\\n    private int dfs(int[] nums, int target, int ci, int[] dp){\\n        if (ci==nums.length-1) return 0;\\n        if (dp[ci]!=0) return dp[ci];\\n\\n        int curr = -1;\\n        for (int i=ci+1; i<nums.length; i++){\\n            if (Math.abs(nums[i]-nums[ci])>target) continue;\\n            int next = dfs(nums, target, i, dp);\\n            if (next!=-1)\\n                curr = Math.max(curr, 1+next);\\n        }\\n        dp[ci] = curr;\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926887,
                "title": "easy-dp-solution-beginner-friendly-python",
                "content": "## Complexity\\n- Time complexity: 94% faster\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 99.9% optimal\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], tar: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,n):\\n                if abs(nums[i]-nums[j]) <= tar and (dp[j] != 0 or j == n-1):\\n                    dp[i] = max(dp[i], dp[j]+1)\\n\\n        return dp[0] if dp[0] > 0 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], tar: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,n):\\n                if abs(nums[i]-nums[j]) <= tar and (dp[j] != 0 or j == n-1):\\n                    dp[i] = max(dp[i], dp[j]+1)\\n\\n        return dp[0] if dp[0] > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926475,
                "title": "simple-method-using-tabulation-top-down-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCondition to go from i to j is (abs(nums[j]-nums[i])<=target).\\ndp[i] indicates maximum number of jumps from index i to index n-1. So dp[n-1]=0 as we are already standing at last index(i.e. n-1). Now we will move to index=n-2 and check for the condition, if the condition is satisfied dp[n-2]=1+dp[n-1] as we can go from n-2 to n-1. We will do the same upto i=0.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // private:\\n    // int maximumJumps(vector<int>& nums, int target, int index){\\n    //     if(index==nums.size()-1)\\n    //     return 0;\\n\\n    //     for(int i=index;i<nums.size();i++){\\n    //         if(abs(nums[i+1]-nums[index])<=target){\\n    //             int jump=1+maximumJumps(nums, target, i+1);\\n    //             return jump;\\n    //         }\\n    //     }\\n    //     return INT_MIN;\\n    \\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        // return maximumJumps(nums, target, 0); \\n        vector<int>dp(nums.size(),0);\\n        dp[nums.size()-1]=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(abs(nums[j]-nums[i])<=target){\\n                    if(j==nums.size()-1)\\n                    dp[i]=max(dp[i], 1+dp[j]);\\n                    else{\\n// [1,2,3,4,1,5] target=0,  we can still go from i=0 to j=4 but from we j=4 we can\\'t reach last index so to overcome this problem we are using this condition dp[j]!=0   but if j=n-1(last index) then dp[j] will be zero as we are already standing on the last index\\n                        if(dp[j]!=0)\\n                        dp[i]=max(dp[i], 1+dp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[0]==0)\\n        return -1;\\n        return dp[0];       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // private:\\n    // int maximumJumps(vector<int>& nums, int target, int index){\\n    //     if(index==nums.size()-1)\\n    //     return 0;\\n\\n    //     for(int i=index;i<nums.size();i++){\\n    //         if(abs(nums[i+1]-nums[index])<=target){\\n    //             int jump=1+maximumJumps(nums, target, i+1);\\n    //             return jump;\\n    //         }\\n    //     }\\n    //     return INT_MIN;\\n    \\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        // return maximumJumps(nums, target, 0); \\n        vector<int>dp(nums.size(),0);\\n        dp[nums.size()-1]=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(abs(nums[j]-nums[i])<=target){\\n                    if(j==nums.size()-1)\\n                    dp[i]=max(dp[i], 1+dp[j]);\\n                    else{\\n// [1,2,3,4,1,5] target=0,  we can still go from i=0 to j=4 but from we j=4 we can\\'t reach last index so to overcome this problem we are using this condition dp[j]!=0   but if j=n-1(last index) then dp[j] will be zero as we are already standing on the last index\\n                        if(dp[j]!=0)\\n                        dp[i]=max(dp[i], 1+dp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[0]==0)\\n        return -1;\\n        return dp[0];       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917964,
                "title": "bottom-up-dp-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    int f(vector<int>& nums, int target , int ind , vector<int>&dp){\\n        \\n        if(ind==nums.size()-1)\\n            return 0;\\n        \\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        //WE WILL DECLARE RES AS INT_MIN AND WILL COMPARE TO OUR INCREMENTED VALUE\\n        int res=INT_MIN;\\n        //TRAVERSING EACH VALUE FROM LAST REACHED INDEX AND MAKING SURE THAT IT       IN LIES IN THE GIVEN RANGE\\n        //WHENEVER FIND SUITABLE INDEX JUST SKIP TO THAT INDEX\\n        for(int i=ind+1;i<nums.size();i++){\\n            if(nums[i]-nums[ind]<=target && nums[i]-nums[ind]>=(-target))\\n                res=max(res,1 + f(nums,target,i,dp));\\n        }\\n        return dp[ind] = res;\\n    }\\n\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        // if(target==0)\\n        //     return -1;\\n        int n=nums.size();\\n        vector<int>dp(n+1,-1);\\n        int a = f(nums , target , 0 , dp);\\n        if(a<0)\\n            return -1;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    int f(vector<int>& nums, int target , int ind , vector<int>&dp){\\n        \\n        if(ind==nums.size()-1)\\n            return 0;\\n        \\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        //WE WILL DECLARE RES AS INT_MIN AND WILL COMPARE TO OUR INCREMENTED VALUE\\n        int res=INT_MIN;\\n        //TRAVERSING EACH VALUE FROM LAST REACHED INDEX AND MAKING SURE THAT IT       IN LIES IN THE GIVEN RANGE\\n        //WHENEVER FIND SUITABLE INDEX JUST SKIP TO THAT INDEX\\n        for(int i=ind+1;i<nums.size();i++){\\n            if(nums[i]-nums[ind]<=target && nums[i]-nums[ind]>=(-target))\\n                res=max(res,1 + f(nums,target,i,dp));\\n        }\\n        return dp[ind] = res;\\n    }\\n\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        // if(target==0)\\n        //     return -1;\\n        int n=nums.size();\\n        vector<int>dp(n+1,-1);\\n        int a = f(nums , target , 0 , dp);\\n        if(a<0)\\n            return -1;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891940,
                "title": "max-jumps-to-reach-last-index-java-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        Integer []dp=new Integer[nums.length];\\n        int ans=helper(nums,target,0, dp);\\n        return ans<=0?-1:ans;\\n    }\\n\\n    public int helper(int []nums, int target, int idx, Integer[]dp){\\n        if(idx>=nums.length-1){\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=null){\\n            return dp[idx];\\n        }\\n\\n\\n        long l=1L*nums[idx]-target;\\n        long r=1L*nums[idx]+target;\\n\\n        int ans=-(int)(1e9);\\n        for(int i=idx+1;i<nums.length;i++){\\n\\n            if(nums[i]>=l && nums[i]<=r){\\n                ans=Math.max(ans,1+helper(nums,target,i,dp));\\n            }\\n        }\\n\\n        return dp[idx]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        Integer []dp=new Integer[nums.length];\\n        int ans=helper(nums,target,0, dp);\\n        return ans<=0?-1:ans;\\n    }\\n\\n    public int helper(int []nums, int target, int idx, Integer[]dp){\\n        if(idx>=nums.length-1){\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=null){\\n            return dp[idx];\\n        }\\n\\n\\n        long l=1L*nums[idx]-target;\\n        long r=1L*nums[idx]+target;\\n\\n        int ans=-(int)(1e9);\\n        for(int i=idx+1;i<nums.length;i++){\\n\\n            if(nums[i]>=l && nums[i]<=r){\\n                ans=Math.max(ans,1+helper(nums,target,i,dp));\\n            }\\n        }\\n\\n        return dp[idx]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889563,
                "title": "simple-c-iterative-solution-with-intution-to-approach-all-linear-dp-questions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets say we are at any ith index. Our final goal is to reach n-1. From here we can go to every index from i+1 to n-1.These are the possible paths ahead. Find which path gives max jumps we have our answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom above approach we can clearly see some repeating subproblems.\\nfor example from 3 we can go to 4,5,6...\\nsimilarly when we are at 4 we go to 5,6,7...\\nSo to sort that we have a dp array wherein dp[i] tells max jumps we can have to reach from i to n-1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n      int n=nums.size();\\n       \\n      vector<int> dp(n,-1e9);\\n//standing at n-1 we dont need any jumps\\n      dp[n-1]=0;\\n\\n      for(int i=n-2;i>=0;i--)\\n      {\\n          int jumps=-1e9;\\n// we will go to every index ahead and find which gives max jumps\\n//to reach n-1.\\n          for(int j=i+1;j<n;j++)\\n          {\\n\\n              if(abs(nums[i]-nums[j])<=target)\\n              {\\n                jumps=max(jumps,dp[j]);  \\n              }\\n          }\\n  // adding 1 cause we will take 1 jump to reach that specific index\\n          if(jumps!=-1e9)dp[i]=jumps+1;\\n      }\\n      return dp[0]==-1e9 ? -1 :dp[0];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n      int n=nums.size();\\n       \\n      vector<int> dp(n,-1e9);\\n//standing at n-1 we dont need any jumps\\n      dp[n-1]=0;\\n\\n      for(int i=n-2;i>=0;i--)\\n      {\\n          int jumps=-1e9;\\n// we will go to every index ahead and find which gives max jumps\\n//to reach n-1.\\n          for(int j=i+1;j<n;j++)\\n          {\\n\\n              if(abs(nums[i]-nums[j])<=target)\\n              {\\n                jumps=max(jumps,dp[j]);  \\n              }\\n          }\\n  // adding 1 cause we will take 1 jump to reach that specific index\\n          if(jumps!=-1e9)dp[i]=jumps+1;\\n      }\\n      return dp[0]==-1e9 ? -1 :dp[0];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886850,
                "title": "java-easy-solution-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int[] dp;\\n\\n    int solve(int[] nums,int target,int i){\\n\\n        if(i==nums.length-1){\\n            return 0;\\n        }\\n\\n        if(dp[i]!=-2){\\n            return dp[i];\\n        }\\n\\n        int maxx=-1;\\n\\n        for(int j=i+1;j<nums.length;j++){\\n\\n            if(nums[j]-nums[i]<=target && nums[j]-nums[i]>=-target){\\n                maxx=Math.max(maxx,solve(nums,target,j)+1);\\n            }\\n\\n        }\\n\\n        if(maxx==0){\\n            dp[i]=-1;\\n            return -1;\\n        }\\n\\n        dp[i]=maxx;\\n        return maxx;\\n\\n    }\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        \\n        dp=new int[nums.length+1];\\n        for(int i=0;i<dp.length;i++){\\n            dp[i]=-2;\\n        }\\n\\n        return solve(nums,target,0);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] dp;\\n\\n    int solve(int[] nums,int target,int i){\\n\\n        if(i==nums.length-1){\\n            return 0;\\n        }\\n\\n        if(dp[i]!=-2){\\n            return dp[i];\\n        }\\n\\n        int maxx=-1;\\n\\n        for(int j=i+1;j<nums.length;j++){\\n\\n            if(nums[j]-nums[i]<=target && nums[j]-nums[i]>=-target){\\n                maxx=Math.max(maxx,solve(nums,target,j)+1);\\n            }\\n\\n        }\\n\\n        if(maxx==0){\\n            dp[i]=-1;\\n            return -1;\\n        }\\n\\n        dp[i]=maxx;\\n        return maxx;\\n\\n    }\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        \\n        dp=new int[nums.length+1];\\n        for(int i=0;i<dp.length;i++){\\n            dp[i]=-2;\\n        }\\n\\n        return solve(nums,target,0);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878505,
                "title": "dynamic-programmin",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MaximumJumps(int[] nums, int target)\\n    {\\n        var dp = new int[nums.Length];\\n        dp[0] = 1;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (dp[i] == 0) continue;\\n            for (int j = i + 1; j < nums.Length; j++)\\n            {\\n                if (Math.Abs(nums[j] - nums[i]) <= target)\\n                {\\n                    dp[j] = Math.Max(dp[j], dp[i] + 1);\\n                }\\n            }\\n        }\\n\\n        return dp[^1] > 0 ? dp[^1] - 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MaximumJumps(int[] nums, int target)\\n    {\\n        var dp = new int[nums.Length];\\n        dp[0] = 1;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (dp[i] == 0) continue;\\n            for (int j = i + 1; j < nums.Length; j++)\\n            {\\n                if (Math.Abs(nums[j] - nums[i]) <= target)\\n                {\\n                    dp[j] = Math.Max(dp[j], dp[i] + 1);\\n                }\\n            }\\n        }\\n\\n        return dp[^1] > 0 ? dp[^1] - 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872418,
                "title": "beats-98-81-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> track(n);\\n        track[n-1] = 0;\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            //bool canjump=false;\\n            int mx = INT_MIN;\\n            for(int j = i+1;j<n;j++)\\n            {\\n                if(abs(nums[i]-nums[j])<=target)\\n                {\\n                    //canjump = true;\\n                    mx = max(mx,track[j]);\\n                }\\n            }\\n            track[i] = mx+1;\\n        }\\n        if(track[0]<0)\\n        return -1;\\n        else\\n        return track[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> track(n);\\n        track[n-1] = 0;\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            //bool canjump=false;\\n            int mx = INT_MIN;\\n            for(int j = i+1;j<n;j++)\\n            {\\n                if(abs(nums[i]-nums[j])<=target)\\n                {\\n                    //canjump = true;\\n                    mx = max(mx,track[j]);\\n                }\\n            }\\n            track[i] = mx+1;\\n        }\\n        if(track[0]<0)\\n        return -1;\\n        else\\n        return track[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857228,
                "title": "c-dp-95-faster",
                "content": "Variation of Longest Increasing Subsequence problem.\\n\\n# Complexity\\n- Time complexity: $$O(n$$^2$$)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,0);\\n        dp[0] = 1;\\n\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(abs(nums[i] - nums[j]) <= target && dp[j] > 0)\\n                    dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n\\n        }\\n\\n        return dp[n - 1] > 0 ? dp[n - 1] - 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,0);\\n        dp[0] = 1;\\n\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(abs(nums[i] - nums[j]) <= target && dp[j] > 0)\\n                    dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n\\n        }\\n\\n        return dp[n - 1] > 0 ? dp[n - 1] - 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855405,
                "title": "c-dp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Jump Game\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> steps(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (abs(nums[j] - nums[i]) <= target) {\\n                    if (i != 0 && steps[i] == 0) {\\n                        continue;\\n                    }\\n                    steps[j] = max(steps[j], steps[i] + 1);\\n                }\\n            }\\n        }\\n        return steps[n - 1] == 0 ? -1 : steps[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Jump Game\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> steps(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (abs(nums[j] - nums[i]) <= target) {\\n                    if (i != 0 && steps[i] == 0) {\\n                        continue;\\n                    }\\n                    steps[j] = max(steps[j], steps[i] + 1);\\n                }\\n            }\\n        }\\n        return steps[n - 1] == 0 ? -1 : steps[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852477,
                "title": "easy-solution-beats-98-3-dynamic-programming",
                "content": "# Intuition\\nsimilar to climbing stairs problem but extra target has came in this problem  and maximum number of jumps you can make to reach index n - 1. .\\n\\n# Approach\\nsame recursive apporach  and adding dp  with the condition. \\n\\n# Complexity\\n- Time complexity: O(N^2)+space complexity(O(N))\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // unordered_map<int,int>dp;\\n    int solve(vector<int>& nums, int i,int target,vector<int>&dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=INT_MIN;\\n        for(int j=i+1;j<nums.size();j++){\\n            if(-target<=(nums[j]-nums[i]) and (nums[j]-nums[i])<=target ){\\n                ans=max(ans,1+solve(nums,j,target,dp)); \\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int>dp(nums.size(),-1);\\n        int ans=solve(nums,0,target,dp);\\n        return ans<0 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // unordered_map<int,int>dp;\\n    int solve(vector<int>& nums, int i,int target,vector<int>&dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=INT_MIN;\\n        for(int j=i+1;j<nums.size();j++){\\n            if(-target<=(nums[j]-nums[i]) and (nums[j]-nums[i])<=target ){\\n                ans=max(ans,1+solve(nums,j,target,dp)); \\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int>dp(nums.size(),-1);\\n        int ans=solve(nums,0,target,dp);\\n        return ans<0 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850237,
                "title": "easy-java-solution",
                "content": "Create a new array `maxJumps` that tracks the maximum steps from any index before it satisfying the given conditions. We calculate this for all the indices and return the last value from this new array.\\n\\nmaxJumps[0] will be 0 since we start at 0\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] maxJumps = new int[nums.length];\\n        for(int i=1;i<nums.length;i++) {\\n            for(int j=0;j<i;j++) {\\n                if(Math.abs(nums[i]-nums[j]) <=target && \\n                        (j==0 || maxJumps[j]>0)) {\\n                    maxJumps[i]=Math.max(maxJumps[i], maxJumps[j]+1);\\n                }\\n            }\\n        }\\n        return maxJumps[nums.length-1] > 0 ? maxJumps[nums.length-1]: -1 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] maxJumps = new int[nums.length];\\n        for(int i=1;i<nums.length;i++) {\\n            for(int j=0;j<i;j++) {\\n                if(Math.abs(nums[i]-nums[j]) <=target && \\n                        (j==0 || maxJumps[j]>0)) {\\n                    maxJumps[i]=Math.max(maxJumps[i], maxJumps[j]+1);\\n                }\\n            }\\n        }\\n        return maxJumps[nums.length-1] > 0 ? maxJumps[nums.length-1]: -1 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840026,
                "title": "c-easy-dp-solution-beats-100-00",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& v, int t) {\\n        int n = size(v);\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0] = 0;\\n        for(int i=0 ; i<n ; i++){\\n            if(dp[i] == -1) continue;\\n            for(int j=i+1 ; j<n ; j++) if(abs(v[i]-v[j]) <= t) dp[j] = max(dp[j] , 1 + dp[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& v, int t) {\\n        int n = size(v);\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0] = 0;\\n        for(int i=0 ; i<n ; i++){\\n            if(dp[i] == -1) continue;\\n            for(int j=i+1 ; j<n ; j++) if(abs(v[i]-v[j]) <= t) dp[j] = max(dp[j] , 1 + dp[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834846,
                "title": "dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {  \\n        int n = nums.size();\\n        int dp[n];\\n     dp[0] = 0;\\n        for(int i=1;i<n;i++){\\n            int j=i-1;\\n            int maxi = 0;\\n            while(j>=0){\\n                \\n    if(nums[j]-nums[i]>=-target && nums[j]-nums[i]<=target){\\n                    maxi = max(dp[j]+1,maxi); \\n                }\\n                j--;\\n            }\\n            if(maxi == 1 && nums[0]-nums[i]>=-target && nums[0]-nums[i]<=target){\\n                dp[i] = 1;\\n            }\\n            else if(maxi>1){\\n                dp[i] = maxi;\\n            }\\n            else{\\n                dp[i] = 0;\\n            } \\n        }\\n        if(dp[n-1] == 0){\\n            return -1;\\n        }\\n        return dp[n-1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {  \\n        int n = nums.size();\\n        int dp[n];\\n     dp[0] = 0;\\n        for(int i=1;i<n;i++){\\n            int j=i-1;\\n            int maxi = 0;\\n            while(j>=0){\\n                \\n    if(nums[j]-nums[i]>=-target && nums[j]-nums[i]<=target){\\n                    maxi = max(dp[j]+1,maxi); \\n                }\\n                j--;\\n            }\\n            if(maxi == 1 && nums[0]-nums[i]>=-target && nums[0]-nums[i]<=target){\\n                dp[i] = 1;\\n            }\\n            else if(maxi>1){\\n                dp[i] = maxi;\\n            }\\n            else{\\n                dp[i] = 0;\\n            } \\n        }\\n        if(dp[n-1] == 0){\\n            return -1;\\n        }\\n        return dp[n-1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829134,
                "title": "99-99-fast-dp-explanation-comments-clean-code",
                "content": "# Intuition\\nWrite the recursion to compute all possible answer.\\n\\n# Approach\\nFrom the current point (lets say i) go to all the points (lets say j) and compute the value with respect to every possible points in the array. \\nCompute the maximum among them and return it.\\n\\n# Complexity\\n- Time complexity:\\n- O(N*N) = O(N^2) -> with every i there is N time j is called in rec function. Store array (DP) is reduing calls of i from 2^N to N. \\n  where N is size of array.\\n\\n- Space complexity:\\n- O(N) = O(N) -> used as dp array (store).\\n  where N is size of array.\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    vector<pair<int,bool>> store;\\npublic:\\n    // Computing all possible answers.\\n    pair<int,bool> rec(vector<int> &nums,int target,int i) {\\n        // Base Case\\n        if(i>=n-1) return {0,true}; \\n        if(store[i].first != -1) return store[i];\\n        // Pair to first store the maximum value and second to know wheather it is going till last element or not.\\n        pair<int,bool> res = {0,false};\\n        for(int j=i+1 ; j<n ; ++j) {\\n            if(abs(nums[i]-nums[j]) <= target) {\\n                pair<int,bool> curr = rec(nums,target,j);\\n                curr.first += 1;\\n                if(curr.second) {\\n                    if(curr.first > res.first) {\\n                        res = curr;\\n                    }\\n                }\\n            }\\n        }\\n        // returing the most optimal answer.\\n        return store[i] = res;\\n    }\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        n = nums.size();\\n        // Store works as dp array that stores computed value and use it when it is required.\\n        store.resize(n,{-1,0});\\n        pair<int,bool> res = rec(nums,target,0);\\n        // It answer exists return answer otherwise -1.\\n        return res.second ? res.first : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<pair<int,bool>> store;\\npublic:\\n    // Computing all possible answers.\\n    pair<int,bool> rec(vector<int> &nums,int target,int i) {\\n        // Base Case\\n        if(i>=n-1) return {0,true}; \\n        if(store[i].first != -1) return store[i];\\n        // Pair to first store the maximum value and second to know wheather it is going till last element or not.\\n        pair<int,bool> res = {0,false};\\n        for(int j=i+1 ; j<n ; ++j) {\\n            if(abs(nums[i]-nums[j]) <= target) {\\n                pair<int,bool> curr = rec(nums,target,j);\\n                curr.first += 1;\\n                if(curr.second) {\\n                    if(curr.first > res.first) {\\n                        res = curr;\\n                    }\\n                }\\n            }\\n        }\\n        // returing the most optimal answer.\\n        return store[i] = res;\\n    }\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        n = nums.size();\\n        // Store works as dp array that stores computed value and use it when it is required.\\n        store.resize(n,{-1,0});\\n        pair<int,bool> res = rec(nums,target,0);\\n        // It answer exists return answer otherwise -1.\\n        return res.second ? res.first : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824850,
                "title": "dp-o-n-2",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumJumps(int[] nums, int target) {\\n        int[] dp = nums.Select((_, i) => i == nums.Length - 1 ? 0 : -1).ToArray();        \\n        for (int i = nums.Length - 2; i >= 0; i--)\\n            for (int j = i + 1; j < nums.Length; j++)           \\n                if (dp[j] >= 0 && Math.Abs(nums[i] - nums[j]) <= target)                    \\n                    dp[i] = Math.Max(dp[i], dp[j] + 1);            \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumJumps(int[] nums, int target) {\\n        int[] dp = nums.Select((_, i) => i == nums.Length - 1 ? 0 : -1).ToArray();        \\n        for (int i = nums.Length - 2; i >= 0; i--)\\n            for (int j = i + 1; j < nums.Length; j++)           \\n                if (dp[j] >= 0 && Math.Abs(nums[i] - nums[j]) <= target)                    \\n                    dp[i] = Math.Max(dp[i], dp[j] + 1);            \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824696,
                "title": "golang-brute-force-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(N\\xB2)\\n- Space complexity: O(N)\\n\\n# Code\\n```go\\nfunc maximumJumps(nums []int, target int) int {\\n\\ttimes := make([]int, len(nums))\\n\\tfor f := 0; f < len(nums); f++ {\\n\\t\\tfor t := f+1; t < len(nums); t++ {\\n\\t\\t\\tif f != 0 && times[f] == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif abs(nums[f] - nums[t]) <= target {\\n\\t\\t\\t\\ttimes[t] = max(times[t], times[f]+1)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif times[len(nums)-1] == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn times[len(nums)-1]\\n}\\n\\nfunc abs(x int) int {\\n\\tif x >= 0 {\\n\\t\\treturn x\\n\\t}\\n\\treturn -x\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maximumJumps(nums []int, target int) int {\\n\\ttimes := make([]int, len(nums))\\n\\tfor f := 0; f < len(nums); f++ {\\n\\t\\tfor t := f+1; t < len(nums); t++ {\\n\\t\\t\\tif f != 0 && times[f] == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif abs(nums[f] - nums[t]) <= target {\\n\\t\\t\\t\\ttimes[t] = max(times[t], times[f]+1)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif times[len(nums)-1] == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn times[len(nums)-1]\\n}\\n\\nfunc abs(x int) int {\\n\\tif x >= 0 {\\n\\t\\treturn x\\n\\t}\\n\\treturn -x\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3822548,
                "title": "simple-cpp-solution-easy-to-understand",
                "content": "# Intuition\\nIf we are at any index i then we can have multiple indexes to which we can jump.So we need to explore all possible choices.\\nSo how we explore all choices ?? RECURSION\\n\\n# Approach\\nMain idea of this algorithm is checking every num between nums[0, i - 1] is reachable or not to nums[i] i =0..n, where n = nums.length\\n\\nNext steps:\\n\\ncreate array which stores number of jumps, dp[n], where n = nums.length\\ninitialize dp[0] = 0, because it is initial position, and rest of them fill with -1, because in the beginning they are not reachable\\nthen for every i=1,n(why from 1?, because we should compare at least with one num behind curr number) check every j=0,i - 1 that satisfies next condition:\\n3.1) abs(nums[i] - nums[j]) <= target\\n3.2) nums[j] != -1 (it means that nums[j] reachable from nums[0])\\nthen update dp[i] with max(dp[i], (dp[j] + 1))\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        dp[0]=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1)\\n            continue;\\n            for(int j=i+1;j<n;j++){\\n                int diff=nums[j]-nums[i];\\n                if(-target<=diff && diff<=target){\\n                    dp[j]=max(dp[j],dp[i]+1);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        dp[0]=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1)\\n            continue;\\n            for(int j=i+1;j<n;j++){\\n                int diff=nums[j]-nums[i];\\n                if(-target<=diff && diff<=target){\\n                    dp[j]=max(dp[j],dp[i]+1);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822344,
                "title": "python3-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = [0 for _ in range(len(nums))]\\n        for i in range(1,len(nums)):\\n            dp[i] = max([0 if dp[j]==0 and j != 0 else dp[j]+1 if abs(nums[i] - nums[j]) <= target else 0 for  j in range(i)])\\n        return(-1 if dp[-1]==0 else dp[-1])\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = [0 for _ in range(len(nums))]\\n        for i in range(1,len(nums)):\\n            dp[i] = max([0 if dp[j]==0 and j != 0 else dp[j]+1 if abs(nums[i] - nums[j]) <= target else 0 for  j in range(i)])\\n        return(-1 if dp[-1]==0 else dp[-1])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812458,
                "title": "easy-to-understand-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake an auxillary space of similar size as that of nums array. Index i of this array will store the maximum number of jumps taken to reach to the index. Let this array be dp, if dp[i] = 0 then we cannot reach to this position from any of the previous indices. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n\\n        vector<int> dp(nums.size(),0);\\n        dp[0] = 1;\\n        for(int i=0;i<nums.size();i++){\\n//we cannot jump from a position where we cannot reach from any of the previous positions.\\n            if(dp[i]==0)\\n                continue;\\n            for(int j=i+1; j<nums.size();j++){\\n                if(abs(nums[i]-nums[j]) <= target)\\n                    dp[j] = max(dp[j],dp[i] + 1);\\n            }\\n        }\\n\\n        return dp.back()-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n\\n        vector<int> dp(nums.size(),0);\\n        dp[0] = 1;\\n        for(int i=0;i<nums.size();i++){\\n//we cannot jump from a position where we cannot reach from any of the previous positions.\\n            if(dp[i]==0)\\n                continue;\\n            for(int j=i+1; j<nums.size();j++){\\n                if(abs(nums[i]-nums[j]) <= target)\\n                    dp[j] = max(dp[j],dp[i] + 1);\\n            }\\n        }\\n\\n        return dp.back()-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800157,
                "title": "dp-java-solution-lis-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        dp[0] = 0;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j] - nums[i] <= target && nums[j] - nums[i] >= -target && dp[j] != -1){\\n                    dp[i] = Math.max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        dp[0] = 0;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j] - nums[i] <= target && nums[j] - nums[i] >= -target && dp[j] != -1){\\n                    dp[i] = Math.max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798548,
                "title": "golang-simple-solution-with-dynamic-programming",
                "content": "\\n\\n# Approach\\nLet $dp[i]$ is maximal number of jumps to receive $i$ point and $dp[i]=-1$ if we can not receive point.\\nThen $dp[i]$ is maximal value of $dp[j]+1$ for $j<i$ and $abs(nums[i]-nums[j])<=target$ and $dp[j]>=0$\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc maximumJumps(nums []int, target int) int {\\n    n:=len(nums)\\n    dp:=make([]int,n)\\n    for i:=1;i<n;i++{\\n        dp[i]=-1\\n        for j:=0;j<i;j++{\\n            if abs(nums[i]-nums[j])<=target && dp[j]>=0{\\n                dp[i]=max(dp[i],dp[j]+1)\\n            }\\n        }\\n    }\\n    return dp[n-1]\\n}\\n\\nfunc max(a, b int)int {\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc abs(a int)int {\\n    if a<0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc maximumJumps(nums []int, target int) int {\\n    n:=len(nums)\\n    dp:=make([]int,n)\\n    for i:=1;i<n;i++{\\n        dp[i]=-1\\n        for j:=0;j<i;j++{\\n            if abs(nums[i]-nums[j])<=target && dp[j]>=0{\\n                dp[i]=max(dp[i],dp[j]+1)\\n            }\\n        }\\n    }\\n    return dp[n-1]\\n}\\n\\nfunc max(a, b int)int {\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc abs(a int)int {\\n    if a<0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797812,
                "title": "python-video-walkthrough-time-o-n-2-space-o-n-three-lines",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/kpV27GuDEyk)\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        D = [0]  + [-1] * (len(nums) - 1) \\n        for j in range(1, len(nums)):  D[j] = 1 + max([D[i] for i in range(j) if abs(nums[j] - nums[i]) <= target and D[i] >= 0],default=-2)\\n        return D[len(nums) - 1] \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        D = [0]  + [-1] * (len(nums) - 1) \\n        for j in range(1, len(nums)):  D[j] = 1 + max([D[i] for i in range(j) if abs(nums[j] - nums[i]) <= target and D[i] >= 0],default=-2)\\n        return D[len(nums) - 1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796724,
                "title": "2770-maximum-number-of-jumps-to-reach-the-last-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int maximumJumps(vector<int>& nums, int target) {\\n    const int n = nums.size();\\n    // dp[i] := max # of jumps to reach i from 0\\n    vector<int> dp(n, -1);\\n    dp[0] = 0;\\n\\n    for (int j = 1; j < n; ++j)\\n      for (int i = 0; i < j; ++i)\\n        if (dp[i] != -1 && abs(nums[j] - nums[i]) <= target)\\n          dp[j] = max(dp[j], dp[i] + 1);\\n\\n    return dp[n - 1];\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int maximumJumps(vector<int>& nums, int target) {\\n    const int n = nums.size();\\n    // dp[i] := max # of jumps to reach i from 0\\n    vector<int> dp(n, -1);\\n    dp[0] = 0;\\n\\n    for (int j = 1; j < n; ++j)\\n      for (int i = 0; i < j; ++i)\\n        if (dp[i] != -1 && abs(nums[j] - nums[i]) <= target)\\n          dp[j] = max(dp[j], dp[i] + 1);\\n\\n    return dp[n - 1];\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793467,
                "title": "python-easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = {len(nums) - 1: 0}\\n        for i in range(len(nums) - 2, -1, -1):\\n            dp_i = -1\\n            for j in dp:\\n                if nums[j] - nums[i] in range(-target, target + 1):\\n                    dp_i = max(dp_i, dp[j] + 1)\\n            if dp_i != -1:\\n                dp[i] = dp_i\\n        return dp.get(0, -1)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = {len(nums) - 1: 0}\\n        for i in range(len(nums) - 2, -1, -1):\\n            dp_i = -1\\n            for j in dp:\\n                if nums[j] - nums[i] in range(-target, target + 1):\\n                    dp_i = max(dp_i, dp[j] + 1)\\n            if dp_i != -1:\\n                dp[i] = dp_i\\n        return dp.get(0, -1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792915,
                "title": "easy-dp-solution-c",
                "content": "# Intuition\\ndp[i] represents maximum number of steps it takes to reach poisition i,\\npossible[i] represents if it is possible to reach index i\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[0] = 0;\\n        vector<bool> possible(n+1, false);\\n        possible[0] = true;\\n        for(int i=0;i<n;i++){\\n            if(!possible[i]) continue;\\n            for(int j = i+1;j<n;j++){\\n                int diff = nums[j]-nums[i];\\n                if(diff >= -target && diff<= target){\\n                    dp[j] = max(dp[j], dp[i]+1);\\n                    possible[j] = true;\\n                }\\n            }\\n        }\\n        return possible[n-1] ? dp[n-1] : -1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[0] = 0;\\n        vector<bool> possible(n+1, false);\\n        possible[0] = true;\\n        for(int i=0;i<n;i++){\\n            if(!possible[i]) continue;\\n            for(int j = i+1;j<n;j++){\\n                int diff = nums[j]-nums[i];\\n                if(diff >= -target && diff<= target){\\n                    dp[j] = max(dp[j], dp[i]+1);\\n                    possible[j] = true;\\n                }\\n            }\\n        }\\n        return possible[n-1] ? dp[n-1] : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789676,
                "title": "pick-not-pick-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,int prev,vector<int> &nums,int target,vector<vector<int>> &dp)\\n    {\\n        if(ind == nums.size()-1)\\n        {\\n            if(abs(nums[ind]-nums[prev])<=target) return 1;\\n            else{\\n                return -1e9;\\n            }\\n        }\\n        if(dp[ind][prev]!=-1) return dp[ind][prev];\\n        int pick = INT_MIN;\\n        if(ind!=prev&&((nums[ind]-nums[prev])<=target)&&((nums[ind]-nums[prev])>=-(target)))\\n        {\\n            pick = 1+solve(ind+1,ind,nums,target,dp);\\n        }\\n        int not_pick = solve(ind+1,prev,nums,target,dp);\\n        return dp[ind][prev] = max(pick,not_pick);\\n}\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int k = solve(0,0,nums,target,dp);\\n        if(k>0) return k;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int ind,int prev,vector<int> &nums,int target,vector<vector<int>> &dp)\\n    {\\n        if(ind == nums.size()-1)\\n        {\\n            if(abs(nums[ind]-nums[prev])<=target) return 1;\\n            else{\\n                return -1e9;\\n            }\\n        }\\n        if(dp[ind][prev]!=-1) return dp[ind][prev];\\n        int pick = INT_MIN;\\n        if(ind!=prev&&((nums[ind]-nums[prev])<=target)&&((nums[ind]-nums[prev])>=-(target)))\\n        {\\n            pick = 1+solve(ind+1,ind,nums,target,dp);\\n        }\\n        int not_pick = solve(ind+1,prev,nums,target,dp);\\n        return dp[ind][prev] = max(pick,not_pick);\\n}\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int k = solve(0,0,nums,target,dp);\\n        if(k>0) return k;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788625,
                "title": "python-dynamic-programming-tabulation",
                "content": "# Intuition\\nThe given code uses dynamic programming to solve the problem. It maintains an array dp where dp[i] represents the maximum number of jumps to reach index i from the starting index (0).\\n\\n# Approach\\n1. Initialize an array dp of size n (length of the nums array) and  set all elements to 0.\\n2. Iterate from index 1 to n-1 (representing the position we want to   reach).\\n3. For each index i, iterate through all indices j from 0 to i-1.\\n4. Check if the difference between nums[i] and nums[j] is within the range of -target to target. If it is, then we can jump from index j to index i.\\n5. If the value of dp[j] is 0 (meaning index j is not reachable), and j is not the starting index (0), we skip this iteration to avoid unnecessary computations.\\n6. Otherwise, we update dp[i] to be the maximum value between its current value and dp[j] + 1, indicating that we can reach index i from index j with an additional jump.\\n7. Finally, we return dp[n-1] as the result. If dp[n-1] is still 0, it means we couldn\\'t reach index n-1, so we return -1. Otherwise, it contains the maximum number of jumps required to reach index n-1.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [0 for _ in range(n)]\\n        for i in range(1,n):\\n            for j in range(i):\\n                if abs(nums[i]-nums[j]) <= target:\\n                    if dp[j] == 0 and j != 0:\\n                        continue\\n                    if dp[j]+1>dp[i]:\\n                        dp[i] = dp[j]+1\\n        return -1 if dp[n-1] == 0 else dp[n-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [0 for _ in range(n)]\\n        for i in range(1,n):\\n            for j in range(i):\\n                if abs(nums[i]-nums[j]) <= target:\\n                    if dp[j] == 0 and j != 0:\\n                        continue\\n                    if dp[j]+1>dp[i]:\\n                        dp[i] = dp[j]+1\\n        return -1 if dp[n-1] == 0 else dp[n-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788578,
                "title": "java-bottom-up-dp-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        dp[n - 1] = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (dp[j] != -1 && Math.abs(nums[j] - nums[i]) <= target) {\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        dp[n - 1] = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (dp[j] != -1 && Math.abs(nums[j] - nums[i]) <= target) {\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786832,
                "title": "dp-memoisation-time-compleity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // recursive function can have time complexity of O(N^N) when array is strictly increasing [1,2,3,4..]\\n    // After memoisation time complexity is O(N) since each element is visied once\\n    int dp[1001];\\n    int helper(vector<int>&nums,int i,int target){\\n        if(i>=nums.size()-1)return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans = -5000 ;\\n        for(int j=i+1;j<nums.size();j++){\\n            int diff = nums[j]-nums[i];\\n            if(diff>=-target&&diff<=target){\\n                // cout<<j<<\" \" ;\\n                int cost = 1 + helper(nums,j,target);\\n                ans = max(ans,cost);\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n    int helperTab(vector<int>&nums,int target){\\n        int n = nums.size();\\n        vector<int>dp(n+1,0);\\n\\n        for(int i=n-1;i>=0;i--){\\n            int ans = -5000 ;\\n            for(int j=i+1;j<nums.size();j++){\\n                int diff = nums[j]-nums[i];\\n                if(diff>=-target&&diff<=target){\\n                    int cost = 1 +dp[j];\\n                    ans = max(ans,cost);\\n                }\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[0];\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans =  helper(nums,0,target);\\n        return ans<0?-1:ans;\\n        // return helperTab(nums,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // recursive function can have time complexity of O(N^N) when array is strictly increasing [1,2,3,4..]\\n    // After memoisation time complexity is O(N) since each element is visied once\\n    int dp[1001];\\n    int helper(vector<int>&nums,int i,int target){\\n        if(i>=nums.size()-1)return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans = -5000 ;\\n        for(int j=i+1;j<nums.size();j++){\\n            int diff = nums[j]-nums[i];\\n            if(diff>=-target&&diff<=target){\\n                // cout<<j<<\" \" ;\\n                int cost = 1 + helper(nums,j,target);\\n                ans = max(ans,cost);\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n    int helperTab(vector<int>&nums,int target){\\n        int n = nums.size();\\n        vector<int>dp(n+1,0);\\n\\n        for(int i=n-1;i>=0;i--){\\n            int ans = -5000 ;\\n            for(int j=i+1;j<nums.size();j++){\\n                int diff = nums[j]-nums[i];\\n                if(diff>=-target&&diff<=target){\\n                    int cost = 1 +dp[j];\\n                    ans = max(ans,cost);\\n                }\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[0];\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans =  helper(nums,0,target);\\n        return ans<0?-1:ans;\\n        // return helperTab(nums,target);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3785451,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = len(nums)*[-1]\\n\\n        for i in range(len(nums)-1,-1,-1):\\n            if i==len(nums)-1:\\n                dp[i]=0\\n            else:\\n                for j in range(i+1, len(nums)):\\n                    if dp[j]!=-1 and abs(nums[j]-nums[i])<=target:\\n                        dp[i] = max(dp[i], dp[j]+1)\\n        \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = len(nums)*[-1]\\n\\n        for i in range(len(nums)-1,-1,-1):\\n            if i==len(nums)-1:\\n                dp[i]=0\\n            else:\\n                for j in range(i+1, len(nums)):\\n                    if dp[j]!=-1 and abs(nums[j]-nums[i])<=target:\\n                        dp[i] = max(dp[i], dp[j]+1)\\n        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785356,
                "title": "c-dp-solution",
                "content": "# Code\\n```\\nint maximumJumps(int* nums, int numsSize, int target){\\n    int* dp = (int*)malloc(sizeof(int) * numsSize);\\n    for(int i = 0;i < numsSize;i++){\\n        dp[i] = 0;\\n    }\\n    dp[0] = 1;\\n    int max;\\n    for(int i = 1;i < numsSize;i++){\\n        max = 0;\\n        for(int j = 0;j < i;j++){\\n            if(abs(nums[j]-nums[i]) <= target && dp[j] > max){\\n                max = dp[j];\\n            }\\n        }\\n        if(max != 0){\\n            dp[i] = max + 1;\\n        }\\n        else{\\n            dp[i] = 0;\\n        }\\n    }\\n    return dp[numsSize-1]-1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximumJumps(int* nums, int numsSize, int target){\\n    int* dp = (int*)malloc(sizeof(int) * numsSize);\\n    for(int i = 0;i < numsSize;i++){\\n        dp[i] = 0;\\n    }\\n    dp[0] = 1;\\n    int max;\\n    for(int i = 1;i < numsSize;i++){\\n        max = 0;\\n        for(int j = 0;j < i;j++){\\n            if(abs(nums[j]-nums[i]) <= target && dp[j] > max){\\n                max = dp[j];\\n            }\\n        }\\n        if(max != 0){\\n            dp[i] = max + 1;\\n        }\\n        else{\\n            dp[i] = 0;\\n        }\\n    }\\n    return dp[numsSize-1]-1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780100,
                "title": "dp-tree-map-beat-99-time-complexity-with-64-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTypical DP solution uses a std::vector to store the max steps reached at each index which requires time complexity O(n^2). \\n\\nHere, we could also utilize the rule: **At nums[i], it could only get reached from nums[j] within [nums[i]-taget, nums[i]+target]** where j<i.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe could use a tree map to store <num, steps> in ascending order by num, we don\\'t need to worry about key collision since we should always prefer duplicate key later in nums given the max steps to reach it would also be greater.\\n\\nAt each step, we just to need to traverse the previous nums within the range [`num`-`target`, `num`+`target`] and pick the max steps among them.\\n\\n# Complexity\\n- Time complexity:\\nWith amortization, the time complexity would be O(nlogn) given `target` and `num` are in the same range. In **worst case, time complexity could be O(n^2)** if say the `target` is much larger than `num` because we still need to traverse the whole map at each step.\\n\\n- Space complexity:\\nTechnically speaking, this approach has spatial advantage because we  **avoid redundant keys**. However, given std::map requires larger internal overhead than std::vector, so space complexity wise, they both have pros and cons.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        // An ordered map between num and the max steps to reach the num.\\n        // Use int64_t as Key type because nums[i] +/- target might \\n        // overflow. \\n        map<int64_t, int> dp;\\n        dp[nums[0]] = 0;\\n\\n        for (int i=1; i<nums.size(); ++i){\\n            const int64_t lower_bound = static_cast<int64_t>(nums[i]) - \\n                target;\\n            const int64_t upper_bound = static_cast<int64_t>(nums[i]) + \\n                target;\\n\\n            int max_steps = -1;\\n            auto it = dp.lower_bound(lower_bound);\\n            while(it != dp.end() && it->first <= upper_bound){\\n                max_steps = max(max_steps, it++->second + 1);\\n            }\\n            if (max_steps != -1){\\n                dp[nums[i]] = max_steps;\\n            }\\n        }\\n\\n        const int dest = nums.back();\\n        return dp.count(dest)?dp[dest]:-1;\\n    }\\n};\\n```\\n\\n# Upvotes/Comments are Welcomed!!!\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        // An ordered map between num and the max steps to reach the num.\\n        // Use int64_t as Key type because nums[i] +/- target might \\n        // overflow. \\n        map<int64_t, int> dp;\\n        dp[nums[0]] = 0;\\n\\n        for (int i=1; i<nums.size(); ++i){\\n            const int64_t lower_bound = static_cast<int64_t>(nums[i]) - \\n                target;\\n            const int64_t upper_bound = static_cast<int64_t>(nums[i]) + \\n                target;\\n\\n            int max_steps = -1;\\n            auto it = dp.lower_bound(lower_bound);\\n            while(it != dp.end() && it->first <= upper_bound){\\n                max_steps = max(max_steps, it++->second + 1);\\n            }\\n            if (max_steps != -1){\\n                dp[nums[i]] = max_steps;\\n            }\\n        }\\n\\n        const int dest = nums.back();\\n        return dp.count(dest)?dp[dest]:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778555,
                "title": "java-memo-dp-dfs-13ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemoization top-down DP (or DFS) can work well for this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBesides the memo cache, the iterations to DFS search following indices can be break down early if optimal result already reached.\\n\\nWhen search at index `i`, if the result steps is already the max possible `length - 1 - i`, then there is no need to search the next `i + 1`, `i + 2`...\\n\\nE.g. Assuming the array contains only 1: `[1,1,1,1,1...1,1]`, it will search index `0 -> 1 -> 2 -> ... -> n-1` with O(n) time, since each recursion call returns optimal result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$ worst, $$O(n)$$ best\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ for memo cache\\n\\n# Runtime\\n13ms\\n\\n# Code\\n```\\nclass Solution {\\n\\n    Integer[] memo;\\n    int[] nums;\\n    int target, length;\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        this.length = nums.length;\\n        this.nums = nums;\\n        this.target = target;\\n\\n        memo = new Integer[length];\\n        memo[length - 1] = 0;\\n\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int idx) {\\n        if (memo[idx] != null) {\\n            return memo[idx];\\n        }\\n\\n        int result = -1, dis;\\n\\n        for (int i = idx + 1; i < length; i++) {\\n            dis = nums[i] - nums[idx];\\n\\n            if (-target <= dis && dis <= target) {\\n                result = Math.max(result, dfs(i));\\n\\n                // break early if optimal result reached\\n                if (result >= length - 2 - i) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return memo[idx] = result == -1 ? -1 : result + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    Integer[] memo;\\n    int[] nums;\\n    int target, length;\\n\\n    public int maximumJumps(int[] nums, int target) {\\n        this.length = nums.length;\\n        this.nums = nums;\\n        this.target = target;\\n\\n        memo = new Integer[length];\\n        memo[length - 1] = 0;\\n\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int idx) {\\n        if (memo[idx] != null) {\\n            return memo[idx];\\n        }\\n\\n        int result = -1, dis;\\n\\n        for (int i = idx + 1; i < length; i++) {\\n            dis = nums[i] - nums[idx];\\n\\n            if (-target <= dis && dis <= target) {\\n                result = Math.max(result, dfs(i));\\n\\n                // break early if optimal result reached\\n                if (result >= length - 2 - i) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return memo[idx] = result == -1 ? -1 : result + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777150,
                "title": "1d-dp-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n;\\nvector<int>memo;\\nint dp(int cur,int tar,vector<int>&nums){\\n    if(cur==n-1) return 0;\\n    if(memo[cur]!=-1) return memo[cur];;\\n    int ans=INT_MIN;\\n    for(int j=cur+1;j<n;j++){\\n         if(abs(nums[j]-nums[cur])<=tar) ans=max(ans,1+dp(j,tar,nums));\\n    }\\n    return memo[cur]=ans;\\n}\\n    int maximumJumps(vector<int>& nums, int target) {\\n        this->n=nums.size();\\n        memo.resize(n+1,-1);\\n        int p=dp(0,target,nums);\\n        return p>0?p:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n;\\nvector<int>memo;\\nint dp(int cur,int tar,vector<int>&nums){\\n    if(cur==n-1) return 0;\\n    if(memo[cur]!=-1) return memo[cur];;\\n    int ans=INT_MIN;\\n    for(int j=cur+1;j<n;j++){\\n         if(abs(nums[j]-nums[cur])<=tar) ans=max(ans,1+dp(j,tar,nums));\\n    }\\n    return memo[cur]=ans;\\n}\\n    int maximumJumps(vector<int>& nums, int target) {\\n        this->n=nums.size();\\n        memo.resize(n+1,-1);\\n        int p=dp(0,target,nums);\\n        return p>0?p:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776093,
                "title": "simple-dp-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> vec(n, -1);\\n        vec[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=i-1; j>=0; j--){\\n                if(vec[j] != -1 && abs(nums[i]-nums[j]) <= target)\\n                    vec[i] = max(vec[i], vec[j]+1);\\n            }\\n        }\\n        return vec[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> vec(n, -1);\\n        vec[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=i-1; j>=0; j--){\\n                if(vec[j] != -1 && abs(nums[i]-nums[j]) <= target)\\n                    vec[i] = max(vec[i], vec[j]+1);\\n            }\\n        }\\n        return vec[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772199,
                "title": "simple-c-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums,int &target,int j,vector<int> &dp){\\n        if(j==nums.size()-1)\\n            return 0;\\n        if(dp[j]!=-1)\\n            return dp[j];\\n        int res = INT_MIN;\\n        for(int i=j+1;i<nums.size();i++){\\n            if(abs(nums[i]-nums[j])<=target)\\n                res = max(res,1+solve(nums,target,i,dp));\\n        }\\n        return dp[j] = res;\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),-1);\\n        int ans = solve(nums,target,0,dp);\\n        if(ans <= 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums,int &target,int j,vector<int> &dp){\\n        if(j==nums.size()-1)\\n            return 0;\\n        if(dp[j]!=-1)\\n            return dp[j];\\n        int res = INT_MIN;\\n        for(int i=j+1;i<nums.size();i++){\\n            if(abs(nums[i]-nums[j])<=target)\\n                res = max(res,1+solve(nums,target,i,dp));\\n        }\\n        return dp[j] = res;\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),-1);\\n        int ans = solve(nums,target,0,dp);\\n        if(ans <= 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770521,
                "title": "tabulation-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),0);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]-nums[j]<=target and nums[i]-nums[j]>=-target){\\n                    if(j==0 or dp[j]!=0)dp[i]=max(dp[i],1+dp[j]);\\n                    \\n                }\\n            }\\n        }\\n        if(dp[nums.size()-1]==0){\\n            return -1;\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),0);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]-nums[j]<=target and nums[i]-nums[j]>=-target){\\n                    if(j==0 or dp[j]!=0)dp[i]=max(dp[i],1+dp[j]);\\n                    \\n                }\\n            }\\n        }\\n        if(dp[nums.size()-1]==0){\\n            return -1;\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769714,
                "title": "c-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) \\n    {\\n        vector <int> dp(nums.size(),-1);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                continue;\\n            }\\n            for(int j=i+1; j<nums.size();j++)\\n            {\\n                int diff = nums[j]-nums[i];\\n                if(diff>=-target&& diff<=target)\\n                {\\n                    dp[j] = max(dp[j],1+dp[i]);\\n                }\\n            }\\n        }       \\n        \\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) \\n    {\\n        vector <int> dp(nums.size(),-1);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                continue;\\n            }\\n            for(int j=i+1; j<nums.size();j++)\\n            {\\n                int diff = nums[j]-nums[i];\\n                if(diff>=-target&& diff<=target)\\n                {\\n                    dp[j] = max(dp[j],1+dp[i]);\\n                }\\n            }\\n        }       \\n        \\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769625,
                "title": "top-down-bottom-up-dp-solutions-in-python",
                "content": "# Code\\n```\\n# Top-down DP version. O(n^2) time & space because of adj_list data structure\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        adj_list = collections.defaultdict(list) # idx: [indices]\\n        \\n        # populate adj_list in O(n^2)\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[j] - nums[i]) <= target: adj_list[i].append(j)\\n        \\n        # dp(i) is max num jumps from i -> n - 1\\n        @cache\\n        def dp(i):\\n            if i == len(nums) - 1: return 0\\n            max_jumps = -1\\n            for j in adj_list[i]:\\n                max_jumps = max(max_jumps, 1 + dp(j))\\n            return max_jumps if max_jumps else -1\\n        return dp(0)\\n\\n# Bottom-up DP. O(n^2) time, but O(n) space beacuse I don\\'t have the O(n^2) call stack for top-down, and I avoid using the adj_list, which is O(n^2) data structure. I use a for loop instead.\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = [-1] * (len(nums) - 1) + [0]\\n        for i in range(len(nums) - 2, -1, -1):\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[j] - nums[i]) > target: continue\\n                if dp[j] == -1: continue\\n                dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[0]\\n```\\nIf you found useful, upvotes always appreciated :)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Top-down DP version. O(n^2) time & space because of adj_list data structure\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        adj_list = collections.defaultdict(list) # idx: [indices]\\n        \\n        # populate adj_list in O(n^2)\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[j] - nums[i]) <= target: adj_list[i].append(j)\\n        \\n        # dp(i) is max num jumps from i -> n - 1\\n        @cache\\n        def dp(i):\\n            if i == len(nums) - 1: return 0\\n            max_jumps = -1\\n            for j in adj_list[i]:\\n                max_jumps = max(max_jumps, 1 + dp(j))\\n            return max_jumps if max_jumps else -1\\n        return dp(0)\\n\\n# Bottom-up DP. O(n^2) time, but O(n) space beacuse I don\\'t have the O(n^2) call stack for top-down, and I avoid using the adj_list, which is O(n^2) data structure. I use a for loop instead.\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        dp = [-1] * (len(nums) - 1) + [0]\\n        for i in range(len(nums) - 2, -1, -1):\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[j] - nums[i]) > target: continue\\n                if dp[j] == -1: continue\\n                dp[i] = max(dp[i], 1 + dp[j])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768939,
                "title": "easy-cpp-solution-based-on-dp",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(abs(nums[i]-nums[j])<=target)\\n                {\\n                    if(dp[j]==0 && j!=0)\\n                    continue;\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        if(dp[nums.size()-1]==0)\\n        return -1;\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(abs(nums[i]-nums[j])<=target)\\n                {\\n                    if(dp[j]==0 && j!=0)\\n                    continue;\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        if(dp[nums.size()-1]==0)\\n        return -1;\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765040,
                "title": "java-beats-99-dp-version",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int total = 0;\\n        int[] dp = new int[nums.length];\\n\\n        dp[0] = 0;\\n        for(int i = 1; i<nums.length; i++){\\n            int currentMax = -1;\\n            for(int j = 0; j<i; j++){\\n                if(-target<=nums[i]-nums[j] && nums[i]-nums[j]<=target && dp[j]!=-1){\\n                    currentMax = Math.max(currentMax, dp[j]+1);\\n                }\\n            }\\n            dp[i]=currentMax;\\n        }\\n        \\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int total = 0;\\n        int[] dp = new int[nums.length];\\n\\n        dp[0] = 0;\\n        for(int i = 1; i<nums.length; i++){\\n            int currentMax = -1;\\n            for(int j = 0; j<i; j++){\\n                if(-target<=nums[i]-nums[j] && nums[i]-nums[j]<=target && dp[j]!=-1){\\n                    currentMax = Math.max(currentMax, dp[j]+1);\\n                }\\n            }\\n            dp[i]=currentMax;\\n        }\\n        \\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765039,
                "title": "python-dp-bottom-up-short-clean",
                "content": "# Intuition\\nDP\\n\\n# Approach\\nDP bottom-up\\n\\n# Complexity\\n\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n\\n        dp[0] = 0\\n        for i in range(1, n):\\n            for j in range(i):\\n                if dp[j] >= 0 and abs(nums[i] - nums[j]) <= target:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n\\n        dp[0] = 0\\n        for i in range(1, n):\\n            for j in range(i):\\n                if dp[j] >= 0 and abs(nums[i] - nums[j]) <= target:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764505,
                "title": "can-anyone-tell-me-why-this-approach-does-not-work-thanks",
                "content": "public int maximumJumps(int[] nums, int target) {\\n        \\n        int n=nums.length;\\n        \\n        int result=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            result=Math.max(result,1+solve(i,nums,target));\\n            \\n        }\\n        return result;\\n    }\\n    \\n    private int solve(int idx,int[] nums,int target){\\n        \\n        if(idx==nums.length-1){\\n            return 0;\\n        }\\n        \\n        int n=nums.length;\\n        int result=-1;\\n        \\n        for(int i=idx+1;i<n;i++){\\n            if(Math.abs(nums[i]-nums[idx])<=target){\\n                result=Math.max(result,1+solve(i,nums,target));\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "public int maximumJumps(int[] nums, int target) {\\n        \\n        int n=nums.length;\\n        \\n        int result=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            result=Math.max(result,1+solve(i,nums,target));\\n            \\n        }\\n        return result;\\n    }\\n    \\n    private int solve(int idx,int[] nums,int target){\\n        \\n        if(idx==nums.length-1){\\n            return 0;\\n        }\\n        \\n        int n=nums.length;\\n        int result=-1;\\n        \\n        for(int i=idx+1;i<n;i++){\\n            if(Math.abs(nums[i]-nums[idx])<=target){\\n                result=Math.max(result,1+solve(i,nums,target));\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3763011,
                "title": "max-jumps-solution",
                "content": "# Approach 1 - Recursion\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved with recursion. If the first jump is to `j`, the max number of jumps to the end of the array is `1 + maximumJumps(nums[j:n-1], target)` or `-1` if jumping to the end is not possible. To avoid creating additional arrays in memory, this solution will use a recursive helper function `helper(nums, i, target)` that returns the max number of jumps from positions `i` to `n-1` in array `nums`. `maximumJumps` will simply return `helper(nums, 0, target)`.\\n\\nThe base case is when the start position is the final element. The start position is already at the destination and no jumps can be made, so have `helper` return `0`.\\n\\nFor the recursion step, have `j` iterate over `i+1 <= j < n`. If `abs(nums[j] - nums[0]) <= target`, a jump can be made from `i` to `j`. Compute `jumps = helper(nums, j, target)`. If `jumps != -1`, the max number of jumps from `i` to `j` to `n-1` is `jumps + 1`. Keep track of the max number of jumps amongst all values of `j` and have `helper` output it.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maximumJumps(const vector<int>& nums, const int& target) {\\n        return helper(nums, 0, target);\\n    }\\n\\n    int helper(const vector<int>& nums, const int& i, const int& target) {\\n        if (i == nums.size()-1) {\\n            return 0;\\n        }\\n\\n        int maxJumps = -1;\\n\\n        for (int j = i+1; j < nums.size(); j++) {\\n            if (abs(nums[j] - nums[i]) > target) {\\n                continue;\\n            }\\n\\n            const int jumps = helper(nums, j, target);\\n\\n            if (jumps != -1) {\\n                maxJumps = max(maxJumps, jumps + 1);\\n            }\\n        }\\n\\n        return maxJumps;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        return helper(nums, 0, target);\\n    }\\n\\n    private int helper(int[] nums, int i, int target) {\\n        if (i == nums.length-1) {\\n            return 0;\\n        }\\n\\n        int maxJumps = -1;\\n\\n        for (int j = i+1; j < nums.length; j++) {\\n            if (Math.abs(nums[j] - nums[i]) > target) {\\n                continue;\\n            }\\n\\n            final int jumps = helper(nums, j, target);\\n\\n            if (jumps != -1) {\\n                maxJumps = Math.max(maxJumps, jumps + 1);\\n            }\\n        }\\n\\n        return maxJumps;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        return self.helper(nums, 0, target)\\n\\n    def helper(self, nums: List[int], i: int, target: int) -> int:\\n        if i == len(nums) - 1:\\n            return 0\\n\\n        maxJumps = -1\\n\\n        for j in range(i+1, len(nums)):\\n            if abs(nums[j] - nums[i]) > target:\\n                continue\\n\\n            jumps = self.helper(nums, j, target)\\n\\n            if jumps != -1:\\n                maxJumps = max(maxJumps, jumps + 1)\\n\\n        return maxJumps\\n```\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$\\n    - It takes $$O(1)$$ time to check if it\\'s possible to jump from index `i` to `j`\\n    - $$T(n)=1+T(n-1)+1+T(n-2)+\\\\ldots+1+T(1)$$\\n      $$\\\\qquad= n-1 + T(n-1) + T(n-2)+\\\\ldots+T(1)$$ \\n      $$T(n-1) = n-2 + T(n-2) + T(n-3) +\\\\dots+T(1)$$\\n      $$T(n)-T(n-1)=1 + T(n-1)$$\\n      $$T(n) = 1 + 2T(n-1)$$\\n    - Solving the recurrence equation yields $$T(n) = O(2^{n-1})-1=O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n    - The recursion uses $$O(n)$$ call stack space at most\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 2 - Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet `F(nums) = maximumJumps(nums, target)`. Let\\'s examing the function calls in the recursive method when `nums` has four elements:\\n![Max Jumps.png](https://assets.leetcode.com/users/images/8936160e-35c1-4fcf-950a-c0b577193ed0_1689318078.2965846.png)\\nThere are quite a few repeated calls. `F(nums[3:3])` in particular is called four times. The procedure can be improved considerably by storing the results of the subproblems in an array. Let `dp` be an array for which `dp[i] = maximumJumps(nums[i:n], target)`. Initialize `dp[n-1] = 0` and the rest of the elements to `-1`. \\n\\n`dp` can be updated from back to front. Iterate over `i` in range `n-1 > i >= 0` and `j` in range `i+1 <= j < n` for each `i`. If `abs(nums[i] - nums[j]) <= threshold` and `dp[j] != -1`, it is possible to make jumps from `i` to `n-1` with `i` to `j` as the first jump. In that case, the total number jumps is `dp[j] + 1` so update `dp` with `dp[i] = max(dp[i], dp[j] + 1)`.\\n\\nOnce `dp` has finished processing every pair of `i` and `j`, output the answer as `dp[0]`!\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maximumJumps(const vector<int>& nums, const int& target) {\\n        const int n = nums.size();\\n        vector<int> dp (n, -1);\\n        dp[n-1] = 0;\\n        \\n        for (int i = n; i >= 0; i--) {\\n            for (int j = i+1; j < n; j++) {\\n                if (abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n                    \\n        return dp[0];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        final int n = nums.length;\\n        final int[] dp = new int[n];\\n        dp[n-1] = 0;\\n        \\n        for (int i = n-2; i >= 0; i--) {\\n            dp[i] = -1;\\n\\n            for (int j = i+1; j < n; j++) {\\n                if (Math.abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n                    \\n        return dp[0];\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1]*n\\n        dp[-1] = 0\\n        \\n        for i in range(n, -1, -1):\\n            for j in range(i+1, n):\\n                if abs(nums[j] - nums[i]) <= target and dp[j] != -1:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n                    \\n        return dp[0]\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n    - It takes $$O(n)$$ time to create the dynamic programming array \\n    - The loops covers $$O(n^2)$$ pairs of `i` and `j`\\n    - Total time is $$O(n)+O(n^2)=O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n    - The dynamic programming array stores a total of $$n$$ elements \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maximumJumps(const vector<int>& nums, const int& target) {\\n        return helper(nums, 0, target);\\n    }\\n\\n    int helper(const vector<int>& nums, const int& i, const int& target) {\\n        if (i == nums.size()-1) {\\n            return 0;\\n        }\\n\\n        int maxJumps = -1;\\n\\n        for (int j = i+1; j < nums.size(); j++) {\\n            if (abs(nums[j] - nums[i]) > target) {\\n                continue;\\n            }\\n\\n            const int jumps = helper(nums, j, target);\\n\\n            if (jumps != -1) {\\n                maxJumps = max(maxJumps, jumps + 1);\\n            }\\n        }\\n\\n        return maxJumps;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        return helper(nums, 0, target);\\n    }\\n\\n    private int helper(int[] nums, int i, int target) {\\n        if (i == nums.length-1) {\\n            return 0;\\n        }\\n\\n        int maxJumps = -1;\\n\\n        for (int j = i+1; j < nums.length; j++) {\\n            if (Math.abs(nums[j] - nums[i]) > target) {\\n                continue;\\n            }\\n\\n            final int jumps = helper(nums, j, target);\\n\\n            if (jumps != -1) {\\n                maxJumps = Math.max(maxJumps, jumps + 1);\\n            }\\n        }\\n\\n        return maxJumps;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        return self.helper(nums, 0, target)\\n\\n    def helper(self, nums: List[int], i: int, target: int) -> int:\\n        if i == len(nums) - 1:\\n            return 0\\n\\n        maxJumps = -1\\n\\n        for j in range(i+1, len(nums)):\\n            if abs(nums[j] - nums[i]) > target:\\n                continue\\n\\n            jumps = self.helper(nums, j, target)\\n\\n            if jumps != -1:\\n                maxJumps = max(maxJumps, jumps + 1)\\n\\n        return maxJumps\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maximumJumps(const vector<int>& nums, const int& target) {\\n        const int n = nums.size();\\n        vector<int> dp (n, -1);\\n        dp[n-1] = 0;\\n        \\n        for (int i = n; i >= 0; i--) {\\n            for (int j = i+1; j < n; j++) {\\n                if (abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n                    \\n        return dp[0];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        final int n = nums.length;\\n        final int[] dp = new int[n];\\n        dp[n-1] = 0;\\n        \\n        for (int i = n-2; i >= 0; i--) {\\n            dp[i] = -1;\\n\\n            for (int j = i+1; j < n; j++) {\\n                if (Math.abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n                    \\n        return dp[0];\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [-1]*n\\n        dp[-1] = 0\\n        \\n        for i in range(n, -1, -1):\\n            for j in range(i+1, n):\\n                if abs(nums[j] - nums[i]) <= target and dp[j] != -1:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n                    \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762672,
                "title": "c-memorization-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums, int target, int ind, int n, vector<int>&dp)\\n    {\\n        if(ind==n-1)\\n            return 0;\\n        if(ind > n-1)\\n            return -1e9;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int cnt = INT_MIN;\\n        for(int i = ind+1; i<n;i++)\\n        {\\n            int temp = nums[i]-nums[ind];\\n            if(temp > target || temp <(0-target))\\n                continue;\\n            cnt = max(cnt, 1+solve(nums, target, i, n, dp));\\n        }\\n        return dp[ind] = cnt;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n+5, -1);\\n        int ans = solve(nums, target, 0, n, dp);\\n        if(ans <= -1e9)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums, int target, int ind, int n, vector<int>&dp)\\n    {\\n        if(ind==n-1)\\n            return 0;\\n        if(ind > n-1)\\n            return -1e9;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int cnt = INT_MIN;\\n        for(int i = ind+1; i<n;i++)\\n        {\\n            int temp = nums[i]-nums[ind];\\n            if(temp > target || temp <(0-target))\\n                continue;\\n            cnt = max(cnt, 1+solve(nums, target, i, n, dp));\\n        }\\n        return dp[ind] = cnt;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(n+5, -1);\\n        int ans = solve(nums, target, 0, n, dp);\\n        if(ans <= -1e9)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761236,
                "title": "easy-clean-code-recursive-and-memoization",
                "content": "# Intuition\\nHere we are asked the maximize the number and steps with some given jump condition..so dynamic programing comes to our mind.\\n\\nWe must jump if only if we satisfy the given condition else we ignore.\\nsee the recursive solution to understand more.\\n\\n# Approach\\nRecursion -> DP\\n\\n\\n# Recursive solution (TLE)\\n```\\n\\n    //RECURSIVE SOLUTION\\n    public int recursive(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n\\n        int count=Integer.MIN_VALUE;\\n\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n\\n            if(temp>target||temp<(0-target))continue;\\n\\n            count=Math.max(count,1+recursive(arr,target,i));\\n        }\\n\\n        return count;\\n    }\\n   \\n```\\n# Memoization DP (accepted)\\n```\\n//MEMOIZATION\\n    public int memoization(int[] arr,int target,int index){\\n\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n\\n        if(memo[index]!=0)return memo[index];\\n\\n        int count=Integer.MIN_VALUE;\\n\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n\\n            if(temp>target||temp<(0-target))continue;\\n            \\n            count=Math.max(count,1+memoization(arr,target,i));\\n        }\\n\\n        return memo[index]=count;\\n    }\\n```\\n# My accepted solution\\n```\\nclass Solution {\\n    int[] memo;\\n    public int maximumJumps(int[] nums, int target) {\\n        memo=new int[nums.length+1];\\n        int ans= memoization(nums,target,0);\\n        if(ans<0)return -1;\\n\\n        return ans;\\n    }\\n\\n    //RECURSIVE SOLUTION\\n    public int recursive(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n        int count=Integer.MIN_VALUE;\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n            if(temp>target||temp<(0-target))continue;\\n\\n            count=Math.max(count,1+recursive(arr,target,i));\\n        }\\n\\n        return count;\\n    }\\n\\n    //MEMOIZATION\\n    public int memoization(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n        if(memo[index]!=0)return memo[index];\\n        int count=Integer.MIN_VALUE;\\n        for(int i=index+1;i<arr.length;i++){\\n            int temp=arr[i]-arr[index];\\n            if(temp>target||temp<(0-target))continue;\\n            \\n            count=Math.max(count,1+memoization(arr,target,i));\\n        }\\n        return memo[index]=count;\\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE IF FOUND IT HELPFUL",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n    //RECURSIVE SOLUTION\\n    public int recursive(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n\\n        int count=Integer.MIN_VALUE;\\n\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n\\n            if(temp>target||temp<(0-target))continue;\\n\\n            count=Math.max(count,1+recursive(arr,target,i));\\n        }\\n\\n        return count;\\n    }\\n   \\n```\n```\\n//MEMOIZATION\\n    public int memoization(int[] arr,int target,int index){\\n\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n\\n        if(memo[index]!=0)return memo[index];\\n\\n        int count=Integer.MIN_VALUE;\\n\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n\\n            if(temp>target||temp<(0-target))continue;\\n            \\n            count=Math.max(count,1+memoization(arr,target,i));\\n        }\\n\\n        return memo[index]=count;\\n    }\\n```\n```\\nclass Solution {\\n    int[] memo;\\n    public int maximumJumps(int[] nums, int target) {\\n        memo=new int[nums.length+1];\\n        int ans= memoization(nums,target,0);\\n        if(ans<0)return -1;\\n\\n        return ans;\\n    }\\n\\n    //RECURSIVE SOLUTION\\n    public int recursive(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n        int count=Integer.MIN_VALUE;\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n            if(temp>target||temp<(0-target))continue;\\n\\n            count=Math.max(count,1+recursive(arr,target,i));\\n        }\\n\\n        return count;\\n    }\\n\\n    //MEMOIZATION\\n    public int memoization(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n        if(memo[index]!=0)return memo[index];\\n        int count=Integer.MIN_VALUE;\\n        for(int i=index+1;i<arr.length;i++){\\n            int temp=arr[i]-arr[index];\\n            if(temp>target||temp<(0-target))continue;\\n            \\n            count=Math.max(count,1+memoization(arr,target,i));\\n        }\\n        return memo[index]=count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761225,
                "title": "easy-clean-code-recursive-and-memoization",
                "content": "# Intuition\\nHere we are asked the maximize the number and steps with some given jump condition..so dynamic programing comes to our mind.\\n\\nWe must jump if only if we satisfy the given condition else we ignore.\\nsee the recursive solution to understand more.\\n\\n# Approach\\nRecursion -> DP\\n\\n\\n# Recursive solution (TLE)\\n```\\n\\n    //RECURSIVE SOLUTION\\n    public int recursive(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n\\n        int count=Integer.MIN_VALUE;\\n\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n\\n            if(temp>target||temp<(0-target))continue;\\n\\n            count=Math.max(count,1+recursive(arr,target,i));\\n        }\\n\\n        return count;\\n    }\\n   \\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n    //RECURSIVE SOLUTION\\n    public int recursive(int[] arr,int target,int index){\\n        if(index==arr.length-1){ \\n            return 0;\\n        }\\n        if(index>arr.length-1)return Integer.MIN_VALUE;\\n\\n        int count=Integer.MIN_VALUE;\\n\\n        for(int i=index+1;i<arr.length;i++){\\n\\n            int temp=arr[i]-arr[index];\\n\\n            if(temp>target||temp<(0-target))continue;\\n\\n            count=Math.max(count,1+recursive(arr,target,i));\\n        }\\n\\n        return count;\\n    }\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760058,
                "title": "beats-76-77-easy-solution-in-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count(int co,vector<int> &res,int tar,vector<int> &dp){\\n        if(co==res.size()-1)return 0;\\n        if(dp[co]!=-1) return dp[co];\\n        int a = INT_MIN;\\n        for(int i=co+1;i<res.size();i++){\\n            if(abs(res[i]-res[co])<=tar) a = max(a,1+count(i,res,tar,dp));\\n        }\\n        return dp[co] = a;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar) {\\n        vector<int> dp(nums.size(),-1);\\n        int a = count(0,nums,tar,dp);\\n        if(a>0) return a;\\n        else return -1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(int co,vector<int> &res,int tar,vector<int> &dp){\\n        if(co==res.size()-1)return 0;\\n        if(dp[co]!=-1) return dp[co];\\n        int a = INT_MIN;\\n        for(int i=co+1;i<res.size();i++){\\n            if(abs(res[i]-res[co])<=tar) a = max(a,1+count(i,res,tar,dp));\\n        }\\n        return dp[co] = a;\\n    }\\n    int maximumJumps(vector<int>& nums, int tar) {\\n        vector<int> dp(nums.size(),-1);\\n        int a = count(0,nums,tar,dp);\\n        if(a>0) return a;\\n        else return -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757026,
                "title": "top-down-solution",
                "content": "```\\nclass Solution {\\n    func maximumJumps(_ nums: [Int], _ target: Int) -> Int {\\n        let n = nums.count\\n        // -2: unvisited\\n        // -1: can\\'t reach\\n        var cache = Array(repeating: -2, count: n)\\n        \\n        func helper(_ id: Int) -> Int {\\n            if id == n-1 { return 0 }\\n            if cache[id] != -2 { return cache[id] }\\n            var ans = -1\\n            for i in (id+1)..<n {\\n                if abs(nums[id] - nums[i]) <= target {\\n                    let nextAns = helper(i)\\n                    if nextAns >= 0 {\\n                        ans = max(ans, nextAns + 1)   \\n                    }\\n                }\\n            }\\n            cache[id] = ans\\n            return ans\\n        }\\n        \\n        return helper(0)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maximumJumps(_ nums: [Int], _ target: Int) -> Int {\\n        let n = nums.count\\n        // -2: unvisited\\n        // -1: can\\'t reach\\n        var cache = Array(repeating: -2, count: n)\\n        \\n        func helper(_ id: Int) -> Int {\\n            if id == n-1 { return 0 }\\n            if cache[id] != -2 { return cache[id] }\\n            var ans = -1\\n            for i in (id+1)..<n {\\n                if abs(nums[id] - nums[i]) <= target {\\n                    let nextAns = helper(i)\\n                    if nextAns >= 0 {\\n                        ans = max(ans, nextAns + 1)   \\n                    }\\n                }\\n            }\\n            cache[id] = ans\\n            return ans\\n        }\\n        \\n        return helper(0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754946,
                "title": "very-simple-dp-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int i =1 ; i<n ; i++ ){\\n            for(int j =0 ; j< i ; j++){\\n                if((abs(nums[i]-nums[j])<=target) && dp[j]!=-1){\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                } \\n            }\\n        }\\n        return dp[n-1];\\n\\n    }\\n    //first dp question\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        dp[0]=0;\\n        for(int i =1 ; i<n ; i++ ){\\n            for(int j =0 ; j< i ; j++){\\n                if((abs(nums[i]-nums[j])<=target) && dp[j]!=-1){\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                } \\n            }\\n        }\\n        return dp[n-1];\\n\\n    }\\n    //first dp question\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754819,
                "title": "straight-forward-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int target;\\n    Long[]dp;\\n    public int maximumJumps(int[] nums, int target) {\\n        dp=new Long[nums.length];\\n        this.target=target;\\n        int res= (int)(helper(nums,0));\\n        return res<0?-1:res;\\n    }\\n    \\n    long helper(int[]nums,int index)\\n    {\\n        if(index==nums.length-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=null)\\n        {\\n            return dp[index];\\n        }\\n        long max=Integer.MIN_VALUE;\\n        for(int i=index+1;i<nums.length;i++)\\n        {\\n            int ele=nums[i]-nums[index];\\n            if(-target<=ele && ele<=target)\\n            {\\n                max=Math.max(max,1+helper(nums,i));\\n            }\\n        }\\n        \\n        dp[index]=max;\\n        return dp[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int target;\\n    Long[]dp;\\n    public int maximumJumps(int[] nums, int target) {\\n        dp=new Long[nums.length];\\n        this.target=target;\\n        int res= (int)(helper(nums,0));\\n        return res<0?-1:res;\\n    }\\n    \\n    long helper(int[]nums,int index)\\n    {\\n        if(index==nums.length-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=null)\\n        {\\n            return dp[index];\\n        }\\n        long max=Integer.MIN_VALUE;\\n        for(int i=index+1;i<nums.length;i++)\\n        {\\n            int ele=nums[i]-nums[index];\\n            if(-target<=ele && ele<=target)\\n            {\\n                max=Math.max(max,1+helper(nums,i));\\n            }\\n        }\\n        \\n        dp[index]=max;\\n        return dp[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754716,
                "title": "memoized-recursive-solution-to-dp-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question is asking for maximum number of jumps. The first approach that comes to mind maybe the greedy one, basically you can jump whenever the condition <= target is met for the first time. But it may be possible that if we take the best choice we may not reach the end.\\nSo there are are different options available at any point and we need to maximize our answer which immediately points to DP.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first recursive and memoized approach is straightforward. We start with the first index and of all the available indexes we jump to each of the valid one and take the maximum value from each one.\\n\\nWe can convert the above to DP. The array dp[i] represents the maximum jumps we can do till the ith index. So for first index we require 0 jumps. For second index or subsequent indexes(j) we can check which of the indexes from 0 to j are valid (<= target) and update dp[i] to max(dp[i], dp[j] + 1)\\n\\n# Complexity\\n- Time complexity: O(N^2) 2 iterations of len(nums)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N) 1D array for DP\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        # DP SOLUTION\\n        dp = [float(\"-inf\")] *(len(nums))\\n        dp[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if abs(nums[j] - nums[i]) <= target:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[-1] if dp[-1] != float(\\'-inf\\') else -1\\n\\n        # MEMOIZED SOLUTION\\n        @cache\\n        def getMaxJumps(i):\\n            if i >= len(nums) - 1:\\n                return 0\\n            res = float(\\'-inf\\')\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[j] - nums[i]) <= target:\\n                    res = max(1 + getMaxJumps(j), res)\\n            return res\\n        ans = getMaxJumps(0)\\n        return -1 if ans == float(\\'-inf\\') else ans\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        # DP SOLUTION\\n        dp = [float(\"-inf\")] *(len(nums))\\n        dp[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if abs(nums[j] - nums[i]) <= target:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[-1] if dp[-1] != float(\\'-inf\\') else -1\\n\\n        # MEMOIZED SOLUTION\\n        @cache\\n        def getMaxJumps(i):\\n            if i >= len(nums) - 1:\\n                return 0\\n            res = float(\\'-inf\\')\\n            for j in range(i + 1, len(nums)):\\n                if abs(nums[j] - nums[i]) <= target:\\n                    res = max(1 + getMaxJumps(j), res)\\n            return res\\n        ans = getMaxJumps(0)\\n        return -1 if ans == float(\\'-inf\\') else ans\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754271,
                "title": "simple-dp-solution-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size(), maxi = 0;\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        for(int i=0; i<n; i++){\\n         for(int j=i+1; j<n; j++){\\n           if(abs(nums[j] - nums[i]) <= target && dp[i] != -1)\\n               { \\n//second condition ensures that we have reached ith index from 0 index,\\n//if dp[i] == -1, this means we cannot reach i by jumoing from 0 index\\n//as there is no point jumping from i to j if we cannot jump from 0 to i index\\n                  dp[j] = max(dp[j], 1 + dp[i]); //since, we want maximum jumps\\n               }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size(), maxi = 0;\\n        vector<int> dp(n,-1);\\n        dp[0] = 0;\\n        for(int i=0; i<n; i++){\\n         for(int j=i+1; j<n; j++){\\n           if(abs(nums[j] - nums[i]) <= target && dp[i] != -1)\\n               { \\n//second condition ensures that we have reached ith index from 0 index,\\n//if dp[i] == -1, this means we cannot reach i by jumoing from 0 index\\n//as there is no point jumping from i to j if we cannot jump from 0 to i index\\n                  dp[j] = max(dp[j], 1 + dp[i]); //since, we want maximum jumps\\n               }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753820,
                "title": "dp-memo-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int memo(vector<vector<int>>& dp, vector<int>& nums, int target, int i, int prev)\\n    {\\n        if(i == nums.size()-1)\\n        {\\n            if(abs(nums[i]-nums[prev])<=target)\\n            {\\n                return 1;\\n            }\\n            else return INT_MIN;\\n        }\\n        if(dp[i][prev] != -1) return dp[i][prev];\\n        \\n        int incl = INT_MIN;\\n        if(abs(nums[i]-nums[prev])<=target)\\n        {\\n            incl = 1+memo(dp,nums,target,i+1,i);\\n        }\\n        int excl = memo(dp,nums,target,i+1,prev);\\n        \\n        return dp[i][prev] = max(incl,excl);\\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<vector<int>> dp(nums.size(),vector<int>(nums.size(),-1));\\n        int ans = memo(dp,nums,target,1,0);\\n        //cout<<ans<<endl;\\n        if(ans<=0) return -1;\\n        else return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo(vector<vector<int>>& dp, vector<int>& nums, int target, int i, int prev)\\n    {\\n        if(i == nums.size()-1)\\n        {\\n            if(abs(nums[i]-nums[prev])<=target)\\n            {\\n                return 1;\\n            }\\n            else return INT_MIN;\\n        }\\n        if(dp[i][prev] != -1) return dp[i][prev];\\n        \\n        int incl = INT_MIN;\\n        if(abs(nums[i]-nums[prev])<=target)\\n        {\\n            incl = 1+memo(dp,nums,target,i+1,i);\\n        }\\n        int excl = memo(dp,nums,target,i+1,prev);\\n        \\n        return dp[i][prev] = max(incl,excl);\\n    }\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<vector<int>> dp(nums.size(),vector<int>(nums.size(),-1));\\n        int ans = memo(dp,nums,target,1,0);\\n        //cout<<ans<<endl;\\n        if(ans<=0) return -1;\\n        else return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3752767,
                "title": "c-one-dimensional-dynamic-programming",
                "content": "# Intuition\\nDynamic programming approach. We will maintain an array `dp` of size `numsSize`, where `dp[i]` represents the maximum number of jumps to reach index `i`.\\n\\n# Approach\\nWe will initialize `dp[0]` to 0, as we are initially positioned at index 0. \\n\\nWe will iterate over the array `nums` starting from index 1. For each index `i`, we will consider all indices `j` less than `i` and check if the absolute difference between `nums[j]` and `nums[i]` is within the range `[-target, target]`.\\n\\nIf it is, we can jump from index `j` to index `i`. In that case, we will update `dp[i]` to be the maximum of its current value and `dp[j] + 1`. This means that we can reach index `i` in `dp[j] + 1` jumps.\\n\\nFinally, the maximum number of jumps to reach the last index will be stored in `dp[numsSize - 1]`. If `dp[numsSize - 1]` is still -1, it means we cannot reach the last index and we return -1.\\n\\n# Complexity\\n- Time complexity: $O(n^2)$ due to nested loops iterating over the array `nums`.\\n- Space complexity: $O(n)$ due to using an additional array `dp` of size `numsSize`.\\n\\n# Code\\n```c\\nint maximumJumps(int* nums, int numsSize, int target){\\n    int dp[numsSize];\\n    dp[0] = 0;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        dp[i] = -1;\\n        for (int j = 0; j < i; j++) {\\n            if (abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                dp[i] = (dp[i] > dp[j] + 1) ? dp[i] : dp[j] + 1;\\n            }\\n        }\\n    }\\n    return dp[numsSize - 1];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c\\nint maximumJumps(int* nums, int numsSize, int target){\\n    int dp[numsSize];\\n    dp[0] = 0;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        dp[i] = -1;\\n        for (int j = 0; j < i; j++) {\\n            if (abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                dp[i] = (dp[i] > dp[j] + 1) ? dp[i] : dp[j] + 1;\\n            }\\n        }\\n    }\\n    return dp[numsSize - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752546,
                "title": "python3-dp-with-memo",
                "content": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        mem=[-1 for x in nums]\\n        def dp(i):\\n            if i==len(nums)-1:return 0\\n            if i>=len(nums):return -float(\\'inf\\')\\n            if mem[i]!=-1:return mem[i]\\n            mem[i]=-float(\\'inf\\')\\n            for ni in range(i+1,len(nums)):\\n                if (nums[ni]-nums[i])>=-target and (nums[ni]-nums[i])<=target:mem[i]=max(mem[i],1+dp(ni))\\n            return mem[i]\\n        x=dp(0)\\n        return x if x!=-float(\\'inf\\')else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        mem=[-1 for x in nums]\\n        def dp(i):\\n            if i==len(nums)-1:return 0\\n            if i>=len(nums):return -float(\\'inf\\')\\n            if mem[i]!=-1:return mem[i]\\n            mem[i]=-float(\\'inf\\')\\n            for ni in range(i+1,len(nums)):\\n                if (nums[ni]-nums[i])>=-target and (nums[ni]-nums[i])<=target:mem[i]=max(mem[i],1+dp(ni))\\n            return mem[i]\\n        x=dp(0)\\n        return x if x!=-float(\\'inf\\')else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752228,
                "title": "dynamic-programming-approach-c",
                "content": "# Intuition\\nso we could have gone with the traditional pick and try approach I tried it in contest but there was a test case that told me I was wrong and I have to test each and every element for finding the max jumps required.\\n\\n# Approach\\ndynamic programming is nothing just optimized brute force so applying the same i declared a dp array where dp[i] told me the max number of jumps required to reach n-1 from ith index.\\nnow the base case would be dp[n-1]=0 as we are already on the n-1th index so we cannot jump further.\\nthe ans would have been according to the question dp[0] i.e the max number of jumps required to reach n-1th index from 0th index.\\nalso starting from the back was easy because i thought the comparisons would be easy so we can go from the back and check with the constraints if they are inplace voila you can jump.\\n\\n# Complexity\\n- Time complexity:\\n- i guess the time complexity according to me would be O(n^2);\\n- because it would traverse the two loops anyhow.\\n\\n- Space complexity:\\nspace complexity would be O(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n       int n=nums.size();\\n        vector<int> dp(n,-1);\\n// dp[i] would represent\\n//the max number of jumps required to reach n-1 from ith indexd\\n        dp[n-1]=0;\\n        int j=n-1;\\n        for(int i=n-2;i>=0;i--){\\n            dp[i]=INT_MIN;\\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]-nums[i]>=-target and nums[j]-nums[i]<=target and dp[j]!=INT_MIN){\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            \\n        }\\n        return dp[0]==INT_MIN?-1:dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n       int n=nums.size();\\n        vector<int> dp(n,-1);\\n// dp[i] would represent\\n//the max number of jumps required to reach n-1 from ith indexd\\n        dp[n-1]=0;\\n        int j=n-1;\\n        for(int i=n-2;i>=0;i--){\\n            dp[i]=INT_MIN;\\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]-nums[i]>=-target and nums[j]-nums[i]<=target and dp[j]!=INT_MIN){\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            \\n        }\\n        return dp[0]==INT_MIN?-1:dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752133,
                "title": "segment-tree-o-nlogn-solution",
                "content": "# Intuition\\nWe need the maximum (number of steps) within a range (of values after the current index), which is what segment tree is for. This is the Python version of [Approach 3 here](https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3740572/c-o-nlogn-dp-segment-tree-optimize-step-by-step-with-explanation/).\\n\\n# Approach\\n1. Sort the unique values of `nums`.\\n2. Initialize a segment tree for maximum within a range query, with size equal to the number of unique values and initial values `-inf`.\\n3. Bisect to find the index of the value of the last element of `nums` and update its maximum in the segment tree to `0`.\\n4. Traverse `nums[:-1]` in reverse order. For each element, bisect twice to find the corresponding indices `l` (inclusive) and `r` (exclusive) to `nums[i] - target` and `nums[i] + target`, respectively. Query for the maximum number of steps and update the maximum corresponding to `nums[i]` to maximum plus 1.\\n5. The last \"maximum plus 1\" is the answer if it\\'s bigger than `-inf` (meaning, index `n - 1` is reachable), `-1` otherwise.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n\\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass SegmentTree:\\n    def __init__(self, arr):\\n        self.n = len(arr)\\n        self.max_tree = [-math.inf] * self.n\\n        self.max_tree.extend(arr)\\n        for i in range(self.n - 1, 0, -1):\\n            self.max_tree[i] = max(self.max_tree[i << 1], self.max_tree[i << 1 | 1])\\n\\n    def update(self, i, val):\\n        i += self.n\\n        self.max_tree[i] = val\\n        while i > 1:\\n            self.max_tree[i >> 1] = max(self.max_tree[i], self.max_tree[i ^ 1])\\n            i >>= 1\\n\\n    def max_val(self, l, r):\\n        maximum = -math.inf\\n        l += self.n\\n        r += self.n\\n        while l < r:\\n            if (l & 1):\\n                maximum = max(maximum, self.max_tree[l])\\n                l += 1\\n            if (r & 1):\\n                r -= 1;\\n                maximum = max(maximum, self.max_tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return maximum\\n\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        val = sorted(set(nums))\\n        st = SegmentTree([-math.inf] * len(val))\\n        st.update(bisect.bisect_left(val, nums[-1]), 0)\\n        n = len(nums)\\n        for i in reversed(range(n - 1)):\\n            x = nums[i]\\n            l = bisect.bisect_left(val, x - target)\\n            r = bisect.bisect(val, x + target, l)\\n            ans = st.max_val(l, r) + 1\\n            i = bisect.bisect_left(val, x, l, r)\\n            st.update(i, ans)\\n        return ans if ans > -math.inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SegmentTree:\\n    def __init__(self, arr):\\n        self.n = len(arr)\\n        self.max_tree = [-math.inf] * self.n\\n        self.max_tree.extend(arr)\\n        for i in range(self.n - 1, 0, -1):\\n            self.max_tree[i] = max(self.max_tree[i << 1], self.max_tree[i << 1 | 1])\\n\\n    def update(self, i, val):\\n        i += self.n\\n        self.max_tree[i] = val\\n        while i > 1:\\n            self.max_tree[i >> 1] = max(self.max_tree[i], self.max_tree[i ^ 1])\\n            i >>= 1\\n\\n    def max_val(self, l, r):\\n        maximum = -math.inf\\n        l += self.n\\n        r += self.n\\n        while l < r:\\n            if (l & 1):\\n                maximum = max(maximum, self.max_tree[l])\\n                l += 1\\n            if (r & 1):\\n                r -= 1;\\n                maximum = max(maximum, self.max_tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return maximum\\n\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        val = sorted(set(nums))\\n        st = SegmentTree([-math.inf] * len(val))\\n        st.update(bisect.bisect_left(val, nums[-1]), 0)\\n        n = len(nums)\\n        for i in reversed(range(n - 1)):\\n            x = nums[i]\\n            l = bisect.bisect_left(val, x - target)\\n            r = bisect.bisect(val, x + target, l)\\n            ans = st.max_val(l, r) + 1\\n            i = bisect.bisect_left(val, x, l, r)\\n            st.update(i, ans)\\n        return ans if ans > -math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752092,
                "title": "maximum-number-of-jumps-to-reach-the-last-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n    const n = nums.length;\\n    const dp = new Array(n).fill(-1);\\n    dp[0] = 0;\\n    for (let i = 1; i < n; i++) {\\n        const minVal = nums[i] - target;\\n        const maxVal = nums[i] + target;\\n\\n        for (let j = 0; j < i; j++) {\\n        if (nums[j] >= minVal && nums[j] <= maxVal) {\\n            if (dp[j] !== -1) {\\n            dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        }\\n    }\\n    return dp[n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar maximumJumps = function(nums, target) {\\n    const n = nums.length;\\n    const dp = new Array(n).fill(-1);\\n    dp[0] = 0;\\n    for (let i = 1; i < n; i++) {\\n        const minVal = nums[i] - target;\\n        const maxVal = nums[i] + target;\\n\\n        for (let j = 0; j < i; j++) {\\n        if (nums[j] >= minVal && nums[j] <= maxVal) {\\n            if (dp[j] !== -1) {\\n            dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        }\\n    }\\n    return dp[n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751603,
                "title": "easy-memo",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int>dp;\\n\\n    int func(vector<int>&nums,int target,int i)\\n    {\\n        if(i>=nums.size())return INT_MIN;\\n        if(i==nums.size()-1)return 0;\\n\\n        if(dp[i]!=-1)return dp[i];\\n        int a=INT_MIN;\\n        for(int j=i+1;j<nums.size();j++)\\n        {\\n            if(abs(nums[i]-nums[j])<=target)\\n            {\\n                a=max(a,func(nums,target,j)+1);\\n            }\\n        }\\n        return dp[i]=a;\\n    }\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        dp.resize(nums.size()+1,-1);\\n        int ans=func(nums,target,0);\\n        return ans<0?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int>dp;\\n\\n    int func(vector<int>&nums,int target,int i)\\n    {\\n        if(i>=nums.size())return INT_MIN;\\n        if(i==nums.size()-1)return 0;\\n\\n        if(dp[i]!=-1)return dp[i];\\n        int a=INT_MIN;\\n        for(int j=i+1;j<nums.size();j++)\\n        {\\n            if(abs(nums[i]-nums[j])<=target)\\n            {\\n                a=max(a,func(nums,target,j)+1);\\n            }\\n        }\\n        return dp[i]=a;\\n    }\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        dp.resize(nums.size()+1,-1);\\n        int ans=func(nums,target,0);\\n        return ans<0?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750588,
                "title": "simple-c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int f(vector<int>&nums,int i,int tar,vector<int>&dp){\\n        if(i==nums.size()-1)return 0;\\n        if(i>=nums.size())return -10000;\\n        if(dp[i]!=-1)return dp[i];\\n        int c=-100000;\\n        for(int j=i+1;j<nums.size();j++){\\n            int d=nums[j]-nums[i],t=-10000;\\n            if(d>=-tar&&d<=tar)t=1+f(nums,j,tar,dp);\\n            c=max(t,c);\\n        }  \\n        return dp[i]= c;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n       n=nums.size();\\n      vector<int>dp(n,-1);\\n       int c=f(nums,0,target,dp);\\n       if(c<=0)return -1;\\n       return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int f(vector<int>&nums,int i,int tar,vector<int>&dp){\\n        if(i==nums.size()-1)return 0;\\n        if(i>=nums.size())return -10000;\\n        if(dp[i]!=-1)return dp[i];\\n        int c=-100000;\\n        for(int j=i+1;j<nums.size();j++){\\n            int d=nums[j]-nums[i],t=-10000;\\n            if(d>=-tar&&d<=tar)t=1+f(nums,j,tar,dp);\\n            c=max(t,c);\\n        }  \\n        return dp[i]= c;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n       n=nums.size();\\n      vector<int>dp(n,-1);\\n       int c=f(nums,0,target,dp);\\n       if(c<=0)return -1;\\n       return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749661,
                "title": "memoization-and-tabulation-solution-1d-dp-tc-o-n-2-sc-o-n",
                "content": "\\n# Code\\n```\\n//Tabulation TC=O(NxN) SC=O(N) [dp vec]\\nclass Solution {\\npublic:\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n\\n        dp[0]=0;\\n        for(int i=1; i<n; i++)\\n        {\\n            dp[i] = INT_MIN;\\n            for(int j=0; j<i; j++)\\n            {\\n                int val = abs(nums[j]-nums[i]);\\n                if(val <= target)\\n                {\\n                    int steps = 1 + dp[j];\\n                    dp[i] = max(dp[i], steps);\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1]<0 ? -1 : dp[n-1];\\n    }\\n};\\n\\n\\n//Memoization TC=O(NxN) SC=O(N)+O(N) [dp vec+ RSS]\\nclass Solution {\\npublic:\\n    \\n    int f(int ind, vector<int> &nums, int target, vector<int> &dp)\\n    {\\n        if(ind==0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int maxi = INT_MIN;\\n        \\n        for(int i=ind-1; i>=0; i--)\\n        {\\n            int val = abs(nums[ind]-nums[i]);\\n            if(val <= target)\\n            {\\n                int steps = 1 + f(i, nums, target,dp);\\n                maxi = max(maxi, steps);\\n            }\\n        }\\n        return dp[ind]=maxi;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        int res = f(n-1,nums,target,dp);\\n\\n        return res<0 ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Tabulation TC=O(NxN) SC=O(N) [dp vec]\\nclass Solution {\\npublic:\\n    \\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n\\n        dp[0]=0;\\n        for(int i=1; i<n; i++)\\n        {\\n            dp[i] = INT_MIN;\\n            for(int j=0; j<i; j++)\\n            {\\n                int val = abs(nums[j]-nums[i]);\\n                if(val <= target)\\n                {\\n                    int steps = 1 + dp[j];\\n                    dp[i] = max(dp[i], steps);\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1]<0 ? -1 : dp[n-1];\\n    }\\n};\\n\\n\\n//Memoization TC=O(NxN) SC=O(N)+O(N) [dp vec+ RSS]\\nclass Solution {\\npublic:\\n    \\n    int f(int ind, vector<int> &nums, int target, vector<int> &dp)\\n    {\\n        if(ind==0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int maxi = INT_MIN;\\n        \\n        for(int i=ind-1; i>=0; i--)\\n        {\\n            int val = abs(nums[ind]-nums[i]);\\n            if(val <= target)\\n            {\\n                int steps = 1 + f(i, nums, target,dp);\\n                maxi = max(maxi, steps);\\n            }\\n        }\\n        return dp[ind]=maxi;\\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        int res = f(n-1,nums,target,dp);\\n\\n        return res<0 ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749638,
                "title": "maximum-number-of-jumps",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought using a backtracking approach that is for each index\\nmy solution will find the indices where it can jump to.So by this I my solution will try all the possible paths where it can jump to.\\nAfter finding all the paths to the n-1 the elements. My solution will print maximum jumps from paths.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have usen a dynamic programming approach\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n> Quote\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int dp[]=new int[nums.length];\\n        dp[0]=0;\\n        int k;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            dp[i]=0;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                k=nums[j]-nums[i];\\n                if(k<=target && k>=(-1*target))\\n                {\\n                    if(j==0 || dp[j]!=0)\\n                    {\\n                        dp[i]=dp[i]>(dp[j]+1)?dp[i]:(dp[j]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[nums.length-1]==0)\\n        {\\n            return -1;\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int dp[]=new int[nums.length];\\n        dp[0]=0;\\n        int k;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            dp[i]=0;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                k=nums[j]-nums[i];\\n                if(k<=target && k>=(-1*target))\\n                {\\n                    if(j==0 || dp[j]!=0)\\n                    {\\n                        dp[i]=dp[i]>(dp[j]+1)?dp[i]:(dp[j]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[nums.length-1]==0)\\n        {\\n            return -1;\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748839,
                "title": "simple-c-solution-using-recursion-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i ,int prev , int t , vector<int>&arr , vector<vector<int>>&dp){\\n        if(i==n-1){\\n            if(abs(arr[i]-arr[prev])<=t){\\n                return 1;\\n            }\\n            return INT_MIN;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        if(abs(arr[i]-arr[prev])<=t){\\n            return dp[i][prev] =  max(1 + solve(i+1 , i , t ,arr,dp) , solve(i+1 , prev , t ,arr,dp));\\n        }\\n        return dp[i][prev] = solve(i+1 , prev , t , arr,dp);\\n    }\\n    int maximumJumps(vector<int>& arr, int t) {\\n        n = arr.size();\\n        // int maxx = INT_MAX;\\n        // for(int i=1 ; i<n ; i++){\\n        //     maxx = max(maxx , solve(i, 0,t ,  arr));\\n        // }\\n        vector<vector<int>> dp(n , vector<int>(n , -1));\\n        int maxx = solve(1, 0,t ,  arr , dp);\\n        return maxx < 0 ? -1 : maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i ,int prev , int t , vector<int>&arr , vector<vector<int>>&dp){\\n        if(i==n-1){\\n            if(abs(arr[i]-arr[prev])<=t){\\n                return 1;\\n            }\\n            return INT_MIN;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        if(abs(arr[i]-arr[prev])<=t){\\n            return dp[i][prev] =  max(1 + solve(i+1 , i , t ,arr,dp) , solve(i+1 , prev , t ,arr,dp));\\n        }\\n        return dp[i][prev] = solve(i+1 , prev , t , arr,dp);\\n    }\\n    int maximumJumps(vector<int>& arr, int t) {\\n        n = arr.size();\\n        // int maxx = INT_MAX;\\n        // for(int i=1 ; i<n ; i++){\\n        //     maxx = max(maxx , solve(i, 0,t ,  arr));\\n        // }\\n        vector<vector<int>> dp(n , vector<int>(n , -1));\\n        int maxx = solve(1, 0,t ,  arr , dp);\\n        return maxx < 0 ? -1 : maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748269,
                "title": "easy-c-solution-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>ch(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(j==0 && (target>=nums[j]-nums[i] && -target<=nums[j]-nums[i]))\\n                {\\n                    ch[i]=ch[j]+1;\\n                }\\n                else if(ch[j]!=0 && (target>=nums[j]-nums[i] && -target<=nums[j]-nums[i]))\\n                {\\n                    ch[i]=max(ch[i],ch[j]+1);\\n                }\\n            }\\n        }\\n        if(ch[n-1]==0) return -1;\\n\\n        return ch[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>ch(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(j==0 && (target>=nums[j]-nums[i] && -target<=nums[j]-nums[i]))\\n                {\\n                    ch[i]=ch[j]+1;\\n                }\\n                else if(ch[j]!=0 && (target>=nums[j]-nums[i] && -target<=nums[j]-nums[i]))\\n                {\\n                    ch[i]=max(ch[i],ch[j]+1);\\n                }\\n            }\\n        }\\n        if(ch[n-1]==0) return -1;\\n\\n        return ch[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748242,
                "title": "c-dp-bottom-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[0] = 0;\\n        for(int i = 0; i < n - 1; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if(abs(nums[j] - nums[i]) <= target && dp[i] != -1) \\n                    dp[j] = max(dp[j], dp[i] + 1);\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[0] = 0;\\n        for(int i = 0; i < n - 1; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if(abs(nums[j] - nums[i]) <= target && dp[i] != -1) \\n                    dp[j] = max(dp[j], dp[i] + 1);\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747968,
                "title": "dp-bottom-up",
                "content": "\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP bottom up\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> maxJumps(n, 0);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (abs(nums[j] - nums[i]) <= target && (maxJumps[j] || j == 0)) maxJumps[i] = max(maxJumps[i], maxJumps[j]+1);\\n            }\\n        }\\n        return maxJumps[n-1] ? maxJumps[n-1] : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> maxJumps(n, 0);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (abs(nums[j] - nums[i]) <= target && (maxJumps[j] || j == 0)) maxJumps[i] = max(maxJumps[i], maxJumps[j]+1);\\n            }\\n        }\\n        return maxJumps[n-1] ? maxJumps[n-1] : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747600,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs( vector<vector<int>> &graph, int v, vector<int> &dp ) {\\n        if( graph.size() == v+1 )\\n            return 0;\\n        // if( path[v] )\\n        //     return -2;\\n        if( dp[v] != -1 )\\n            return dp[v];\\n        // path[v] = 1;\\n        int t = INT_MIN;\\n        for( auto i : graph[v] ) {\\n            t = max( t, 1 + dfs( graph, i , dp ) );\\n        }\\n        // path[v] = 0;\\n        if( t < 0 )\\n            return dp[v] = -2;\\n        return dp[v] = t;\\n    }\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> graph( n );\\n        vector<int> path(n, 0);\\n        for( int i = 0; i<n; i++ ) {\\n            for( int j = i+1; j<n; j++ ) {\\n                if( abs( nums[i]-nums[j]) <= target )\\n                    graph[i].push_back( j );\\n            }\\n        }\\n        // path[0] = 1;\\n        vector<int> dp( n, -1 );\\n        int res = dfs( graph, 0, dp );\\n        return res < 0 ? -1 : res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs( vector<vector<int>> &graph, int v, vector<int> &dp ) {\\n        if( graph.size() == v+1 )\\n            return 0;\\n        // if( path[v] )\\n        //     return -2;\\n        if( dp[v] != -1 )\\n            return dp[v];\\n        // path[v] = 1;\\n        int t = INT_MIN;\\n        for( auto i : graph[v] ) {\\n            t = max( t, 1 + dfs( graph, i , dp ) );\\n        }\\n        // path[v] = 0;\\n        if( t < 0 )\\n            return dp[v] = -2;\\n        return dp[v] = t;\\n    }\\n\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> graph( n );\\n        vector<int> path(n, 0);\\n        for( int i = 0; i<n; i++ ) {\\n            for( int j = i+1; j<n; j++ ) {\\n                if( abs( nums[i]-nums[j]) <= target )\\n                    graph[i].push_back( j );\\n            }\\n        }\\n        // path[0] = 1;\\n        vector<int> dp( n, -1 );\\n        int res = dfs( graph, 0, dp );\\n        return res < 0 ? -1 : res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747507,
                "title": "c-bottom-up-dynamic-programming",
                "content": "# Intuition\\nDynamic Programming (Bottom up)\\n\\n# Approach\\ndp[i] = max(dp[j]+1,dp[i]) for all j<i \\n\\n# Complexity\\n- Time complexity:\\nO(N*N) -> nested For loop\\n\\n- Space complexity:\\nO(N) for additional vector (dp)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=0;\\n        int tMax=-1;\\n        for (int i=1;i<nums.size();i++){\\n            tMax=-1;\\n            for (int j=i-1;j>=0;j--){\\n                if (dp[j]!=-1 && abs(nums[i]-nums[j])<=target) tMax = max(tMax,dp[j]+1);\\n            }\\n            dp[i]=tMax;\\n        }\\n        return dp[nums.size()-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=0;\\n        int tMax=-1;\\n        for (int i=1;i<nums.size();i++){\\n            tMax=-1;\\n            for (int j=i-1;j>=0;j--){\\n                if (dp[j]!=-1 && abs(nums[i]-nums[j])<=target) tMax = max(tMax,dp[j]+1);\\n            }\\n            dp[i]=tMax;\\n        }\\n        return dp[nums.size()-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747467,
                "title": "python3-o-n-2-dp-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n      grid = [-1]*(len(nums))\\n      grid[0] = 0\\n      for i in range(1, len(grid)):\\n        src = nums[i]\\n        for j in range(i):\\n          tar = nums[j]\\n          if abs(tar - src) <= target:\\n            if grid[j] != -1:\\n              grid[i] = max(grid[j]+1, grid[i])\\n        #print(grid)\\n      return grid[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n      grid = [-1]*(len(nums))\\n      grid[0] = 0\\n      for i in range(1, len(grid)):\\n        src = nums[i]\\n        for j in range(i):\\n          tar = nums[j]\\n          if abs(tar - src) <= target:\\n            if grid[j] != -1:\\n              grid[i] = max(grid[j]+1, grid[i])\\n        #print(grid)\\n      return grid[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747278,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) \\n    {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=0;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(dp[j]!=-1 && abs(nums[j]-nums[i])<=target)\\n                {\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }    \\n\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) \\n    {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=0;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(dp[j]!=-1 && abs(nums[j]-nums[i])<=target)\\n                {\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }    \\n\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747028,
                "title": "cpp-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n It looks like dp\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndefine dp[i] is the maximum number of step to reach index i.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        set<int> s;\\n        s.insert(0);\\n        while(!s.empty())\\n        {\\n            for(auto j : s){\\n            for(int i=j+1; i<n; i++)\\n            {\\n                int num = nums[i] - nums[j];\\n                if(-abs(target) <= num && num <= abs(target))\\n                {\\n                    dp[i] = max(dp[i], dp[j]+1);\\n                    s.insert(i);\\n                }\\n            }\\n            s.erase(j);\\n            }\\n        }\\n        \\n\\n        return dp[n-1] == 0 ? -1 : dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        set<int> s;\\n        s.insert(0);\\n        while(!s.empty())\\n        {\\n            for(auto j : s){\\n            for(int i=j+1; i<n; i++)\\n            {\\n                int num = nums[i] - nums[j];\\n                if(-abs(target) <= num && num <= abs(target))\\n                {\\n                    dp[i] = max(dp[i], dp[j]+1);\\n                    s.insert(i);\\n                }\\n            }\\n            s.erase(j);\\n            }\\n        }\\n        \\n\\n        return dp[n-1] == 0 ? -1 : dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746915,
                "title": "c-dynamic-programming-easy-top-down-recursive-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClassic DP problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[i]: the maximum steps jumping from i to n-1\\n\\ndp[i] = max(dp[j]+1, dp[i]);\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MIN);\\n        dp[n-1] = 0;\\n\\n        for(int i=n-2; i>=0; i--){\\n            for(int j=i+1; j<n; j++){\\n                int curr = abs(nums[i]-nums[j]);\\n                if(curr>target) continue;\\n                dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n        \\n        return dp[0]<0?-1:dp[0];\\n    }\\n};\\n/*\\n    dp[i]: the maximum steps jumping from i to n-1\\n\\n    dp[i] = max(dp[j]+1, dp[i]);\\n\\n\\n*/\\n\\n\\n\\n\\n/* class Solution {\\npublic:\\n    vector<int> memo;\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memo.resize(nums.size(), -1);\\n        int res = dp(nums, target, 0);\\n        return res<0?-1:res;\\n    }\\n\\n\\n    int dp(vector<int>& nums, int target, int index){\\n        //basecase\\n        int n = nums.size();\\n        if(index==n-1){\\n            return 0;\\n        }\\n        if(memo[index]!=-1)\\n            return memo[index];\\n\\n        int ret = INT_MIN;\\n\\n        for(int next=index+1; next<n; next++){\\n            int curr = abs(nums[next]-nums[index]);\\n            if(curr>target) continue;\\n            ret = max(ret, 1 + dp(nums,target,next));\\n        }\\n\\n        return memo[index] = ret;\\n\\n    }\\n}; */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MIN);\\n        dp[n-1] = 0;\\n\\n        for(int i=n-2; i>=0; i--){\\n            for(int j=i+1; j<n; j++){\\n                int curr = abs(nums[i]-nums[j]);\\n                if(curr>target) continue;\\n                dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n        \\n        return dp[0]<0?-1:dp[0];\\n    }\\n};\\n/*\\n    dp[i]: the maximum steps jumping from i to n-1\\n\\n    dp[i] = max(dp[j]+1, dp[i]);\\n\\n\\n*/\\n\\n\\n\\n\\n/* class Solution {\\npublic:\\n    vector<int> memo;\\n    int maximumJumps(vector<int>& nums, int target) {\\n        memo.resize(nums.size(), -1);\\n        int res = dp(nums, target, 0);\\n        return res<0?-1:res;\\n    }\\n\\n\\n    int dp(vector<int>& nums, int target, int index){\\n        //basecase\\n        int n = nums.size();\\n        if(index==n-1){\\n            return 0;\\n        }\\n        if(memo[index]!=-1)\\n            return memo[index];\\n\\n        int ret = INT_MIN;\\n\\n        for(int next=index+1; next<n; next++){\\n            int curr = abs(nums[next]-nums[index]);\\n            if(curr>target) continue;\\n            ret = max(ret, 1 + dp(nums,target,next));\\n        }\\n\\n        return memo[index] = ret;\\n\\n    }\\n}; */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746398,
                "title": "two-loops-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& a, int t) {\\n        vector<int> jump(a.size(), -1);\\n        jump.back() = 0;\\n        for (int i = a.size() - 2; i>=0;--i) {\\n            int ans = INT_MIN;\\n            for (int j = i+1;j<a.size(); ++j) \\n                if (jump[j] != -1 && abs(a[i]-a[j]) <= t) ans = max(ans,1+jump[j]);\\n            jump[i] = (ans == INT_MIN) ? -1 : ans;\\n        }\\n        return jump[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& a, int t) {\\n        vector<int> jump(a.size(), -1);\\n        jump.back() = 0;\\n        for (int i = a.size() - 2; i>=0;--i) {\\n            int ans = INT_MIN;\\n            for (int j = i+1;j<a.size(); ++j) \\n                if (jump[j] != -1 && abs(a[i]-a[j]) <= t) ans = max(ans,1+jump[j]);\\n            jump[i] = (ans == INT_MIN) ? -1 : ans;\\n        }\\n        return jump[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746397,
                "title": "two-loops-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& a, int t) {\\n        vector<int> jump(a.size(), -1);\\n        jump.back() = 0;\\n        for (int i = a.size() - 2; i>=0;--i) {\\n            int ans = INT_MIN;\\n            for (int j = i+1;j<a.size(); ++j) \\n                if (jump[j] != -1 && abs(a[i]-a[j]) <= t) ans = max(ans,1+jump[j]);\\n            jump[i] = (ans == INT_MIN) ? -1 : ans;\\n        }\\n        return jump[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& a, int t) {\\n        vector<int> jump(a.size(), -1);\\n        jump.back() = 0;\\n        for (int i = a.size() - 2; i>=0;--i) {\\n            int ans = INT_MIN;\\n            for (int j = i+1;j<a.size(); ++j) \\n                if (jump[j] != -1 && abs(a[i]-a[j]) <= t) ans = max(ans,1+jump[j]);\\n            jump[i] = (ans == INT_MIN) ? -1 : ans;\\n        }\\n        return jump[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746396,
                "title": "two-loops-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& a, int t) {\\n        vector<int> jump(a.size(), -1);\\n        jump.back() = 0;\\n        for (int i = a.size() - 2; i>=0;--i) {\\n            int ans = INT_MIN;\\n            for (int j = i+1;j<a.size(); ++j) \\n                if (jump[j] != -1 && abs(a[i]-a[j]) <= t) ans = max(ans,1+jump[j]);\\n            jump[i] = (ans == INT_MIN) ? -1 : ans;\\n        }\\n        return jump[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& a, int t) {\\n        vector<int> jump(a.size(), -1);\\n        jump.back() = 0;\\n        for (int i = a.size() - 2; i>=0;--i) {\\n            int ans = INT_MIN;\\n            for (int j = i+1;j<a.size(); ++j) \\n                if (jump[j] != -1 && abs(a[i]-a[j]) <= t) ans = max(ans,1+jump[j]);\\n            jump[i] = (ans == INT_MIN) ? -1 : ans;\\n        }\\n        return jump[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746302,
                "title": "javascript-2770-maximum-number-of-jumps-to-reach-the-last-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar maximumJumps = function (a, target) {\\n  let n = a.length\\n\\n  let inmemory = {}\\n\\n  function search(i) {\\n    if (i in inmemory) return inmemory[i]\\n    if (i === (n - 1)) return inmemory[i] = 1\\n    if (i >= n) return inmemory[i] = 0\\n\\n    let maxcc = -Infinity\\n    for (let j = i + 1; j < n; j++) {\\n      if (\\n        (-target <= (a[j] - a[i])) &&\\n        ((a[j] - a[i]) <= target)\\n      ) {\\n        let cc = search(j)\\n        maxcc = Math.max(maxcc, 1 + cc)\\n      }\\n    }\\n    return inmemory[i] = maxcc\\n  }\\n\\n  let cc = search(0)\\n  return (cc === -Infinity) ? -1 : cc - 1\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumJumps = function (a, target) {\\n  let n = a.length\\n\\n  let inmemory = {}\\n\\n  function search(i) {\\n    if (i in inmemory) return inmemory[i]\\n    if (i === (n - 1)) return inmemory[i] = 1\\n    if (i >= n) return inmemory[i] = 0\\n\\n    let maxcc = -Infinity\\n    for (let j = i + 1; j < n; j++) {\\n      if (\\n        (-target <= (a[j] - a[i])) &&\\n        ((a[j] - a[i]) <= target)\\n      ) {\\n        let cc = search(j)\\n        maxcc = Math.max(maxcc, 1 + cc)\\n      }\\n    }\\n    return inmemory[i] = maxcc\\n  }\\n\\n  let cc = search(0)\\n  return (cc === -Infinity) ? -1 : cc - 1\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746086,
                "title": "dp-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumJumps(int[] a, int target) {\\n        int n = a.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (dp[i] >= 0 && Math.abs(a[j] - a[i]) <= target) {\\n                    dp[j] = Math.max(dp[j], dp[i] + 1);\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumJumps(int[] a, int target) {\\n        int n = a.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (dp[i] >= 0 && Math.abs(a[j] - a[i]) <= target) {\\n                    dp[j] = Math.max(dp[j], dp[i] + 1);\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746014,
                "title": "java-solution-easy-to-understand-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public int helper(int[] nums,int ind,int[] dp,int target){\\n        if(ind<=0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=ind-1;i>=0;i--){\\n            int val=Math.abs(nums[ind]-nums[i]);\\n            if(val<=target){\\n              max=Math.max(max,helper(nums,i,dp,target));\\n            }\\n        }\\n        if(max==Integer.MIN_VALUE)return dp[ind]=Integer.MIN_VALUE;\\n        return dp[ind]=max+1;\\n        \\n    }\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp=new int[nums.length+1];\\n        Arrays.fill(dp,-1);\\n        int ans=helper(nums,nums.length-1,dp,target);\\n        return ans==Integer.MIN_VALUE?-1:ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int helper(int[] nums,int ind,int[] dp,int target){\\n        if(ind<=0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=ind-1;i>=0;i--){\\n            int val=Math.abs(nums[ind]-nums[i]);\\n            if(val<=target){\\n              max=Math.max(max,helper(nums,i,dp,target));\\n            }\\n        }\\n        if(max==Integer.MIN_VALUE)return dp[ind]=Integer.MIN_VALUE;\\n        return dp[ind]=max+1;\\n        \\n    }\\n    public int maximumJumps(int[] nums, int target) {\\n        int[] dp=new int[nums.length+1];\\n        Arrays.fill(dp,-1);\\n        int ans=helper(nums,nums.length-1,dp,target);\\n        return ans==Integer.MIN_VALUE?-1:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745956,
                "title": "python-iterative-dp",
                "content": "# Approach\\nStart by setting up your dp array, which here is an array of 0s, the same length as the input nums array.  Perform the two loops as is standard with dp:\\n\\\\- Iterate through indices j=1..n (where n is the length of the nums array)\\n\\\\- Iterate through indices i=j-1..0 (decreasing sequence)\\n\\nFor each j and i pair, compare nums[j] and nums[i] to ensure the difference is within the target.  This solution uses the absolute value of the difference (```abs(nums[j] - nums[i]) <= target```) which is equivalent to the comparison in the problem statement.  If that\\'s true, perform one more check whether i, the starting index of a jump, is 0 (the overall starting index) or not.\\n\\\\- If the i index is 0: take the max of dp[i] + 1 and dp[j], which is the greater of jumping from that i index, or taking the current best route.\\n\\\\- If the i index is > 0, check that dp[i] > 0 as well.  This check is done because we can\\'t jump from index i to index j if we can\\'t reach index i in the first place (starting at index 0), so dp[i] + 1 will lead to false results.  If that dp[i] check passes, perform the same dp comparison as above.\\n\\nOnce the loops are complete, the final index (dp[-1]) will contain the maximum # of jumps to reach that final index.  If dp[-1] is 0, that indicates an impossible array where the final index cannot be reached, so return -1.  Otherwise, return dp[-1].\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        for j in range(1, n):\\n            for i in range(j - 1, -1, -1):\\n                if abs(nums[j] - nums[i]) <= target:\\n                    if i == 0:\\n                        dp[j] = max(dp[i] + 1, dp[j])\\n                    elif dp[i] > 0:\\n                        dp[j] = max(dp[i] + 1, dp[j])\\n        \\n        if dp[-1] == 0:\\n            return -1\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```abs(nums[j] - nums[i]) <= target```\n```\\nclass Solution:\\n    def maximumJumps(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        for j in range(1, n):\\n            for i in range(j - 1, -1, -1):\\n                if abs(nums[j] - nums[i]) <= target:\\n                    if i == 0:\\n                        dp[j] = max(dp[i] + 1, dp[j])\\n                    elif dp[i] > 0:\\n                        dp[j] = max(dp[i] + 1, dp[j])\\n        \\n        if dp[-1] == 0:\\n            return -1\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1962755,
                "content": [
                    {
                        "username": "Srinivasa_07",
                        "content": "Is this problem cant be solved with out using dynamic programming?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "[@imninad_99](/imninad_99) fails for [1,0,2] test case"
                    },
                    {
                        "username": "imninad_99",
                        "content": "yes....\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "luismendes070",
                        "content": "// https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3749638/maximum-number-of-jumps/\\nclass Solution {\\nfun maximumJumps(nums: IntArray, target: Int): Int {\\n    val dp = IntArray(nums.size)\\n    dp[0] = 0\\n    for (i in 1 until nums.size) {\\n        dp[i] = 0\\n        for (j in i - 1 downTo 0) {\\n            val k = nums[j] - nums[i]\\n            if (k in -target..target) {\\n                if (j == 0 || dp[j] != 0) {\\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\\n                }\\n            }\\n        }\\n    }\\n    return if (dp[nums.size - 1] == 0) -1 else dp[nums.size - 1]\\n}\\n\\nfun max(i: Int, j: Int): Int {\\n    return if (i > j) i else j\\n}\\n\\n}"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    static int n;\\n    public static int calc(int i,int tar,int arr[],int dp[]){\\n       //System.out.println(\"I entered \"+i+\" i.e \"+arr[i]+\" currently count is \"+cnt);\\n        if(i==n){\\n            return dp[i]=0;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1;\\n        for(int j=i+1;j<=n;j++){\\n            if(Math.abs(arr[j]-arr[i])<=tar){\\n              //  System.out.println(\"The difference is \"+(arr[j]-arr[i])+\" tar is \"+tar);\\n                int temp=1+calc(j,tar,arr,dp);\\n                if(temp!=0)\\n                ans=Math.max(ans,temp);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    public int maximumJumps(int[] arr, int tar) {\\n     n=arr.length-1;\\n     int dp[] = new int[n+1];\\n     for(int i=0;i<=n;i++){\\n         dp[i]=-1;\\n     }   \\n     return calc(0,tar,arr,dp);\\n    }\\n}\\n\\n\\n\\nthis code is passing 2625/2639 cases but showing tle afterwards can anyone please help me ;("
                    },
                    {
                        "username": "neilnaveen",
                        "content": "I have implemented dp, and I really don't know why this is not working. I am writing code in golang\n\nLink to code : https://go.dev/play/p/nw9dPGSAiDF\n\n"
                    },
                    {
                        "username": "imninad_99",
                        "content": "what is wrong in this code ... please can anyone tell me.\\n\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Greedy approach does not always give the best result here.\nFor example: nums = `[0,2,-2,-1,0]`, target = `2`\nIt will take the first found route 0 -> 2 > 0 instead of 0 -> -2 -> -1 -> 0"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "when i = 0, j = 1, cnt ++\\nbut when i = 0, j = 2, 3, 4 (index which satisfy condition) cnt also ++\\n\\nbut the thing is that i can jump to either 1 2 3 or 4\\nbut you add them together thus wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it was a 2Q DP contest"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "You can use 1d dp"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Someone Please help me Memoize this Top - Down Approach.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSteps = 0;\\n    \\n    void dfs(vector<int>& nums, int target , int index , int steps){\\n        \\n        if(index == nums.size()-1){\\n            \\n            maxSteps = max(maxSteps , steps);\\n            \\n            return;\\n\\n        }\\n        \\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                dfs(nums , target , i , steps+1);\\n            }\\n             \\n        }    \\n        \\n    }\\n \\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        dfs(nums , target , 0 , 0);\\n        \\n        return maxSteps == 0 ? -1 : maxSteps;\\n  \\n    }\\n};\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Your recursive code is working fine. But you need to optimize the code as it is giving tle on larger test cases. Use memoization or tabulation to improve the time complexity."
                    },
                    {
                        "username": "bssrdf",
                        "content": "I don\\'t use C++ much but this memorization seems working \\n```\\nclass Solution {\\npublic:\\n\\n    int inf = -9999;\\n    vector<int> memo = vector<int>(1001, inf); \\n    int dfs(vector<int>& nums, int target , int index){\\n        \\n        if(index == nums.size()-1){           \\n            \\n            return 0;\\n\\n        }\\n        if (memo[index] != inf){\\n            return memo[index];\\n        }\\n\\n        int ret = -1;\\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                int t = dfs(nums, target, i);\\n                if (t >= 0)\\n                   ret = max(ret, 1+t);\\n            }\\n             \\n        }    \\n        memo[index] = ret;\\n        return memo[index];\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return dfs(nums, target, 0);        \\n\\n        \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2004805,
                "content": [
                    {
                        "username": "Srinivasa_07",
                        "content": "Is this problem cant be solved with out using dynamic programming?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "[@imninad_99](/imninad_99) fails for [1,0,2] test case"
                    },
                    {
                        "username": "imninad_99",
                        "content": "yes....\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "luismendes070",
                        "content": "// https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3749638/maximum-number-of-jumps/\\nclass Solution {\\nfun maximumJumps(nums: IntArray, target: Int): Int {\\n    val dp = IntArray(nums.size)\\n    dp[0] = 0\\n    for (i in 1 until nums.size) {\\n        dp[i] = 0\\n        for (j in i - 1 downTo 0) {\\n            val k = nums[j] - nums[i]\\n            if (k in -target..target) {\\n                if (j == 0 || dp[j] != 0) {\\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\\n                }\\n            }\\n        }\\n    }\\n    return if (dp[nums.size - 1] == 0) -1 else dp[nums.size - 1]\\n}\\n\\nfun max(i: Int, j: Int): Int {\\n    return if (i > j) i else j\\n}\\n\\n}"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    static int n;\\n    public static int calc(int i,int tar,int arr[],int dp[]){\\n       //System.out.println(\"I entered \"+i+\" i.e \"+arr[i]+\" currently count is \"+cnt);\\n        if(i==n){\\n            return dp[i]=0;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1;\\n        for(int j=i+1;j<=n;j++){\\n            if(Math.abs(arr[j]-arr[i])<=tar){\\n              //  System.out.println(\"The difference is \"+(arr[j]-arr[i])+\" tar is \"+tar);\\n                int temp=1+calc(j,tar,arr,dp);\\n                if(temp!=0)\\n                ans=Math.max(ans,temp);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    public int maximumJumps(int[] arr, int tar) {\\n     n=arr.length-1;\\n     int dp[] = new int[n+1];\\n     for(int i=0;i<=n;i++){\\n         dp[i]=-1;\\n     }   \\n     return calc(0,tar,arr,dp);\\n    }\\n}\\n\\n\\n\\nthis code is passing 2625/2639 cases but showing tle afterwards can anyone please help me ;("
                    },
                    {
                        "username": "neilnaveen",
                        "content": "I have implemented dp, and I really don't know why this is not working. I am writing code in golang\n\nLink to code : https://go.dev/play/p/nw9dPGSAiDF\n\n"
                    },
                    {
                        "username": "imninad_99",
                        "content": "what is wrong in this code ... please can anyone tell me.\\n\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Greedy approach does not always give the best result here.\nFor example: nums = `[0,2,-2,-1,0]`, target = `2`\nIt will take the first found route 0 -> 2 > 0 instead of 0 -> -2 -> -1 -> 0"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "when i = 0, j = 1, cnt ++\\nbut when i = 0, j = 2, 3, 4 (index which satisfy condition) cnt also ++\\n\\nbut the thing is that i can jump to either 1 2 3 or 4\\nbut you add them together thus wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it was a 2Q DP contest"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "You can use 1d dp"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Someone Please help me Memoize this Top - Down Approach.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSteps = 0;\\n    \\n    void dfs(vector<int>& nums, int target , int index , int steps){\\n        \\n        if(index == nums.size()-1){\\n            \\n            maxSteps = max(maxSteps , steps);\\n            \\n            return;\\n\\n        }\\n        \\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                dfs(nums , target , i , steps+1);\\n            }\\n             \\n        }    \\n        \\n    }\\n \\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        dfs(nums , target , 0 , 0);\\n        \\n        return maxSteps == 0 ? -1 : maxSteps;\\n  \\n    }\\n};\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Your recursive code is working fine. But you need to optimize the code as it is giving tle on larger test cases. Use memoization or tabulation to improve the time complexity."
                    },
                    {
                        "username": "bssrdf",
                        "content": "I don\\'t use C++ much but this memorization seems working \\n```\\nclass Solution {\\npublic:\\n\\n    int inf = -9999;\\n    vector<int> memo = vector<int>(1001, inf); \\n    int dfs(vector<int>& nums, int target , int index){\\n        \\n        if(index == nums.size()-1){           \\n            \\n            return 0;\\n\\n        }\\n        if (memo[index] != inf){\\n            return memo[index];\\n        }\\n\\n        int ret = -1;\\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                int t = dfs(nums, target, i);\\n                if (t >= 0)\\n                   ret = max(ret, 1+t);\\n            }\\n             \\n        }    \\n        memo[index] = ret;\\n        return memo[index];\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return dfs(nums, target, 0);        \\n\\n        \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2002516,
                "content": [
                    {
                        "username": "Srinivasa_07",
                        "content": "Is this problem cant be solved with out using dynamic programming?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "[@imninad_99](/imninad_99) fails for [1,0,2] test case"
                    },
                    {
                        "username": "imninad_99",
                        "content": "yes....\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "luismendes070",
                        "content": "// https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3749638/maximum-number-of-jumps/\\nclass Solution {\\nfun maximumJumps(nums: IntArray, target: Int): Int {\\n    val dp = IntArray(nums.size)\\n    dp[0] = 0\\n    for (i in 1 until nums.size) {\\n        dp[i] = 0\\n        for (j in i - 1 downTo 0) {\\n            val k = nums[j] - nums[i]\\n            if (k in -target..target) {\\n                if (j == 0 || dp[j] != 0) {\\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\\n                }\\n            }\\n        }\\n    }\\n    return if (dp[nums.size - 1] == 0) -1 else dp[nums.size - 1]\\n}\\n\\nfun max(i: Int, j: Int): Int {\\n    return if (i > j) i else j\\n}\\n\\n}"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    static int n;\\n    public static int calc(int i,int tar,int arr[],int dp[]){\\n       //System.out.println(\"I entered \"+i+\" i.e \"+arr[i]+\" currently count is \"+cnt);\\n        if(i==n){\\n            return dp[i]=0;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1;\\n        for(int j=i+1;j<=n;j++){\\n            if(Math.abs(arr[j]-arr[i])<=tar){\\n              //  System.out.println(\"The difference is \"+(arr[j]-arr[i])+\" tar is \"+tar);\\n                int temp=1+calc(j,tar,arr,dp);\\n                if(temp!=0)\\n                ans=Math.max(ans,temp);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    public int maximumJumps(int[] arr, int tar) {\\n     n=arr.length-1;\\n     int dp[] = new int[n+1];\\n     for(int i=0;i<=n;i++){\\n         dp[i]=-1;\\n     }   \\n     return calc(0,tar,arr,dp);\\n    }\\n}\\n\\n\\n\\nthis code is passing 2625/2639 cases but showing tle afterwards can anyone please help me ;("
                    },
                    {
                        "username": "neilnaveen",
                        "content": "I have implemented dp, and I really don't know why this is not working. I am writing code in golang\n\nLink to code : https://go.dev/play/p/nw9dPGSAiDF\n\n"
                    },
                    {
                        "username": "imninad_99",
                        "content": "what is wrong in this code ... please can anyone tell me.\\n\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Greedy approach does not always give the best result here.\nFor example: nums = `[0,2,-2,-1,0]`, target = `2`\nIt will take the first found route 0 -> 2 > 0 instead of 0 -> -2 -> -1 -> 0"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "when i = 0, j = 1, cnt ++\\nbut when i = 0, j = 2, 3, 4 (index which satisfy condition) cnt also ++\\n\\nbut the thing is that i can jump to either 1 2 3 or 4\\nbut you add them together thus wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it was a 2Q DP contest"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "You can use 1d dp"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Someone Please help me Memoize this Top - Down Approach.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSteps = 0;\\n    \\n    void dfs(vector<int>& nums, int target , int index , int steps){\\n        \\n        if(index == nums.size()-1){\\n            \\n            maxSteps = max(maxSteps , steps);\\n            \\n            return;\\n\\n        }\\n        \\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                dfs(nums , target , i , steps+1);\\n            }\\n             \\n        }    \\n        \\n    }\\n \\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        dfs(nums , target , 0 , 0);\\n        \\n        return maxSteps == 0 ? -1 : maxSteps;\\n  \\n    }\\n};\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Your recursive code is working fine. But you need to optimize the code as it is giving tle on larger test cases. Use memoization or tabulation to improve the time complexity."
                    },
                    {
                        "username": "bssrdf",
                        "content": "I don\\'t use C++ much but this memorization seems working \\n```\\nclass Solution {\\npublic:\\n\\n    int inf = -9999;\\n    vector<int> memo = vector<int>(1001, inf); \\n    int dfs(vector<int>& nums, int target , int index){\\n        \\n        if(index == nums.size()-1){           \\n            \\n            return 0;\\n\\n        }\\n        if (memo[index] != inf){\\n            return memo[index];\\n        }\\n\\n        int ret = -1;\\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                int t = dfs(nums, target, i);\\n                if (t >= 0)\\n                   ret = max(ret, 1+t);\\n            }\\n             \\n        }    \\n        memo[index] = ret;\\n        return memo[index];\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return dfs(nums, target, 0);        \\n\\n        \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1963364,
                "content": [
                    {
                        "username": "Srinivasa_07",
                        "content": "Is this problem cant be solved with out using dynamic programming?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "[@imninad_99](/imninad_99) fails for [1,0,2] test case"
                    },
                    {
                        "username": "imninad_99",
                        "content": "yes....\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "luismendes070",
                        "content": "// https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3749638/maximum-number-of-jumps/\\nclass Solution {\\nfun maximumJumps(nums: IntArray, target: Int): Int {\\n    val dp = IntArray(nums.size)\\n    dp[0] = 0\\n    for (i in 1 until nums.size) {\\n        dp[i] = 0\\n        for (j in i - 1 downTo 0) {\\n            val k = nums[j] - nums[i]\\n            if (k in -target..target) {\\n                if (j == 0 || dp[j] != 0) {\\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\\n                }\\n            }\\n        }\\n    }\\n    return if (dp[nums.size - 1] == 0) -1 else dp[nums.size - 1]\\n}\\n\\nfun max(i: Int, j: Int): Int {\\n    return if (i > j) i else j\\n}\\n\\n}"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    static int n;\\n    public static int calc(int i,int tar,int arr[],int dp[]){\\n       //System.out.println(\"I entered \"+i+\" i.e \"+arr[i]+\" currently count is \"+cnt);\\n        if(i==n){\\n            return dp[i]=0;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1;\\n        for(int j=i+1;j<=n;j++){\\n            if(Math.abs(arr[j]-arr[i])<=tar){\\n              //  System.out.println(\"The difference is \"+(arr[j]-arr[i])+\" tar is \"+tar);\\n                int temp=1+calc(j,tar,arr,dp);\\n                if(temp!=0)\\n                ans=Math.max(ans,temp);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    public int maximumJumps(int[] arr, int tar) {\\n     n=arr.length-1;\\n     int dp[] = new int[n+1];\\n     for(int i=0;i<=n;i++){\\n         dp[i]=-1;\\n     }   \\n     return calc(0,tar,arr,dp);\\n    }\\n}\\n\\n\\n\\nthis code is passing 2625/2639 cases but showing tle afterwards can anyone please help me ;("
                    },
                    {
                        "username": "neilnaveen",
                        "content": "I have implemented dp, and I really don't know why this is not working. I am writing code in golang\n\nLink to code : https://go.dev/play/p/nw9dPGSAiDF\n\n"
                    },
                    {
                        "username": "imninad_99",
                        "content": "what is wrong in this code ... please can anyone tell me.\\n\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Greedy approach does not always give the best result here.\nFor example: nums = `[0,2,-2,-1,0]`, target = `2`\nIt will take the first found route 0 -> 2 > 0 instead of 0 -> -2 -> -1 -> 0"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "when i = 0, j = 1, cnt ++\\nbut when i = 0, j = 2, 3, 4 (index which satisfy condition) cnt also ++\\n\\nbut the thing is that i can jump to either 1 2 3 or 4\\nbut you add them together thus wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it was a 2Q DP contest"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "You can use 1d dp"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Someone Please help me Memoize this Top - Down Approach.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSteps = 0;\\n    \\n    void dfs(vector<int>& nums, int target , int index , int steps){\\n        \\n        if(index == nums.size()-1){\\n            \\n            maxSteps = max(maxSteps , steps);\\n            \\n            return;\\n\\n        }\\n        \\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                dfs(nums , target , i , steps+1);\\n            }\\n             \\n        }    \\n        \\n    }\\n \\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        dfs(nums , target , 0 , 0);\\n        \\n        return maxSteps == 0 ? -1 : maxSteps;\\n  \\n    }\\n};\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Your recursive code is working fine. But you need to optimize the code as it is giving tle on larger test cases. Use memoization or tabulation to improve the time complexity."
                    },
                    {
                        "username": "bssrdf",
                        "content": "I don\\'t use C++ much but this memorization seems working \\n```\\nclass Solution {\\npublic:\\n\\n    int inf = -9999;\\n    vector<int> memo = vector<int>(1001, inf); \\n    int dfs(vector<int>& nums, int target , int index){\\n        \\n        if(index == nums.size()-1){           \\n            \\n            return 0;\\n\\n        }\\n        if (memo[index] != inf){\\n            return memo[index];\\n        }\\n\\n        int ret = -1;\\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                int t = dfs(nums, target, i);\\n                if (t >= 0)\\n                   ret = max(ret, 1+t);\\n            }\\n             \\n        }    \\n        memo[index] = ret;\\n        return memo[index];\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return dfs(nums, target, 0);        \\n\\n        \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1963173,
                "content": [
                    {
                        "username": "Srinivasa_07",
                        "content": "Is this problem cant be solved with out using dynamic programming?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "[@imninad_99](/imninad_99) fails for [1,0,2] test case"
                    },
                    {
                        "username": "imninad_99",
                        "content": "yes....\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "luismendes070",
                        "content": "// https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3749638/maximum-number-of-jumps/\\nclass Solution {\\nfun maximumJumps(nums: IntArray, target: Int): Int {\\n    val dp = IntArray(nums.size)\\n    dp[0] = 0\\n    for (i in 1 until nums.size) {\\n        dp[i] = 0\\n        for (j in i - 1 downTo 0) {\\n            val k = nums[j] - nums[i]\\n            if (k in -target..target) {\\n                if (j == 0 || dp[j] != 0) {\\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\\n                }\\n            }\\n        }\\n    }\\n    return if (dp[nums.size - 1] == 0) -1 else dp[nums.size - 1]\\n}\\n\\nfun max(i: Int, j: Int): Int {\\n    return if (i > j) i else j\\n}\\n\\n}"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    static int n;\\n    public static int calc(int i,int tar,int arr[],int dp[]){\\n       //System.out.println(\"I entered \"+i+\" i.e \"+arr[i]+\" currently count is \"+cnt);\\n        if(i==n){\\n            return dp[i]=0;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1;\\n        for(int j=i+1;j<=n;j++){\\n            if(Math.abs(arr[j]-arr[i])<=tar){\\n              //  System.out.println(\"The difference is \"+(arr[j]-arr[i])+\" tar is \"+tar);\\n                int temp=1+calc(j,tar,arr,dp);\\n                if(temp!=0)\\n                ans=Math.max(ans,temp);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    public int maximumJumps(int[] arr, int tar) {\\n     n=arr.length-1;\\n     int dp[] = new int[n+1];\\n     for(int i=0;i<=n;i++){\\n         dp[i]=-1;\\n     }   \\n     return calc(0,tar,arr,dp);\\n    }\\n}\\n\\n\\n\\nthis code is passing 2625/2639 cases but showing tle afterwards can anyone please help me ;("
                    },
                    {
                        "username": "neilnaveen",
                        "content": "I have implemented dp, and I really don't know why this is not working. I am writing code in golang\n\nLink to code : https://go.dev/play/p/nw9dPGSAiDF\n\n"
                    },
                    {
                        "username": "imninad_99",
                        "content": "what is wrong in this code ... please can anyone tell me.\\n\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Greedy approach does not always give the best result here.\nFor example: nums = `[0,2,-2,-1,0]`, target = `2`\nIt will take the first found route 0 -> 2 > 0 instead of 0 -> -2 -> -1 -> 0"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "when i = 0, j = 1, cnt ++\\nbut when i = 0, j = 2, 3, 4 (index which satisfy condition) cnt also ++\\n\\nbut the thing is that i can jump to either 1 2 3 or 4\\nbut you add them together thus wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it was a 2Q DP contest"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "You can use 1d dp"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Someone Please help me Memoize this Top - Down Approach.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSteps = 0;\\n    \\n    void dfs(vector<int>& nums, int target , int index , int steps){\\n        \\n        if(index == nums.size()-1){\\n            \\n            maxSteps = max(maxSteps , steps);\\n            \\n            return;\\n\\n        }\\n        \\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                dfs(nums , target , i , steps+1);\\n            }\\n             \\n        }    \\n        \\n    }\\n \\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        dfs(nums , target , 0 , 0);\\n        \\n        return maxSteps == 0 ? -1 : maxSteps;\\n  \\n    }\\n};\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Your recursive code is working fine. But you need to optimize the code as it is giving tle on larger test cases. Use memoization or tabulation to improve the time complexity."
                    },
                    {
                        "username": "bssrdf",
                        "content": "I don\\'t use C++ much but this memorization seems working \\n```\\nclass Solution {\\npublic:\\n\\n    int inf = -9999;\\n    vector<int> memo = vector<int>(1001, inf); \\n    int dfs(vector<int>& nums, int target , int index){\\n        \\n        if(index == nums.size()-1){           \\n            \\n            return 0;\\n\\n        }\\n        if (memo[index] != inf){\\n            return memo[index];\\n        }\\n\\n        int ret = -1;\\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                int t = dfs(nums, target, i);\\n                if (t >= 0)\\n                   ret = max(ret, 1+t);\\n            }\\n             \\n        }    \\n        memo[index] = ret;\\n        return memo[index];\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return dfs(nums, target, 0);        \\n\\n        \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1962789,
                "content": [
                    {
                        "username": "Srinivasa_07",
                        "content": "Is this problem cant be solved with out using dynamic programming?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "[@imninad_99](/imninad_99) fails for [1,0,2] test case"
                    },
                    {
                        "username": "imninad_99",
                        "content": "yes....\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "luismendes070",
                        "content": "// https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3749638/maximum-number-of-jumps/\\nclass Solution {\\nfun maximumJumps(nums: IntArray, target: Int): Int {\\n    val dp = IntArray(nums.size)\\n    dp[0] = 0\\n    for (i in 1 until nums.size) {\\n        dp[i] = 0\\n        for (j in i - 1 downTo 0) {\\n            val k = nums[j] - nums[i]\\n            if (k in -target..target) {\\n                if (j == 0 || dp[j] != 0) {\\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\\n                }\\n            }\\n        }\\n    }\\n    return if (dp[nums.size - 1] == 0) -1 else dp[nums.size - 1]\\n}\\n\\nfun max(i: Int, j: Int): Int {\\n    return if (i > j) i else j\\n}\\n\\n}"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    static int n;\\n    public static int calc(int i,int tar,int arr[],int dp[]){\\n       //System.out.println(\"I entered \"+i+\" i.e \"+arr[i]+\" currently count is \"+cnt);\\n        if(i==n){\\n            return dp[i]=0;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1;\\n        for(int j=i+1;j<=n;j++){\\n            if(Math.abs(arr[j]-arr[i])<=tar){\\n              //  System.out.println(\"The difference is \"+(arr[j]-arr[i])+\" tar is \"+tar);\\n                int temp=1+calc(j,tar,arr,dp);\\n                if(temp!=0)\\n                ans=Math.max(ans,temp);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    public int maximumJumps(int[] arr, int tar) {\\n     n=arr.length-1;\\n     int dp[] = new int[n+1];\\n     for(int i=0;i<=n;i++){\\n         dp[i]=-1;\\n     }   \\n     return calc(0,tar,arr,dp);\\n    }\\n}\\n\\n\\n\\nthis code is passing 2625/2639 cases but showing tle afterwards can anyone please help me ;("
                    },
                    {
                        "username": "neilnaveen",
                        "content": "I have implemented dp, and I really don't know why this is not working. I am writing code in golang\n\nLink to code : https://go.dev/play/p/nw9dPGSAiDF\n\n"
                    },
                    {
                        "username": "imninad_99",
                        "content": "what is wrong in this code ... please can anyone tell me.\\n\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Greedy approach does not always give the best result here.\nFor example: nums = `[0,2,-2,-1,0]`, target = `2`\nIt will take the first found route 0 -> 2 > 0 instead of 0 -> -2 -> -1 -> 0"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "when i = 0, j = 1, cnt ++\\nbut when i = 0, j = 2, 3, 4 (index which satisfy condition) cnt also ++\\n\\nbut the thing is that i can jump to either 1 2 3 or 4\\nbut you add them together thus wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it was a 2Q DP contest"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "You can use 1d dp"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Someone Please help me Memoize this Top - Down Approach.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSteps = 0;\\n    \\n    void dfs(vector<int>& nums, int target , int index , int steps){\\n        \\n        if(index == nums.size()-1){\\n            \\n            maxSteps = max(maxSteps , steps);\\n            \\n            return;\\n\\n        }\\n        \\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                dfs(nums , target , i , steps+1);\\n            }\\n             \\n        }    \\n        \\n    }\\n \\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        dfs(nums , target , 0 , 0);\\n        \\n        return maxSteps == 0 ? -1 : maxSteps;\\n  \\n    }\\n};\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Your recursive code is working fine. But you need to optimize the code as it is giving tle on larger test cases. Use memoization or tabulation to improve the time complexity."
                    },
                    {
                        "username": "bssrdf",
                        "content": "I don\\'t use C++ much but this memorization seems working \\n```\\nclass Solution {\\npublic:\\n\\n    int inf = -9999;\\n    vector<int> memo = vector<int>(1001, inf); \\n    int dfs(vector<int>& nums, int target , int index){\\n        \\n        if(index == nums.size()-1){           \\n            \\n            return 0;\\n\\n        }\\n        if (memo[index] != inf){\\n            return memo[index];\\n        }\\n\\n        int ret = -1;\\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                int t = dfs(nums, target, i);\\n                if (t >= 0)\\n                   ret = max(ret, 1+t);\\n            }\\n             \\n        }    \\n        memo[index] = ret;\\n        return memo[index];\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return dfs(nums, target, 0);        \\n\\n        \\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1962726,
                "content": [
                    {
                        "username": "Srinivasa_07",
                        "content": "Is this problem cant be solved with out using dynamic programming?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "[@imninad_99](/imninad_99) fails for [1,0,2] test case"
                    },
                    {
                        "username": "imninad_99",
                        "content": "yes....\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "luismendes070",
                        "content": "// https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/solutions/3749638/maximum-number-of-jumps/\\nclass Solution {\\nfun maximumJumps(nums: IntArray, target: Int): Int {\\n    val dp = IntArray(nums.size)\\n    dp[0] = 0\\n    for (i in 1 until nums.size) {\\n        dp[i] = 0\\n        for (j in i - 1 downTo 0) {\\n            val k = nums[j] - nums[i]\\n            if (k in -target..target) {\\n                if (j == 0 || dp[j] != 0) {\\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\\n                }\\n            }\\n        }\\n    }\\n    return if (dp[nums.size - 1] == 0) -1 else dp[nums.size - 1]\\n}\\n\\nfun max(i: Int, j: Int): Int {\\n    return if (i > j) i else j\\n}\\n\\n}"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    static int n;\\n    public static int calc(int i,int tar,int arr[],int dp[]){\\n       //System.out.println(\"I entered \"+i+\" i.e \"+arr[i]+\" currently count is \"+cnt);\\n        if(i==n){\\n            return dp[i]=0;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=-1;\\n        for(int j=i+1;j<=n;j++){\\n            if(Math.abs(arr[j]-arr[i])<=tar){\\n              //  System.out.println(\"The difference is \"+(arr[j]-arr[i])+\" tar is \"+tar);\\n                int temp=1+calc(j,tar,arr,dp);\\n                if(temp!=0)\\n                ans=Math.max(ans,temp);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n\\n    public int maximumJumps(int[] arr, int tar) {\\n     n=arr.length-1;\\n     int dp[] = new int[n+1];\\n     for(int i=0;i<=n;i++){\\n         dp[i]=-1;\\n     }   \\n     return calc(0,tar,arr,dp);\\n    }\\n}\\n\\n\\n\\nthis code is passing 2625/2639 cases but showing tle afterwards can anyone please help me ;("
                    },
                    {
                        "username": "neilnaveen",
                        "content": "I have implemented dp, and I really don't know why this is not working. I am writing code in golang\n\nLink to code : https://go.dev/play/p/nw9dPGSAiDF\n\n"
                    },
                    {
                        "username": "imninad_99",
                        "content": "what is wrong in this code ... please can anyone tell me.\\n\\nclass Solution {\\npublic:\\n    int maximumJumps(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(abs(nums[j]-nums[i])<=target){\\n                    cnt++;\\n                    i =j;\\n                    if(j==(n-1)){\\n                        return cnt;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Greedy approach does not always give the best result here.\nFor example: nums = `[0,2,-2,-1,0]`, target = `2`\nIt will take the first found route 0 -> 2 > 0 instead of 0 -> -2 -> -1 -> 0"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "when i = 0, j = 1, cnt ++\\nbut when i = 0, j = 2, 3, 4 (index which satisfy condition) cnt also ++\\n\\nbut the thing is that i can jump to either 1 2 3 or 4\\nbut you add them together thus wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it was a 2Q DP contest"
                    },
                    {
                        "username": "Shashank_008",
                        "content": "You can use 1d dp"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Someone Please help me Memoize this Top - Down Approach.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSteps = 0;\\n    \\n    void dfs(vector<int>& nums, int target , int index , int steps){\\n        \\n        if(index == nums.size()-1){\\n            \\n            maxSteps = max(maxSteps , steps);\\n            \\n            return;\\n\\n        }\\n        \\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                dfs(nums , target , i , steps+1);\\n            }\\n             \\n        }    \\n        \\n    }\\n \\n    int maximumJumps(vector<int>& nums, int target) {\\n        \\n        dfs(nums , target , 0 , 0);\\n        \\n        return maxSteps == 0 ? -1 : maxSteps;\\n  \\n    }\\n};\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Your recursive code is working fine. But you need to optimize the code as it is giving tle on larger test cases. Use memoization or tabulation to improve the time complexity."
                    },
                    {
                        "username": "bssrdf",
                        "content": "I don\\'t use C++ much but this memorization seems working \\n```\\nclass Solution {\\npublic:\\n\\n    int inf = -9999;\\n    vector<int> memo = vector<int>(1001, inf); \\n    int dfs(vector<int>& nums, int target , int index){\\n        \\n        if(index == nums.size()-1){           \\n            \\n            return 0;\\n\\n        }\\n        if (memo[index] != inf){\\n            return memo[index];\\n        }\\n\\n        int ret = -1;\\n        \\n        for(int i= index + 1; i<nums.size() ; i++){\\n            \\n            int diff = abs(nums[index]- nums[i]);\\n            \\n            // If this diff is possible\\n            \\n            if(diff <= target){\\n                int t = dfs(nums, target, i);\\n                if (t >= 0)\\n                   ret = max(ret, 1+t);\\n            }\\n             \\n        }    \\n        memo[index] = ret;\\n        return memo[index];\\n        \\n    }\\n    int maximumJumps(vector<int>& nums, int target) {\\n        return dfs(nums, target, 0);        \\n\\n        \\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    }
]