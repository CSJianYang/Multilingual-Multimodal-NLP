[
    {
        "title": "Customers Who Bought All Products",
        "question_content": "Table: Customer\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| customer_id | int     |\n| product_key | int     |\n+-------------+---------+\nThis table may contain duplicates rows. \ncustomer_id is not NULL.\nproduct_key is a foreign key (reference column) to Product table.\n\n&nbsp;\nTable: Product\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_key | int     |\n+-------------+---------+\nproduct_key is the primary key (column with unique values) for this table.\n\n&nbsp;\nWrite a solution to report the customer ids from the Customer table that bought all the products in the Product table.\nReturn the result table in any order.\nThe&nbsp;result format is in the following example.\n&nbsp;\nExample 1:\n\nInput: \nCustomer table:\n+-------------+-------------+\n| customer_id | product_key |\n+-------------+-------------+\n| 1           | 5           |\n| 2           | 6           |\n| 3           | 5           |\n| 3           | 6           |\n| 1           | 6           |\n+-------------+-------------+\nProduct table:\n+-------------+\n| product_key |\n+-------------+\n| 5           |\n| 6           |\n+-------------+\nOutput: \n+-------------+\n| customer_id |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\nExplanation: \nThe customers who bought all the products (5 and 6) are customers with IDs 1 and 3.",
        "solutions": [
            {
                "id": 294748,
                "title": "mysql-subquery",
                "content": "```\\nselect customer_id\\nfrom customer c\\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_id\\nfrom customer c\\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608247,
                "title": "simple-solution-with-two-line-query",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nTo find the customers who have bought all the products, we need to compare the distinct products bought by each customer with the total number of products available. If the counts match, it means the customer has bought all the products.\\n\\n# Approach\\n1. Select the customer_id from the Customer table.\\n1. Group the results by customer_id.\\n1. Apply a HAVING clause to filter out customers who have not bought all the products.\\n1. In the HAVING clause, use ***COUNT(DISTINCT product_key)*** to count the number of distinct product keys for each customer.\\n1. Compare this count with the total count of product keys in the Product table obtained through a subquery.\\n1. If the counts match, it means the customer has bought all the products.\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution depends on the size of the Customer and Product tables. Let\\'s assume there are n customers and m products. The counting of distinct product keys for each customer takes $$O(n)$$ time, and the subquery to count the total number of products takes $$O(m)$$ time. Therefore, the overall time complexity can be approximated as $$O(n + m)$$.\\n\\n- Space complexity:\\nThe space complexity of this solution is considered $$O(1)$$ or constant. It only requires a constant amount of additional space for storing intermediate results and the subquery. The space usage does not depend on the size of the input tables.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\'SELECT  customer_id FROM Customer GROUP BY customer_id\\nHAVING COUNT(distinct product_key) = (SELECT COUNT(product_key) FROM Product)\\'\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/9b775724-1c6b-46bb-8e7b-5f6f8be29f1c_1686125409.4786477.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\'SELECT  customer_id FROM Customer GROUP BY customer_id\\nHAVING COUNT(distinct product_key) = (SELECT COUNT(product_key) FROM Product)\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865452,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING \\n\\nCOUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/8277a962-a3d0-44d3-b441-e4bbae047a8b_1691212838.5783477.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING \\n\\nCOUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454314,
                "title": "most-posted-solutions-are-wrong",
                "content": "**Ignore my post if you only interested in getting your code pass the leetcode test, but not interested in how to do things right!!!**\\n\\n\\nMost solutions posted here have used \\'count distinct product_key\\'. However, this method **should NOT be considered as the correct answer**. For example, if the **Product** table contains **5 & 7** instead of **5 & 6**, using \\'count distinct product_key\\', you will still get results of customer_id **1 & 3**, which is definitely **WRONG!!!**\\n\\n![image](https://assets.leetcode.com/users/sophiesu0827/image_1576613740.png)\\n\\n**The correct procedures should be:**\\n1. do a **cartesian product** (**cross join** in MySQL) on all customer_id eg.1,2,3 from table Customer and all product_key from table \"Product \". \\n![image](https://assets.leetcode.com/users/sophiesu0827/image_1576613877.png)\\n\\n\\n2. find difference between table **Customer** and the **cartesian product**\\n![image](https://assets.leetcode.com/users/sophiesu0827/image_1576613041.png)\\n\\n3. list all customer_id not in the difference set (red row in the above table)\\n![image](https://assets.leetcode.com/users/sophiesu0827/image_1576614001.png)\\n\\n\\n\\n**MySQL code:**\\n\\n```\\nSELECT DISTINCT customer_id FROM Customer WHERE customer_id NOT IN (\\nSELECT customer_id FROM (\\nSELECT DISTINCT * FROM \\n(SELECT DISTINCT customer_id FROM Customer) C\\nCROSS JOIN Product P) C2\\nWHERE (customer_id,product_key) NOT IN (SELECT customer_id,product_key FROM Customer));\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT customer_id FROM Customer WHERE customer_id NOT IN (\\nSELECT customer_id FROM (\\nSELECT DISTINCT * FROM \\n(SELECT DISTINCT customer_id FROM Customer) C\\nCROSS JOIN Product P) C2\\nWHERE (customer_id,product_key) NOT IN (SELECT customer_id,product_key FROM Customer));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582358,
                "title": "sql-easy-to-understand-group-by-sum-distinct-subquery",
                "content": "# Intuition\\r\\nWe can first group by customer_ids and then check them with having.\\r\\n\\r\\nThe pass shows 2 different ways to achieve the two solutions.\\r\\n\\r\\n![image.png](https://assets.leetcode.com/users/images/8ebca5a0-4abf-40f7-b5e2-ea062298ee6a_1685536566.1817262.png)\\r\\n\\r\\n\\r\\n# First Solution\\r\\n```\\r\\nSELECT                                      \\r\\n    customer_id\\r\\nFROM Customer\\r\\nGROUP BY customer_id\\r\\nHAVING SUM(DISTINCT product_key) = (\\r\\n    SELECT\\r\\n        SUM(product_key)\\r\\n    FROM Product\\r\\n); \\r\\n```\\r\\n# Second Solution\\r\\n```\\r\\nselect \\r\\ncustomer_id\\r\\n#SubQuery Begin -->\\r\\nfrom (select \\r\\ncase \\r\\n     when count(distinct product_key) = (select count(product_key) from Product)\\r\\n         then  customer_id end as customer_id\\r\\nfrom Customer c\\r\\ngroup by customer_id)  as subquery\\r\\n# SubQuery --> End\\r\\nwhere customer_id is not null\\r\\n\\r\\n); \\r\\n```\\r\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\r\\nSELECT                                      \\r\\n    customer_id\\r\\nFROM Customer\\r\\nGROUP BY customer_id\\r\\nHAVING SUM(DISTINCT product_key) = (\\r\\n    SELECT\\r\\n        SUM(product_key)\\r\\n    FROM Product\\r\\n); \\r\\n```\n```\\r\\nselect \\r\\ncustomer_id\\r\\n#SubQuery Begin -->\\r\\nfrom (select \\r\\ncase \\r\\n     when count(distinct product_key) = (select count(product_key) from Product)\\r\\n         then  customer_id end as customer_id\\r\\nfrom Customer c\\r\\ngroup by customer_id)  as subquery\\r\\n# SubQuery --> End\\r\\nwhere customer_id is not null\\r\\n\\r\\n); \\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294657,
                "title": "simple-mysql-solution",
                "content": "Simple join and group by, followed by selecting customers whose unique(distinct) product bought count is equal to total number of products in product table.\\n\\n```\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct(product_key)) = (select count(product_key) from Product)\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct(product_key)) = (select count(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349171,
                "title": "robust-simple-answer",
                "content": "```sql\\nselect customer_id\\nfrom Customer \\nwhere product_key in (select distinct product_key from Product)\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from product);\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect customer_id\\nfrom Customer \\nwhere product_key in (select distinct product_key from Product)\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940533,
                "title": "i-don-t-like-joins-so-here-you-go-4-liner-having-solution",
                "content": "select customer_id\\nfrom Customer\\ngroup by 1\\nhaving count(distinct product_key) = (select count(distinct product_key)  from Product)",
                "solutionTags": [],
                "code": "select customer_id\\nfrom Customer\\ngroup by 1\\nhaving count(distinct product_key) = (select count(distinct product_key)  from Product)",
                "codeTag": "Unknown"
            },
            {
                "id": 1097414,
                "title": "using-group-concat-from-accurate-results",
                "content": "```\\nWITH c as (SELECT customer_id, \\nGROUP_CONCAT(DISTINCT product_key \\n                     order by product_key\\n                     separator \\',\\') as products\\nFROM Customer\\nGROUP BY customer_id),\\np as (\\nSELECT \\nGROUP_CONCAT(DISTINCT product_key \\n\\t\\t\\t\\torder by product_key\\n                 separator \\',\\') as uni_product\\nFROM Product)\\n\\nSELECT customer_id \\nFROM c, p\\nWHERE c.products = p.uni_product\\n```",
                "solutionTags": [],
                "code": "```\\nWITH c as (SELECT customer_id, \\nGROUP_CONCAT(DISTINCT product_key \\n                     order by product_key\\n                     separator \\',\\') as products\\nFROM Customer\\nGROUP BY customer_id),\\np as (\\nSELECT \\nGROUP_CONCAT(DISTINCT product_key \\n\\t\\t\\t\\torder by product_key\\n                 separator \\',\\') as uni_product\\nFROM Product)\\n\\nSELECT customer_id \\nFROM c, p\\nWHERE c.products = p.uni_product\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601333,
                "title": "super-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT customer_id \\nFROM Customer C\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (SELECT COUNT(DISTINCT(product_key)) FROM Product)\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT customer_id \\nFROM Customer C\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (SELECT COUNT(DISTINCT(product_key)) FROM Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572214,
                "title": "a-simple-and-easy-solution-using-group-by-distinct-and-count-beginner-level",
                "content": "# Explanation\\n\\nWe use group by customer_id to disinguish each customer_id and check the number of distinct products they have bought.\\n\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING COUNT(DISTINCT product_key)\\n\\nAnd then we check if this count matches with the count of available products in the product table.\\n\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n\\nIF the count matches, then it is believed that customer has in fact purchased all the available products \\uD83D\\uDC4D.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2328936,
                "title": "easy-mysql",
                "content": "\\tSELECT customer_id\\n\\tFROM Customer\\n\\tGROUP BY customer_id\\n\\tHAVING count(DISTINCT product_key) = (SELECT count(*) FROM Product)",
                "solutionTags": [],
                "code": "\\tSELECT customer_id\\n\\tFROM Customer\\n\\tGROUP BY customer_id\\n\\tHAVING count(DISTINCT product_key) = (SELECT count(*) FROM Product)",
                "codeTag": "Unknown"
            },
            {
                "id": 1569711,
                "title": "simple-4-line-solution",
                "content": "select customer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from product)",
                "solutionTags": [],
                "code": "select customer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from product)",
                "codeTag": "Unknown"
            },
            {
                "id": 679875,
                "title": "easy-to-understand-solution-no-cartesian-join-needed",
                "content": "Select customer_id from (select distinct \\n                         customer_id,product_key from customer) g group by customer_id\\nhaving count(*) = (select count( product_key) from product)\\n\\n1- Use the inner query to get rid of dups ( one customer purchasing same product more than once)\\n2- Then get the number of times each customerid appears in the customer table.\\n3- The records with the count equal to number of products should be in our answer.",
                "solutionTags": [],
                "code": "Select customer_id from (select distinct \\n                         customer_id,product_key from customer) g group by customer_id\\nhaving count(*) = (select count( product_key) from product)\\n\\n1- Use the inner query to get rid of dups ( one customer purchasing same product more than once)\\n2- Then get the number of times each customerid appears in the customer table.\\n3- The records with the count equal to number of products should be in our answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 455370,
                "title": "mssql-answer",
                "content": "```\\nSELECT   customer_id\\nFROM     Customer\\nGROUP BY customer_id\\nHAVING   COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key)FROM Product)\\n```\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT   customer_id\\nFROM     Customer\\nGROUP BY customer_id\\nHAVING   COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key)FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436889,
                "title": "super-easy-solution",
                "content": "```\\nselect \\ncustomer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\ncustomer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877362,
                "title": "easy-solution-mysql-having-clause-100-fast",
                "content": "# Intuition \\uD83E\\uDDE0\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to count the distinct product keys for each customers and then check if it matches with all the types of products in the product table.\\n# Approach \\uD83D\\uDEE4\\uFE0F\\n<!-- Describe your approach to solving the problem. -->\\nTo check that the count of distinct product keys of a customer is equal to the total types of products in Products table. We will just check if the count distinct of product key in Customer table is equal to count of Product Key in Products Table. So for that we have to add the condition in having clause.\\n\\n# Code \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from Product)\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/d72c738f-2795-4c86-9fad-3e746bf42661_1691419489.5374012.png)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536635,
                "title": "mysql-solution-for-customers-who-brought-all-products-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the given solution is to find customer IDs that have purchased all distinct products available in the Product table. The approach involves grouping the Customer table by customer_id and then applying a condition in the HAVING clause to compare the sum of distinct product_key values for each customer with the total sum of product_key values in the Product table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Group the rows in the Customer table by customer_id.\\n1. For each group, calculate the sum of distinct product_key values.\\n1. Compare the sum of distinct product_key values for each group with the total sum of product_key values in the Product table.\\n1. Return the customer_id values that satisfy the condition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution depends on the size of the Customer and Product tables. The grouping operation requires scanning the Customer table, which has a time complexity of O(n), where n is the number of rows in the Customer table. Additionally, calculating the sum of distinct product_key values involves aggregating and comparing values, which also has a time complexity of O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution depends on the number of distinct customer_id values and the number of distinct product_key values. The query requires storing the grouped customer_id values and the distinct product_key values temporarily, so the space complexity is determined by the cardinality of these values.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id from Customer group by customer_id\\nhaving sum(distinct product_key) = \\n(select sum(product_key) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id from Customer group by customer_id\\nhaving sum(distinct product_key) = \\n(select sum(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467737,
                "title": "easy-solution",
                "content": "```\\nselect customer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct(product_key)) = (select count(product_key) from product)\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct(product_key)) = (select count(product_key) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083035,
                "title": "one-subquery",
                "content": "Select the customers who purchased the as many distinct product_key as the count of all product in product table    \\n\\t\\n\\tselect customer_id\\n    from customer\\n    group by customer_id\\n    having count(distinct product_key) = (select count(*) from product);",
                "solutionTags": [],
                "code": "Select the customers who purchased the as many distinct product_key as the count of all product in product table    \\n\\t\\n\\tselect customer_id\\n    from customer\\n    group by customer_id\\n    having count(distinct product_key) = (select count(*) from product);",
                "codeTag": "Unknown"
            },
            {
                "id": 4056405,
                "title": "mysql-solution-with-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to find customer IDs who have purchased all the products from the Customer table. It does so by counting the distinct product keys purchased by each customer and comparing that count to the total number of products in the `Product` table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The inner subquery groups the customers by their IDs and counts the distinct product keys purchased by each customer using `COUNT(DISTINCT product_key)`.\\n\\n2. The `HAVING` clause filters out only those customers who have purchased as many distinct products as the total number of products in the `Product` table. This ensures that the customer has bought all the available products.\\n\\n3. The outer query selects the `customer_id` from the result of the inner subquery, which gives us the customer IDs who meet the criteria.\\n\\n\\n# Complexity\\n## Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The time complexity of this query depends on the size of the `Customer` table and the `Product` table.\\n\\n- The inner subquery involves grouping and counting for each customer, which can be considered O(N), where N is the number of rows in the `Customer` table.\\n- The subquery `(SELECT COUNT(*) FROM Product)` is a constant-time operation, as it calculates the total number of products, which doesn\\'t depend on the size of the tables.\\n\\nSo, the overall time complexity is approximately **`O(N)`**, where N is the **number of customers**.\\n\\n## Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity is primarily determined by the temporary result set created by the inner subquery. This result set stores the `customer_id` and the count of distinct product keys for each customer.\\n\\n- **Assuming M is the number of distinct customers who meet the criteria (those who have bought all products), the space complexity is `O(M)`**.\\n\\nIn terms of space complexity, it\\'s essential to consider the size of the result set that needs to be stored in memory.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id \\nFROM(\\n    SELECT customer_id , COUNT(DISTINCT product_key) AS cnt\\n    FROM Customer\\n    GROUP BY customer_id\\n    HAVING cnt = (SELECT COUNT(*) FROM Product)\\n) Temp;\\n```\\n\\n## Do Upvote if you got it! :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id \\nFROM(\\n    SELECT customer_id , COUNT(DISTINCT product_key) AS cnt\\n    FROM Customer\\n    GROUP BY customer_id\\n    HAVING cnt = (SELECT COUNT(*) FROM Product)\\n) Temp;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501467,
                "title": "group-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGroup by\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. GROUP BY customer_id\\n2. Set the condition in HAVING clause. If count of distinct product key in Customer table grouped with customer_id is equal to Count of product key in Product table then it will determine that if customer has all the distinct product id with it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\\\\\nSELECT customer_id\\nFROM Customer \\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\\\\\nSELECT customer_id\\nFROM Customer \\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2498688,
                "title": "mysql-simple-solution-without-subquery-and-cte",
                "content": "select customer_id\\nfrom Customer\\ngroup by 1\\nhaving count(distinct product_key) = (select count(*) from Product);",
                "solutionTags": [],
                "code": "select customer_id\\nfrom Customer\\ngroup by 1\\nhaving count(distinct product_key) = (select count(*) from Product);",
                "codeTag": "Unknown"
            },
            {
                "id": 2466026,
                "title": "mysql-having-count-distinct-group-by-good-luck",
                "content": "```\\n# Write your MySQL query statement below\\n\\n/**\\nTwo Tables: Customer/Product\\n\\nThere is no primary key for Customer table. It may contain duplicates.\\nproduct_key is a foreign key to Product table.\\n\\nproduct_key is the primary key column for Product table.\\n\\nPROBLEM:  report the customer ids from the Customer table that bought all the products in the Product table.\\n\\nSTEPS\\n    HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n\\n*/\\n\\nSELECT\\n    customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n/**\\nTwo Tables: Customer/Product\\n\\nThere is no primary key for Customer table. It may contain duplicates.\\nproduct_key is a foreign key to Product table.\\n\\nproduct_key is the primary key column for Product table.\\n\\nPROBLEM:  report the customer ids from the Customer table that bought all the products in the Product table.\\n\\nSTEPS\\n    HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n\\n*/\\n\\nSELECT\\n    customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2425149,
                "title": "mysql-not-exists-where-not-in-cte",
                "content": "WITH cte as(\\nSELECT distinct customer_id as customer_id\\nFROM Customer)\\n\\nSELECT cte.customer_id\\nFROM cte\\nWHERE NOT EXISTS(\\nSELECT product_key FROM Product\\nWHERE product_key NOT IN(\\nSELECT product_key FROM Customer c\\nWHERE c.customer_id = cte.customer_id)\\n)",
                "solutionTags": [],
                "code": "WITH cte as(\\nSELECT distinct customer_id as customer_id\\nFROM Customer)\\n\\nSELECT cte.customer_id\\nFROM cte\\nWHERE NOT EXISTS(\\nSELECT product_key FROM Product\\nWHERE product_key NOT IN(\\nSELECT product_key FROM Customer c\\nWHERE c.customer_id = cte.customer_id)\\n)",
                "codeTag": "Unknown"
            },
            {
                "id": 2111687,
                "title": "oracle-easy-solution",
                "content": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from Product)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2091361,
                "title": "simple-mysql-solution",
                "content": "select customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product);",
                "solutionTags": [],
                "code": "select customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product);",
                "codeTag": "Unknown"
            },
            {
                "id": 1608012,
                "title": "using-ctes-faster-than-90",
                "content": "```\\n# Write your MySQL query statement below\\n\\nwith cte1 as (\\n    select count(product_key) as \\'total_products\\' from Product\\n), cte2 as (\\n    select customer_id, count(distinct product_key) as \\'total\\' from Customer\\n    group by customer_id\\n)\\n\\nselect customer_id from cte2\\nwhere total = (select * from cte1)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nwith cte1 as (\\n    select count(product_key) as \\'total_products\\' from Product\\n), cte2 as (\\n    select customer_id, count(distinct product_key) as \\'total\\' from Customer\\n    group by customer_id\\n)\\n\\nselect customer_id from cte2\\nwhere total = (select * from cte1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513965,
                "title": "faster-than-100",
                "content": "\\'\\'\\'\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product);\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product);\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1351923,
                "title": "faster-than-98",
                "content": "```\\n\\nSELECT\\n    customer_id\\nFROM\\n    (SELECT \\n        customer_id,\\n        COUNT(DISTINCT(product_key)) AS c\\n    FROM Customer\\n        GROUP BY customer_id) A\\nWHERE c = (SELECT COUNT(*) FROM product)\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT\\n    customer_id\\nFROM\\n    (SELECT \\n        customer_id,\\n        COUNT(DISTINCT(product_key)) AS c\\n    FROM Customer\\n        GROUP BY customer_id) A\\nWHERE c = (SELECT COUNT(*) FROM product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1237239,
                "title": "my-simple-mysql-solution",
                "content": "```\\nSELECT c.customer_id\\nFROM Customer c\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product p)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT c.customer_id\\nFROM Customer c\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product p)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191649,
                "title": "mysql-easy-understanding-solution",
                "content": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166721,
                "title": "no-subquery-simple-mysql-solution-count-distinct",
                "content": "```\\nselect customer_id\\nfrom customer \\ngroup by customer_id \\nhaving count(distinct product_key) = (select count(distinct product_key) from product)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nselect customer_id\\nfrom customer \\ngroup by customer_id \\nhaving count(distinct product_key) = (select count(distinct product_key) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002235,
                "title": "mysql-group-concat",
                "content": "This solution handles for the edge case when the Product table has different set of product_key than in the Customer table\\n```\\nWITH prods AS (\\n    SELECT customer_id,\\n        GROUP_CONCAT(DISTINCT product_key) as prods\\n    FROM Customer\\n    GROUP BY 1)\\n    \\nSELECT customer_id\\nFROM prods\\nWHERE prods = (SELECT GROUP_CONCAT(DISTINCT product_key) FROM Product)\\n```",
                "solutionTags": [],
                "code": "```\\nWITH prods AS (\\n    SELECT customer_id,\\n        GROUP_CONCAT(DISTINCT product_key) as prods\\n    FROM Customer\\n    GROUP BY 1)\\n    \\nSELECT customer_id\\nFROM prods\\nWHERE prods = (SELECT GROUP_CONCAT(DISTINCT product_key) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880983,
                "title": "not-a-simple-comparison-between-the-two-count",
                "content": "#My solution cover the situation that the product_keys in customer table are out of those in product #table\\n\\nselect customer_id\\nfrom ( \\n    select p.product_key, c.customer_id\\n    from product p\\n    left join customer c on c.product_key = p.product_key ) t\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)",
                "solutionTags": [],
                "code": "#My solution cover the situation that the product_keys in customer table are out of those in product #table\\n\\nselect customer_id\\nfrom ( \\n    select p.product_key, c.customer_id\\n    from product p\\n    left join customer c on c.product_key = p.product_key ) t\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)",
                "codeTag": "Unknown"
            },
            {
                "id": 860166,
                "title": "ms-sql-server",
                "content": "```\\nselect customer_id from Customer group by customer_id\\nhaving count(distinct product_key)=(select count(1) from Product)\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_id from Customer group by customer_id\\nhaving count(distinct product_key)=(select count(1) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 302299,
                "title": "simple-solution",
                "content": "```\\nSELECT customer_id from Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(\\nselect count(distinct product_key) from Product\\n)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_id from Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(\\nselect count(distinct product_key) from Product\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294612,
                "title": "my-mysql-ms-sql-answers",
                "content": "My MySQL solution: Firstly, you need exclude the products which are not in the product list. Secondly, you need to delete the duplicates, which means one customer buy the same product multiple times. Then you just need to make sure the number of distinct product each customer buys is equal to the number of distinct product on the list. \\n\\nMySQL:\\n```\\nSELECT customer_id\\nFROM (\\nSELECT DISTINCT *\\nFROM Customer\\nWHERE product_key IN (SELECT DISTINCT product_key FROM Product)) AS temp\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product)\\n```\\n\\nMS SQL:\\n```\\n\\nSELECT DISTINCT customer_id\\nFROM (\\n    \\nSELECT *, MAX(CT) OVER(PARTITION BY customer_id) AS MX\\n    \\nFROM (  \\nSELECT *, DENSE_RANK() OVER(PARTITION BY customer_id ORDER BY product_key) AS CT\\nFROM Customer\\nWHERE product_key IN (SELECT DISTINCT product_key FROM Product)) AS temp1\\n    \\n ) AS temp2\\nWHERE MX = (SELECT COUNT(DISTINCT product_key) FROM Product)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_id\\nFROM (\\nSELECT DISTINCT *\\nFROM Customer\\nWHERE product_key IN (SELECT DISTINCT product_key FROM Product)) AS temp\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product)\\n```\n```\\n\\nSELECT DISTINCT customer_id\\nFROM (\\n    \\nSELECT *, MAX(CT) OVER(PARTITION BY customer_id) AS MX\\n    \\nFROM (  \\nSELECT *, DENSE_RANK() OVER(PARTITION BY customer_id ORDER BY product_key) AS CT\\nFROM Customer\\nWHERE product_key IN (SELECT DISTINCT product_key FROM Product)) AS temp1\\n    \\n ) AS temp2\\nWHERE MX = (SELECT COUNT(DISTINCT product_key) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926385,
                "title": "pandas-one-liner-f-string-inside-query",
                "content": "# Intuition\\nWe just want to count how many unique products customer bought and check if this is the number of all products (in this question we dont have to worry for products that were bought but are not included in product list, and dont have to worry about duplicates in product list)\\n\\n# Approach\\nGroup by customer and count number of unique products. Then compare it with length of product list and if they are the same, we got customer who bought all products.\\n\\nwhat is worth noticing - we can use f-string as our query. Then inside such query, we can directly specify expression calculating length of product list.\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customer: pd.DataFrame, product: pd.DataFrame) -> pd.DataFrame:\\n    return customer.groupby(\\'customer_id\\',as_index = False).product_key.nunique().query(f\"product_key == {len(product)}\")[[\\'customer_id\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customer: pd.DataFrame, product: pd.DataFrame) -> pd.DataFrame:\\n    return customer.groupby(\\'customer_id\\',as_index = False).product_key.nunique().query(f\"product_key == {len(product)}\")[[\\'customer_id\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3909919,
                "title": "2-lines-very-easy-to-understand-explained-solution-mysql",
                "content": "# Intuition\\n**Use first table (Customer) and count all from (Product) second table.**\\n# Approach\\n1. We\\'re selecting the customer_id from the Customer table.\\n\\n2. The GROUP BY c.customer_id groups the results by customer ID.\\n\\n3. The HAVING clause filters the results to include only those customers who have purchased all the distinct products.\\n\\n4. COUNT(DISTINCT c.product_key) counts the distinct products bought by each customer.\\n\\n5. (SELECT COUNT(*) FROM Product) gets the total count of distinct products available in the Product table.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT c.customer_id FROM Customer c GROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT c.customer_id FROM Customer c GROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3801097,
                "title": "mysql-simple-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id from customer group by customer_id \\nhaving count(distinct product_key)=(\\n    select count(*) from product\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id from customer group by customer_id \\nhaving count(distinct product_key)=(\\n    select count(*) from product\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607512,
                "title": "easy-mysql-solution-with-very-simple-and-detailed-explanation-best-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The question asks us to **find the customers who bought all the products**.\\n- To find the customers, we group the customers using GROUP BY so that we can get the **products bought by each customer**.\\n- Now, we must make sure that the **number of distinct products bought by a single customer is equal to the number of products in Product table**(All the product_keys in Product table are different)\\n- For that, we use the following code-\\n#### GROUP BY customer_id\\n#### HAVING COUNT(DISTINCT product_key)=(SELECT COUNT(*) FROM Product)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the **customer_id**.\\n2. In the FROM statement, we write the table name **Customer**.\\n3. The **GROUP BY** clause groups the query according to the **customer_id**.\\n4. The **HAVING keyword** filters the query such that the **number of distinct products bought by a single customer is equal to the number of products in Product table**. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key)=(SELECT COUNT(*) FROM Product)\\n```\\n# Note\\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key)=(SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557112,
                "title": "simple-code-using-having",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(DISTINCT product_key) = (SELECT COUNT( DISTINCT product_key) FROM Product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(DISTINCT product_key) = (SELECT COUNT( DISTINCT product_key) FROM Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548063,
                "title": "having-clause-beats-76",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from product)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438523,
                "title": "solution-with-simple-join-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n\\r\\n    SELECT \\r\\n        T2.customer_id\\r\\n    FROM\\r\\n        product T1 \\r\\n    INNER JOIN\\r\\n        (\\r\\n            SELECT\\r\\n                DISTINCT *\\r\\n            FROM\\r\\n                Customer\\r\\n         ) T2 ON T2.product_key = T1.product_key\\r\\n    GROUP BY\\r\\n        T2.customer_id\\r\\n    HAVING  COUNT(T1.product_key) = (SELECT COUNT(product_key) FROM Product)\\r\\n\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n\\r\\n    SELECT \\r\\n        T2.customer_id\\r\\n    FROM\\r\\n        product T1 \\r\\n    INNER JOIN\\r\\n        (\\r\\n            SELECT\\r\\n                DISTINCT *\\r\\n            FROM\\r\\n                Customer\\r\\n         ) T2 ON T2.product_key = T1.product_key\\r\\n    GROUP BY\\r\\n        T2.customer_id\\r\\n    HAVING  COUNT(T1.product_key) = (SELECT COUNT(product_key) FROM Product)\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408195,
                "title": "mysql-solution-beats-43-72-sub-query",
                "content": "# Code\\n```\\nSELECT                                      \\n    customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING SUM(DISTINCT product_key) = (\\n    SELECT\\n        SUM(product_key)\\n    FROM Product\\n); \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT                                      \\n    customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING SUM(DISTINCT product_key) = (\\n    SELECT\\n        SUM(product_key)\\n    FROM Product\\n); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608856,
                "title": "noob-mysql-dpm07",
                "content": "```\\nselect customer_id\\nfrom (\\n    select customer_id, group_concat(distinct product_key order by product_key) as \\'all_product\\'\\n    from Customer\\n    group by customer_id) temp1\\n    where all_product = (\\n        select group_concat(product_key order by product_key) as \\'all_product\\' \\n        from Product\\n)\\n\\n```\\n\\n\\nPRO: Thanks to David\\n```\\nSELECT\\ncustomer_id\\nFROM customer c \\nGROUP BY customer_id\\nHAVING count(DISTINCT(c.product_key)) = (SELECT count(distinct(product_key)) FROM product)\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_id\\nfrom (\\n    select customer_id, group_concat(distinct product_key order by product_key) as \\'all_product\\'\\n    from Customer\\n    group by customer_id) temp1\\n    where all_product = (\\n        select group_concat(product_key order by product_key) as \\'all_product\\' \\n        from Product\\n)\\n\\n```\n```\\nSELECT\\ncustomer_id\\nFROM customer c \\nGROUP BY customer_id\\nHAVING count(DISTINCT(c.product_key)) = (SELECT count(distinct(product_key)) FROM product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221898,
                "title": "mysql-properly-styled-group-having-rt-438-ms-ft-96-94",
                "content": "```\\nSELECT\\n    customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185255,
                "title": "easy-solution",
                "content": "```\\n# count unique number of product from each customer and if that matches with total \\n# number of products from the product table then we found our customers \\nwith base as \\n(\\n    select customer_id, count(distinct product_key) as n_product\\n    from Customer\\n    group by 1\\n)\\n\\nselect customer_id from base\\nwhere n_product = (select count(distinct product_key) from Product)\\n```",
                "solutionTags": [],
                "code": "```\\n# count unique number of product from each customer and if that matches with total \\n# number of products from the product table then we found our customers \\nwith base as \\n(\\n    select customer_id, count(distinct product_key) as n_product\\n    from Customer\\n    group by 1\\n)\\n\\nselect customer_id from base\\nwhere n_product = (select count(distinct product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2181642,
                "title": "cte-doesn-t-work-but-inline-select-does-why",
                "content": "Why doesn\\'t this work? \\n```\\nwith pcnt as \\n( \\n    select count(*) as num from Product\\n)\\nselect customer_id from \\n(\\n    select \\n        customer_id , count(distinct product_key) as cnt \\n    from Customer  \\n    group by customer_id \\n) x \\nwhere  \\n    x.cnt =pcnt.num \\n```\\n\\t\\nBut this works...\\n\\t\\n```\\nselect customer_id from \\n(\\n    select \\n        customer_id , count(distinct product_key) as cnt \\n    from Customer  \\n    group by customer_id \\n) x \\nwhere  \\n    x.cnt in (select count(*) as num from Product)\\n```",
                "solutionTags": [],
                "code": "```\\nwith pcnt as \\n( \\n    select count(*) as num from Product\\n)\\nselect customer_id from \\n(\\n    select \\n        customer_id , count(distinct product_key) as cnt \\n    from Customer  \\n    group by customer_id \\n) x \\nwhere  \\n    x.cnt =pcnt.num \\n```\n```\\nselect customer_id from \\n(\\n    select \\n        customer_id , count(distinct product_key) as cnt \\n    from Customer  \\n    group by customer_id \\n) x \\nwhere  \\n    x.cnt in (select count(*) as num from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958020,
                "title": "easy-way",
                "content": "```\\nselect customer_id from customer group by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)\\n```\\n\\nBe careful about the count(distinct product_key) since there are customers buying the same product for many times.\\nIf we forget about this condition, we will get the same result when we run the code but pass the test case when we submit.",
                "solutionTags": [],
                "code": "```\\nselect customer_id from customer group by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894778,
                "title": "4-line-very-simple-mysql-solution",
                "content": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823201,
                "title": "in-clause-and-sub-queries",
                "content": "```\\nselect distinct customer_id from \\n(\\nselect customer_id ,count(distinct product_key) as \"num\",product_key\\nfrom Customer\\nwhere product_key \\nin \\n(select distinct product_key from product)\\ngroup by customer_id ) a\\nwhere num= (select count(distinct product_key) from product)\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct customer_id from \\n(\\nselect customer_id ,count(distinct product_key) as \"num\",product_key\\nfrom Customer\\nwhere product_key \\nin \\n(select distinct product_key from product)\\ngroup by customer_id ) a\\nwhere num= (select count(distinct product_key) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806986,
                "title": "single-select",
                "content": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) >= (select count(*) from Product)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) >= (select count(*) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1726681,
                "title": "simple-soultion",
                "content": "SELECT customer_id \\nFROM Customer \\ngroup by 1\\nhaving  COUNT(distinct product_key) = (SELECT COUNT(DISTINCT product_key) as tot_items FROM Product)",
                "solutionTags": [],
                "code": "SELECT customer_id \\nFROM Customer \\ngroup by 1\\nhaving  COUNT(distinct product_key) = (SELECT COUNT(DISTINCT product_key) as tot_items FROM Product)",
                "codeTag": "Unknown"
            },
            {
                "id": 1651012,
                "title": "simplest-mysql-solution",
                "content": "```\\nSELECT customer_id FROM Customer c\\nJOIN Product p\\nON c.product_key = p.product_key\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_id FROM Customer c\\nJOIN Product p\\nON c.product_key = p.product_key\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629268,
                "title": "inefficient-solution-cross-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id from Customer where customer_id not in (\\n\\tselect customer_id from \\n    (select customer_id, product_key from (select distinct customer_id from Customer) a cross join Product) t\\nwhere (customer_id, product_key) not in (select * from Customer)\\n)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id from Customer where customer_id not in (\\n\\tselect customer_id from \\n    (select customer_id, product_key from (select distinct customer_id from Customer) a cross join Product) t\\nwhere (customer_id, product_key) not in (select * from Customer)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567201,
                "title": "simple-mysql",
                "content": "SELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(distinct product_key) in (SELECT count(distinct product_key) FROM Product)",
                "solutionTags": [],
                "code": "SELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(distinct product_key) in (SELECT count(distinct product_key) FROM Product)",
                "codeTag": "Unknown"
            },
            {
                "id": 1550365,
                "title": "mysql-subquery-and-groupby",
                "content": "select distinct customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product)\\n",
                "solutionTags": [],
                "code": "select distinct customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1544441,
                "title": "faster-than-95",
                "content": "select customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct(product_key))=(select count(*) from product)",
                "solutionTags": [],
                "code": "select customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct(product_key))=(select count(*) from product)",
                "codeTag": "Unknown"
            },
            {
                "id": 1487935,
                "title": "oracle-fast",
                "content": "```\\n-- distinct product count for given customer must match the number of products in product table\\nselect customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from customer)\\norder by 1;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n-- distinct product count for given customer must match the number of products in product table\\nselect customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(distinct product_key) from customer)\\norder by 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426603,
                "title": "ms-sql-right-join-group-by",
                "content": "```\\nSELECT CUSTOMER_ID\\nFROM CUSTOMER C\\nRIGHT JOIN PRODUCT P\\nON C.PRODUCT_KEY = P.PRODUCT_KEY\\nGROUP BY CUSTOMER_ID \\nHAVING COUNT(DISTINCT C.PRODUCT_KEY) = (SELECT COUNT(DISTINCT PRODUCT_KEY) FROM PRODUCT)\\n```\\nHello guys! Please do comment and let me know if you have a better approach in MS SQL. Thanks!!",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT CUSTOMER_ID\\nFROM CUSTOMER C\\nRIGHT JOIN PRODUCT P\\nON C.PRODUCT_KEY = P.PRODUCT_KEY\\nGROUP BY CUSTOMER_ID \\nHAVING COUNT(DISTINCT C.PRODUCT_KEY) = (SELECT COUNT(DISTINCT PRODUCT_KEY) FROM PRODUCT)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343475,
                "title": "simple-mysql-solution-beats-87",
                "content": "```\\n\\nSELECT c.customer_id  \\nFROM Customer c \\nJOIN product p\\n    ON c.product_key = p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM product)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nSELECT c.customer_id  \\nFROM Customer c \\nJOIN product p\\n    ON c.product_key = p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1323445,
                "title": "group-by-with-having",
                "content": "Having Disticnt is important in for produdct_key from customer table, do not need it for product\\n\\n```\\nSELECT customer_id\\nFROM customer c\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(product_key) FROM product)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_id\\nFROM customer c\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(product_key) FROM product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284617,
                "title": "simple-three-lines-mysql-solution",
                "content": "select distinct customer_id from customer\\ngroup by customer_id \\nhaving count(distinct product_key) = (select count(distinct product_key) from product);",
                "solutionTags": [],
                "code": "select distinct customer_id from customer\\ngroup by customer_id \\nhaving count(distinct product_key) = (select count(distinct product_key) from product);",
                "codeTag": "Unknown"
            },
            {
                "id": 1075725,
                "title": "easy-peasy",
                "content": "```\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_id FROM Customer GROUP BY customer_id HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991394,
                "title": "mysql-4-lines-super-easy-to-understand",
                "content": "```\\nSELECT customer_id\\nFROM customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(product_key) FROM product)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_id\\nFROM customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(product_key) FROM product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874339,
                "title": "easiest-mssql-solution",
                "content": "```\\nselect customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(*) from product)\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(*) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845869,
                "title": "simple-mysql-faster-than-99-49",
                "content": "```\\nSelect customer_id\\nFrom Customer \\nGroup by customer_id\\nHaving count(distinct product_key) = (\\nSelect count(distinct product_key)\\nFrom Product)\\n```",
                "solutionTags": [],
                "code": "```\\nSelect customer_id\\nFrom Customer \\nGroup by customer_id\\nHaving count(distinct product_key) = (\\nSelect count(distinct product_key)\\nFrom Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836864,
                "title": "mysql-simple-approach-solution",
                "content": "```select customer_id from customer group by customer_id having count(distinct product_key) = (select count(*) from product);```",
                "solutionTags": [],
                "code": "```select customer_id from customer group by customer_id having count(distinct product_key) = (select count(*) from product);```",
                "codeTag": "Unknown"
            },
            {
                "id": 575466,
                "title": "easy-mysql-solution-beats-over-90",
                "content": "```\\n# Write your MySQL query statement below\\nselect\\n    customer_id\\nfrom\\n    (select\\n        c.customer_id\\n        , count(distinct(p.product_key)) as cnt\\n    from\\n        Customer as c\\n    left join\\n        Product as p\\n    on\\n        p.product_key =c.product_key\\n    group by\\n        c.customer_id\\n    ) t\\nwhere\\n    t.cnt = (select count(*) from Product)\\norder by\\n    customer_id\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    customer_id\\nfrom\\n    (select\\n        c.customer_id\\n        , count(distinct(p.product_key)) as cnt\\n    from\\n        Customer as c\\n    left join\\n        Product as p\\n    on\\n        p.product_key =c.product_key\\n    group by\\n        c.customer_id\\n    ) t\\nwhere\\n    t.cnt = (select count(*) from Product)\\norder by\\n    customer_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543962,
                "title": "mysql-solutions-using-double-not-exists-compare-counts-is-not-accurate",
                "content": "select customer_id from Customer c1\\nwhere not exists\\n\\t(select * from Product p\\n\\twhere not exists\\n\\t\\t(select * from Customer c2\\n\\t\\twhere c2.product_key = p.product_key\\n\\t\\tand c2.customer_id = c1.customer_id))\\ngroup by customer_id",
                "solutionTags": [],
                "code": "select customer_id from Customer c1\\nwhere not exists\\n\\t(select * from Product p\\n\\twhere not exists\\n\\t\\t(select * from Customer c2\\n\\t\\twhere c2.product_key = p.product_key\\n\\t\\tand c2.customer_id = c1.customer_id))\\ngroup by customer_id",
                "codeTag": "Unknown"
            },
            {
                "id": 517201,
                "title": "mysql-beat-99-having",
                "content": "```\\nselect customer_id \\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from product)\\n```",
                "solutionTags": [],
                "code": "```\\nselect customer_id \\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500598,
                "title": "mysql-compare-products-bought-to-products-available",
                "content": "The customer who bought all products bought the same number of unique products as there are available. \\n\\n(448ms, 90.25%): \\n```\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product); \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389644,
                "title": "mysql-no-subquery-easy-to-understand",
                "content": "```\\nSELECT customer_id\\nFROM customer\\nGROUP BY customer_id\\nHAVING count(distinct product_key) = (SELECT COUNT(DISTINCT product_key) FROM product);\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT customer_id\\nFROM customer\\nGROUP BY customer_id\\nHAVING count(distinct product_key) = (SELECT COUNT(DISTINCT product_key) FROM product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 334460,
                "title": "faster-than-100",
                "content": "Faster Than 100%:\\n\\n```\\nWITH \\ncus_pro\\nAS\\n(\\n  SELECT c.customer_id, c.product_key, dense_rank() over (partition by c.customer_id order by c.product_key) as rn\\n  FROM customer c inner join product p on c.product_key = p.product_key\\n)\\nSELECT  \\n  distinct c.customer_id\\nFROM\\n  cus_pro c\\nWHERE\\n  c.rn = (SELECT count(*) from Product)\\n```",
                "solutionTags": [],
                "code": "```\\nWITH \\ncus_pro\\nAS\\n(\\n  SELECT c.customer_id, c.product_key, dense_rank() over (partition by c.customer_id order by c.product_key) as rn\\n  FROM customer c inner join product p on c.product_key = p.product_key\\n)\\nSELECT  \\n  distinct c.customer_id\\nFROM\\n  cus_pro c\\nWHERE\\n  c.rn = (SELECT count(*) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319791,
                "title": "easy-to-understand-solution",
                "content": "```\\nSELECT\\n    c.customer_id\\nFROM\\n    Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    c.customer_id\\nFROM\\n    Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311903,
                "title": "mysql-refined-solution",
                "content": "```\\nselect ifnull(customer_id, null) as customer_id\\nfrom customer\\ngroup by customer_id \\nhaving count(distinct product_key) = (select count(*) from product )\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect ifnull(customer_id, null) as customer_id\\nfrom customer\\ngroup by customer_id \\nhaving count(distinct product_key) = (select count(*) from product )\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294402,
                "title": "my-solution-with-explanation",
                "content": "```\\n1\\t\\t\\tselect customer_id\\n2\\t\\t\\tfrom\\n3\\t\\t\\t(\\n4\\t\\t\\t\\tselect customer_id, product_key\\n5\\t\\t\\t\\tfrom customer\\n6\\t\\t\\t\\tgroup by customer_id, product_key\\n7\\t\\t\\t) as temp\\n8\\t\\t\\tgroup by customer_id\\n9\\t\\t\\thaving count(*) = \\n10\\t\\t\\t(\\n11\\t\\t\\t  select count(*)\\n12\\t\\t\\t  from product\\n13\\t\\t\\t)\\n```\\n\\nIt is not stated in the question whether the customer_id is a primary key of customer table. Therefore, my solution is a bit longer than others, because I consider the situation where we have duplicates, which is a person can buy the same products more than 1 time (results in two or more rows that are exactly the same).\\n\\nIn order to get rid of the duplicates, I have line 4-6.\\n\\nFeel free to ask if you have any questions.\\n",
                "solutionTags": [],
                "code": "```\\n1\\t\\t\\tselect customer_id\\n2\\t\\t\\tfrom\\n3\\t\\t\\t(\\n4\\t\\t\\t\\tselect customer_id, product_key\\n5\\t\\t\\t\\tfrom customer\\n6\\t\\t\\t\\tgroup by customer_id, product_key\\n7\\t\\t\\t) as temp\\n8\\t\\t\\tgroup by customer_id\\n9\\t\\t\\thaving count(*) = \\n10\\t\\t\\t(\\n11\\t\\t\\t  select count(*)\\n12\\t\\t\\t  from product\\n13\\t\\t\\t)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106923,
                "title": "simple-subquery-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT CUSTOMER_ID FROM \\n(SELECT CUSTOMER_ID,COUNT(DISTINCT CUSTOMER_ID,PRODUCT_KEY) F FROM CUSTOMER GROUP BY CUSTOMER_ID) B\\nWHERE F=(SELECT COUNT(PRODUCT_KEY) FROM PRODUCT)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT CUSTOMER_ID FROM \\n(SELECT CUSTOMER_ID,COUNT(DISTINCT CUSTOMER_ID,PRODUCT_KEY) F FROM CUSTOMER GROUP BY CUSTOMER_ID) B\\nWHERE F=(SELECT COUNT(PRODUCT_KEY) FROM PRODUCT)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4104503,
                "title": "simple-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nDECLARE @products INT;\\nSELECT @products = (SELECT COUNT(*) FROM Product);\\n\\nWITH Customers AS (SELECT customer_id, COUNT( DISTINCT product_key) as co\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT( DISTINCT product_key) = @products)\\n\\nSELECT customer_id FROM Customers\\n \\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nDECLARE @products INT;\\nSELECT @products = (SELECT COUNT(*) FROM Product);\\n\\nWITH Customers AS (SELECT customer_id, COUNT( DISTINCT product_key) as co\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT( DISTINCT product_key) = @products)\\n\\nSELECT customer_id FROM Customers\\n \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4103626,
                "title": "beats-51-68-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect cus.customer_id from Customer cus\\ngroup by cus.customer_id\\nhaving count( distinct product_key) = (\\n    Select count(distinct product_key) from Product p\\n) order by cus.customer_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect cus.customer_id from Customer cus\\ngroup by cus.customer_id\\nhaving count( distinct product_key) = (\\n    Select count(distinct product_key) from Product p\\n) order by cus.customer_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102124,
                "title": "sql-basic-optimal-sol-beats-70-group-by-count-having",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.customer_id\\nfrom customer c\\ngroup by customer_id\\nhaving count(distinct c.product_key) = (select count(1) from product)\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.customer_id\\nfrom customer c\\ngroup by customer_id\\nhaving count(distinct c.product_key) = (select count(1) from product)\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097833,
                "title": "simple-two-liner-mysql",
                "content": "# Explanation\\nWe first select the customer id since that will be the only column that we are returning. Then we select only the ones whose distinct product keys are equal in number to the total amount of product keys in the product table. **Like if this was useful!!!**\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id FROM Customer GROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(product_key) FROM Product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id FROM Customer GROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(product_key) FROM Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094261,
                "title": "simple-mysql-query",
                "content": "# Intuition\\nSimple use of having with sub query count\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id\\n  from customer\\n  group by customer_id\\n  having count(distinct product_key) = (select count(product_key) from product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id\\n  from customer\\n  group by customer_id\\n  having count(distinct product_key) = (select count(product_key) from product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091791,
                "title": "sql-simple-solution",
                "content": "# Code\\n\\n```\\nSELECT\\n  customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(DISTINCT product_key) = (SELECT count(*) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT\\n  customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(DISTINCT product_key) = (SELECT count(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091078,
                "title": "beats-93-97-distinct-cte-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWith uniq as (\\nSelect\\ncustomer_id,\\nCount(Distinct(product_key)) as unique_count\\nFrom Customer\\ngroup by customer_id)\\n\\nselect\\ncustomer_id\\nFrom uniq\\nwhere unique_count = (select count(*) From Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWith uniq as (\\nSelect\\ncustomer_id,\\nCount(Distinct(product_key)) as unique_count\\nFrom Customer\\ngroup by customer_id)\\n\\nselect\\ncustomer_id\\nFrom uniq\\nwhere unique_count = (select count(*) From Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085688,
                "title": "mysql-using-group-by-and-subquery",
                "content": "# Approach\\n<!-- Find the count of distinct product_key for each customer. Compare it with total count of product_key available in Product table -->\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id FROM Customer \\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id FROM Customer \\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085428,
                "title": "easy-cpp-solution-beats-89-56-in-runtime-using-subquery",
                "content": "![image.png](https://assets.leetcode.com/users/images/d6aacbc9-57db-425f-93ef-d3e9c1f10428_1695572039.825931.png)\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT customer_id FROM customer GROUP BY customer_id HAVING \\n    COUNT(DISTINCT product_key) \\n    = \\n    (SELECT COUNT(DISTINCT product_key) FROM product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT customer_id FROM customer GROUP BY customer_id HAVING \\n    COUNT(DISTINCT product_key) \\n    = \\n    (SELECT COUNT(DISTINCT product_key) FROM product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085423,
                "title": "easy-cpp-solution-beats-89-56-in-runtime-using-subquery",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT customer_id FROM customer GROUP BY customer_id HAVING \\n    COUNT(DISTINCT product_key) \\n    = \\n    (SELECT COUNT(DISTINCT product_key) FROM product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT customer_id FROM customer GROUP BY customer_id HAVING \\n    COUNT(DISTINCT product_key) \\n    = \\n    (SELECT COUNT(DISTINCT product_key) FROM product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082030,
                "title": "oracle-solution-beats-98-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n    customer_id\\nfrom \\n    (select \\n        customer_id, \\n        count(distinct product_key) p_num\\n    from Customer \\n    group by customer_id) c\\nwhere p_num = (select count (product_key) from Product)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n    customer_id\\nfrom \\n    (select \\n        customer_id, \\n        count(distinct product_key) p_num\\n    from Customer \\n    group by customer_id) c\\nwhere p_num = (select count (product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081826,
                "title": "easy-approach",
                "content": "with table1 as(\\nselect customer_id , count(distinct product_key) as cnt from (\\nselect customer_id , c.product_key\\nfrom customer c join product p\\non c.product_key = p.product_key) as x \\ngroup by customer_id)\\nselect customer_id from table1 where cnt = (select count(product_key) from product)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with table1 as(\\nselect customer_id , count(distinct product_key) as cnt from (\\nselect customer_id , c.product_key\\nfrom customer c join product p\\non c.product_key = p.product_key) as x \\ngroup by customer_id)\\nselect customer_id from table1 where cnt = (select count(product_key) from product)",
                "codeTag": "Unknown"
            },
            {
                "id": 4080527,
                "title": "mysql-cte-and-subquery-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSelect customer_id from \\n(Select distinct c.customer_id, count(distinct c.product_key) as ct \\nfrom customer c join product p on c.product_key = p.product_key\\ngroup by c.customer_id ) src where ct = (Select count(product_key) from product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSelect customer_id from \\n(Select distinct c.customer_id, count(distinct c.product_key) as ct \\nfrom customer c join product p on c.product_key = p.product_key\\ngroup by c.customer_id ) src where ct = (Select count(product_key) from product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078258,
                "title": "using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (select count(distinct(product_key)) as pNo, customer_id from Customer  group by customer_id)\\n\\nselect distinct(customer_id) from cte as c join Product as p on c.pNo = (select count(*) from Product);\\n \\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/9aa017d9-f7f5-49d2-b069-cadf406c9870_1695414069.4510965.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (select count(distinct(product_key)) as pNo, customer_id from Customer  group by customer_id)\\n\\nselect distinct(customer_id) from cte as c join Product as p on c.pNo = (select count(*) from Product);\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077369,
                "title": "group-by-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    If total unique pruduct purchased by customer is equal to number of pruduct .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n    n = number of customer \\n    m = number of pruduct \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    \\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077368,
                "title": "group-by-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    If total unique pruduct purchased by customer is equal to number of pruduct .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n    n = number of customer \\n    m = number of pruduct \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    \\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077367,
                "title": "group-by-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    If total unique pruduct purchased by customer is equal to number of pruduct .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n    n = number of customer \\n    m = number of pruduct \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    \\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom Customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076340,
                "title": "mssql",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    customer_id\\nfrom Customer  \\ngroup by customer_id\\nhaving(count(distinct product_key))=(select count(*) from product)\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    customer_id\\nfrom Customer  \\ngroup by customer_id\\nhaving(count(distinct product_key))=(select count(*) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076275,
                "title": "simple-solution-with-with-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith Q as(\\nselect customer_id ,count(distinct product_key) as cnt from customer  group by customer_id)\\nselect customer_id from q where cnt = (select count(distinct product_key  ) from product);\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith Q as(\\nselect customer_id ,count(distinct product_key) as cnt from customer  group by customer_id)\\nselect customer_id from q where cnt = (select count(distinct product_key  ) from product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073918,
                "title": "beats-89-91-of-users-with-mysql",
                "content": "# Code\\n```\\nSELECT customer_id \\nFROM Customer \\nGROUP BY customer_id \\nHAVING COUNT(DISTINCT product_key)=(SELECT COUNT(product_key) FROM Product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_id \\nFROM Customer \\nGROUP BY customer_id \\nHAVING COUNT(DISTINCT product_key)=(SELECT COUNT(product_key) FROM Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073638,
                "title": "easy-approach-using-having-group-by",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT customer_id\\nFROM Customer C \\nGROUP BY customer_id\\nHAVING count(DISTINCT C.product_key) = (SELECT count(product_key) FROM Product);\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT customer_id\\nFROM Customer C \\nGROUP BY customer_id\\nHAVING count(DISTINCT C.product_key) = (SELECT count(product_key) FROM Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073280,
                "title": "simple-solution-beats-97",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect customer_id \\nfrom Customer\\ngroup by customer_id \\nhaving count(distinct product_key) = (\\n    select count(distinct product_key) \\n    from Product\\n);\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect customer_id \\nfrom Customer\\ngroup by customer_id \\nhaving count(distinct product_key) = (\\n    select count(distinct product_key) \\n    from Product\\n);\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072744,
                "title": "best-approach-group-by-having-clause-all-test-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id\\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072627,
                "title": "pandas-straight-forward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll values of `product_key` in the customer table exist in the product key, so we only need to calculate the length of the products.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customer: pd.DataFrame, product: pd.DataFrame) -> pd.DataFrame:\\n    bought_all = (customer.groupby(\\'customer_id\\').nunique() == len(product)).reset_index()\\n    return bought_all[bought_all[\\'product_key\\']][[\\'customer_id\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customer: pd.DataFrame, product: pd.DataFrame) -> pd.DataFrame:\\n    bought_all = (customer.groupby(\\'customer_id\\').nunique() == len(product)).reset_index()\\n    return bought_all[bought_all[\\'product_key\\']][[\\'customer_id\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4071661,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n#SELECT c.customer_id from Customer c join Product p on c.product_key = p.product_key group by c.customer_id having count(distinct c.product_key) = count(p.product_key);\\nselect customer_id from Customer group by customer_id having count(distinct product_key) = (select count(product_key) from Product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n#SELECT c.customer_id from Customer c join Product p on c.product_key = p.product_key group by c.customer_id having count(distinct c.product_key) = count(p.product_key);\\nselect customer_id from Customer group by customer_id having count(distinct product_key) = (select count(product_key) from Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066087,
                "title": "distinct-count-group-by",
                "content": "# Code\\n```\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065743,
                "title": "simple-conceptual-solution-using-ctes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (\\n  select customer_id, count(distinct(product_key)) as \\'custcount\\' from customer\\n  group by customer_id\\n), cte2 as (\\n\\nselect *, (if(custcount = (select count(distinct product_key) from product),1,0)) as \\'flag\\' from cte\\n)\\nSelect customer_id from cte2 where flag = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (\\n  select customer_id, count(distinct(product_key)) as \\'custcount\\' from customer\\n  group by customer_id\\n), cte2 as (\\n\\nselect *, (if(custcount = (select count(distinct product_key) from product),1,0)) as \\'flag\\' from cte\\n)\\nSelect customer_id from cte2 where flag = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065437,
                "title": "aggregate-functions-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id from Customer\\ngroup by customer_id\\nhaving sum(distinct product_key) = \\n(select sum(product_key) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id from Customer\\ngroup by customer_id\\nhaving sum(distinct product_key) = \\n(select sum(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061184,
                "title": "solution-includes-comparing-max-value-and-min-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nselect customer_id #,max(Product_key), min(Product_key), count(*) \\nfrom Customer c\\ngroup by customer_id\\nhaving max(Product_key) = (select max(Product_key) from Product)\\nand min(Product_key) = (select min(Product_key) from Product)\\nand count(distinct product_key) = (select count(product_key) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nselect customer_id #,max(Product_key), min(Product_key), count(*) \\nfrom Customer c\\ngroup by customer_id\\nhaving max(Product_key) = (select max(Product_key) from Product)\\nand min(Product_key) = (select min(Product_key) from Product)\\nand count(distinct product_key) = (select count(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059523,
                "title": "beats-100-in-both-speed-and-memory",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nWITH CTE AS (\\nSELECT  CUSTOMER_ID,COUNT(DISTINCT PRODUCT_KEY) AS CNT FROM CUSTOMER A GROUP BY CUSTOMER_ID)\\n\\nSELECT CUSTOMER_ID FROM CTE WHERE CTE.CNT = (SELECT COUNT(DISTINCT PRODUCT_KEY) FROM PRODUCT )\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nWITH CTE AS (\\nSELECT  CUSTOMER_ID,COUNT(DISTINCT PRODUCT_KEY) AS CNT FROM CUSTOMER A GROUP BY CUSTOMER_ID)\\n\\nSELECT CUSTOMER_ID FROM CTE WHERE CTE.CNT = (SELECT COUNT(DISTINCT PRODUCT_KEY) FROM PRODUCT )\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059305,
                "title": "customers-who-bought-all-products-simple-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect customer_id\\nfrom Customer C \\ngroup by customer_id\\nhaving count(distinct C.product_key) = (select count(product_key) from Product)\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect customer_id\\nfrom Customer C \\ngroup by customer_id\\nhaving count(distinct C.product_key) = (select count(product_key) from Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059259,
                "title": "simple-and-beginner-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst count all the products \\nthen choose the customers having the same distinct count of products\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\ndeclare @totProducts int = (select count(product_key) from product)\\n\\nselect customer_id \\nfrom (select customer_id, count(distinct product_key) NumOfProducts from customer \\ngroup by customer_id) as productsCount\\nwhere NumOfProducts = @totProducts\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\ndeclare @totProducts int = (select count(product_key) from product)\\n\\nselect customer_id \\nfrom (select customer_id, count(distinct product_key) NumOfProducts from customer \\ngroup by customer_id) as productsCount\\nwhere NumOfProducts = @totProducts\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057323,
                "title": "beats-92-50-of-users-with-mysql-simple-solution-using-group-by-having",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT customer_id\\nFROM customer\\nGROUP BY 1\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT customer_id\\nFROM customer\\nGROUP BY 1\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054535,
                "title": "mysql-simple-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy initial thought is that we want to identify customers who have purchased every distinct product available. This means the count of distinct products associated with a customer must match the total count of distinct products in the product table\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSubquery for Total Products: Use a subquery to determine the total count of distinct products from the product table.\\nGrouping and Filtering: Group the customer table by customer_id and filter out customers whose count of distinct product_key values doesn\\'t match the total count from the subquery.\\nFinal Selection: Select the customer_id of customers who meet the above criteria, indicating they have purchased every available product.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe main query will group by customer_id and count the distinct product_key for each customer. In the worst case, this will have a time complexity of  O(c\\xD7p), where \\nc is the number of customers and \\np is the number of products a customer has purchased.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(product_key) from product);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(product_key) from product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049334,
                "title": "1045-mysql-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING SUM(DISTINCT product_key) = (SELECT SUM(product_key) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING SUM(DISTINCT product_key) = (SELECT SUM(product_key) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047956,
                "title": "using-groupby-having-and-subquery",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nSelect distinct customer_id\\nFrom Customer \\nGroup by customer_id\\nhaving count(distinct product_key) = (\\n    Select count(product_key)\\n    From Product\\n)\\nOrder by customer_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSelect distinct customer_id\\nFrom Customer \\nGroup by customer_id\\nhaving count(distinct product_key) = (\\n    Select count(product_key)\\n    From Product\\n)\\nOrder by customer_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047641,
                "title": "super-easy-using-having-clause-mssql-server",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT c.customer_id \\nFROM Customer c \\nGROUP BY c.customer_id \\nHAVING COUNT(DISTINCT(c.product_key)) = (SELECT COUNT(*) FROM Product)\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT c.customer_id \\nFROM Customer c \\nGROUP BY c.customer_id \\nHAVING COUNT(DISTINCT(c.product_key)) = (SELECT COUNT(*) FROM Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046769,
                "title": "best-and-easy-to-get-solution",
                "content": "\\n\\n# Code\\n```\\nSelect customer_id \\nfrom customer\\ngroup by customer_id\\nhaving count(Distinct product_key) = (Select count(distinct product_key) \\n                                      from product)\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSelect customer_id \\nfrom customer\\ngroup by customer_id\\nhaving count(Distinct product_key) = (Select count(distinct product_key) \\n                                      from product)\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045816,
                "title": "subquery-count-distinct",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id \\nFROM\\n(SELECT customer_id,\\nCOUNT(DISTINCT(product_key)) as cnt \\nFROM Customer \\nGROUP BY customer_id) as t\\nWHERE t.cnt = (SELECT COUNT(product_key) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id \\nFROM\\n(SELECT customer_id,\\nCOUNT(DISTINCT(product_key)) as cnt \\nFROM Customer \\nGROUP BY customer_id) as t\\nWHERE t.cnt = (SELECT COUNT(product_key) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045475,
                "title": "quick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key)from Product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  customer_id\\nfrom customer\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key)from Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045134,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nselect customer_id\\nfrom Customer c\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_id\\nfrom Customer c\\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044434,
                "title": "easy-solution-group-by-having",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse count clause to check if all products have been bought by a single customer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly group all data by the customer id then use having clause to count which one of them have bought all products\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.customer_id\\nfrom Customer c\\ngroup by c.customer_id\\nhaving count(distinct(c.product_key)) = (select count(p.product_key) from Product p);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.customer_id\\nfrom Customer c\\ngroup by c.customer_id\\nhaving count(distinct(c.product_key)) = (select count(p.product_key) from Product p);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044252,
                "title": "oracle-group-by-having",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect c.customer_id\\nfrom customer c\\ngroup by c.customer_id\\nhaving count(distinct c.product_key)=(select count(*) as pcnt from product)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect c.customer_id\\nfrom customer c\\ngroup by c.customer_id\\nhaving count(distinct c.product_key)=(select count(*) as pcnt from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038338,
                "title": "simple-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038174,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nI thought I could do it by grouping the customer_id and using the HAVING clause I could do the comparison with the total products.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI did not need to specify in the HAVING clause that the IDs were distinct because the statement mentions that some rows are repeated.\\n\\n# Complexity\\n- Time complexity: 30 min\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (SELECT COUNT(product_key) FROM Product)\\n \\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (SELECT COUNT(product_key) FROM Product)\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035623,
                "title": "my-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct a.customer_id  from Customer a\\nwhere (select count( distinct product_key ) from Customer b \\nwhere b.customer_id  = a.customer_id )\\n = \\n(select count( * )  from Product ) \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct a.customer_id  from Customer a\\nwhere (select count( distinct product_key ) from Customer b \\nwhere b.customer_id  = a.customer_id )\\n = \\n(select count( * )  from Product ) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034603,
                "title": "mysql-1045-customers-who-bought-all-products-easy-understandable-solution-using-sub-query",
                "content": "```Approach []\\nThe problem was asked to find all the customer_id who bought all the products with `product_key` that are available in `Product` table.\\nSo In order to do go through the following steps:\\n 1. First count the total number of distinct product_id in Product table as a sub-query.\\n        \"(SELECT count(DISTINCT product_key) FROM Product)\"\\n 2. Then retrive the customer_id from `Customer` table by grouping the rows based on customer_id.\\n        \"SELECT customer_id FROM Customer GROUP BY customer_id\"\\n 3. Now pass the condition in HAVING clause to check whether the total number of distinct \\n    product_key in Customer table matches with total number of distinct product_id in Product table.\\n        \"HAVING count(DISTINCT product_id) = (SELECT count(DISTINCT product_key) FROM Product)\"\\n```\\n\\n# Code\\n```MySQL []\\n\\nSELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(DISTINCT product_key) = (SELECT count(DISTINCT product_key) FROM Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```Approach []\\nThe problem was asked to find all the customer_id who bought all the products with `product_key` that are available in `Product` table.\\nSo In order to do go through the following steps:\\n 1. First count the total number of distinct product_id in Product table as a sub-query.\\n        \"(SELECT count(DISTINCT product_key) FROM Product)\"\\n 2. Then retrive the customer_id from `Customer` table by grouping the rows based on customer_id.\\n        \"SELECT customer_id FROM Customer GROUP BY customer_id\"\\n 3. Now pass the condition in HAVING clause to check whether the total number of distinct \\n    product_key in Customer table matches with total number of distinct product_id in Product table.\\n        \"HAVING count(DISTINCT product_id) = (SELECT count(DISTINCT product_key) FROM Product)\"\\n```\n```MySQL []\\n\\nSELECT customer_id \\nFROM Customer\\nGROUP BY customer_id\\nHAVING count(DISTINCT product_key) = (SELECT count(DISTINCT product_key) FROM Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030731,
                "title": "really-straight-forward-subquery-approach-mysql-without-joins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id from Customer \\ngroup by customer_id \\nhaving count(distinct product_key)=(select count(product_key) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id from Customer \\ngroup by customer_id \\nhaving count(distinct product_key)=(select count(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028284,
                "title": "beats-100-easy-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect customer_id From Customer\\nGroup by customer_id\\nHaving count(distinct product_key) = (select count(product_key) from Product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect customer_id From Customer\\nGroup by customer_id\\nHaving count(distinct product_key) = (select count(product_key) from Product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027783,
                "title": "simple-solutin-which-beats-65",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT c.customer_id FROM Customer c LEFT JOIN Product p\\nON c.product_key =p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key)=(SELECT COUNT(product_key) FROM Product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT c.customer_id FROM Customer c LEFT JOIN Product p\\nON c.product_key =p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key)=(SELECT COUNT(product_key) FROM Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027072,
                "title": "with-cte-count-any-case",
                "content": "```\\nwith b as \\n(\\nwith a \\nas\\n(\\n    # Write your MySQL query statement below\\nselect  c.customer_id  , case when p.product_key = c.product_key then 1 end as key_search , c.product_key  from customer c  , product p\\n#left join product p \\n#on p.product_key = c.product_key \\n)\\nselect customer_id , count(distinct product_key) as cnt from a \\nwhere case when key_search = 0 then 0 else 1 end \\ngroup by customer_id  , key_search\\n)\\nselect distinct customer_id from  b\\nwhere cnt >=  any (select count(distinct product_key) from product)\\n```",
                "solutionTags": [],
                "code": "```\\nwith b as \\n(\\nwith a \\nas\\n(\\n    # Write your MySQL query statement below\\nselect  c.customer_id  , case when p.product_key = c.product_key then 1 end as key_search , c.product_key  from customer c  , product p\\n#left join product p \\n#on p.product_key = c.product_key \\n)\\nselect customer_id , count(distinct product_key) as cnt from a \\nwhere case when key_search = 0 then 0 else 1 end \\ngroup by customer_id  , key_search\\n)\\nselect distinct customer_id from  b\\nwhere cnt >=  any (select count(distinct product_key) from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023592,
                "title": "simeple-easy-solution-query-ran-in-650-ms",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below \\nwith cte1 as (\\n        select distinct * from product\\n    )\\n    ,cte2 as (\\n        select distinct * from customer\\n    )\\nselect customer_id \\nfrom cte2 \\ngroup by customer_id \\nhaving count(product_key) = (select count(product_key) from cte1)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below \\nwith cte1 as (\\n        select distinct * from product\\n    )\\n    ,cte2 as (\\n        select distinct * from customer\\n    )\\nselect customer_id \\nfrom cte2 \\ngroup by customer_id \\nhaving count(product_key) = (select count(product_key) from cte1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018330,
                "title": "self-explanatory-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct(product_key)) = (\\n  select count(*)\\n  from product\\n)\\norder by customer_id ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect customer_id\\nfrom customer \\ngroup by customer_id\\nhaving count(distinct(product_key)) = (\\n  select count(*)\\n  from product\\n)\\norder by customer_id ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015489,
                "title": "2-mysql-solution-using-joins-count-and-having",
                "content": "# Code\\n### using joins gave better runtime\\n\\n```mysql []\\nSELECT c.customer_id\\nFROM Customer c\\nLEFT JOIN Product p ON c.product_key = p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT p.product_key) = (SELECT COUNT(*) FROM Product);\\n```\\n\\nWithout Joins\\n\\n```\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```mysql []\\nSELECT c.customer_id\\nFROM Customer c\\nLEFT JOIN Product p ON c.product_key = p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT p.product_key) = (SELECT COUNT(*) FROM Product);\\n```\n```\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013596,
                "title": "simple-solution-using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Join\\n2) Group by\\n3) compare count\\'s\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect c.customer_id from Customer c join Product p on c.product_key=p.product_key  group by c.customer_id having count(distinct c.product_key)=(SELECT COUNT(*) FROM Product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect c.customer_id from Customer c join Product p on c.product_key=p.product_key  group by c.customer_id having count(distinct c.product_key)=(SELECT COUNT(*) FROM Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013249,
                "title": "beats-90-solutions-and-easy-to-understand-using-join-count",
                "content": "\\n\\n# Code\\n```\\nSELECT\\n    c.customer_id\\nFROM\\n    Customer c\\nJOIN\\n    Product p\\nON\\n    c.product_key = p.product_key\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    c.customer_id\\nFROM\\n    Customer c\\nJOIN\\n    Product p\\nON\\n    c.product_key = p.product_key\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011409,
                "title": "easy-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect customer_id from customer group by customer_id having count(distinct product_key) = (select count(*) from product) ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect customer_id from customer group by customer_id having count(distinct product_key) = (select count(*) from product) ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008198,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Having usually works after the aggregation operation  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect customer_id \\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct(product_key)) = (select count(product_key) from Product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_id \\nfrom Customer\\ngroup by customer_id\\nhaving count(distinct(product_key)) = (select count(product_key) from Product)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007850,
                "title": "easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id\\nfrom (\\n  select customer_id, count(distinct(product_key)) as product_count\\n  from Customer\\n  group by customer_id\\n) as t\\nwhere t.product_count = (\\n  select count(*)\\n  from Product\\n)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id\\nfrom (\\n  select customer_id, count(distinct(product_key)) as product_count\\n  from Customer\\n  group by customer_id\\n) as t\\nwhere t.product_count = (\\n  select count(*)\\n  from Product\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003818,
                "title": "70-beats-mysql-solution-no-join-using-subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT c.Customer_id\\nFROM Customer c\\nGROUP BY c.customer_id\\nHAVING COUNT( distinct product_key) = (\\n  SELECT count(product_key)\\n  FROM product\\n)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT c.Customer_id\\nFROM Customer c\\nGROUP BY c.customer_id\\nHAVING COUNT( distinct product_key) = (\\n  SELECT count(product_key)\\n  FROM product\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002548,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect customer_id from Customer group by customer_id having count(distinct product_key)=(Select count(product_key)from product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect customer_id from Customer group by customer_id having count(distinct product_key)=(Select count(product_key)from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001571,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect customer_id \\nfrom customer\\ngroup by customer_id\\nhaving  count(distinct product_key) = (select count(product_key) as total from product)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect customer_id \\nfrom customer\\ngroup by customer_id\\nhaving  count(distinct product_key) = (select count(product_key) as total from product)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999127,
                "title": "complicate-solution",
                "content": "\\n# Code\\n```\\nSELECT a.customer_id FROM \\n(SELECT customer_id,GROUP_CONCAT(distinct product_key ORDER BY product_key) AS pk FROM customer GROUP BY customer_id) AS a\\nINNER JOIN\\n(SELECT GROUP_CONCAT(product_key ORDER BY product_key) AS pk FROM product) AS b \\nON a.pk=b.pk;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT a.customer_id FROM \\n(SELECT customer_id,GROUP_CONCAT(distinct product_key ORDER BY product_key) AS pk FROM customer GROUP BY customer_id) AS a\\nINNER JOIN\\n(SELECT GROUP_CONCAT(product_key ORDER BY product_key) AS pk FROM product) AS b \\nON a.pk=b.pk;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998107,
                "title": "subquery-clear-easy-sql-step-by-step-correct-formatting-comprehensive-explanation",
                "content": "# \\u2757 Upvote \\u2B06 if you found this useful \\u2714\\n\\n# \\uD83D\\uDCA1 Intuition (hint)\\n\\nCan be solved with subquery inside easy main query with aggregating functions. \\n\\n# \\uD83C\\uDFAF Approach (solution)\\n\\nLets divide the solution into 2 steps:\\n1. First step\\n```sql\\n(SELECT COUNT(DISTINCT product_key) FROM Product)\\n```\\n- This subquery finds the total amount of distinct products\\n\\n2. Second step\\n```sql\\nSELECT DISTINCT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) =\\n```\\n- This subquery returns a list of DISTINCT *customer_id* for all clients that bought COUNTed amount of distinct products equal to the result of first step subquery\\n\\n# \\uD83D\\uDCC8 Complexity\\n\\n- \\u23F1 Time complexity:\\nBeats 82% of solutions with MySQL (at the time of submission)\\n\\n- \\uD83D\\uDCBE Space complexity:\\nBeats 100% of solutions with MySQL (space complexity in case of this problem is constant for all solutions)\\n\\n# \\uD83D\\uDD25 Code\\n\\n```sql\\nSELECT DISTINCT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product);\\n```\\n# \\u2757 Upvote \\u2B06 if you found this useful \\u2714",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\n(SELECT COUNT(DISTINCT product_key) FROM Product)\\n```\n```sql\\nSELECT DISTINCT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) =\\n```\n```sql\\nSELECT DISTINCT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) FROM Product);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994849,
                "title": "beats-80",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect customer_id \\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product )\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect customer_id \\nfrom customer \\ngroup by customer_id\\nhaving count(distinct product_key) = (select count(*) from product )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994599,
                "title": "100-easy-explain-fast-clean",
                "content": "# Intuition\\n\\nIn the HAVING clause, we compare two counts:\\n\\nCOUNT(DISTINCT c.product_key) counts the distinct products each customer has purchased.\\nCOUNT(DISTINCT p.product_key) counts the distinct products available in the entire product table.\\nIf the count of distinct products purchased by a customer equals the count of distinct products available, that customer is included in the result set.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect c.customer_id \\nfrom customer as c, product as p\\ngroup by c.customer_id \\nhaving count(distinct c.product_key) = count(distinct p.product_key);\\n```\\n\\n\\n![4i88GgaV8qiGEw1xifwYz2xp7RJEnNpBZq7dn2K62dyucR1bKCQQP3oJkTQN1CtPmpu1MeKqPh9TVeVMTj9qvJMVzGQMPgTQYFYBh8Uj21b7rmMLxNytGKJ1C2.jpeg](https://assets.leetcode.com/users/images/70dc8293-3453-4a90-bf58-9e8e2c21991a_1693704925.576871.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect c.customer_id \\nfrom customer as c, product as p\\ngroup by c.customer_id \\nhaving count(distinct c.product_key) = count(distinct p.product_key);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990681,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT c.customer_id \\nFROM Customer c\\nINNER JOIN Product p ON c.product_key = p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT c.customer_id \\nFROM Customer c\\nINNER JOIN Product p ON c.product_key = p.product_key\\nGROUP BY c.customer_id\\nHAVING COUNT(DISTINCT c.product_key) = (SELECT COUNT(*) FROM Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990234,
                "title": "sql-customers-who-bought-all-products",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(distinct(product_key))=(SELECT COUNT(*) FROM Product);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(distinct(product_key))=(SELECT COUNT(*) FROM Product);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989951,
                "title": "ms-sql-server-explication",
                "content": "\\n# Approach\\n\\n1. We need to find the number of products for all customer_id\\n2. Count all products\\n\\n\\nWe will transform (point 1) in our first sub-query from code, i used in finding all customers that have all the n products\\n\\nWith the second point force the table customers to show up with all customers that have the n products\\n\\n\\n# Code\\n```\\n\\nSelect distinct customer_id FROM Customer c\\nJOIN (Select c1.customer_id c , count(distinct c1.product_key ) n FROM Customer c1 Group by customer_id) c2\\nON c.customer_id = c2.c\\nWhere c2.n = (Select count(*) FROM Product )\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n\\nSelect distinct customer_id FROM Customer c\\nJOIN (Select c1.customer_id c , count(distinct c1.product_key ) n FROM Customer c1 Group by customer_id) c2\\nON c.customer_id = c2.c\\nWhere c2.n = (Select count(*) FROM Product )\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3988353,
                "title": "fast-easy-sql-solution-using-sum",
                "content": "# Intuition\\nAs long as we have key value of int type, we can simply calculate sum of all uniqe products bought by each customer and sum of keys of Product table, then compare these two sums.\\n\\n# Approach\\nFirst, I fetched only unique pairs of *customer_id* and *product_key*, the summarized them *over partition by customer_id*. Calculated sum of *product_key* from Product table as well. Then comaped above sums and provided as a result *customer_id*s where they are equal.\\n\\n# Complexity\\n- Time complexity: 1133ms\\n\\n- Space complexity: 0.00MB\\n\\n# Code\\n```\\nselect\\n  customer_id\\nfrom (select distinct customer_id, sum(product_key) over (partition by customer_id) as keys_sum\\n      from (select distinct customer_id, product_key from Customer) t) t1\\nwhere keys_sum = (select sum(product_key) from Product)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n  customer_id\\nfrom (select distinct customer_id, sum(product_key) over (partition by customer_id) as keys_sum\\n      from (select distinct customer_id, product_key from Customer) t) t1\\nwhere keys_sum = (select sum(product_key) from Product)\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575825,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1565547,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1576381,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1887401,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1732920,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1935858,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1574812,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1572901,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1885021,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1872325,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1575825,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1565547,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1576381,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1887401,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1732920,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1935858,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1574812,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1572901,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1885021,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            },
            {
                "id": 1872325,
                "content": [
                    {
                        "username": "trex88",
                        "content": "\\n\\n-- number of products \\n-- customer id who bought all the distinct products \\n\\n\\n\\n\\tselect customer_id from customer \\n\\tgroup by \\n\\tcustomer_id\\n\\thaving count(distinct product_key ) = (select count(product_key ) from product)"
                    },
                    {
                        "username": "kirakira1992",
                        "content": "---The other solutions only count the numbers and check if the same, but if the customer buys product from not the second table, that solution is incorrect.\\n\\nselect customer_id\\nfrom\\n(\\nselect c.customer_id,p.product_key\\nfrom\\ncustomer c inner join product p\\non c.product_key = p.product_key\\n\\n) c_p\\ngroup by customer_id\\nhaving count(distinct product_key) = \\n(select count(distinct product_key) from product)"
                    },
                    {
                        "username": "aarcot100",
                        "content": "product key is a foreign key to Product table so this is impossible"
                    },
                    {
                        "username": "sumitsingh2415",
                        "content": "\\nselect customer_id from customer group by customer_id having count(distinct product_key)=(select count(*) from product)"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Group by customer_id and set condition in having clause as if count of distinct product_key is equal to count of product_key in product tablle.\\n[Solution](https://leetcode.com/problems/customers-who-bought-all-products/solutions/3501467/group-by/)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "EASY_Solution in MS-SQL \\n\\nSELECT c.customer_id FROM  Customer c\\nGROUP BY\\n    c.customer_id\\nHAVING\\n    count(DISTINCT product_key) = (SELECT count(*) FROM Product);"
                    },
                    {
                        "username": "MrAu11",
                        "content": "SELECT  c.customer_id\\nFROM Customer c  JOIN Product p \\nON c.product_key = p.product_key \\nGROUP BY 1\\nHAVING  COUNT(DISTINCT p.product_key) = (SELECT COUNT(product_key) FROM Product);"
                    },
                    {
                        "username": "yelian",
                        "content": "I came up a solution to match count(customer.product_key) = product.product_key,i works for test data but when I submit, it doesn\\'t work\\n\\nelect customer_id\\nfrom customer\\ngroup by  customer_id\\nhaving count(product_key) = (\\nselect count (distinct product_key)\\nfrom product)\\n\\n"
                    },
                    {
                        "username": "xr2129",
                        "content": "Hi,\\nI am just wondering if someone accidentally enter a wrong product_key for a customer in the CUSTOMER table, is there any way to solve it?\\nLet say for Customer 1 in the example, someone enter another entry whose product_key is 100. It\\'s clear the Customer 1 still bought product 5 and 6 so we should select him for the question. However, using count() won\\'t work because there is the third wrong product_key. \\n\\nAnyone can think of a solution for this scenario?\\n"
                    },
                    {
                        "username": "Egisess",
                        "content": "You\\'re welcome\\n\\nWITH\\nall_prod_concat as\\n(\\n    SELECT LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM product\\n),\\n\\ndistinct_customer as\\n(\\n    SELECT distinct customer_id, product_key FROM Customer\\n),\\n\\nbought_items as\\n(\\n    SELECT customer_id, LISTAGG(product_key, \\'\\') WITHIN GROUP (ORDER BY product_key) as id\\n    FROM distinct_customer \\n    GROUP BY customer_id\\n)\\n\\nSELECT customer_id\\nFROM bought_items join all_prod_concat on bought_items.id = all_prod_concat.id\\n"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "Select customer_id\\nFROM Customer\\nGROUP BY customer_id\\nHAVING COUNT(DISTINCT(product_key)) = (\\n  SELECT Count(*)\\n  FROM Product\\n) "
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select customer_id from customer \\ngroup by customer_id\\nhaving count(distinct product_key)=(select count(distinct product_key) from product)\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Good Triplets",
        "question_content": "<p>Given an array of integers <code>arr</code>, and three integers&nbsp;<code>a</code>,&nbsp;<code>b</code>&nbsp;and&nbsp;<code>c</code>. You need to find the number of good triplets.</p>\r\n\r\n<p>A triplet <code>(arr[i], arr[j], arr[k])</code>&nbsp;is <strong>good</strong> if the following conditions are true:</p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>\r\n\t<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\r\n\t<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\r\n\t<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\r\n</ul>\r\n\r\n<p>Where <code>|x|</code> denotes the absolute value of <code>x</code>.</p>\r\n\r\n<p>Return<em> the number of good triplets</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong>&nbsp;There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [1,1,2,2,3], a = 0, b = 0, c = 1\r\n<strong>Output:</strong> 0\r\n<strong>Explanation: </strong>No triplet satisfies all conditions.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>3 &lt;= arr.length &lt;= 100</code></li>\r\n\t<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\r\n\t<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 768064,
                "title": "self-explanatory-code-bf-little-optimization-bf",
                "content": "Just do what question says and count good triplets \\n\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int n = arr.length;\\n        for(int i = 0; i < n -2; i++) {\\n            for(int j = i + 1; j < n - 1; j++) {\\n                for(int k = j + 1; k < n; k++) {\\n                    if(Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[k] - arr[i]) <= c)\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n\\nLittle optimization as per @gupta-pramod suggestion\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int n = arr.length;\\n        for(int i = 0; i < n -2; i++) {\\n            for(int j = i + 1; j < n - 1; j++) {\\n                if(Math.abs(arr[i] - arr[j]) <= a) { // check if satisfy then loop for k\\n                    for(int k = j + 1; k < n; k++) {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[k] - arr[i]) <= c)\\n                            count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int n = arr.length;\\n        for(int i = 0; i < n -2; i++) {\\n            for(int j = i + 1; j < n - 1; j++) {\\n                for(int k = j + 1; k < n; k++) {\\n                    if(Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[k] - arr[i]) <= c)\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int n = arr.length;\\n        for(int i = 0; i < n -2; i++) {\\n            for(int j = i + 1; j < n - 1; j++) {\\n                if(Math.abs(arr[i] - arr[j]) <= a) { // check if satisfy then loop for k\\n                    for(int k = j + 1; k < n; k++) {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[k] - arr[i]) <= c)\\n                            count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768170,
                "title": "easy-brute-force-modular-clean-code",
                "content": "Just the implementation of english statement into programming language is needed here.\\n\\n**Thanks**\\nPlease upvote if you like the code so that it remains near the top and the learners can see it :)\\nIt also encourages me to write on Leetcode and on my blog/website.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGood(int first, int second, int third, int a, int b, int c) {\\n        return abs(first-second) <= a && abs(second-third) <= b && abs(first-third) <= c;\\n    }\\n    \\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for (int i=0; i<n; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                for (int k=j+1; k<n; k++) {\\n                    if (isGood(arr[i], arr[j], arr[k], a, b, c)) {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGood(int first, int second, int third, int a, int b, int c) {\\n        return abs(first-second) <= a && abs(second-third) <= b && abs(first-third) <= c;\\n    }\\n    \\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for (int i=0; i<n; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                for (int k=j+1; k<n; k++) {\\n                    if (isGood(arr[i], arr[j], arr[k], a, b, c)) {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768459,
                "title": "o-n-2-solution",
                "content": "Case 1: c >= a + b\\nThe last inequality follows from the first and second. For a fixed value `j` we can count the number of `i` that satisfy the first inequality, the number of `k` that satisfy the second one and multiply this numbers to get the number of triples for the fixed value `j`.\\n\\nCase 2: c < a + b\\nWe count the number of triples for a fixed value `j` again, but this is slightly harder. The algorithm has the following key steps:\\n1. Sort the numbers to the left and to the right of `arr[j]`.\\n2. Find the range `[i_min,i_max)` of `i` such that `|arr[i] - arr[j]| <= a`.\\n3. Find the range of `k` such that `|arr[j] - arr[k]| <= b`.\\n4. For every `k` find subrange of `i` such that `|arr[i] - arr[k]| <= c`.\\n5. Add up lengths of the subranges from step 4.\\n\\nIn the implementation `index` array is used to store indicies of the elements in the sorted array (`arr` in not changed) and sorting from step 1 is optimized. In the first loop `arr[j]` is placed in its original place `j`. The second loop is an insertion sort that moves `arr[j + 1]` to the correct place.\\n\\nTime complexity: O(n^2)\\nSpace complexity: O(n)\\n\\n```\\nclass Solution\\n{\\n    int countGoodTripletsCase1(vector<int>& arr, int a, int b)\\n    {\\n        // Case 1: c >= a + b\\n        // |arr[i] - arr[k]| <= |arr[i] - arr[j]| + |arr[j] - arr[k]| <= a + b <= c.\\n        int count = 0;\\n        for (int j = arr.size() - 2; j > 0; j--) {\\n            int l = 0, r = 0;\\n            for (int i = 0; i < j; i++)\\n                if (abs(arr[i] - arr[j]) <= a) l++;\\n            for (int k = j + 1; k < arr.size(); k++)\\n                if (abs(arr[j] - arr[k]) <= b) r++;\\n            count += l * r;\\n        }\\n        return count;\\n    }\\n    int countGoodTripletsCase2(vector<int>& arr, int a, int b, int c)\\n    {\\n        // Case 2: c < a + b\\n        vector<int> index(arr.size());\\n        std::iota(index.begin(), index.end(), 0);\\n        std::sort(index.begin(), index.end(),\\n                  [&arr](auto a, auto b) { return arr[a] < arr[b]; });\\n        \\n        int count = 0;\\n        for (int j = arr.size() - 1; j > 0; j--) {\\n            for (int i = j - 1; index[j] != j && i >= 0; i--)\\n                swap(index[j], index[i]);\\n            for (int k = j + 2; k < arr.size(); k++)\\n                if (arr[index[k - 1]] > arr[index[k]])\\n                    swap(index[k - 1], index[k]);\\n            \\n            int i_min = 0;\\n            while (i_min < j && arr[index[i_min]] < arr[j] - a) i_min++;\\n            int i_max = i_min;\\n            while (i_max < j && arr[index[i_max]] <= arr[j] + a) i_max++;\\n            \\n            int k = j + 1;\\n            while (k < arr.size() && arr[index[k]] < arr[j] - b) k++;\\n            int ic_min = i_min, ic_max = i_min;\\n            while (k < arr.size() && arr[index[k]] <= arr[j] + b) {\\n                while (ic_min < i_max && arr[index[ic_min]] < arr[index[k]] - c) ic_min++;\\n                while (ic_max < i_max && arr[index[ic_max]] <= arr[index[k]] + c) ic_max++;\\n                count += ic_max - ic_min;\\n                k++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c)\\n    {\\n        if (c >= a + b)\\n            return countGoodTripletsCase1(arr, a, b);\\n        return countGoodTripletsCase2(arr, a, b, c);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int countGoodTripletsCase1(vector<int>& arr, int a, int b)\\n    {\\n        // Case 1: c >= a + b\\n        // |arr[i] - arr[k]| <= |arr[i] - arr[j]| + |arr[j] - arr[k]| <= a + b <= c.\\n        int count = 0;\\n        for (int j = arr.size() - 2; j > 0; j--) {\\n            int l = 0, r = 0;\\n            for (int i = 0; i < j; i++)\\n                if (abs(arr[i] - arr[j]) <= a) l++;\\n            for (int k = j + 1; k < arr.size(); k++)\\n                if (abs(arr[j] - arr[k]) <= b) r++;\\n            count += l * r;\\n        }\\n        return count;\\n    }\\n    int countGoodTripletsCase2(vector<int>& arr, int a, int b, int c)\\n    {\\n        // Case 2: c < a + b\\n        vector<int> index(arr.size());\\n        std::iota(index.begin(), index.end(), 0);\\n        std::sort(index.begin(), index.end(),\\n                  [&arr](auto a, auto b) { return arr[a] < arr[b]; });\\n        \\n        int count = 0;\\n        for (int j = arr.size() - 1; j > 0; j--) {\\n            for (int i = j - 1; index[j] != j && i >= 0; i--)\\n                swap(index[j], index[i]);\\n            for (int k = j + 2; k < arr.size(); k++)\\n                if (arr[index[k - 1]] > arr[index[k]])\\n                    swap(index[k - 1], index[k]);\\n            \\n            int i_min = 0;\\n            while (i_min < j && arr[index[i_min]] < arr[j] - a) i_min++;\\n            int i_max = i_min;\\n            while (i_max < j && arr[index[i_max]] <= arr[j] + a) i_max++;\\n            \\n            int k = j + 1;\\n            while (k < arr.size() && arr[index[k]] < arr[j] - b) k++;\\n            int ic_min = i_min, ic_max = i_min;\\n            while (k < arr.size() && arr[index[k]] <= arr[j] + b) {\\n                while (ic_min < i_max && arr[index[ic_min]] < arr[index[k]] - c) ic_min++;\\n                while (ic_max < i_max && arr[index[ic_max]] <= arr[index[k]] + c) ic_max++;\\n                count += ic_max - ic_min;\\n                k++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c)\\n    {\\n        if (c >= a + b)\\n            return countGoodTripletsCase1(arr, a, b);\\n        return countGoodTripletsCase2(arr, a, b, c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772455,
                "title": "python-sol-with-generator-and-loops",
                "content": "Python sol with generator and loops\\n\\n---\\n\\n**Implementation** by nested loops:\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        size = len(arr)\\n        \\n        good_count = 0\\n        \\n        for i in range(size-2):\\n            for j in range(i+1, size-1):\\n                for k in range(j+1, size):\\n                    \\n                    ok_a = abs(arr[i] - arr[j]) <= a\\n                    ok_b = abs(arr[j] - arr[k]) <= b\\n                    ok_c = abs(arr[i] - arr[k]) <= c\\n                    \\n                    if all((ok_a, ok_b, ok_c)):\\n                        good_count += 1\\n                        \\n                        \\n        return good_count\\n\\n```\\n\\n---\\n\\n**Implementation** by generator expression and sum:\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        \\n        def is_good(i, j, k):\\n            \\n            ok_a = abs(arr[i] - arr[j]) <= a\\n            ok_b = abs(arr[j] - arr[k]) <= b\\n            ok_c = abs(arr[i] - arr[k]) <= c\\n\\n            return all((ok_a, ok_b, ok_c))\\n        \\n        # -------------------------------------\\n        \\n        size = len(arr)\\n            \\n        return sum(1 for i in range(size-2) for j in range(i+1, size-1) for k in range(j+1, size) if is_good(i,j,k))\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about generator expression](https://www.python.org/dev/peps/pep-0289/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        size = len(arr)\\n        \\n        good_count = 0\\n        \\n        for i in range(size-2):\\n            for j in range(i+1, size-1):\\n                for k in range(j+1, size):\\n                    \\n                    ok_a = abs(arr[i] - arr[j]) <= a\\n                    ok_b = abs(arr[j] - arr[k]) <= b\\n                    ok_c = abs(arr[i] - arr[k]) <= c\\n                    \\n                    if all((ok_a, ok_b, ok_c)):\\n                        good_count += 1\\n                        \\n                        \\n        return good_count\\n\\n```\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        \\n        def is_good(i, j, k):\\n            \\n            ok_a = abs(arr[i] - arr[j]) <= a\\n            ok_b = abs(arr[j] - arr[k]) <= b\\n            ok_c = abs(arr[i] - arr[k]) <= c\\n\\n            return all((ok_a, ok_b, ok_c))\\n        \\n        # -------------------------------------\\n        \\n        size = len(arr)\\n            \\n        return sum(1 for i in range(size-2) for j in range(i+1, size-1) for k in range(j+1, size) if is_good(i,j,k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769821,
                "title": "java-o-n-well-it-is-really-o-1000-n",
                "content": "Loop through the middle number, find out the lower and upper bounds for numbers before and after it. Then loop through the possible values before it, adjust the after bounds and add them up. (I am not good at words. This is the best I can do.)\\n \\nI think O(nlogn) is possible if Fenwick Tree is used to store the suffix sum.\\nI am too lazy to do it. (Actually, I am not sure about Fenwick Tree)\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int n = arr.length;\\n        int ans = 0;\\n        int[] pre = new int[1001];\\n        int[] post = new int[1001];  // stores suffix sum\\n        pre[arr[0]] = 1;\\n        for(int i = n-1; i > 1; i--) {\\n            post[arr[i]]++;\\n        }\\n        for(int i = 1; i <= 1000; i++) {\\n            post[i] = post[i-1] + post[i];\\n        }\\n        \\n        for(int j = 1; j < n-1; j++) {\\n            int v = arr[j];\\n            int p1 = Math.max(0, v-a);\\n            int p2 = Math.min(1000, v+a);\\n            int t1 = Math.max(0, v-b);\\n            int t2 = Math.min(1000, v+b);\\n            \\n            for(int s = p1; s <= p2; s++) {\\n                if (pre[s] == 0) continue;\\n                int m1 = Math.max(t1, s-c);\\n                int m2 = Math.min(t2, s+c);\\n                if (m2 >= m1) {\\n                    if (m1 == 0) {\\n                        ans += pre[s] * post[m2];\\n                    } else {\\n                        ans += pre[s] * (post[m2] - post[m1-1]);\\n                    }\\n                }\\n            }\\n            pre[v]++;\\n            for(int i = arr[j+1]; i <= 1000; i++) {\\n                post[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int n = arr.length;\\n        int ans = 0;\\n        int[] pre = new int[1001];\\n        int[] post = new int[1001];  // stores suffix sum\\n        pre[arr[0]] = 1;\\n        for(int i = n-1; i > 1; i--) {\\n            post[arr[i]]++;\\n        }\\n        for(int i = 1; i <= 1000; i++) {\\n            post[i] = post[i-1] + post[i];\\n        }\\n        \\n        for(int j = 1; j < n-1; j++) {\\n            int v = arr[j];\\n            int p1 = Math.max(0, v-a);\\n            int p2 = Math.min(1000, v+a);\\n            int t1 = Math.max(0, v-b);\\n            int t2 = Math.min(1000, v+b);\\n            \\n            for(int s = p1; s <= p2; s++) {\\n                if (pre[s] == 0) continue;\\n                int m1 = Math.max(t1, s-c);\\n                int m2 = Math.min(t2, s+c);\\n                if (m2 >= m1) {\\n                    if (m1 == 0) {\\n                        ans += pre[s] * post[m2];\\n                    } else {\\n                        ans += pre[s] * (post[m2] - post[m1-1]);\\n                    }\\n                }\\n            }\\n            pre[v]++;\\n            for(int i = arr[j+1]; i <= 1000; i++) {\\n                post[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770393,
                "title": "java-brutal-force",
                "content": "```\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int res = 0, n = arr.length;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (Math.abs(arr[i] - arr[j]) > a) continue;\\n                for (int k = j + 1; k < n; k++) {\\n                    if (Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[k] - arr[i]) <= c) res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int res = 0, n = arr.length;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (Math.abs(arr[i] - arr[j]) > a) continue;\\n                for (int k = j + 1; k < n; k++) {\\n                    if (Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[k] - arr[i]) <= c) res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772886,
                "title": "simple-brute-force-c-code-faster-runtime-than-100-and-lesser-memory-usage-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int ct = 0;\\n        for(int i = 0; i<arr.size()-2; i++)\\n        {\\n            for(int j = i+1; j<arr.size()-1; j++)\\n            {\\n                if(abs(arr[i]-arr[j])<=a)\\n                    for(int k = j+1; k<arr.size(); k++)\\n                    {\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                            ct++;\\n                    }\\n            }\\n        }\\n        return ct;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int ct = 0;\\n        for(int i = 0; i<arr.size()-2; i++)\\n        {\\n            for(int j = i+1; j<arr.size()-1; j++)\\n            {\\n                if(abs(arr[i]-arr[j])<=a)\\n                    for(int k = j+1; k<arr.size(); k++)\\n                    {\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                            ct++;\\n                    }\\n            }\\n        }\\n        return ct;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752765,
                "title": "c-easy-100-fast-optimized-brute-force-solution",
                "content": "**Upvote if you found solution helpful**\\n```C++\\nclass Solution\\n{\\npublic:\\n    int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (int k = j + 1; k < arr.size(); k++)\\n                    {\\n                        int B = abs(arr[j] - arr[k]);\\n                        int C = abs(arr[k] - arr[i]);\\n                        if (B <= b and C <= c)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (int k = j + 1; k < arr.size(); k++)\\n                    {\\n                        int B = abs(arr[j] - arr[k]);\\n                        int C = abs(arr[k] - arr[i]);\\n                        if (B <= b and C <= c)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768124,
                "title": "clean-python-3-100-faster-with-early-return",
                "content": "Just ignore impossible cases before checking all conditions.\\nTime: `O(N^3)`\\nSpace: `O(N)` for input `arr`\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        n, result = len(arr), 0\\n        for i in range(n):\\n            for k in range(i + 1, n):\\n                if abs(arr[i] - arr[k]) > c: continue\\n                result += sum(abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b\\n                              for j in range(i + 1, k))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        n, result = len(arr), 0\\n        for i in range(n):\\n            for k in range(i + 1, n):\\n                if abs(arr[i] - arr[k]) > c: continue\\n                result += sum(abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b\\n                              for j in range(i + 1, k))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951019,
                "title": "java-roughly-o-n-log-n-with-fenwick-tree",
                "content": "Check great solution by @SleepyFarmer from [here](https://leetcode.com/problems/count-good-triplets/discuss/769821/Java.-O(n).-Well-it-is-really-O(1000-*-n)).\\nHere, it is modified by using Fenwick tree. \\nThe time complexity seems to be O(n + n (2a * log n + log n)) ~ O(an * log n), where m is the maximum allowed value of arr[] elements.\\n\\n```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int m = 1000;\\n        int n = arr.length;\\n        \\n        int[] valuesBefore = new int[m+1];\\n        valuesBefore[arr[0]] = 1;\\n        \\n        Fenv valuesAfter = new Fenv(m+1);\\n        for(int i = 2; i < n; i++)\\n            valuesAfter.add(arr[i], 1);\\n        \\n        int ans = 0;\\n        for(int j = 1; j < n-1; j++) {\\n            int currVal = arr[j];\\n            int limUpA = Math.min(m, currVal + a);\\n            int limLoA = Math.max(0, currVal - a);\\n            \\n            int limUpB = Math.min(m, currVal + b);\\n            int limLoB = Math.max(0, currVal - b);\\n            for (int prevVal = limLoA; prevVal <= limUpA; prevVal++) {\\n                if (valuesBefore[prevVal] == 0)\\n                    continue;\\n                \\n                int limUpC = Math.min(prevVal + c, limUpB);\\n                int limLoC = Math.max(prevVal - c, limLoB);\\n                if (limLoC > limUpC)\\n                    continue;\\n                \\n                if (limLoC == 0)\\n                    ans += valuesBefore[prevVal]*valuesAfter.getSum(limUpC);\\n                else \\n                    ans += valuesBefore[prevVal]*valuesAfter.getSum(limLoC, limUpC);\\n            }\\n            valuesBefore[currVal]++;\\n            valuesAfter.add(arr[j+1], -1);\\n        }\\n        return ans;\\n    }\\n```\\n\\nFenwick tree implementation *for solving the problem*:\\n```\\nclass Fenv {\\n        private int[] tree;\\n\\n        public int getSum(int i, int j) {\\n            return getSum(j) - getSum(i-1);\\n        }\\n            \\n        public int getSum(int idx) {\\n            int res = 0;\\n            for (int i = idx + 1; i > 0; i -= i&(-i)) \\n                res += tree[i];\\n            return res;\\n        }\\n        \\n        public void add(int idx, int val) {\\n            for (int i = idx + 1; i < tree.length; i += i&(-i)) \\n                tree[i] += val;\\n        }\\n        \\n        public Fenv(int size) {\\n            tree = new int[size+1];\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int m = 1000;\\n        int n = arr.length;\\n        \\n        int[] valuesBefore = new int[m+1];\\n        valuesBefore[arr[0]] = 1;\\n        \\n        Fenv valuesAfter = new Fenv(m+1);\\n        for(int i = 2; i < n; i++)\\n            valuesAfter.add(arr[i], 1);\\n        \\n        int ans = 0;\\n        for(int j = 1; j < n-1; j++) {\\n            int currVal = arr[j];\\n            int limUpA = Math.min(m, currVal + a);\\n            int limLoA = Math.max(0, currVal - a);\\n            \\n            int limUpB = Math.min(m, currVal + b);\\n            int limLoB = Math.max(0, currVal - b);\\n            for (int prevVal = limLoA; prevVal <= limUpA; prevVal++) {\\n                if (valuesBefore[prevVal] == 0)\\n                    continue;\\n                \\n                int limUpC = Math.min(prevVal + c, limUpB);\\n                int limLoC = Math.max(prevVal - c, limLoB);\\n                if (limLoC > limUpC)\\n                    continue;\\n                \\n                if (limLoC == 0)\\n                    ans += valuesBefore[prevVal]*valuesAfter.getSum(limUpC);\\n                else \\n                    ans += valuesBefore[prevVal]*valuesAfter.getSum(limLoC, limUpC);\\n            }\\n            valuesBefore[currVal]++;\\n            valuesAfter.add(arr[j+1], -1);\\n        }\\n        return ans;\\n    }\\n```\n```\\nclass Fenv {\\n        private int[] tree;\\n\\n        public int getSum(int i, int j) {\\n            return getSum(j) - getSum(i-1);\\n        }\\n            \\n        public int getSum(int idx) {\\n            int res = 0;\\n            for (int i = idx + 1; i > 0; i -= i&(-i)) \\n                res += tree[i];\\n            return res;\\n        }\\n        \\n        public void add(int idx, int val) {\\n            for (int i = idx + 1; i < tree.length; i += i&(-i)) \\n                tree[i] += val;\\n        }\\n        \\n        public Fenv(int size) {\\n            tree = new int[size+1];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785120,
                "title": "javascript-clean-optimized-solution",
                "content": "```javascript\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let res = 0;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        \\n        for(let j = i+1; j < arr.length; j++) {\\n            if(Math.abs(arr[i] - arr[j]) > a) continue;\\n            \\n            for(let k = j+1; k < arr.length; k++) {\\n                if(Math.abs(arr[j] - arr[k]) > b) continue;\\n                if(Math.abs(arr[k] - arr[i]) <= c) res++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let res = 0;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        \\n        for(let j = i+1; j < arr.length; j++) {\\n            if(Math.abs(arr[i] - arr[j]) > a) continue;\\n            \\n            for(let k = j+1; k < arr.length; k++) {\\n                if(Math.abs(arr[j] - arr[k]) > b) continue;\\n                if(Math.abs(arr[k] - arr[i]) <= c) res++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564564,
                "title": "java-brute-force-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c){\\n      int i,j,k,count=0;\\n      for(i=0;i<(arr.length)-2;i++){\\n        for(j=i+1;j<(arr.length)-1;j++){\\n          if(Math.abs(arr[i]-arr[j]) <=a){\\n            for(k=j+1;k<arr.length;k++){\\n             if(Math.abs(arr[j]-arr[k]) <=b && Math.abs(arr[i]-arr[k]) <=c)\\n                  count++;\\n            }\\n          }\\n        }\\n      }\\n      return count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c){\\n      int i,j,k,count=0;\\n      for(i=0;i<(arr.length)-2;i++){\\n        for(j=i+1;j<(arr.length)-1;j++){\\n          if(Math.abs(arr[i]-arr[j]) <=a){\\n            for(k=j+1;k<arr.length;k++){\\n             if(Math.abs(arr[j]-arr[k]) <=b && Math.abs(arr[i]-arr[k]) <=c)\\n                  count++;\\n            }\\n          }\\n        }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880956,
                "title": "java-weirdly-satisfy-no-brackets",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int output = 0;\\n        \\n        for(int i = 0; i < arr.length -2; i++)\\n            for(int j = i+1; j < arr.length -1; j++)\\n                if(Math.abs(arr[i] - arr[j]) <= a)\\n                    for(int k = j+1; k < arr.length; k++)\\n                        if(Math.abs(arr[j] - arr[k]) <= b)\\n                            if(Math.abs(arr[i] - arr[k]) <= c)\\n                                output++;\\n\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int output = 0;\\n        \\n        for(int i = 0; i < arr.length -2; i++)\\n            for(int j = i+1; j < arr.length -1; j++)\\n                if(Math.abs(arr[i] - arr[j]) <= a)\\n                    for(int k = j+1; k < arr.length; k++)\\n                        if(Math.abs(arr[j] - arr[k]) <= b)\\n                            if(Math.abs(arr[i] - arr[k]) <= c)\\n                                output++;\\n\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489890,
                "title": "python-roughly-o-n-log-n-with-fenwick-tree",
                "content": "This is merely a python spin-off of 2 great solutions.\\n1. [Bucket sort ](https://leetcode.com/problems/count-good-triplets/discuss/769821/Java.-O(n).-Well-it-is-really-O(1000-*-n))\\n2. [Fenwick tree](https://leetcode.com/problems/count-good-triplets/discuss/951019/Java-Roughly-O(n-log-n)-with-Fenwick-Tree)\\n\\nI kid you not each of them deserve your full respect. The former is intricate in nature and the latter warrants plenty of understanding to bits manipulation, not to mention these two are merely the prelude to implementations that are solely dependent on programming language and your clear mind. A simple difference in syntax among programming languages could well be the next bug that catches you off-guard. I hope this justifies my contribution.\\n\\nAttached below is my Fenwick tree implementation. \\n\\n```\\nclass Fenwick:\\n    def __init__(self, size: int):\\n        self.partial = [0] * (size + 1)\\n        self.length = size + 1\\n    \\n    def getCum(self, end: int, start: int) -> int:\\n        return self.getSum(end) - self.getSum(start - 1)\\n    \\n    def getSum(self, index0: int) -> int:\\n        start1 = index0 + 1\\n        ans = 0\\n        while start1 > 0:\\n            ans += self.partial[start1]\\n            start1 &= (start1 - 1)\\n        return ans\\n    \\n    def addSum(self, i0:int, val: int):\\n        start1 = i0 + 1\\n        while True:\\n            self.partial[start1] += val\\n            start1 += start1 & (-start1)\\n            if start1 >= self.length:\\n                return\\n```\\n\\nUnfortunately, I think it is almost impossible to produce a bug-free implementation under time pressure. So instead of painstakingly memorizing minuscule off-by-one errors that you will surely forget in the next high octane full throttle interview, I would post a log that verrifies my Fenwick tree implementation for your reference.\\n\\n```\\na =  [7,3,7,3,12,1,12,2,3]\\nfen = Fenwick(len(a))\\nfor i, v in enumerate(a):\\n    fen.addSum(i,v)\\n\\nb = [v for v in a]\\nfor i in range(1, len(a) + 0):\\n    b[i] += b[i-1]\\nprint(b)\\n\\nfor i in range(1, len(b)):\\n    right = b[i]\\n    for j in range(0, i):\\n        left = b[j]\\n        print(f\"True? {(b[i] - b[j]) == fen.getCum(i , j)} (left,right): ({j},{i}); b[i] - b[j] = {b[i]} - {b[j]} = {b[i] - b[j]}\")\\n    print()\\n```\\n\\nWhat follows will be the solution that makes use of Fenwick tree.\\nI specifically commented out the lines that were used to caclulate post array in the old way. In so doing, you should be able to compare and see the difference in runtime by switching through lines.\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        pre = [0] * 1001\\n        post = Fenwick(1001)\\n        pre[arr[0]] += 1\\n        vi = 2\\n        while vi < 0 + len(arr):\\n            # post[arr[vi]] += 1\\n            post.addSum(arr[vi], 1)\\n            vi += 1\\n        # pi = 1 \\n        # while pi < 0 + len(post):\\n        #     post[pi] += post[pi-1]\\n        #     pi += 1\\n        i = 1\\n        ans = 0\\n        while i < 0 + len(arr) - 1:\\n            middle = arr[i]\\n            aupper = min(1000, middle + a)\\n            alower = max(0, middle - a)\\n            bupper = min(1000, middle + b)\\n            blower = max(0, middle - b)\\n            traversea = alower\\n            while traversea <= aupper:\\n                if pre[traversea]:\\n                    intersectlower = max(blower, traversea - c)\\n                    intersecupper = min(bupper, traversea + c)\\n                    if intersecupper >= intersectlower:\\n                        if not intersectlower:\\n                            # ans += pre[traversea] * post[intersecupper]\\n                            ans += pre[traversea] * post.getSum(intersecupper)\\n                        else:\\n                            # ans += pre[traversea] * (post[intersecupper] - post[intersectlower - 1])\\n                            ans += pre[traversea] * post.getCum(intersecupper, intersectlower)\\n                traversea += 1\\n            pre[middle] += 1\\n            vaftermiddle = arr[i + 1]\\n            # while vaftermiddle <= 1000:\\n            #     post[vaftermiddle] -= 1\\n            #     vaftermiddle += 1\\n            post.addSum(vaftermiddle, -1)\\n            i += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Fenwick:\\n    def __init__(self, size: int):\\n        self.partial = [0] * (size + 1)\\n        self.length = size + 1\\n    \\n    def getCum(self, end: int, start: int) -> int:\\n        return self.getSum(end) - self.getSum(start - 1)\\n    \\n    def getSum(self, index0: int) -> int:\\n        start1 = index0 + 1\\n        ans = 0\\n        while start1 > 0:\\n            ans += self.partial[start1]\\n            start1 &= (start1 - 1)\\n        return ans\\n    \\n    def addSum(self, i0:int, val: int):\\n        start1 = i0 + 1\\n        while True:\\n            self.partial[start1] += val\\n            start1 += start1 & (-start1)\\n            if start1 >= self.length:\\n                return\\n```\n```\\na =  [7,3,7,3,12,1,12,2,3]\\nfen = Fenwick(len(a))\\nfor i, v in enumerate(a):\\n    fen.addSum(i,v)\\n\\nb = [v for v in a]\\nfor i in range(1, len(a) + 0):\\n    b[i] += b[i-1]\\nprint(b)\\n\\nfor i in range(1, len(b)):\\n    right = b[i]\\n    for j in range(0, i):\\n        left = b[j]\\n        print(f\"True? {(b[i] - b[j]) == fen.getCum(i , j)} (left,right): ({j},{i}); b[i] - b[j] = {b[i]} - {b[j]} = {b[i] - b[j]}\")\\n    print()\\n```\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        pre = [0] * 1001\\n        post = Fenwick(1001)\\n        pre[arr[0]] += 1\\n        vi = 2\\n        while vi < 0 + len(arr):\\n            # post[arr[vi]] += 1\\n            post.addSum(arr[vi], 1)\\n            vi += 1\\n        # pi = 1 \\n        # while pi < 0 + len(post):\\n        #     post[pi] += post[pi-1]\\n        #     pi += 1\\n        i = 1\\n        ans = 0\\n        while i < 0 + len(arr) - 1:\\n            middle = arr[i]\\n            aupper = min(1000, middle + a)\\n            alower = max(0, middle - a)\\n            bupper = min(1000, middle + b)\\n            blower = max(0, middle - b)\\n            traversea = alower\\n            while traversea <= aupper:\\n                if pre[traversea]:\\n                    intersectlower = max(blower, traversea - c)\\n                    intersecupper = min(bupper, traversea + c)\\n                    if intersecupper >= intersectlower:\\n                        if not intersectlower:\\n                            # ans += pre[traversea] * post[intersecupper]\\n                            ans += pre[traversea] * post.getSum(intersecupper)\\n                        else:\\n                            # ans += pre[traversea] * (post[intersecupper] - post[intersectlower - 1])\\n                            ans += pre[traversea] * post.getCum(intersecupper, intersectlower)\\n                traversea += 1\\n            pre[middle] += 1\\n            vaftermiddle = arr[i + 1]\\n            # while vaftermiddle <= 1000:\\n            #     post[vaftermiddle] -= 1\\n            #     vaftermiddle += 1\\n            post.addSum(vaftermiddle, -1)\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845745,
                "title": "python-combinations",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        C = list(combinations(arr,3))\\n        C = [self.checkGood(x,a,b,c) for x in C]\\n        C = [x for x in C if x != None]\\n        # print(C)\\n        return len(C)\\n    \\n    def checkGood(self,tup,a,b,c):\\n        if abs(tup[0] - tup[1]) <= a and abs(tup[0] - tup[2]) <= c and abs(tup[2] - tup[1]) <= b:\\n            return tup\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        C = list(combinations(arr,3))\\n        C = [self.checkGood(x,a,b,c) for x in C]\\n        C = [x for x in C if x != None]\\n        # print(C)\\n        return len(C)\\n    \\n    def checkGood(self,tup,a,b,c):\\n        if abs(tup[0] - tup[1]) <= a and abs(tup[0] - tup[2]) <= c and abs(tup[2] - tup[1]) <= b:\\n            return tup\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769862,
                "title": "python-solution-with-comments",
                "content": "Following is the solution,\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        # here the arr length is not huge\\n        # so we can use the brute force to get the count as per the condition\\n              \\n\\t\\t# given condition\\t  \\n        # 0 <= i < j < k < arr.length\\n        # |arr[i] - arr[j]| <= a\\n        # |arr[j] - arr[k]| <= b\\n        # |arr[i] - arr[k]| <= c\\n\\n        # our count variable to hold the result\\n        count = 0\\n        \\n        # iterate over i, j, k such that  0 <= i < j < k < arr.length\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                for k in range(j + 1, len(arr)):\\n                    # here we are starting with i/j+1  becasue of the i < j < k < condition\\n                    # check the other conditions\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        count += 1\\n        \\n        \\n        # return the count \\n        return count\\n  ```\\n  Please let me know for any improvements in the above code.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        # here the arr length is not huge\\n        # so we can use the brute force to get the count as per the condition\\n              \\n\\t\\t# given condition\\t  \\n        # 0 <= i < j < k < arr.length\\n        # |arr[i] - arr[j]| <= a\\n        # |arr[j] - arr[k]| <= b\\n        # |arr[i] - arr[k]| <= c\\n\\n        # our count variable to hold the result\\n        count = 0\\n        \\n        # iterate over i, j, k such that  0 <= i < j < k < arr.length\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                for k in range(j + 1, len(arr)):\\n                    # here we are starting with i/j+1  becasue of the i < j < k < condition\\n                    # check the other conditions\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        count += 1\\n        \\n        \\n        # return the count \\n        return count\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 775132,
                "title": "both-100-javascript-easy-to-understand-with-explanation",
                "content": "https://youtu.be/QF9zZ3Q-1F8\\n\\n\\n```\\nconst countGoodTriplets = (arr, a, b, c) => {\\n\\tlet count = 0;\\n\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tfor (let k = j + 1; k < arr.length; k++) {\\n\\t\\t\\t\\tconst conditions = [\\n\\t\\t\\t\\t\\tMath.abs(arr[i] - arr[j]) <= a,\\n\\t\\t\\t\\t\\tMath.abs(arr[j] - arr[k]) <= b,\\n\\t\\t\\t\\t\\tMath.abs(arr[i] - arr[k]) <= c,\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t\\tif (conditions.indexOf(false) === -1) count++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst countGoodTriplets = (arr, a, b, c) => {\\n\\tlet count = 0;\\n\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tfor (let k = j + 1; k < arr.length; k++) {\\n\\t\\t\\t\\tconst conditions = [\\n\\t\\t\\t\\t\\tMath.abs(arr[i] - arr[j]) <= a,\\n\\t\\t\\t\\t\\tMath.abs(arr[j] - arr[k]) <= b,\\n\\t\\t\\t\\t\\tMath.abs(arr[i] - arr[k]) <= c,\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t\\tif (conditions.indexOf(false) === -1) count++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767942,
                "title": "python3-1-line",
                "content": "1-line \\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        return sum(abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c for i in range(len(arr)) for j in range(i+1, len(arr)) for k in range(j+1, len(arr)))\\n```\\n\\nor expanded \\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        ans = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):\\n                for k in range(j+1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c: ans += 1\\n        return ans \\n```\\n\\nEdit: I see lots of down votes for this post understandably due to the unreadable 1-liner. I agree that in production code one bearly write double for loops into one line not to mention triple for loops. But I believe LC is more for interview settings which is more free-style in terms of format. A coding interview is usually about algorithm knowledge and language proficiency. Earlier this year, I was asked by an interviewer to write a piece of code that is way more complicated than this into one line for which I have to make heavy usage of `itertools` module for generators. Can you tell your interviewer \"I am not doing it becuase it is against PEP8\"? If your interview asks you not to use functions from standard library, can you tell them \"no, because I can use them in production\"? In fact, if you think about it, interview code can be dramatically different from production code. In production, 1) one doesn\\'t even deal with algorithms as often; 2) a bigger chunk is devoted to sanity check for various edge cases; 3) ingeniously concise code can be frown upon due to maintainability; 4) there is no constraint of using functions from standard library etc etc. \\n\\nIf you can write a beautiful piece of code in an interview that is production ready, great! But don\\'t assume there is no place in an interview for code that is not suitable for production.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        return sum(abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c for i in range(len(arr)) for j in range(i+1, len(arr)) for k in range(j+1, len(arr)))\\n```\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        ans = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):\\n                for k in range(j+1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c: ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811380,
                "title": "c-easy-optimized-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                if((abs(arr[i]-arr[j])<=a))\\n                   {\\n                        for(int k=j+1;k<arr.size();k++)\\n                        {\\n                             if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                            {\\n                                count++;\\n                            }\\n                        }\\n                   }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                if((abs(arr[i]-arr[j])<=a))\\n                   {\\n                        for(int k=j+1;k<arr.size();k++)\\n                        {\\n                             if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                            {\\n                                count++;\\n                            }\\n                        }\\n                   }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734000,
                "title": "java-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c)\\n    {\\n      int i,j,k,count=0;\\n      for(i=0;i<(arr.length)-2;i++)\\n        for(j=i+1;j<(arr.length)-1;j++)\\n          if(Math.abs(arr[i]-arr[j]) <=a)\\n            for(k=j+1;k<arr.length;k++){\\n             if(Math.abs(arr[j]-arr[k]) <=b)\\n               if(Math.abs(arr[i]-arr[k]) <=c)\\n                  count++;\\n          }\\n      return count;\\n    }\\n}\\n```\\n***please upvote if you liked the solution.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c)\\n    {\\n      int i,j,k,count=0;\\n      for(i=0;i<(arr.length)-2;i++)\\n        for(j=i+1;j<(arr.length)-1;j++)\\n          if(Math.abs(arr[i]-arr[j]) <=a)\\n            for(k=j+1;k<arr.length;k++){\\n             if(Math.abs(arr[j]-arr[k]) <=b)\\n               if(Math.abs(arr[i]-arr[k]) <=c)\\n                  count++;\\n          }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375104,
                "title": "pythonn-faster-than-99-84-two-pointers-o-n-2-solution-with-explanation",
                "content": "For every middle element, maintain two pointers, one for the first element in the triplet (say left), one for the third (say right). Keep collecting the elements which follow the constraint in left array, and correspondingly in the right array\\n\\nAfter every iteration, compare each pair of elements in the left and right arrays, and if they satisfy the third constraint, increment the answer counter\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        n = len(arr)\\n        ans = 0\\n        \\n        for i in range(1,n-1):\\n            left = []\\n            right = []\\n            for j in range(0,i):\\n                if(abs(arr[i] - arr[j]) <= a):\\n                    left.append(arr[j])\\n            for j in range(i+1,n):       \\n                if(abs(arr[i] - arr[j]) <= b):\\n                    right.append(arr[j])\\n            \\n            for p in range(0, len(left)):\\n                for q in range(0, len(right)):\\n                    if(abs(left[p] - right[q]) <= c):\\n                        ans+=1\\n                            \\n        return ans",
                "solutionTags": [],
                "code": "For every middle element, maintain two pointers, one for the first element in the triplet (say left), one for the third (say right). Keep collecting the elements which follow the constraint in left array, and correspondingly in the right array\\n\\nAfter every iteration, compare each pair of elements in the left and right arrays, and if they satisfy the third constraint, increment the answer counter\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        n = len(arr)\\n        ans = 0\\n        \\n        for i in range(1,n-1):\\n            left = []\\n            right = []\\n            for j in range(0,i):\\n                if(abs(arr[i] - arr[j]) <= a):\\n                    left.append(arr[j])\\n            for j in range(i+1,n):       \\n                if(abs(arr[i] - arr[j]) <= b):\\n                    right.append(arr[j])\\n            \\n            for p in range(0, len(left)):\\n                for q in range(0, len(right)):\\n                    if(abs(left[p] - right[q]) <= c):\\n                        ans+=1\\n                            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 768347,
                "title": "c-data-size-driven-solution",
                "content": "Hint: Notice that the constraints are small enough for a brute force solution to pass.\\n\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        const int n = arr.size();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++)\\n            for(int j = i+1; j < n - 1 ; j++)\\n                for(int k = j+1; k < n && abs(arr[i] -  arr[j]) <= a; k++)\\n                    if(abs(arr[j] -  arr[k]) <= b && abs(arr[i] -  arr[k]) <= c) ans++;\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        const int n = arr.size();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++)\\n            for(int j = i+1; j < n - 1 ; j++)\\n                for(int k = j+1; k < n && abs(arr[i] -  arr[j]) <= a; k++)\\n                    if(abs(arr[j] -  arr[k]) <= b && abs(arr[i] -  arr[k]) <= c) ans++;\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259289,
                "title": "java-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int x = 0, size = arr.length;\\n        for(int i = 0; i <size - 2; i++){\\n            for(int j = i + 1; j < size - 1; j++){\\n                if(Math.abs(arr[i] - arr[j]) <= a){\\n                for(int k = j + 1; k < size; k++){\\n                if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c)\\n                    x++;\\n                }\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int x = 0, size = arr.length;\\n        for(int i = 0; i <size - 2; i++){\\n            for(int j = i + 1; j < size - 1; j++){\\n                if(Math.abs(arr[i] - arr[j]) <= a){\\n                for(int k = j + 1; k < size; k++){\\n                if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c)\\n                    x++;\\n                }\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161062,
                "title": "java-solution-simple-and-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c){\\n        int count = 0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k = j+1; k<arr.length; k++){\\n                    if(Math.abs(arr[i] - arr[j]) <= a){\\n                        if(Math.abs(arr[j] - arr[k]) <= b){\\n                            if(Math.abs(arr[i] - arr[k]) <= c){\\n                                count++;          \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c){\\n        int count = 0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k = j+1; k<arr.length; k++){\\n                    if(Math.abs(arr[i] - arr[j]) <= a){\\n                        if(Math.abs(arr[j] - arr[k]) <= b){\\n                            if(Math.abs(arr[i] - arr[k]) <= c){\\n                                count++;          \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848542,
                "title": "simple-c-code",
                "content": "# Intuition\\nWe need to compare the difference of three pairs  and i<j<K must hold true so we have to  three loops to iterate which will raise the complexity of code.\\n\\n# Approach\\nist we check the \\n# # condition 1 **if(abs(nums[i]-nums[j])<=a)** \\n\\nif it satisfy the we will intialize the variable just greater than J and iterate i.e k=J+1 in 3rd for loop \\nnow  we will check for next two conditions \\n # CONDITION TWO AND THREE\\n# **if(abs(nums[k]-nums[j])<=b && abs(nums[k]-nums[i])<=c)**\\n\\nif this becomes true we will increment the count variable \\nwhich become our result\\n\\n# Complexity\\n- Time complexity:\\n$O(n^3)$ THREE FOR LOOPs\\n\\n- Space complexity:\\nCONSTANT SPACE $O(1)$\\n\\n**(IF IT\\'S  UNDERSTANDABLE  THEN UPVOTE MY SOLUTION)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& nums, int a, int b, int c) {\\n      int count =0;\\n      int n=nums.size();\\n      for(int i=0; i<n; i++)\\n         {\\n           for(int j=i+1; j<n; j++ ){\\n              if(abs(nums[i]-nums[j])<=a){\\n                for(int k=j+1; k<n; k++){\\n                  if(abs(nums[k]-nums[j])<=b && abs(nums[k]-nums[i])<=c)count++;\\n                }\\n              }\\n           }\\n         }\\n         return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& nums, int a, int b, int c) {\\n      int count =0;\\n      int n=nums.size();\\n      for(int i=0; i<n; i++)\\n         {\\n           for(int j=i+1; j<n; j++ ){\\n              if(abs(nums[i]-nums[j])<=a){\\n                for(int k=j+1; k<n; k++){\\n                  if(abs(nums[k]-nums[j])<=b && abs(nums[k]-nums[i])<=c)count++;\\n                }\\n              }\\n           }\\n         }\\n         return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719102,
                "title": "java-brute-force",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int n = arr.length;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++)\\n                    if (Math.abs(arr[i] - arr[j]) <= a && \\n                        Math.abs(arr[j] - arr[k]) <= b &&\\n                        Math.abs(arr[i] - arr[k]) <= c) {\\n                            count++;\\n                    }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int n = arr.length;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++)\\n                    if (Math.abs(arr[i] - arr[j]) <= a && \\n                        Math.abs(arr[j] - arr[k]) <= b &&\\n                        Math.abs(arr[i] - arr[k]) <= c) {\\n                            count++;\\n                    }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596597,
                "title": "fast-enough-in-python3-79-ms",
                "content": "![image](https://assets.leetcode.com/users/images/ae38960e-d3dc-486d-8b62-e644824a15e4_1663582109.6432118.png)\\n\\nPlease go through the code for a clear explaination.\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        # insert function to insert the value in the list after checking if the value is greater than present elements in the list\\n        def insrt(lst, val):\\n            i = 0\\n            while i < len(lst):\\n                if val <= lst[i]:\\n                    break\\n                i += 1\\n            lst.insert(i, val)\\n        \\n        # res is the var to return the count of good triples\\n        out = 0\\n        \\n        # a new list to store the previous good doubles arr[i] and arr[j]\\n        left = [arr[0]]\\n        \\n        # another list to store the previous good doubles arr[j] and arr[k]\\n        right = sorted(arr[2:])\\n        \\n        # loops through the array for the difference values for a, b, c\\n        for j in range(1, len(arr) - 1):\\n            \\n            # necessary variables to count the number of good doubles for a\\n            #usage of left array\\n            left_start, left_end = 0, len(left) - 1\\n            left_down = arr[j] - a    ####  arr[i] = a + arr[j]\\n            left_up = arr[j] + a      #### -(arr[j]) = a - arr[i]\\n            \\n            # these loops iterate over the array and counts number of values for a\\n            while left_start <= left_end and left[left_start] < left_down:\\n                left_start += 1\\n            while left_start <= left_end and left[left_end] > left_up:\\n                left_end -= 1\\n                \\n            # necessary variables to count the number of good doubles for b\\n            #usage of right array\\n            right_start, right_end = 0, len(right) - 1\\n            right_down = arr[j] - b    ####    arr[j] = b + arr[k]\\n            right_up = arr[j] + b      ####   -(arr[k]) = a - arr[j]\\n            \\n            # these loops iterate over the array and counts number of values for b\\n            while right_start <= right_end and right[right_start] < right_down:\\n                right_start += 1\\n            while right_start <= right_end and right[right_end] > right_up:\\n                right_end -= 1\\n\\n            # conditional statement for obtaining the values of c\\n            if left_start <= left_end and right_start <= right_end:\\n                \\n                # necessary variables to count the number of good doubles for c\\n                k_start, k_end = right_start, right_start\\n                \\n                # another final loop to iterate over both the lists so that we can find the values for c\\n                for i in range(left_start, left_end + 1):\\n                    k_down = left[i] - c   ####    arr[i] = c + arr[k]\\n                    k_up = left[i] + c     ####   -(arr[k]) = c - arr[i]\\n                    \\n                    while k_start <= right_end and right[k_start] < k_down:    \\n                        k_start += 1\\n                    while k_end <= right_end and right[k_end] <= k_up:\\n                        k_end += 1\\n                    \\n                    # counts the number of good triples from the lists and indices we have used so far\\n                    if k_start < k_end:\\n                        out += k_end - k_start  \\n                \\n            # inserts arr[j] at its position in non-decreasing order\\n            insrt(left, arr[j])\\n            \\n            # removes the unnecessary element which cannot be one of the good triple\\n            right.remove(arr[j + 1])\\n\\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        # insert function to insert the value in the list after checking if the value is greater than present elements in the list\\n        def insrt(lst, val):\\n            i = 0\\n            while i < len(lst):\\n                if val <= lst[i]:\\n                    break\\n                i += 1\\n            lst.insert(i, val)\\n        \\n        # res is the var to return the count of good triples\\n        out = 0\\n        \\n        # a new list to store the previous good doubles arr[i] and arr[j]\\n        left = [arr[0]]\\n        \\n        # another list to store the previous good doubles arr[j] and arr[k]\\n        right = sorted(arr[2:])\\n        \\n        # loops through the array for the difference values for a, b, c\\n        for j in range(1, len(arr) - 1):\\n            \\n            # necessary variables to count the number of good doubles for a\\n            #usage of left array\\n            left_start, left_end = 0, len(left) - 1\\n            left_down = arr[j] - a    ####  arr[i] = a + arr[j]\\n            left_up = arr[j] + a      #### -(arr[j]) = a - arr[i]\\n            \\n            # these loops iterate over the array and counts number of values for a\\n            while left_start <= left_end and left[left_start] < left_down:\\n                left_start += 1\\n            while left_start <= left_end and left[left_end] > left_up:\\n                left_end -= 1\\n                \\n            # necessary variables to count the number of good doubles for b\\n            #usage of right array\\n            right_start, right_end = 0, len(right) - 1\\n            right_down = arr[j] - b    ####    arr[j] = b + arr[k]\\n            right_up = arr[j] + b      ####   -(arr[k]) = a - arr[j]\\n            \\n            # these loops iterate over the array and counts number of values for b\\n            while right_start <= right_end and right[right_start] < right_down:\\n                right_start += 1\\n            while right_start <= right_end and right[right_end] > right_up:\\n                right_end -= 1\\n\\n            # conditional statement for obtaining the values of c\\n            if left_start <= left_end and right_start <= right_end:\\n                \\n                # necessary variables to count the number of good doubles for c\\n                k_start, k_end = right_start, right_start\\n                \\n                # another final loop to iterate over both the lists so that we can find the values for c\\n                for i in range(left_start, left_end + 1):\\n                    k_down = left[i] - c   ####    arr[i] = c + arr[k]\\n                    k_up = left[i] + c     ####   -(arr[k]) = c - arr[i]\\n                    \\n                    while k_start <= right_end and right[k_start] < k_down:    \\n                        k_start += 1\\n                    while k_end <= right_end and right[k_end] <= k_up:\\n                        k_end += 1\\n                    \\n                    # counts the number of good triples from the lists and indices we have used so far\\n                    if k_start < k_end:\\n                        out += k_end - k_start  \\n                \\n            # inserts arr[j] at its position in non-decreasing order\\n            insrt(left, arr[j])\\n            \\n            # removes the unnecessary element which cannot be one of the good triple\\n            right.remove(arr[j + 1])\\n\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269910,
                "title": "python-self-explanatory-simple-code",
                "content": "Runtime: 645 ms, faster than 80.95% of Python3 online submissions for Count Good Triplets.\\nMemory Usage: 14 MB, less than 16.30% of Python3 online submissions for Count Good Triplets.\\n\\n```class Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        co = 0\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                for k in range(j + 1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        co += 1\\n        return co",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 645 ms, faster than 80.95% of Python3 online submissions for Count Good Triplets.\\nMemory Usage: 14 MB, less than 16.30% of Python3 online submissions for Count Good Triplets.\\n\\n```class Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        co = 0\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                for k in range(j + 1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        co += 1\\n        return co",
                "codeTag": "Java"
            },
            {
                "id": 1691068,
                "title": "java-solution-beginner-friendly",
                "content": "**Time Complexity : O(n^3)**\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i=0; i<arr.length-2; i++){\\n            for(int j=i+1; j<arr.length-1; j++){\\n                if(Math.abs(arr[i] - arr[j]) <= a){\\n                    for(int k=j+1; k<arr.length; k++){\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }  \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i=0; i<arr.length-2; i++){\\n            for(int j=i+1; j<arr.length-1; j++){\\n                if(Math.abs(arr[i] - arr[j]) <= a){\\n                    for(int k=j+1; k<arr.length; k++){\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }  \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489452,
                "title": "easy-to-understand-c-solution-faster-than-98",
                "content": "**Explanation**\\nWe are using brute force approach as the constraints are small enough to do so. We generate three elements using three for loops and increase the answer counter when all the conditions meet. \\n\\nPlease upvote the solution if you find it helpful and comment down if you have any questions!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int ans=0;\\n        for(int i=0;i<arr.size()-2;i++){\\n            for(int j=i+1;j<arr.size()-1;j++){\\n                if(abs(arr[j]-arr[i])<=a)\\n                    for(int k=j+1;k<arr.size();k++){\\n                        if(abs(arr[k]-arr[j])<=b and abs(arr[k]-arr[i])<=c)\\n                            ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int ans=0;\\n        for(int i=0;i<arr.size()-2;i++){\\n            for(int j=i+1;j<arr.size()-1;j++){\\n                if(abs(arr[j]-arr[i])<=a)\\n                    for(int k=j+1;k<arr.size();k++){\\n                        if(abs(arr[k]-arr[j])<=b and abs(arr[k]-arr[i])<=c)\\n                            ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142665,
                "title": "easy-solution-and-faster-than-92-90-submission",
                "content": "*I have used 3 loops and checking 1st condition after i and j loops,  to avoid the iteration to 3rd loop if 1st condition is not true. \\nThe boolean conditions in for loop doesnt affect complexities much*\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0 ; \\n        for(int i  = 0 ; i < arr.length-2 ; i++)    {\\n            for(int j = i+1 ; j < arr.length-1 ; j++)   {\\n                if(Math.abs(arr[i] - arr[j]) <= a )  {\\n                    for(int k = j+1 ;  k < arr.length ; k++)    {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c)    {\\n                                count +=1 ; \\n                            }\\n                    }\\n                }\\n            }\\n        }\\n        return count ; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0 ; \\n        for(int i  = 0 ; i < arr.length-2 ; i++)    {\\n            for(int j = i+1 ; j < arr.length-1 ; j++)   {\\n                if(Math.abs(arr[i] - arr[j]) <= a )  {\\n                    for(int k = j+1 ;  k < arr.length ; k++)    {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c)    {\\n                                count +=1 ; \\n                            }\\n                    }\\n                }\\n            }\\n        }\\n        return count ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059353,
                "title": "easy-python-99-speed",
                "content": "**Easy Python | 99% Speed**\\n\\nEasy brute force algorithm, with a few early checks to detect impossobile combinations. The code achieved a 99% speed rating in Python.\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, A, a, b, c):\\n        \\n        L = len(A)\\n        n = 0\\n        \\n        for i in range(L-2):\\n            x = A[i]\\n            for j in range(i+1,L-1):\\n                y = A[j]\\n                if abs(x-y) <= a:\\n                    for k in range(j+1,L):\\n                        z = A[k]\\n                        if abs(y-z)<=b and abs(x-z)<=c:\\n                            n += 1\\n\\t\\treturn n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, A, a, b, c):\\n        \\n        L = len(A)\\n        n = 0\\n        \\n        for i in range(L-2):\\n            x = A[i]\\n            for j in range(i+1,L-1):\\n                y = A[j]\\n                if abs(x-y) <= a:\\n                    for k in range(j+1,L):\\n                        z = A[k]\\n                        if abs(y-z)<=b and abs(x-z)<=c:\\n                            n += 1\\n\\t\\treturn n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039913,
                "title": "c-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i,j,k,count=0;\\n        for(i=0;i<arr.size()-2;i++){\\n            for(j=i+1;j<arr.size()-1;j++){\\n                if(abs(arr[i]-arr[j])<=a){  //this if condition skips few computations\\n                for(k=j+1;k<arr.size();k++){\\n                    if( abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                        count++;\\n            }}}}}\\n            \\n        \\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i,j,k,count=0;\\n        for(i=0;i<arr.size()-2;i++){\\n            for(j=i+1;j<arr.size()-1;j++){\\n                if(abs(arr[i]-arr[j])<=a){  //this if condition skips few computations\\n                for(k=j+1;k<arr.size();k++){\\n                    if( abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                        count++;\\n            }}}}}\\n            \\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907050,
                "title": "python-brute-force-technique",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, ar: List[int], a: int, b: int, c: int) -> int:\\n        count = 0\\n        for i in range(len(ar)):\\n            for j in range(i+1, len(ar)):\\n                for k in range(j+1, len(ar)):\\n                    if abs(ar[i]-ar[j])<=a and abs(ar[j]-ar[k])<=b and abs(ar[i]-ar[k])<=c:\\n                        count += 1\\n        return count\\n```\\nFor more such questions: https://github.com/vanigupta20024",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, ar: List[int], a: int, b: int, c: int) -> int:\\n        count = 0\\n        for i in range(len(ar)):\\n            for j in range(i+1, len(ar)):\\n                for k in range(j+1, len(ar)):\\n                    if abs(ar[i]-ar[j])<=a and abs(ar[j]-ar[k])<=b and abs(ar[i]-ar[k])<=c:\\n                        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840465,
                "title": "python-3-360-ms-solution-96",
                "content": "# Python 3 Solution\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        size = len(arr)\\n        result = 0\\n        for i in range(0, size - 2):\\n            for j in range(i + 1, size - 1):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j + 1, size):\\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                            result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        size = len(arr)\\n        result = 0\\n        for i in range(0, size - 2):\\n            for j in range(i + 1, size - 1):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j + 1, size):\\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                            result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768042,
                "title": "c-o-n-3",
                "content": "Runtime: 188 ms\\nMemory Usage: 24.3 MB\\n\\n```\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) {\\n       int result = 0;\\n        \\n       for(int i=0; i< arr.Length-2; i++)\\n       {\\n           for(int j=i+1; j < arr.Length-1; j++)\\n           {\\n               if (Math.Abs(arr[i] - arr[j]) > a ) { continue; }\\n               \\n               for(int k=j+1; k < arr.Length; k++)\\n               {\\n                   if (Math.Abs(arr[j]- arr[k]) <= b && Math.Abs(arr[i]- arr[k]) <= c) { result++; }\\n               }\\n           }\\n       }\\n        \\n       return result;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 188 ms\\nMemory Usage: 24.3 MB\\n\\n```\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) {\\n       int result = 0;\\n        \\n       for(int i=0; i< arr.Length-2; i++)\\n       {\\n           for(int j=i+1; j < arr.Length-1; j++)\\n           {\\n               if (Math.Abs(arr[i] - arr[j]) > a ) { continue; }\\n               \\n               for(int k=j+1; k < arr.Length; k++)\\n               {\\n                   if (Math.Abs(arr[j]- arr[k]) <= b && Math.Abs(arr[i]- arr[k]) <= c) { result++; }\\n               }\\n           }\\n       }\\n        \\n       return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3634936,
                "title": "segment-tree-approach",
                "content": "Reference [@SleepyFarmer\\n](https://leetcode.com/problems/count-good-triplets/solutions/769821/java-o-n-well-it-is-really-o-1000-n/)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n    void queryUpdate(int node, int node_low, int node_high, int l,int h){\\n        if(node_high < l || node_low > h || node_low > node_high){\\n            return ;\\n        }\\n        if(node_low >= l && node_high <= h){\\n            tree[node] -= 1;\\n            return;\\n        }\\n        int mid = (node_low + node_high) >> 1;\\n        queryUpdate(2*node,node_low,mid,l,h);\\n        queryUpdate(2*node  + 1,mid + 1, node_high,l,h);\\n        tree[node] = tree[2*node] + tree[2*node + 1];\\n    }\\n    int querySum(int node, int node_low, int node_high,int l, int h){\\n        if(node_high < l || node_low > h || node_low > node_high){\\n            return 0;\\n        }\\n        if(node_low >= l && node_high <= h){\\n            return tree[node];\\n        }\\n        int mid = (node_low + node_high) >> 1;\\n        return querySum(2*node,node_low,mid,l,h) +\\n        querySum(2*node  + 1,mid + 1, node_high,l,h);\\n    }\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n = arr.size();\\n        const int N = 1024;\\n        vector<int> pre(N);\\n        vector<int> post(N);\\n        tree.assign(2*N,0);\\n        pre[arr[0]]++;\\n        for(int i = 2; i < n; i++) post[arr[i]]++;\\n        for(int i = 0; i < N; i++){\\n            tree[N + i] = post[i]; \\n        }\\n        for(int i = N-1; i >= 1; i--){\\n            tree[i] = tree[2*i] + tree[2*i+ 1];\\n        }\\n        int ans = 0;\\n        for(int middle = 1; middle < n-1; middle++){\\n            int v = arr[middle];\\n            int p1 = max(0,v-a);\\n            int p2 = min(1000,v + a);\\n            int t1 = max(0,v - b);\\n            int t2 = min(1000,v + b);\\n            for(int s = p1; s <= p2; s++){\\n                if(pre[s] == 0) continue;\\n                int m1 = max(t1,s-c);\\n                int m2 = min(t2,s + c);\\n                if(m2 >= m1){\\n                    int val = querySum(1,0,N-1,m1,m2);\\n                    // cout <<val << endl;\\n                    ans += pre[s]*(val);\\n                }\\n            }\\n            pre[v]++;\\n            queryUpdate(1,0,N-1,arr[middle + 1],arr[middle + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n    void queryUpdate(int node, int node_low, int node_high, int l,int h){\\n        if(node_high < l || node_low > h || node_low > node_high){\\n            return ;\\n        }\\n        if(node_low >= l && node_high <= h){\\n            tree[node] -= 1;\\n            return;\\n        }\\n        int mid = (node_low + node_high) >> 1;\\n        queryUpdate(2*node,node_low,mid,l,h);\\n        queryUpdate(2*node  + 1,mid + 1, node_high,l,h);\\n        tree[node] = tree[2*node] + tree[2*node + 1];\\n    }\\n    int querySum(int node, int node_low, int node_high,int l, int h){\\n        if(node_high < l || node_low > h || node_low > node_high){\\n            return 0;\\n        }\\n        if(node_low >= l && node_high <= h){\\n            return tree[node];\\n        }\\n        int mid = (node_low + node_high) >> 1;\\n        return querySum(2*node,node_low,mid,l,h) +\\n        querySum(2*node  + 1,mid + 1, node_high,l,h);\\n    }\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n = arr.size();\\n        const int N = 1024;\\n        vector<int> pre(N);\\n        vector<int> post(N);\\n        tree.assign(2*N,0);\\n        pre[arr[0]]++;\\n        for(int i = 2; i < n; i++) post[arr[i]]++;\\n        for(int i = 0; i < N; i++){\\n            tree[N + i] = post[i]; \\n        }\\n        for(int i = N-1; i >= 1; i--){\\n            tree[i] = tree[2*i] + tree[2*i+ 1];\\n        }\\n        int ans = 0;\\n        for(int middle = 1; middle < n-1; middle++){\\n            int v = arr[middle];\\n            int p1 = max(0,v-a);\\n            int p2 = min(1000,v + a);\\n            int t1 = max(0,v - b);\\n            int t2 = min(1000,v + b);\\n            for(int s = p1; s <= p2; s++){\\n                if(pre[s] == 0) continue;\\n                int m1 = max(t1,s-c);\\n                int m2 = min(t2,s + c);\\n                if(m2 >= m1){\\n                    int val = querySum(1,0,N-1,m1,m2);\\n                    // cout <<val << endl;\\n                    ans += pre[s]*(val);\\n                }\\n            }\\n            pre[v]++;\\n            queryUpdate(1,0,N-1,arr[middle + 1],arr[middle + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3404057,
                "title": "easy-way-to-solve-it-in-c",
                "content": "PLEASE UPVOTE \\uD83D\\uDC4D\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute Force method to solve it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            for(int j =i+1;j<arr.size();j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    if( abs(arr[i]-arr[j]) <= a && abs(arr[j]-arr[k]) <= b && abs(arr[i]-arr[k]) <= c ) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            for(int j =i+1;j<arr.size();j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    if( abs(arr[i]-arr[j]) <= a && abs(arr[j]-arr[k]) <= b && abs(arr[i]-arr[k]) <= c ) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358369,
                "title": "obvious-brute-force-that-gets-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodTriplets(self, A: List[int], a: int, b: int, c: int) -> int:\\n        n = len(A)\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    if abs(A[i]-A[j]) <= a and abs(A[k]-A[j]) <= b and abs(A[i]-A[k]) <= c:\\n                        cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, A: List[int], a: int, b: int, c: int) -> int:\\n        n = len(A)\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    if abs(A[i]-A[j]) <= a and abs(A[k]-A[j]) <= b and abs(A[i]-A[k]) <= c:\\n                        cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224706,
                "title": "easy-to-understand-and-readable-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length - 2; i++){\\n            for(int j = i+1; j < arr.length - 1; j++){\\n                if(Math.abs(arr[i] - arr[j]) <= a){\\n                    for(int k = j+1; k < arr.length; k++){\\n                        if((Math.abs(arr[j]-arr[k]) <= b) && (Math.abs(arr[i]-arr[k]) <= c)){\\n                            count++;\\n                        }  \\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length - 2; i++){\\n            for(int j = i+1; j < arr.length - 1; j++){\\n                if(Math.abs(arr[i] - arr[j]) <= a){\\n                    for(int k = j+1; k < arr.length; k++){\\n                        if((Math.abs(arr[j]-arr[k]) <= b) && (Math.abs(arr[i]-arr[k]) <= c)){\\n                            count++;\\n                        }  \\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152443,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n\\n        int count = 0;\\n    int n=arr.size();\\n    for (int i = 0; i < n - 2; i++)\\n    {\\n        for (int j = i + 1; j < n - 1; j++)\\n        {\\n            for (int k = j + 1; k < n; k++)\\n            {\\n                int diff1 = arr[i] - arr[j];\\n                int diff2 = arr[j] - arr[k];\\n                int diff3 = arr[i] - arr[k];\\n                if (diff1 < 0)\\n                {\\n                    diff1 = diff1 * (-1);\\n                }\\n                if (diff2 < 0)\\n                {\\n                    diff2 = diff2 * (-1);\\n                }\\n                if (diff3 < 0)\\n                {\\n                    diff3 = diff3 * (-1);\\n                }\\n\\n                if (diff1 <= a && diff2 <= b && diff3 <= c)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n\\n        int count = 0;\\n    int n=arr.size();\\n    for (int i = 0; i < n - 2; i++)\\n    {\\n        for (int j = i + 1; j < n - 1; j++)\\n        {\\n            for (int k = j + 1; k < n; k++)\\n            {\\n                int diff1 = arr[i] - arr[j];\\n                int diff2 = arr[j] - arr[k];\\n                int diff3 = arr[i] - arr[k];\\n                if (diff1 < 0)\\n                {\\n                    diff1 = diff1 * (-1);\\n                }\\n                if (diff2 < 0)\\n                {\\n                    diff2 = diff2 * (-1);\\n                }\\n                if (diff3 < 0)\\n                {\\n                    diff3 = diff3 * (-1);\\n                }\\n\\n                if (diff1 <= a && diff2 <= b && diff3 <= c)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029735,
                "title": "java-good-triplets-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(n3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n\\n         int count = 0;\\n         int n = arr.length;\\n         for(int i = 0; i < n - 2; i++){\\n            for(int j = i + 1; j < n - 1; j++){\\n                for(int k = j + 1; k < n; k++){\\n                     if(\\n                         (Math.abs(arr[i] - arr[j]) <= a) && \\n                         (Math.abs(arr[j] - arr[k]) <= b) && \\n                         (Math.abs(arr[i] - arr[k]) <= c)\\n                     ){\\n                         count++;\\n                     }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n\\n         int count = 0;\\n         int n = arr.length;\\n         for(int i = 0; i < n - 2; i++){\\n            for(int j = i + 1; j < n - 1; j++){\\n                for(int k = j + 1; k < n; k++){\\n                     if(\\n                         (Math.abs(arr[i] - arr[j]) <= a) && \\n                         (Math.abs(arr[j] - arr[k]) <= b) && \\n                         (Math.abs(arr[i] - arr[k]) <= c)\\n                     ){\\n                         count++;\\n                     }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929470,
                "title": "python-o-n-3-clean-code",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        result = 0\\n\\n        for i in range(len(arr) - 2):\\n            for j in range(i + 1, len(arr) - 1):\\n                if abs(arr[i] - arr[j]) > a:\\n                    continue\\n                for k in range(j + 1, len(arr)):\\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        result += 1\\n        \\n        return result\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        result = 0\\n\\n        for i in range(len(arr) - 2):\\n            for j in range(i + 1, len(arr) - 1):\\n                if abs(arr[i] - arr[j]) > a:\\n                    continue\\n                for k in range(j + 1, len(arr)):\\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        result += 1\\n        \\n        return result\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715011,
                "title": "1-loop-java-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int i=0,j=i+1,k=j+1;\\n        int count=0;\\n        while(k<arr.length){\\n            if(Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                count++;\\n            }\\n            if(k<arr.length-1) k++;\\n            else if(k==arr.length-1 && j<arr.length-2){\\n                j++;k=j+1;\\n            } else if(j==arr.length-2){\\n                i++;j=i+1;k=j+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int i=0,j=i+1,k=j+1;\\n        int count=0;\\n        while(k<arr.length){\\n            if(Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                count++;\\n            }\\n            if(k<arr.length-1) k++;\\n            else if(k==arr.length-1 && j<arr.length-2){\\n                j++;k=j+1;\\n            } else if(j==arr.length-2){\\n                i++;j=i+1;k=j+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704597,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (int k = j + 1; k < arr.size(); k++)\\n                    {\\n                        int B = abs(arr[j] - arr[k]);\\n                        int C = abs(arr[k] - arr[i]);\\n                        if (B <= b and C <= c)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (int k = j + 1; k < arr.size(); k++)\\n                    {\\n                        int B = abs(arr[j] - arr[k]);\\n                        int C = abs(arr[k] - arr[i]);\\n                        if (B <= b and C <= c)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704179,
                "title": "python-simple-solution-faster-than-97-41",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if abs(arr[i]-arr[j])<=a:\\n                    for k in range(j+1,n):\\n                        if abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c:\\n                                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if abs(arr[i]-arr[j])<=a:\\n                    for k in range(j+1,n):\\n                        if abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c:\\n                                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045609,
                "title": "java-easiest-solution-in-basic-terms",
                "content": "import java.lang.Math;\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c)\\n                        count++;\\n                }\\n                    \\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c)\\n                        count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1583865,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        boolean firstcond = false;\\n        boolean secondcond = false;\\n        boolean thirdcond = false;\\n        for(int i = 0; i < arr.length - 2; i++){\\n            for(int j = i + 1; j < arr.length - 1; j++){\\n               for(int k = j + 1; k < arr.length; k++){\\n                   firstcond = Math.abs(arr[i] - arr[j]) <= a;\\n                   secondcond = Math.abs(arr[j] - arr[k]) <= b;\\n                   thirdcond = Math.abs(arr[i] - arr[k]) <= c;\\n                   if(firstcond && secondcond && thirdcond){\\n                       count += 1;\\n                   }\\n               }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        boolean firstcond = false;\\n        boolean secondcond = false;\\n        boolean thirdcond = false;\\n        for(int i = 0; i < arr.length - 2; i++){\\n            for(int j = i + 1; j < arr.length - 1; j++){\\n               for(int k = j + 1; k < arr.length; k++){\\n                   firstcond = Math.abs(arr[i] - arr[j]) <= a;\\n                   secondcond = Math.abs(arr[j] - arr[k]) <= b;\\n                   thirdcond = Math.abs(arr[i] - arr[k]) <= c;\\n                   if(firstcond && secondcond && thirdcond){\\n                       count += 1;\\n                   }\\n               }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547417,
                "title": "javascript-100",
                "content": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n  let triplets = 0;\\n  for(let i = 0; i < arr.length - 2; i++) {\\n    for(let j = i+1; j < arr.length - 1; j++) {\\n      if(Math.abs(arr[i] - arr[j]) <= a) {\\n        for(let k = j+1; k < arr.length; k++) {\\n          if((Math.abs(arr[j] - arr[k]) <= b) && (Math.abs(arr[i] - arr[k]) <= c)) {\\n            triplets++;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return triplets;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n  let triplets = 0;\\n  for(let i = 0; i < arr.length - 2; i++) {\\n    for(let j = i+1; j < arr.length - 1; j++) {\\n      if(Math.abs(arr[i] - arr[j]) <= a) {\\n        for(let k = j+1; k < arr.length; k++) {\\n          if((Math.abs(arr[j] - arr[k]) <= b) && (Math.abs(arr[i] - arr[k]) <= c)) {\\n            triplets++;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return triplets;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1449450,
                "title": "c-straightforward-solution-with-tiny-optimization",
                "content": "```cpp\\nclass Solution\\n{\\npublic:\\n  int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n  {\\n    int n = arr.size(), ans = 0;\\n    for (int i = 0; i < n - 2; ++i)\\n    {\\n      for (int j = i + 1; j < n - 1; ++j)\\n      {\\n        if (std::abs(arr[i] - arr[j]) <= a) // early stoppage -> optimization\\n        {\\n          for (int k = j + 1; k < n; ++k)\\n          {\\n            if (std::abs(arr[j] - arr[k]) <= b && std::abs(arr[i] - arr[k]) <= c)\\n            {\\n              ++ans;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n  int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n  {\\n    int n = arr.size(), ans = 0;\\n    for (int i = 0; i < n - 2; ++i)\\n    {\\n      for (int j = i + 1; j < n - 1; ++j)\\n      {\\n        if (std::abs(arr[i] - arr[j]) <= a) // early stoppage -> optimization\\n        {\\n          for (int k = j + 1; k < n; ++k)\\n          {\\n            if (std::abs(arr[j] - arr[k]) <= b && std::abs(arr[i] - arr[k]) <= c)\\n            {\\n              ++ans;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386883,
                "title": "java-beats-99-39",
                "content": "```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i=0; i<arr.length-2; i++) {\\n            for(int j=i+1; j<arr.length-1; j++) {\\n                if(Math.abs(arr[i]-arr[j]) <= a)\\n                    for(int k=j+1; k<arr.length; k++)\\n                        if(Math.abs(arr[j]-arr[k]) <= b && Math.abs(arr[i]-arr[k]) <= c)\\n                            count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i=0; i<arr.length-2; i++) {\\n            for(int j=i+1; j<arr.length-1; j++) {\\n                if(Math.abs(arr[i]-arr[j]) <= a)\\n                    for(int k=j+1; k<arr.length; k++)\\n                        if(Math.abs(arr[j]-arr[k]) <= b && Math.abs(arr[i]-arr[k]) <= c)\\n                            count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259004,
                "title": "c-simple-easy-to-understand-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n        int ans=0;\\n        \\n        int n=arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if((abs(arr[i]-arr[j])<=a)&&(abs(arr[j]-arr[k])<=b)&&(abs(arr[i]-arr[k])<=c))\\n                    {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n        int ans=0;\\n        \\n        int n=arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if((abs(arr[i]-arr[j])<=a)&&(abs(arr[j]-arr[k])<=b)&&(abs(arr[i]-arr[k])<=c))\\n                    {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246822,
                "title": "rust-2-brute-force-solutions",
                "content": "Simple solution with 3 cycles. Runtime = **4 ms**\\n```\\nimpl Solution {\\n    pub fn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n        let mut counter = 0;\\n\\n        for i in 0..arr.len() - 2 {\\n            for j in i + 1..arr.len() - 1 {\\n                if (arr[i] - arr[j]).abs() <= a {\\n                    for k in j + 1..arr.len() {\\n                        if (arr[j] - arr[k]).abs() <= b && (arr[i] - arr[k]).abs() <= c {\\n                            counter += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        counter\\n    }\\n}\\n```\\n\\nIt\\'s strange, but long functional solution is faster. Runtime = **0 ms**\\n```\\nimpl Solution {\\n    pub fn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n        let mut counter = 0;\\n        let l = arr.len();\\n\\n        arr[..l - 2].iter().enumerate().for_each(|(i, &ai)| {\\n            arr[..l - 1]\\n                .iter()\\n                .enumerate()\\n                .skip(i + 1)\\n                .filter(|(_, aj)| (ai - **aj).abs() <= a)\\n                .for_each(|(j, &aj)| {\\n                    arr[j + 1..l]\\n                        .iter()\\n                        .filter(|&&ak| (aj - ak).abs() <= b && (ai - ak).abs() <= c)\\n                        .for_each(|_| {\\n                            counter += 1;\\n                        })\\n                })\\n        });\\n        counter\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n        let mut counter = 0;\\n\\n        for i in 0..arr.len() - 2 {\\n            for j in i + 1..arr.len() - 1 {\\n                if (arr[i] - arr[j]).abs() <= a {\\n                    for k in j + 1..arr.len() {\\n                        if (arr[j] - arr[k]).abs() <= b && (arr[i] - arr[k]).abs() <= c {\\n                            counter += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        counter\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n        let mut counter = 0;\\n        let l = arr.len();\\n\\n        arr[..l - 2].iter().enumerate().for_each(|(i, &ai)| {\\n            arr[..l - 1]\\n                .iter()\\n                .enumerate()\\n                .skip(i + 1)\\n                .filter(|(_, aj)| (ai - **aj).abs() <= a)\\n                .for_each(|(j, &aj)| {\\n                    arr[j + 1..l]\\n                        .iter()\\n                        .filter(|&&ak| (aj - ak).abs() <= b && (ai - ak).abs() <= c)\\n                        .for_each(|_| {\\n                            counter += 1;\\n                        })\\n                })\\n        });\\n        counter\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245217,
                "title": "python-easy-solution-explained-faster-than-97-36-less-memory-then-71-85",
                "content": "These 2 principles help better the time complexity:\\n1) Modifying the start and the end of the range in order to get all of the triplets that fullfil the 1st criteria of a valid triplet. (i < j < k)\\n2) Once we have a couple or a triplet, we check if the other 3 criterias hold.\\n\\n* If you find this helpful, I would appriciate a positive rating. Thank you.\\n\\n```\\nclass Solution(object):\\n    def countGoodTriplets(self, arr, a, b, c):\\n        res = 0\\n        for i in range(0, len(arr) - 2):\\n            for j in range(i + 1, len(arr) - 1):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j + 1, len(arr)):\\n                        if abs(arr[k] - arr[i]) <= c and abs(arr[k] - arr[j]) <= b:\\n                            res += 1\\n                        \\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countGoodTriplets(self, arr, a, b, c):\\n        res = 0\\n        for i in range(0, len(arr) - 2):\\n            for j in range(i + 1, len(arr) - 1):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j + 1, len(arr)):\\n                        if abs(arr[k] - arr[i]) <= c and abs(arr[k] - arr[j]) <= b:\\n                            res += 1\\n                        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223173,
                "title": "840ms-python-with-comments-and-detailed-walkthrough",
                "content": "If you find this post helpful, please **Upvote** :)\\n```\\nclass Solution(object):\\n    def countGoodTriplets(self, arr, a, b, c):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type a: int\\n        :type b: int\\n        :type c: int\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#initialise a variable to store the output\\n        result = 0\\n\\t\\t#loop through each each index untill except the last 2 as we are looking for set of 3 numbers\\n        for i in range(len(arr)-2):\\n\\t\\t#loop from 2nd element to the 2nd last element\\n            for j in range(1,len(arr)-1):\\n\\t\\t\\t#This condition is reduce excessive computation as we dont want to deal with j<=i\\n                if j<=i:\\n                    continue\\n\\t\\t\\t\\t\\t#loop from 3rd element to end of the list\\n                for k in range(2,len(arr)):\\n\\t\\t\\t\\t#This condition is to remove excess computation as we dont want to deal with k<=j\\n                    if k<=j:\\n                        continue\\n\\t\\t\\t\\t\\t\\t#Checking whether the condition given in the question is being satisfied\\n                    if ((abs(arr[i] - arr[j]) <= a) and (abs(arr[j] - arr[k]) <= b) and abs(arr[i] - arr[k]) <= c):\\n\\t\\t\\t\\t\\t#increment the output variable whenever we find a suitable pair (i,j,k) that satisfies all the conditions\\n                        result+=1\\n        return result\\n```\\n\\nI will try to explain a bit elaborately:\\nLet us assume we have a list of 5 element [ -, -, -, -, -]\\nNow based on the 0<=i<j<k<len(arr)\\nthe indices we are interested in are :\\n(0,1,2), (0,2,3), (0,3,4)\\n(0,1,3), (0,2,4)\\n(0,1,4)\\n(1,2,3), (1,3,4)\\n(1,2,4)\\n\\nThe below code does exactly this\\n```\\n\\t for i in range(len(arr)-2):\\n            for j in range(1,len(arr)-1):\\n                if j<=i:\\n                    continue\\n                for k in range(2,len(arr)):\\n                    if k<=j:\\n                        continue\\n```\\nNow we need to check whether the other conditions are satisifed or not!\\n![image](https://assets.leetcode.com/users/images/dfb4d7f4-5cf5-4179-8a5b-11c9abfb4da4_1621675245.6721513.png)\\nPlease comment if you have any doubts or suggestions :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def countGoodTriplets(self, arr, a, b, c):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type a: int\\n        :type b: int\\n        :type c: int\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#initialise a variable to store the output\\n        result = 0\\n\\t\\t#loop through each each index untill except the last 2 as we are looking for set of 3 numbers\\n        for i in range(len(arr)-2):\\n\\t\\t#loop from 2nd element to the 2nd last element\\n            for j in range(1,len(arr)-1):\\n\\t\\t\\t#This condition is reduce excessive computation as we dont want to deal with j<=i\\n                if j<=i:\\n                    continue\\n\\t\\t\\t\\t\\t#loop from 3rd element to end of the list\\n                for k in range(2,len(arr)):\\n\\t\\t\\t\\t#This condition is to remove excess computation as we dont want to deal with k<=j\\n                    if k<=j:\\n                        continue\\n\\t\\t\\t\\t\\t\\t#Checking whether the condition given in the question is being satisfied\\n                    if ((abs(arr[i] - arr[j]) <= a) and (abs(arr[j] - arr[k]) <= b) and abs(arr[i] - arr[k]) <= c):\\n\\t\\t\\t\\t\\t#increment the output variable whenever we find a suitable pair (i,j,k) that satisfies all the conditions\\n                        result+=1\\n        return result\\n```\n```\\n\\t for i in range(len(arr)-2):\\n            for j in range(1,len(arr)-1):\\n                if j<=i:\\n                    continue\\n                for k in range(2,len(arr)):\\n                    if k<=j:\\n                        continue\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221046,
                "title": "java-solution",
                "content": "```\\n    class Solution\\n    {\\n        public int countGoodTriplets(int[] arr, int a, int b, int c)\\n        {\\n            int goodTriplets = 0;\\n            for (int i = 0; i < arr.length - 2; i++)\\n            {\\n                for (int j = i + 1; j < arr.length - 1; j++)\\n                {\\n                    for (int k = j + 1; k < arr.length; k++)\\n                    {\\n                        if (Math.abs(arr[i] - arr[j]) <= a &&\\n                            Math.abs(arr[j] - arr[k]) <= b &&\\n                            Math.abs(arr[i] - arr[k]) <= c)\\n                            goodTriplets++;\\n                    }\\n                }\\n            }\\n            return goodTriplets;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution\\n    {\\n        public int countGoodTriplets(int[] arr, int a, int b, int c)\\n        {\\n            int goodTriplets = 0;\\n            for (int i = 0; i < arr.length - 2; i++)\\n            {\\n                for (int j = i + 1; j < arr.length - 1; j++)\\n                {\\n                    for (int k = j + 1; k < arr.length; k++)\\n                    {\\n                        if (Math.abs(arr[i] - arr[j]) <= a &&\\n                            Math.abs(arr[j] - arr[k]) <= b &&\\n                            Math.abs(arr[i] - arr[k]) <= c)\\n                            goodTriplets++;\\n                    }\\n                }\\n            }\\n            return goodTriplets;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219361,
                "title": "9ms-in-java-faster-than-99-25-solution-java",
                "content": "```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int result=0;\\n        int len=arr.length;\\n        for(int i=0;i<len;i++){\\n            for(int j=i+1;j<len;j++){\\n                if(Math.abs(arr[i]-arr[j])>a)\\n                    continue;\\n                for(int k=j+1;k<len;k++){\\n                    if(Math.abs(arr[j]-arr[k])>b)\\n                        continue;\\n                    if(Math.abs(arr[i]-arr[k])>c)\\n                        continue;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int result=0;\\n        int len=arr.length;\\n        for(int i=0;i<len;i++){\\n            for(int j=i+1;j<len;j++){\\n                if(Math.abs(arr[i]-arr[j])>a)\\n                    continue;\\n                for(int k=j+1;k<len;k++){\\n                    if(Math.abs(arr[j]-arr[k])>b)\\n                        continue;\\n                    if(Math.abs(arr[i]-arr[k])>c)\\n                        continue;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1169944,
                "title": "c-easy-solution",
                "content": "***Do upvote if you found it helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n***Feel free to give suggestions***\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n      int i , j , k , count = 0;\\n        int n = arr.size();\\n        for(i=0 ; i<n-2 ; i++)\\n        {\\n            for(j=i+1 ; j<n-1 ; j++)\\n            {\\n                for(k=j+1 ; k<n ; k++)\\n                {\\n                    if(abs(arr[i]-arr[j]) <= a && abs(arr[j]-arr[k]) <= b && abs(arr[i]-arr[k]) <= c)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n      int i , j , k , count = 0;\\n        int n = arr.size();\\n        for(i=0 ; i<n-2 ; i++)\\n        {\\n            for(j=i+1 ; j<n-1 ; j++)\\n            {\\n                for(k=j+1 ; k<n ; k++)\\n                {\\n                    if(abs(arr[i]-arr[j]) <= a && abs(arr[j]-arr[k]) <= b && abs(arr[i]-arr[k]) <= c)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146383,
                "title": "simple-python-solution-faster-than-88-82",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        n=len(arr)\\n        count=0\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                 if abs(arr[i] - arr[j])<= a:\\n                    for k in range(j+1,n):\\n                        if abs(arr[j] - arr[k])<= b and abs(arr[i] - arr[k])<= c:\\n                            count+=1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        n=len(arr)\\n        count=0\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                 if abs(arr[i] - arr[j])<= a:\\n                    for k in range(j+1,n):\\n                        if abs(arr[j] - arr[k])<= b and abs(arr[i] - arr[k])<= c:\\n                            count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133609,
                "title": "c-solution-99-2",
                "content": "Update: to explain the main idea.\\n\\n1. we need to count the number of triples {i,j,k}. Such triples satisfiy that:\\n\\t0 <= i < j < k < arr.length\\n\\t|arr[i] - arr[j]| <= a\\n\\t|arr[j] - arr[k]| <= b\\n\\t|arr[i] - arr[k]| <= c\\n\\n2. Let\\'s draw an axis and put arr[i], arr[j] and arr[k] on the axis. We can draw circles where radius would be a, b and c. You can easily see that, too big c and too big a are meaningless. The following codes are to modify c and a without loss of any qualified triple.\\n\\n```\\n        if(a<=c) {\\n\\t\\t\\tc = min (c, a+b);\\n\\t\\t} else {\\n\\t\\t\\ta= min (a, b+c);\\n\\t\\t}\\n```\\n\\n3. Since i < j < k, we scan i from 0 to N-3.\\nFirst, we filter possible k\\'s from i+2 to N-1.\\nNext, as long as we have i and k, we check j\\'s from i+1 to N-2.\\nHere, |arr[i] - arr[j]| <= a  is evaluated. Be careful that j<k.\\nOnce {i, j} is ok, we compute |arr[j] - arr[k]| <= b for the k\\'s filtered just as aforementioned.\\n\\nDone.\\n\\nPS: To be honest, I am personally not quite familiar with the submission system here. Sometimes the code runs faster and sometimes slower, with difference of about 4~8ms or 10%. I guess it could comes from the various delay. WHO KNOWS!\\n\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n\\t\\t\\tconst int N = arr.size();\\n\\t\\t\\tint i, j, k, h, l;\\n\\t\\t\\tint cnt;\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\tif(a<=c) {\\n\\t\\t\\t\\tc = min (c, a+b);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta= min (a, b+c);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(i= 0; i != N-2; ++i) {\\n\\t\\t\\t\\tcnt = 0;\\n\\t\\t\\t\\tfor(k = i+2; k!=N; ++k) {\\n\\t\\t\\t\\t\\tif(abs(arr[i]-arr[k])<=c) {\\n\\t\\t\\t\\t\\t\\tks[cnt++] = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(j = i+1, h = 0; j!=N-1 && h!=cnt; ++j) {\\n\\t\\t\\t\\t\\tif(j == ks[h]) {\\n\\t\\t\\t\\t\\t\\t++h;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(abs(arr[i]-arr[j])<=a) {\\n\\t\\t\\t\\t\\t\\tfor(l=h; l!=cnt; ++l) {\\n\\t\\t\\t\\t\\t\\t\\tk = ks[l];\\n\\t\\t\\t\\t\\t\\t\\tsum += abs(arr[j]-arr[k])<=b;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\tprivate:\\n\\t\\tint ks[100];\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "```\\n        if(a<=c) {\\n\\t\\t\\tc = min (c, a+b);\\n\\t\\t} else {\\n\\t\\t\\ta= min (a, b+c);\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094810,
                "title": "two-c-solutions-visitor-pattern-and-basic-loop-includes-some-extras-for-learning-etc",
                "content": "```C++\\nclass Solution {\\npublic:\\n    \\n    ////////////////////////////////////\\n    // Some extra (unnecessary) stuff //\\n    ////////////////////////////////////\\n    \\n    using elem_t = int;\\n    using list_t = vector<elem_t>;\\n    //The _t stands for typedef (\"using\" here is essentially a better version of typedef). \\n    //typedef and using declarations create type synonyms, never new types. That\\'s important.\\n    //I felt like abstracting the vector and element types this time,\\n    //just for practice and entertainment. It\\'s big overkill here.\\n    //\\n    //typedefs and using declarations allow us to abstract over types\\n    //in much the same way that we abstract over numbers and objects with variables. \\n    //It\\'s a nice trick. Templates are another related option. Pros and cons, as always.\\n    \\n    static_assert(is_same_v<list_t::size_type, size_t>);\\n    //Technically, the size type of vector may not be size_t, although it usually is.\\n    //It\\'s certainly not int though, despite the fact that int is so common in people\\'s loops\\n    //and can cause undefined behavior if the int ever overflows since int is signed.\\n    \\n    static_assert(is_unsigned_v<size_t>);\\n    //size_t is unsigned, so one should be careful not to decrement below 0 unintentionally.\\n    //This statement just alerts readers of the code to that and checks that it is true too.\\n    \\n    ///////////////////////////////////\\n    // Solution #1 (visitor pattern) //\\n    ///////////////////////////////////\\n    \\n    using triplet_action = function<void(elem_t, elem_t, elem_t)>;\\n    \\n    inline static void visit_triplets(\\n        const list_t    arr, \\n        triplet_action  action_per_triplet\\n    ) {\\n        const size_t arr_size = arr.size(); //Only improves performance if optimizer is off.\\n        for (size_t i = 0; i < arr_size; ++i) {\\n            for (size_t j = i + 1; j < arr_size; ++j) {\\n                for (size_t k = j + 1; k < arr_size; ++k) {\\n                    action_per_triplet(arr[i], arr[j], arr[k]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    inline static void print_triplet(\\n        const elem_t arr_i, \\n        const elem_t arr_j, \\n        const elem_t arr_k\\n    ) {\\n        cout << \\'(\\' << arr_i << \", \" << arr_j << \", \" << arr_k << \"), \";\\n    }\\n    \\n    inline static bool is_good_triplet(\\n        const elem_t arr_i, const elem_t arr_j, const elem_t arr_k,\\n        const elem_t a,     const elem_t b,     const elem_t c\\n    ) {\\n        return \\n            (abs(arr_i - arr_j) <= a) &&\\n            (abs(arr_j - arr_k) <= b) &&\\n            (abs(arr_k - arr_i) <= c);\\n    }\\n    //The intent here is to have this function inlined away, and so \\n    //if the compiler behaves as intended then the large parameter list \\n    //for is_good_triplet here shouldn\\'t matter.\\n    \\n    inline static triplet_action count_if_good_triplet(\\n        elem_t& count, \\n        const elem_t a, \\n        const elem_t b, \\n        const elem_t c\\n    ) {\\n        //{a, b, c} must be passed by value to the lambda here, else undefined behavior\\n        return [&, a, b, c](const elem_t arr_i, const elem_t arr_j, const elem_t arr_k) {\\n            if (is_good_triplet(arr_i, arr_j, arr_k, a, b, c)) ++count;\\n        };\\n    }\\n    \\n    inline static int solve_using_visitor(\\n        const list_t&   arr, \\n        const elem_t    a, \\n        const elem_t    b, \\n        const elem_t    c\\n     ) {\\n        //visit_triplets(arr, print_triplet); \\n        //You can use this (above) to easily print all the i<j<k triplets.\\n        //Notice how the visitor pattern allows us to reuse our\\n        //traversal of the triplets and apply any arbitrary verb\\n        //without ever again having to setup the traversal iteration.\\n        \\n        elem_t count = 0;\\n        \\n        visit_triplets(arr, count_if_good_triplet(count, a, b, c));\\n        \\n        return count;\\n    }\\n    \\n    //The visitor-based solution is running much slower (~2x slower) on Leetcode\\n    //compared to the below looping-based solution. It may (or may not) be due\\n    //to LeetCode potentially having bad optimization settings for C++ compilation.\\n    //I don\\'t know. Perhaps I should figure out if the optimizer is on/off.\\n    \\n    //////////////////////////////\\n    // Solution #2 (basic loop) //\\n    //////////////////////////////\\n    \\n    inline static int solve_using_loop(\\n        const list_t&   arr, \\n        const elem_t    a, \\n        const elem_t    b, \\n        const elem_t    c\\n    ) {\\n        int count = 0;\\n        const size_t arr_size = arr.size(); //Only improves performance if optimizer is off.\\n        for (size_t i = 0; i < arr_size; ++i) {\\n            for (size_t j = i + 1; j < arr_size; ++j) {\\n                for (size_t k = j + 1; k < arr_size; ++k) {\\n                    const bool is_good_triplet = \\n                        (abs(arr[i] - arr[j]) <= a) &&\\n                        (abs(arr[j] - arr[k]) <= b) &&\\n                        (abs(arr[k] - arr[i]) <= c);\\n                    if (is_good_triplet) ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    //This (above) is the obvious solution, but it isn\\'t as flexible in\\n    //the long term as the visitor pattern based approach in solution #1.\\n    //In a real project, overusing this kind of simpler approach to problems \\n    //and not making things more modular such as in the visitor based approach \\n    //will very likely be a net loss. It\\'s better to be modular and let the optimizer micromanage.\\n    \\n    /////////////////////////\\n    // Test case execution //\\n    /////////////////////////\\n    \\n    int countGoodTriplets(\\n        const list_t&   arr, \\n        const elem_t    a, \\n        const elem_t    b, \\n        const elem_t    c\\n    ) const {\\n        return solve_using_loop(arr, a, b, c);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    \\n    ////////////////////////////////////\\n    // Some extra (unnecessary) stuff //\\n    ////////////////////////////////////\\n    \\n    using elem_t = int;\\n    using list_t = vector<elem_t>;\\n    //The _t stands for typedef (\"using\" here is essentially a better version of typedef). \\n    //typedef and using declarations create type synonyms, never new types. That\\'s important.\\n    //I felt like abstracting the vector and element types this time,\\n    //just for practice and entertainment. It\\'s big overkill here.\\n    //\\n    //typedefs and using declarations allow us to abstract over types\\n    //in much the same way that we abstract over numbers and objects with variables. \\n    //It\\'s a nice trick. Templates are another related option. Pros and cons, as always.\\n    \\n    static_assert(is_same_v<list_t::size_type, size_t>);\\n    //Technically, the size type of vector may not be size_t, although it usually is.\\n    //It\\'s certainly not int though, despite the fact that int is so common in people\\'s loops\\n    //and can cause undefined behavior if the int ever overflows since int is signed.\\n    \\n    static_assert(is_unsigned_v<size_t>);\\n    //size_t is unsigned, so one should be careful not to decrement below 0 unintentionally.\\n    //This statement just alerts readers of the code to that and checks that it is true too.\\n    \\n    ///////////////////////////////////\\n    // Solution #1 (visitor pattern) //\\n    ///////////////////////////////////\\n    \\n    using triplet_action = function<void(elem_t, elem_t, elem_t)>;\\n    \\n    inline static void visit_triplets(\\n        const list_t    arr, \\n        triplet_action  action_per_triplet\\n    ) {\\n        const size_t arr_size = arr.size(); //Only improves performance if optimizer is off.\\n        for (size_t i = 0; i < arr_size; ++i) {\\n            for (size_t j = i + 1; j < arr_size; ++j) {\\n                for (size_t k = j + 1; k < arr_size; ++k) {\\n                    action_per_triplet(arr[i], arr[j], arr[k]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    inline static void print_triplet(\\n        const elem_t arr_i, \\n        const elem_t arr_j, \\n        const elem_t arr_k\\n    ) {\\n        cout << \\'(\\' << arr_i << \", \" << arr_j << \", \" << arr_k << \"), \";\\n    }\\n    \\n    inline static bool is_good_triplet(\\n        const elem_t arr_i, const elem_t arr_j, const elem_t arr_k,\\n        const elem_t a,     const elem_t b,     const elem_t c\\n    ) {\\n        return \\n            (abs(arr_i - arr_j) <= a) &&\\n            (abs(arr_j - arr_k) <= b) &&\\n            (abs(arr_k - arr_i) <= c);\\n    }\\n    //The intent here is to have this function inlined away, and so \\n    //if the compiler behaves as intended then the large parameter list \\n    //for is_good_triplet here shouldn\\'t matter.\\n    \\n    inline static triplet_action count_if_good_triplet(\\n        elem_t& count, \\n        const elem_t a, \\n        const elem_t b, \\n        const elem_t c\\n    ) {\\n        //{a, b, c} must be passed by value to the lambda here, else undefined behavior\\n        return [&, a, b, c](const elem_t arr_i, const elem_t arr_j, const elem_t arr_k) {\\n            if (is_good_triplet(arr_i, arr_j, arr_k, a, b, c)) ++count;\\n        };\\n    }\\n    \\n    inline static int solve_using_visitor(\\n        const list_t&   arr, \\n        const elem_t    a, \\n        const elem_t    b, \\n        const elem_t    c\\n     ) {\\n        //visit_triplets(arr, print_triplet); \\n        //You can use this (above) to easily print all the i<j<k triplets.\\n        //Notice how the visitor pattern allows us to reuse our\\n        //traversal of the triplets and apply any arbitrary verb\\n        //without ever again having to setup the traversal iteration.\\n        \\n        elem_t count = 0;\\n        \\n        visit_triplets(arr, count_if_good_triplet(count, a, b, c));\\n        \\n        return count;\\n    }\\n    \\n    //The visitor-based solution is running much slower (~2x slower) on Leetcode\\n    //compared to the below looping-based solution. It may (or may not) be due\\n    //to LeetCode potentially having bad optimization settings for C++ compilation.\\n    //I don\\'t know. Perhaps I should figure out if the optimizer is on/off.\\n    \\n    //////////////////////////////\\n    // Solution #2 (basic loop) //\\n    //////////////////////////////\\n    \\n    inline static int solve_using_loop(\\n        const list_t&   arr, \\n        const elem_t    a, \\n        const elem_t    b, \\n        const elem_t    c\\n    ) {\\n        int count = 0;\\n        const size_t arr_size = arr.size(); //Only improves performance if optimizer is off.\\n        for (size_t i = 0; i < arr_size; ++i) {\\n            for (size_t j = i + 1; j < arr_size; ++j) {\\n                for (size_t k = j + 1; k < arr_size; ++k) {\\n                    const bool is_good_triplet = \\n                        (abs(arr[i] - arr[j]) <= a) &&\\n                        (abs(arr[j] - arr[k]) <= b) &&\\n                        (abs(arr[k] - arr[i]) <= c);\\n                    if (is_good_triplet) ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    //This (above) is the obvious solution, but it isn\\'t as flexible in\\n    //the long term as the visitor pattern based approach in solution #1.\\n    //In a real project, overusing this kind of simpler approach to problems \\n    //and not making things more modular such as in the visitor based approach \\n    //will very likely be a net loss. It\\'s better to be modular and let the optimizer micromanage.\\n    \\n    /////////////////////////\\n    // Test case execution //\\n    /////////////////////////\\n    \\n    int countGoodTriplets(\\n        const list_t&   arr, \\n        const elem_t    a, \\n        const elem_t    b, \\n        const elem_t    c\\n    ) const {\\n        return solve_using_loop(arr, a, b, c);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1093634,
                "title": "c-straightforward-and-self-explained-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int size=arr.size(), res=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int A=arr[i];\\n            for(int j=i+1;j<size;j++)\\n            {\\n                int B=arr[j];\\n                if(abs(A-B)>a)\\n                    continue;\\n                for(int k=j+1;k<size;k++)\\n                {\\n                    int C=arr[k];\\n                    if(abs(B-C)>b||abs(A-C)>c)\\n                        continue;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int size=arr.size(), res=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int A=arr[i];\\n            for(int j=i+1;j<size;j++)\\n            {\\n                int B=arr[j];\\n                if(abs(A-B)>a)\\n                    continue;\\n                for(int k=j+1;k<size;k++)\\n                {\\n                    int C=arr[k];\\n                    if(abs(B-C)>b||abs(A-C)>c)\\n                        continue;\\n                    res++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1048834,
                "title": "c-soution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int res=0, i =0, j, k, n=arr.size();\\n        for (int i=0; i<n-2; ++i) {\\n            for (int j=i+1; j<n-1; ++j) {\\n                if (abs(arr[j]-arr[i])>a) {continue;}\\n                for (int k=j+1; k<n; ++k) {\\n                    if (abs(arr[k]-arr[j])>b) {continue;}\\n                    if (abs(arr[k]-arr[i])<=c) {++res;}\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int res=0, i =0, j, k, n=arr.size();\\n        for (int i=0; i<n-2; ++i) {\\n            for (int j=i+1; j<n-1; ++j) {\\n                if (abs(arr[j]-arr[i])>a) {continue;}\\n                for (int k=j+1; k<n; ++k) {\\n                    if (abs(arr[k]-arr[j])>b) {continue;}\\n                    if (abs(arr[k]-arr[i])<=c) {++res;}\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004356,
                "title": "simple-javascript-solution-88ms",
                "content": "```\\nlet countGoodTriplets = (arr, a, b, c) => {\\n    let checkTriplets = (i, j, k) => {\\n        const val1 = Math.abs(arr[i] - arr[j]) <= a;\\n        const val2 = Math.abs(arr[j] - arr[k]) <= b;\\n        const val3 = Math.abs(arr[i] - arr[k]) <= c;\\n        if (val1 && val2 && val3) {\\n            return true;\\n        }\\n    };\\n\\n    let count = 0;\\n    for (let i = 0; i < arr.length - 2; i++) {\\n        for (let j = i + 1; j < arr.length - 1; j++) {\\n            for (let k = j + 1; k < arr.length; k++) {\\n                if (checkTriplets(i, j, k)) {\\n                    count++;\\n                    //console.log(arr[i], arr[j], arr[k], \"count\", count);\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet countGoodTriplets = (arr, a, b, c) => {\\n    let checkTriplets = (i, j, k) => {\\n        const val1 = Math.abs(arr[i] - arr[j]) <= a;\\n        const val2 = Math.abs(arr[j] - arr[k]) <= b;\\n        const val3 = Math.abs(arr[i] - arr[k]) <= c;\\n        if (val1 && val2 && val3) {\\n            return true;\\n        }\\n    };\\n\\n    let count = 0;\\n    for (let i = 0; i < arr.length - 2; i++) {\\n        for (let j = i + 1; j < arr.length - 1; j++) {\\n            for (let k = j + 1; k < arr.length; k++) {\\n                if (checkTriplets(i, j, k)) {\\n                    count++;\\n                    //console.log(arr[i], arr[j], arr[k], \"count\", count);\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 984728,
                "title": "python-98-24-faster-and-relatively-simple-and-concise-solution",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        partial_solutions = list()\\n        count = 0\\n        \\n        for idx, n in enumerate(arr):\\n            for arri, arrj in partial_solutions:\\n                arrk = n\\n                if abs(arrj - arrk) <= b and abs(arri - arrk) <= c:\\n                    count += 1\\n        \\n            for arri in arr[:idx]:\\n                arrj = n\\n                if abs(arri - arrj) <= a:\\n                    partial_solutions.append((arri, arrj))\\n                    \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        partial_solutions = list()\\n        count = 0\\n        \\n        for idx, n in enumerate(arr):\\n            for arri, arrj in partial_solutions:\\n                arrk = n\\n                if abs(arrj - arrk) <= b and abs(arri - arrk) <= c:\\n                    count += 1\\n        \\n            for arri in arr[:idx]:\\n                arrj = n\\n                if abs(arri - arrj) <= a:\\n                    partial_solutions.append((arri, arrj))\\n                    \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896650,
                "title": "python-with-for-loops",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\'\\'\\'\\n        condition need to satisfy\\n        |arr[i] - arr[j]| <= a\\n        |arr[j] - arr[k]| <= b\\n        |arr[i] - arr[k]| <= c\\n        \\'\\'\\'\\n        results = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j+1, len(arr)):\\n                        if (abs(arr[j] - arr[k]) <= b) and (abs(arr[i] - arr[k]) <= c):\\n                            results += 1\\n        return results\\n\\t\\t\\n\\t\\t```\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\'\\'\\'\\n        condition need to satisfy\\n        |arr[i] - arr[j]| <= a\\n        |arr[j] - arr[k]| <= b\\n        |arr[i] - arr[k]| <= c\\n        \\'\\'\\'\\n        results = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j+1, len(arr)):\\n                        if (abs(arr[j] - arr[k]) <= b) and (abs(arr[i] - arr[k]) <= c):\\n                            results += 1\\n        return results\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 796705,
                "title": "4-ms-2-2-mb",
                "content": "```\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n\\nfunc countGoodTriplets(arr []int, a int, b int, c int) int {\\n    cnt := 0\\n    for i := 0; i < len(arr) - 2; i++ {\\n        for j := i + 1; j < len(arr) - 1; j++ {\\n            if abs(arr[i] - arr[j]) <= a {\\n                for k := j + 1; k < len(arr); k++ {\\n                    if  abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c {\\n                        cnt++\\n                    }    \\n                }\\n            }\\n        }\\n    }\\n    return cnt\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n\\nfunc countGoodTriplets(arr []int, a int, b int, c int) int {\\n    cnt := 0\\n    for i := 0; i < len(arr) - 2; i++ {\\n        for j := i + 1; j < len(arr) - 1; j++ {\\n            if abs(arr[i] - arr[j]) <= a {\\n                for k := j + 1; k < len(arr); k++ {\\n                    if  abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c {\\n                        cnt++\\n                    }    \\n                }\\n            }\\n        }\\n    }\\n    return cnt\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774810,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        int n=arr.length;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=i+1;j<n-1;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    int a1=Math.abs(arr[i]-arr[j]);\\n                    int b1=Math.abs(arr[j]-arr[k]);\\n                    int c1=Math.abs(arr[i]-arr[k]);\\n                    if(a1<=a && b1<=b && c1<=c)\\n                    {\\n                        count++;\\n                     }\\n                   \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        int n=arr.length;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=i+1;j<n-1;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    int a1=Math.abs(arr[i]-arr[j]);\\n                    int b1=Math.abs(arr[j]-arr[k]);\\n                    int c1=Math.abs(arr[i]-arr[k]);\\n                    if(a1<=a && b1<=b && c1<=c)\\n                    {\\n                        count++;\\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 769121,
                "title": "c-solution",
                "content": "```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n\\tint numGoodTriplets = 0;\\n\\tfor (int i = 0; i < arr.size() - 2; i++)\\n\\t\\tfor (int j = i + 1; j < arr.size() - 1; j++)\\n\\t\\t\\tfor (int k = j + 1; k < arr.size(); k++)\\n\\t\\t\\t\\tif (abs(arr[i] - arr[j]) <= a &&\\n\\t\\t\\t\\t\\tabs(arr[j] - arr[k]) <= b &&\\n\\t\\t\\t\\t\\tabs(arr[i] - arr[k]) <= c)\\n\\t\\t\\t\\t\\tnumGoodTriplets++;\\n\\treturn numGoodTriplets;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n\\tint numGoodTriplets = 0;\\n\\tfor (int i = 0; i < arr.size() - 2; i++)\\n\\t\\tfor (int j = i + 1; j < arr.size() - 1; j++)\\n\\t\\t\\tfor (int k = j + 1; k < arr.size(); k++)\\n\\t\\t\\t\\tif (abs(arr[i] - arr[j]) <= a &&\\n\\t\\t\\t\\t\\tabs(arr[j] - arr[k]) <= b &&\\n\\t\\t\\t\\t\\tabs(arr[i] - arr[k]) <= c)\\n\\t\\t\\t\\t\\tnumGoodTriplets++;\\n\\treturn numGoodTriplets;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922812,
                "title": "runtime-beats-100-00-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/4907bfd0-b466-47af-861a-b070bf799eaa_1692282582.9593415.png)\\n\\n# Complexity\\n- Time complexity:O(n^3) Beats 100.00% of users with JavaScript\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let result=0;\\n    for(let i=0;i<arr.length;i++){\\n        let val1=arr[i];\\n        for(let j=i+1;j<arr.length;j++){\\n            let val2=arr[j];\\n            let diff1=Math.abs(val1-val2);\\n            if (diff1 > a) continue;\\n            for(let k=j+1;k<arr.length;k++){\\n                let val3=arr[k];\\n                let diff2=Math.abs(val2-val3);\\n                let diff3=Math.abs(val1-val3);\\n                if(diff2 <=b && diff3 <=c){\\n                    result++;\\n                }\\n            }\\n        } \\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let result=0;\\n    for(let i=0;i<arr.length;i++){\\n        let val1=arr[i];\\n        for(let j=i+1;j<arr.length;j++){\\n            let val2=arr[j];\\n            let diff1=Math.abs(val1-val2);\\n            if (diff1 > a) continue;\\n            for(let k=j+1;k<arr.length;k++){\\n                let val3=arr[k];\\n                let diff2=Math.abs(val2-val3);\\n                let diff3=Math.abs(val1-val3);\\n                if(diff2 <=b && diff3 <=c){\\n                    result++;\\n                }\\n            }\\n        } \\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689237,
                "title": "time-78-memory-99-9-you-can-remove-triple-for-statement-with-itertool",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can use itertool.\\nAnd there are awesome $$O(nlogn)$$ solution using fenwick tree\\nLook at the other solution down below\\n# Complexity\\n- Time complexity: $$O(N^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        cnt = 0\\n        for i, j, k in itertools.combinations(arr, 3):\\n            if abs(i-j) <= a and abs(j-k) <= b and abs(k-i) <= c:\\n                cnt +=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        cnt = 0\\n        for i, j, k in itertools.combinations(arr, 3):\\n            if abs(i-j) <= a and abs(j-k) <= b and abs(k-i) <= c:\\n                cnt +=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492713,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length - 2; i++) {\\n            for(int j = i + 1; j < arr.length - 1; j++) {\\n                if(Math.abs(arr[i] - arr[j]) <= a) {\\n                    for(int k = j + 1; k < arr.length; k++) {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i]-arr[k]) <=c) {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length - 2; i++) {\\n            for(int j = i + 1; j < arr.length - 1; j++) {\\n                if(Math.abs(arr[i] - arr[j]) <= a) {\\n                    for(int k = j + 1; k < arr.length; k++) {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i]-arr[k]) <=c) {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482339,
                "title": "c-basic-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size(),cnt=0;\\n        for(int i=0;i<n;i++){\\n            for (int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c) cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size(),cnt=0;\\n        for(int i=0;i<n;i++){\\n            for (int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c) cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465360,
                "title": "brute-force",
                "content": "# Complexity\\n- Time complexity:\\nO(N ** 3)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction countGoodTriplets(arr: number[], a: number, b: number, c: number): number {\\n    let count = 0\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = i + 1; j < arr.length; j++) {\\n            for (let k = j + 1; k < arr.length; k++) {\\n                if (\\n                    Math.abs(arr[i] - arr[j]) <= a &&\\n                    Math.abs(arr[j] - arr[k]) <= b &&\\n                    Math.abs(arr[i] - arr[k]) <= c\\n                ) count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n// Approach A.  Brute Force\\n// 3 nested loops\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction countGoodTriplets(arr: number[], a: number, b: number, c: number): number {\\n    let count = 0\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = i + 1; j < arr.length; j++) {\\n            for (let k = j + 1; k < arr.length; k++) {\\n                if (\\n                    Math.abs(arr[i] - arr[j]) <= a &&\\n                    Math.abs(arr[j] - arr[k]) <= b &&\\n                    Math.abs(arr[i] - arr[k]) <= c\\n                ) count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n// Approach A.  Brute Force\\n// 3 nested loops\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3248653,
                "title": "count-good-triplets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            for(j=i+1 ; j<arr.size()-1 ; j++)\\n            {\\n                if((abs(arr[i]-arr[j])<=a))\\n                {\\n                    for(k=j+1 ; k<arr.size() ; k++)\\n                    {\\n                        if((abs(arr[j]-arr[k])<=b) && (abs(arr[i]-arr[k])<=c))\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            for(j=i+1 ; j<arr.size()-1 ; j++)\\n            {\\n                if((abs(arr[i]-arr[j])<=a))\\n                {\\n                    for(k=j+1 ; k<arr.size() ; k++)\\n                    {\\n                        if((abs(arr[j]-arr[k])<=b) && (abs(arr[i]-arr[k])<=c))\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248648,
                "title": "count-good-triplets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            for(j=i+1 ; j<arr.size()-1 ; j++)\\n            {\\n                for(k=j+1 ; k<arr.size() ; k++)\\n                {\\n                    if((abs(arr[i]-arr[j])<=a) && (abs(arr[j]-arr[k])<=b) && (abs(arr[i]-arr[k])<=c))\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            for(j=i+1 ; j<arr.size()-1 ; j++)\\n            {\\n                for(k=j+1 ; k<arr.size() ; k++)\\n                {\\n                    if((abs(arr[i]-arr[j])<=a) && (abs(arr[j]-arr[k])<=b) && (abs(arr[i]-arr[k])<=c))\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121994,
                "title": "simple-java-solution-easy-to-understand-for-beginners-o-n-3-time-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int count = 0 ; \\n//we make an int count so that whenever we find a good triplet it can be incremented\\n//and we will return it\\'s value in the end ;\\n\\n//we simply used nested for loops to find good triplets as the length of the \\n//given array is <=100 ;\\n        for(int i = 0 ; i < arr.length-2 ; i++){\\n            for(int j = i+1 ; j < arr.length-1 ; j++){\\n                for(int k = j+1 ; k < arr.length ; k++){\\n                    boolean x = good(a,b,c,arr[i],arr[j],arr[k]);\\n                    if(x)count++;\\n                }\\n            }\\n        }\\n        return count ;\\n    }\\n    //this function checks them for a good triplet and return true if they are ;\\n    public boolean good(int a , int b , int c , int i , int j , int k){\\n        \\n        int first = i-j ; first = Math.abs(first);\\n        int second = j-k ; second = Math.abs(second);\\n        int third = k-i ; third = Math.abs(third);\\n        if(first <= a && second <= b && third <= c) return true;\\n        \\n        return false ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int count = 0 ; \\n//we make an int count so that whenever we find a good triplet it can be incremented\\n//and we will return it\\'s value in the end ;\\n\\n//we simply used nested for loops to find good triplets as the length of the \\n//given array is <=100 ;\\n        for(int i = 0 ; i < arr.length-2 ; i++){\\n            for(int j = i+1 ; j < arr.length-1 ; j++){\\n                for(int k = j+1 ; k < arr.length ; k++){\\n                    boolean x = good(a,b,c,arr[i],arr[j],arr[k]);\\n                    if(x)count++;\\n                }\\n            }\\n        }\\n        return count ;\\n    }\\n    //this function checks them for a good triplet and return true if they are ;\\n    public boolean good(int a , int b , int c , int i , int j , int k){\\n        \\n        int first = i-j ; first = Math.abs(first);\\n        int second = j-k ; second = Math.abs(second);\\n        int third = k-i ; third = Math.abs(third);\\n        if(first <= a && second <= b && third <= c) return true;\\n        \\n        return false ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114898,
                "title": "pyhton3-solution-triple-nested-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem is to use a triple nested loop. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, I will use a triple nested loop. The outer loop will iterate through each element in the array. For each element, the two inner loops will iterate through the elements after the outer loop\\'s current index to make a triplet. After making each triplet, we can then check if each element of the triplet meets the criteria for being a good triplet. If it does, then we can increment our counter. \\n# Complexity\\n- Time complexity: $$$$O(n^3)$$$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count = 0\\n        for i in range(len(arr) - 2):\\n            for j in range(i + 1, len(arr) - 1):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j + 1, len(arr)):\\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                            count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count = 0\\n        for i in range(len(arr) - 2):\\n            for j in range(i + 1, len(arr) - 1):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    for k in range(j + 1, len(arr)):\\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114587,
                "title": "naive-approach-count-good-triplets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count=0\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                for k in range(len(arr)):\\n                    if i>=0 and i<j and j<k and k<len(arr):\\n                        if abs(arr[i]-arr[j] )<=a and abs(arr[j]-arr[k] )<=b and abs(arr[i]-arr[k] )<=c:\\n                            count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count=0\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                for k in range(len(arr)):\\n                    if i>=0 and i<j and j<k and k<len(arr):\\n                        if abs(arr[i]-arr[j] )<=a and abs(arr[j]-arr[k] )<=b and abs(arr[i]-arr[k] )<=c:\\n                            count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643471,
                "title": "c-solution-count-good-triplets-brute-force-solution",
                "content": "**Brute Force**\\n* Time Complexity - O(N^3)\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt = 0;\\n        int n = arr.size();\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j < n; j++){\\n                for(int k = j+1; k < n; k++){\\n                    if(abs(arr[i] - arr[j]) <= a && abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt = 0;\\n        int n = arr.size();\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j < n; j++){\\n                for(int k = j+1; k < n; k++){\\n                    if(abs(arr[i] - arr[j]) <= a && abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549794,
                "title": "simple-brute-force-python-solution",
                "content": "Time Complexcity O(N^3)\\nSpace complexcity O(1)\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count=0\\n        n=len(arr)\\n        for i in range(n-2):\\n            for j in range(i+1,n-1):\\n                for k in range(j+1,n):\\n                    if abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c:\\n                        count+=1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count=0\\n        n=len(arr)\\n        for i in range(n-2):\\n            for j in range(i+1,n-1):\\n                for k in range(j+1,n):\\n                    if abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c:\\n                        count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435009,
                "title": "triplet-soution",
                "content": "```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n    int size = arr.size();\\n    int ans = 0;\\n    for (int i = 0; i < size; i++) {\\n        for (int j = i + 1; j < size; j++) {\\n            for (int k = j + 1; k < size; k++) {\\n                if((abs(arr[i] - arr[j]) <= a) && (abs(arr[j] - arr[k]) <= b) && (abs(arr[i] - arr[k]) <= c))\\n                ans++;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n    int size = arr.size();\\n    int ans = 0;\\n    for (int i = 0; i < size; i++) {\\n        for (int j = i + 1; j < size; j++) {\\n            for (int k = j + 1; k < size; k++) {\\n                if((abs(arr[i] - arr[j]) <= a) && (abs(arr[j] - arr[k]) <= b) && (abs(arr[i] - arr[k]) <= c))\\n                ans++;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412834,
                "title": "c-easy-solution",
                "content": "**C++ Code:**\\n\\n```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n = arr.size(),count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                        count++;\\n                }\\n            }\\n        }\\n     return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n = arr.size(),count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                        count++;\\n                }\\n            }\\n        }\\n     return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2392726,
                "title": "java-solution-brute-force",
                "content": "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int n = arr.length,\\n        ans = 0;\\n        for(int i = 0;i<n-2;i++){\\n            for(int j = i+1;j<n-1;j++){\\n                if(Math.abs(arr[i]-arr[j])<=a){\\n                    for(int k = j+1;k<n;k++){\\n                        if(Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                            ans++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int n = arr.length,\\n        ans = 0;\\n        for(int i = 0;i<n-2;i++){\\n            for(int j = i+1;j<n-1;j++){\\n                if(Math.abs(arr[i]-arr[j])<=a){\\n                    for(int k = j+1;k<n;k++){\\n                        if(Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                            ans++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2346574,
                "title": "java-easy-solution-brute-force-only-using-for-loop",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                for(int k = j + 1; k <arr.length; k++){\\n                    if(Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b &&   Math.abs(arr[i] - arr[k]) <= c) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                for(int k = j + 1; k <arr.length; k++){\\n                    if(Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b &&   Math.abs(arr[i] - arr[k]) <= c) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330945,
                "title": "c-easy-beginner-friendly-solution",
                "content": "Stats for this solution:\\nRuntime: 29 ms, faster than 95.79% of C++ online submissions for Count Good Triplets.\\nMemory Usage: 8.1 MB, less than 70.95% of C++ online submissions for Count Good Triplets.\\n\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i + 1; j < arr.size(); j++) {\\n                if(abs(arr[j] - arr[i]) <= a) {\\n                    for(int k = j + 1; k < arr.size(); k++) {\\n                        if(abs(arr[k] - arr[i]) <= c && abs(arr[k] - arr[j]) <= b) count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i + 1; j < arr.size(); j++) {\\n                if(abs(arr[j] - arr[i]) <= a) {\\n                    for(int k = j + 1; k < arr.size(); k++) {\\n                        if(abs(arr[k] - arr[i]) <= c && abs(arr[k] - arr[j]) <= b) count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309910,
                "title": "java-brute-force-optimized-approach",
                "content": "```\\nclass Solution {\\n    private boolean isGood ( int[] arr, int i, int j, int k, int a, int b, int c ) {\\n        return (Math.abs(arr[i] - arr[j]) <= a) && (Math.abs(arr[j] - arr[k]) <= b) && (Math.abs(arr[i] - arr[k]) <= c);\\n    }\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int n = arr.length, ct = 0;\\n        for ( int i = 0; i < n - 2; i++ )\\n            for ( int j = i + 1; j < n - 1; j++ )\\n                for ( int k = j + 1; k < n; k++ )\\n                    if ( isGood(arr, i, j, k, a, b, c) ) ct++;\\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isGood ( int[] arr, int i, int j, int k, int a, int b, int c ) {\\n        return (Math.abs(arr[i] - arr[j]) <= a) && (Math.abs(arr[j] - arr[k]) <= b) && (Math.abs(arr[i] - arr[k]) <= c);\\n    }\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int n = arr.length, ct = 0;\\n        for ( int i = 0; i < n - 2; i++ )\\n            for ( int j = i + 1; j < n - 1; j++ )\\n                for ( int k = j + 1; k < n; k++ )\\n                    if ( isGood(arr, i, j, k, a, b, c) ) ct++;\\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294196,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& nums, int a, int b, int c) {\\n        int ans = 0 ;\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            for(int j = i + 1 ; j < nums.size() ; ++j ){\\n                if(abs(nums[j]-nums[i]) > a) continue ;\\n                \\n                for(int k = j + 1 ; k < nums.size(); ++k ){\\n                    if(abs(nums[k] - nums[j]) > b || abs(nums[k]  - nums[i]) > c ) continue ;\\n                    ++ans ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& nums, int a, int b, int c) {\\n        int ans = 0 ;\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            for(int j = i + 1 ; j < nums.size() ; ++j ){\\n                if(abs(nums[j]-nums[i]) > a) continue ;\\n                \\n                for(int k = j + 1 ; k < nums.size(); ++k ){\\n                    if(abs(nums[k] - nums[j]) > b || abs(nums[k]  - nums[i]) > c ) continue ;\\n                    ++ans ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232493,
                "title": "java-solution-faster-than-89",
                "content": "class Solution {\\n    \\n\\tpublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        \\n        for(int i=0;i<arr.length-2;i++){\\n            for(int j=i+1;j<arr.length-1;j++){\\n                int aa = arr[i]-arr[j];\\n                if(aa<0)\\n                    aa=aa*-1;\\n                if(aa>a)                   //check if condition1 is wrong\\n                    continue;              //then do not irritate other loops and go for next ith element\\n                \\n                for(int k=j+1;k<arr.length;k++){\\n                    int bb = arr[j]-arr[k];\\n                    int cc = arr[i]-arr[k];\\n                    \\n                    if(bb<0)\\n                        bb=bb*-1;\\n                    if(cc<0)\\n                        cc=cc*-1;\\n                    \\n                    if(bb<=b && cc<=c)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        \\n        for(int i=0;i<arr.length-2;i++){\\n            for(int j=i+1;j<arr.length-1;j++){\\n                int aa = arr[i]-arr[j];\\n                if(aa<0)\\n                    aa=aa*-1;\\n                if(aa>a)                   //check if condition1 is wrong\\n                    continue;              //then do not irritate other loops and go for next ith element\\n                \\n                for(int k=j+1;k<arr.length;k++){\\n                    int bb = arr[j]-arr[k];\\n                    int cc = arr[i]-arr[k];\\n                    \\n                    if(bb<0)\\n                        bb=bb*-1;\\n                    if(cc<0)\\n                        cc=cc*-1;\\n                    \\n                    if(bb<=b && cc<=c)\\n                        count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2212521,
                "title": "brute-force-java-80-loop",
                "content": "```\\n public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count =0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i+1; j < arr.length; j++){\\n                \\n                if(Math.abs(arr[i]-arr[j]) <= a){\\n                    \\n                    for(int k = j+1; k < arr.length; k++){\\n                        if(Math.abs(arr[j]-arr[k]) <= b && Math.abs(arr[i]-arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count =0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i+1; j < arr.length; j++){\\n                \\n                if(Math.abs(arr[i]-arr[j]) <= a){\\n                    \\n                    for(int k = j+1; k < arr.length; k++){\\n                        if(Math.abs(arr[j]-arr[k]) <= b && Math.abs(arr[i]-arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130718,
                "title": "python-one-liner-bruteforce",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, x: List[int], a: int, b: int, c: int) -> int:\\n        return sum(sum(sum(1 if abs(x[i]-x[j])<=a and abs(x[j]-x[k])<=b and abs(x[k]-x[i])<=c else 0 for k in range(j+1,len(x))) for j in range(i+1,len(x))) for i in range(len(x)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, x: List[int], a: int, b: int, c: int) -> int:\\n        return sum(sum(sum(1 if abs(x[i]-x[j])<=a and abs(x[j]-x[k])<=b and abs(x[k]-x[i])<=c else 0 for k in range(j+1,len(x))) for j in range(i+1,len(x))) for i in range(len(x)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098694,
                "title": "c-easy-solution-faster-than-95",
                "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n        int t=0;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            for(int j=i+1; j<arr.size(); j++){\\n                \\n                if(abs(arr[i]-arr[j])>a) continue;\\n                \\n                for(int k=j+1;k<arr.size();k++){\\n                    \\n                    if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                        \\n                        t++;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return t;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n        int t=0;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            for(int j=i+1; j<arr.size(); j++){\\n                \\n                if(abs(arr[i]-arr[j])>a) continue;\\n                \\n                for(int k=j+1;k<arr.size();k++){\\n                    \\n                    if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                        \\n                        t++;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2081254,
                "title": "c-easy-brute-force-prior-if-check-for-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt=0;\\n        for(int i=0;i<arr.size();++i)\\n            for(int j=i+1;j<arr.size();++j){\\n                if(abs(arr[i]-arr[j])>a) continue;\\n                for(int k=j+1;k<size(arr);++k)\\n                    if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)cnt++;                \\n            }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt=0;\\n        for(int i=0;i<arr.size();++i)\\n            for(int j=i+1;j<arr.size();++j){\\n                if(abs(arr[i]-arr[j])>a) continue;\\n                for(int k=j+1;k<size(arr);++k)\\n                    if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)cnt++;                \\n            }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080251,
                "title": "c-beginner-level-easy-and-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n      for(int i=0;i<arr.size();i++){\\n          for(int j=i+1;j<arr.size();j++){\\n              for(int k=j+1;k<arr.size();k++){\\n                    if((abs(arr[i]-arr[j])<=a)  and (abs(arr[j]-arr[k])<=b) and (abs(arr[i]-arr[k])<=c))\\n                    {\\n                        count++;\\n                    }\\n              }\\n          }\\n      }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n      for(int i=0;i<arr.size();i++){\\n          for(int j=i+1;j<arr.size();j++){\\n              for(int k=j+1;k<arr.size();k++){\\n                    if((abs(arr[i]-arr[j])<=a)  and (abs(arr[j]-arr[k])<=b) and (abs(arr[i]-arr[k])<=c))\\n                    {\\n                        count++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2075075,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):                  \\n                for k in range(j+1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        count = count + 1\\n        return count\\n                    \\n                   \\n                    \\n        \\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):                  \\n                for k in range(j+1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        count = count + 1\\n        return count\\n                    \\n                   \\n                    \\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2049662,
                "title": "multiple-cpp-approaches-explained",
                "content": "**Brute Force**\\n\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n(arr.size());\\n        \\n        int count(0);\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            for(int j=i+1;j<n-1;j++){\\n                \\n                for(int k=j+1;k<n;k++){\\n                    \\n                    bool q=abs(arr[i] - arr[j]) <= a;\\n                    bool w=abs(arr[j] - arr[k]) <= b;\\n                    bool e=abs(arr[i] - arr[k]) <= c;\\n                    if( q and w and e ){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n\\n**Improved version than previous version buy reduing third loop buy comaping it with \"a\" condition**\\n\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n(arr.size());\\n        \\n        int count(0);\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            for(int j=i+1;j<n-1;j++){\\n                \\n                bool q ( abs(arr[i] - arr[j]) <= a );\\n                \\n                if(!q)\\n                    continue;\\n                \\n                for(int k=j+1;k<n;k++){\\n                    \\n                    \\n                    bool w ( abs(arr[j] - arr[k]) <= b );\\n                    bool e ( abs(arr[i] - arr[k]) <= c );\\n                    \\n                    count+=(w&&e);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n(arr.size());\\n        \\n        int count(0);\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            for(int j=i+1;j<n-1;j++){\\n                \\n                for(int k=j+1;k<n;k++){\\n                    \\n                    bool q=abs(arr[i] - arr[j]) <= a;\\n                    bool w=abs(arr[j] - arr[k]) <= b;\\n                    bool e=abs(arr[i] - arr[k]) <= c;\\n                    if( q and w and e ){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n(arr.size());\\n        \\n        int count(0);\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            for(int j=i+1;j<n-1;j++){\\n                \\n                bool q ( abs(arr[i] - arr[j]) <= a );\\n                \\n                if(!q)\\n                    continue;\\n                \\n                for(int k=j+1;k<n;k++){\\n                    \\n                    \\n                    bool w ( abs(arr[j] - arr[k]) <= b );\\n                    bool e ( abs(arr[i] - arr[k]) <= c );\\n                    \\n                    count+=(w&&e);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024618,
                "title": "fast-easy-to-understand-js-solution",
                "content": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n  let triplets = 0;\\n\\n  for (let i = 0; i < arr.length - 2; i++) {\\n    for (let j = i + 1; j < arr.length - 1; j++) {\\n      if (Math.abs(arr[i] - arr[j]) > a) continue;\\n      for (let k = j + 1; k < arr.length; k++) {\\n        if (Math.abs(arr[j] - arr[k]) > b || Math.abs(arr[i] - arr[k]) > c) {\\n          continue;\\n        }\\n        triplets++;\\n      }\\n    }\\n  }\\n\\n  return triplets;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n  let triplets = 0;\\n\\n  for (let i = 0; i < arr.length - 2; i++) {\\n    for (let j = i + 1; j < arr.length - 1; j++) {\\n      if (Math.abs(arr[i] - arr[j]) > a) continue;\\n      for (let k = j + 1; k < arr.length; k++) {\\n        if (Math.abs(arr[j] - arr[k]) > b || Math.abs(arr[i] - arr[k]) > c) {\\n          continue;\\n        }\\n        triplets++;\\n      }\\n    }\\n  }\\n\\n  return triplets;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1923480,
                "title": "rust-brute-force-0ms-lol",
                "content": "As a pythonista, it\\'s hard to believe you can make it 0ms with O(n^3)\\n\\n```rust\\nimpl Solution {\\n    pub fn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n        let mut count = 0;\\n        let lens = arr.len();\\n        for i in 0..lens-2 {\\n            for j in i+1..lens-1 {\\n                if ((arr[i] - arr[j]).abs() <= a) {\\n                    for k in j+1..lens {\\n                        if ((arr[j] - arr[k]).abs() <= b && (arr[k] - arr[i]).abs() <= c ) {\\n                            count+=1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n        let mut count = 0;\\n        let lens = arr.len();\\n        for i in 0..lens-2 {\\n            for j in i+1..lens-1 {\\n                if ((arr[i] - arr[j]).abs() <= a) {\\n                    for k in j+1..lens {\\n                        if ((arr[j] - arr[k]).abs() <= b && (arr[k] - arr[i]).abs() <= c ) {\\n                            count+=1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884907,
                "title": "c-fast",
                "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                for(int k=j+1;k<arr.size();k++){\\n                    if(  abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                        count++;\\n}\\n                }\\n            }\\n        }\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                for(int k=j+1;k<arr.size();k++){\\n                    if(  abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                        count++;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1884902,
                "title": "c-apporach-very-optimal",
                "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt=0;\\n        \\n        for( int i=0;i<arr.size();i++){\\n            for (int j=i+1;j<arr.size();j++){\\n                if(abs(arr[i]-arr[j])<=a ){\\n                 for( int k=j+1;k<arr.size();k++){\\n                     if( abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                         cnt++;\\n                     }\\n                  }\\n                }\\n            }\\n            \\n        \\n        }\\n        return cnt;\\n        \\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt=0;\\n        \\n        for( int i=0;i<arr.size();i++){\\n            for (int j=i+1;j<arr.size();j++){\\n                if(abs(arr[i]-arr[j])<=a ){\\n                 for( int k=j+1;k<arr.size();k++){\\n                     if( abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                         cnt++;\\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 1863815,
                "title": "java-easy-solution-brute-force",
                "content": "class Solution \\n{\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<arr.length;i++)    \\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                for(int k=0;k<j;k++)\\n                {\\n                    if((Math.abs(arr[k]-arr[j])<=a) && (Math.abs(arr[j]-arr[i])<=b) &&                                  (Math.abs(arr[k]-arr[i])<=c)) \\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<arr.length;i++)    \\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                for(int k=0;k<j;k++)\\n                {\\n                    if((Math.abs(arr[k]-arr[j])<=a) && (Math.abs(arr[j]-arr[i])<=b) &&                                  (Math.abs(arr[k]-arr[i])<=c)) \\n                    {\\n                        cnt++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1847178,
                "title": "javascript-solution-76-ms-42-1-mb",
                "content": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let count = 0\\n    for(let i = 0; i < arr.length; i++){\\n        for(let j = i + 1; j < arr.length; j++){\\n            for(let k = j + 1; k < arr.length; k++){\\n                Math.abs(arr[i] - arr[j]) <= a &&  Math.abs(arr[j] - arr[k]) <= b &&  Math.abs(arr[i] - arr[k]) <= c && count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let count = 0\\n    for(let i = 0; i < arr.length; i++){\\n        for(let j = i + 1; j < arr.length; j++){\\n            for(let k = j + 1; k < arr.length; k++){\\n                Math.abs(arr[i] - arr[j]) <= a &&  Math.abs(arr[j] - arr[k]) <= b &&  Math.abs(arr[i] - arr[k]) <= c && count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826109,
                "title": "count-good-triplets",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (int k = j + 1; k < arr.size(); k++)\\n                    {\\n                        int B = abs(arr[j] - arr[k]);\\n                        int C = abs(arr[k] - arr[i]);\\n                        if (B <= b and C <= c)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (int k = j + 1; k < arr.size(); k++)\\n                    {\\n                        int B = abs(arr[j] - arr[k]);\\n                        int C = abs(arr[k] - arr[i]);\\n                        if (B <= b and C <= c)\\n                        {\\n                            count++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1756596,
                "title": "python-olution",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        x, count = len(arr), 0\\n        for i in range(x):\\n            for j in range(i+1,x):\\n                if abs(arr[i] -arr[j]) < a+1:\\n                    for k in range(j+1,x):\\n                        if abs(arr[j] -arr[k]) < b+1 and abs(arr[i] -arr[k]) < c+1:\\n                            count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        x, count = len(arr), 0\\n        for i in range(x):\\n            for j in range(i+1,x):\\n                if abs(arr[i] -arr[j]) < a+1:\\n                    for k in range(j+1,x):\\n                        if abs(arr[j] -arr[k]) < b+1 and abs(arr[i] -arr[k]) < c+1:\\n                            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709360,
                "title": "c-solution",
                "content": "beginner friendly\\n```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(i<arr.size()-2){\\n            if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                count++;\\n            }\\n            if(k!=arr.size()-1 && j!=arr.size()-2){\\n                k++;\\n            }else if(k==arr.size()-1 && j!=arr.size()-2){\\n                j++;\\n                k=j+1;\\n            }else if(k!=arr.size()-1 && j==arr.size()-2){\\n                k++;\\n            }else{\\n                i++;\\n                j=i+1;\\n                k=j+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(i<arr.size()-2){\\n            if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c){\\n                count++;\\n            }\\n            if(k!=arr.size()-1 && j!=arr.size()-2){\\n                k++;\\n            }else if(k==arr.size()-1 && j!=arr.size()-2){\\n                j++;\\n                k=j+1;\\n            }else if(k!=arr.size()-1 && j==arr.size()-2){\\n                k++;\\n            }else{\\n                i++;\\n                j=i+1;\\n                k=j+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699767,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic int CountGoodTriplets(int[] arr, int a, int b, int c) =>\\n    Enumerable.Range(0, arr.Length - 2).Sum(i =>\\n    Enumerable.Range(i + 1, arr.Length - 2 - i).Sum(j =>\\n    Enumerable.Range(j + 1, arr.Length - 1 - j).Count(k =>\\n        Math.Abs(arr[i] - arr[j]) <= a && Math.Abs(arr[j] - arr[k]) <= b && Math.Abs(arr[i] - arr[k]) <= c)));\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int CountGoodTriplets(int[] arr, int a, int b, int c) =>\\n    Enumerable.Range(0, arr.Length - 2).Sum(i =>\\n    Enumerable.Range(i + 1, arr.Length - 2 - i).Sum(j =>\\n    Enumerable.Range(j + 1, arr.Length - 1 - j).Count(k =>\\n        Math.Abs(arr[i] - arr[j]) <= a && Math.Abs(arr[j] - arr[k]) <= b && Math.Abs(arr[i] - arr[k]) <= c)));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691287,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678102,
                "title": "o-n-2",
                "content": "**Step 1:** Create 3 separate sets of tuples of indexes, which give the expected differences of a, b , c using O(n^2) operation in loop 1\\n**Step 2:** For tuples identified in above step, use a nested loop for set_a and set_b and check if the required tuple exist in set_c  in another O(k^2) operation. k is number of tuples which satisfies the given condtion. If found increment count\\n**Step 3:** return count\\n\\n**The caveat here is, if k < n, this works well. However, if k >> n, then O(k^2) approaches O(n^3) which defeats the purpose and can make the solution useless. **\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        diff_pairs = []\\n        for i in range(3):\\n            diff_pairs.append(set())\\n        \\n        count = 0\\n        \\n        for i in range(len(arr)):\\n            for j in range(i + 1,len(arr)):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    diff_pairs[0].add((i,j))\\n                if abs(arr[i] - arr[j]) <= b:\\n                    diff_pairs[1].add((i,j))\\n                if abs(arr[i] - arr[j]) <= c:\\n                    diff_pairs[2].add((i,j))\\n        \\n        for a_diff in diff_pairs[0]:\\n            for b_diff in diff_pairs[1]:\\n                if a_diff[1] == b_diff[0] and (a_diff[0], b_diff[1]) in diff_pairs[2]:\\n                    count+=1\\n        \\n        return count",
                "solutionTags": [],
                "code": "**Step 1:** Create 3 separate sets of tuples of indexes, which give the expected differences of a, b , c using O(n^2) operation in loop 1\\n**Step 2:** For tuples identified in above step, use a nested loop for set_a and set_b and check if the required tuple exist in set_c  in another O(k^2) operation. k is number of tuples which satisfies the given condtion. If found increment count\\n**Step 3:** return count\\n\\n**The caveat here is, if k < n, this works well. However, if k >> n, then O(k^2) approaches O(n^3) which defeats the purpose and can make the solution useless. **\\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        diff_pairs = []\\n        for i in range(3):\\n            diff_pairs.append(set())\\n        \\n        count = 0\\n        \\n        for i in range(len(arr)):\\n            for j in range(i + 1,len(arr)):\\n                if abs(arr[i] - arr[j]) <= a:\\n                    diff_pairs[0].add((i,j))\\n                if abs(arr[i] - arr[j]) <= b:\\n                    diff_pairs[1].add((i,j))\\n                if abs(arr[i] - arr[j]) <= c:\\n                    diff_pairs[2].add((i,j))\\n        \\n        for a_diff in diff_pairs[0]:\\n            for b_diff in diff_pairs[1]:\\n                if a_diff[1] == b_diff[0] and (a_diff[0], b_diff[1]) in diff_pairs[2]:\\n                    count+=1\\n        \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1672517,
                "title": "c-overthought-out-approach-not-very-fast",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool conditionOne(int size, int i, int j, int k)\\n    {\\n        if(0 <= i && j > i && k > j && size > k)\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool conditionTwo(vector<int>& arr, int i, int j, int k, int a, int b, int c)\\n    {\\n        \\n        if(abs(arr[i] - arr[j]) <= a && abs(arr[j]  -arr[k]) <= b && abs(arr[i] - arr[k]) <= c)\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n        if(arr.size() < 3)\\n        {\\n            return 0;\\n        }\\n        int cnt =0;\\n        \\n        int len = arr.size();\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            for(int j = i + 1; j < arr.size(); j++)\\n            {\\n                for(int k = j + 1; k < arr.size(); k++)\\n                {\\n                    if(conditionOne(len, i, j, k) == true && conditionTwo(arr, i, j, k, a, b, c))\\n\\t\\t\\t\\t\\t//condition one is not necessary at all\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool conditionOne(int size, int i, int j, int k)\\n    {\\n        if(0 <= i && j > i && k > j && size > k)\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool conditionTwo(vector<int>& arr, int i, int j, int k, int a, int b, int c)\\n    {\\n        \\n        if(abs(arr[i] - arr[j]) <= a && abs(arr[j]  -arr[k]) <= b && abs(arr[i] - arr[k]) <= c)\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        \\n        if(arr.size() < 3)\\n        {\\n            return 0;\\n        }\\n        int cnt =0;\\n        \\n        int len = arr.size();\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            for(int j = i + 1; j < arr.size(); j++)\\n            {\\n                for(int k = j + 1; k < arr.size(); k++)\\n                {\\n                    if(conditionOne(len, i, j, k) == true && conditionTwo(arr, i, j, k, a, b, c))\\n\\t\\t\\t\\t\\t//condition one is not necessary at all\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671428,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int len = arr.length;\\n        int goodTripletsCount =0;\\n        \\n        for(int i=0; i<len-2; i++){\\n            for(int j =i+1;j<len-1; j++){\\n                for(int k=j+1; k<len; k++){\\n                    if(Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                      goodTripletsCount+=1;  \\n                    }\\n                }\\n            }\\n        }\\n        return goodTripletsCount;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int len = arr.length;\\n        int goodTripletsCount =0;\\n        \\n        for(int i=0; i<len-2; i++){\\n            for(int j =i+1;j<len-1; j++){\\n                for(int k=j+1; k<len; k++){\\n                    if(Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                      goodTripletsCount+=1;  \\n                    }\\n                }\\n            }\\n        }\\n        return goodTripletsCount;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615795,
                "title": "java-so-many-loops-still-0ms",
                "content": "Never did I thought that this would have best time complexity:\\n```Java\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n\\tint valid = 0;\\n\\tfor(int i=0;i<(arr.length-2);i++){\\n\\t\\tfor(int j=i+1;j<(arr.length-1);j++){\\n\\t\\t\\tif(Math.abs(arr[i]-arr[j])<=a) {\\n\\t\\t\\t\\tfor(int k=j+1;k<arr.length;k++){\\n\\t\\t\\t\\t\\tif(Math.abs(arr[j]-arr[k])<=b){\\n\\t\\t\\t\\t\\t\\tif(Math.abs(arr[i]-arr[k])<=c){\\n\\t\\t\\t\\t\\t\\t\\tvalid++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn valid;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n\\tint valid = 0;\\n\\tfor(int i=0;i<(arr.length-2);i++){\\n\\t\\tfor(int j=i+1;j<(arr.length-1);j++){\\n\\t\\t\\tif(Math.abs(arr[i]-arr[j])<=a) {\\n\\t\\t\\t\\tfor(int k=j+1;k<arr.length;k++){\\n\\t\\t\\t\\t\\tif(Math.abs(arr[j]-arr[k])<=b){\\n\\t\\t\\t\\t\\t\\tif(Math.abs(arr[i]-arr[k])<=c){\\n\\t\\t\\t\\t\\t\\t\\tvalid++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn valid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604519,
                "title": "python-o-3",
                "content": "```py\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count=0\\n        n=len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                for k in range(j+1,n):\\n                    if abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c:\\n                        count+=1\\n        return count",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        count=0\\n        n=len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                for k in range(j+1,n):\\n                    if abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c:\\n                        count+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1553900,
                "title": "mental-process-for-solving-this-problem",
                "content": "Usually the way I try to create scalable solutions is dividing the problem into some sub-problem that solve some part of the bigger problem. This allow to solve the problem in one pass (or maybe two passes) giving as a result a linear function.\\n\\nIn this occasion we have to create the triplets. and once every triplet is created is when we can check if it complies with the rule.\\n\\nso I need a loop to get element i in the triplet, other loop nested in the first loop to get the element j (this loop should start from element 1 because j must always be greater than i), and another nested loop to get the element k.\\n\\nWith those three loops we will form every possible triplet ang getting the answer will be easy. \\n\\n```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        ans = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):\\n                for k in range(j+1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c: ans += 1\\n        return ans\\n```\\n\\nI think there is a possible optimization for this,I will look for it, by now I will let it here.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        ans = 0\\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):\\n                for k in range(j+1, len(arr)):\\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c: ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549948,
                "title": "python-two-line",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        from itertools import combinations as cb\\n        return len([ i for i in list(cb(arr,3)) if abs(i[0]-i[1]) <= a and abs(i[1]-i[2])<=b and abs(i[0]-i[2])<=c ])\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        from itertools import combinations as cb\\n        return len([ i for i in list(cb(arr,3)) if abs(i[0]-i[1]) <= a and abs(i[1]-i[2])<=b and abs(i[0]-i[2])<=c ])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540048,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int arr_size = arr.size(), output = 0;\\n\\n        for (int i = 0; i < arr_size - 2; i++)\\n            for(int j = i+1; j < arr_size - 1; j++)\\n                for(int k = j+1; k < arr_size; k++)\\n                    if(abs(arr[i] - arr[j]) <= a && abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c)\\n                        output++;\\n        \\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int arr_size = arr.size(), output = 0;\\n\\n        for (int i = 0; i < arr_size - 2; i++)\\n            for(int j = i+1; j < arr_size - 1; j++)\\n                for(int k = j+1; k < arr_size; k++)\\n                    if(abs(arr[i] - arr[j]) <= a && abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c)\\n                        output++;\\n        \\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498507,
                "title": "basic-7-line-java-solution-easy-beginner",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    if( Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    if( Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453222,
                "title": "python-not-sure-if-it-is-o-n-2",
                "content": "```\\ndef countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        n = len(arr)\\n        dictHelper = {\\'a\\': set(), \\'b\\': set(), \\'c\\': set()}\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if abs(arr[i]-arr[j]) <= a:\\n                    dictHelper[\\'a\\'].add((i,j))\\n                if abs(arr[i]-arr[j]) <= b:\\n                    dictHelper[\\'b\\'].add((i,j))\\n                if abs(arr[i]-arr[j]) <= c:\\n                    dictHelper[\\'c\\'].add((i,j))\\n        res = 0\\n        for ai in dictHelper[\\'a\\']:\\n            for k in range(ai[1]+1, n):\\n                if (ai[1], k) in dictHelper[\\'b\\'] and(ai[0], k) in dictHelper[\\'c\\']:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        n = len(arr)\\n        dictHelper = {\\'a\\': set(), \\'b\\': set(), \\'c\\': set()}\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if abs(arr[i]-arr[j]) <= a:\\n                    dictHelper[\\'a\\'].add((i,j))\\n                if abs(arr[i]-arr[j]) <= b:\\n                    dictHelper[\\'b\\'].add((i,j))\\n                if abs(arr[i]-arr[j]) <= c:\\n                    dictHelper[\\'c\\'].add((i,j))\\n        res = 0\\n        for ai in dictHelper[\\'a\\']:\\n            for k in range(ai[1]+1, n):\\n                if (ai[1], k) in dictHelper[\\'b\\'] and(ai[0], k) in dictHelper[\\'c\\']:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1447543,
                "title": "c-easy-understandable-solution",
                "content": "**Please upvote if it helped you !!!**\\n```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) \\n    {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                if(abs(arr[i]-arr[j])<=a)\\n                {\\n                    for(int k=j+1;k<arr.size();k++)\\n                    {\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nint countGoodTriplets(vector<int>& arr, int a, int b, int c) \\n    {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                if(abs(arr[i]-arr[j])<=a)\\n                {\\n                    for(int k=j+1;k<arr.size();k++)\\n                    {\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446446,
                "title": "java-easy-no-brainer",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int ccount = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            int tmp1 = arr[i];\\n            for(int j = 0; j < arr.length; j++){\\n                int tmp2 = arr[j];\\n                for(int k = 0; k < arr.length; k++){\\n                    int tmp3 = arr[k];\\n                    ccount = (i < j)&&(j<k)&&Math.abs(tmp1-tmp2)<=a&&Math.abs(tmp2-tmp3)<=b&&Math.abs(tmp1-tmp3)<=c ? ccount+1 : ccount;\\n                }\\n            }\\n        }\\n        return ccount;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int ccount = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            int tmp1 = arr[i];\\n            for(int j = 0; j < arr.length; j++){\\n                int tmp2 = arr[j];\\n                for(int k = 0; k < arr.length; k++){\\n                    int tmp3 = arr[k];\\n                    ccount = (i < j)&&(j<k)&&Math.abs(tmp1-tmp2)<=a&&Math.abs(tmp2-tmp3)<=b&&Math.abs(tmp1-tmp3)<=c ? ccount+1 : ccount;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1378123,
                "title": "swift-easy-brute-force-solution-beats-100-runtime-and-92-memory",
                "content": "```\\nclass Solution {\\n    func countGoodTriplets(_ arr: [Int], _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var count = 0\\n        \\n        for i in arr.indices {\\n            for j in i+1..<arr.count {\\n                if (arr[i] - arr[j]).magnitude <= a {\\n                    for k in j+1..<arr.count {\\n                        if (arr[j] - arr[k]).magnitude <= b {\\n                            if (arr[i] - arr[k]).magnitude <= c {\\n                                count += 1\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countGoodTriplets(_ arr: [Int], _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var count = 0\\n        \\n        for i in arr.indices {\\n            for j in i+1..<arr.count {\\n                if (arr[i] - arr[j]).magnitude <= a {\\n                    for k in j+1..<arr.count {\\n                        if (arr[j] - arr[k]).magnitude <= b {\\n                            if (arr[i] - arr[k]).magnitude <= c {\\n                                count += 1\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366152,
                "title": "swift-variant-of-solution",
                "content": "*<- Please vote if my solution was helpful to you.*\\n*  Runtime: 136 ms, faster than 86.11%.\\n* Memory Usage: 14.1 MB, less than 44.44%\\n\\n```\\nclass Solution {\\n    func countGoodTriplets(_ arr: [Int], _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var counter = 0\\n        for i in 0..<arr.count {\\n            for j in i+1..<arr.count {\\n                let conditionA = abs(arr[i] - arr[j]) <= a\\n                // If conditionA is false we no need calculate other conditions\\n                if conditionA {\\n                    for k in j+1..<arr.count {\\n                        let conditionB = abs(arr[j] - arr[k]) <= b\\n                        let conditionC = abs(arr[i] - arr[k]) <= c\\n                        if conditionA && conditionB && conditionC {\\n                            counter += 1\\n                        }\\n                    }   \\n                }              \\n            }   \\n        }  \\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countGoodTriplets(_ arr: [Int], _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var counter = 0\\n        for i in 0..<arr.count {\\n            for j in i+1..<arr.count {\\n                let conditionA = abs(arr[i] - arr[j]) <= a\\n                // If conditionA is false we no need calculate other conditions\\n                if conditionA {\\n                    for k in j+1..<arr.count {\\n                        let conditionB = abs(arr[j] - arr[k]) <= b\\n                        let conditionC = abs(arr[i] - arr[k]) <= c\\n                        if conditionA && conditionB && conditionC {\\n                            counter += 1\\n                        }\\n                    }   \\n                }              \\n            }   \\n        }  \\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331443,
                "title": "c-easy-to-understand-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                    {\\n                        res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                    {\\n                        res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321001,
                "title": "javascript-easy-solution",
                "content": "var countGoodTriplets = function(arr, a, b, c) {\\n    var count = 0;\\n    for(let i=0; i<arr.length; i++){\\n        for(let j=i+1; j<arr.length; j++){\\n            if(Math.abs(arr[i] - arr[j]) <= a){\\n                for(let k=j+1; k<arr.length; k++){\\n                    if(Math.abs(arr[j] - arr[k]) <= b){\\n                        if(Math.abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};",
                "solutionTags": [],
                "code": "var countGoodTriplets = function(arr, a, b, c) {\\n    var count = 0;\\n    for(let i=0; i<arr.length; i++){\\n        for(let j=i+1; j<arr.length; j++){\\n            if(Math.abs(arr[i] - arr[j]) <= a){\\n                for(let k=j+1; k<arr.length; k++){\\n                    if(Math.abs(arr[j] - arr[k]) <= b){\\n                        if(Math.abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1269370,
                "title": "c-solution-faster-than-97-08-submissions-easy",
                "content": "*If you are using Brute Force approach then try to reduce the number of runs as much as possible. Like in the solution given below, we are entering in the third loop only when the if condition is satisfied.*\\n```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.size()-2;i++){\\n            for(int j=i+1;j<arr.size()-1;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<arr.size();k++){\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c) count++;\\n                    }\\n                }\\n            }   \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0;i<arr.size()-2;i++){\\n            for(int j=i+1;j<arr.size()-1;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<arr.size();k++){\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c) count++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1261117,
                "title": "java-solution-multiple-approach-simple-as-well-as-complex",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k=j+1; k<arr.length; k++){\\n                    if(Math.abs(arr[i]-arr[j]) <=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n//Another approach\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int i = 0;\\n        int j = i + 1,\\n            k = j + 1;\\n        \\n        while(i < arr.length && j < arr.length && k < arr.length){\\n            if(Math.abs(arr[i] - arr[j]) <= a &&\\n               Math.abs(arr[j] - arr[k]) <= b &&\\n               Math.abs(arr[i] - arr[k]) <= c){\\n                count++;\\n            }\\n            if(k < arr.length){\\n                k++;\\n            }\\n            if(k == arr.length){\\n                j++;\\n                k = j + 1;\\n            }\\n            if(j+1 == arr.length){\\n                i++;\\n                j = i + 1;\\n                k = j + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k=j+1; k<arr.length; k++){\\n                    if(Math.abs(arr[i]-arr[j]) <=a && Math.abs(arr[j]-arr[k])<=b && Math.abs(arr[i]-arr[k])<=c){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n//Another approach\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int count = 0;\\n        int i = 0;\\n        int j = i + 1,\\n            k = j + 1;\\n        \\n        while(i < arr.length && j < arr.length && k < arr.length){\\n            if(Math.abs(arr[i] - arr[j]) <= a &&\\n               Math.abs(arr[j] - arr[k]) <= b &&\\n               Math.abs(arr[i] - arr[k]) <= c){\\n                count++;\\n            }\\n            if(k < arr.length){\\n                k++;\\n            }\\n            if(k == arr.length){\\n                j++;\\n                k = j + 1;\\n            }\\n            if(j+1 == arr.length){\\n                i++;\\n                j = i + 1;\\n                k = j + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245581,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt=0;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    int p=arr[i]-arr[j];\\n                    if(abs(p)<=a)\\n                    {\\n                        int o=arr[j] - arr[k];\\n                        if(abs(o)<=b)\\n                        {\\n                            int l=arr[i] - arr[k];\\n                            if(abs(l)<=c)\\n                            {\\n                                cnt++;\\n                            }\\n                            \\n                        }\\n                        \\n                    }\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int cnt=0;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    int p=arr[i]-arr[j];\\n                    if(abs(p)<=a)\\n                    {\\n                        int o=arr[j] - arr[k];\\n                        if(abs(o)<=b)\\n                        {\\n                            int l=arr[i] - arr[k];\\n                            if(abs(l)<=c)\\n                            {\\n                                cnt++;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 1231773,
                "title": "simple-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n         int result = 0;\\n        for(int i = 0; i<arr.size()-2; i++)\\n        {\\n            for(int j = i+1; j<arr.size()-1; j++)\\n            {\\n                if(abs(arr[i]-arr[j])<=a)\\n                    for(int k = j+1; k<arr.size(); k++)\\n                    {\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                            result++;\\n                    }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n         int result = 0;\\n        for(int i = 0; i<arr.size()-2; i++)\\n        {\\n            for(int j = i+1; j<arr.size()-1; j++)\\n            {\\n                if(abs(arr[i]-arr[j])<=a)\\n                    for(int k = j+1; k<arr.size(); k++)\\n                    {\\n                        if(abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                            result++;\\n                    }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220408,
                "title": "python-for-beginners",
                "content": "\\tclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        cant=0\\n        i=0\\n        j=0\\n        k=0\\n        while i<len(arr)-2:\\n            j=i+1\\n            while j<len(arr)-1:\\n                k=j+1\\n                while k<len(arr):\\n                    if (abs(arr[i] - arr[j])<= a) and (abs(arr[j] - arr[k])<= b) and (abs(arr[i] - arr[k])<= c):\\n                        cant=cant+1\\n                    k=k+1\\n                j=j+1\\n            i=i+1\\n        return cant\\n            \\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        cant=0\\n        i=0\\n        j=0\\n        k=0\\n        while i<len(arr)-2:\\n            j=i+1\\n            while j<len(arr)-1:\\n                k=j+1\\n                while k<len(arr):\\n                    if (abs(arr[i] - arr[j])<= a) and (abs(arr[j] - arr[k])<= b) and (abs(arr[i] - arr[k])<= c):\\n                        cant=cant+1\\n                    k=k+1\\n                j=j+1\\n            i=i+1\\n        return cant\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1178109,
                "title": "optimized-c-solution-faster-than-99-20-and-less-than-44-00",
                "content": "![image](https://assets.leetcode.com/users/images/7d660123-40ef-49d8-9f54-1ba3028e1e3a_1619471918.974475.png)\\n\\n\\n```\\npublic class Solution {\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) {\\n        int result = 0, length = arr.Length;\\n        \\n        for(int i = 0; i < length; i++)\\n            for(int j = i + 1; j < length; j++){\\n                if(Math.Abs(arr[i]-arr[j]) > a)\\n                    continue;\\n                for(int k = j + 1; k < length; k++)\\n                    if(Math.Abs(arr[j]-arr[k]) <= b \\n                       && Math.Abs(arr[i]-arr[k]) <= c)\\n                        result++;\\n            }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) {\\n        int result = 0, length = arr.Length;\\n        \\n        for(int i = 0; i < length; i++)\\n            for(int j = i + 1; j < length; j++){\\n                if(Math.Abs(arr[i]-arr[j]) > a)\\n                    continue;\\n                for(int k = j + 1; k < length; k++)\\n                    if(Math.Abs(arr[j]-arr[k]) <= b \\n                       && Math.Abs(arr[i]-arr[k]) <= c)\\n                        result++;\\n            }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175955,
                "title": "java-15ms-simple-to-understand",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int i = 0;\\n        int j = i+1;\\n        int k = j+1;\\n        int answer = 0;\\n        // when arr.length == 3, i should be < 1\\n        // when arr.length == 4, i should be < 2\\n        // when arr.length == 5, i should be < 3\\n        // so we can make \"i < arr.length-2\"          \\n        while(i < arr.length-2){\\n            if(Math.abs(arr[i] - arr[j]) <= a &&\\n              Math.abs(arr[j] - arr[k]) <= b &&\\n              Math.abs(arr[i] - arr[k]) <= c){\\n                answer++;\\n            }\\n            k++;\\n            if(k == arr.length){\\n                j++;\\n                k = j+1;\\n            }\\n            if(j == arr.length-1){\\n                i++;\\n                j = i+1;\\n                k = j+1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int i = 0;\\n        int j = i+1;\\n        int k = j+1;\\n        int answer = 0;\\n        // when arr.length == 3, i should be < 1\\n        // when arr.length == 4, i should be < 2\\n        // when arr.length == 5, i should be < 3\\n        // so we can make \"i < arr.length-2\"          \\n        while(i < arr.length-2){\\n            if(Math.abs(arr[i] - arr[j]) <= a &&\\n              Math.abs(arr[j] - arr[k]) <= b &&\\n              Math.abs(arr[i] - arr[k]) <= c){\\n                answer++;\\n            }\\n            k++;\\n            if(k == arr.length){\\n                j++;\\n                k = j+1;\\n            }\\n            if(j == arr.length-1){\\n                i++;\\n                j = i+1;\\n                k = j+1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159364,
                "title": "ruby-faster-than-100-00-of-ruby-online-submissions-for-count-good-triplets",
                "content": "def count_good_triplets(arr, a, b, c)\\n    res = 0\\n    len = arr.length\\n    for i in 0...len-2\\n        for k in i+1...len\\n            next if ((arr[i] - arr[k]).abs > c)\\n            res += arr[i+1...k].select{|x| (arr[i] - x).abs <= a && (x - arr[k]).abs <= b}.length\\n        end\\n    end\\n    res\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "def count_good_triplets(arr, a, b, c)\\n    res = 0\\n    len = arr.length\\n    for i in 0...len-2\\n        for k in i+1...len\\n            next if ((arr[i] - arr[k]).abs > c)\\n            res += arr[i+1...k].select{|x| (arr[i] - x).abs <= a && (x - arr[k]).abs <= b}.length\\n        end\\n    end\\n    res\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 1158515,
                "title": "javascript-simple-solution",
                "content": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let count = 0\\nfor (let i = 0; i < arr.length; i++) {\\n   for (let j = i+1; j < arr.length; j++) {  \\n       if( Math.abs(arr[i] - arr[j]) <= a ){ \\n           for (let k = j+1; k < arr.length; k++) {\\n                if(Math.abs( arr[j] - arr[k] ) <= b &&  Math.abs( arr[i] - arr[k] ) <= c ){\\n                    // console.log(\\'called\\')\\n                    count ++\\n                }\\n           }\\n       }\\n   } \\n}\\n\\nreturn count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let count = 0\\nfor (let i = 0; i < arr.length; i++) {\\n   for (let j = i+1; j < arr.length; j++) {  \\n       if( Math.abs(arr[i] - arr[j]) <= a ){ \\n           for (let k = j+1; k < arr.length; k++) {\\n                if(Math.abs( arr[j] - arr[k] ) <= b &&  Math.abs( arr[i] - arr[k] ) <= c ){\\n                    // console.log(\\'called\\')\\n                    count ++\\n                }\\n           }\\n       }\\n   } \\n}\\n\\nreturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150992,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int cnt = 0;\\n        int i = 0;\\n        int j = i + 1,\\n            k = j + 1;\\n        \\n        while(i < arr.length && j < arr.length && k < arr.length){\\n            if(Math.abs(arr[i] - arr[j]) <= a &&\\n               Math.abs(arr[j] - arr[k]) <= b &&\\n               Math.abs(arr[i] - arr[k]) <= c){\\n                cnt++;\\n            }\\n            if(k < arr.length){\\n                k++;\\n            }\\n            if(k == arr.length){\\n                j++;\\n                k = j + 1;\\n            }\\n            if(j+1 == arr.length){\\n                i++;\\n                j = i + 1;\\n                k = j + 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int cnt = 0;\\n        int i = 0;\\n        int j = i + 1,\\n            k = j + 1;\\n        \\n        while(i < arr.length && j < arr.length && k < arr.length){\\n            if(Math.abs(arr[i] - arr[j]) <= a &&\\n               Math.abs(arr[j] - arr[k]) <= b &&\\n               Math.abs(arr[i] - arr[k]) <= c){\\n                cnt++;\\n            }\\n            if(k < arr.length){\\n                k++;\\n            }\\n            if(k == arr.length){\\n                j++;\\n                k = j + 1;\\n            }\\n            if(j+1 == arr.length){\\n                i++;\\n                j = i + 1;\\n                k = j + 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121093,
                "title": "javascript-100-speed",
                "content": "```\\nconst countGoodTriplets = (arr, a, b, c) => {\\n    let gt = 0;\\n    const n = arr.length;\\n    for (let i = 0; i < n - 2; i++)\\n        for (let j = i+1; j < n - 1; j++)\\n            for (let k = j+1; k < n; k++)\\n                if (Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c)\\n                    gt++;\\n    return gt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst countGoodTriplets = (arr, a, b, c) => {\\n    let gt = 0;\\n    const n = arr.length;\\n    for (let i = 0; i < n - 2; i++)\\n        for (let j = i+1; j < n - 1; j++)\\n            for (let k = j+1; k < n; k++)\\n                if (Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c)\\n                    gt++;\\n    return gt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115943,
                "title": "javascript-90-faster-solution",
                "content": "Time : Fraction Less than O(n^3)\\n\\n```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let count = 0\\n    for(let i=0;i<arr.length-2;i++){\\n        for(let j=i+1;j<arr.length-1;j++){\\n            if(Math.abs(arr[i]-arr[j]) <= a){\\n                for(let k = j+1;k<arr.length;k++){\\n                    if(Math.abs(arr[j]-arr[k]) <= b && Math.abs(arr[i]-arr[k]) <= c){\\n                        count += 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countGoodTriplets = function(arr, a, b, c) {\\n    let count = 0\\n    for(let i=0;i<arr.length-2;i++){\\n        for(let j=i+1;j<arr.length-1;j++){\\n            if(Math.abs(arr[i]-arr[j]) <= a){\\n                for(let k = j+1;k<arr.length;k++){\\n                    if(Math.abs(arr[j]-arr[k]) <= b && Math.abs(arr[i]-arr[k]) <= c){\\n                        count += 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1100718,
                "title": "python-3-one-liner-bf-beats-99",
                "content": "Just one long list comprehension, using early breakouts for the first pair for efficiency. Spaced out here for readability:\\n\\n```python\\nreturn sum([1 for i, ai in enumerate(arr)\\n\\t\\t\\t\\t\\tfor j, aj in enumerate(arr[i + 1:], i + 1) if -a <= (ai - aj) <= a\\n\\t\\t\\t\\t\\tfor ak in arr[j + 1:]\\n\\t\\t\\t\\t\\tif -b <= (ak - aj) <= b and\\n\\t\\t\\t\\t\\t-c <= (ak - ai) <= c])\\n```\\nEdit: Removed useless if/else",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nreturn sum([1 for i, ai in enumerate(arr)\\n\\t\\t\\t\\t\\tfor j, aj in enumerate(arr[i + 1:], i + 1) if -a <= (ai - aj) <= a\\n\\t\\t\\t\\t\\tfor ak in arr[j + 1:]\\n\\t\\t\\t\\t\\tif -b <= (ak - aj) <= b and\\n\\t\\t\\t\\t\\t-c <= (ak - ai) <= c])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1091915,
                "title": "c-easy-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) \\n    {\\n        int len = arr.Length;\\n        int count = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            for(int j=i+1; j<len; j++)\\n            {\\n                for(int k=j+1; k<len; k++)\\n                {\\n                    if((Math.Abs(arr[i] - arr[j]) <= a) && (Math.Abs(arr[j] - arr[k]) <= b) && (Math.Abs(arr[i] - arr[k]) <= c))\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) \\n    {\\n        int len = arr.Length;\\n        int count = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            for(int j=i+1; j<len; j++)\\n            {\\n                for(int k=j+1; k<len; k++)\\n                {\\n                    if((Math.Abs(arr[i] - arr[j]) <= a) && (Math.Abs(arr[j] - arr[k]) <= b) && (Math.Abs(arr[i] - arr[k]) <= c))\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089243,
                "title": "simple-java-solution-95",
                "content": "It is O(n^3) timecomplexity solution.\\nMy point is location of comparison codes of arr[i] and arr[j] before third for loop.\\nIt is much more faster than located in third for loop.\\n\\n```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int res = 0;        \\n        for(int i=0; i<arr.length-2; i++) {\\n            for(int j=i+1; j<arr.length-1; j++) {\\n                if(Math.abs(arr[i]-arr[j]) > a) continue;\\n                for(int k=j+1; k<arr.length && i!=k; k++) {\\n                    if(Math.abs(arr[j]-arr[k]) > b) continue;\\n                    if(Math.abs(arr[i]-arr[k]) > c) continue;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int res = 0;        \\n        for(int i=0; i<arr.length-2; i++) {\\n            for(int j=i+1; j<arr.length-1; j++) {\\n                if(Math.abs(arr[i]-arr[j]) > a) continue;\\n                for(int k=j+1; k<arr.length && i!=k; k++) {\\n                    if(Math.abs(arr[j]-arr[k]) > b) continue;\\n                    if(Math.abs(arr[i]-arr[k]) > c) continue;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080214,
                "title": "94-python3-solution",
                "content": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr, a = 0, b = 0, c = 0):\\n\\t\\t# | a[i] - a[j] | <=  a\\n\\t\\t# | a[j] - a[k] | <= b\\n\\t\\t# | a[i] - a[k] | <= c\\n\\t\\t\\n        output = 0\\n\\t\\t# store array length so it\\'s not called every iteration\\n        arrLen = len(arr)\\n        \\n        for i in range(arrLen):\\n            ai = arr[i]\\n            for j in range(i + 1, arrLen):\\n                aj = arr[j]\\n\\t\\t\\t\\t# no use in going down another level if this check is false \\n                if abs(ai - aj) > a:\\n                    continue\\n                for k in range(j + 1, arrLen):      \\n                  ak = arr[k]\\n\\t\\t\\t\\t  # no need to check if k < len(arr) or i >= 0, they will never be those values in range()\\n                  if (        \\n                      abs(aj - ak) <= b and\\n                      abs(ai - ak) <= c and\\n                      i < j and\\n                      j < k \\n                  ):\\n                      output += 1\\n                    \\n        return output\\n` ``",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodTriplets(self, arr, a = 0, b = 0, c = 0):\\n\\t\\t# | a[i] - a[j] | <=  a\\n\\t\\t# | a[j] - a[k] | <= b\\n\\t\\t# | a[i] - a[k] | <= c\\n\\t\\t\\n        output = 0\\n\\t\\t# store array length so it\\'s not called every iteration\\n        arrLen = len(arr)\\n        \\n        for i in range(arrLen):\\n            ai = arr[i]\\n            for j in range(i + 1, arrLen):\\n                aj = arr[j]\\n\\t\\t\\t\\t# no use in going down another level if this check is false \\n                if abs(ai - aj) > a:\\n                    continue\\n                for k in range(j + 1, arrLen):      \\n                  ak = arr[k]\\n\\t\\t\\t\\t  # no need to check if k < len(arr) or i >= 0, they will never be those values in range()\\n                  if (        \\n                      abs(aj - ak) <= b and\\n                      abs(ai - ak) <= c and\\n                      i < j and\\n                      j < k \\n                  ):\\n                      output += 1\\n                    \\n        return output\\n` ``",
                "codeTag": "Java"
            },
            {
                "id": 1071300,
                "title": "c-eazy-beats-97-95-of-c-submissions",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n    {\\n        int i, j, k, count = 0;\\n        int n = arr.size();\\n        for (i = 0; i < n - 2; i++)\\n        {\\n            for (j = i + 1; j < n - 1; j++)\\n            {\\n                if (i < j && abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (k = j + 1; k < n; k++)\\n                    {\\n                        if (j < k && abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c)\\n                            count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int countGoodTriplets(vector<int> &arr, int a, int b, int c)\\n    {\\n        int i, j, k, count = 0;\\n        int n = arr.size();\\n        for (i = 0; i < n - 2; i++)\\n        {\\n            for (j = i + 1; j < n - 1; j++)\\n            {\\n                if (i < j && abs(arr[i] - arr[j]) <= a)\\n                {\\n                    for (k = j + 1; k < n; k++)\\n                    {\\n                        if (j < k && abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c)\\n                            count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067987,
                "title": "c-eaxy",
                "content": "```\\nint countGoodTriplets(int* arr, int arrSize, int a, int b, int c){\\n    int i,j,k;\\n    int count=0;\\n    for(i=0; i<arrSize-2;i++)\\n    {\\n         for(j=i+1; j<arrSize-1;j++)\\n         {\\n             for(k=j+1; k<arrSize;k++)\\n             {\\n                 if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                 {\\n                     count++;\\n                 }\\n             }\\n         }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodTriplets(int* arr, int arrSize, int a, int b, int c){\\n    int i,j,k;\\n    int count=0;\\n    for(i=0; i<arrSize-2;i++)\\n    {\\n         for(j=i+1; j<arrSize-1;j++)\\n         {\\n             for(k=j+1; k<arrSize;k++)\\n             {\\n                 if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                 {\\n                     count++;\\n                 }\\n             }\\n         }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057091,
                "title": "fast-c-solution-beats-98-35-of-c-an-improved-brute-force",
                "content": "Intuition:\\nInstead of using Math.abs to compare arr[k] with arr[i] and arr[j], for all couples (i,j) calculate the lower and higher bounds of the domain arr[k] should lie in. Then compare arr[k] without using the resource consuming Math.Abs()\\n\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) {\\n        int result = 0;\\n        int i,j,k;\\n        int mink;\\n        int maxk;\\n        \\n        for(i = 0; i< arr.Length-2; ++i)\\n            for(j = i+1; j+ 1 < arr.Length; ++j)\\n                if (Math.Abs( arr[i]-arr[j]) <= a)\\n                {\\n                    mink = Math.Max(arr[i] - c, arr[j] - b);\\n                    maxk = Math.Min(arr[i] + c, arr[j] + b);\\n                    for(k = j+1; k< arr.Length; ++k)\\n                        if (arr[k] >= mink && arr[k] <= maxk)\\n                            ++result;\\n                }\\n        \\n    return result;\\n    }",
                "solutionTags": [],
                "code": "Intuition:\\nInstead of using Math.abs to compare arr[k] with arr[i] and arr[j], for all couples (i,j) calculate the lower and higher bounds of the domain arr[k] should lie in. Then compare arr[k] without using the resource consuming Math.Abs()\\n\\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) {\\n        int result = 0;\\n        int i,j,k;\\n        int mink;\\n        int maxk;\\n        \\n        for(i = 0; i< arr.Length-2; ++i)\\n            for(j = i+1; j+ 1 < arr.Length; ++j)\\n                if (Math.Abs( arr[i]-arr[j]) <= a)\\n                {\\n                    mink = Math.Max(arr[i] - c, arr[j] - b);\\n                    maxk = Math.Min(arr[i] + c, arr[j] + b);\\n                    for(k = j+1; k< arr.Length; ++k)\\n                        if (arr[k] >= mink && arr[k] <= maxk)\\n                            ++result;\\n                }\\n        \\n    return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1048580,
                "title": "java-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        var count = 0;\\n        for (int i = 0; i < arr.length - 2; i++)\\n            for (int j = i + 1; j < arr.length - 1; j++)\\n                if (Math.abs(arr[i] - arr[j]) <= a)\\n                    for (int k = j + 1; k < arr.length; k++)\\n                        if (Math.abs(arr[j] - arr[k]) <= b\\n                            && Math.abs(arr[i] - arr[k]) <= c) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        var count = 0;\\n        for (int i = 0; i < arr.length - 2; i++)\\n            for (int j = i + 1; j < arr.length - 1; j++)\\n                if (Math.abs(arr[i] - arr[j]) <= a)\\n                    for (int k = j + 1; k < arr.length; k++)\\n                        if (Math.abs(arr[j] - arr[k]) <= b\\n                            && Math.abs(arr[i] - arr[k]) <= c) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020151,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int i;\\n        int j;\\n        int k;\\n        int counter = 0;\\n        \\n        for(i=0; i < arr.length - 2; i++)\\n        {\\n            for(j=i + 1; j < arr.length - 1; j++)\\n            {\\n                for(k = j + 1; k < arr.length; k++)\\n                {\\n                    int temp1 = Math.abs(arr[i] - arr[j]);\\n                    int temp2 = Math.abs(arr[j] - arr[k]);\\n                    int temp3 = Math.abs(arr[i] - arr[k]);\\n                    \\n                    if(temp1 <= a && temp2 <= b && temp3 <= c)\\n                        counter++;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return counter;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int i;\\n        int j;\\n        int k;\\n        int counter = 0;\\n        \\n        for(i=0; i < arr.length - 2; i++)\\n        {\\n            for(j=i + 1; j < arr.length - 1; j++)\\n            {\\n                for(k = j + 1; k < arr.length; k++)\\n                {\\n                    int temp1 = Math.abs(arr[i] - arr[j]);\\n                    int temp2 = Math.abs(arr[j] - arr[k]);\\n                    int temp3 = Math.abs(arr[i] - arr[k]);\\n                    \\n                    if(temp1 <= a && temp2 <= b && temp3 <= c)\\n                        counter++;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1013972,
                "title": "java-99-34-time-brute-force",
                "content": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int res = 0;\\n        for(int i = 0; i < arr.length-2; i++) {\\n            for(int j = i+1 ; j < arr.length-1; j++) {\\n                if(Math.abs(arr[i] - arr[j]) <= a ) {\\n                    for(int k = j+1; k < arr.length; k++) {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c){\\n                            res++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int res = 0;\\n        for(int i = 0; i < arr.length-2; i++) {\\n            for(int j = i+1 ; j < arr.length-1; j++) {\\n                if(Math.abs(arr[i] - arr[j]) <= a ) {\\n                    for(int k = j+1; k < arr.length; k++) {\\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c){\\n                            res++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011981,
                "title": "c-bruteforce-solution-intuitive-solution-o-n-3-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        vector<vector<int>> v;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    vector<int> t;\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                    {\\n                        t.push_back(arr[i]);\\n                        t.push_back(arr[j]);\\n                        t.push_back(arr[k]);\\n                    }\\n                    if(t.size()!=0) v.push_back(t);\\n                }\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        vector<vector<int>> v;\\n        for(int i=0;i<arr.size()-2;i++)\\n        {\\n            for(int j=i+1;j<arr.size()-1;j++)\\n            {\\n                for(int k=j+1;k<arr.size();k++)\\n                {\\n                    vector<int> t;\\n                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c)\\n                    {\\n                        t.push_back(arr[i]);\\n                        t.push_back(arr[j]);\\n                        t.push_back(arr[k]);\\n                    }\\n                    if(t.size()!=0) v.push_back(t);\\n                }\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010524,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def countGoodTriplets(self, arr, a, b, c):\\n        count = 0\\n        for i in range(len(arr)-2):\\n            for j in range(i+1,len(arr)-1):\\n                for k in range(j+1,len(arr)):\\n                    if (abs(arr[i]-arr[j])<=a) and (abs(arr[j]-arr[k])<=b) and (abs(arr[i]-arr[k])<=c):\\n                        count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countGoodTriplets(self, arr, a, b, c):\\n        count = 0\\n        for i in range(len(arr)-2):\\n            for j in range(i+1,len(arr)-1):\\n                for k in range(j+1,len(arr)):\\n                    if (abs(arr[i]-arr[j])<=a) and (abs(arr[j]-arr[k])<=b) and (abs(arr[i]-arr[k])<=c):\\n                        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009646,
                "title": "python-newbie-s-solution-try-to-be-compact",
                "content": "\\tclass Solution(object):\\n\\t\\tdef countGoodTriplets(self, arr, a, b, c):\\n\\t\\t\\tfrom itertools import combinations\\n\\t\\t\\tcomb = list(combinations(arr, 3))\\n\\t\\t\\tcount = 0\\n\\t\\t\\treturn len(list((count for qq in comb if abs(qq[0] - qq[1]) <= a and abs(qq[1] - qq[2]) <= b and abs(qq[0] - qq[2]) <= c)))",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef countGoodTriplets(self, arr, a, b, c):\\n\\t\\t\\tfrom itertools import combinations\\n\\t\\t\\tcomb = list(combinations(arr, 3))\\n\\t\\t\\tcount = 0\\n\\t\\t\\treturn len(list((count for qq in comb if abs(qq[0] - qq[1]) <= a and abs(qq[1] - qq[2]) <= b and abs(qq[0] - qq[2]) <= c)))",
                "codeTag": "Java"
            },
            {
                "id": 990192,
                "title": "rust",
                "content": "```rust\\nfn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n          let mut out = 0; \\n            for i in 0..arr.len() {\\n                for j in (i+1)..arr.len() {\\n                    for k in (j+1)..arr.len(){\\n\\n                        if (arr[i] - arr[j]).abs() <= a &&\\n                            (arr[j] - arr[k]).abs() <= b &&\\n                            (arr[i] - arr[k]).abs() <= c {\\n                            out += 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            out\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nfn count_good_triplets(arr: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {\\n          let mut out = 0; \\n            for i in 0..arr.len() {\\n                for j in (i+1)..arr.len() {\\n                    for k in (j+1)..arr.len(){\\n\\n                        if (arr[i] - arr[j]).abs() <= a &&\\n                            (arr[j] - arr[k]).abs() <= b &&\\n                            (arr[i] - arr[k]).abs() <= c {\\n                            out += 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            out\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981815,
                "title": "java-brute-force-solution",
                "content": "```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n\\tint numGood = 0;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tfor (int j = i+1; j < arr.length; j++) {\\n\\t\\t\\tfor (int k = j+1; k < arr.length; k++) {\\n\\t\\t\\t\\tif (Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b\\n\\t\\t\\t\\t\\t\\t&& Math.abs(arr[i] - arr[k]) <= c){\\n\\t\\t\\t\\t\\tnumGood += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn numGood;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodTriplets(int[] arr, int a, int b, int c) {\\n\\tint numGood = 0;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tfor (int j = i+1; j < arr.length; j++) {\\n\\t\\t\\tfor (int k = j+1; k < arr.length; k++) {\\n\\t\\t\\t\\tif (Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b\\n\\t\\t\\t\\t\\t\\t&& Math.abs(arr[i] - arr[k]) <= c){\\n\\t\\t\\t\\t\\tnumGood += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn numGood;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575638,
                "content": [
                    {
                        "username": "chasemaster",
                        "content": "I assume a soultion less than O(n^3) is not possible?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think a segment tree / fenwick tree can be used for a O(n^2*log(m)) solution.\n\nEg: For each combination of (i, j), we need to find the number of elements with value in a specific range, in the subarray `arr[j + 1:]`.\n\nm is the range of values of `arr`."
                    },
                    {
                        "username": "parthamishra",
                        "content": "I didn\\'t think a o(n^3) solution would be what we\\'re looking for and now I\\'m wiser :)\\n\\nCan someone help me understand why this problem can\\'t be solved under n^3 ? Even a general, thumb-rule to go ahead with such high complexity would also help. I\\'m assuming that the problem had \\'something\\' that helped people believe that this is an n^3 problem indeed.\\n\\nThanks in advance."
                    },
                    {
                        "username": "lavos4life",
                        "content": "Is it possible to use dynamic programming techniques to solve this problem?"
                    },
                    {
                        "username": "cheesebread",
                        "content": "From what I\\'ve understood so far, dp is a strategy if we need if we want to remember the path when we went across so far. But since there\\'s nothing we need to remember in each iteration, I\\'m guessing not."
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "`Tip` after solving this with O(N^3) look below in similar questions\\n3 line up questions are same to same."
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<n;k++){\\n                        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "lukasmaska98",
                        "content": "[@manojkr6637](/manojkr6637) This is not section for solutions!!!!"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Thx you have reduced no of iteration if first condition false"
                    },
                    {
                        "username": "HarshitMestry",
                        "content": "is there an error in output or input im getting the wrong answer even though code is correct"
                    },
                    {
                        "username": "qodain",
                        "content": "You can solve this problem by simply using 3 nested loops to iterate over all possible triplets of the given array and then checking the given conditions for each triplet."
                    }
                ]
            },
            {
                "id": 1568407,
                "content": [
                    {
                        "username": "chasemaster",
                        "content": "I assume a soultion less than O(n^3) is not possible?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think a segment tree / fenwick tree can be used for a O(n^2*log(m)) solution.\n\nEg: For each combination of (i, j), we need to find the number of elements with value in a specific range, in the subarray `arr[j + 1:]`.\n\nm is the range of values of `arr`."
                    },
                    {
                        "username": "parthamishra",
                        "content": "I didn\\'t think a o(n^3) solution would be what we\\'re looking for and now I\\'m wiser :)\\n\\nCan someone help me understand why this problem can\\'t be solved under n^3 ? Even a general, thumb-rule to go ahead with such high complexity would also help. I\\'m assuming that the problem had \\'something\\' that helped people believe that this is an n^3 problem indeed.\\n\\nThanks in advance."
                    },
                    {
                        "username": "lavos4life",
                        "content": "Is it possible to use dynamic programming techniques to solve this problem?"
                    },
                    {
                        "username": "cheesebread",
                        "content": "From what I\\'ve understood so far, dp is a strategy if we need if we want to remember the path when we went across so far. But since there\\'s nothing we need to remember in each iteration, I\\'m guessing not."
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "`Tip` after solving this with O(N^3) look below in similar questions\\n3 line up questions are same to same."
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<n;k++){\\n                        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "lukasmaska98",
                        "content": "[@manojkr6637](/manojkr6637) This is not section for solutions!!!!"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Thx you have reduced no of iteration if first condition false"
                    },
                    {
                        "username": "HarshitMestry",
                        "content": "is there an error in output or input im getting the wrong answer even though code is correct"
                    },
                    {
                        "username": "qodain",
                        "content": "You can solve this problem by simply using 3 nested loops to iterate over all possible triplets of the given array and then checking the given conditions for each triplet."
                    }
                ]
            },
            {
                "id": 1574754,
                "content": [
                    {
                        "username": "chasemaster",
                        "content": "I assume a soultion less than O(n^3) is not possible?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think a segment tree / fenwick tree can be used for a O(n^2*log(m)) solution.\n\nEg: For each combination of (i, j), we need to find the number of elements with value in a specific range, in the subarray `arr[j + 1:]`.\n\nm is the range of values of `arr`."
                    },
                    {
                        "username": "parthamishra",
                        "content": "I didn\\'t think a o(n^3) solution would be what we\\'re looking for and now I\\'m wiser :)\\n\\nCan someone help me understand why this problem can\\'t be solved under n^3 ? Even a general, thumb-rule to go ahead with such high complexity would also help. I\\'m assuming that the problem had \\'something\\' that helped people believe that this is an n^3 problem indeed.\\n\\nThanks in advance."
                    },
                    {
                        "username": "lavos4life",
                        "content": "Is it possible to use dynamic programming techniques to solve this problem?"
                    },
                    {
                        "username": "cheesebread",
                        "content": "From what I\\'ve understood so far, dp is a strategy if we need if we want to remember the path when we went across so far. But since there\\'s nothing we need to remember in each iteration, I\\'m guessing not."
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "`Tip` after solving this with O(N^3) look below in similar questions\\n3 line up questions are same to same."
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<n;k++){\\n                        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "lukasmaska98",
                        "content": "[@manojkr6637](/manojkr6637) This is not section for solutions!!!!"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Thx you have reduced no of iteration if first condition false"
                    },
                    {
                        "username": "HarshitMestry",
                        "content": "is there an error in output or input im getting the wrong answer even though code is correct"
                    },
                    {
                        "username": "qodain",
                        "content": "You can solve this problem by simply using 3 nested loops to iterate over all possible triplets of the given array and then checking the given conditions for each triplet."
                    }
                ]
            },
            {
                "id": 2069260,
                "content": [
                    {
                        "username": "chasemaster",
                        "content": "I assume a soultion less than O(n^3) is not possible?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think a segment tree / fenwick tree can be used for a O(n^2*log(m)) solution.\n\nEg: For each combination of (i, j), we need to find the number of elements with value in a specific range, in the subarray `arr[j + 1:]`.\n\nm is the range of values of `arr`."
                    },
                    {
                        "username": "parthamishra",
                        "content": "I didn\\'t think a o(n^3) solution would be what we\\'re looking for and now I\\'m wiser :)\\n\\nCan someone help me understand why this problem can\\'t be solved under n^3 ? Even a general, thumb-rule to go ahead with such high complexity would also help. I\\'m assuming that the problem had \\'something\\' that helped people believe that this is an n^3 problem indeed.\\n\\nThanks in advance."
                    },
                    {
                        "username": "lavos4life",
                        "content": "Is it possible to use dynamic programming techniques to solve this problem?"
                    },
                    {
                        "username": "cheesebread",
                        "content": "From what I\\'ve understood so far, dp is a strategy if we need if we want to remember the path when we went across so far. But since there\\'s nothing we need to remember in each iteration, I\\'m guessing not."
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "`Tip` after solving this with O(N^3) look below in similar questions\\n3 line up questions are same to same."
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<n;k++){\\n                        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "lukasmaska98",
                        "content": "[@manojkr6637](/manojkr6637) This is not section for solutions!!!!"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Thx you have reduced no of iteration if first condition false"
                    },
                    {
                        "username": "HarshitMestry",
                        "content": "is there an error in output or input im getting the wrong answer even though code is correct"
                    },
                    {
                        "username": "qodain",
                        "content": "You can solve this problem by simply using 3 nested loops to iterate over all possible triplets of the given array and then checking the given conditions for each triplet."
                    }
                ]
            },
            {
                "id": 1833952,
                "content": [
                    {
                        "username": "chasemaster",
                        "content": "I assume a soultion less than O(n^3) is not possible?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think a segment tree / fenwick tree can be used for a O(n^2*log(m)) solution.\n\nEg: For each combination of (i, j), we need to find the number of elements with value in a specific range, in the subarray `arr[j + 1:]`.\n\nm is the range of values of `arr`."
                    },
                    {
                        "username": "parthamishra",
                        "content": "I didn\\'t think a o(n^3) solution would be what we\\'re looking for and now I\\'m wiser :)\\n\\nCan someone help me understand why this problem can\\'t be solved under n^3 ? Even a general, thumb-rule to go ahead with such high complexity would also help. I\\'m assuming that the problem had \\'something\\' that helped people believe that this is an n^3 problem indeed.\\n\\nThanks in advance."
                    },
                    {
                        "username": "lavos4life",
                        "content": "Is it possible to use dynamic programming techniques to solve this problem?"
                    },
                    {
                        "username": "cheesebread",
                        "content": "From what I\\'ve understood so far, dp is a strategy if we need if we want to remember the path when we went across so far. But since there\\'s nothing we need to remember in each iteration, I\\'m guessing not."
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "`Tip` after solving this with O(N^3) look below in similar questions\\n3 line up questions are same to same."
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<n;k++){\\n                        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "lukasmaska98",
                        "content": "[@manojkr6637](/manojkr6637) This is not section for solutions!!!!"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Thx you have reduced no of iteration if first condition false"
                    },
                    {
                        "username": "HarshitMestry",
                        "content": "is there an error in output or input im getting the wrong answer even though code is correct"
                    },
                    {
                        "username": "qodain",
                        "content": "You can solve this problem by simply using 3 nested loops to iterate over all possible triplets of the given array and then checking the given conditions for each triplet."
                    }
                ]
            },
            {
                "id": 1823988,
                "content": [
                    {
                        "username": "chasemaster",
                        "content": "I assume a soultion less than O(n^3) is not possible?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think a segment tree / fenwick tree can be used for a O(n^2*log(m)) solution.\n\nEg: For each combination of (i, j), we need to find the number of elements with value in a specific range, in the subarray `arr[j + 1:]`.\n\nm is the range of values of `arr`."
                    },
                    {
                        "username": "parthamishra",
                        "content": "I didn\\'t think a o(n^3) solution would be what we\\'re looking for and now I\\'m wiser :)\\n\\nCan someone help me understand why this problem can\\'t be solved under n^3 ? Even a general, thumb-rule to go ahead with such high complexity would also help. I\\'m assuming that the problem had \\'something\\' that helped people believe that this is an n^3 problem indeed.\\n\\nThanks in advance."
                    },
                    {
                        "username": "lavos4life",
                        "content": "Is it possible to use dynamic programming techniques to solve this problem?"
                    },
                    {
                        "username": "cheesebread",
                        "content": "From what I\\'ve understood so far, dp is a strategy if we need if we want to remember the path when we went across so far. But since there\\'s nothing we need to remember in each iteration, I\\'m guessing not."
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "`Tip` after solving this with O(N^3) look below in similar questions\\n3 line up questions are same to same."
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<n;k++){\\n                        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "lukasmaska98",
                        "content": "[@manojkr6637](/manojkr6637) This is not section for solutions!!!!"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Thx you have reduced no of iteration if first condition false"
                    },
                    {
                        "username": "HarshitMestry",
                        "content": "is there an error in output or input im getting the wrong answer even though code is correct"
                    },
                    {
                        "username": "qodain",
                        "content": "You can solve this problem by simply using 3 nested loops to iterate over all possible triplets of the given array and then checking the given conditions for each triplet."
                    }
                ]
            },
            {
                "id": 1801461,
                "content": [
                    {
                        "username": "chasemaster",
                        "content": "I assume a soultion less than O(n^3) is not possible?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think a segment tree / fenwick tree can be used for a O(n^2*log(m)) solution.\n\nEg: For each combination of (i, j), we need to find the number of elements with value in a specific range, in the subarray `arr[j + 1:]`.\n\nm is the range of values of `arr`."
                    },
                    {
                        "username": "parthamishra",
                        "content": "I didn\\'t think a o(n^3) solution would be what we\\'re looking for and now I\\'m wiser :)\\n\\nCan someone help me understand why this problem can\\'t be solved under n^3 ? Even a general, thumb-rule to go ahead with such high complexity would also help. I\\'m assuming that the problem had \\'something\\' that helped people believe that this is an n^3 problem indeed.\\n\\nThanks in advance."
                    },
                    {
                        "username": "lavos4life",
                        "content": "Is it possible to use dynamic programming techniques to solve this problem?"
                    },
                    {
                        "username": "cheesebread",
                        "content": "From what I\\'ve understood so far, dp is a strategy if we need if we want to remember the path when we went across so far. But since there\\'s nothing we need to remember in each iteration, I\\'m guessing not."
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "`Tip` after solving this with O(N^3) look below in similar questions\\n3 line up questions are same to same."
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n=arr.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(abs(arr[i]-arr[j])<=a){\\n                    for(int k=j+1;k<n;k++){\\n                        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "lukasmaska98",
                        "content": "[@manojkr6637](/manojkr6637) This is not section for solutions!!!!"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Thx you have reduced no of iteration if first condition false"
                    },
                    {
                        "username": "HarshitMestry",
                        "content": "is there an error in output or input im getting the wrong answer even though code is correct"
                    },
                    {
                        "username": "qodain",
                        "content": "You can solve this problem by simply using 3 nested loops to iterate over all possible triplets of the given array and then checking the given conditions for each triplet."
                    }
                ]
            }
        ]
    }
]